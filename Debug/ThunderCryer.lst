
ThunderCryer.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000330fc  08000188  08000188  00008188  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.extab    00000030  08033284  08033284  0003b284  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          000000e0  080332b4  080332b4  0003b2b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   0000000c  08033394  08033394  0003b394  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  080333a0  080333a0  0003b3a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         000009d0  20000000  080333a8  00040000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00009b78  200009d0  08033d78  000409d0  2**3
                  ALLOC
  8 ._user_heap_stack 00000400  2000a548  08033d78  00042548  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  000409d0  2**0
                  CONTENTS, READONLY
 10 .debug_info   0003b276  00000000  00000000  00040a00  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000a00d  00000000  00000000  0007bc76  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000fd20  00000000  00000000  00085c83  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00000cf8  00000000  00000000  000959a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00020f91  00000000  00000000  000966a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_macinfo 01557625  00000000  00000000  000b7631  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000e83d  00000000  00000000  0160ec56  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      00000070  00000000  00000000  0161d493  2**0
                  CONTENTS, READONLY
 18 .debug_frame  0000a5f4  00000000  00000000  0161d504  2**2
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges 00000340  00000000  00000000  01627af8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	; (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4804      	ldr	r0, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b110      	cbz	r0, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2101      	movs	r1, #1
 800019c:	7021      	strb	r1, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	200009d0 	.word	0x200009d0
 80001a4:	00000000 	.word	0x00000000
 80001a8:	0803326c 	.word	0x0803326c

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b06      	ldr	r3, [pc, #24]	; (80001c8 <frame_dummy+0x1c>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4806      	ldr	r0, [pc, #24]	; (80001cc <frame_dummy+0x20>)
 80001b4:	4906      	ldr	r1, [pc, #24]	; (80001d0 <frame_dummy+0x24>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	4806      	ldr	r0, [pc, #24]	; (80001d4 <frame_dummy+0x28>)
 80001bc:	6801      	ldr	r1, [r0, #0]
 80001be:	b111      	cbz	r1, 80001c6 <frame_dummy+0x1a>
 80001c0:	4b05      	ldr	r3, [pc, #20]	; (80001d8 <frame_dummy+0x2c>)
 80001c2:	b103      	cbz	r3, 80001c6 <frame_dummy+0x1a>
 80001c4:	4798      	blx	r3
 80001c6:	bd08      	pop	{r3, pc}
 80001c8:	00000000 	.word	0x00000000
 80001cc:	0803326c 	.word	0x0803326c
 80001d0:	200009d4 	.word	0x200009d4
 80001d4:	200009d0 	.word	0x200009d0
 80001d8:	00000000 	.word	0x00000000

080001dc <USB_OTG_EnableCommonInt>:
*         Initializes the commmon interrupts, used in both device and modes
* @param  pdev : Selected device
* @retval None
*/
static void USB_OTG_EnableCommonInt(USB_OTG_CORE_HANDLE *pdev)
{
 80001dc:	b480      	push	{r7}
 80001de:	b085      	sub	sp, #20
 80001e0:	af00      	add	r7, sp, #0
 80001e2:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTMSK_TypeDef  int_mask;
  
  int_mask.d32 = 0;
 80001e4:	f04f 0300 	mov.w	r3, #0
 80001e8:	60fb      	str	r3, [r7, #12]
  /* Clear any pending USB_OTG Interrupts */
#ifndef USE_OTG_MODE
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 80001ea:	687b      	ldr	r3, [r7, #4]
 80001ec:	68db      	ldr	r3, [r3, #12]
 80001ee:	f04f 32ff 	mov.w	r2, #4294967295
 80001f2:	605a      	str	r2, [r3, #4]
#endif
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 80001f4:	687b      	ldr	r3, [r7, #4]
 80001f6:	68db      	ldr	r3, [r3, #12]
 80001f8:	f04f 32ff 	mov.w	r2, #4294967295
 80001fc:	615a      	str	r2, [r3, #20]
  /* Enable the interrupts in the INTMSK */
  int_mask.b.wkupintr = 1;
 80001fe:	68fb      	ldr	r3, [r7, #12]
 8000200:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000204:	60fb      	str	r3, [r7, #12]
  int_mask.b.usbsuspend = 1; 
 8000206:	68fb      	ldr	r3, [r7, #12]
 8000208:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800020c:	60fb      	str	r3, [r7, #12]
#ifdef USE_OTG_MODE
  int_mask.b.otgintr = 1;
  int_mask.b.sessreqintr = 1;
  int_mask.b.conidstschng = 1;
#endif
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 800020e:	687b      	ldr	r3, [r7, #4]
 8000210:	68db      	ldr	r3, [r3, #12]
 8000212:	68fa      	ldr	r2, [r7, #12]
 8000214:	619a      	str	r2, [r3, #24]
}
 8000216:	f107 0714 	add.w	r7, r7, #20
 800021a:	46bd      	mov	sp, r7
 800021c:	bc80      	pop	{r7}
 800021e:	4770      	bx	lr

08000220 <USB_OTG_CoreReset>:
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
{
 8000220:	b580      	push	{r7, lr}
 8000222:	b086      	sub	sp, #24
 8000224:	af00      	add	r7, sp, #0
 8000226:	6078      	str	r0, [r7, #4]
  USB_OTG_STS status = USB_OTG_OK;
 8000228:	f04f 0300 	mov.w	r3, #0
 800022c:	74fb      	strb	r3, [r7, #19]
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
 800022e:	f04f 0300 	mov.w	r3, #0
 8000232:	617b      	str	r3, [r7, #20]
  
  greset.d32 = 0;
 8000234:	f04f 0300 	mov.w	r3, #0
 8000238:	60fb      	str	r3, [r7, #12]
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 800023a:	f04f 0003 	mov.w	r0, #3
 800023e:	f01c fc47 	bl	801cad0 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8000242:	687b      	ldr	r3, [r7, #4]
 8000244:	68db      	ldr	r3, [r3, #12]
 8000246:	691b      	ldr	r3, [r3, #16]
 8000248:	60fb      	str	r3, [r7, #12]
    if (++count > 200000)
 800024a:	697b      	ldr	r3, [r7, #20]
 800024c:	f103 0301 	add.w	r3, r3, #1
 8000250:	617b      	str	r3, [r7, #20]
 8000252:	697a      	ldr	r2, [r7, #20]
 8000254:	f44f 6354 	mov.w	r3, #3392	; 0xd40
 8000258:	f2c0 0303 	movt	r3, #3
 800025c:	429a      	cmp	r2, r3
 800025e:	d902      	bls.n	8000266 <USB_OTG_CoreReset+0x46>
    {
      return USB_OTG_OK;
 8000260:	f04f 0300 	mov.w	r3, #0
 8000264:	e02a      	b.n	80002bc <USB_OTG_CoreReset+0x9c>
    }
  }
  while (greset.b.ahbidle == 0);
 8000266:	68fb      	ldr	r3, [r7, #12]
 8000268:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 800026c:	2b00      	cmp	r3, #0
 800026e:	d0e4      	beq.n	800023a <USB_OTG_CoreReset+0x1a>
  /* Core Soft Reset */
  count = 0;
 8000270:	f04f 0300 	mov.w	r3, #0
 8000274:	617b      	str	r3, [r7, #20]
  greset.b.csftrst = 1;
 8000276:	68fb      	ldr	r3, [r7, #12]
 8000278:	f043 0301 	orr.w	r3, r3, #1
 800027c:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 800027e:	687b      	ldr	r3, [r7, #4]
 8000280:	68db      	ldr	r3, [r3, #12]
 8000282:	68fa      	ldr	r2, [r7, #12]
 8000284:	611a      	str	r2, [r3, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8000286:	687b      	ldr	r3, [r7, #4]
 8000288:	68db      	ldr	r3, [r3, #12]
 800028a:	691b      	ldr	r3, [r3, #16]
 800028c:	60fb      	str	r3, [r7, #12]
    if (++count > 200000)
 800028e:	697b      	ldr	r3, [r7, #20]
 8000290:	f103 0301 	add.w	r3, r3, #1
 8000294:	617b      	str	r3, [r7, #20]
 8000296:	697a      	ldr	r2, [r7, #20]
 8000298:	f44f 6354 	mov.w	r3, #3392	; 0xd40
 800029c:	f2c0 0303 	movt	r3, #3
 80002a0:	429a      	cmp	r2, r3
 80002a2:	d805      	bhi.n	80002b0 <USB_OTG_CoreReset+0x90>
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 80002a4:	68fb      	ldr	r3, [r7, #12]
 80002a6:	f003 0301 	and.w	r3, r3, #1
 80002aa:	2b00      	cmp	r3, #0
 80002ac:	d1eb      	bne.n	8000286 <USB_OTG_CoreReset+0x66>
 80002ae:	e000      	b.n	80002b2 <USB_OTG_CoreReset+0x92>
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
    if (++count > 200000)
    {
      break;
 80002b0:	bf00      	nop
    }
  }
  while (greset.b.csftrst == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 80002b2:	f04f 0003 	mov.w	r0, #3
 80002b6:	f01c fc0b 	bl	801cad0 <USB_OTG_BSP_uDelay>
  return status;
 80002ba:	7cfb      	ldrb	r3, [r7, #19]
}
 80002bc:	4618      	mov	r0, r3
 80002be:	f107 0718 	add.w	r7, r7, #24
 80002c2:	46bd      	mov	sp, r7
 80002c4:	bd80      	pop	{r7, pc}
 80002c6:	bf00      	nop

080002c8 <USB_OTG_WritePacket>:
*/
USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
 80002c8:	b480      	push	{r7}
 80002ca:	b089      	sub	sp, #36	; 0x24
 80002cc:	af00      	add	r7, sp, #0
 80002ce:	60f8      	str	r0, [r7, #12]
 80002d0:	60b9      	str	r1, [r7, #8]
 80002d2:	71fa      	strb	r2, [r7, #7]
 80002d4:	80bb      	strh	r3, [r7, #4]
  USB_OTG_STS status = USB_OTG_OK;
 80002d6:	f04f 0300 	mov.w	r3, #0
 80002da:	76fb      	strb	r3, [r7, #27]
  if (pdev->cfg.dma_enable == 0)
 80002dc:	68fb      	ldr	r3, [r7, #12]
 80002de:	78db      	ldrb	r3, [r3, #3]
 80002e0:	2b00      	cmp	r3, #0
 80002e2:	d12c      	bne.n	800033e <USB_OTG_WritePacket+0x76>
  {
    uint32_t count32b= 0 , i= 0;
 80002e4:	f04f 0300 	mov.w	r3, #0
 80002e8:	617b      	str	r3, [r7, #20]
 80002ea:	f04f 0300 	mov.w	r3, #0
 80002ee:	61fb      	str	r3, [r7, #28]
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 80002f0:	88bb      	ldrh	r3, [r7, #4]
 80002f2:	f103 0303 	add.w	r3, r3, #3
 80002f6:	2b00      	cmp	r3, #0
 80002f8:	da01      	bge.n	80002fe <USB_OTG_WritePacket+0x36>
 80002fa:	f103 0303 	add.w	r3, r3, #3
 80002fe:	ea4f 03a3 	mov.w	r3, r3, asr #2
 8000302:	617b      	str	r3, [r7, #20]
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8000304:	79fb      	ldrb	r3, [r7, #7]
 8000306:	68fa      	ldr	r2, [r7, #12]
 8000308:	f103 0332 	add.w	r3, r3, #50	; 0x32
 800030c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000310:	18d3      	adds	r3, r2, r3
 8000312:	689b      	ldr	r3, [r3, #8]
 8000314:	613b      	str	r3, [r7, #16]
    for (i = 0; i < count32b; i++, src+=4)
 8000316:	f04f 0300 	mov.w	r3, #0
 800031a:	61fb      	str	r3, [r7, #28]
 800031c:	e00b      	b.n	8000336 <USB_OTG_WritePacket+0x6e>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 800031e:	68bb      	ldr	r3, [r7, #8]
 8000320:	681a      	ldr	r2, [r3, #0]
 8000322:	693b      	ldr	r3, [r7, #16]
 8000324:	601a      	str	r2, [r3, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8000326:	69fb      	ldr	r3, [r7, #28]
 8000328:	f103 0301 	add.w	r3, r3, #1
 800032c:	61fb      	str	r3, [r7, #28]
 800032e:	68bb      	ldr	r3, [r7, #8]
 8000330:	f103 0304 	add.w	r3, r3, #4
 8000334:	60bb      	str	r3, [r7, #8]
 8000336:	69fa      	ldr	r2, [r7, #28]
 8000338:	697b      	ldr	r3, [r7, #20]
 800033a:	429a      	cmp	r2, r3
 800033c:	d3ef      	bcc.n	800031e <USB_OTG_WritePacket+0x56>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
    }
  }
  return status;
 800033e:	7efb      	ldrb	r3, [r7, #27]
}
 8000340:	4618      	mov	r0, r3
 8000342:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8000346:	46bd      	mov	sp, r7
 8000348:	bc80      	pop	{r7}
 800034a:	4770      	bx	lr

0800034c <USB_OTG_ReadPacket>:
* @retval None
*/
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
 800034c:	b480      	push	{r7}
 800034e:	b089      	sub	sp, #36	; 0x24
 8000350:	af00      	add	r7, sp, #0
 8000352:	60f8      	str	r0, [r7, #12]
 8000354:	60b9      	str	r1, [r7, #8]
 8000356:	4613      	mov	r3, r2
 8000358:	80fb      	strh	r3, [r7, #6]
  uint32_t i=0;
 800035a:	f04f 0300 	mov.w	r3, #0
 800035e:	61fb      	str	r3, [r7, #28]
  uint32_t count32b = (len + 3) / 4;
 8000360:	88fb      	ldrh	r3, [r7, #6]
 8000362:	f103 0303 	add.w	r3, r3, #3
 8000366:	2b00      	cmp	r3, #0
 8000368:	da01      	bge.n	800036e <USB_OTG_ReadPacket+0x22>
 800036a:	f103 0303 	add.w	r3, r3, #3
 800036e:	ea4f 03a3 	mov.w	r3, r3, asr #2
 8000372:	61bb      	str	r3, [r7, #24]
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
 8000374:	68fb      	ldr	r3, [r7, #12]
 8000376:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 800037a:	617b      	str	r3, [r7, #20]
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 800037c:	f04f 0300 	mov.w	r3, #0
 8000380:	61fb      	str	r3, [r7, #28]
 8000382:	e00b      	b.n	800039c <USB_OTG_ReadPacket+0x50>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8000384:	697b      	ldr	r3, [r7, #20]
 8000386:	681a      	ldr	r2, [r3, #0]
 8000388:	68bb      	ldr	r3, [r7, #8]
 800038a:	601a      	str	r2, [r3, #0]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 800038c:	69fb      	ldr	r3, [r7, #28]
 800038e:	f103 0301 	add.w	r3, r3, #1
 8000392:	61fb      	str	r3, [r7, #28]
 8000394:	68bb      	ldr	r3, [r7, #8]
 8000396:	f103 0304 	add.w	r3, r3, #4
 800039a:	60bb      	str	r3, [r7, #8]
 800039c:	69fa      	ldr	r2, [r7, #28]
 800039e:	69bb      	ldr	r3, [r7, #24]
 80003a0:	429a      	cmp	r2, r3
 80003a2:	d3ef      	bcc.n	8000384 <USB_OTG_ReadPacket+0x38>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
    
  }
  return ((void *)dest);
 80003a4:	68bb      	ldr	r3, [r7, #8]
}
 80003a6:	4618      	mov	r0, r3
 80003a8:	f107 0724 	add.w	r7, r7, #36	; 0x24
 80003ac:	46bd      	mov	sp, r7
 80003ae:	bc80      	pop	{r7}
 80003b0:	4770      	bx	lr
 80003b2:	bf00      	nop

080003b4 <USB_OTG_SelectCore>:
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
 80003b4:	b480      	push	{r7}
 80003b6:	b087      	sub	sp, #28
 80003b8:	af00      	add	r7, sp, #0
 80003ba:	6078      	str	r0, [r7, #4]
 80003bc:	460b      	mov	r3, r1
 80003be:	70fb      	strb	r3, [r7, #3]
  uint32_t i , baseAddress = 0;
 80003c0:	f04f 0300 	mov.w	r3, #0
 80003c4:	613b      	str	r3, [r7, #16]
  USB_OTG_STS status = USB_OTG_OK;
 80003c6:	f04f 0300 	mov.w	r3, #0
 80003ca:	73fb      	strb	r3, [r7, #15]
  
  pdev->cfg.dma_enable       = 0;
 80003cc:	687b      	ldr	r3, [r7, #4]
 80003ce:	f04f 0200 	mov.w	r2, #0
 80003d2:	70da      	strb	r2, [r3, #3]
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 80003d4:	687b      	ldr	r3, [r7, #4]
 80003d6:	f04f 0201 	mov.w	r2, #1
 80003da:	709a      	strb	r2, [r3, #2]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 80003dc:	687b      	ldr	r3, [r7, #4]
 80003de:	f04f 0240 	mov.w	r2, #64	; 0x40
 80003e2:	809a      	strh	r2, [r3, #4]
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 80003e4:	78fb      	ldrb	r3, [r7, #3]
 80003e6:	2b01      	cmp	r3, #1
 80003e8:	d117      	bne.n	800041a <USB_OTG_SelectCore+0x66>
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
 80003ea:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 80003ee:	613b      	str	r3, [r7, #16]
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 80003f0:	687b      	ldr	r3, [r7, #4]
 80003f2:	f04f 0201 	mov.w	r2, #1
 80003f6:	72da      	strb	r2, [r3, #11]
    pdev->cfg.host_channels    = 8 ;
 80003f8:	687b      	ldr	r3, [r7, #4]
 80003fa:	f04f 0208 	mov.w	r2, #8
 80003fe:	701a      	strb	r2, [r3, #0]
    pdev->cfg.dev_endpoints    = 4 ;
 8000400:	687b      	ldr	r3, [r7, #4]
 8000402:	f04f 0204 	mov.w	r2, #4
 8000406:	705a      	strb	r2, [r3, #1]
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8000408:	687b      	ldr	r3, [r7, #4]
 800040a:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800040e:	80da      	strh	r2, [r3, #6]
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8000410:	687b      	ldr	r3, [r7, #4]
 8000412:	f04f 0202 	mov.w	r2, #2
 8000416:	721a      	strb	r2, [r3, #8]
 8000418:	e01f      	b.n	800045a <USB_OTG_SelectCore+0xa6>
    
#ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
 800041a:	78fb      	ldrb	r3, [r7, #3]
 800041c:	2b00      	cmp	r3, #0
 800041e:	d11c      	bne.n	800045a <USB_OTG_SelectCore+0xa6>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
 8000420:	f04f 0300 	mov.w	r3, #0
 8000424:	f2c4 0304 	movt	r3, #16388	; 0x4004
 8000428:	613b      	str	r3, [r7, #16]
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
 800042a:	687b      	ldr	r3, [r7, #4]
 800042c:	f04f 0200 	mov.w	r2, #0
 8000430:	72da      	strb	r2, [r3, #11]
    pdev->cfg.host_channels    = 12 ;
 8000432:	687b      	ldr	r3, [r7, #4]
 8000434:	f04f 020c 	mov.w	r2, #12
 8000438:	701a      	strb	r2, [r3, #0]
    pdev->cfg.dev_endpoints    = 6 ;
 800043a:	687b      	ldr	r3, [r7, #4]
 800043c:	f04f 0206 	mov.w	r2, #6
 8000440:	705a      	strb	r2, [r3, #1]
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8000442:	687b      	ldr	r3, [r7, #4]
 8000444:	f44f 62a0 	mov.w	r2, #1280	; 0x500
 8000448:	80da      	strh	r2, [r3, #6]
    
#ifdef USB_OTG_ULPI_PHY_ENABLED
    pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
#else    
 #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
 800044a:	687b      	ldr	r3, [r7, #4]
 800044c:	f04f 0202 	mov.w	r2, #2
 8000450:	721a      	strb	r2, [r3, #8]
   #endif
 #endif  
#endif      
    
#ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
    pdev->cfg.dma_enable       = 1;    
 8000452:	687b      	ldr	r3, [r7, #4]
 8000454:	f04f 0201 	mov.w	r2, #1
 8000458:	70da      	strb	r2, [r3, #3]
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 800045a:	693a      	ldr	r2, [r7, #16]
 800045c:	687b      	ldr	r3, [r7, #4]
 800045e:	60da      	str	r2, [r3, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8000460:	693b      	ldr	r3, [r7, #16]
 8000462:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8000466:	461a      	mov	r2, r3
 8000468:	687b      	ldr	r3, [r7, #4]
 800046a:	611a      	str	r2, [r3, #16]
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 800046c:	f04f 0300 	mov.w	r3, #0
 8000470:	617b      	str	r3, [r7, #20]
 8000472:	e023      	b.n	80004bc <USB_OTG_SelectCore+0x108>
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
 8000474:	697b      	ldr	r3, [r7, #20]
 8000476:	ea4f 1243 	mov.w	r2, r3, lsl #5
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 800047a:	693b      	ldr	r3, [r7, #16]
 800047c:	18d3      	adds	r3, r2, r3
 800047e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8000482:	461a      	mov	r2, r3
 8000484:	6879      	ldr	r1, [r7, #4]
 8000486:	697b      	ldr	r3, [r7, #20]
 8000488:	f103 0304 	add.w	r3, r3, #4
 800048c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000490:	18cb      	adds	r3, r1, r3
 8000492:	609a      	str	r2, [r3, #8]
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
 8000494:	697b      	ldr	r3, [r7, #20]
 8000496:	ea4f 1243 	mov.w	r2, r3, lsl #5
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 800049a:	693b      	ldr	r3, [r7, #16]
 800049c:	18d3      	adds	r3, r2, r3
 800049e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 80004a2:	461a      	mov	r2, r3
 80004a4:	6879      	ldr	r1, [r7, #4]
 80004a6:	697b      	ldr	r3, [r7, #20]
 80004a8:	f103 0314 	add.w	r3, r3, #20
 80004ac:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80004b0:	18cb      	adds	r3, r1, r3
 80004b2:	605a      	str	r2, [r3, #4]
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 80004b4:	697b      	ldr	r3, [r7, #20]
 80004b6:	f103 0301 	add.w	r3, r3, #1
 80004ba:	617b      	str	r3, [r7, #20]
 80004bc:	687b      	ldr	r3, [r7, #4]
 80004be:	785b      	ldrb	r3, [r3, #1]
 80004c0:	461a      	mov	r2, r3
 80004c2:	697b      	ldr	r3, [r7, #20]
 80004c4:	429a      	cmp	r2, r3
 80004c6:	d8d5      	bhi.n	8000474 <USB_OTG_SelectCore+0xc0>
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
 80004c8:	693b      	ldr	r3, [r7, #16]
 80004ca:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80004ce:	461a      	mov	r2, r3
 80004d0:	687b      	ldr	r3, [r7, #4]
 80004d2:	615a      	str	r2, [r3, #20]
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
 80004d4:	693b      	ldr	r3, [r7, #16]
 80004d6:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 80004da:	461a      	mov	r2, r3
 80004dc:	687b      	ldr	r3, [r7, #4]
 80004de:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80004e2:	f04f 0300 	mov.w	r3, #0
 80004e6:	617b      	str	r3, [r7, #20]
 80004e8:	e013      	b.n	8000512 <USB_OTG_SelectCore+0x15e>
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
 80004ea:	697b      	ldr	r3, [r7, #20]
 80004ec:	ea4f 1243 	mov.w	r2, r3, lsl #5
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 80004f0:	693b      	ldr	r3, [r7, #16]
 80004f2:	18d3      	adds	r3, r2, r3
 80004f4:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 80004f8:	461a      	mov	r2, r3
 80004fa:	6879      	ldr	r1, [r7, #4]
 80004fc:	697b      	ldr	r3, [r7, #20]
 80004fe:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8000502:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000506:	18cb      	adds	r3, r1, r3
 8000508:	609a      	str	r2, [r3, #8]
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 800050a:	697b      	ldr	r3, [r7, #20]
 800050c:	f103 0301 	add.w	r3, r3, #1
 8000510:	617b      	str	r3, [r7, #20]
 8000512:	687b      	ldr	r3, [r7, #4]
 8000514:	781b      	ldrb	r3, [r3, #0]
 8000516:	461a      	mov	r2, r3
 8000518:	697b      	ldr	r3, [r7, #20]
 800051a:	429a      	cmp	r2, r3
 800051c:	d8e5      	bhi.n	80004ea <USB_OTG_SelectCore+0x136>
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 800051e:	f04f 0300 	mov.w	r3, #0
 8000522:	617b      	str	r3, [r7, #20]
 8000524:	e013      	b.n	800054e <USB_OTG_SelectCore+0x19a>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
      (i * USB_OTG_DATA_FIFO_SIZE));
 8000526:	697b      	ldr	r3, [r7, #20]
 8000528:	ea4f 3203 	mov.w	r2, r3, lsl #12
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 800052c:	693b      	ldr	r3, [r7, #16]
 800052e:	18d3      	adds	r3, r2, r3
 8000530:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8000534:	461a      	mov	r2, r3
 8000536:	6879      	ldr	r1, [r7, #4]
 8000538:	697b      	ldr	r3, [r7, #20]
 800053a:	f103 0332 	add.w	r3, r3, #50	; 0x32
 800053e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000542:	18cb      	adds	r3, r1, r3
 8000544:	609a      	str	r2, [r3, #8]
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8000546:	697b      	ldr	r3, [r7, #20]
 8000548:	f103 0301 	add.w	r3, r3, #1
 800054c:	617b      	str	r3, [r7, #20]
 800054e:	687b      	ldr	r3, [r7, #4]
 8000550:	781b      	ldrb	r3, [r3, #0]
 8000552:	461a      	mov	r2, r3
 8000554:	697b      	ldr	r3, [r7, #20]
 8000556:	429a      	cmp	r2, r3
 8000558:	d8e5      	bhi.n	8000526 <USB_OTG_SelectCore+0x172>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
      (i * USB_OTG_DATA_FIFO_SIZE));
  }
  pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
 800055a:	693b      	ldr	r3, [r7, #16]
 800055c:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 8000560:	461a      	mov	r2, r3
 8000562:	687b      	ldr	r3, [r7, #4]
 8000564:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  
  return status;
 8000568:	7bfb      	ldrb	r3, [r7, #15]
}
 800056a:	4618      	mov	r0, r3
 800056c:	f107 071c 	add.w	r7, r7, #28
 8000570:	46bd      	mov	sp, r7
 8000572:	bc80      	pop	{r7}
 8000574:	4770      	bx	lr
 8000576:	bf00      	nop

08000578 <USB_OTG_CoreInit>:
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8000578:	b580      	push	{r7, lr}
 800057a:	b088      	sub	sp, #32
 800057c:	af00      	add	r7, sp, #0
 800057e:	6078      	str	r0, [r7, #4]
  USB_OTG_STS status = USB_OTG_OK;
 8000580:	f04f 0300 	mov.w	r3, #0
 8000584:	77fb      	strb	r3, [r7, #31]
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  USB_OTG_GCCFG_TypeDef    gccfg;
  USB_OTG_GI2CCTL_TypeDef  i2cctl;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  usbcfg.d32 = 0;
 8000586:	f04f 0300 	mov.w	r3, #0
 800058a:	61bb      	str	r3, [r7, #24]
  gccfg.d32 = 0;
 800058c:	f04f 0300 	mov.w	r3, #0
 8000590:	617b      	str	r3, [r7, #20]
  ahbcfg.d32 = 0;
 8000592:	f04f 0300 	mov.w	r3, #0
 8000596:	60fb      	str	r3, [r7, #12]
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8000598:	687b      	ldr	r3, [r7, #4]
 800059a:	7a1b      	ldrb	r3, [r3, #8]
 800059c:	2b01      	cmp	r3, #1
 800059e:	d155      	bne.n	800064c <USB_OTG_CoreInit+0xd4>
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 80005a0:	687b      	ldr	r3, [r7, #4]
 80005a2:	68db      	ldr	r3, [r3, #12]
 80005a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80005a6:	617b      	str	r3, [r7, #20]
    gccfg.b.pwdn = 0;
 80005a8:	697b      	ldr	r3, [r7, #20]
 80005aa:	f36f 4310 	bfc	r3, #16, #1
 80005ae:	617b      	str	r3, [r7, #20]
    
    if (pdev->cfg.Sof_output)
 80005b0:	687b      	ldr	r3, [r7, #4]
 80005b2:	7a5b      	ldrb	r3, [r3, #9]
 80005b4:	2b00      	cmp	r3, #0
 80005b6:	d003      	beq.n	80005c0 <USB_OTG_CoreInit+0x48>
    {
      gccfg.b.sofouten = 1;   
 80005b8:	697b      	ldr	r3, [r7, #20]
 80005ba:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80005be:	617b      	str	r3, [r7, #20]
    }
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 80005c0:	687b      	ldr	r3, [r7, #4]
 80005c2:	68db      	ldr	r3, [r3, #12]
 80005c4:	697a      	ldr	r2, [r7, #20]
 80005c6:	639a      	str	r2, [r3, #56]	; 0x38
    
    /* Init The ULPI Interface */
    usbcfg.d32 = 0;
 80005c8:	f04f 0300 	mov.w	r3, #0
 80005cc:	61bb      	str	r3, [r7, #24]
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 80005ce:	687b      	ldr	r3, [r7, #4]
 80005d0:	68db      	ldr	r3, [r3, #12]
 80005d2:	68db      	ldr	r3, [r3, #12]
 80005d4:	61bb      	str	r3, [r7, #24]
    
    usbcfg.b.physel            = 0; /* HS Interface */
 80005d6:	69bb      	ldr	r3, [r7, #24]
 80005d8:	f36f 1386 	bfc	r3, #6, #1
 80005dc:	61bb      	str	r3, [r7, #24]
#ifdef USB_OTG_INTERNAL_VBUS_ENABLED
    usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
#else
 #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
 80005de:	69bb      	ldr	r3, [r7, #24]
 80005e0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80005e4:	61bb      	str	r3, [r7, #24]
 #endif
#endif 
    usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
 80005e6:	69bb      	ldr	r3, [r7, #24]
 80005e8:	f36f 5396 	bfc	r3, #22, #1
 80005ec:	61bb      	str	r3, [r7, #24]
    usbcfg.b.ulpi_utmi_sel     = 1; /* ULPI seleInterfacect */
 80005ee:	69bb      	ldr	r3, [r7, #24]
 80005f0:	f043 0310 	orr.w	r3, r3, #16
 80005f4:	61bb      	str	r3, [r7, #24]
    
    usbcfg.b.phyif             = 0; /* 8 bits */
 80005f6:	69bb      	ldr	r3, [r7, #24]
 80005f8:	f36f 03c3 	bfc	r3, #3, #1
 80005fc:	61bb      	str	r3, [r7, #24]
    usbcfg.b.ddrsel            = 0; /* single data rate */
 80005fe:	69bb      	ldr	r3, [r7, #24]
 8000600:	f36f 13c7 	bfc	r3, #7, #1
 8000604:	61bb      	str	r3, [r7, #24]
    
    usbcfg.b.ulpi_fsls = 0;
 8000606:	69bb      	ldr	r3, [r7, #24]
 8000608:	f36f 4351 	bfc	r3, #17, #1
 800060c:	61bb      	str	r3, [r7, #24]
    usbcfg.b.ulpi_clk_sus_m = 0;
 800060e:	69bb      	ldr	r3, [r7, #24]
 8000610:	f36f 43d3 	bfc	r3, #19, #1
 8000614:	61bb      	str	r3, [r7, #24]
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8000616:	687b      	ldr	r3, [r7, #4]
 8000618:	68db      	ldr	r3, [r3, #12]
 800061a:	69ba      	ldr	r2, [r7, #24]
 800061c:	60da      	str	r2, [r3, #12]
    
    /* Reset after a PHY select  */
    USB_OTG_CoreReset(pdev);
 800061e:	6878      	ldr	r0, [r7, #4]
 8000620:	f7ff fdfe 	bl	8000220 <USB_OTG_CoreReset>
    
    if(pdev->cfg.dma_enable == 1)
 8000624:	687b      	ldr	r3, [r7, #4]
 8000626:	78db      	ldrb	r3, [r3, #3]
 8000628:	2b01      	cmp	r3, #1
 800062a:	f040 8089 	bne.w	8000740 <USB_OTG_CoreInit+0x1c8>
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 800062e:	68fb      	ldr	r3, [r7, #12]
 8000630:	f04f 0205 	mov.w	r2, #5
 8000634:	f362 0344 	bfi	r3, r2, #1, #4
 8000638:	60fb      	str	r3, [r7, #12]
      ahbcfg.b.dmaenable = 1;
 800063a:	68fb      	ldr	r3, [r7, #12]
 800063c:	f043 0320 	orr.w	r3, r3, #32
 8000640:	60fb      	str	r3, [r7, #12]
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8000642:	687b      	ldr	r3, [r7, #4]
 8000644:	68db      	ldr	r3, [r3, #12]
 8000646:	68fa      	ldr	r2, [r7, #12]
 8000648:	609a      	str	r2, [r3, #8]
 800064a:	e079      	b.n	8000740 <USB_OTG_CoreInit+0x1c8>
    }    
  }
  else /* FS interface (embedded Phy or I2C Phy) */
  {
    
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 800064c:	687b      	ldr	r3, [r7, #4]
 800064e:	68db      	ldr	r3, [r3, #12]
 8000650:	68db      	ldr	r3, [r3, #12]
 8000652:	61bb      	str	r3, [r7, #24]
    usbcfg.b.physel  = 1; /* FS Interface */
 8000654:	69bb      	ldr	r3, [r7, #24]
 8000656:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800065a:	61bb      	str	r3, [r7, #24]
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 800065c:	687b      	ldr	r3, [r7, #4]
 800065e:	68db      	ldr	r3, [r3, #12]
 8000660:	69ba      	ldr	r2, [r7, #24]
 8000662:	60da      	str	r2, [r3, #12]
    /* Reset after a PHY select and set Host mode */
    USB_OTG_CoreReset(pdev);
 8000664:	6878      	ldr	r0, [r7, #4]
 8000666:	f7ff fddb 	bl	8000220 <USB_OTG_CoreReset>
    /* Enable the I2C interface and deactivate the power down*/
    gccfg.d32 = 0;
 800066a:	f04f 0300 	mov.w	r3, #0
 800066e:	617b      	str	r3, [r7, #20]
    gccfg.b.pwdn = 1;
 8000670:	697b      	ldr	r3, [r7, #20]
 8000672:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000676:	617b      	str	r3, [r7, #20]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 8000678:	687b      	ldr	r3, [r7, #4]
 800067a:	7a1b      	ldrb	r3, [r3, #8]
 800067c:	2b03      	cmp	r3, #3
 800067e:	d103      	bne.n	8000688 <USB_OTG_CoreInit+0x110>
    {
      gccfg.b.i2cifen = 1;
 8000680:	697b      	ldr	r3, [r7, #20]
 8000682:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000686:	617b      	str	r3, [r7, #20]
    }   
    gccfg.b.vbussensingA = 1 ;
 8000688:	697b      	ldr	r3, [r7, #20]
 800068a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800068e:	617b      	str	r3, [r7, #20]
    gccfg.b.vbussensingB = 1 ;     
 8000690:	697b      	ldr	r3, [r7, #20]
 8000692:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8000696:	617b      	str	r3, [r7, #20]
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
 8000698:	697b      	ldr	r3, [r7, #20]
 800069a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800069e:	617b      	str	r3, [r7, #20]
#endif    
    
    if(pdev->cfg.Sof_output)
 80006a0:	687b      	ldr	r3, [r7, #4]
 80006a2:	7a5b      	ldrb	r3, [r3, #9]
 80006a4:	2b00      	cmp	r3, #0
 80006a6:	d003      	beq.n	80006b0 <USB_OTG_CoreInit+0x138>
    {
      gccfg.b.sofouten = 1;  
 80006a8:	697b      	ldr	r3, [r7, #20]
 80006aa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80006ae:	617b      	str	r3, [r7, #20]
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 80006b0:	687b      	ldr	r3, [r7, #4]
 80006b2:	68db      	ldr	r3, [r3, #12]
 80006b4:	697a      	ldr	r2, [r7, #20]
 80006b6:	639a      	str	r2, [r3, #56]	; 0x38
    USB_OTG_BSP_mDelay(20);
 80006b8:	f04f 0014 	mov.w	r0, #20
 80006bc:	f01c fa34 	bl	801cb28 <USB_OTG_BSP_mDelay>
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 80006c0:	687b      	ldr	r3, [r7, #4]
 80006c2:	68db      	ldr	r3, [r3, #12]
 80006c4:	68db      	ldr	r3, [r3, #12]
 80006c6:	61bb      	str	r3, [r7, #24]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 80006c8:	687b      	ldr	r3, [r7, #4]
 80006ca:	7a1b      	ldrb	r3, [r3, #8]
 80006cc:	2b03      	cmp	r3, #3
 80006ce:	d103      	bne.n	80006d8 <USB_OTG_CoreInit+0x160>
    {
      usbcfg.b.otgutmifssel = 1;
 80006d0:	69bb      	ldr	r3, [r7, #24]
 80006d2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80006d6:	61bb      	str	r3, [r7, #24]
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 80006d8:	687b      	ldr	r3, [r7, #4]
 80006da:	68db      	ldr	r3, [r3, #12]
 80006dc:	69ba      	ldr	r2, [r7, #24]
 80006de:	60da      	str	r2, [r3, #12]
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 80006e0:	687b      	ldr	r3, [r7, #4]
 80006e2:	7a1b      	ldrb	r3, [r3, #8]
 80006e4:	2b03      	cmp	r3, #3
 80006e6:	d12b      	bne.n	8000740 <USB_OTG_CoreInit+0x1c8>
    {
      /*Program GI2CCTL.I2CEn*/
      i2cctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GI2CCTL);
 80006e8:	687b      	ldr	r3, [r7, #4]
 80006ea:	68db      	ldr	r3, [r3, #12]
 80006ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80006ee:	613b      	str	r3, [r7, #16]
      i2cctl.b.i2cdevaddr = 1;
 80006f0:	693b      	ldr	r3, [r7, #16]
 80006f2:	f04f 0201 	mov.w	r2, #1
 80006f6:	f362 639b 	bfi	r3, r2, #26, #2
 80006fa:	613b      	str	r3, [r7, #16]
      i2cctl.b.i2cen = 0;
 80006fc:	693b      	ldr	r3, [r7, #16]
 80006fe:	f36f 53d7 	bfc	r3, #23, #1
 8000702:	613b      	str	r3, [r7, #16]
      i2cctl.b.dat_se0 = 1;
 8000704:	693b      	ldr	r3, [r7, #16]
 8000706:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800070a:	613b      	str	r3, [r7, #16]
      i2cctl.b.addr = 0x2D;
 800070c:	693b      	ldr	r3, [r7, #16]
 800070e:	f04f 022d 	mov.w	r2, #45	; 0x2d
 8000712:	f362 4316 	bfi	r3, r2, #16, #7
 8000716:	613b      	str	r3, [r7, #16]
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8000718:	687b      	ldr	r3, [r7, #4]
 800071a:	68db      	ldr	r3, [r3, #12]
 800071c:	693a      	ldr	r2, [r7, #16]
 800071e:	631a      	str	r2, [r3, #48]	; 0x30
      
      USB_OTG_BSP_mDelay(200);
 8000720:	f04f 00c8 	mov.w	r0, #200	; 0xc8
 8000724:	f01c fa00 	bl	801cb28 <USB_OTG_BSP_mDelay>
      
      i2cctl.b.i2cen = 1;
 8000728:	693b      	ldr	r3, [r7, #16]
 800072a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800072e:	613b      	str	r3, [r7, #16]
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 8000730:	687b      	ldr	r3, [r7, #4]
 8000732:	68db      	ldr	r3, [r3, #12]
 8000734:	693a      	ldr	r2, [r7, #16]
 8000736:	631a      	str	r2, [r3, #48]	; 0x30
      USB_OTG_BSP_mDelay(200);
 8000738:	f04f 00c8 	mov.w	r0, #200	; 0xc8
 800073c:	f01c f9f4 	bl	801cb28 <USB_OTG_BSP_mDelay>
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 8000740:	687b      	ldr	r3, [r7, #4]
 8000742:	78db      	ldrb	r3, [r3, #3]
 8000744:	2b01      	cmp	r3, #1
 8000746:	d111      	bne.n	800076c <USB_OTG_CoreInit+0x1f4>
  {
    
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 8000748:	687b      	ldr	r3, [r7, #4]
 800074a:	68db      	ldr	r3, [r3, #12]
 800074c:	689b      	ldr	r3, [r3, #8]
 800074e:	60fb      	str	r3, [r7, #12]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8000750:	68fb      	ldr	r3, [r7, #12]
 8000752:	f04f 0205 	mov.w	r2, #5
 8000756:	f362 0344 	bfi	r3, r2, #1, #4
 800075a:	60fb      	str	r3, [r7, #12]
    ahbcfg.b.dmaenable = 1;
 800075c:	68fb      	ldr	r3, [r7, #12]
 800075e:	f043 0320 	orr.w	r3, r3, #32
 8000762:	60fb      	str	r3, [r7, #12]
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8000764:	687b      	ldr	r3, [r7, #4]
 8000766:	68db      	ldr	r3, [r3, #12]
 8000768:	68fa      	ldr	r2, [r7, #12]
 800076a:	609a      	str	r2, [r3, #8]
  usbcfg.b.hnpcap = 1;
  usbcfg.b.srpcap = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_EnableCommonInt(pdev);
#endif
  return status;
 800076c:	7ffb      	ldrb	r3, [r7, #31]
}
 800076e:	4618      	mov	r0, r3
 8000770:	f107 0720 	add.w	r7, r7, #32
 8000774:	46bd      	mov	sp, r7
 8000776:	bd80      	pop	{r7, pc}

08000778 <USB_OTG_EnableGlobalInt>:
*         Enables the controller's Global Int in the AHB Config reg
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
{
 8000778:	b480      	push	{r7}
 800077a:	b085      	sub	sp, #20
 800077c:	af00      	add	r7, sp, #0
 800077e:	6078      	str	r0, [r7, #4]
  USB_OTG_STS status = USB_OTG_OK;
 8000780:	f04f 0300 	mov.w	r3, #0
 8000784:	73fb      	strb	r3, [r7, #15]
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
 8000786:	f04f 0300 	mov.w	r3, #0
 800078a:	60bb      	str	r3, [r7, #8]
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
 800078c:	68bb      	ldr	r3, [r7, #8]
 800078e:	f043 0301 	orr.w	r3, r3, #1
 8000792:	60bb      	str	r3, [r7, #8]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 8000794:	687b      	ldr	r3, [r7, #4]
 8000796:	68db      	ldr	r3, [r3, #12]
 8000798:	687a      	ldr	r2, [r7, #4]
 800079a:	68d2      	ldr	r2, [r2, #12]
 800079c:	6892      	ldr	r2, [r2, #8]
 800079e:	4611      	mov	r1, r2
 80007a0:	68ba      	ldr	r2, [r7, #8]
 80007a2:	430a      	orrs	r2, r1
 80007a4:	609a      	str	r2, [r3, #8]
  return status;
 80007a6:	7bfb      	ldrb	r3, [r7, #15]
}
 80007a8:	4618      	mov	r0, r3
 80007aa:	f107 0714 	add.w	r7, r7, #20
 80007ae:	46bd      	mov	sp, r7
 80007b0:	bc80      	pop	{r7}
 80007b2:	4770      	bx	lr

080007b4 <USB_OTG_DisableGlobalInt>:
*         Enables the controller's Global Int in the AHB Config reg
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
{
 80007b4:	b480      	push	{r7}
 80007b6:	b085      	sub	sp, #20
 80007b8:	af00      	add	r7, sp, #0
 80007ba:	6078      	str	r0, [r7, #4]
  USB_OTG_STS status = USB_OTG_OK;
 80007bc:	f04f 0300 	mov.w	r3, #0
 80007c0:	73fb      	strb	r3, [r7, #15]
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
 80007c2:	f04f 0300 	mov.w	r3, #0
 80007c6:	60bb      	str	r3, [r7, #8]
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
 80007c8:	68bb      	ldr	r3, [r7, #8]
 80007ca:	f043 0301 	orr.w	r3, r3, #1
 80007ce:	60bb      	str	r3, [r7, #8]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 80007d0:	687b      	ldr	r3, [r7, #4]
 80007d2:	68db      	ldr	r3, [r3, #12]
 80007d4:	687a      	ldr	r2, [r7, #4]
 80007d6:	68d2      	ldr	r2, [r2, #12]
 80007d8:	6892      	ldr	r2, [r2, #8]
 80007da:	4611      	mov	r1, r2
 80007dc:	68ba      	ldr	r2, [r7, #8]
 80007de:	ea6f 0202 	mvn.w	r2, r2
 80007e2:	400a      	ands	r2, r1
 80007e4:	609a      	str	r2, [r3, #8]
  return status;
 80007e6:	7bfb      	ldrb	r3, [r7, #15]
}
 80007e8:	4618      	mov	r0, r3
 80007ea:	f107 0714 	add.w	r7, r7, #20
 80007ee:	46bd      	mov	sp, r7
 80007f0:	bc80      	pop	{r7}
 80007f2:	4770      	bx	lr

080007f4 <USB_OTG_FlushTxFifo>:
* @param  pdev : Selected device
* @param  num : FO num
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
{
 80007f4:	b580      	push	{r7, lr}
 80007f6:	b086      	sub	sp, #24
 80007f8:	af00      	add	r7, sp, #0
 80007fa:	6078      	str	r0, [r7, #4]
 80007fc:	6039      	str	r1, [r7, #0]
  USB_OTG_STS status = USB_OTG_OK;
 80007fe:	f04f 0300 	mov.w	r3, #0
 8000802:	74fb      	strb	r3, [r7, #19]
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
 8000804:	f04f 0300 	mov.w	r3, #0
 8000808:	617b      	str	r3, [r7, #20]
  greset.d32 = 0;
 800080a:	f04f 0300 	mov.w	r3, #0
 800080e:	60fb      	str	r3, [r7, #12]
  greset.b.txfflsh = 1;
 8000810:	68fb      	ldr	r3, [r7, #12]
 8000812:	f043 0320 	orr.w	r3, r3, #32
 8000816:	60fb      	str	r3, [r7, #12]
  greset.b.txfnum  = num;
 8000818:	683b      	ldr	r3, [r7, #0]
 800081a:	b2db      	uxtb	r3, r3
 800081c:	f003 031f 	and.w	r3, r3, #31
 8000820:	b2da      	uxtb	r2, r3
 8000822:	68fb      	ldr	r3, [r7, #12]
 8000824:	f362 138a 	bfi	r3, r2, #6, #5
 8000828:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 800082a:	687b      	ldr	r3, [r7, #4]
 800082c:	68db      	ldr	r3, [r3, #12]
 800082e:	68fa      	ldr	r2, [r7, #12]
 8000830:	611a      	str	r2, [r3, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8000832:	687b      	ldr	r3, [r7, #4]
 8000834:	68db      	ldr	r3, [r3, #12]
 8000836:	691b      	ldr	r3, [r3, #16]
 8000838:	60fb      	str	r3, [r7, #12]
    if (++count > 200000)
 800083a:	697b      	ldr	r3, [r7, #20]
 800083c:	f103 0301 	add.w	r3, r3, #1
 8000840:	617b      	str	r3, [r7, #20]
 8000842:	697a      	ldr	r2, [r7, #20]
 8000844:	f44f 6354 	mov.w	r3, #3392	; 0xd40
 8000848:	f2c0 0303 	movt	r3, #3
 800084c:	429a      	cmp	r2, r3
 800084e:	d805      	bhi.n	800085c <USB_OTG_FlushTxFifo+0x68>
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 8000850:	68fb      	ldr	r3, [r7, #12]
 8000852:	f003 0320 	and.w	r3, r3, #32
 8000856:	2b00      	cmp	r3, #0
 8000858:	d1eb      	bne.n	8000832 <USB_OTG_FlushTxFifo+0x3e>
 800085a:	e000      	b.n	800085e <USB_OTG_FlushTxFifo+0x6a>
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
    if (++count > 200000)
    {
      break;
 800085c:	bf00      	nop
    }
  }
  while (greset.b.txfflsh == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 800085e:	f04f 0003 	mov.w	r0, #3
 8000862:	f01c f935 	bl	801cad0 <USB_OTG_BSP_uDelay>
  return status;
 8000866:	7cfb      	ldrb	r3, [r7, #19]
}
 8000868:	4618      	mov	r0, r3
 800086a:	f107 0718 	add.w	r7, r7, #24
 800086e:	46bd      	mov	sp, r7
 8000870:	bd80      	pop	{r7, pc}
 8000872:	bf00      	nop

08000874 <USB_OTG_FlushRxFifo>:
* @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
{
 8000874:	b580      	push	{r7, lr}
 8000876:	b086      	sub	sp, #24
 8000878:	af00      	add	r7, sp, #0
 800087a:	6078      	str	r0, [r7, #4]
  USB_OTG_STS status = USB_OTG_OK;
 800087c:	f04f 0300 	mov.w	r3, #0
 8000880:	74fb      	strb	r3, [r7, #19]
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
 8000882:	f04f 0300 	mov.w	r3, #0
 8000886:	617b      	str	r3, [r7, #20]
  
  greset.d32 = 0;
 8000888:	f04f 0300 	mov.w	r3, #0
 800088c:	60fb      	str	r3, [r7, #12]
  greset.b.rxfflsh = 1;
 800088e:	68fb      	ldr	r3, [r7, #12]
 8000890:	f043 0310 	orr.w	r3, r3, #16
 8000894:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8000896:	687b      	ldr	r3, [r7, #4]
 8000898:	68db      	ldr	r3, [r3, #12]
 800089a:	68fa      	ldr	r2, [r7, #12]
 800089c:	611a      	str	r2, [r3, #16]
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 800089e:	687b      	ldr	r3, [r7, #4]
 80008a0:	68db      	ldr	r3, [r3, #12]
 80008a2:	691b      	ldr	r3, [r3, #16]
 80008a4:	60fb      	str	r3, [r7, #12]
    if (++count > 200000)
 80008a6:	697b      	ldr	r3, [r7, #20]
 80008a8:	f103 0301 	add.w	r3, r3, #1
 80008ac:	617b      	str	r3, [r7, #20]
 80008ae:	697a      	ldr	r2, [r7, #20]
 80008b0:	f44f 6354 	mov.w	r3, #3392	; 0xd40
 80008b4:	f2c0 0303 	movt	r3, #3
 80008b8:	429a      	cmp	r2, r3
 80008ba:	d805      	bhi.n	80008c8 <USB_OTG_FlushRxFifo+0x54>
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 80008bc:	68fb      	ldr	r3, [r7, #12]
 80008be:	f003 0310 	and.w	r3, r3, #16
 80008c2:	2b00      	cmp	r3, #0
 80008c4:	d1eb      	bne.n	800089e <USB_OTG_FlushRxFifo+0x2a>
 80008c6:	e000      	b.n	80008ca <USB_OTG_FlushRxFifo+0x56>
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
    if (++count > 200000)
    {
      break;
 80008c8:	bf00      	nop
    }
  }
  while (greset.b.rxfflsh == 1);
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 80008ca:	f04f 0003 	mov.w	r0, #3
 80008ce:	f01c f8ff 	bl	801cad0 <USB_OTG_BSP_uDelay>
  return status;
 80008d2:	7cfb      	ldrb	r3, [r7, #19]
}
 80008d4:	4618      	mov	r0, r3
 80008d6:	f107 0718 	add.w	r7, r7, #24
 80008da:	46bd      	mov	sp, r7
 80008dc:	bd80      	pop	{r7, pc}
 80008de:	bf00      	nop

080008e0 <USB_OTG_SetCurrentMode>:
* @param  pdev : Selected device
* @param  mode :  (Host/device)
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
 80008e0:	b580      	push	{r7, lr}
 80008e2:	b084      	sub	sp, #16
 80008e4:	af00      	add	r7, sp, #0
 80008e6:	6078      	str	r0, [r7, #4]
 80008e8:	460b      	mov	r3, r1
 80008ea:	70fb      	strb	r3, [r7, #3]
  USB_OTG_STS status = USB_OTG_OK;
 80008ec:	f04f 0300 	mov.w	r3, #0
 80008f0:	73fb      	strb	r3, [r7, #15]
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 80008f2:	687b      	ldr	r3, [r7, #4]
 80008f4:	68db      	ldr	r3, [r3, #12]
 80008f6:	68db      	ldr	r3, [r3, #12]
 80008f8:	60bb      	str	r3, [r7, #8]
  
  usbcfg.b.force_host = 0;
 80008fa:	68bb      	ldr	r3, [r7, #8]
 80008fc:	f36f 735d 	bfc	r3, #29, #1
 8000900:	60bb      	str	r3, [r7, #8]
  usbcfg.b.force_dev = 0;
 8000902:	68bb      	ldr	r3, [r7, #8]
 8000904:	f36f 739e 	bfc	r3, #30, #1
 8000908:	60bb      	str	r3, [r7, #8]
  
  if ( mode == HOST_MODE)
 800090a:	78fb      	ldrb	r3, [r7, #3]
 800090c:	2b01      	cmp	r3, #1
 800090e:	d104      	bne.n	800091a <USB_OTG_SetCurrentMode+0x3a>
  {
    usbcfg.b.force_host = 1;
 8000910:	68bb      	ldr	r3, [r7, #8]
 8000912:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8000916:	60bb      	str	r3, [r7, #8]
 8000918:	e006      	b.n	8000928 <USB_OTG_SetCurrentMode+0x48>
  }
  else if ( mode == DEVICE_MODE)
 800091a:	78fb      	ldrb	r3, [r7, #3]
 800091c:	2b00      	cmp	r3, #0
 800091e:	d103      	bne.n	8000928 <USB_OTG_SetCurrentMode+0x48>
  {
    usbcfg.b.force_dev = 1;
 8000920:	68bb      	ldr	r3, [r7, #8]
 8000922:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000926:	60bb      	str	r3, [r7, #8]
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8000928:	687b      	ldr	r3, [r7, #4]
 800092a:	68db      	ldr	r3, [r3, #12]
 800092c:	68ba      	ldr	r2, [r7, #8]
 800092e:	60da      	str	r2, [r3, #12]
  USB_OTG_BSP_mDelay(50);
 8000930:	f04f 0032 	mov.w	r0, #50	; 0x32
 8000934:	f01c f8f8 	bl	801cb28 <USB_OTG_BSP_mDelay>
  return status;
 8000938:	7bfb      	ldrb	r3, [r7, #15]
}
 800093a:	4618      	mov	r0, r3
 800093c:	f107 0710 	add.w	r7, r7, #16
 8000940:	46bd      	mov	sp, r7
 8000942:	bd80      	pop	{r7, pc}

08000944 <USB_OTG_GetMode>:
* @brief  USB_OTG_GetMode : Get current mode
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
 8000944:	b480      	push	{r7}
 8000946:	b083      	sub	sp, #12
 8000948:	af00      	add	r7, sp, #0
 800094a:	6078      	str	r0, [r7, #4]
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 800094c:	687b      	ldr	r3, [r7, #4]
 800094e:	68db      	ldr	r3, [r3, #12]
 8000950:	695b      	ldr	r3, [r3, #20]
 8000952:	f003 0301 	and.w	r3, r3, #1
}
 8000956:	4618      	mov	r0, r3
 8000958:	f107 070c 	add.w	r7, r7, #12
 800095c:	46bd      	mov	sp, r7
 800095e:	bc80      	pop	{r7}
 8000960:	4770      	bx	lr
 8000962:	bf00      	nop

08000964 <USB_OTG_IsDeviceMode>:
* @brief  USB_OTG_IsDeviceMode : Check if it is device mode
* @param  pdev : Selected device
* @retval num_in_ep
*/
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
 8000964:	b580      	push	{r7, lr}
 8000966:	b082      	sub	sp, #8
 8000968:	af00      	add	r7, sp, #0
 800096a:	6078      	str	r0, [r7, #4]
  return (USB_OTG_GetMode(pdev) != HOST_MODE);
 800096c:	6878      	ldr	r0, [r7, #4]
 800096e:	f7ff ffe9 	bl	8000944 <USB_OTG_GetMode>
 8000972:	4603      	mov	r3, r0
 8000974:	2b01      	cmp	r3, #1
 8000976:	bf0c      	ite	eq
 8000978:	2300      	moveq	r3, #0
 800097a:	2301      	movne	r3, #1
 800097c:	b2db      	uxtb	r3, r3
}
 800097e:	4618      	mov	r0, r3
 8000980:	f107 0708 	add.w	r7, r7, #8
 8000984:	46bd      	mov	sp, r7
 8000986:	bd80      	pop	{r7, pc}

08000988 <USB_OTG_IsHostMode>:
* @brief  USB_OTG_IsHostMode : Check if it is host mode
* @param  pdev : Selected device
* @retval num_in_ep
*/
uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
{
 8000988:	b580      	push	{r7, lr}
 800098a:	b082      	sub	sp, #8
 800098c:	af00      	add	r7, sp, #0
 800098e:	6078      	str	r0, [r7, #4]
  return (USB_OTG_GetMode(pdev) == HOST_MODE);
 8000990:	6878      	ldr	r0, [r7, #4]
 8000992:	f7ff ffd7 	bl	8000944 <USB_OTG_GetMode>
 8000996:	4603      	mov	r3, r0
 8000998:	2b01      	cmp	r3, #1
 800099a:	bf14      	ite	ne
 800099c:	2300      	movne	r3, #0
 800099e:	2301      	moveq	r3, #1
 80009a0:	b2db      	uxtb	r3, r3
}
 80009a2:	4618      	mov	r0, r3
 80009a4:	f107 0708 	add.w	r7, r7, #8
 80009a8:	46bd      	mov	sp, r7
 80009aa:	bd80      	pop	{r7, pc}

080009ac <USB_OTG_ReadCoreItr>:
* @brief  USB_OTG_ReadCoreItr : returns the Core Interrupt register
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
{
 80009ac:	b480      	push	{r7}
 80009ae:	b085      	sub	sp, #20
 80009b0:	af00      	add	r7, sp, #0
 80009b2:	6078      	str	r0, [r7, #4]
  uint32_t v = 0;
 80009b4:	f04f 0300 	mov.w	r3, #0
 80009b8:	60fb      	str	r3, [r7, #12]
  v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 80009ba:	687b      	ldr	r3, [r7, #4]
 80009bc:	68db      	ldr	r3, [r3, #12]
 80009be:	695b      	ldr	r3, [r3, #20]
 80009c0:	60fb      	str	r3, [r7, #12]
  v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 80009c2:	687b      	ldr	r3, [r7, #4]
 80009c4:	68db      	ldr	r3, [r3, #12]
 80009c6:	699b      	ldr	r3, [r3, #24]
 80009c8:	68fa      	ldr	r2, [r7, #12]
 80009ca:	4013      	ands	r3, r2
 80009cc:	60fb      	str	r3, [r7, #12]
  return v;
 80009ce:	68fb      	ldr	r3, [r7, #12]
}
 80009d0:	4618      	mov	r0, r3
 80009d2:	f107 0714 	add.w	r7, r7, #20
 80009d6:	46bd      	mov	sp, r7
 80009d8:	bc80      	pop	{r7}
 80009da:	4770      	bx	lr

080009dc <USB_OTG_ReadOtgItr>:
* @brief  USB_OTG_ReadOtgItr : returns the USB_OTG Interrupt register
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
{
 80009dc:	b480      	push	{r7}
 80009de:	b083      	sub	sp, #12
 80009e0:	af00      	add	r7, sp, #0
 80009e2:	6078      	str	r0, [r7, #4]
  return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
 80009e4:	687b      	ldr	r3, [r7, #4]
 80009e6:	68db      	ldr	r3, [r3, #12]
 80009e8:	685b      	ldr	r3, [r3, #4]
}
 80009ea:	4618      	mov	r0, r3
 80009ec:	f107 070c 	add.w	r7, r7, #12
 80009f0:	46bd      	mov	sp, r7
 80009f2:	bc80      	pop	{r7}
 80009f4:	4770      	bx	lr
 80009f6:	bf00      	nop

080009f8 <USB_OTG_CoreInitHost>:
* @brief  USB_OTG_CoreInitHost : Initializes USB_OTG controller for host mode
* @param  pdev : Selected device
* @retval status
*/
USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
{
 80009f8:	b580      	push	{r7, lr}
 80009fa:	b088      	sub	sp, #32
 80009fc:	af00      	add	r7, sp, #0
 80009fe:	6078      	str	r0, [r7, #4]
  USB_OTG_STS                     status = USB_OTG_OK;
 8000a00:	f04f 0300 	mov.w	r3, #0
 8000a04:	76fb      	strb	r3, [r7, #27]
  
#ifdef USE_OTG_MODE
  USB_OTG_OTGCTL_TypeDef          gotgctl;
#endif
  
  uint32_t                        i = 0;
 8000a06:	f04f 0300 	mov.w	r3, #0
 8000a0a:	61fb      	str	r3, [r7, #28]
  
  nptxfifosize.d32 = 0;  
 8000a0c:	f04f 0300 	mov.w	r3, #0
 8000a10:	617b      	str	r3, [r7, #20]
  ptxfifosize.d32 = 0;
 8000a12:	f04f 0300 	mov.w	r3, #0
 8000a16:	613b      	str	r3, [r7, #16]
#ifdef USE_OTG_MODE
  gotgctl.d32 = 0;
#endif
  hcfg.d32 = 0;
 8000a18:	f04f 0300 	mov.w	r3, #0
 8000a1c:	60fb      	str	r3, [r7, #12]
  
  
  /* configure charge pump IO */
  USB_OTG_BSP_ConfigVBUS(pdev);
 8000a1e:	6878      	ldr	r0, [r7, #4]
 8000a20:	f01c f824 	bl	801ca6c <USB_OTG_BSP_ConfigVBUS>
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 8000a24:	687b      	ldr	r3, [r7, #4]
 8000a26:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 8000a2a:	f04f 0200 	mov.w	r2, #0
 8000a2e:	601a      	str	r2, [r3, #0]
  
  /* Initialize Host Configuration Register */
  USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); /* in init phase */
 8000a30:	6878      	ldr	r0, [r7, #4]
 8000a32:	f04f 0101 	mov.w	r1, #1
 8000a36:	f000 f935 	bl	8000ca4 <USB_OTG_InitFSLSPClkSel>
  
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 8000a3a:	687b      	ldr	r3, [r7, #4]
 8000a3c:	695b      	ldr	r3, [r3, #20]
 8000a3e:	681b      	ldr	r3, [r3, #0]
 8000a40:	60fb      	str	r3, [r7, #12]
  hcfg.b.fslssupp = 0;
 8000a42:	68fb      	ldr	r3, [r7, #12]
 8000a44:	f36f 0382 	bfc	r3, #2, #1
 8000a48:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
 8000a4a:	687b      	ldr	r3, [r7, #4]
 8000a4c:	695b      	ldr	r3, [r3, #20]
 8000a4e:	68fa      	ldr	r2, [r7, #12]
 8000a50:	601a      	str	r2, [r3, #0]
  
  /* Configure data FIFO sizes */
  /* Rx FIFO */
#ifdef USB_OTG_FS_CORE
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
 8000a52:	687b      	ldr	r3, [r7, #4]
 8000a54:	7adb      	ldrb	r3, [r3, #11]
 8000a56:	2b01      	cmp	r3, #1
 8000a58:	d125      	bne.n	8000aa6 <USB_OTG_CoreInitHost+0xae>
  {
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 8000a5a:	687b      	ldr	r3, [r7, #4]
 8000a5c:	68db      	ldr	r3, [r3, #12]
 8000a5e:	f04f 0280 	mov.w	r2, #128	; 0x80
 8000a62:	625a      	str	r2, [r3, #36]	; 0x24
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
 8000a64:	697b      	ldr	r3, [r7, #20]
 8000a66:	f04f 0280 	mov.w	r2, #128	; 0x80
 8000a6a:	f362 030f 	bfi	r3, r2, #0, #16
 8000a6e:	617b      	str	r3, [r7, #20]
    nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
 8000a70:	697b      	ldr	r3, [r7, #20]
 8000a72:	f04f 0260 	mov.w	r2, #96	; 0x60
 8000a76:	f362 431f 	bfi	r3, r2, #16, #16
 8000a7a:	617b      	str	r3, [r7, #20]
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
 8000a7c:	687b      	ldr	r3, [r7, #4]
 8000a7e:	68db      	ldr	r3, [r3, #12]
 8000a80:	697a      	ldr	r2, [r7, #20]
 8000a82:	629a      	str	r2, [r3, #40]	; 0x28
    
    ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
 8000a84:	693b      	ldr	r3, [r7, #16]
 8000a86:	f04f 02e0 	mov.w	r2, #224	; 0xe0
 8000a8a:	f362 030f 	bfi	r3, r2, #0, #16
 8000a8e:	613b      	str	r3, [r7, #16]
    ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
 8000a90:	693b      	ldr	r3, [r7, #16]
 8000a92:	f04f 0260 	mov.w	r2, #96	; 0x60
 8000a96:	f362 431f 	bfi	r3, r2, #16, #16
 8000a9a:	613b      	str	r3, [r7, #16]
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
 8000a9c:	687b      	ldr	r3, [r7, #4]
 8000a9e:	68db      	ldr	r3, [r3, #12]
 8000aa0:	693a      	ldr	r2, [r7, #16]
 8000aa2:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
#endif
#ifdef USB_OTG_HS_CORE  
   if (pdev->cfg.coreID == USB_OTG_HS_CORE_ID)
 8000aa6:	687b      	ldr	r3, [r7, #4]
 8000aa8:	7adb      	ldrb	r3, [r3, #11]
 8000aaa:	2b00      	cmp	r3, #0
 8000aac:	d125      	bne.n	8000afa <USB_OTG_CoreInitHost+0x102>
  {
   /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
 8000aae:	687b      	ldr	r3, [r7, #4]
 8000ab0:	68db      	ldr	r3, [r3, #12]
 8000ab2:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000ab6:	625a      	str	r2, [r3, #36]	; 0x24
    nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;   
 8000ab8:	697b      	ldr	r3, [r7, #20]
 8000aba:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000abe:	f362 030f 	bfi	r3, r2, #0, #16
 8000ac2:	617b      	str	r3, [r7, #20]
    nptxfifosize.b.depth = TXH_NP_HS_FIFOSIZ;  
 8000ac4:	697b      	ldr	r3, [r7, #20]
 8000ac6:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000aca:	f362 431f 	bfi	r3, r2, #16, #16
 8000ace:	617b      	str	r3, [r7, #20]
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
 8000ad0:	687b      	ldr	r3, [r7, #4]
 8000ad2:	68db      	ldr	r3, [r3, #12]
 8000ad4:	697a      	ldr	r2, [r7, #20]
 8000ad6:	629a      	str	r2, [r3, #40]	; 0x28
    
    ptxfifosize.b.startaddr = RX_FIFO_HS_SIZE + TXH_NP_HS_FIFOSIZ;
 8000ad8:	693b      	ldr	r3, [r7, #16]
 8000ada:	f44f 7240 	mov.w	r2, #768	; 0x300
 8000ade:	f362 030f 	bfi	r3, r2, #0, #16
 8000ae2:	613b      	str	r3, [r7, #16]
    ptxfifosize.b.depth     = TXH_P_HS_FIFOSIZ;
 8000ae4:	693b      	ldr	r3, [r7, #16]
 8000ae6:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000aea:	f362 431f 	bfi	r3, r2, #16, #16
 8000aee:	613b      	str	r3, [r7, #16]
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
 8000af0:	687b      	ldr	r3, [r7, #4]
 8000af2:	68db      	ldr	r3, [r3, #12]
 8000af4:	693a      	ldr	r2, [r7, #16]
 8000af6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  gotgctl.b.hstsethnpen = 1;
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
#endif
  
  /* Make sure the FIFOs are flushed. */
  USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
 8000afa:	6878      	ldr	r0, [r7, #4]
 8000afc:	f04f 0110 	mov.w	r1, #16
 8000b00:	f7ff fe78 	bl	80007f4 <USB_OTG_FlushTxFifo>
  USB_OTG_FlushRxFifo(pdev);
 8000b04:	6878      	ldr	r0, [r7, #4]
 8000b06:	f7ff feb5 	bl	8000874 <USB_OTG_FlushRxFifo>
  
  
  /* Clear all pending HC Interrupts */
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8000b0a:	f04f 0300 	mov.w	r3, #0
 8000b0e:	61fb      	str	r3, [r7, #28]
 8000b10:	e019      	b.n	8000b46 <USB_OTG_CoreInitHost+0x14e>
  {
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 8000b12:	687a      	ldr	r2, [r7, #4]
 8000b14:	69fb      	ldr	r3, [r7, #28]
 8000b16:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8000b1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000b1e:	18d3      	adds	r3, r2, r3
 8000b20:	689b      	ldr	r3, [r3, #8]
 8000b22:	f04f 32ff 	mov.w	r2, #4294967295
 8000b26:	609a      	str	r2, [r3, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 8000b28:	687a      	ldr	r2, [r7, #4]
 8000b2a:	69fb      	ldr	r3, [r7, #28]
 8000b2c:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8000b30:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000b34:	18d3      	adds	r3, r2, r3
 8000b36:	689b      	ldr	r3, [r3, #8]
 8000b38:	f04f 0200 	mov.w	r2, #0
 8000b3c:	60da      	str	r2, [r3, #12]
  USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
  USB_OTG_FlushRxFifo(pdev);
  
  
  /* Clear all pending HC Interrupts */
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8000b3e:	69fb      	ldr	r3, [r7, #28]
 8000b40:	f103 0301 	add.w	r3, r3, #1
 8000b44:	61fb      	str	r3, [r7, #28]
 8000b46:	687b      	ldr	r3, [r7, #4]
 8000b48:	781b      	ldrb	r3, [r3, #0]
 8000b4a:	461a      	mov	r2, r3
 8000b4c:	69fb      	ldr	r3, [r7, #28]
 8000b4e:	429a      	cmp	r2, r3
 8000b50:	d8df      	bhi.n	8000b12 <USB_OTG_CoreInitHost+0x11a>
  {
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
  }
#ifndef USE_OTG_MODE
  USB_OTG_DriveVbus(pdev, 1);
 8000b52:	6878      	ldr	r0, [r7, #4]
 8000b54:	f04f 0101 	mov.w	r1, #1
 8000b58:	f000 f81e 	bl	8000b98 <USB_OTG_DriveVbus>
#endif
  
  USB_OTG_EnableHostInt(pdev);
 8000b5c:	6878      	ldr	r0, [r7, #4]
 8000b5e:	f000 f85b 	bl	8000c18 <USB_OTG_EnableHostInt>
  return status;
 8000b62:	7efb      	ldrb	r3, [r7, #27]
}
 8000b64:	4618      	mov	r0, r3
 8000b66:	f107 0720 	add.w	r7, r7, #32
 8000b6a:	46bd      	mov	sp, r7
 8000b6c:	bd80      	pop	{r7, pc}
 8000b6e:	bf00      	nop

08000b70 <USB_OTG_IsEvenFrame>:
*         This function returns the frame number for sof packet
* @param  pdev : Selected device
* @retval Frame number
*/
uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
{
 8000b70:	b480      	push	{r7}
 8000b72:	b083      	sub	sp, #12
 8000b74:	af00      	add	r7, sp, #0
 8000b76:	6078      	str	r0, [r7, #4]
  return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
 8000b78:	687b      	ldr	r3, [r7, #4]
 8000b7a:	695b      	ldr	r3, [r3, #20]
 8000b7c:	689b      	ldr	r3, [r3, #8]
 8000b7e:	f003 0301 	and.w	r3, r3, #1
 8000b82:	2b00      	cmp	r3, #0
 8000b84:	bf14      	ite	ne
 8000b86:	2300      	movne	r3, #0
 8000b88:	2301      	moveq	r3, #1
 8000b8a:	b2db      	uxtb	r3, r3
}
 8000b8c:	4618      	mov	r0, r3
 8000b8e:	f107 070c 	add.w	r7, r7, #12
 8000b92:	46bd      	mov	sp, r7
 8000b94:	bc80      	pop	{r7}
 8000b96:	4770      	bx	lr

08000b98 <USB_OTG_DriveVbus>:
* @param  pdev : Selected device
* @param  state : VBUS state
* @retval None
*/
void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
{
 8000b98:	b580      	push	{r7, lr}
 8000b9a:	b084      	sub	sp, #16
 8000b9c:	af00      	add	r7, sp, #0
 8000b9e:	6078      	str	r0, [r7, #4]
 8000ba0:	460b      	mov	r3, r1
 8000ba2:	70fb      	strb	r3, [r7, #3]
  USB_OTG_HPRT0_TypeDef     hprt0;
  
  hprt0.d32 = 0;
 8000ba4:	f04f 0300 	mov.w	r3, #0
 8000ba8:	60fb      	str	r3, [r7, #12]
  
  /* enable disable the external charge pump */
  USB_OTG_BSP_DriveVBUS(pdev, state);
 8000baa:	78fb      	ldrb	r3, [r7, #3]
 8000bac:	6878      	ldr	r0, [r7, #4]
 8000bae:	4619      	mov	r1, r3
 8000bb0:	f01b ff3e 	bl	801ca30 <USB_OTG_BSP_DriveVBUS>
  
  /* Turn on the Host port power. */
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
 8000bb4:	6878      	ldr	r0, [r7, #4]
 8000bb6:	f000 f891 	bl	8000cdc <USB_OTG_ReadHPRT0>
 8000bba:	4603      	mov	r3, r0
 8000bbc:	60fb      	str	r3, [r7, #12]
  if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
 8000bbe:	7b7b      	ldrb	r3, [r7, #13]
 8000bc0:	f003 0310 	and.w	r3, r3, #16
 8000bc4:	b2db      	uxtb	r3, r3
 8000bc6:	2b00      	cmp	r3, #0
 8000bc8:	d10b      	bne.n	8000be2 <USB_OTG_DriveVbus+0x4a>
 8000bca:	78fb      	ldrb	r3, [r7, #3]
 8000bcc:	2b01      	cmp	r3, #1
 8000bce:	d108      	bne.n	8000be2 <USB_OTG_DriveVbus+0x4a>
  {
    hprt0.b.prtpwr = 1;
 8000bd0:	68fb      	ldr	r3, [r7, #12]
 8000bd2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000bd6:	60fb      	str	r3, [r7, #12]
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8000bd8:	687b      	ldr	r3, [r7, #4]
 8000bda:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8000bde:	68fa      	ldr	r2, [r7, #12]
 8000be0:	601a      	str	r2, [r3, #0]
  }
  if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
 8000be2:	7b7b      	ldrb	r3, [r7, #13]
 8000be4:	f003 0310 	and.w	r3, r3, #16
 8000be8:	b2db      	uxtb	r3, r3
 8000bea:	2b00      	cmp	r3, #0
 8000bec:	d00b      	beq.n	8000c06 <USB_OTG_DriveVbus+0x6e>
 8000bee:	78fb      	ldrb	r3, [r7, #3]
 8000bf0:	2b00      	cmp	r3, #0
 8000bf2:	d108      	bne.n	8000c06 <USB_OTG_DriveVbus+0x6e>
  {
    hprt0.b.prtpwr = 0;
 8000bf4:	68fb      	ldr	r3, [r7, #12]
 8000bf6:	f36f 330c 	bfc	r3, #12, #1
 8000bfa:	60fb      	str	r3, [r7, #12]
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8000bfc:	687b      	ldr	r3, [r7, #4]
 8000bfe:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8000c02:	68fa      	ldr	r2, [r7, #12]
 8000c04:	601a      	str	r2, [r3, #0]
  }
  
  USB_OTG_BSP_mDelay(200);
 8000c06:	f04f 00c8 	mov.w	r0, #200	; 0xc8
 8000c0a:	f01b ff8d 	bl	801cb28 <USB_OTG_BSP_mDelay>
}
 8000c0e:	f107 0710 	add.w	r7, r7, #16
 8000c12:	46bd      	mov	sp, r7
 8000c14:	bd80      	pop	{r7, pc}
 8000c16:	bf00      	nop

08000c18 <USB_OTG_EnableHostInt>:
* @brief  USB_OTG_EnableHostInt: Enables the Host mode interrupts
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
{
 8000c18:	b580      	push	{r7, lr}
 8000c1a:	b084      	sub	sp, #16
 8000c1c:	af00      	add	r7, sp, #0
 8000c1e:	6078      	str	r0, [r7, #4]
  USB_OTG_STS       status = USB_OTG_OK;
 8000c20:	f04f 0300 	mov.w	r3, #0
 8000c24:	73fb      	strb	r3, [r7, #15]
  USB_OTG_GINTMSK_TypeDef  intmsk;
  intmsk.d32 = 0;
 8000c26:	f04f 0300 	mov.w	r3, #0
 8000c2a:	60bb      	str	r3, [r7, #8]
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
 8000c2c:	687b      	ldr	r3, [r7, #4]
 8000c2e:	68db      	ldr	r3, [r3, #12]
 8000c30:	f04f 0200 	mov.w	r2, #0
 8000c34:	619a      	str	r2, [r3, #24]
  
  /* Clear any pending interrupts. */
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8000c36:	687b      	ldr	r3, [r7, #4]
 8000c38:	68db      	ldr	r3, [r3, #12]
 8000c3a:	f04f 32ff 	mov.w	r2, #4294967295
 8000c3e:	615a      	str	r2, [r3, #20]
  
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
 8000c40:	6878      	ldr	r0, [r7, #4]
 8000c42:	f7ff facb 	bl	80001dc <USB_OTG_EnableCommonInt>
  
  if (pdev->cfg.dma_enable == 0)
 8000c46:	687b      	ldr	r3, [r7, #4]
 8000c48:	78db      	ldrb	r3, [r3, #3]
 8000c4a:	2b00      	cmp	r3, #0
 8000c4c:	d103      	bne.n	8000c56 <USB_OTG_EnableHostInt+0x3e>
  {  
    intmsk.b.rxstsqlvl  = 1;
 8000c4e:	68bb      	ldr	r3, [r7, #8]
 8000c50:	f043 0310 	orr.w	r3, r3, #16
 8000c54:	60bb      	str	r3, [r7, #8]
  }  
  intmsk.b.portintr   = 1;
 8000c56:	68bb      	ldr	r3, [r7, #8]
 8000c58:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000c5c:	60bb      	str	r3, [r7, #8]
  intmsk.b.hcintr     = 1;
 8000c5e:	68bb      	ldr	r3, [r7, #8]
 8000c60:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8000c64:	60bb      	str	r3, [r7, #8]
  intmsk.b.disconnect = 1;  
 8000c66:	68bb      	ldr	r3, [r7, #8]
 8000c68:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8000c6c:	60bb      	str	r3, [r7, #8]
  intmsk.b.sofintr    = 1;  
 8000c6e:	68bb      	ldr	r3, [r7, #8]
 8000c70:	f043 0308 	orr.w	r3, r3, #8
 8000c74:	60bb      	str	r3, [r7, #8]
  intmsk.b.incomplisoout  = 1; 
 8000c76:	68bb      	ldr	r3, [r7, #8]
 8000c78:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8000c7c:	60bb      	str	r3, [r7, #8]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8000c7e:	687b      	ldr	r3, [r7, #4]
 8000c80:	68db      	ldr	r3, [r3, #12]
 8000c82:	687a      	ldr	r2, [r7, #4]
 8000c84:	68d2      	ldr	r2, [r2, #12]
 8000c86:	6992      	ldr	r2, [r2, #24]
 8000c88:	4611      	mov	r1, r2
 8000c8a:	68ba      	ldr	r2, [r7, #8]
 8000c8c:	ea6f 0202 	mvn.w	r2, r2
 8000c90:	4011      	ands	r1, r2
 8000c92:	68ba      	ldr	r2, [r7, #8]
 8000c94:	430a      	orrs	r2, r1
 8000c96:	619a      	str	r2, [r3, #24]
  return status;
 8000c98:	7bfb      	ldrb	r3, [r7, #15]
}
 8000c9a:	4618      	mov	r0, r3
 8000c9c:	f107 0710 	add.w	r7, r7, #16
 8000ca0:	46bd      	mov	sp, r7
 8000ca2:	bd80      	pop	{r7, pc}

08000ca4 <USB_OTG_InitFSLSPClkSel>:
* @param  pdev : Selected device
* @param  freq : clock frequency
* @retval None
*/
void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
{
 8000ca4:	b480      	push	{r7}
 8000ca6:	b085      	sub	sp, #20
 8000ca8:	af00      	add	r7, sp, #0
 8000caa:	6078      	str	r0, [r7, #4]
 8000cac:	460b      	mov	r3, r1
 8000cae:	70fb      	strb	r3, [r7, #3]
  USB_OTG_HCFG_TypeDef   hcfg;
  
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 8000cb0:	687b      	ldr	r3, [r7, #4]
 8000cb2:	695b      	ldr	r3, [r3, #20]
 8000cb4:	681b      	ldr	r3, [r3, #0]
 8000cb6:	60fb      	str	r3, [r7, #12]
  hcfg.b.fslspclksel = freq;
 8000cb8:	78fb      	ldrb	r3, [r7, #3]
 8000cba:	f003 0303 	and.w	r3, r3, #3
 8000cbe:	b2da      	uxtb	r2, r3
 8000cc0:	68fb      	ldr	r3, [r7, #12]
 8000cc2:	f362 0301 	bfi	r3, r2, #0, #2
 8000cc6:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
 8000cc8:	687b      	ldr	r3, [r7, #4]
 8000cca:	695b      	ldr	r3, [r3, #20]
 8000ccc:	68fa      	ldr	r2, [r7, #12]
 8000cce:	601a      	str	r2, [r3, #0]
}
 8000cd0:	f107 0714 	add.w	r7, r7, #20
 8000cd4:	46bd      	mov	sp, r7
 8000cd6:	bc80      	pop	{r7}
 8000cd8:	4770      	bx	lr
 8000cda:	bf00      	nop

08000cdc <USB_OTG_ReadHPRT0>:
* @brief  USB_OTG_ReadHPRT0 : Reads HPRT0 to modify later
* @param  pdev : Selected device
* @retval HPRT0 value
*/
uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
{
 8000cdc:	b480      	push	{r7}
 8000cde:	b085      	sub	sp, #20
 8000ce0:	af00      	add	r7, sp, #0
 8000ce2:	6078      	str	r0, [r7, #4]
  USB_OTG_HPRT0_TypeDef  hprt0;
  
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 8000ce4:	687b      	ldr	r3, [r7, #4]
 8000ce6:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8000cea:	681b      	ldr	r3, [r3, #0]
 8000cec:	60fb      	str	r3, [r7, #12]
  hprt0.b.prtena = 0;
 8000cee:	68fb      	ldr	r3, [r7, #12]
 8000cf0:	f36f 0382 	bfc	r3, #2, #1
 8000cf4:	60fb      	str	r3, [r7, #12]
  hprt0.b.prtconndet = 0;
 8000cf6:	68fb      	ldr	r3, [r7, #12]
 8000cf8:	f36f 0341 	bfc	r3, #1, #1
 8000cfc:	60fb      	str	r3, [r7, #12]
  hprt0.b.prtenchng = 0;
 8000cfe:	68fb      	ldr	r3, [r7, #12]
 8000d00:	f36f 03c3 	bfc	r3, #3, #1
 8000d04:	60fb      	str	r3, [r7, #12]
  hprt0.b.prtovrcurrchng = 0;
 8000d06:	68fb      	ldr	r3, [r7, #12]
 8000d08:	f36f 1345 	bfc	r3, #5, #1
 8000d0c:	60fb      	str	r3, [r7, #12]
  return hprt0.d32;
 8000d0e:	68fb      	ldr	r3, [r7, #12]
}
 8000d10:	4618      	mov	r0, r3
 8000d12:	f107 0714 	add.w	r7, r7, #20
 8000d16:	46bd      	mov	sp, r7
 8000d18:	bc80      	pop	{r7}
 8000d1a:	4770      	bx	lr

08000d1c <USB_OTG_ReadHostAllChannels_intr>:
* @brief  USB_OTG_ReadHostAllChannels_intr : Register PCD Callbacks
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
{
 8000d1c:	b480      	push	{r7}
 8000d1e:	b083      	sub	sp, #12
 8000d20:	af00      	add	r7, sp, #0
 8000d22:	6078      	str	r0, [r7, #4]
  return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
 8000d24:	687b      	ldr	r3, [r7, #4]
 8000d26:	695b      	ldr	r3, [r3, #20]
 8000d28:	695b      	ldr	r3, [r3, #20]
}
 8000d2a:	4618      	mov	r0, r3
 8000d2c:	f107 070c 	add.w	r7, r7, #12
 8000d30:	46bd      	mov	sp, r7
 8000d32:	bc80      	pop	{r7}
 8000d34:	4770      	bx	lr
 8000d36:	bf00      	nop

08000d38 <USB_OTG_ResetPort>:
* @retval status
* @note : (1)The application must wait at least 10 ms (+ 10 ms security)
*   before clearing the reset bit.
*/
uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
{
 8000d38:	b580      	push	{r7, lr}
 8000d3a:	b084      	sub	sp, #16
 8000d3c:	af00      	add	r7, sp, #0
 8000d3e:	6078      	str	r0, [r7, #4]
  USB_OTG_HPRT0_TypeDef  hprt0;
  
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
 8000d40:	6878      	ldr	r0, [r7, #4]
 8000d42:	f7ff ffcb 	bl	8000cdc <USB_OTG_ReadHPRT0>
 8000d46:	4603      	mov	r3, r0
 8000d48:	60fb      	str	r3, [r7, #12]
  hprt0.b.prtrst = 1;
 8000d4a:	68fb      	ldr	r3, [r7, #12]
 8000d4c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000d50:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8000d52:	687b      	ldr	r3, [r7, #4]
 8000d54:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8000d58:	68fa      	ldr	r2, [r7, #12]
 8000d5a:	601a      	str	r2, [r3, #0]
  USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
 8000d5c:	f04f 000a 	mov.w	r0, #10
 8000d60:	f01b fee2 	bl	801cb28 <USB_OTG_BSP_mDelay>
  hprt0.b.prtrst = 0;
 8000d64:	68fb      	ldr	r3, [r7, #12]
 8000d66:	f36f 2308 	bfc	r3, #8, #1
 8000d6a:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8000d6c:	687b      	ldr	r3, [r7, #4]
 8000d6e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8000d72:	68fa      	ldr	r2, [r7, #12]
 8000d74:	601a      	str	r2, [r3, #0]
  USB_OTG_BSP_mDelay (20);   
 8000d76:	f04f 0014 	mov.w	r0, #20
 8000d7a:	f01b fed5 	bl	801cb28 <USB_OTG_BSP_mDelay>
  return 1;
 8000d7e:	f04f 0301 	mov.w	r3, #1
}
 8000d82:	4618      	mov	r0, r3
 8000d84:	f107 0710 	add.w	r7, r7, #16
 8000d88:	46bd      	mov	sp, r7
 8000d8a:	bd80      	pop	{r7, pc}

08000d8c <USB_OTG_HC_Init>:
* @param  pdev : Selected device
* @param  hc_num : channel number
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 8000d8c:	b480      	push	{r7}
 8000d8e:	b089      	sub	sp, #36	; 0x24
 8000d90:	af00      	add	r7, sp, #0
 8000d92:	6078      	str	r0, [r7, #4]
 8000d94:	460b      	mov	r3, r1
 8000d96:	70fb      	strb	r3, [r7, #3]
  USB_OTG_STS status = USB_OTG_OK;
 8000d98:	f04f 0300 	mov.w	r3, #0
 8000d9c:	77fb      	strb	r3, [r7, #31]
  uint32_t intr_enable = 0;
 8000d9e:	f04f 0300 	mov.w	r3, #0
 8000da2:	61bb      	str	r3, [r7, #24]
  USB_OTG_GINTMSK_TypeDef    gintmsk;
  USB_OTG_HCCHAR_TypeDef     hcchar;
  USB_OTG_HCINTn_TypeDef     hcint;
  
  
  gintmsk.d32 = 0;
 8000da4:	f04f 0300 	mov.w	r3, #0
 8000da8:	613b      	str	r3, [r7, #16]
  hcintmsk.d32 = 0;
 8000daa:	f04f 0300 	mov.w	r3, #0
 8000dae:	617b      	str	r3, [r7, #20]
  hcchar.d32 = 0;
 8000db0:	f04f 0300 	mov.w	r3, #0
 8000db4:	60fb      	str	r3, [r7, #12]
  
  /* Clear old interrupt conditions for this host channel. */
  hcint.d32 = 0xFFFFFFFF;
 8000db6:	f04f 33ff 	mov.w	r3, #4294967295
 8000dba:	60bb      	str	r3, [r7, #8]
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
 8000dbc:	78fb      	ldrb	r3, [r7, #3]
 8000dbe:	687a      	ldr	r2, [r7, #4]
 8000dc0:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8000dc4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000dc8:	18d3      	adds	r3, r2, r3
 8000dca:	689b      	ldr	r3, [r3, #8]
 8000dcc:	68ba      	ldr	r2, [r7, #8]
 8000dce:	609a      	str	r2, [r3, #8]
  
  /* Enable channel interrupts required for this transfer. */
  hcintmsk.d32 = 0;
 8000dd0:	f04f 0300 	mov.w	r3, #0
 8000dd4:	617b      	str	r3, [r7, #20]
  
  if (pdev->cfg.dma_enable == 1)
 8000dd6:	687b      	ldr	r3, [r7, #4]
 8000dd8:	78db      	ldrb	r3, [r3, #3]
 8000dda:	2b01      	cmp	r3, #1
 8000ddc:	d103      	bne.n	8000de6 <USB_OTG_HC_Init+0x5a>
  {
    hcintmsk.b.ahberr = 1;
 8000dde:	697b      	ldr	r3, [r7, #20]
 8000de0:	f043 0304 	orr.w	r3, r3, #4
 8000de4:	617b      	str	r3, [r7, #20]
  }
  
  switch (pdev->host.hc[hc_num].ep_type) 
 8000de6:	78fb      	ldrb	r3, [r7, #3]
 8000de8:	687a      	ldr	r2, [r7, #4]
 8000dea:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000dee:	18d3      	adds	r3, r2, r3
 8000df0:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000df4:	7a5b      	ldrb	r3, [r3, #9]
 8000df6:	2b03      	cmp	r3, #3
 8000df8:	f200 808d 	bhi.w	8000f16 <USB_OTG_HC_Init+0x18a>
 8000dfc:	a201      	add	r2, pc, #4	; (adr r2, 8000e04 <USB_OTG_HC_Init+0x78>)
 8000dfe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000e02:	bf00      	nop
 8000e04:	08000e15 	.word	0x08000e15
 8000e08:	08000ecf 	.word	0x08000ecf
 8000e0c:	08000e15 	.word	0x08000e15
 8000e10:	08000e81 	.word	0x08000e81
  {
  case EP_TYPE_CTRL:
  case EP_TYPE_BULK:
    hcintmsk.b.xfercompl = 1;
 8000e14:	697b      	ldr	r3, [r7, #20]
 8000e16:	f043 0301 	orr.w	r3, r3, #1
 8000e1a:	617b      	str	r3, [r7, #20]
    hcintmsk.b.stall = 1;
 8000e1c:	697b      	ldr	r3, [r7, #20]
 8000e1e:	f043 0308 	orr.w	r3, r3, #8
 8000e22:	617b      	str	r3, [r7, #20]
    hcintmsk.b.xacterr = 1;
 8000e24:	697b      	ldr	r3, [r7, #20]
 8000e26:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000e2a:	617b      	str	r3, [r7, #20]
    hcintmsk.b.datatglerr = 1;
 8000e2c:	697b      	ldr	r3, [r7, #20]
 8000e2e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000e32:	617b      	str	r3, [r7, #20]
    hcintmsk.b.nak = 1;  
 8000e34:	697b      	ldr	r3, [r7, #20]
 8000e36:	f043 0310 	orr.w	r3, r3, #16
 8000e3a:	617b      	str	r3, [r7, #20]
    if (pdev->host.hc[hc_num].ep_is_in) 
 8000e3c:	78fb      	ldrb	r3, [r7, #3]
 8000e3e:	687a      	ldr	r2, [r7, #4]
 8000e40:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000e44:	18d3      	adds	r3, r2, r3
 8000e46:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000e4a:	799b      	ldrb	r3, [r3, #6]
 8000e4c:	2b00      	cmp	r3, #0
 8000e4e:	d004      	beq.n	8000e5a <USB_OTG_HC_Init+0xce>
    {
      hcintmsk.b.bblerr = 1;
 8000e50:	697b      	ldr	r3, [r7, #20]
 8000e52:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000e56:	617b      	str	r3, [r7, #20]
      if (pdev->host.hc[hc_num].do_ping) 
      {
        hcintmsk.b.ack = 1;
      }
    }
    break;
 8000e58:	e058      	b.n	8000f0c <USB_OTG_HC_Init+0x180>
    {
      hcintmsk.b.bblerr = 1;
    } 
    else 
    {
      hcintmsk.b.nyet = 1;
 8000e5a:	697b      	ldr	r3, [r7, #20]
 8000e5c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000e60:	617b      	str	r3, [r7, #20]
      if (pdev->host.hc[hc_num].do_ping) 
 8000e62:	78fb      	ldrb	r3, [r7, #3]
 8000e64:	687a      	ldr	r2, [r7, #4]
 8000e66:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000e6a:	18d3      	adds	r3, r2, r3
 8000e6c:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000e70:	7a1b      	ldrb	r3, [r3, #8]
 8000e72:	2b00      	cmp	r3, #0
 8000e74:	d04a      	beq.n	8000f0c <USB_OTG_HC_Init+0x180>
      {
        hcintmsk.b.ack = 1;
 8000e76:	697b      	ldr	r3, [r7, #20]
 8000e78:	f043 0320 	orr.w	r3, r3, #32
 8000e7c:	617b      	str	r3, [r7, #20]
      }
    }
    break;
 8000e7e:	e045      	b.n	8000f0c <USB_OTG_HC_Init+0x180>
  case EP_TYPE_INTR:
    hcintmsk.b.xfercompl = 1;
 8000e80:	697b      	ldr	r3, [r7, #20]
 8000e82:	f043 0301 	orr.w	r3, r3, #1
 8000e86:	617b      	str	r3, [r7, #20]
    hcintmsk.b.nak = 1;
 8000e88:	697b      	ldr	r3, [r7, #20]
 8000e8a:	f043 0310 	orr.w	r3, r3, #16
 8000e8e:	617b      	str	r3, [r7, #20]
    hcintmsk.b.stall = 1;
 8000e90:	697b      	ldr	r3, [r7, #20]
 8000e92:	f043 0308 	orr.w	r3, r3, #8
 8000e96:	617b      	str	r3, [r7, #20]
    hcintmsk.b.xacterr = 1;
 8000e98:	697b      	ldr	r3, [r7, #20]
 8000e9a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000e9e:	617b      	str	r3, [r7, #20]
    hcintmsk.b.datatglerr = 1;
 8000ea0:	697b      	ldr	r3, [r7, #20]
 8000ea2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000ea6:	617b      	str	r3, [r7, #20]
    hcintmsk.b.frmovrun = 1;
 8000ea8:	697b      	ldr	r3, [r7, #20]
 8000eaa:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000eae:	617b      	str	r3, [r7, #20]
    
    if (pdev->host.hc[hc_num].ep_is_in) 
 8000eb0:	78fb      	ldrb	r3, [r7, #3]
 8000eb2:	687a      	ldr	r2, [r7, #4]
 8000eb4:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000eb8:	18d3      	adds	r3, r2, r3
 8000eba:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000ebe:	799b      	ldrb	r3, [r3, #6]
 8000ec0:	2b00      	cmp	r3, #0
 8000ec2:	d025      	beq.n	8000f10 <USB_OTG_HC_Init+0x184>
    {
      hcintmsk.b.bblerr = 1;
 8000ec4:	697b      	ldr	r3, [r7, #20]
 8000ec6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000eca:	617b      	str	r3, [r7, #20]
    }
    
    break;
 8000ecc:	e020      	b.n	8000f10 <USB_OTG_HC_Init+0x184>
  case EP_TYPE_ISOC:
    hcintmsk.b.xfercompl = 1;
 8000ece:	697b      	ldr	r3, [r7, #20]
 8000ed0:	f043 0301 	orr.w	r3, r3, #1
 8000ed4:	617b      	str	r3, [r7, #20]
    hcintmsk.b.frmovrun = 1;
 8000ed6:	697b      	ldr	r3, [r7, #20]
 8000ed8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000edc:	617b      	str	r3, [r7, #20]
    hcintmsk.b.ack = 1;
 8000ede:	697b      	ldr	r3, [r7, #20]
 8000ee0:	f043 0320 	orr.w	r3, r3, #32
 8000ee4:	617b      	str	r3, [r7, #20]
    
    if (pdev->host.hc[hc_num].ep_is_in) 
 8000ee6:	78fb      	ldrb	r3, [r7, #3]
 8000ee8:	687a      	ldr	r2, [r7, #4]
 8000eea:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000eee:	18d3      	adds	r3, r2, r3
 8000ef0:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000ef4:	799b      	ldrb	r3, [r3, #6]
 8000ef6:	2b00      	cmp	r3, #0
 8000ef8:	d00c      	beq.n	8000f14 <USB_OTG_HC_Init+0x188>
    {
      hcintmsk.b.xacterr = 1;
 8000efa:	697b      	ldr	r3, [r7, #20]
 8000efc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000f00:	617b      	str	r3, [r7, #20]
      hcintmsk.b.bblerr = 1;
 8000f02:	697b      	ldr	r3, [r7, #20]
 8000f04:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000f08:	617b      	str	r3, [r7, #20]
    }
    break;
 8000f0a:	e003      	b.n	8000f14 <USB_OTG_HC_Init+0x188>
      if (pdev->host.hc[hc_num].do_ping) 
      {
        hcintmsk.b.ack = 1;
      }
    }
    break;
 8000f0c:	bf00      	nop
 8000f0e:	e002      	b.n	8000f16 <USB_OTG_HC_Init+0x18a>
    if (pdev->host.hc[hc_num].ep_is_in) 
    {
      hcintmsk.b.bblerr = 1;
    }
    
    break;
 8000f10:	bf00      	nop
 8000f12:	e000      	b.n	8000f16 <USB_OTG_HC_Init+0x18a>
    if (pdev->host.hc[hc_num].ep_is_in) 
    {
      hcintmsk.b.xacterr = 1;
      hcintmsk.b.bblerr = 1;
    }
    break;
 8000f14:	bf00      	nop
  }
  
  
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCGINTMSK, hcintmsk.d32);
 8000f16:	78fb      	ldrb	r3, [r7, #3]
 8000f18:	687a      	ldr	r2, [r7, #4]
 8000f1a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8000f1e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000f22:	18d3      	adds	r3, r2, r3
 8000f24:	689b      	ldr	r3, [r3, #8]
 8000f26:	697a      	ldr	r2, [r7, #20]
 8000f28:	60da      	str	r2, [r3, #12]
  
  
  /* Enable the top level host channel interrupt. */
  intr_enable = (1 << hc_num);
 8000f2a:	78fb      	ldrb	r3, [r7, #3]
 8000f2c:	f04f 0201 	mov.w	r2, #1
 8000f30:	fa02 f303 	lsl.w	r3, r2, r3
 8000f34:	61bb      	str	r3, [r7, #24]
  USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
 8000f36:	687b      	ldr	r3, [r7, #4]
 8000f38:	695b      	ldr	r3, [r3, #20]
 8000f3a:	687a      	ldr	r2, [r7, #4]
 8000f3c:	6952      	ldr	r2, [r2, #20]
 8000f3e:	6992      	ldr	r2, [r2, #24]
 8000f40:	4611      	mov	r1, r2
 8000f42:	69ba      	ldr	r2, [r7, #24]
 8000f44:	430a      	orrs	r2, r1
 8000f46:	619a      	str	r2, [r3, #24]
  
  /* Make sure host channel interrupts are enabled. */
  gintmsk.b.hcintr = 1;
 8000f48:	693b      	ldr	r3, [r7, #16]
 8000f4a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8000f4e:	613b      	str	r3, [r7, #16]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
 8000f50:	687b      	ldr	r3, [r7, #4]
 8000f52:	68db      	ldr	r3, [r3, #12]
 8000f54:	687a      	ldr	r2, [r7, #4]
 8000f56:	68d2      	ldr	r2, [r2, #12]
 8000f58:	6992      	ldr	r2, [r2, #24]
 8000f5a:	4611      	mov	r1, r2
 8000f5c:	693a      	ldr	r2, [r7, #16]
 8000f5e:	430a      	orrs	r2, r1
 8000f60:	619a      	str	r2, [r3, #24]
  
  /* Program the HCCHAR register */
  hcchar.d32 = 0;
 8000f62:	f04f 0300 	mov.w	r3, #0
 8000f66:	60fb      	str	r3, [r7, #12]
  hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
 8000f68:	78fb      	ldrb	r3, [r7, #3]
 8000f6a:	687a      	ldr	r2, [r7, #4]
 8000f6c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000f70:	18d3      	adds	r3, r2, r3
 8000f72:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000f76:	791b      	ldrb	r3, [r3, #4]
 8000f78:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8000f7c:	b2da      	uxtb	r2, r3
 8000f7e:	68fb      	ldr	r3, [r7, #12]
 8000f80:	f362 539c 	bfi	r3, r2, #22, #7
 8000f84:	60fb      	str	r3, [r7, #12]
  hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
 8000f86:	78fb      	ldrb	r3, [r7, #3]
 8000f88:	687a      	ldr	r2, [r7, #4]
 8000f8a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000f8e:	18d3      	adds	r3, r2, r3
 8000f90:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000f94:	795b      	ldrb	r3, [r3, #5]
 8000f96:	f003 030f 	and.w	r3, r3, #15
 8000f9a:	b2da      	uxtb	r2, r3
 8000f9c:	68fb      	ldr	r3, [r7, #12]
 8000f9e:	f362 23ce 	bfi	r3, r2, #11, #4
 8000fa2:	60fb      	str	r3, [r7, #12]
  hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
 8000fa4:	78fb      	ldrb	r3, [r7, #3]
 8000fa6:	687a      	ldr	r2, [r7, #4]
 8000fa8:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000fac:	18d3      	adds	r3, r2, r3
 8000fae:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000fb2:	799b      	ldrb	r3, [r3, #6]
 8000fb4:	f003 0301 	and.w	r3, r3, #1
 8000fb8:	b2da      	uxtb	r2, r3
 8000fba:	68fb      	ldr	r3, [r7, #12]
 8000fbc:	f362 33cf 	bfi	r3, r2, #15, #1
 8000fc0:	60fb      	str	r3, [r7, #12]
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
 8000fc2:	78fb      	ldrb	r3, [r7, #3]
 8000fc4:	687a      	ldr	r2, [r7, #4]
 8000fc6:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000fca:	18d3      	adds	r3, r2, r3
 8000fcc:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000fd0:	79db      	ldrb	r3, [r3, #7]
 8000fd2:	2b02      	cmp	r3, #2
 8000fd4:	bf14      	ite	ne
 8000fd6:	2300      	movne	r3, #0
 8000fd8:	2301      	moveq	r3, #1
 8000fda:	b2da      	uxtb	r2, r3
 8000fdc:	68fb      	ldr	r3, [r7, #12]
 8000fde:	f362 4351 	bfi	r3, r2, #17, #1
 8000fe2:	60fb      	str	r3, [r7, #12]
  hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
 8000fe4:	78fb      	ldrb	r3, [r7, #3]
 8000fe6:	687a      	ldr	r2, [r7, #4]
 8000fe8:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8000fec:	18d3      	adds	r3, r2, r3
 8000fee:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8000ff2:	7a5b      	ldrb	r3, [r3, #9]
 8000ff4:	f003 0303 	and.w	r3, r3, #3
 8000ff8:	b2da      	uxtb	r2, r3
 8000ffa:	68fb      	ldr	r3, [r7, #12]
 8000ffc:	f362 4393 	bfi	r3, r2, #18, #2
 8001000:	60fb      	str	r3, [r7, #12]
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 8001002:	78fb      	ldrb	r3, [r7, #3]
 8001004:	687a      	ldr	r2, [r7, #4]
 8001006:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800100a:	18d3      	adds	r3, r2, r3
 800100c:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8001010:	895b      	ldrh	r3, [r3, #10]
 8001012:	ea4f 5343 	mov.w	r3, r3, lsl #21
 8001016:	ea4f 5353 	mov.w	r3, r3, lsr #21
 800101a:	b29a      	uxth	r2, r3
 800101c:	68fb      	ldr	r3, [r7, #12]
 800101e:	f362 030a 	bfi	r3, r2, #0, #11
 8001022:	60fb      	str	r3, [r7, #12]
  if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
 8001024:	78fb      	ldrb	r3, [r7, #3]
 8001026:	687a      	ldr	r2, [r7, #4]
 8001028:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800102c:	18d3      	adds	r3, r2, r3
 800102e:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8001032:	7a5b      	ldrb	r3, [r3, #9]
 8001034:	2b03      	cmp	r3, #3
 8001036:	d103      	bne.n	8001040 <USB_OTG_HC_Init+0x2b4>
  {
    hcchar.b.oddfrm  = 1;
 8001038:	68fb      	ldr	r3, [r7, #12]
 800103a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800103e:	60fb      	str	r3, [r7, #12]
  }
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 8001040:	78fb      	ldrb	r3, [r7, #3]
 8001042:	687a      	ldr	r2, [r7, #4]
 8001044:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001048:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800104c:	18d3      	adds	r3, r2, r3
 800104e:	689b      	ldr	r3, [r3, #8]
 8001050:	68fa      	ldr	r2, [r7, #12]
 8001052:	601a      	str	r2, [r3, #0]
  return status;
 8001054:	7ffb      	ldrb	r3, [r7, #31]
}
 8001056:	4618      	mov	r0, r3
 8001058:	f107 0724 	add.w	r7, r7, #36	; 0x24
 800105c:	46bd      	mov	sp, r7
 800105e:	bc80      	pop	{r7}
 8001060:	4770      	bx	lr
 8001062:	bf00      	nop

08001064 <USB_OTG_HC_StartXfer>:
* @param  pdev : Selected device
* @param  hc_num : channel number
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 8001064:	b580      	push	{r7, lr}
 8001066:	b08a      	sub	sp, #40	; 0x28
 8001068:	af00      	add	r7, sp, #0
 800106a:	6078      	str	r0, [r7, #4]
 800106c:	460b      	mov	r3, r1
 800106e:	70fb      	strb	r3, [r7, #3]
  USB_OTG_STS status = USB_OTG_OK;
 8001070:	f04f 0300 	mov.w	r3, #0
 8001074:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
  USB_OTG_HCCHAR_TypeDef   hcchar;
  USB_OTG_HCTSIZn_TypeDef  hctsiz;
  USB_OTG_HNPTXSTS_TypeDef hnptxsts; 
  USB_OTG_HPTXSTS_TypeDef  hptxsts; 
  USB_OTG_GINTMSK_TypeDef  intmsk;
  uint16_t                 len_words = 0;   
 8001078:	f04f 0300 	mov.w	r3, #0
 800107c:	847b      	strh	r3, [r7, #34]	; 0x22
  
  uint16_t num_packets;
  uint16_t max_hc_pkt_count;
  
  max_hc_pkt_count = 256;
 800107e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001082:	843b      	strh	r3, [r7, #32]
  hctsiz.d32 = 0;
 8001084:	f04f 0300 	mov.w	r3, #0
 8001088:	61bb      	str	r3, [r7, #24]
  hcchar.d32 = 0;
 800108a:	f04f 0300 	mov.w	r3, #0
 800108e:	61fb      	str	r3, [r7, #28]
  intmsk.d32 = 0;
 8001090:	f04f 0300 	mov.w	r3, #0
 8001094:	60fb      	str	r3, [r7, #12]
  
  /* Compute the expected number of packets associated to the transfer */
  if (pdev->host.hc[hc_num].xfer_len > 0)
 8001096:	78fb      	ldrb	r3, [r7, #3]
 8001098:	687a      	ldr	r2, [r7, #4]
 800109a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800109e:	18d3      	adds	r3, r2, r3
 80010a0:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 80010a4:	681b      	ldr	r3, [r3, #0]
 80010a6:	2b00      	cmp	r3, #0
 80010a8:	d037      	beq.n	800111a <USB_OTG_HC_StartXfer+0xb6>
  {
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
 80010aa:	78fb      	ldrb	r3, [r7, #3]
 80010ac:	687a      	ldr	r2, [r7, #4]
 80010ae:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80010b2:	18d3      	adds	r3, r2, r3
 80010b4:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 80010b8:	681a      	ldr	r2, [r3, #0]
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
 80010ba:	78fb      	ldrb	r3, [r7, #3]
 80010bc:	6879      	ldr	r1, [r7, #4]
 80010be:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80010c2:	18cb      	adds	r3, r1, r3
 80010c4:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 80010c8:	895b      	ldrh	r3, [r3, #10]
  intmsk.d32 = 0;
  
  /* Compute the expected number of packets associated to the transfer */
  if (pdev->host.hc[hc_num].xfer_len > 0)
  {
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
 80010ca:	18d3      	adds	r3, r2, r3
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
 80010cc:	f103 32ff 	add.w	r2, r3, #4294967295
 80010d0:	78fb      	ldrb	r3, [r7, #3]
 80010d2:	6879      	ldr	r1, [r7, #4]
 80010d4:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80010d8:	18cb      	adds	r3, r1, r3
 80010da:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 80010de:	895b      	ldrh	r3, [r3, #10]
 80010e0:	fbb2 f3f3 	udiv	r3, r2, r3
  intmsk.d32 = 0;
  
  /* Compute the expected number of packets associated to the transfer */
  if (pdev->host.hc[hc_num].xfer_len > 0)
  {
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
 80010e4:	84fb      	strh	r3, [r7, #38]	; 0x26
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
    
    if (num_packets > max_hc_pkt_count)
 80010e6:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80010e8:	8c3b      	ldrh	r3, [r7, #32]
 80010ea:	429a      	cmp	r2, r3
 80010ec:	d918      	bls.n	8001120 <USB_OTG_HC_StartXfer+0xbc>
    {
      num_packets = max_hc_pkt_count;
 80010ee:	8c3b      	ldrh	r3, [r7, #32]
 80010f0:	84fb      	strh	r3, [r7, #38]	; 0x26
      pdev->host.hc[hc_num].xfer_len = num_packets * \
 80010f2:	78fb      	ldrb	r3, [r7, #3]
 80010f4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
        pdev->host.hc[hc_num].max_packet;
 80010f6:	78f9      	ldrb	r1, [r7, #3]
 80010f8:	6878      	ldr	r0, [r7, #4]
 80010fa:	ea4f 1141 	mov.w	r1, r1, lsl #5
 80010fe:	1841      	adds	r1, r0, r1
 8001100:	f501 712a 	add.w	r1, r1, #680	; 0x2a8
 8001104:	8949      	ldrh	r1, [r1, #10]
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
    
    if (num_packets > max_hc_pkt_count)
    {
      num_packets = max_hc_pkt_count;
      pdev->host.hc[hc_num].xfer_len = num_packets * \
 8001106:	fb01 f202 	mul.w	r2, r1, r2
 800110a:	6879      	ldr	r1, [r7, #4]
 800110c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001110:	18cb      	adds	r3, r1, r3
 8001112:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001116:	601a      	str	r2, [r3, #0]
 8001118:	e002      	b.n	8001120 <USB_OTG_HC_StartXfer+0xbc>
        pdev->host.hc[hc_num].max_packet;
    }
  }
  else
  {
    num_packets = 1;
 800111a:	f04f 0301 	mov.w	r3, #1
 800111e:	84fb      	strh	r3, [r7, #38]	; 0x26
  }
  if (pdev->host.hc[hc_num].ep_is_in)
 8001120:	78fb      	ldrb	r3, [r7, #3]
 8001122:	687a      	ldr	r2, [r7, #4]
 8001124:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001128:	18d3      	adds	r3, r2, r3
 800112a:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 800112e:	799b      	ldrb	r3, [r3, #6]
 8001130:	2b00      	cmp	r3, #0
 8001132:	d012      	beq.n	800115a <USB_OTG_HC_StartXfer+0xf6>
  {
    pdev->host.hc[hc_num].xfer_len = num_packets * \
 8001134:	78fb      	ldrb	r3, [r7, #3]
 8001136:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
      pdev->host.hc[hc_num].max_packet;
 8001138:	78f9      	ldrb	r1, [r7, #3]
 800113a:	6878      	ldr	r0, [r7, #4]
 800113c:	ea4f 1141 	mov.w	r1, r1, lsl #5
 8001140:	1841      	adds	r1, r0, r1
 8001142:	f501 712a 	add.w	r1, r1, #680	; 0x2a8
 8001146:	8949      	ldrh	r1, [r1, #10]
  {
    num_packets = 1;
  }
  if (pdev->host.hc[hc_num].ep_is_in)
  {
    pdev->host.hc[hc_num].xfer_len = num_packets * \
 8001148:	fb01 f202 	mul.w	r2, r1, r2
 800114c:	6879      	ldr	r1, [r7, #4]
 800114e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001152:	18cb      	adds	r3, r1, r3
 8001154:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001158:	601a      	str	r2, [r3, #0]
      pdev->host.hc[hc_num].max_packet;
  }
  /* Initialize the HCTSIZn register */
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
 800115a:	78fb      	ldrb	r3, [r7, #3]
 800115c:	687a      	ldr	r2, [r7, #4]
 800115e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001162:	18d3      	adds	r3, r2, r3
 8001164:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001168:	681b      	ldr	r3, [r3, #0]
 800116a:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
 800116e:	f422 0278 	bic.w	r2, r2, #16252928	; 0xf80000
 8001172:	69bb      	ldr	r3, [r7, #24]
 8001174:	f362 0312 	bfi	r3, r2, #0, #19
 8001178:	61bb      	str	r3, [r7, #24]
  hctsiz.b.pktcnt = num_packets;
 800117a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800117c:	ea4f 5383 	mov.w	r3, r3, lsl #22
 8001180:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8001184:	b29a      	uxth	r2, r3
 8001186:	69bb      	ldr	r3, [r7, #24]
 8001188:	f362 43dc 	bfi	r3, r2, #19, #10
 800118c:	61bb      	str	r3, [r7, #24]
  hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
 800118e:	78fb      	ldrb	r3, [r7, #3]
 8001190:	687a      	ldr	r2, [r7, #4]
 8001192:	f103 030d 	add.w	r3, r3, #13
 8001196:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800119a:	18d3      	adds	r3, r2, r3
 800119c:	f503 7388 	add.w	r3, r3, #272	; 0x110
 80011a0:	791b      	ldrb	r3, [r3, #4]
 80011a2:	f003 0303 	and.w	r3, r3, #3
 80011a6:	b2da      	uxtb	r2, r3
 80011a8:	69bb      	ldr	r3, [r7, #24]
 80011aa:	f362 735e 	bfi	r3, r2, #29, #2
 80011ae:	61bb      	str	r3, [r7, #24]
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 80011b0:	78fb      	ldrb	r3, [r7, #3]
 80011b2:	687a      	ldr	r2, [r7, #4]
 80011b4:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80011b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80011bc:	18d3      	adds	r3, r2, r3
 80011be:	689b      	ldr	r3, [r3, #8]
 80011c0:	69ba      	ldr	r2, [r7, #24]
 80011c2:	611a      	str	r2, [r3, #16]
  
  if (pdev->cfg.dma_enable == 1)
 80011c4:	687b      	ldr	r3, [r7, #4]
 80011c6:	78db      	ldrb	r3, [r3, #3]
 80011c8:	2b01      	cmp	r3, #1
 80011ca:	d112      	bne.n	80011f2 <USB_OTG_HC_StartXfer+0x18e>
  {
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
 80011cc:	78fb      	ldrb	r3, [r7, #3]
 80011ce:	687a      	ldr	r2, [r7, #4]
 80011d0:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80011d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80011d8:	18d3      	adds	r3, r2, r3
 80011da:	689b      	ldr	r3, [r3, #8]
 80011dc:	78fa      	ldrb	r2, [r7, #3]
 80011de:	6879      	ldr	r1, [r7, #4]
 80011e0:	f102 020d 	add.w	r2, r2, #13
 80011e4:	ea4f 1242 	mov.w	r2, r2, lsl #5
 80011e8:	188a      	adds	r2, r1, r2
 80011ea:	f502 728c 	add.w	r2, r2, #280	; 0x118
 80011ee:	6812      	ldr	r2, [r2, #0]
 80011f0:	615a      	str	r2, [r3, #20]
  }
  
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 80011f2:	78fb      	ldrb	r3, [r7, #3]
 80011f4:	687a      	ldr	r2, [r7, #4]
 80011f6:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80011fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80011fe:	18d3      	adds	r3, r2, r3
 8001200:	689b      	ldr	r3, [r3, #8]
 8001202:	681b      	ldr	r3, [r3, #0]
 8001204:	61fb      	str	r3, [r7, #28]
  hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
 8001206:	6878      	ldr	r0, [r7, #4]
 8001208:	f7ff fcb2 	bl	8000b70 <USB_OTG_IsEvenFrame>
 800120c:	4603      	mov	r3, r0
 800120e:	f003 0301 	and.w	r3, r3, #1
 8001212:	b2da      	uxtb	r2, r3
 8001214:	69fb      	ldr	r3, [r7, #28]
 8001216:	f362 735d 	bfi	r3, r2, #29, #1
 800121a:	61fb      	str	r3, [r7, #28]
  
  /* Set host channel enable */
  hcchar.b.chen = 1;
 800121c:	69fb      	ldr	r3, [r7, #28]
 800121e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001222:	61fb      	str	r3, [r7, #28]
  hcchar.b.chdis = 0;
 8001224:	69fb      	ldr	r3, [r7, #28]
 8001226:	f36f 739e 	bfc	r3, #30, #1
 800122a:	61fb      	str	r3, [r7, #28]
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 800122c:	78fb      	ldrb	r3, [r7, #3]
 800122e:	687a      	ldr	r2, [r7, #4]
 8001230:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001234:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001238:	18d3      	adds	r3, r2, r3
 800123a:	689b      	ldr	r3, [r3, #8]
 800123c:	69fa      	ldr	r2, [r7, #28]
 800123e:	601a      	str	r2, [r3, #0]

  if (pdev->cfg.dma_enable == 0) /* Slave mode */
 8001240:	687b      	ldr	r3, [r7, #4]
 8001242:	78db      	ldrb	r3, [r3, #3]
 8001244:	2b00      	cmp	r3, #0
 8001246:	f040 808d 	bne.w	8001364 <USB_OTG_HC_StartXfer+0x300>
  {  
    if((pdev->host.hc[hc_num].ep_is_in == 0) && 
 800124a:	78fb      	ldrb	r3, [r7, #3]
 800124c:	687a      	ldr	r2, [r7, #4]
 800124e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001252:	18d3      	adds	r3, r2, r3
 8001254:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8001258:	799b      	ldrb	r3, [r3, #6]
 800125a:	2b00      	cmp	r3, #0
 800125c:	f040 8082 	bne.w	8001364 <USB_OTG_HC_StartXfer+0x300>
        (pdev->host.hc[hc_num].xfer_len > 0))
 8001260:	78fb      	ldrb	r3, [r7, #3]
 8001262:	687a      	ldr	r2, [r7, #4]
 8001264:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001268:	18d3      	adds	r3, r2, r3
 800126a:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 800126e:	681b      	ldr	r3, [r3, #0]
  hcchar.b.chdis = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);

  if (pdev->cfg.dma_enable == 0) /* Slave mode */
  {  
    if((pdev->host.hc[hc_num].ep_is_in == 0) && 
 8001270:	2b00      	cmp	r3, #0
 8001272:	d077      	beq.n	8001364 <USB_OTG_HC_StartXfer+0x300>
        (pdev->host.hc[hc_num].xfer_len > 0))
    {
      switch(pdev->host.hc[hc_num].ep_type) 
 8001274:	78fb      	ldrb	r3, [r7, #3]
 8001276:	687a      	ldr	r2, [r7, #4]
 8001278:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800127c:	18d3      	adds	r3, r2, r3
 800127e:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8001282:	7a5b      	ldrb	r3, [r3, #9]
 8001284:	2b03      	cmp	r3, #3
 8001286:	d851      	bhi.n	800132c <USB_OTG_HC_StartXfer+0x2c8>
 8001288:	a201      	add	r2, pc, #4	; (adr r2, 8001290 <USB_OTG_HC_StartXfer+0x22c>)
 800128a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800128e:	bf00      	nop
 8001290:	080012a1 	.word	0x080012a1
 8001294:	080012e7 	.word	0x080012e7
 8001298:	080012a1 	.word	0x080012a1
 800129c:	080012e7 	.word	0x080012e7
      {
        /* Non periodic transfer */
      case EP_TYPE_CTRL:
      case EP_TYPE_BULK:
        
        hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 80012a0:	687b      	ldr	r3, [r7, #4]
 80012a2:	68db      	ldr	r3, [r3, #12]
 80012a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80012a6:	617b      	str	r3, [r7, #20]
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
 80012a8:	78fb      	ldrb	r3, [r7, #3]
 80012aa:	687a      	ldr	r2, [r7, #4]
 80012ac:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80012b0:	18d3      	adds	r3, r2, r3
 80012b2:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 80012b6:	681b      	ldr	r3, [r3, #0]
 80012b8:	f103 0303 	add.w	r3, r3, #3
 80012bc:	ea4f 0393 	mov.w	r3, r3, lsr #2
 80012c0:	847b      	strh	r3, [r7, #34]	; 0x22
        
        /* check if there is enough space in FIFO space */
        if(len_words > hnptxsts.b.nptxfspcavail)
 80012c2:	8abb      	ldrh	r3, [r7, #20]
 80012c4:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 80012c6:	429a      	cmp	r2, r3
 80012c8:	d932      	bls.n	8001330 <USB_OTG_HC_StartXfer+0x2cc>
        {
          /* need to process data in nptxfempty interrupt */
          intmsk.b.nptxfempty = 1;
 80012ca:	68fb      	ldr	r3, [r7, #12]
 80012cc:	f043 0320 	orr.w	r3, r3, #32
 80012d0:	60fb      	str	r3, [r7, #12]
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
 80012d2:	687b      	ldr	r3, [r7, #4]
 80012d4:	68db      	ldr	r3, [r3, #12]
 80012d6:	687a      	ldr	r2, [r7, #4]
 80012d8:	68d2      	ldr	r2, [r2, #12]
 80012da:	6992      	ldr	r2, [r2, #24]
 80012dc:	4611      	mov	r1, r2
 80012de:	68fa      	ldr	r2, [r7, #12]
 80012e0:	430a      	orrs	r2, r1
 80012e2:	619a      	str	r2, [r3, #24]
        }
        
        break;
 80012e4:	e024      	b.n	8001330 <USB_OTG_HC_StartXfer+0x2cc>
        /* Periodic transfer */
      case EP_TYPE_INTR:
      case EP_TYPE_ISOC:
        hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 80012e6:	687b      	ldr	r3, [r7, #4]
 80012e8:	695b      	ldr	r3, [r3, #20]
 80012ea:	691b      	ldr	r3, [r3, #16]
 80012ec:	613b      	str	r3, [r7, #16]
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
 80012ee:	78fb      	ldrb	r3, [r7, #3]
 80012f0:	687a      	ldr	r2, [r7, #4]
 80012f2:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80012f6:	18d3      	adds	r3, r2, r3
 80012f8:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 80012fc:	681b      	ldr	r3, [r3, #0]
 80012fe:	f103 0303 	add.w	r3, r3, #3
 8001302:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8001306:	847b      	strh	r3, [r7, #34]	; 0x22
        /* check if there is enough space in FIFO space */
        if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
 8001308:	8a3b      	ldrh	r3, [r7, #16]
 800130a:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 800130c:	429a      	cmp	r2, r3
 800130e:	d911      	bls.n	8001334 <USB_OTG_HC_StartXfer+0x2d0>
        {
          /* need to process data in ptxfempty interrupt */
          intmsk.b.ptxfempty = 1;
 8001310:	68fb      	ldr	r3, [r7, #12]
 8001312:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8001316:	60fb      	str	r3, [r7, #12]
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
 8001318:	687b      	ldr	r3, [r7, #4]
 800131a:	68db      	ldr	r3, [r3, #12]
 800131c:	687a      	ldr	r2, [r7, #4]
 800131e:	68d2      	ldr	r2, [r2, #12]
 8001320:	6992      	ldr	r2, [r2, #24]
 8001322:	4611      	mov	r1, r2
 8001324:	68fa      	ldr	r2, [r7, #12]
 8001326:	430a      	orrs	r2, r1
 8001328:	619a      	str	r2, [r3, #24]
        }
        break;
 800132a:	e003      	b.n	8001334 <USB_OTG_HC_StartXfer+0x2d0>
        
      default:
        break;
 800132c:	bf00      	nop
 800132e:	e002      	b.n	8001336 <USB_OTG_HC_StartXfer+0x2d2>
          /* need to process data in nptxfempty interrupt */
          intmsk.b.nptxfempty = 1;
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
        }
        
        break;
 8001330:	bf00      	nop
 8001332:	e000      	b.n	8001336 <USB_OTG_HC_StartXfer+0x2d2>
        {
          /* need to process data in ptxfempty interrupt */
          intmsk.b.ptxfempty = 1;
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
        }
        break;
 8001334:	bf00      	nop
      default:
        break;
      }
      
      /* Write packet into the Tx FIFO. */
      USB_OTG_WritePacket(pdev, 
 8001336:	78fb      	ldrb	r3, [r7, #3]
                          pdev->host.hc[hc_num].xfer_buff , 
 8001338:	687a      	ldr	r2, [r7, #4]
      default:
        break;
      }
      
      /* Write packet into the Tx FIFO. */
      USB_OTG_WritePacket(pdev, 
 800133a:	f103 030d 	add.w	r3, r3, #13
 800133e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001342:	18d3      	adds	r3, r2, r3
 8001344:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8001348:	6819      	ldr	r1, [r3, #0]
                          pdev->host.hc[hc_num].xfer_buff , 
                          hc_num, pdev->host.hc[hc_num].xfer_len);
 800134a:	78fb      	ldrb	r3, [r7, #3]
 800134c:	687a      	ldr	r2, [r7, #4]
 800134e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001352:	18d3      	adds	r3, r2, r3
 8001354:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001358:	681b      	ldr	r3, [r3, #0]
      default:
        break;
      }
      
      /* Write packet into the Tx FIFO. */
      USB_OTG_WritePacket(pdev, 
 800135a:	b29b      	uxth	r3, r3
 800135c:	78fa      	ldrb	r2, [r7, #3]
 800135e:	6878      	ldr	r0, [r7, #4]
 8001360:	f7fe ffb2 	bl	80002c8 <USB_OTG_WritePacket>
                          pdev->host.hc[hc_num].xfer_buff , 
                          hc_num, pdev->host.hc[hc_num].xfer_len);
    }
  }
  return status;
 8001364:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
}
 8001368:	4618      	mov	r0, r3
 800136a:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800136e:	46bd      	mov	sp, r7
 8001370:	bd80      	pop	{r7, pc}
 8001372:	bf00      	nop

08001374 <USB_OTG_HC_Halt>:
* @param  pdev : Selected device
* @param  hc_num : channel number
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 8001374:	b480      	push	{r7}
 8001376:	b087      	sub	sp, #28
 8001378:	af00      	add	r7, sp, #0
 800137a:	6078      	str	r0, [r7, #4]
 800137c:	460b      	mov	r3, r1
 800137e:	70fb      	strb	r3, [r7, #3]
  USB_OTG_STS status = USB_OTG_OK;
 8001380:	f04f 0300 	mov.w	r3, #0
 8001384:	75fb      	strb	r3, [r7, #23]
  USB_OTG_HNPTXSTS_TypeDef            nptxsts;
  USB_OTG_HPTXSTS_TypeDef             hptxsts;
  USB_OTG_HCCHAR_TypeDef              hcchar;
  
  nptxsts.d32 = 0;
 8001386:	f04f 0300 	mov.w	r3, #0
 800138a:	613b      	str	r3, [r7, #16]
  hptxsts.d32 = 0;
 800138c:	f04f 0300 	mov.w	r3, #0
 8001390:	60fb      	str	r3, [r7, #12]
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 8001392:	78fb      	ldrb	r3, [r7, #3]
 8001394:	687a      	ldr	r2, [r7, #4]
 8001396:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800139a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800139e:	18d3      	adds	r3, r2, r3
 80013a0:	689b      	ldr	r3, [r3, #8]
 80013a2:	681b      	ldr	r3, [r3, #0]
 80013a4:	60bb      	str	r3, [r7, #8]
  hcchar.b.chen = 1;
 80013a6:	68bb      	ldr	r3, [r7, #8]
 80013a8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80013ac:	60bb      	str	r3, [r7, #8]
  hcchar.b.chdis = 1;
 80013ae:	68bb      	ldr	r3, [r7, #8]
 80013b0:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80013b4:	60bb      	str	r3, [r7, #8]
  
  /* Check for space in the request queue to issue the halt. */
  if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
 80013b6:	7abb      	ldrb	r3, [r7, #10]
 80013b8:	f003 030c 	and.w	r3, r3, #12
 80013bc:	b2db      	uxtb	r3, r3
 80013be:	2b00      	cmp	r3, #0
 80013c0:	d005      	beq.n	80013ce <USB_OTG_HC_Halt+0x5a>
 80013c2:	7abb      	ldrb	r3, [r7, #10]
 80013c4:	f003 030c 	and.w	r3, r3, #12
 80013c8:	b2db      	uxtb	r3, r3
 80013ca:	2b08      	cmp	r3, #8
 80013cc:	d10b      	bne.n	80013e6 <USB_OTG_HC_Halt+0x72>
  {
    nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 80013ce:	687b      	ldr	r3, [r7, #4]
 80013d0:	68db      	ldr	r3, [r3, #12]
 80013d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80013d4:	613b      	str	r3, [r7, #16]
    if (nptxsts.b.nptxqspcavail == 0)
 80013d6:	7cbb      	ldrb	r3, [r7, #18]
 80013d8:	2b00      	cmp	r3, #0
 80013da:	d10f      	bne.n	80013fc <USB_OTG_HC_Halt+0x88>
    {
      hcchar.b.chen = 0;
 80013dc:	68bb      	ldr	r3, [r7, #8]
 80013de:	f36f 73df 	bfc	r3, #31, #1
 80013e2:	60bb      	str	r3, [r7, #8]
  
  /* Check for space in the request queue to issue the halt. */
  if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
  {
    nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
    if (nptxsts.b.nptxqspcavail == 0)
 80013e4:	e00a      	b.n	80013fc <USB_OTG_HC_Halt+0x88>
      hcchar.b.chen = 0;
    }
  }
  else
  {
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 80013e6:	687b      	ldr	r3, [r7, #4]
 80013e8:	695b      	ldr	r3, [r3, #20]
 80013ea:	691b      	ldr	r3, [r3, #16]
 80013ec:	60fb      	str	r3, [r7, #12]
    if (hptxsts.b.ptxqspcavail == 0)
 80013ee:	7bbb      	ldrb	r3, [r7, #14]
 80013f0:	2b00      	cmp	r3, #0
 80013f2:	d103      	bne.n	80013fc <USB_OTG_HC_Halt+0x88>
    {
      hcchar.b.chen = 0;
 80013f4:	68bb      	ldr	r3, [r7, #8]
 80013f6:	f36f 73df 	bfc	r3, #31, #1
 80013fa:	60bb      	str	r3, [r7, #8]
    }
  }
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 80013fc:	78fb      	ldrb	r3, [r7, #3]
 80013fe:	687a      	ldr	r2, [r7, #4]
 8001400:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001404:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001408:	18d3      	adds	r3, r2, r3
 800140a:	689b      	ldr	r3, [r3, #8]
 800140c:	68ba      	ldr	r2, [r7, #8]
 800140e:	601a      	str	r2, [r3, #0]
  return status;
 8001410:	7dfb      	ldrb	r3, [r7, #23]
}
 8001412:	4618      	mov	r0, r3
 8001414:	f107 071c 	add.w	r7, r7, #28
 8001418:	46bd      	mov	sp, r7
 800141a:	bc80      	pop	{r7}
 800141c:	4770      	bx	lr
 800141e:	bf00      	nop

08001420 <USB_OTG_HC_DoPing>:
* @brief  Issue a ping token
* @param  None
* @retval : None
*/
USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 8001420:	b480      	push	{r7}
 8001422:	b087      	sub	sp, #28
 8001424:	af00      	add	r7, sp, #0
 8001426:	6078      	str	r0, [r7, #4]
 8001428:	460b      	mov	r3, r1
 800142a:	70fb      	strb	r3, [r7, #3]
  USB_OTG_STS               status = USB_OTG_OK;
 800142c:	f04f 0300 	mov.w	r3, #0
 8001430:	75fb      	strb	r3, [r7, #23]
  USB_OTG_HCCHAR_TypeDef    hcchar;
  USB_OTG_HCTSIZn_TypeDef   hctsiz;  
 
  hctsiz.d32 = 0;
 8001432:	f04f 0300 	mov.w	r3, #0
 8001436:	60fb      	str	r3, [r7, #12]
  hctsiz.b.dopng = 1;
 8001438:	68fb      	ldr	r3, [r7, #12]
 800143a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800143e:	60fb      	str	r3, [r7, #12]
  hctsiz.b.pktcnt = 1;
 8001440:	68fb      	ldr	r3, [r7, #12]
 8001442:	f04f 0201 	mov.w	r2, #1
 8001446:	f362 43dc 	bfi	r3, r2, #19, #10
 800144a:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 800144c:	78fb      	ldrb	r3, [r7, #3]
 800144e:	687a      	ldr	r2, [r7, #4]
 8001450:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001454:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001458:	18d3      	adds	r3, r2, r3
 800145a:	689b      	ldr	r3, [r3, #8]
 800145c:	68fa      	ldr	r2, [r7, #12]
 800145e:	611a      	str	r2, [r3, #16]
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 8001460:	78fb      	ldrb	r3, [r7, #3]
 8001462:	687a      	ldr	r2, [r7, #4]
 8001464:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001468:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800146c:	18d3      	adds	r3, r2, r3
 800146e:	689b      	ldr	r3, [r3, #8]
 8001470:	681b      	ldr	r3, [r3, #0]
 8001472:	613b      	str	r3, [r7, #16]
  hcchar.b.chen = 1;
 8001474:	693b      	ldr	r3, [r7, #16]
 8001476:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800147a:	613b      	str	r3, [r7, #16]
  hcchar.b.chdis = 0;
 800147c:	693b      	ldr	r3, [r7, #16]
 800147e:	f36f 739e 	bfc	r3, #30, #1
 8001482:	613b      	str	r3, [r7, #16]
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 8001484:	78fb      	ldrb	r3, [r7, #3]
 8001486:	687a      	ldr	r2, [r7, #4]
 8001488:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800148c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001490:	18d3      	adds	r3, r2, r3
 8001492:	689b      	ldr	r3, [r3, #8]
 8001494:	693a      	ldr	r2, [r7, #16]
 8001496:	601a      	str	r2, [r3, #0]
  return status;  
 8001498:	7dfb      	ldrb	r3, [r7, #23]
}
 800149a:	4618      	mov	r0, r3
 800149c:	f107 071c 	add.w	r7, r7, #28
 80014a0:	46bd      	mov	sp, r7
 80014a2:	bc80      	pop	{r7}
 80014a4:	4770      	bx	lr
 80014a6:	bf00      	nop

080014a8 <USB_OTG_StopHost>:
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
{
 80014a8:	b580      	push	{r7, lr}
 80014aa:	b084      	sub	sp, #16
 80014ac:	af00      	add	r7, sp, #0
 80014ae:	6078      	str	r0, [r7, #4]
  USB_OTG_HCCHAR_TypeDef  hcchar;
  uint32_t                i;
  
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
 80014b0:	687b      	ldr	r3, [r7, #4]
 80014b2:	695b      	ldr	r3, [r3, #20]
 80014b4:	f04f 0200 	mov.w	r2, #0
 80014b8:	619a      	str	r2, [r3, #24]
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
 80014ba:	687b      	ldr	r3, [r7, #4]
 80014bc:	695b      	ldr	r3, [r3, #20]
 80014be:	f04f 32ff 	mov.w	r2, #4294967295
 80014c2:	615a      	str	r2, [r3, #20]
  /* Flush out any leftover queued requests. */
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80014c4:	f04f 0300 	mov.w	r3, #0
 80014c8:	60fb      	str	r3, [r7, #12]
 80014ca:	e023      	b.n	8001514 <USB_OTG_StopHost+0x6c>
  {
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 80014cc:	687a      	ldr	r2, [r7, #4]
 80014ce:	68fb      	ldr	r3, [r7, #12]
 80014d0:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80014d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80014d8:	18d3      	adds	r3, r2, r3
 80014da:	689b      	ldr	r3, [r3, #8]
 80014dc:	681b      	ldr	r3, [r3, #0]
 80014de:	60bb      	str	r3, [r7, #8]
    hcchar.b.chen = 0;
 80014e0:	68bb      	ldr	r3, [r7, #8]
 80014e2:	f36f 73df 	bfc	r3, #31, #1
 80014e6:	60bb      	str	r3, [r7, #8]
    hcchar.b.chdis = 1;
 80014e8:	68bb      	ldr	r3, [r7, #8]
 80014ea:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80014ee:	60bb      	str	r3, [r7, #8]
    hcchar.b.epdir = 0;
 80014f0:	68bb      	ldr	r3, [r7, #8]
 80014f2:	f36f 33cf 	bfc	r3, #15, #1
 80014f6:	60bb      	str	r3, [r7, #8]
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 80014f8:	687a      	ldr	r2, [r7, #4]
 80014fa:	68fb      	ldr	r3, [r7, #12]
 80014fc:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001500:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001504:	18d3      	adds	r3, r2, r3
 8001506:	689b      	ldr	r3, [r3, #8]
 8001508:	68ba      	ldr	r2, [r7, #8]
 800150a:	601a      	str	r2, [r3, #0]
  
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
  /* Flush out any leftover queued requests. */
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 800150c:	68fb      	ldr	r3, [r7, #12]
 800150e:	f103 0301 	add.w	r3, r3, #1
 8001512:	60fb      	str	r3, [r7, #12]
 8001514:	687b      	ldr	r3, [r7, #4]
 8001516:	781b      	ldrb	r3, [r3, #0]
 8001518:	461a      	mov	r2, r3
 800151a:	68fb      	ldr	r3, [r7, #12]
 800151c:	429a      	cmp	r2, r3
 800151e:	d8d5      	bhi.n	80014cc <USB_OTG_StopHost+0x24>
    hcchar.b.epdir = 0;
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
  }
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 8001520:	6878      	ldr	r0, [r7, #4]
 8001522:	f7ff f9a7 	bl	8000874 <USB_OTG_FlushRxFifo>
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 8001526:	6878      	ldr	r0, [r7, #4]
 8001528:	f04f 0110 	mov.w	r1, #16
 800152c:	f7ff f962 	bl	80007f4 <USB_OTG_FlushTxFifo>
}
 8001530:	f107 0710 	add.w	r7, r7, #16
 8001534:	46bd      	mov	sp, r7
 8001536:	bd80      	pop	{r7, pc}

08001538 <HCD_Init>:
  * @param  base_address: OTG base address
  * @retval Status
  */
uint32_t HCD_Init(USB_OTG_CORE_HANDLE *pdev , 
                  USB_OTG_CORE_ID_TypeDef coreID)
{
 8001538:	b580      	push	{r7, lr}
 800153a:	b084      	sub	sp, #16
 800153c:	af00      	add	r7, sp, #0
 800153e:	6078      	str	r0, [r7, #4]
 8001540:	460b      	mov	r3, r1
 8001542:	70fb      	strb	r3, [r7, #3]
  uint8_t i = 0;
 8001544:	f04f 0300 	mov.w	r3, #0
 8001548:	73fb      	strb	r3, [r7, #15]
  pdev->host.ConnSts = 0;
 800154a:	687b      	ldr	r3, [r7, #4]
 800154c:	f04f 0200 	mov.w	r2, #0
 8001550:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  
  for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
 8001554:	f04f 0300 	mov.w	r3, #0
 8001558:	73fb      	strb	r3, [r7, #15]
 800155a:	e01c      	b.n	8001596 <HCD_Init+0x5e>
  {
  pdev->host.ErrCnt[i]  = 0;
 800155c:	7bfb      	ldrb	r3, [r7, #15]
 800155e:	687a      	ldr	r2, [r7, #4]
 8001560:	f103 0384 	add.w	r3, r3, #132	; 0x84
 8001564:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001568:	18d3      	adds	r3, r2, r3
 800156a:	f04f 0200 	mov.w	r2, #0
 800156e:	605a      	str	r2, [r3, #4]
  pdev->host.XferCnt[i]   = 0;
 8001570:	7bfa      	ldrb	r2, [r7, #15]
 8001572:	687b      	ldr	r3, [r7, #4]
 8001574:	f102 0294 	add.w	r2, r2, #148	; 0x94
 8001578:	f04f 0100 	mov.w	r1, #0
 800157c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->host.HC_Status[i]   = HC_IDLE;
 8001580:	7bfb      	ldrb	r3, [r7, #15]
 8001582:	687a      	ldr	r2, [r7, #4]
 8001584:	18d3      	adds	r3, r2, r3
 8001586:	f04f 0200 	mov.w	r2, #0
 800158a:	f883 228c 	strb.w	r2, [r3, #652]	; 0x28c
                  USB_OTG_CORE_ID_TypeDef coreID)
{
  uint8_t i = 0;
  pdev->host.ConnSts = 0;
  
  for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
 800158e:	7bfb      	ldrb	r3, [r7, #15]
 8001590:	f103 0301 	add.w	r3, r3, #1
 8001594:	73fb      	strb	r3, [r7, #15]
 8001596:	7bfb      	ldrb	r3, [r7, #15]
 8001598:	2b0e      	cmp	r3, #14
 800159a:	d9df      	bls.n	800155c <HCD_Init+0x24>
  {
  pdev->host.ErrCnt[i]  = 0;
  pdev->host.XferCnt[i]   = 0;
  pdev->host.HC_Status[i]   = HC_IDLE;
  }
  pdev->host.hc[0].max_packet  = 8; 
 800159c:	687b      	ldr	r3, [r7, #4]
 800159e:	f04f 0208 	mov.w	r2, #8
 80015a2:	f8a3 22b2 	strh.w	r2, [r3, #690]	; 0x2b2

  USB_OTG_SelectCore(pdev, coreID);
 80015a6:	78fb      	ldrb	r3, [r7, #3]
 80015a8:	6878      	ldr	r0, [r7, #4]
 80015aa:	4619      	mov	r1, r3
 80015ac:	f7fe ff02 	bl	80003b4 <USB_OTG_SelectCore>
#ifndef DUAL_ROLE_MODE_ENABLED
  USB_OTG_DisableGlobalInt(pdev);
 80015b0:	6878      	ldr	r0, [r7, #4]
 80015b2:	f7ff f8ff 	bl	80007b4 <USB_OTG_DisableGlobalInt>
  USB_OTG_CoreInit(pdev);
 80015b6:	6878      	ldr	r0, [r7, #4]
 80015b8:	f7fe ffde 	bl	8000578 <USB_OTG_CoreInit>

  /* Force Host Mode*/
  USB_OTG_SetCurrentMode(pdev , HOST_MODE);
 80015bc:	6878      	ldr	r0, [r7, #4]
 80015be:	f04f 0101 	mov.w	r1, #1
 80015c2:	f7ff f98d 	bl	80008e0 <USB_OTG_SetCurrentMode>
  USB_OTG_CoreInitHost(pdev);
 80015c6:	6878      	ldr	r0, [r7, #4]
 80015c8:	f7ff fa16 	bl	80009f8 <USB_OTG_CoreInitHost>
  USB_OTG_EnableGlobalInt(pdev);
 80015cc:	6878      	ldr	r0, [r7, #4]
 80015ce:	f7ff f8d3 	bl	8000778 <USB_OTG_EnableGlobalInt>
#endif
   
  return 0;
 80015d2:	f04f 0300 	mov.w	r3, #0
}
 80015d6:	4618      	mov	r0, r3
 80015d8:	f107 0710 	add.w	r7, r7, #16
 80015dc:	46bd      	mov	sp, r7
 80015de:	bd80      	pop	{r7, pc}

080015e0 <HCD_GetCurrentSpeed>:
  * @param  pdev : Selected device
  * @retval Status
  */

uint32_t HCD_GetCurrentSpeed (USB_OTG_CORE_HANDLE *pdev)
{    
 80015e0:	b480      	push	{r7}
 80015e2:	b085      	sub	sp, #20
 80015e4:	af00      	add	r7, sp, #0
 80015e6:	6078      	str	r0, [r7, #4]
    USB_OTG_HPRT0_TypeDef  HPRT0;
    HPRT0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 80015e8:	687b      	ldr	r3, [r7, #4]
 80015ea:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80015ee:	681b      	ldr	r3, [r3, #0]
 80015f0:	60fb      	str	r3, [r7, #12]
    
    return HPRT0.b.prtspd;
 80015f2:	68fb      	ldr	r3, [r7, #12]
 80015f4:	f3c3 4341 	ubfx	r3, r3, #17, #2
 80015f8:	b2db      	uxtb	r3, r3
}
 80015fa:	4618      	mov	r0, r3
 80015fc:	f107 0714 	add.w	r7, r7, #20
 8001600:	46bd      	mov	sp, r7
 8001602:	bc80      	pop	{r7}
 8001604:	4770      	bx	lr
 8001606:	bf00      	nop

08001608 <HCD_ResetPort>:
  *         Issues the reset command to device
  * @param  pdev : Selected device
  * @retval Status
  */
uint32_t HCD_ResetPort(USB_OTG_CORE_HANDLE *pdev)
{
 8001608:	b580      	push	{r7, lr}
 800160a:	b082      	sub	sp, #8
 800160c:	af00      	add	r7, sp, #0
 800160e:	6078      	str	r0, [r7, #4]
  interrupt triggered by the debounce done bit (DBCDNE bit in OTG_FS_GOTGINT), 
  which indicates that the bus is stable again after the electrical debounce 
  caused by the attachment of a pull-up resistor on DP (FS) or DM (LS).
  */
  
  USB_OTG_ResetPort(pdev); 
 8001610:	6878      	ldr	r0, [r7, #4]
 8001612:	f7ff fb91 	bl	8000d38 <USB_OTG_ResetPort>
  return 0;
 8001616:	f04f 0300 	mov.w	r3, #0
}
 800161a:	4618      	mov	r0, r3
 800161c:	f107 0708 	add.w	r7, r7, #8
 8001620:	46bd      	mov	sp, r7
 8001622:	bd80      	pop	{r7, pc}

08001624 <HCD_IsDeviceConnected>:
  * @param  pdev : Selected device
  * @retval Device connection status. 1 -> connected and 0 -> disconnected
  * 
  */
uint32_t HCD_IsDeviceConnected(USB_OTG_CORE_HANDLE *pdev)
{
 8001624:	b480      	push	{r7}
 8001626:	b083      	sub	sp, #12
 8001628:	af00      	add	r7, sp, #0
 800162a:	6078      	str	r0, [r7, #4]
  return (pdev->host.ConnSts);
 800162c:	687b      	ldr	r3, [r7, #4]
 800162e:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
}
 8001632:	4618      	mov	r0, r3
 8001634:	f107 070c 	add.w	r7, r7, #12
 8001638:	46bd      	mov	sp, r7
 800163a:	bc80      	pop	{r7}
 800163c:	4770      	bx	lr
 800163e:	bf00      	nop

08001640 <HCD_GetCurrentFrame>:
  * @param  pdev : Selected device
  * @retval Frame number
  * 
  */
uint32_t HCD_GetCurrentFrame (USB_OTG_CORE_HANDLE *pdev) 
{
 8001640:	b480      	push	{r7}
 8001642:	b083      	sub	sp, #12
 8001644:	af00      	add	r7, sp, #0
 8001646:	6078      	str	r0, [r7, #4]
 return (USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0xFFFF) ;
 8001648:	687b      	ldr	r3, [r7, #4]
 800164a:	695b      	ldr	r3, [r3, #20]
 800164c:	689b      	ldr	r3, [r3, #8]
 800164e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8001652:	ea4f 4313 	mov.w	r3, r3, lsr #16
}
 8001656:	4618      	mov	r0, r3
 8001658:	f107 070c 	add.w	r7, r7, #12
 800165c:	46bd      	mov	sp, r7
 800165e:	bc80      	pop	{r7}
 8001660:	4770      	bx	lr
 8001662:	bf00      	nop

08001664 <HCD_GetURB_State>:
  * @param  pdev: Selected device
  * @retval URB_STATE
  * 
  */
URB_STATE HCD_GetURB_State (USB_OTG_CORE_HANDLE *pdev , uint8_t ch_num) 
{
 8001664:	b480      	push	{r7}
 8001666:	b083      	sub	sp, #12
 8001668:	af00      	add	r7, sp, #0
 800166a:	6078      	str	r0, [r7, #4]
 800166c:	460b      	mov	r3, r1
 800166e:	70fb      	strb	r3, [r7, #3]
  return pdev->host.URB_State[ch_num] ;
 8001670:	78fb      	ldrb	r3, [r7, #3]
 8001672:	687a      	ldr	r2, [r7, #4]
 8001674:	18d3      	adds	r3, r2, r3
 8001676:	f893 329b 	ldrb.w	r3, [r3, #667]	; 0x29b
 800167a:	b2db      	uxtb	r3, r3
}
 800167c:	4618      	mov	r0, r3
 800167e:	f107 070c 	add.w	r7, r7, #12
 8001682:	46bd      	mov	sp, r7
 8001684:	bc80      	pop	{r7}
 8001686:	4770      	bx	lr

08001688 <HCD_GetXferCnt>:
  * @param  pdev: Selected device
  * @retval No. of data bytes transferred
  * 
  */
uint32_t HCD_GetXferCnt (USB_OTG_CORE_HANDLE *pdev, uint8_t ch_num) 
{
 8001688:	b480      	push	{r7}
 800168a:	b083      	sub	sp, #12
 800168c:	af00      	add	r7, sp, #0
 800168e:	6078      	str	r0, [r7, #4]
 8001690:	460b      	mov	r3, r1
 8001692:	70fb      	strb	r3, [r7, #3]
  return pdev->host.XferCnt[ch_num] ;
 8001694:	78fa      	ldrb	r2, [r7, #3]
 8001696:	687b      	ldr	r3, [r7, #4]
 8001698:	f102 0294 	add.w	r2, r2, #148	; 0x94
 800169c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
}
 80016a0:	4618      	mov	r0, r3
 80016a2:	f107 070c 	add.w	r7, r7, #12
 80016a6:	46bd      	mov	sp, r7
 80016a8:	bc80      	pop	{r7}
 80016aa:	4770      	bx	lr

080016ac <HCD_GetHCState>:
  * @param  pdev: Selected device
  * @retval HC_STATUS
  * 
  */
HC_STATUS HCD_GetHCState (USB_OTG_CORE_HANDLE *pdev ,  uint8_t ch_num) 
{
 80016ac:	b480      	push	{r7}
 80016ae:	b083      	sub	sp, #12
 80016b0:	af00      	add	r7, sp, #0
 80016b2:	6078      	str	r0, [r7, #4]
 80016b4:	460b      	mov	r3, r1
 80016b6:	70fb      	strb	r3, [r7, #3]
  return pdev->host.HC_Status[ch_num] ;
 80016b8:	78fb      	ldrb	r3, [r7, #3]
 80016ba:	687a      	ldr	r2, [r7, #4]
 80016bc:	18d3      	adds	r3, r2, r3
 80016be:	f893 328c 	ldrb.w	r3, [r3, #652]	; 0x28c
 80016c2:	b2db      	uxtb	r3, r3
}
 80016c4:	4618      	mov	r0, r3
 80016c6:	f107 070c 	add.w	r7, r7, #12
 80016ca:	46bd      	mov	sp, r7
 80016cc:	bc80      	pop	{r7}
 80016ce:	4770      	bx	lr

080016d0 <HCD_HC_Init>:
  * @param  pdev: Selected device
  * @param  hc_num: Channel number 
  * @retval status 
  */
uint32_t HCD_HC_Init (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
{
 80016d0:	b580      	push	{r7, lr}
 80016d2:	b082      	sub	sp, #8
 80016d4:	af00      	add	r7, sp, #0
 80016d6:	6078      	str	r0, [r7, #4]
 80016d8:	460b      	mov	r3, r1
 80016da:	70fb      	strb	r3, [r7, #3]
  return USB_OTG_HC_Init(pdev, hc_num);  
 80016dc:	78fb      	ldrb	r3, [r7, #3]
 80016de:	6878      	ldr	r0, [r7, #4]
 80016e0:	4619      	mov	r1, r3
 80016e2:	f7ff fb53 	bl	8000d8c <USB_OTG_HC_Init>
 80016e6:	4603      	mov	r3, r0
}
 80016e8:	4618      	mov	r0, r3
 80016ea:	f107 0708 	add.w	r7, r7, #8
 80016ee:	46bd      	mov	sp, r7
 80016f0:	bd80      	pop	{r7, pc}
 80016f2:	bf00      	nop

080016f4 <HCD_SubmitRequest>:
  * @param  pdev: Selected device
  * @param  hc_num: Channel number 
  * @retval status
  */
uint32_t HCD_SubmitRequest (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
{
 80016f4:	b580      	push	{r7, lr}
 80016f6:	b082      	sub	sp, #8
 80016f8:	af00      	add	r7, sp, #0
 80016fa:	6078      	str	r0, [r7, #4]
 80016fc:	460b      	mov	r3, r1
 80016fe:	70fb      	strb	r3, [r7, #3]
  
  pdev->host.URB_State[hc_num] =   URB_IDLE;  
 8001700:	78fb      	ldrb	r3, [r7, #3]
 8001702:	687a      	ldr	r2, [r7, #4]
 8001704:	18d3      	adds	r3, r2, r3
 8001706:	f04f 0200 	mov.w	r2, #0
 800170a:	f883 229b 	strb.w	r2, [r3, #667]	; 0x29b
  pdev->host.hc[hc_num].xfer_count = 0 ;
 800170e:	78fb      	ldrb	r3, [r7, #3]
 8001710:	687a      	ldr	r2, [r7, #4]
 8001712:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001716:	18d3      	adds	r3, r2, r3
 8001718:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 800171c:	f04f 0200 	mov.w	r2, #0
 8001720:	601a      	str	r2, [r3, #0]
  return USB_OTG_HC_StartXfer(pdev, hc_num);
 8001722:	78fb      	ldrb	r3, [r7, #3]
 8001724:	6878      	ldr	r0, [r7, #4]
 8001726:	4619      	mov	r1, r3
 8001728:	f7ff fc9c 	bl	8001064 <USB_OTG_HC_StartXfer>
 800172c:	4603      	mov	r3, r0
}
 800172e:	4618      	mov	r0, r3
 8001730:	f107 0708 	add.w	r7, r7, #8
 8001734:	46bd      	mov	sp, r7
 8001736:	bd80      	pop	{r7, pc}

08001738 <USBH_OTG_ISR_Handler>:
  * @param  pdev: Selected device
  * @retval status 
  */

uint32_t USBH_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 8001738:	b580      	push	{r7, lr}
 800173a:	b084      	sub	sp, #16
 800173c:	af00      	add	r7, sp, #0
 800173e:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTSTS_TypeDef  gintsts;
  uint32_t retval = 0;
 8001740:	f04f 0300 	mov.w	r3, #0
 8001744:	60fb      	str	r3, [r7, #12]
  
  gintsts.d32 = 0;
 8001746:	f04f 0300 	mov.w	r3, #0
 800174a:	60bb      	str	r3, [r7, #8]
  
  /* Check if HOST Mode */
  if (USB_OTG_IsHostMode(pdev))
 800174c:	6878      	ldr	r0, [r7, #4]
 800174e:	f7ff f91b 	bl	8000988 <USB_OTG_IsHostMode>
 8001752:	4603      	mov	r3, r0
 8001754:	2b00      	cmp	r3, #0
 8001756:	d072      	beq.n	800183e <USBH_OTG_ISR_Handler+0x106>
  {
    gintsts.d32 = USB_OTG_ReadCoreItr(pdev);
 8001758:	6878      	ldr	r0, [r7, #4]
 800175a:	f7ff f927 	bl	80009ac <USB_OTG_ReadCoreItr>
 800175e:	4603      	mov	r3, r0
 8001760:	60bb      	str	r3, [r7, #8]
    if (!gintsts.d32)
 8001762:	68bb      	ldr	r3, [r7, #8]
 8001764:	2b00      	cmp	r3, #0
 8001766:	d102      	bne.n	800176e <USBH_OTG_ISR_Handler+0x36>
    {
      return 0;
 8001768:	f04f 0300 	mov.w	r3, #0
 800176c:	e068      	b.n	8001840 <USBH_OTG_ISR_Handler+0x108>
    }
    
    if (gintsts.b.sofintr)
 800176e:	7a3b      	ldrb	r3, [r7, #8]
 8001770:	f003 0308 	and.w	r3, r3, #8
 8001774:	b2db      	uxtb	r3, r3
 8001776:	2b00      	cmp	r3, #0
 8001778:	d006      	beq.n	8001788 <USBH_OTG_ISR_Handler+0x50>
    {
      retval |= USB_OTG_USBH_handle_sof_ISR (pdev);
 800177a:	6878      	ldr	r0, [r7, #4]
 800177c:	f000 f8b4 	bl	80018e8 <USB_OTG_USBH_handle_sof_ISR>
 8001780:	4603      	mov	r3, r0
 8001782:	68fa      	ldr	r2, [r7, #12]
 8001784:	4313      	orrs	r3, r2
 8001786:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.rxstsqlvl)
 8001788:	7a3b      	ldrb	r3, [r7, #8]
 800178a:	f003 0310 	and.w	r3, r3, #16
 800178e:	b2db      	uxtb	r3, r3
 8001790:	2b00      	cmp	r3, #0
 8001792:	d006      	beq.n	80017a2 <USBH_OTG_ISR_Handler+0x6a>
    {
      retval |= USB_OTG_USBH_handle_rx_qlvl_ISR (pdev);
 8001794:	6878      	ldr	r0, [r7, #4]
 8001796:	f001 f907 	bl	80029a8 <USB_OTG_USBH_handle_rx_qlvl_ISR>
 800179a:	4603      	mov	r3, r0
 800179c:	68fa      	ldr	r2, [r7, #12]
 800179e:	4313      	orrs	r3, r2
 80017a0:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.nptxfempty)
 80017a2:	7a3b      	ldrb	r3, [r7, #8]
 80017a4:	f003 0320 	and.w	r3, r3, #32
 80017a8:	b2db      	uxtb	r3, r3
 80017aa:	2b00      	cmp	r3, #0
 80017ac:	d006      	beq.n	80017bc <USBH_OTG_ISR_Handler+0x84>
    {
      retval |= USB_OTG_USBH_handle_nptxfempty_ISR (pdev);
 80017ae:	6878      	ldr	r0, [r7, #4]
 80017b0:	f000 f8d4 	bl	800195c <USB_OTG_USBH_handle_nptxfempty_ISR>
 80017b4:	4603      	mov	r3, r0
 80017b6:	68fa      	ldr	r2, [r7, #12]
 80017b8:	4313      	orrs	r3, r2
 80017ba:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.ptxfempty)
 80017bc:	7afb      	ldrb	r3, [r7, #11]
 80017be:	f003 0304 	and.w	r3, r3, #4
 80017c2:	b2db      	uxtb	r3, r3
 80017c4:	2b00      	cmp	r3, #0
 80017c6:	d006      	beq.n	80017d6 <USBH_OTG_ISR_Handler+0x9e>
    {
      retval |= USB_OTG_USBH_handle_ptxfempty_ISR (pdev);
 80017c8:	6878      	ldr	r0, [r7, #4]
 80017ca:	f000 f99f 	bl	8001b0c <USB_OTG_USBH_handle_ptxfempty_ISR>
 80017ce:	4603      	mov	r3, r0
 80017d0:	68fa      	ldr	r2, [r7, #12]
 80017d2:	4313      	orrs	r3, r2
 80017d4:	60fb      	str	r3, [r7, #12]
    }    
    
    if (gintsts.b.hcintr)
 80017d6:	7afb      	ldrb	r3, [r7, #11]
 80017d8:	f003 0302 	and.w	r3, r3, #2
 80017dc:	b2db      	uxtb	r3, r3
 80017de:	2b00      	cmp	r3, #0
 80017e0:	d006      	beq.n	80017f0 <USBH_OTG_ISR_Handler+0xb8>
    {
      retval |= USB_OTG_USBH_handle_hc_ISR (pdev);
 80017e2:	6878      	ldr	r0, [r7, #4]
 80017e4:	f000 f832 	bl	800184c <USB_OTG_USBH_handle_hc_ISR>
 80017e8:	4603      	mov	r3, r0
 80017ea:	68fa      	ldr	r2, [r7, #12]
 80017ec:	4313      	orrs	r3, r2
 80017ee:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.portintr)
 80017f0:	7afb      	ldrb	r3, [r7, #11]
 80017f2:	f003 0301 	and.w	r3, r3, #1
 80017f6:	b2db      	uxtb	r3, r3
 80017f8:	2b00      	cmp	r3, #0
 80017fa:	d006      	beq.n	800180a <USBH_OTG_ISR_Handler+0xd2>
    {
      retval |= USB_OTG_USBH_handle_port_ISR (pdev);
 80017fc:	6878      	ldr	r0, [r7, #4]
 80017fe:	f000 fa5d 	bl	8001cbc <USB_OTG_USBH_handle_port_ISR>
 8001802:	4603      	mov	r3, r0
 8001804:	68fa      	ldr	r2, [r7, #12]
 8001806:	4313      	orrs	r3, r2
 8001808:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.disconnect)
 800180a:	7afb      	ldrb	r3, [r7, #11]
 800180c:	f003 0320 	and.w	r3, r3, #32
 8001810:	b2db      	uxtb	r3, r3
 8001812:	2b00      	cmp	r3, #0
 8001814:	d006      	beq.n	8001824 <USBH_OTG_ISR_Handler+0xec>
    {
      retval |= USB_OTG_USBH_handle_Disconnect_ISR (pdev);  
 8001816:	6878      	ldr	r0, [r7, #4]
 8001818:	f000 f87e 	bl	8001918 <USB_OTG_USBH_handle_Disconnect_ISR>
 800181c:	4603      	mov	r3, r0
 800181e:	68fa      	ldr	r2, [r7, #12]
 8001820:	4313      	orrs	r3, r2
 8001822:	60fb      	str	r3, [r7, #12]
      
    }
    
     if (gintsts.b.incomplisoout)
 8001824:	7abb      	ldrb	r3, [r7, #10]
 8001826:	f003 0320 	and.w	r3, r3, #32
 800182a:	b2db      	uxtb	r3, r3
 800182c:	2b00      	cmp	r3, #0
 800182e:	d006      	beq.n	800183e <USBH_OTG_ISR_Handler+0x106>
      {
         retval |= USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (pdev);
 8001830:	6878      	ldr	r0, [r7, #4]
 8001832:	f001 f99f 	bl	8002b74 <USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR>
 8001836:	4603      	mov	r3, r0
 8001838:	68fa      	ldr	r2, [r7, #12]
 800183a:	4313      	orrs	r3, r2
 800183c:	60fb      	str	r3, [r7, #12]
      }
      
    
  }
  return retval;
 800183e:	68fb      	ldr	r3, [r7, #12]
}
 8001840:	4618      	mov	r0, r3
 8001842:	f107 0710 	add.w	r7, r7, #16
 8001846:	46bd      	mov	sp, r7
 8001848:	bd80      	pop	{r7, pc}
 800184a:	bf00      	nop

0800184c <USB_OTG_USBH_handle_hc_ISR>:
  *         This function indicates that one or more host channels has a pending
  * @param  pdev: Selected device
  * @retval status 
  */
static uint32_t USB_OTG_USBH_handle_hc_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 800184c:	b580      	push	{r7, lr}
 800184e:	b086      	sub	sp, #24
 8001850:	af00      	add	r7, sp, #0
 8001852:	6078      	str	r0, [r7, #4]
  USB_OTG_HAINT_TypeDef        haint;
  USB_OTG_HCCHAR_TypeDef       hcchar;
  uint32_t i = 0;
 8001854:	f04f 0300 	mov.w	r3, #0
 8001858:	617b      	str	r3, [r7, #20]
  uint32_t retval = 0;
 800185a:	f04f 0300 	mov.w	r3, #0
 800185e:	613b      	str	r3, [r7, #16]
  
  /* Clear appropriate bits in HCINTn to clear the interrupt bit in
  * GINTSTS */
  
  haint.d32 = USB_OTG_ReadHostAllChannels_intr(pdev);
 8001860:	6878      	ldr	r0, [r7, #4]
 8001862:	f7ff fa5b 	bl	8000d1c <USB_OTG_ReadHostAllChannels_intr>
 8001866:	4603      	mov	r3, r0
 8001868:	60fb      	str	r3, [r7, #12]
  
  for (i = 0; i < pdev->cfg.host_channels ; i++)
 800186a:	f04f 0300 	mov.w	r3, #0
 800186e:	617b      	str	r3, [r7, #20]
 8001870:	e02e      	b.n	80018d0 <USB_OTG_USBH_handle_hc_ISR+0x84>
  {
    if (haint.b.chint & (1 << i))
 8001872:	89bb      	ldrh	r3, [r7, #12]
 8001874:	461a      	mov	r2, r3
 8001876:	697b      	ldr	r3, [r7, #20]
 8001878:	fa42 f303 	asr.w	r3, r2, r3
 800187c:	f003 0301 	and.w	r3, r3, #1
 8001880:	b2db      	uxtb	r3, r3
 8001882:	2b00      	cmp	r3, #0
 8001884:	d020      	beq.n	80018c8 <USB_OTG_USBH_handle_hc_ISR+0x7c>
    {
      hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 8001886:	687a      	ldr	r2, [r7, #4]
 8001888:	697b      	ldr	r3, [r7, #20]
 800188a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800188e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001892:	18d3      	adds	r3, r2, r3
 8001894:	689b      	ldr	r3, [r3, #8]
 8001896:	681b      	ldr	r3, [r3, #0]
 8001898:	60bb      	str	r3, [r7, #8]
      
      if (hcchar.b.epdir)
 800189a:	7a7b      	ldrb	r3, [r7, #9]
 800189c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80018a0:	b2db      	uxtb	r3, r3
 80018a2:	2b00      	cmp	r3, #0
 80018a4:	d008      	beq.n	80018b8 <USB_OTG_USBH_handle_hc_ISR+0x6c>
      {
        retval |= USB_OTG_USBH_handle_hc_n_In_ISR (pdev, i);
 80018a6:	6878      	ldr	r0, [r7, #4]
 80018a8:	6979      	ldr	r1, [r7, #20]
 80018aa:	f000 fd77 	bl	800239c <USB_OTG_USBH_handle_hc_n_In_ISR>
 80018ae:	4603      	mov	r3, r0
 80018b0:	693a      	ldr	r2, [r7, #16]
 80018b2:	4313      	orrs	r3, r2
 80018b4:	613b      	str	r3, [r7, #16]
 80018b6:	e007      	b.n	80018c8 <USB_OTG_USBH_handle_hc_ISR+0x7c>
      }
      else
      {
        retval |=  USB_OTG_USBH_handle_hc_n_Out_ISR (pdev, i);
 80018b8:	6878      	ldr	r0, [r7, #4]
 80018ba:	6979      	ldr	r1, [r7, #20]
 80018bc:	f000 fabe 	bl	8001e3c <USB_OTG_USBH_handle_hc_n_Out_ISR>
 80018c0:	4603      	mov	r3, r0
 80018c2:	693a      	ldr	r2, [r7, #16]
 80018c4:	4313      	orrs	r3, r2
 80018c6:	613b      	str	r3, [r7, #16]
  /* Clear appropriate bits in HCINTn to clear the interrupt bit in
  * GINTSTS */
  
  haint.d32 = USB_OTG_ReadHostAllChannels_intr(pdev);
  
  for (i = 0; i < pdev->cfg.host_channels ; i++)
 80018c8:	697b      	ldr	r3, [r7, #20]
 80018ca:	f103 0301 	add.w	r3, r3, #1
 80018ce:	617b      	str	r3, [r7, #20]
 80018d0:	687b      	ldr	r3, [r7, #4]
 80018d2:	781b      	ldrb	r3, [r3, #0]
 80018d4:	461a      	mov	r2, r3
 80018d6:	697b      	ldr	r3, [r7, #20]
 80018d8:	429a      	cmp	r2, r3
 80018da:	d8ca      	bhi.n	8001872 <USB_OTG_USBH_handle_hc_ISR+0x26>
        retval |=  USB_OTG_USBH_handle_hc_n_Out_ISR (pdev, i);
      }
    }
  }
  
  return retval;
 80018dc:	693b      	ldr	r3, [r7, #16]
}
 80018de:	4618      	mov	r0, r3
 80018e0:	f107 0718 	add.w	r7, r7, #24
 80018e4:	46bd      	mov	sp, r7
 80018e6:	bd80      	pop	{r7, pc}

080018e8 <USB_OTG_USBH_handle_sof_ISR>:
  *         Handles the start-of-frame interrupt in host mode.
  * @param  pdev: Selected device
  * @retval status 
  */
static uint32_t USB_OTG_USBH_handle_sof_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 80018e8:	b480      	push	{r7}
 80018ea:	b085      	sub	sp, #20
 80018ec:	af00      	add	r7, sp, #0
 80018ee:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTSTS_TypeDef      gintsts;
  
  
  gintsts.d32 = 0;
 80018f0:	f04f 0300 	mov.w	r3, #0
 80018f4:	60fb      	str	r3, [r7, #12]
  /* Clear interrupt */
  gintsts.b.sofintr = 1;
 80018f6:	68fb      	ldr	r3, [r7, #12]
 80018f8:	f043 0308 	orr.w	r3, r3, #8
 80018fc:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80018fe:	687b      	ldr	r3, [r7, #4]
 8001900:	68db      	ldr	r3, [r3, #12]
 8001902:	68fa      	ldr	r2, [r7, #12]
 8001904:	615a      	str	r2, [r3, #20]
  
  return 1;
 8001906:	f04f 0301 	mov.w	r3, #1
}
 800190a:	4618      	mov	r0, r3
 800190c:	f107 0714 	add.w	r7, r7, #20
 8001910:	46bd      	mov	sp, r7
 8001912:	bc80      	pop	{r7}
 8001914:	4770      	bx	lr
 8001916:	bf00      	nop

08001918 <USB_OTG_USBH_handle_Disconnect_ISR>:
  *         Handles disconnect event.
  * @param  pdev: Selected device
  * @retval status 
  */
static uint32_t USB_OTG_USBH_handle_Disconnect_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8001918:	b580      	push	{r7, lr}
 800191a:	b084      	sub	sp, #16
 800191c:	af00      	add	r7, sp, #0
 800191e:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTSTS_TypeDef      gintsts;
  
  pdev->host.ConnSts = 0;
 8001920:	687b      	ldr	r3, [r7, #4]
 8001922:	f04f 0200 	mov.w	r2, #0
 8001926:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  gintsts.d32 = 0;
 800192a:	f04f 0300 	mov.w	r3, #0
 800192e:	60fb      	str	r3, [r7, #12]
  
  pdev->host.port_cb->Disconnect(pdev);
 8001930:	687b      	ldr	r3, [r7, #4]
 8001932:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8001936:	681b      	ldr	r3, [r3, #0]
 8001938:	6878      	ldr	r0, [r7, #4]
 800193a:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.disconnect = 1;
 800193c:	68fb      	ldr	r3, [r7, #12]
 800193e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001942:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8001944:	687b      	ldr	r3, [r7, #4]
 8001946:	68db      	ldr	r3, [r3, #12]
 8001948:	68fa      	ldr	r2, [r7, #12]
 800194a:	615a      	str	r2, [r3, #20]
  
  return 1;
 800194c:	f04f 0301 	mov.w	r3, #1
}
 8001950:	4618      	mov	r0, r3
 8001952:	f107 0710 	add.w	r7, r7, #16
 8001956:	46bd      	mov	sp, r7
 8001958:	bd80      	pop	{r7, pc}
 800195a:	bf00      	nop

0800195c <USB_OTG_USBH_handle_nptxfempty_ISR>:
  *         Handles non periodic tx fifo empty.
  * @param  pdev: Selected device
  * @retval status 
  */
static uint32_t USB_OTG_USBH_handle_nptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 800195c:	b580      	push	{r7, lr}
 800195e:	b086      	sub	sp, #24
 8001960:	af00      	add	r7, sp, #0
 8001962:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTMSK_TypeDef      intmsk;
  USB_OTG_HNPTXSTS_TypeDef     hnptxsts; 
  uint16_t                     len_words , len; 
  
  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 8001964:	687b      	ldr	r3, [r7, #4]
 8001966:	68db      	ldr	r3, [r3, #12]
 8001968:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800196a:	60fb      	str	r3, [r7, #12]
  
  len_words = (pdev->host.hc[hnptxsts.b.chnum].xfer_len + 3) / 4;
 800196c:	68fb      	ldr	r3, [r7, #12]
 800196e:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001972:	b2db      	uxtb	r3, r3
 8001974:	687a      	ldr	r2, [r7, #4]
 8001976:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800197a:	18d3      	adds	r3, r2, r3
 800197c:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001980:	681b      	ldr	r3, [r3, #0]
 8001982:	f103 0303 	add.w	r3, r3, #3
 8001986:	ea4f 0393 	mov.w	r3, r3, lsr #2
 800198a:	82fb      	strh	r3, [r7, #22]
  
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 800198c:	e0a5      	b.n	8001ada <USB_OTG_USBH_handle_nptxfempty_ISR+0x17e>
      (pdev->host.hc[hnptxsts.b.chnum].xfer_len != 0))
  {
    
    len = hnptxsts.b.nptxfspcavail * 4;
 800198e:	89bb      	ldrh	r3, [r7, #12]
 8001990:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001994:	82bb      	strh	r3, [r7, #20]
    
    if (len > pdev->host.hc[hnptxsts.b.chnum].xfer_len)
 8001996:	8aba      	ldrh	r2, [r7, #20]
 8001998:	68fb      	ldr	r3, [r7, #12]
 800199a:	f3c3 7341 	ubfx	r3, r3, #29, #2
 800199e:	b2db      	uxtb	r3, r3
 80019a0:	6879      	ldr	r1, [r7, #4]
 80019a2:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80019a6:	18cb      	adds	r3, r1, r3
 80019a8:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 80019ac:	681b      	ldr	r3, [r3, #0]
 80019ae:	429a      	cmp	r2, r3
 80019b0:	d91d      	bls.n	80019ee <USB_OTG_USBH_handle_nptxfempty_ISR+0x92>
    {
      /* Last packet */
      len = pdev->host.hc[hnptxsts.b.chnum].xfer_len;
 80019b2:	68fb      	ldr	r3, [r7, #12]
 80019b4:	f3c3 7341 	ubfx	r3, r3, #29, #2
 80019b8:	b2db      	uxtb	r3, r3
 80019ba:	687a      	ldr	r2, [r7, #4]
 80019bc:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80019c0:	18d3      	adds	r3, r2, r3
 80019c2:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 80019c6:	681b      	ldr	r3, [r3, #0]
 80019c8:	82bb      	strh	r3, [r7, #20]
      
      intmsk.d32 = 0;
 80019ca:	f04f 0300 	mov.w	r3, #0
 80019ce:	613b      	str	r3, [r7, #16]
      intmsk.b.nptxfempty = 1;
 80019d0:	693b      	ldr	r3, [r7, #16]
 80019d2:	f043 0320 	orr.w	r3, r3, #32
 80019d6:	613b      	str	r3, [r7, #16]
      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);       
 80019d8:	687b      	ldr	r3, [r7, #4]
 80019da:	68db      	ldr	r3, [r3, #12]
 80019dc:	687a      	ldr	r2, [r7, #4]
 80019de:	68d2      	ldr	r2, [r2, #12]
 80019e0:	6992      	ldr	r2, [r2, #24]
 80019e2:	4611      	mov	r1, r2
 80019e4:	693a      	ldr	r2, [r7, #16]
 80019e6:	ea6f 0202 	mvn.w	r2, r2
 80019ea:	400a      	ands	r2, r1
 80019ec:	619a      	str	r2, [r3, #24]
    }
    
    len_words = (pdev->host.hc[hnptxsts.b.chnum].xfer_len + 3) / 4;
 80019ee:	68fb      	ldr	r3, [r7, #12]
 80019f0:	f3c3 7341 	ubfx	r3, r3, #29, #2
 80019f4:	b2db      	uxtb	r3, r3
 80019f6:	687a      	ldr	r2, [r7, #4]
 80019f8:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80019fc:	18d3      	adds	r3, r2, r3
 80019fe:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001a02:	681b      	ldr	r3, [r3, #0]
 8001a04:	f103 0303 	add.w	r3, r3, #3
 8001a08:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8001a0c:	82fb      	strh	r3, [r7, #22]
    
    USB_OTG_WritePacket (pdev , pdev->host.hc[hnptxsts.b.chnum].xfer_buff, hnptxsts.b.chnum, len);
 8001a0e:	68fb      	ldr	r3, [r7, #12]
 8001a10:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001a14:	b2db      	uxtb	r3, r3
 8001a16:	687a      	ldr	r2, [r7, #4]
 8001a18:	f103 030d 	add.w	r3, r3, #13
 8001a1c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001a20:	18d3      	adds	r3, r2, r3
 8001a22:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8001a26:	6819      	ldr	r1, [r3, #0]
 8001a28:	68fb      	ldr	r3, [r7, #12]
 8001a2a:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001a2e:	b2db      	uxtb	r3, r3
 8001a30:	461a      	mov	r2, r3
 8001a32:	8abb      	ldrh	r3, [r7, #20]
 8001a34:	6878      	ldr	r0, [r7, #4]
 8001a36:	f7fe fc47 	bl	80002c8 <USB_OTG_WritePacket>
    
    pdev->host.hc[hnptxsts.b.chnum].xfer_buff  += len;
 8001a3a:	68fb      	ldr	r3, [r7, #12]
 8001a3c:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001a40:	b2db      	uxtb	r3, r3
 8001a42:	68fa      	ldr	r2, [r7, #12]
 8001a44:	f3c2 7241 	ubfx	r2, r2, #29, #2
 8001a48:	b2d2      	uxtb	r2, r2
 8001a4a:	6879      	ldr	r1, [r7, #4]
 8001a4c:	f102 020d 	add.w	r2, r2, #13
 8001a50:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8001a54:	188a      	adds	r2, r1, r2
 8001a56:	f502 728c 	add.w	r2, r2, #280	; 0x118
 8001a5a:	6811      	ldr	r1, [r2, #0]
 8001a5c:	8aba      	ldrh	r2, [r7, #20]
 8001a5e:	188a      	adds	r2, r1, r2
 8001a60:	6879      	ldr	r1, [r7, #4]
 8001a62:	f103 030d 	add.w	r3, r3, #13
 8001a66:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001a6a:	18cb      	adds	r3, r1, r3
 8001a6c:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8001a70:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hnptxsts.b.chnum].xfer_len   -= len;
 8001a72:	68fb      	ldr	r3, [r7, #12]
 8001a74:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001a78:	b2db      	uxtb	r3, r3
 8001a7a:	68fa      	ldr	r2, [r7, #12]
 8001a7c:	f3c2 7241 	ubfx	r2, r2, #29, #2
 8001a80:	b2d2      	uxtb	r2, r2
 8001a82:	6879      	ldr	r1, [r7, #4]
 8001a84:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8001a88:	188a      	adds	r2, r1, r2
 8001a8a:	f502 722f 	add.w	r2, r2, #700	; 0x2bc
 8001a8e:	6811      	ldr	r1, [r2, #0]
 8001a90:	8aba      	ldrh	r2, [r7, #20]
 8001a92:	1a8a      	subs	r2, r1, r2
 8001a94:	6879      	ldr	r1, [r7, #4]
 8001a96:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001a9a:	18cb      	adds	r3, r1, r3
 8001a9c:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001aa0:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hnptxsts.b.chnum].xfer_count  += len; 
 8001aa2:	68fb      	ldr	r3, [r7, #12]
 8001aa4:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001aa8:	b2db      	uxtb	r3, r3
 8001aaa:	68fa      	ldr	r2, [r7, #12]
 8001aac:	f3c2 7241 	ubfx	r2, r2, #29, #2
 8001ab0:	b2d2      	uxtb	r2, r2
 8001ab2:	6879      	ldr	r1, [r7, #4]
 8001ab4:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8001ab8:	188a      	adds	r2, r1, r2
 8001aba:	f502 7230 	add.w	r2, r2, #704	; 0x2c0
 8001abe:	6811      	ldr	r1, [r2, #0]
 8001ac0:	8aba      	ldrh	r2, [r7, #20]
 8001ac2:	188a      	adds	r2, r1, r2
 8001ac4:	6879      	ldr	r1, [r7, #4]
 8001ac6:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001aca:	18cb      	adds	r3, r1, r3
 8001acc:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8001ad0:	601a      	str	r2, [r3, #0]
        
    hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 8001ad2:	687b      	ldr	r3, [r7, #4]
 8001ad4:	68db      	ldr	r3, [r3, #12]
 8001ad6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001ad8:	60fb      	str	r3, [r7, #12]
  
  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
  
  len_words = (pdev->host.hc[hnptxsts.b.chnum].xfer_len + 3) / 4;
  
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 8001ada:	89bb      	ldrh	r3, [r7, #12]
 8001adc:	8afa      	ldrh	r2, [r7, #22]
 8001ade:	429a      	cmp	r2, r3
 8001ae0:	d20d      	bcs.n	8001afe <USB_OTG_USBH_handle_nptxfempty_ISR+0x1a2>
      (pdev->host.hc[hnptxsts.b.chnum].xfer_len != 0))
 8001ae2:	68fb      	ldr	r3, [r7, #12]
 8001ae4:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001ae8:	b2db      	uxtb	r3, r3
 8001aea:	687a      	ldr	r2, [r7, #4]
 8001aec:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001af0:	18d3      	adds	r3, r2, r3
 8001af2:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001af6:	681b      	ldr	r3, [r3, #0]
  
  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
  
  len_words = (pdev->host.hc[hnptxsts.b.chnum].xfer_len + 3) / 4;
  
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 8001af8:	2b00      	cmp	r3, #0
 8001afa:	f47f af48 	bne.w	800198e <USB_OTG_USBH_handle_nptxfempty_ISR+0x32>
    pdev->host.hc[hnptxsts.b.chnum].xfer_count  += len; 
        
    hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
  }  

  return 1;
 8001afe:	f04f 0301 	mov.w	r3, #1
}
 8001b02:	4618      	mov	r0, r3
 8001b04:	f107 0718 	add.w	r7, r7, #24
 8001b08:	46bd      	mov	sp, r7
 8001b0a:	bd80      	pop	{r7, pc}

08001b0c <USB_OTG_USBH_handle_ptxfempty_ISR>:
  *         Handles periodic tx fifo empty
  * @param  pdev: Selected device
  * @retval status 
  */
static uint32_t USB_OTG_USBH_handle_ptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8001b0c:	b580      	push	{r7, lr}
 8001b0e:	b086      	sub	sp, #24
 8001b10:	af00      	add	r7, sp, #0
 8001b12:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTMSK_TypeDef      intmsk;
  USB_OTG_HPTXSTS_TypeDef      hptxsts; 
  uint16_t                     len_words , len; 
  
  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 8001b14:	687b      	ldr	r3, [r7, #4]
 8001b16:	695b      	ldr	r3, [r3, #20]
 8001b18:	691b      	ldr	r3, [r3, #16]
 8001b1a:	60fb      	str	r3, [r7, #12]
  
  len_words = (pdev->host.hc[hptxsts.b.chnum].xfer_len + 3) / 4;
 8001b1c:	68fb      	ldr	r3, [r7, #12]
 8001b1e:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001b22:	b2db      	uxtb	r3, r3
 8001b24:	687a      	ldr	r2, [r7, #4]
 8001b26:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001b2a:	18d3      	adds	r3, r2, r3
 8001b2c:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001b30:	681b      	ldr	r3, [r3, #0]
 8001b32:	f103 0303 	add.w	r3, r3, #3
 8001b36:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8001b3a:	82fb      	strh	r3, [r7, #22]
  
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 8001b3c:	e0a5      	b.n	8001c8a <USB_OTG_USBH_handle_ptxfempty_ISR+0x17e>
      (pdev->host.hc[hptxsts.b.chnum].xfer_len != 0))    
  {
    
    len = hptxsts.b.ptxfspcavail * 4;
 8001b3e:	89bb      	ldrh	r3, [r7, #12]
 8001b40:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001b44:	82bb      	strh	r3, [r7, #20]
    
    if (len > pdev->host.hc[hptxsts.b.chnum].xfer_len)
 8001b46:	8aba      	ldrh	r2, [r7, #20]
 8001b48:	68fb      	ldr	r3, [r7, #12]
 8001b4a:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001b4e:	b2db      	uxtb	r3, r3
 8001b50:	6879      	ldr	r1, [r7, #4]
 8001b52:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001b56:	18cb      	adds	r3, r1, r3
 8001b58:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001b5c:	681b      	ldr	r3, [r3, #0]
 8001b5e:	429a      	cmp	r2, r3
 8001b60:	d91d      	bls.n	8001b9e <USB_OTG_USBH_handle_ptxfempty_ISR+0x92>
    {
      len = pdev->host.hc[hptxsts.b.chnum].xfer_len;
 8001b62:	68fb      	ldr	r3, [r7, #12]
 8001b64:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001b68:	b2db      	uxtb	r3, r3
 8001b6a:	687a      	ldr	r2, [r7, #4]
 8001b6c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001b70:	18d3      	adds	r3, r2, r3
 8001b72:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001b76:	681b      	ldr	r3, [r3, #0]
 8001b78:	82bb      	strh	r3, [r7, #20]
      /* Last packet */
      intmsk.d32 = 0;
 8001b7a:	f04f 0300 	mov.w	r3, #0
 8001b7e:	613b      	str	r3, [r7, #16]
      intmsk.b.ptxfempty = 1;
 8001b80:	693b      	ldr	r3, [r7, #16]
 8001b82:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8001b86:	613b      	str	r3, [r7, #16]
      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0); 
 8001b88:	687b      	ldr	r3, [r7, #4]
 8001b8a:	68db      	ldr	r3, [r3, #12]
 8001b8c:	687a      	ldr	r2, [r7, #4]
 8001b8e:	68d2      	ldr	r2, [r2, #12]
 8001b90:	6992      	ldr	r2, [r2, #24]
 8001b92:	4611      	mov	r1, r2
 8001b94:	693a      	ldr	r2, [r7, #16]
 8001b96:	ea6f 0202 	mvn.w	r2, r2
 8001b9a:	400a      	ands	r2, r1
 8001b9c:	619a      	str	r2, [r3, #24]
    }
    
    len_words = (pdev->host.hc[hptxsts.b.chnum].xfer_len + 3) / 4;
 8001b9e:	68fb      	ldr	r3, [r7, #12]
 8001ba0:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001ba4:	b2db      	uxtb	r3, r3
 8001ba6:	687a      	ldr	r2, [r7, #4]
 8001ba8:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001bac:	18d3      	adds	r3, r2, r3
 8001bae:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001bb2:	681b      	ldr	r3, [r3, #0]
 8001bb4:	f103 0303 	add.w	r3, r3, #3
 8001bb8:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8001bbc:	82fb      	strh	r3, [r7, #22]
    
    USB_OTG_WritePacket (pdev , pdev->host.hc[hptxsts.b.chnum].xfer_buff, hptxsts.b.chnum, len);
 8001bbe:	68fb      	ldr	r3, [r7, #12]
 8001bc0:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001bc4:	b2db      	uxtb	r3, r3
 8001bc6:	687a      	ldr	r2, [r7, #4]
 8001bc8:	f103 030d 	add.w	r3, r3, #13
 8001bcc:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001bd0:	18d3      	adds	r3, r2, r3
 8001bd2:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8001bd6:	6819      	ldr	r1, [r3, #0]
 8001bd8:	68fb      	ldr	r3, [r7, #12]
 8001bda:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001bde:	b2db      	uxtb	r3, r3
 8001be0:	461a      	mov	r2, r3
 8001be2:	8abb      	ldrh	r3, [r7, #20]
 8001be4:	6878      	ldr	r0, [r7, #4]
 8001be6:	f7fe fb6f 	bl	80002c8 <USB_OTG_WritePacket>
    
    pdev->host.hc[hptxsts.b.chnum].xfer_buff  += len;
 8001bea:	68fb      	ldr	r3, [r7, #12]
 8001bec:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001bf0:	b2db      	uxtb	r3, r3
 8001bf2:	68fa      	ldr	r2, [r7, #12]
 8001bf4:	f3c2 7241 	ubfx	r2, r2, #29, #2
 8001bf8:	b2d2      	uxtb	r2, r2
 8001bfa:	6879      	ldr	r1, [r7, #4]
 8001bfc:	f102 020d 	add.w	r2, r2, #13
 8001c00:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8001c04:	188a      	adds	r2, r1, r2
 8001c06:	f502 728c 	add.w	r2, r2, #280	; 0x118
 8001c0a:	6811      	ldr	r1, [r2, #0]
 8001c0c:	8aba      	ldrh	r2, [r7, #20]
 8001c0e:	188a      	adds	r2, r1, r2
 8001c10:	6879      	ldr	r1, [r7, #4]
 8001c12:	f103 030d 	add.w	r3, r3, #13
 8001c16:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001c1a:	18cb      	adds	r3, r1, r3
 8001c1c:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8001c20:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hptxsts.b.chnum].xfer_len   -= len;
 8001c22:	68fb      	ldr	r3, [r7, #12]
 8001c24:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001c28:	b2db      	uxtb	r3, r3
 8001c2a:	68fa      	ldr	r2, [r7, #12]
 8001c2c:	f3c2 7241 	ubfx	r2, r2, #29, #2
 8001c30:	b2d2      	uxtb	r2, r2
 8001c32:	6879      	ldr	r1, [r7, #4]
 8001c34:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8001c38:	188a      	adds	r2, r1, r2
 8001c3a:	f502 722f 	add.w	r2, r2, #700	; 0x2bc
 8001c3e:	6811      	ldr	r1, [r2, #0]
 8001c40:	8aba      	ldrh	r2, [r7, #20]
 8001c42:	1a8a      	subs	r2, r1, r2
 8001c44:	6879      	ldr	r1, [r7, #4]
 8001c46:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001c4a:	18cb      	adds	r3, r1, r3
 8001c4c:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001c50:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hptxsts.b.chnum].xfer_count  += len; 
 8001c52:	68fb      	ldr	r3, [r7, #12]
 8001c54:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001c58:	b2db      	uxtb	r3, r3
 8001c5a:	68fa      	ldr	r2, [r7, #12]
 8001c5c:	f3c2 7241 	ubfx	r2, r2, #29, #2
 8001c60:	b2d2      	uxtb	r2, r2
 8001c62:	6879      	ldr	r1, [r7, #4]
 8001c64:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8001c68:	188a      	adds	r2, r1, r2
 8001c6a:	f502 7230 	add.w	r2, r2, #704	; 0x2c0
 8001c6e:	6811      	ldr	r1, [r2, #0]
 8001c70:	8aba      	ldrh	r2, [r7, #20]
 8001c72:	188a      	adds	r2, r1, r2
 8001c74:	6879      	ldr	r1, [r7, #4]
 8001c76:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001c7a:	18cb      	adds	r3, r1, r3
 8001c7c:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8001c80:	601a      	str	r2, [r3, #0]
     
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 8001c82:	687b      	ldr	r3, [r7, #4]
 8001c84:	695b      	ldr	r3, [r3, #20]
 8001c86:	691b      	ldr	r3, [r3, #16]
 8001c88:	60fb      	str	r3, [r7, #12]
  
  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
  
  len_words = (pdev->host.hc[hptxsts.b.chnum].xfer_len + 3) / 4;
  
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 8001c8a:	89bb      	ldrh	r3, [r7, #12]
 8001c8c:	8afa      	ldrh	r2, [r7, #22]
 8001c8e:	429a      	cmp	r2, r3
 8001c90:	d20d      	bcs.n	8001cae <USB_OTG_USBH_handle_ptxfempty_ISR+0x1a2>
      (pdev->host.hc[hptxsts.b.chnum].xfer_len != 0))    
 8001c92:	68fb      	ldr	r3, [r7, #12]
 8001c94:	f3c3 7341 	ubfx	r3, r3, #29, #2
 8001c98:	b2db      	uxtb	r3, r3
 8001c9a:	687a      	ldr	r2, [r7, #4]
 8001c9c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001ca0:	18d3      	adds	r3, r2, r3
 8001ca2:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8001ca6:	681b      	ldr	r3, [r3, #0]
  
  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
  
  len_words = (pdev->host.hc[hptxsts.b.chnum].xfer_len + 3) / 4;
  
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 8001ca8:	2b00      	cmp	r3, #0
 8001caa:	f47f af48 	bne.w	8001b3e <USB_OTG_USBH_handle_ptxfempty_ISR+0x32>
    pdev->host.hc[hptxsts.b.chnum].xfer_count  += len; 
     
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
  }  
  
  return 1;
 8001cae:	f04f 0301 	mov.w	r3, #1
}
 8001cb2:	4618      	mov	r0, r3
 8001cb4:	f107 0718 	add.w	r7, r7, #24
 8001cb8:	46bd      	mov	sp, r7
 8001cba:	bd80      	pop	{r7, pc}

08001cbc <USB_OTG_USBH_handle_port_ISR>:
  *         This function determines which interrupt conditions have occurred
  * @param  pdev: Selected device
  * @retval status 
  */
static uint32_t USB_OTG_USBH_handle_port_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8001cbc:	b580      	push	{r7, lr}
 8001cbe:	b088      	sub	sp, #32
 8001cc0:	af00      	add	r7, sp, #0
 8001cc2:	6078      	str	r0, [r7, #4]
  USB_OTG_HPRT0_TypeDef  hprt0;
  USB_OTG_HPRT0_TypeDef  hprt0_dup;
  USB_OTG_HCFG_TypeDef   hcfg;    
  uint32_t do_reset = 0;
 8001cc4:	f04f 0300 	mov.w	r3, #0
 8001cc8:	61fb      	str	r3, [r7, #28]
  uint32_t retval = 0;
 8001cca:	f04f 0300 	mov.w	r3, #0
 8001cce:	61bb      	str	r3, [r7, #24]
  
  hcfg.d32 = 0;
 8001cd0:	f04f 0300 	mov.w	r3, #0
 8001cd4:	60fb      	str	r3, [r7, #12]
  hprt0.d32 = 0;
 8001cd6:	f04f 0300 	mov.w	r3, #0
 8001cda:	617b      	str	r3, [r7, #20]
  hprt0_dup.d32 = 0;
 8001cdc:	f04f 0300 	mov.w	r3, #0
 8001ce0:	613b      	str	r3, [r7, #16]
  
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 8001ce2:	687b      	ldr	r3, [r7, #4]
 8001ce4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8001ce8:	681b      	ldr	r3, [r3, #0]
 8001cea:	617b      	str	r3, [r7, #20]
  hprt0_dup.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 8001cec:	687b      	ldr	r3, [r7, #4]
 8001cee:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8001cf2:	681b      	ldr	r3, [r3, #0]
 8001cf4:	613b      	str	r3, [r7, #16]
  
  /* Clear the interrupt bits in GINTSTS */
  
  hprt0_dup.b.prtena = 0;
 8001cf6:	693b      	ldr	r3, [r7, #16]
 8001cf8:	f36f 0382 	bfc	r3, #2, #1
 8001cfc:	613b      	str	r3, [r7, #16]
  hprt0_dup.b.prtconndet = 0;
 8001cfe:	693b      	ldr	r3, [r7, #16]
 8001d00:	f36f 0341 	bfc	r3, #1, #1
 8001d04:	613b      	str	r3, [r7, #16]
  hprt0_dup.b.prtenchng = 0;
 8001d06:	693b      	ldr	r3, [r7, #16]
 8001d08:	f36f 03c3 	bfc	r3, #3, #1
 8001d0c:	613b      	str	r3, [r7, #16]
  hprt0_dup.b.prtovrcurrchng = 0;
 8001d0e:	693b      	ldr	r3, [r7, #16]
 8001d10:	f36f 1345 	bfc	r3, #5, #1
 8001d14:	613b      	str	r3, [r7, #16]
  
  /* Port Connect Detected */
  if (hprt0.b.prtconndet)
 8001d16:	7d3b      	ldrb	r3, [r7, #20]
 8001d18:	f003 0302 	and.w	r3, r3, #2
 8001d1c:	b2db      	uxtb	r3, r3
 8001d1e:	2b00      	cmp	r3, #0
 8001d20:	d010      	beq.n	8001d44 <USB_OTG_USBH_handle_port_ISR+0x88>
  {
    pdev->host.port_cb->Connect(pdev);
 8001d22:	687b      	ldr	r3, [r7, #4]
 8001d24:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8001d28:	685b      	ldr	r3, [r3, #4]
 8001d2a:	6878      	ldr	r0, [r7, #4]
 8001d2c:	4798      	blx	r3
    hprt0_dup.b.prtconndet = 1;
 8001d2e:	693b      	ldr	r3, [r7, #16]
 8001d30:	f043 0302 	orr.w	r3, r3, #2
 8001d34:	613b      	str	r3, [r7, #16]
    do_reset = 1;
 8001d36:	f04f 0301 	mov.w	r3, #1
 8001d3a:	61fb      	str	r3, [r7, #28]
    retval |= 1;
 8001d3c:	69bb      	ldr	r3, [r7, #24]
 8001d3e:	f043 0301 	orr.w	r3, r3, #1
 8001d42:	61bb      	str	r3, [r7, #24]
  }
  
  /* Port Enable Changed */
  if (hprt0.b.prtenchng)
 8001d44:	7d3b      	ldrb	r3, [r7, #20]
 8001d46:	f003 0308 	and.w	r3, r3, #8
 8001d4a:	b2db      	uxtb	r3, r3
 8001d4c:	2b00      	cmp	r3, #0
 8001d4e:	d055      	beq.n	8001dfc <USB_OTG_USBH_handle_port_ISR+0x140>
  {
    hprt0_dup.b.prtenchng = 1;
 8001d50:	693b      	ldr	r3, [r7, #16]
 8001d52:	f043 0308 	orr.w	r3, r3, #8
 8001d56:	613b      	str	r3, [r7, #16]
    if (hprt0.b.prtena == 1)
 8001d58:	7d3b      	ldrb	r3, [r7, #20]
 8001d5a:	f003 0304 	and.w	r3, r3, #4
 8001d5e:	b2db      	uxtb	r3, r3
 8001d60:	2b00      	cmp	r3, #0
 8001d62:	d04b      	beq.n	8001dfc <USB_OTG_USBH_handle_port_ISR+0x140>
    {
      pdev->host.ConnSts = 1;
 8001d64:	687b      	ldr	r3, [r7, #4]
 8001d66:	f04f 0201 	mov.w	r2, #1
 8001d6a:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
      
      if ((hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED) ||
 8001d6e:	7dbb      	ldrb	r3, [r7, #22]
 8001d70:	f003 0306 	and.w	r3, r3, #6
 8001d74:	b2db      	uxtb	r3, r3
 8001d76:	2b04      	cmp	r3, #4
 8001d78:	d005      	beq.n	8001d86 <USB_OTG_USBH_handle_port_ISR+0xca>
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
 8001d7a:	7dbb      	ldrb	r3, [r7, #22]
 8001d7c:	f003 0306 	and.w	r3, r3, #6
 8001d80:	b2db      	uxtb	r3, r3
    hprt0_dup.b.prtenchng = 1;
    if (hprt0.b.prtena == 1)
    {
      pdev->host.ConnSts = 1;
      
      if ((hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED) ||
 8001d82:	2b02      	cmp	r3, #2
 8001d84:	d135      	bne.n	8001df2 <USB_OTG_USBH_handle_port_ISR+0x136>
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 8001d86:	687b      	ldr	r3, [r7, #4]
 8001d88:	695b      	ldr	r3, [r3, #20]
 8001d8a:	681b      	ldr	r3, [r3, #0]
 8001d8c:	60fb      	str	r3, [r7, #12]
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8001d8e:	7dbb      	ldrb	r3, [r7, #22]
 8001d90:	f003 0306 	and.w	r3, r3, #6
 8001d94:	b2db      	uxtb	r3, r3
 8001d96:	2b04      	cmp	r3, #4
 8001d98:	d117      	bne.n	8001dca <USB_OTG_USBH_handle_port_ISR+0x10e>
        {
          USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 6000 );
 8001d9a:	687b      	ldr	r3, [r7, #4]
 8001d9c:	695b      	ldr	r3, [r3, #20]
 8001d9e:	f241 7270 	movw	r2, #6000	; 0x1770
 8001da2:	605a      	str	r2, [r3, #4]
          if (hcfg.b.fslspclksel != HCFG_6_MHZ)
 8001da4:	7b3b      	ldrb	r3, [r7, #12]
 8001da6:	f003 0303 	and.w	r3, r3, #3
 8001daa:	b2db      	uxtb	r3, r3
 8001dac:	2b02      	cmp	r3, #2
 8001dae:	d024      	beq.n	8001dfa <USB_OTG_USBH_handle_port_ISR+0x13e>
          {
            if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
 8001db0:	687b      	ldr	r3, [r7, #4]
 8001db2:	7adb      	ldrb	r3, [r3, #11]
 8001db4:	2b01      	cmp	r3, #1
 8001db6:	d104      	bne.n	8001dc2 <USB_OTG_USBH_handle_port_ISR+0x106>
            {          
              USB_OTG_InitFSLSPClkSel(pdev ,HCFG_6_MHZ );
 8001db8:	6878      	ldr	r0, [r7, #4]
 8001dba:	f04f 0102 	mov.w	r1, #2
 8001dbe:	f7fe ff71 	bl	8000ca4 <USB_OTG_InitFSLSPClkSel>
            }          
            do_reset = 1;
 8001dc2:	f04f 0301 	mov.w	r3, #1
 8001dc6:	61fb      	str	r3, [r7, #28]
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8001dc8:	e017      	b.n	8001dfa <USB_OTG_USBH_handle_port_ISR+0x13e>
          }
        }
        else
        {
          
          USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 48000 );            
 8001dca:	687b      	ldr	r3, [r7, #4]
 8001dcc:	695b      	ldr	r3, [r3, #20]
 8001dce:	f64b 3280 	movw	r2, #48000	; 0xbb80
 8001dd2:	605a      	str	r2, [r3, #4]
          if (hcfg.b.fslspclksel != HCFG_48_MHZ)
 8001dd4:	7b3b      	ldrb	r3, [r7, #12]
 8001dd6:	f003 0303 	and.w	r3, r3, #3
 8001dda:	b2db      	uxtb	r3, r3
 8001ddc:	2b01      	cmp	r3, #1
 8001dde:	d00c      	beq.n	8001dfa <USB_OTG_USBH_handle_port_ISR+0x13e>
          {
            USB_OTG_InitFSLSPClkSel(pdev ,HCFG_48_MHZ );
 8001de0:	6878      	ldr	r0, [r7, #4]
 8001de2:	f04f 0101 	mov.w	r1, #1
 8001de6:	f7fe ff5d 	bl	8000ca4 <USB_OTG_InitFSLSPClkSel>
            do_reset = 1;
 8001dea:	f04f 0301 	mov.w	r3, #1
 8001dee:	61fb      	str	r3, [r7, #28]
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8001df0:	e003      	b.n	8001dfa <USB_OTG_USBH_handle_port_ISR+0x13e>
          }
        }
      }
      else
      {
        do_reset = 1;
 8001df2:	f04f 0301 	mov.w	r3, #1
 8001df6:	61fb      	str	r3, [r7, #28]
 8001df8:	e000      	b.n	8001dfc <USB_OTG_USBH_handle_port_ISR+0x140>
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8001dfa:	bf00      	nop
        do_reset = 1;
      }
    }
  }
  /* Overcurrent Change Interrupt */
  if (hprt0.b.prtovrcurrchng)
 8001dfc:	7d3b      	ldrb	r3, [r7, #20]
 8001dfe:	f003 0320 	and.w	r3, r3, #32
 8001e02:	b2db      	uxtb	r3, r3
 8001e04:	2b00      	cmp	r3, #0
 8001e06:	d007      	beq.n	8001e18 <USB_OTG_USBH_handle_port_ISR+0x15c>
  {
    hprt0_dup.b.prtovrcurrchng = 1;
 8001e08:	693b      	ldr	r3, [r7, #16]
 8001e0a:	f043 0320 	orr.w	r3, r3, #32
 8001e0e:	613b      	str	r3, [r7, #16]
    retval |= 1;
 8001e10:	69bb      	ldr	r3, [r7, #24]
 8001e12:	f043 0301 	orr.w	r3, r3, #1
 8001e16:	61bb      	str	r3, [r7, #24]
  }
  if (do_reset)
 8001e18:	69fb      	ldr	r3, [r7, #28]
 8001e1a:	2b00      	cmp	r3, #0
 8001e1c:	d002      	beq.n	8001e24 <USB_OTG_USBH_handle_port_ISR+0x168>
  {
    USB_OTG_ResetPort(pdev);
 8001e1e:	6878      	ldr	r0, [r7, #4]
 8001e20:	f7fe ff8a 	bl	8000d38 <USB_OTG_ResetPort>
    
  }
  /* Clear Port Interrupts */
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0_dup.d32);
 8001e24:	687b      	ldr	r3, [r7, #4]
 8001e26:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8001e2a:	693a      	ldr	r2, [r7, #16]
 8001e2c:	601a      	str	r2, [r3, #0]
  
  return retval;
 8001e2e:	69bb      	ldr	r3, [r7, #24]
}
 8001e30:	4618      	mov	r0, r3
 8001e32:	f107 0720 	add.w	r7, r7, #32
 8001e36:	46bd      	mov	sp, r7
 8001e38:	bd80      	pop	{r7, pc}
 8001e3a:	bf00      	nop

08001e3c <USB_OTG_USBH_handle_hc_n_Out_ISR>:
  * @param  pdev: Selected device
  * @param  hc_num: Channel number
  * @retval status 
  */
uint32_t USB_OTG_USBH_handle_hc_n_Out_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
{
 8001e3c:	b580      	push	{r7, lr}
 8001e3e:	b098      	sub	sp, #96	; 0x60
 8001e40:	af00      	add	r7, sp, #0
 8001e42:	6078      	str	r0, [r7, #4]
 8001e44:	6039      	str	r1, [r7, #0]
  USB_OTG_HCINTn_TypeDef     hcint;
  USB_OTG_HCGINTMSK_TypeDef  hcintmsk;
  USB_OTG_HC_REGS *hcreg;
  USB_OTG_HCCHAR_TypeDef     hcchar; 
  
  hcreg = pdev->regs.HC_REGS[num];
 8001e46:	687a      	ldr	r2, [r7, #4]
 8001e48:	683b      	ldr	r3, [r7, #0]
 8001e4a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001e4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001e52:	18d3      	adds	r3, r2, r3
 8001e54:	689b      	ldr	r3, [r3, #8]
 8001e56:	65fb      	str	r3, [r7, #92]	; 0x5c
  hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
 8001e58:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001e5a:	689b      	ldr	r3, [r3, #8]
 8001e5c:	65bb      	str	r3, [r7, #88]	; 0x58
  hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCGINTMSK);
 8001e5e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001e60:	68db      	ldr	r3, [r3, #12]
 8001e62:	657b      	str	r3, [r7, #84]	; 0x54
  hcint.d32 = hcint.d32 & hcintmsk.d32;
 8001e64:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8001e66:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001e68:	4013      	ands	r3, r2
 8001e6a:	65bb      	str	r3, [r7, #88]	; 0x58
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
 8001e6c:	687a      	ldr	r2, [r7, #4]
 8001e6e:	683b      	ldr	r3, [r7, #0]
 8001e70:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001e74:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001e78:	18d3      	adds	r3, r2, r3
 8001e7a:	689b      	ldr	r3, [r3, #8]
 8001e7c:	681b      	ldr	r3, [r3, #0]
 8001e7e:	653b      	str	r3, [r7, #80]	; 0x50
  
  if (hcint.b.ahberr)
 8001e80:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8001e84:	f003 0304 	and.w	r3, r3, #4
 8001e88:	b2db      	uxtb	r3, r3
 8001e8a:	2b00      	cmp	r3, #0
 8001e8c:	d022      	beq.n	8001ed4 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x98>
  {
    CLEAR_HC_INT(hcreg ,ahberr);
 8001e8e:	f04f 0300 	mov.w	r3, #0
 8001e92:	64fb      	str	r3, [r7, #76]	; 0x4c
 8001e94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001e96:	f043 0304 	orr.w	r3, r3, #4
 8001e9a:	64fb      	str	r3, [r7, #76]	; 0x4c
 8001e9c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8001e9e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001ea0:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 8001ea2:	687a      	ldr	r2, [r7, #4]
 8001ea4:	683b      	ldr	r3, [r7, #0]
 8001ea6:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001eaa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001eae:	18d3      	adds	r3, r2, r3
 8001eb0:	689b      	ldr	r3, [r3, #8]
 8001eb2:	68db      	ldr	r3, [r3, #12]
 8001eb4:	64bb      	str	r3, [r7, #72]	; 0x48
 8001eb6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8001eb8:	f043 0302 	orr.w	r3, r3, #2
 8001ebc:	64bb      	str	r3, [r7, #72]	; 0x48
 8001ebe:	687a      	ldr	r2, [r7, #4]
 8001ec0:	683b      	ldr	r3, [r7, #0]
 8001ec2:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001ec6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001eca:	18d3      	adds	r3, r2, r3
 8001ecc:	689b      	ldr	r3, [r3, #8]
 8001ece:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001ed0:	60da      	str	r2, [r3, #12]
 8001ed2:	e25c      	b.n	800238e <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
  } 
  else if (hcint.b.ack)
 8001ed4:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8001ed8:	f003 0320 	and.w	r3, r3, #32
 8001edc:	b2db      	uxtb	r3, r3
 8001ede:	2b00      	cmp	r3, #0
 8001ee0:	d00a      	beq.n	8001ef8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0xbc>
  {
    CLEAR_HC_INT(hcreg , ack);
 8001ee2:	f04f 0300 	mov.w	r3, #0
 8001ee6:	647b      	str	r3, [r7, #68]	; 0x44
 8001ee8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001eea:	f043 0320 	orr.w	r3, r3, #32
 8001eee:	647b      	str	r3, [r7, #68]	; 0x44
 8001ef0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8001ef2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001ef4:	609a      	str	r2, [r3, #8]
 8001ef6:	e24a      	b.n	800238e <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
  }
  
  else if (hcint.b.xfercompl)
 8001ef8:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8001efc:	f003 0301 	and.w	r3, r3, #1
 8001f00:	b2db      	uxtb	r3, r3
 8001f02:	2b00      	cmp	r3, #0
 8001f04:	d03a      	beq.n	8001f7c <USB_OTG_USBH_handle_hc_n_Out_ISR+0x140>
  {
    pdev->host.ErrCnt[num] = 0;
 8001f06:	687a      	ldr	r2, [r7, #4]
 8001f08:	683b      	ldr	r3, [r7, #0]
 8001f0a:	f103 0384 	add.w	r3, r3, #132	; 0x84
 8001f0e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001f12:	18d3      	adds	r3, r2, r3
 8001f14:	f04f 0200 	mov.w	r2, #0
 8001f18:	605a      	str	r2, [r3, #4]
    UNMASK_HOST_INT_CHH (num);
 8001f1a:	687a      	ldr	r2, [r7, #4]
 8001f1c:	683b      	ldr	r3, [r7, #0]
 8001f1e:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001f22:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001f26:	18d3      	adds	r3, r2, r3
 8001f28:	689b      	ldr	r3, [r3, #8]
 8001f2a:	68db      	ldr	r3, [r3, #12]
 8001f2c:	643b      	str	r3, [r7, #64]	; 0x40
 8001f2e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8001f30:	f043 0302 	orr.w	r3, r3, #2
 8001f34:	643b      	str	r3, [r7, #64]	; 0x40
 8001f36:	687a      	ldr	r2, [r7, #4]
 8001f38:	683b      	ldr	r3, [r7, #0]
 8001f3a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001f3e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001f42:	18d3      	adds	r3, r2, r3
 8001f44:	689b      	ldr	r3, [r3, #8]
 8001f46:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8001f48:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8001f4a:	683b      	ldr	r3, [r7, #0]
 8001f4c:	b2db      	uxtb	r3, r3
 8001f4e:	6878      	ldr	r0, [r7, #4]
 8001f50:	4619      	mov	r1, r3
 8001f52:	f7ff fa0f 	bl	8001374 <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , xfercompl);
 8001f56:	f04f 0300 	mov.w	r3, #0
 8001f5a:	63fb      	str	r3, [r7, #60]	; 0x3c
 8001f5c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8001f5e:	f043 0301 	orr.w	r3, r3, #1
 8001f62:	63fb      	str	r3, [r7, #60]	; 0x3c
 8001f64:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8001f66:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001f68:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_XFRC;            
 8001f6a:	687a      	ldr	r2, [r7, #4]
 8001f6c:	683b      	ldr	r3, [r7, #0]
 8001f6e:	18d3      	adds	r3, r2, r3
 8001f70:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8001f74:	f04f 0201 	mov.w	r2, #1
 8001f78:	711a      	strb	r2, [r3, #4]
 8001f7a:	e208      	b.n	800238e <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
  }
  
  else if (hcint.b.stall)
 8001f7c:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8001f80:	f003 0308 	and.w	r3, r3, #8
 8001f84:	b2db      	uxtb	r3, r3
 8001f86:	2b00      	cmp	r3, #0
 8001f88:	d030      	beq.n	8001fec <USB_OTG_USBH_handle_hc_n_Out_ISR+0x1b0>
  {
    CLEAR_HC_INT(hcreg , stall);
 8001f8a:	f04f 0300 	mov.w	r3, #0
 8001f8e:	63bb      	str	r3, [r7, #56]	; 0x38
 8001f90:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8001f92:	f043 0308 	orr.w	r3, r3, #8
 8001f96:	63bb      	str	r3, [r7, #56]	; 0x38
 8001f98:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8001f9a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001f9c:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 8001f9e:	687a      	ldr	r2, [r7, #4]
 8001fa0:	683b      	ldr	r3, [r7, #0]
 8001fa2:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001fa6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001faa:	18d3      	adds	r3, r2, r3
 8001fac:	689b      	ldr	r3, [r3, #8]
 8001fae:	68db      	ldr	r3, [r3, #12]
 8001fb0:	637b      	str	r3, [r7, #52]	; 0x34
 8001fb2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001fb4:	f043 0302 	orr.w	r3, r3, #2
 8001fb8:	637b      	str	r3, [r7, #52]	; 0x34
 8001fba:	687a      	ldr	r2, [r7, #4]
 8001fbc:	683b      	ldr	r3, [r7, #0]
 8001fbe:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8001fc2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001fc6:	18d3      	adds	r3, r2, r3
 8001fc8:	689b      	ldr	r3, [r3, #8]
 8001fca:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8001fcc:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8001fce:	683b      	ldr	r3, [r7, #0]
 8001fd0:	b2db      	uxtb	r3, r3
 8001fd2:	6878      	ldr	r0, [r7, #4]
 8001fd4:	4619      	mov	r1, r3
 8001fd6:	f7ff f9cd 	bl	8001374 <USB_OTG_HC_Halt>
    pdev->host.HC_Status[num] = HC_STALL;      
 8001fda:	687a      	ldr	r2, [r7, #4]
 8001fdc:	683b      	ldr	r3, [r7, #0]
 8001fde:	18d3      	adds	r3, r2, r3
 8001fe0:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8001fe4:	f04f 0205 	mov.w	r2, #5
 8001fe8:	711a      	strb	r2, [r3, #4]
 8001fea:	e1d0      	b.n	800238e <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
  }
  
  else if (hcint.b.nak)
 8001fec:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8001ff0:	f003 0310 	and.w	r3, r3, #16
 8001ff4:	b2db      	uxtb	r3, r3
 8001ff6:	2b00      	cmp	r3, #0
 8001ff8:	d03a      	beq.n	8002070 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x234>
  {
    pdev->host.ErrCnt[num] = 0;
 8001ffa:	687a      	ldr	r2, [r7, #4]
 8001ffc:	683b      	ldr	r3, [r7, #0]
 8001ffe:	f103 0384 	add.w	r3, r3, #132	; 0x84
 8002002:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002006:	18d3      	adds	r3, r2, r3
 8002008:	f04f 0200 	mov.w	r2, #0
 800200c:	605a      	str	r2, [r3, #4]
    UNMASK_HOST_INT_CHH (num);
 800200e:	687a      	ldr	r2, [r7, #4]
 8002010:	683b      	ldr	r3, [r7, #0]
 8002012:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002016:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800201a:	18d3      	adds	r3, r2, r3
 800201c:	689b      	ldr	r3, [r3, #8]
 800201e:	68db      	ldr	r3, [r3, #12]
 8002020:	633b      	str	r3, [r7, #48]	; 0x30
 8002022:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002024:	f043 0302 	orr.w	r3, r3, #2
 8002028:	633b      	str	r3, [r7, #48]	; 0x30
 800202a:	687a      	ldr	r2, [r7, #4]
 800202c:	683b      	ldr	r3, [r7, #0]
 800202e:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002032:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002036:	18d3      	adds	r3, r2, r3
 8002038:	689b      	ldr	r3, [r3, #8]
 800203a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800203c:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 800203e:	683b      	ldr	r3, [r7, #0]
 8002040:	b2db      	uxtb	r3, r3
 8002042:	6878      	ldr	r0, [r7, #4]
 8002044:	4619      	mov	r1, r3
 8002046:	f7ff f995 	bl	8001374 <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);
 800204a:	f04f 0300 	mov.w	r3, #0
 800204e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002050:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002052:	f043 0310 	orr.w	r3, r3, #16
 8002056:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002058:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800205a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800205c:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_NAK;      
 800205e:	687a      	ldr	r2, [r7, #4]
 8002060:	683b      	ldr	r3, [r7, #0]
 8002062:	18d3      	adds	r3, r2, r3
 8002064:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8002068:	f04f 0203 	mov.w	r2, #3
 800206c:	711a      	strb	r2, [r3, #4]
 800206e:	e18e      	b.n	800238e <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
  }
  
  else if (hcint.b.xacterr)
 8002070:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8002074:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8002078:	b2db      	uxtb	r3, r3
 800207a:	2b00      	cmp	r3, #0
 800207c:	d042      	beq.n	8002104 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x2c8>
  {
    UNMASK_HOST_INT_CHH (num);
 800207e:	687a      	ldr	r2, [r7, #4]
 8002080:	683b      	ldr	r3, [r7, #0]
 8002082:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002086:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800208a:	18d3      	adds	r3, r2, r3
 800208c:	689b      	ldr	r3, [r3, #8]
 800208e:	68db      	ldr	r3, [r3, #12]
 8002090:	62bb      	str	r3, [r7, #40]	; 0x28
 8002092:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002094:	f043 0302 	orr.w	r3, r3, #2
 8002098:	62bb      	str	r3, [r7, #40]	; 0x28
 800209a:	687a      	ldr	r2, [r7, #4]
 800209c:	683b      	ldr	r3, [r7, #0]
 800209e:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80020a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80020a6:	18d3      	adds	r3, r2, r3
 80020a8:	689b      	ldr	r3, [r3, #8]
 80020aa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80020ac:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 80020ae:	683b      	ldr	r3, [r7, #0]
 80020b0:	b2db      	uxtb	r3, r3
 80020b2:	6878      	ldr	r0, [r7, #4]
 80020b4:	4619      	mov	r1, r3
 80020b6:	f7ff f95d 	bl	8001374 <USB_OTG_HC_Halt>
    pdev->host.ErrCnt[num] ++;
 80020ba:	687a      	ldr	r2, [r7, #4]
 80020bc:	683b      	ldr	r3, [r7, #0]
 80020be:	f103 0384 	add.w	r3, r3, #132	; 0x84
 80020c2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80020c6:	18d3      	adds	r3, r2, r3
 80020c8:	685b      	ldr	r3, [r3, #4]
 80020ca:	f103 0201 	add.w	r2, r3, #1
 80020ce:	6879      	ldr	r1, [r7, #4]
 80020d0:	683b      	ldr	r3, [r7, #0]
 80020d2:	f103 0384 	add.w	r3, r3, #132	; 0x84
 80020d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80020da:	18cb      	adds	r3, r1, r3
 80020dc:	605a      	str	r2, [r3, #4]
    pdev->host.HC_Status[num] = HC_XACTERR;
 80020de:	687a      	ldr	r2, [r7, #4]
 80020e0:	683b      	ldr	r3, [r7, #0]
 80020e2:	18d3      	adds	r3, r2, r3
 80020e4:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80020e8:	f04f 0206 	mov.w	r2, #6
 80020ec:	711a      	strb	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , xacterr);
 80020ee:	f04f 0300 	mov.w	r3, #0
 80020f2:	627b      	str	r3, [r7, #36]	; 0x24
 80020f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80020f6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80020fa:	627b      	str	r3, [r7, #36]	; 0x24
 80020fc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80020fe:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8002100:	609a      	str	r2, [r3, #8]
 8002102:	e144      	b.n	800238e <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
  }
  else if (hcint.b.nyet)
 8002104:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8002108:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800210c:	b2db      	uxtb	r3, r3
 800210e:	2b00      	cmp	r3, #0
 8002110:	d03a      	beq.n	8002188 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x34c>
  {
    pdev->host.ErrCnt[num] = 0;
 8002112:	687a      	ldr	r2, [r7, #4]
 8002114:	683b      	ldr	r3, [r7, #0]
 8002116:	f103 0384 	add.w	r3, r3, #132	; 0x84
 800211a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800211e:	18d3      	adds	r3, r2, r3
 8002120:	f04f 0200 	mov.w	r2, #0
 8002124:	605a      	str	r2, [r3, #4]
    UNMASK_HOST_INT_CHH (num);
 8002126:	687a      	ldr	r2, [r7, #4]
 8002128:	683b      	ldr	r3, [r7, #0]
 800212a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800212e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002132:	18d3      	adds	r3, r2, r3
 8002134:	689b      	ldr	r3, [r3, #8]
 8002136:	68db      	ldr	r3, [r3, #12]
 8002138:	623b      	str	r3, [r7, #32]
 800213a:	6a3b      	ldr	r3, [r7, #32]
 800213c:	f043 0302 	orr.w	r3, r3, #2
 8002140:	623b      	str	r3, [r7, #32]
 8002142:	687a      	ldr	r2, [r7, #4]
 8002144:	683b      	ldr	r3, [r7, #0]
 8002146:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800214a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800214e:	18d3      	adds	r3, r2, r3
 8002150:	689b      	ldr	r3, [r3, #8]
 8002152:	6a3a      	ldr	r2, [r7, #32]
 8002154:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8002156:	683b      	ldr	r3, [r7, #0]
 8002158:	b2db      	uxtb	r3, r3
 800215a:	6878      	ldr	r0, [r7, #4]
 800215c:	4619      	mov	r1, r3
 800215e:	f7ff f909 	bl	8001374 <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nyet);
 8002162:	f04f 0300 	mov.w	r3, #0
 8002166:	61fb      	str	r3, [r7, #28]
 8002168:	69fb      	ldr	r3, [r7, #28]
 800216a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800216e:	61fb      	str	r3, [r7, #28]
 8002170:	69fa      	ldr	r2, [r7, #28]
 8002172:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8002174:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_NYET;    
 8002176:	687a      	ldr	r2, [r7, #4]
 8002178:	683b      	ldr	r3, [r7, #0]
 800217a:	18d3      	adds	r3, r2, r3
 800217c:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8002180:	f04f 0204 	mov.w	r2, #4
 8002184:	711a      	strb	r2, [r3, #4]
 8002186:	e102      	b.n	800238e <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
  }
  else if (hcint.b.datatglerr)
 8002188:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 800218c:	f003 0304 	and.w	r3, r3, #4
 8002190:	b2db      	uxtb	r3, r3
 8002192:	2b00      	cmp	r3, #0
 8002194:	d03a      	beq.n	800220c <USB_OTG_USBH_handle_hc_n_Out_ISR+0x3d0>
  {
   
    UNMASK_HOST_INT_CHH (num);
 8002196:	687a      	ldr	r2, [r7, #4]
 8002198:	683b      	ldr	r3, [r7, #0]
 800219a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800219e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80021a2:	18d3      	adds	r3, r2, r3
 80021a4:	689b      	ldr	r3, [r3, #8]
 80021a6:	68db      	ldr	r3, [r3, #12]
 80021a8:	61bb      	str	r3, [r7, #24]
 80021aa:	69bb      	ldr	r3, [r7, #24]
 80021ac:	f043 0302 	orr.w	r3, r3, #2
 80021b0:	61bb      	str	r3, [r7, #24]
 80021b2:	687a      	ldr	r2, [r7, #4]
 80021b4:	683b      	ldr	r3, [r7, #0]
 80021b6:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80021ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80021be:	18d3      	adds	r3, r2, r3
 80021c0:	689b      	ldr	r3, [r3, #8]
 80021c2:	69ba      	ldr	r2, [r7, #24]
 80021c4:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 80021c6:	683b      	ldr	r3, [r7, #0]
 80021c8:	b2db      	uxtb	r3, r3
 80021ca:	6878      	ldr	r0, [r7, #4]
 80021cc:	4619      	mov	r1, r3
 80021ce:	f7ff f8d1 	bl	8001374 <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);   
 80021d2:	f04f 0300 	mov.w	r3, #0
 80021d6:	617b      	str	r3, [r7, #20]
 80021d8:	697b      	ldr	r3, [r7, #20]
 80021da:	f043 0310 	orr.w	r3, r3, #16
 80021de:	617b      	str	r3, [r7, #20]
 80021e0:	697a      	ldr	r2, [r7, #20]
 80021e2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80021e4:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_DATATGLERR;
 80021e6:	687a      	ldr	r2, [r7, #4]
 80021e8:	683b      	ldr	r3, [r7, #0]
 80021ea:	18d3      	adds	r3, r2, r3
 80021ec:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80021f0:	f04f 0208 	mov.w	r2, #8
 80021f4:	711a      	strb	r2, [r3, #4]
    
    CLEAR_HC_INT(hcreg , datatglerr);
 80021f6:	f04f 0300 	mov.w	r3, #0
 80021fa:	613b      	str	r3, [r7, #16]
 80021fc:	693b      	ldr	r3, [r7, #16]
 80021fe:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8002202:	613b      	str	r3, [r7, #16]
 8002204:	693a      	ldr	r2, [r7, #16]
 8002206:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8002208:	609a      	str	r2, [r3, #8]
 800220a:	e0c0      	b.n	800238e <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
  }  
  else if (hcint.b.chhltd)
 800220c:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8002210:	f003 0302 	and.w	r3, r3, #2
 8002214:	b2db      	uxtb	r3, r3
 8002216:	2b00      	cmp	r3, #0
 8002218:	f000 80b9 	beq.w	800238e <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
  {
    MASK_HOST_INT_CHH (num);
 800221c:	687a      	ldr	r2, [r7, #4]
 800221e:	683b      	ldr	r3, [r7, #0]
 8002220:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002224:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002228:	18d3      	adds	r3, r2, r3
 800222a:	689b      	ldr	r3, [r3, #8]
 800222c:	68db      	ldr	r3, [r3, #12]
 800222e:	60fb      	str	r3, [r7, #12]
 8002230:	68fb      	ldr	r3, [r7, #12]
 8002232:	f36f 0341 	bfc	r3, #1, #1
 8002236:	60fb      	str	r3, [r7, #12]
 8002238:	687a      	ldr	r2, [r7, #4]
 800223a:	683b      	ldr	r3, [r7, #0]
 800223c:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002240:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002244:	18d3      	adds	r3, r2, r3
 8002246:	689b      	ldr	r3, [r3, #8]
 8002248:	68fa      	ldr	r2, [r7, #12]
 800224a:	60da      	str	r2, [r3, #12]
    
    if(pdev->host.HC_Status[num] == HC_XFRC)
 800224c:	687a      	ldr	r2, [r7, #4]
 800224e:	683b      	ldr	r3, [r7, #0]
 8002250:	18d3      	adds	r3, r2, r3
 8002252:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8002256:	791b      	ldrb	r3, [r3, #4]
 8002258:	b2db      	uxtb	r3, r3
 800225a:	2b01      	cmp	r3, #1
 800225c:	d122      	bne.n	80022a4 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x468>
    {
      pdev->host.URB_State[num] = URB_DONE;  
 800225e:	687a      	ldr	r2, [r7, #4]
 8002260:	683b      	ldr	r3, [r7, #0]
 8002262:	18d3      	adds	r3, r2, r3
 8002264:	f503 7326 	add.w	r3, r3, #664	; 0x298
 8002268:	f04f 0201 	mov.w	r2, #1
 800226c:	70da      	strb	r2, [r3, #3]
      
      if (hcchar.b.eptype == EP_TYPE_BULK)
 800226e:	f897 3052 	ldrb.w	r3, [r7, #82]	; 0x52
 8002272:	f003 030c 	and.w	r3, r3, #12
 8002276:	b2db      	uxtb	r3, r3
 8002278:	2b08      	cmp	r3, #8
 800227a:	d17e      	bne.n	800237a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x53e>
      {
        pdev->host.hc[num].toggle_out ^= 1; 
 800227c:	687a      	ldr	r2, [r7, #4]
 800227e:	683b      	ldr	r3, [r7, #0]
 8002280:	f103 0316 	add.w	r3, r3, #22
 8002284:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8002288:	18d3      	adds	r3, r2, r3
 800228a:	795b      	ldrb	r3, [r3, #5]
 800228c:	f083 0301 	eor.w	r3, r3, #1
 8002290:	b2da      	uxtb	r2, r3
 8002292:	6879      	ldr	r1, [r7, #4]
 8002294:	683b      	ldr	r3, [r7, #0]
 8002296:	f103 0316 	add.w	r3, r3, #22
 800229a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800229e:	18cb      	adds	r3, r1, r3
 80022a0:	715a      	strb	r2, [r3, #5]
 80022a2:	e06a      	b.n	800237a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x53e>
      }
    }
    else if(pdev->host.HC_Status[num] == HC_NAK)
 80022a4:	687a      	ldr	r2, [r7, #4]
 80022a6:	683b      	ldr	r3, [r7, #0]
 80022a8:	18d3      	adds	r3, r2, r3
 80022aa:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80022ae:	791b      	ldrb	r3, [r3, #4]
 80022b0:	b2db      	uxtb	r3, r3
 80022b2:	2b03      	cmp	r3, #3
 80022b4:	d108      	bne.n	80022c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x48c>
    {
      pdev->host.URB_State[num] = URB_NOTREADY;      
 80022b6:	687a      	ldr	r2, [r7, #4]
 80022b8:	683b      	ldr	r3, [r7, #0]
 80022ba:	18d3      	adds	r3, r2, r3
 80022bc:	f503 7326 	add.w	r3, r3, #664	; 0x298
 80022c0:	f04f 0202 	mov.w	r2, #2
 80022c4:	70da      	strb	r2, [r3, #3]
 80022c6:	e058      	b.n	800237a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x53e>
    }    
    else if(pdev->host.HC_Status[num] == HC_NYET)
 80022c8:	687a      	ldr	r2, [r7, #4]
 80022ca:	683b      	ldr	r3, [r7, #0]
 80022cc:	18d3      	adds	r3, r2, r3
 80022ce:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80022d2:	791b      	ldrb	r3, [r3, #4]
 80022d4:	b2db      	uxtb	r3, r3
 80022d6:	2b04      	cmp	r3, #4
 80022d8:	d118      	bne.n	800230c <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4d0>
    {
      if(pdev->host.hc[num].do_ping == 1)
 80022da:	687a      	ldr	r2, [r7, #4]
 80022dc:	683b      	ldr	r3, [r7, #0]
 80022de:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80022e2:	18d3      	adds	r3, r2, r3
 80022e4:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 80022e8:	7a1b      	ldrb	r3, [r3, #8]
 80022ea:	2b01      	cmp	r3, #1
 80022ec:	d105      	bne.n	80022fa <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4be>
      {
        USB_OTG_HC_DoPing(pdev, num);
 80022ee:	683b      	ldr	r3, [r7, #0]
 80022f0:	b2db      	uxtb	r3, r3
 80022f2:	6878      	ldr	r0, [r7, #4]
 80022f4:	4619      	mov	r1, r3
 80022f6:	f7ff f893 	bl	8001420 <USB_OTG_HC_DoPing>
      }
      pdev->host.URB_State[num] = URB_NOTREADY;      
 80022fa:	687a      	ldr	r2, [r7, #4]
 80022fc:	683b      	ldr	r3, [r7, #0]
 80022fe:	18d3      	adds	r3, r2, r3
 8002300:	f503 7326 	add.w	r3, r3, #664	; 0x298
 8002304:	f04f 0202 	mov.w	r2, #2
 8002308:	70da      	strb	r2, [r3, #3]
 800230a:	e036      	b.n	800237a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x53e>
    }      
    else if(pdev->host.HC_Status[num] == HC_STALL)
 800230c:	687a      	ldr	r2, [r7, #4]
 800230e:	683b      	ldr	r3, [r7, #0]
 8002310:	18d3      	adds	r3, r2, r3
 8002312:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8002316:	791b      	ldrb	r3, [r3, #4]
 8002318:	b2db      	uxtb	r3, r3
 800231a:	2b05      	cmp	r3, #5
 800231c:	d108      	bne.n	8002330 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4f4>
    {
      pdev->host.URB_State[num] = URB_STALL;      
 800231e:	687a      	ldr	r2, [r7, #4]
 8002320:	683b      	ldr	r3, [r7, #0]
 8002322:	18d3      	adds	r3, r2, r3
 8002324:	f503 7326 	add.w	r3, r3, #664	; 0x298
 8002328:	f04f 0204 	mov.w	r2, #4
 800232c:	70da      	strb	r2, [r3, #3]
 800232e:	e024      	b.n	800237a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x53e>
    }  
    else if(pdev->host.HC_Status[num] == HC_XACTERR)
 8002330:	687a      	ldr	r2, [r7, #4]
 8002332:	683b      	ldr	r3, [r7, #0]
 8002334:	18d3      	adds	r3, r2, r3
 8002336:	f503 7322 	add.w	r3, r3, #648	; 0x288
 800233a:	791b      	ldrb	r3, [r3, #4]
 800233c:	b2db      	uxtb	r3, r3
 800233e:	2b06      	cmp	r3, #6
 8002340:	d11b      	bne.n	800237a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x53e>
    {
      if (pdev->host.ErrCnt[num] == 3)
 8002342:	687a      	ldr	r2, [r7, #4]
 8002344:	683b      	ldr	r3, [r7, #0]
 8002346:	f103 0384 	add.w	r3, r3, #132	; 0x84
 800234a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800234e:	18d3      	adds	r3, r2, r3
 8002350:	685b      	ldr	r3, [r3, #4]
 8002352:	2b03      	cmp	r3, #3
 8002354:	d111      	bne.n	800237a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x53e>
      {
        pdev->host.URB_State[num] = URB_ERROR;  
 8002356:	687a      	ldr	r2, [r7, #4]
 8002358:	683b      	ldr	r3, [r7, #0]
 800235a:	18d3      	adds	r3, r2, r3
 800235c:	f503 7326 	add.w	r3, r3, #664	; 0x298
 8002360:	f04f 0203 	mov.w	r2, #3
 8002364:	70da      	strb	r2, [r3, #3]
        pdev->host.ErrCnt[num] = 0;
 8002366:	687a      	ldr	r2, [r7, #4]
 8002368:	683b      	ldr	r3, [r7, #0]
 800236a:	f103 0384 	add.w	r3, r3, #132	; 0x84
 800236e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002372:	18d3      	adds	r3, r2, r3
 8002374:	f04f 0200 	mov.w	r2, #0
 8002378:	605a      	str	r2, [r3, #4]
      }
    }
    CLEAR_HC_INT(hcreg , chhltd);    
 800237a:	f04f 0300 	mov.w	r3, #0
 800237e:	60bb      	str	r3, [r7, #8]
 8002380:	68bb      	ldr	r3, [r7, #8]
 8002382:	f043 0302 	orr.w	r3, r3, #2
 8002386:	60bb      	str	r3, [r7, #8]
 8002388:	68ba      	ldr	r2, [r7, #8]
 800238a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800238c:	609a      	str	r2, [r3, #8]
  }
  

  return 1;
 800238e:	f04f 0301 	mov.w	r3, #1
}
 8002392:	4618      	mov	r0, r3
 8002394:	f107 0760 	add.w	r7, r7, #96	; 0x60
 8002398:	46bd      	mov	sp, r7
 800239a:	bd80      	pop	{r7, pc}

0800239c <USB_OTG_USBH_handle_hc_n_In_ISR>:
  * @param  pdev: Selected device
  * @param  hc_num: Channel number
  * @retval status 
  */
uint32_t USB_OTG_USBH_handle_hc_n_In_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
{
 800239c:	b580      	push	{r7, lr}
 800239e:	b09c      	sub	sp, #112	; 0x70
 80023a0:	af00      	add	r7, sp, #0
 80023a2:	6078      	str	r0, [r7, #4]
 80023a4:	6039      	str	r1, [r7, #0]
  USB_OTG_HCCHAR_TypeDef     hcchar; 
  USB_OTG_HCTSIZn_TypeDef  hctsiz;
  USB_OTG_HC_REGS *hcreg;

  
  hcreg = pdev->regs.HC_REGS[num];
 80023a6:	687a      	ldr	r2, [r7, #4]
 80023a8:	683b      	ldr	r3, [r7, #0]
 80023aa:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80023ae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80023b2:	18d3      	adds	r3, r2, r3
 80023b4:	689b      	ldr	r3, [r3, #8]
 80023b6:	66fb      	str	r3, [r7, #108]	; 0x6c
  hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
 80023b8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80023ba:	689b      	ldr	r3, [r3, #8]
 80023bc:	66bb      	str	r3, [r7, #104]	; 0x68
  hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCGINTMSK);
 80023be:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80023c0:	68db      	ldr	r3, [r3, #12]
 80023c2:	667b      	str	r3, [r7, #100]	; 0x64
  hcint.d32 = hcint.d32 & hcintmsk.d32;
 80023c4:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80023c6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80023c8:	4013      	ands	r3, r2
 80023ca:	66bb      	str	r3, [r7, #104]	; 0x68
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
 80023cc:	687a      	ldr	r2, [r7, #4]
 80023ce:	683b      	ldr	r3, [r7, #0]
 80023d0:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80023d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80023d8:	18d3      	adds	r3, r2, r3
 80023da:	689b      	ldr	r3, [r3, #8]
 80023dc:	681b      	ldr	r3, [r3, #0]
 80023de:	663b      	str	r3, [r7, #96]	; 0x60
  hcintmsk.d32 = 0;
 80023e0:	f04f 0300 	mov.w	r3, #0
 80023e4:	667b      	str	r3, [r7, #100]	; 0x64
  
  
  if (hcint.b.ahberr)
 80023e6:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 80023ea:	f003 0304 	and.w	r3, r3, #4
 80023ee:	b2db      	uxtb	r3, r3
 80023f0:	2b00      	cmp	r3, #0
 80023f2:	d022      	beq.n	800243a <USB_OTG_USBH_handle_hc_n_In_ISR+0x9e>
  {
    CLEAR_HC_INT(hcreg ,ahberr);
 80023f4:	f04f 0300 	mov.w	r3, #0
 80023f8:	65bb      	str	r3, [r7, #88]	; 0x58
 80023fa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80023fc:	f043 0304 	orr.w	r3, r3, #4
 8002400:	65bb      	str	r3, [r7, #88]	; 0x58
 8002402:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8002404:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002406:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 8002408:	687a      	ldr	r2, [r7, #4]
 800240a:	683b      	ldr	r3, [r7, #0]
 800240c:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002410:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002414:	18d3      	adds	r3, r2, r3
 8002416:	689b      	ldr	r3, [r3, #8]
 8002418:	68db      	ldr	r3, [r3, #12]
 800241a:	657b      	str	r3, [r7, #84]	; 0x54
 800241c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800241e:	f043 0302 	orr.w	r3, r3, #2
 8002422:	657b      	str	r3, [r7, #84]	; 0x54
 8002424:	687a      	ldr	r2, [r7, #4]
 8002426:	683b      	ldr	r3, [r7, #0]
 8002428:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800242c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002430:	18d3      	adds	r3, r2, r3
 8002432:	689b      	ldr	r3, [r3, #8]
 8002434:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8002436:	60da      	str	r2, [r3, #12]
 8002438:	e098      	b.n	800256c <USB_OTG_USBH_handle_hc_n_In_ISR+0x1d0>
  }  
  else if (hcint.b.ack)
 800243a:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 800243e:	f003 0320 	and.w	r3, r3, #32
 8002442:	b2db      	uxtb	r3, r3
 8002444:	2b00      	cmp	r3, #0
 8002446:	d00a      	beq.n	800245e <USB_OTG_USBH_handle_hc_n_In_ISR+0xc2>
  {
    CLEAR_HC_INT(hcreg ,ack);
 8002448:	f04f 0300 	mov.w	r3, #0
 800244c:	653b      	str	r3, [r7, #80]	; 0x50
 800244e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8002450:	f043 0320 	orr.w	r3, r3, #32
 8002454:	653b      	str	r3, [r7, #80]	; 0x50
 8002456:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8002458:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800245a:	609a      	str	r2, [r3, #8]
 800245c:	e086      	b.n	800256c <USB_OTG_USBH_handle_hc_n_In_ISR+0x1d0>
  }
  
  else if (hcint.b.stall)  
 800245e:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8002462:	f003 0308 	and.w	r3, r3, #8
 8002466:	b2db      	uxtb	r3, r3
 8002468:	2b00      	cmp	r3, #0
 800246a:	d03e      	beq.n	80024ea <USB_OTG_USBH_handle_hc_n_In_ISR+0x14e>
  {
    UNMASK_HOST_INT_CHH (num);
 800246c:	687a      	ldr	r2, [r7, #4]
 800246e:	683b      	ldr	r3, [r7, #0]
 8002470:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002474:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002478:	18d3      	adds	r3, r2, r3
 800247a:	689b      	ldr	r3, [r3, #8]
 800247c:	68db      	ldr	r3, [r3, #12]
 800247e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8002480:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8002482:	f043 0302 	orr.w	r3, r3, #2
 8002486:	64fb      	str	r3, [r7, #76]	; 0x4c
 8002488:	687a      	ldr	r2, [r7, #4]
 800248a:	683b      	ldr	r3, [r7, #0]
 800248c:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002490:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002494:	18d3      	adds	r3, r2, r3
 8002496:	689b      	ldr	r3, [r3, #8]
 8002498:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800249a:	60da      	str	r2, [r3, #12]
    pdev->host.HC_Status[num] = HC_STALL; 
 800249c:	687a      	ldr	r2, [r7, #4]
 800249e:	683b      	ldr	r3, [r7, #0]
 80024a0:	18d3      	adds	r3, r2, r3
 80024a2:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80024a6:	f04f 0205 	mov.w	r2, #5
 80024aa:	711a      	strb	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , nak);   /* Clear the NAK Condition */
 80024ac:	f04f 0300 	mov.w	r3, #0
 80024b0:	64bb      	str	r3, [r7, #72]	; 0x48
 80024b2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80024b4:	f043 0310 	orr.w	r3, r3, #16
 80024b8:	64bb      	str	r3, [r7, #72]	; 0x48
 80024ba:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80024bc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80024be:	609a      	str	r2, [r3, #8]
    CLEAR_HC_INT(hcreg , stall); /* Clear the STALL Condition */
 80024c0:	f04f 0300 	mov.w	r3, #0
 80024c4:	647b      	str	r3, [r7, #68]	; 0x44
 80024c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80024c8:	f043 0308 	orr.w	r3, r3, #8
 80024cc:	647b      	str	r3, [r7, #68]	; 0x44
 80024ce:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80024d0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80024d2:	609a      	str	r2, [r3, #8]
    hcint.b.nak = 0;           /* NOTE: When there is a 'stall', reset also nak, 
 80024d4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80024d6:	f36f 1304 	bfc	r3, #4, #1
 80024da:	66bb      	str	r3, [r7, #104]	; 0x68
                                  else, the pdev->host.HC_Status = HC_STALL
                                  will be overwritten by 'nak' in code below */
    USB_OTG_HC_Halt(pdev, num);    
 80024dc:	683b      	ldr	r3, [r7, #0]
 80024de:	b2db      	uxtb	r3, r3
 80024e0:	6878      	ldr	r0, [r7, #4]
 80024e2:	4619      	mov	r1, r3
 80024e4:	f7fe ff46 	bl	8001374 <USB_OTG_HC_Halt>
 80024e8:	e040      	b.n	800256c <USB_OTG_USBH_handle_hc_n_In_ISR+0x1d0>
  }
  else if (hcint.b.datatglerr)
 80024ea:	f897 3069 	ldrb.w	r3, [r7, #105]	; 0x69
 80024ee:	f003 0304 	and.w	r3, r3, #4
 80024f2:	b2db      	uxtb	r3, r3
 80024f4:	2b00      	cmp	r3, #0
 80024f6:	d039      	beq.n	800256c <USB_OTG_USBH_handle_hc_n_In_ISR+0x1d0>
  {

      UNMASK_HOST_INT_CHH (num);
 80024f8:	687a      	ldr	r2, [r7, #4]
 80024fa:	683b      	ldr	r3, [r7, #0]
 80024fc:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002500:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002504:	18d3      	adds	r3, r2, r3
 8002506:	689b      	ldr	r3, [r3, #8]
 8002508:	68db      	ldr	r3, [r3, #12]
 800250a:	643b      	str	r3, [r7, #64]	; 0x40
 800250c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800250e:	f043 0302 	orr.w	r3, r3, #2
 8002512:	643b      	str	r3, [r7, #64]	; 0x40
 8002514:	687a      	ldr	r2, [r7, #4]
 8002516:	683b      	ldr	r3, [r7, #0]
 8002518:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800251c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002520:	18d3      	adds	r3, r2, r3
 8002522:	689b      	ldr	r3, [r3, #8]
 8002524:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002526:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 8002528:	683b      	ldr	r3, [r7, #0]
 800252a:	b2db      	uxtb	r3, r3
 800252c:	6878      	ldr	r0, [r7, #4]
 800252e:	4619      	mov	r1, r3
 8002530:	f7fe ff20 	bl	8001374 <USB_OTG_HC_Halt>
      CLEAR_HC_INT(hcreg , nak);   
 8002534:	f04f 0300 	mov.w	r3, #0
 8002538:	63fb      	str	r3, [r7, #60]	; 0x3c
 800253a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800253c:	f043 0310 	orr.w	r3, r3, #16
 8002540:	63fb      	str	r3, [r7, #60]	; 0x3c
 8002542:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8002544:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002546:	609a      	str	r2, [r3, #8]
      pdev->host.HC_Status[num] = HC_DATATGLERR; 
 8002548:	687a      	ldr	r2, [r7, #4]
 800254a:	683b      	ldr	r3, [r7, #0]
 800254c:	18d3      	adds	r3, r2, r3
 800254e:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8002552:	f04f 0208 	mov.w	r2, #8
 8002556:	711a      	strb	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , datatglerr);
 8002558:	f04f 0300 	mov.w	r3, #0
 800255c:	63bb      	str	r3, [r7, #56]	; 0x38
 800255e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8002560:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8002564:	63bb      	str	r3, [r7, #56]	; 0x38
 8002566:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8002568:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800256a:	609a      	str	r2, [r3, #8]
  }    
  
  if (hcint.b.frmovrun)
 800256c:	f897 3069 	ldrb.w	r3, [r7, #105]	; 0x69
 8002570:	f003 0302 	and.w	r3, r3, #2
 8002574:	b2db      	uxtb	r3, r3
 8002576:	2b00      	cmp	r3, #0
 8002578:	d028      	beq.n	80025cc <USB_OTG_USBH_handle_hc_n_In_ISR+0x230>
  {
    UNMASK_HOST_INT_CHH (num);
 800257a:	687a      	ldr	r2, [r7, #4]
 800257c:	683b      	ldr	r3, [r7, #0]
 800257e:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002582:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002586:	18d3      	adds	r3, r2, r3
 8002588:	689b      	ldr	r3, [r3, #8]
 800258a:	68db      	ldr	r3, [r3, #12]
 800258c:	637b      	str	r3, [r7, #52]	; 0x34
 800258e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002590:	f043 0302 	orr.w	r3, r3, #2
 8002594:	637b      	str	r3, [r7, #52]	; 0x34
 8002596:	687a      	ldr	r2, [r7, #4]
 8002598:	683b      	ldr	r3, [r7, #0]
 800259a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800259e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80025a2:	18d3      	adds	r3, r2, r3
 80025a4:	689b      	ldr	r3, [r3, #8]
 80025a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80025a8:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 80025aa:	683b      	ldr	r3, [r7, #0]
 80025ac:	b2db      	uxtb	r3, r3
 80025ae:	6878      	ldr	r0, [r7, #4]
 80025b0:	4619      	mov	r1, r3
 80025b2:	f7fe fedf 	bl	8001374 <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg ,frmovrun);
 80025b6:	f04f 0300 	mov.w	r3, #0
 80025ba:	633b      	str	r3, [r7, #48]	; 0x30
 80025bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80025be:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80025c2:	633b      	str	r3, [r7, #48]	; 0x30
 80025c4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80025c6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80025c8:	609a      	str	r2, [r3, #8]
 80025ca:	e1e5      	b.n	8002998 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5fc>
  }
  
  else if (hcint.b.xfercompl)
 80025cc:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 80025d0:	f003 0301 	and.w	r3, r3, #1
 80025d4:	b2db      	uxtb	r3, r3
 80025d6:	2b00      	cmp	r3, #0
 80025d8:	f000 80a5 	beq.w	8002726 <USB_OTG_USBH_handle_hc_n_In_ISR+0x38a>
  {
    
    if (pdev->cfg.dma_enable == 1)
 80025dc:	687b      	ldr	r3, [r7, #4]
 80025de:	78db      	ldrb	r3, [r3, #3]
 80025e0:	2b01      	cmp	r3, #1
 80025e2:	d11b      	bne.n	800261c <USB_OTG_USBH_handle_hc_n_In_ISR+0x280>
    {
      hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCTSIZ);
 80025e4:	687a      	ldr	r2, [r7, #4]
 80025e6:	683b      	ldr	r3, [r7, #0]
 80025e8:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80025ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80025f0:	18d3      	adds	r3, r2, r3
 80025f2:	689b      	ldr	r3, [r3, #8]
 80025f4:	691b      	ldr	r3, [r3, #16]
 80025f6:	65fb      	str	r3, [r7, #92]	; 0x5c
      pdev->host.XferCnt[num] =  pdev->host.hc[num].xfer_len - hctsiz.b.xfersize;
 80025f8:	687a      	ldr	r2, [r7, #4]
 80025fa:	683b      	ldr	r3, [r7, #0]
 80025fc:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8002600:	18d3      	adds	r3, r2, r3
 8002602:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8002606:	681a      	ldr	r2, [r3, #0]
 8002608:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800260a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800260e:	1ad1      	subs	r1, r2, r3
 8002610:	687b      	ldr	r3, [r7, #4]
 8002612:	683a      	ldr	r2, [r7, #0]
 8002614:	f102 0294 	add.w	r2, r2, #148	; 0x94
 8002618:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
 
    pdev->host.HC_Status[num] = HC_XFRC;     
 800261c:	687a      	ldr	r2, [r7, #4]
 800261e:	683b      	ldr	r3, [r7, #0]
 8002620:	18d3      	adds	r3, r2, r3
 8002622:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8002626:	f04f 0201 	mov.w	r2, #1
 800262a:	711a      	strb	r2, [r3, #4]
    pdev->host.ErrCnt [num]= 0;
 800262c:	687a      	ldr	r2, [r7, #4]
 800262e:	683b      	ldr	r3, [r7, #0]
 8002630:	f103 0384 	add.w	r3, r3, #132	; 0x84
 8002634:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002638:	18d3      	adds	r3, r2, r3
 800263a:	f04f 0200 	mov.w	r2, #0
 800263e:	605a      	str	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , xfercompl);
 8002640:	f04f 0300 	mov.w	r3, #0
 8002644:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002646:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002648:	f043 0301 	orr.w	r3, r3, #1
 800264c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800264e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002650:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002652:	609a      	str	r2, [r3, #8]
    
    if ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8002654:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8002658:	f003 030c 	and.w	r3, r3, #12
 800265c:	b2db      	uxtb	r3, r3
 800265e:	2b00      	cmp	r3, #0
 8002660:	d006      	beq.n	8002670 <USB_OTG_USBH_handle_hc_n_In_ISR+0x2d4>
        (hcchar.b.eptype == EP_TYPE_BULK))
 8002662:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8002666:	f003 030c 	and.w	r3, r3, #12
 800266a:	b2db      	uxtb	r3, r3
 
    pdev->host.HC_Status[num] = HC_XFRC;     
    pdev->host.ErrCnt [num]= 0;
    CLEAR_HC_INT(hcreg , xfercompl);
    
    if ((hcchar.b.eptype == EP_TYPE_CTRL)||
 800266c:	2b08      	cmp	r3, #8
 800266e:	d13b      	bne.n	80026e8 <USB_OTG_USBH_handle_hc_n_In_ISR+0x34c>
        (hcchar.b.eptype == EP_TYPE_BULK))
    {
      UNMASK_HOST_INT_CHH (num);
 8002670:	687a      	ldr	r2, [r7, #4]
 8002672:	683b      	ldr	r3, [r7, #0]
 8002674:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002678:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800267c:	18d3      	adds	r3, r2, r3
 800267e:	689b      	ldr	r3, [r3, #8]
 8002680:	68db      	ldr	r3, [r3, #12]
 8002682:	62bb      	str	r3, [r7, #40]	; 0x28
 8002684:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002686:	f043 0302 	orr.w	r3, r3, #2
 800268a:	62bb      	str	r3, [r7, #40]	; 0x28
 800268c:	687a      	ldr	r2, [r7, #4]
 800268e:	683b      	ldr	r3, [r7, #0]
 8002690:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002694:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002698:	18d3      	adds	r3, r2, r3
 800269a:	689b      	ldr	r3, [r3, #8]
 800269c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800269e:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 80026a0:	683b      	ldr	r3, [r7, #0]
 80026a2:	b2db      	uxtb	r3, r3
 80026a4:	6878      	ldr	r0, [r7, #4]
 80026a6:	4619      	mov	r1, r3
 80026a8:	f7fe fe64 	bl	8001374 <USB_OTG_HC_Halt>
      CLEAR_HC_INT(hcreg , nak); 
 80026ac:	f04f 0300 	mov.w	r3, #0
 80026b0:	627b      	str	r3, [r7, #36]	; 0x24
 80026b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026b4:	f043 0310 	orr.w	r3, r3, #16
 80026b8:	627b      	str	r3, [r7, #36]	; 0x24
 80026ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80026bc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80026be:	609a      	str	r2, [r3, #8]
      pdev->host.hc[num].toggle_in ^= 1;
 80026c0:	687a      	ldr	r2, [r7, #4]
 80026c2:	683b      	ldr	r3, [r7, #0]
 80026c4:	f103 0316 	add.w	r3, r3, #22
 80026c8:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80026cc:	18d3      	adds	r3, r2, r3
 80026ce:	791b      	ldrb	r3, [r3, #4]
 80026d0:	f083 0301 	eor.w	r3, r3, #1
 80026d4:	b2da      	uxtb	r2, r3
 80026d6:	6879      	ldr	r1, [r7, #4]
 80026d8:	683b      	ldr	r3, [r7, #0]
 80026da:	f103 0316 	add.w	r3, r3, #22
 80026de:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80026e2:	18cb      	adds	r3, r1, r3
 80026e4:	711a      	strb	r2, [r3, #4]
 80026e6:	e157      	b.n	8002998 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5fc>

    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
 80026e8:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 80026ec:	f003 030c 	and.w	r3, r3, #12
 80026f0:	b2db      	uxtb	r3, r3
 80026f2:	2b0c      	cmp	r3, #12
 80026f4:	f040 814f 	bne.w	8002996 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5fa>
    {
      hcchar.b.oddfrm  = 1;
 80026f8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80026fa:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80026fe:	663b      	str	r3, [r7, #96]	; 0x60
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
 8002700:	687a      	ldr	r2, [r7, #4]
 8002702:	683b      	ldr	r3, [r7, #0]
 8002704:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002708:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800270c:	18d3      	adds	r3, r2, r3
 800270e:	689b      	ldr	r3, [r3, #8]
 8002710:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8002712:	601a      	str	r2, [r3, #0]
      pdev->host.URB_State[num] = URB_DONE;  
 8002714:	687a      	ldr	r2, [r7, #4]
 8002716:	683b      	ldr	r3, [r7, #0]
 8002718:	18d3      	adds	r3, r2, r3
 800271a:	f503 7326 	add.w	r3, r3, #664	; 0x298
 800271e:	f04f 0201 	mov.w	r2, #1
 8002722:	70da      	strb	r2, [r3, #3]
 8002724:	e137      	b.n	8002996 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5fa>
    }
    
  }
  else if (hcint.b.chhltd)
 8002726:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 800272a:	f003 0302 	and.w	r3, r3, #2
 800272e:	b2db      	uxtb	r3, r3
 8002730:	2b00      	cmp	r3, #0
 8002732:	f000 8086 	beq.w	8002842 <USB_OTG_USBH_handle_hc_n_In_ISR+0x4a6>
  {
    MASK_HOST_INT_CHH (num);
 8002736:	687a      	ldr	r2, [r7, #4]
 8002738:	683b      	ldr	r3, [r7, #0]
 800273a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800273e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002742:	18d3      	adds	r3, r2, r3
 8002744:	689b      	ldr	r3, [r3, #8]
 8002746:	68db      	ldr	r3, [r3, #12]
 8002748:	623b      	str	r3, [r7, #32]
 800274a:	6a3b      	ldr	r3, [r7, #32]
 800274c:	f36f 0341 	bfc	r3, #1, #1
 8002750:	623b      	str	r3, [r7, #32]
 8002752:	687a      	ldr	r2, [r7, #4]
 8002754:	683b      	ldr	r3, [r7, #0]
 8002756:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800275a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800275e:	18d3      	adds	r3, r2, r3
 8002760:	689b      	ldr	r3, [r3, #8]
 8002762:	6a3a      	ldr	r2, [r7, #32]
 8002764:	60da      	str	r2, [r3, #12]
    
    if(pdev->host.HC_Status[num] == HC_XFRC)
 8002766:	687a      	ldr	r2, [r7, #4]
 8002768:	683b      	ldr	r3, [r7, #0]
 800276a:	18d3      	adds	r3, r2, r3
 800276c:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8002770:	791b      	ldrb	r3, [r3, #4]
 8002772:	b2db      	uxtb	r3, r3
 8002774:	2b01      	cmp	r3, #1
 8002776:	d108      	bne.n	800278a <USB_OTG_USBH_handle_hc_n_In_ISR+0x3ee>
    {
      pdev->host.URB_State[num] = URB_DONE;      
 8002778:	687a      	ldr	r2, [r7, #4]
 800277a:	683b      	ldr	r3, [r7, #0]
 800277c:	18d3      	adds	r3, r2, r3
 800277e:	f503 7326 	add.w	r3, r3, #664	; 0x298
 8002782:	f04f 0201 	mov.w	r2, #1
 8002786:	70da      	strb	r2, [r3, #3]
 8002788:	e050      	b.n	800282c <USB_OTG_USBH_handle_hc_n_In_ISR+0x490>
    }
    
    else if (pdev->host.HC_Status[num] == HC_STALL) 
 800278a:	687a      	ldr	r2, [r7, #4]
 800278c:	683b      	ldr	r3, [r7, #0]
 800278e:	18d3      	adds	r3, r2, r3
 8002790:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8002794:	791b      	ldrb	r3, [r3, #4]
 8002796:	b2db      	uxtb	r3, r3
 8002798:	2b05      	cmp	r3, #5
 800279a:	d108      	bne.n	80027ae <USB_OTG_USBH_handle_hc_n_In_ISR+0x412>
    {
       pdev->host.URB_State[num] = URB_STALL;
 800279c:	687a      	ldr	r2, [r7, #4]
 800279e:	683b      	ldr	r3, [r7, #0]
 80027a0:	18d3      	adds	r3, r2, r3
 80027a2:	f503 7326 	add.w	r3, r3, #664	; 0x298
 80027a6:	f04f 0204 	mov.w	r2, #4
 80027aa:	70da      	strb	r2, [r3, #3]
 80027ac:	e03e      	b.n	800282c <USB_OTG_USBH_handle_hc_n_In_ISR+0x490>
    }   
    
    else if((pdev->host.HC_Status[num] == HC_XACTERR) ||
 80027ae:	687a      	ldr	r2, [r7, #4]
 80027b0:	683b      	ldr	r3, [r7, #0]
 80027b2:	18d3      	adds	r3, r2, r3
 80027b4:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80027b8:	791b      	ldrb	r3, [r3, #4]
 80027ba:	b2db      	uxtb	r3, r3
 80027bc:	2b06      	cmp	r3, #6
 80027be:	d008      	beq.n	80027d2 <USB_OTG_USBH_handle_hc_n_In_ISR+0x436>
            (pdev->host.HC_Status[num] == HC_DATATGLERR))
 80027c0:	687a      	ldr	r2, [r7, #4]
 80027c2:	683b      	ldr	r3, [r7, #0]
 80027c4:	18d3      	adds	r3, r2, r3
 80027c6:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80027ca:	791b      	ldrb	r3, [r3, #4]
 80027cc:	b2db      	uxtb	r3, r3
    else if (pdev->host.HC_Status[num] == HC_STALL) 
    {
       pdev->host.URB_State[num] = URB_STALL;
    }   
    
    else if((pdev->host.HC_Status[num] == HC_XACTERR) ||
 80027ce:	2b08      	cmp	r3, #8
 80027d0:	d112      	bne.n	80027f8 <USB_OTG_USBH_handle_hc_n_In_ISR+0x45c>
            (pdev->host.HC_Status[num] == HC_DATATGLERR))
    {
        pdev->host.ErrCnt[num] = 0;
 80027d2:	687a      	ldr	r2, [r7, #4]
 80027d4:	683b      	ldr	r3, [r7, #0]
 80027d6:	f103 0384 	add.w	r3, r3, #132	; 0x84
 80027da:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80027de:	18d3      	adds	r3, r2, r3
 80027e0:	f04f 0200 	mov.w	r2, #0
 80027e4:	605a      	str	r2, [r3, #4]
        pdev->host.URB_State[num] = URB_ERROR;  
 80027e6:	687a      	ldr	r2, [r7, #4]
 80027e8:	683b      	ldr	r3, [r7, #0]
 80027ea:	18d3      	adds	r3, r2, r3
 80027ec:	f503 7326 	add.w	r3, r3, #664	; 0x298
 80027f0:	f04f 0203 	mov.w	r2, #3
 80027f4:	70da      	strb	r2, [r3, #3]
 80027f6:	e019      	b.n	800282c <USB_OTG_USBH_handle_hc_n_In_ISR+0x490>

    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
 80027f8:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 80027fc:	f003 030c 	and.w	r3, r3, #12
 8002800:	b2db      	uxtb	r3, r3
 8002802:	2b0c      	cmp	r3, #12
 8002804:	d112      	bne.n	800282c <USB_OTG_USBH_handle_hc_n_In_ISR+0x490>
    {
      pdev->host.hc[num].toggle_in ^= 1;
 8002806:	687a      	ldr	r2, [r7, #4]
 8002808:	683b      	ldr	r3, [r7, #0]
 800280a:	f103 0316 	add.w	r3, r3, #22
 800280e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8002812:	18d3      	adds	r3, r2, r3
 8002814:	791b      	ldrb	r3, [r3, #4]
 8002816:	f083 0301 	eor.w	r3, r3, #1
 800281a:	b2da      	uxtb	r2, r3
 800281c:	6879      	ldr	r1, [r7, #4]
 800281e:	683b      	ldr	r3, [r7, #0]
 8002820:	f103 0316 	add.w	r3, r3, #22
 8002824:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8002828:	18cb      	adds	r3, r1, r3
 800282a:	711a      	strb	r2, [r3, #4]
    }
    
    CLEAR_HC_INT(hcreg , chhltd);    
 800282c:	f04f 0300 	mov.w	r3, #0
 8002830:	61fb      	str	r3, [r7, #28]
 8002832:	69fb      	ldr	r3, [r7, #28]
 8002834:	f043 0302 	orr.w	r3, r3, #2
 8002838:	61fb      	str	r3, [r7, #28]
 800283a:	69fa      	ldr	r2, [r7, #28]
 800283c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800283e:	609a      	str	r2, [r3, #8]
 8002840:	e0aa      	b.n	8002998 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5fc>
    
  }    
  else if (hcint.b.xacterr)
 8002842:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8002846:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800284a:	b2db      	uxtb	r3, r3
 800284c:	2b00      	cmp	r3, #0
 800284e:	d042      	beq.n	80028d6 <USB_OTG_USBH_handle_hc_n_In_ISR+0x53a>
  {
    UNMASK_HOST_INT_CHH (num);
 8002850:	687a      	ldr	r2, [r7, #4]
 8002852:	683b      	ldr	r3, [r7, #0]
 8002854:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002858:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800285c:	18d3      	adds	r3, r2, r3
 800285e:	689b      	ldr	r3, [r3, #8]
 8002860:	68db      	ldr	r3, [r3, #12]
 8002862:	61bb      	str	r3, [r7, #24]
 8002864:	69bb      	ldr	r3, [r7, #24]
 8002866:	f043 0302 	orr.w	r3, r3, #2
 800286a:	61bb      	str	r3, [r7, #24]
 800286c:	687a      	ldr	r2, [r7, #4]
 800286e:	683b      	ldr	r3, [r7, #0]
 8002870:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002874:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002878:	18d3      	adds	r3, r2, r3
 800287a:	689b      	ldr	r3, [r3, #8]
 800287c:	69ba      	ldr	r2, [r7, #24]
 800287e:	60da      	str	r2, [r3, #12]
    pdev->host.ErrCnt[num] ++;
 8002880:	687a      	ldr	r2, [r7, #4]
 8002882:	683b      	ldr	r3, [r7, #0]
 8002884:	f103 0384 	add.w	r3, r3, #132	; 0x84
 8002888:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800288c:	18d3      	adds	r3, r2, r3
 800288e:	685b      	ldr	r3, [r3, #4]
 8002890:	f103 0201 	add.w	r2, r3, #1
 8002894:	6879      	ldr	r1, [r7, #4]
 8002896:	683b      	ldr	r3, [r7, #0]
 8002898:	f103 0384 	add.w	r3, r3, #132	; 0x84
 800289c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80028a0:	18cb      	adds	r3, r1, r3
 80028a2:	605a      	str	r2, [r3, #4]
    pdev->host.HC_Status[num] = HC_XACTERR;
 80028a4:	687a      	ldr	r2, [r7, #4]
 80028a6:	683b      	ldr	r3, [r7, #0]
 80028a8:	18d3      	adds	r3, r2, r3
 80028aa:	f503 7322 	add.w	r3, r3, #648	; 0x288
 80028ae:	f04f 0206 	mov.w	r2, #6
 80028b2:	711a      	strb	r2, [r3, #4]
    USB_OTG_HC_Halt(pdev, num);
 80028b4:	683b      	ldr	r3, [r7, #0]
 80028b6:	b2db      	uxtb	r3, r3
 80028b8:	6878      	ldr	r0, [r7, #4]
 80028ba:	4619      	mov	r1, r3
 80028bc:	f7fe fd5a 	bl	8001374 <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , xacterr);    
 80028c0:	f04f 0300 	mov.w	r3, #0
 80028c4:	617b      	str	r3, [r7, #20]
 80028c6:	697b      	ldr	r3, [r7, #20]
 80028c8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80028cc:	617b      	str	r3, [r7, #20]
 80028ce:	697a      	ldr	r2, [r7, #20]
 80028d0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80028d2:	609a      	str	r2, [r3, #8]
 80028d4:	e060      	b.n	8002998 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5fc>
    
  }
  else if (hcint.b.nak)  
 80028d6:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 80028da:	f003 0310 	and.w	r3, r3, #16
 80028de:	b2db      	uxtb	r3, r3
 80028e0:	2b00      	cmp	r3, #0
 80028e2:	d059      	beq.n	8002998 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5fc>
  {  
    if(hcchar.b.eptype == EP_TYPE_INTR)
 80028e4:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 80028e8:	f003 030c 	and.w	r3, r3, #12
 80028ec:	b2db      	uxtb	r3, r3
 80028ee:	2b0c      	cmp	r3, #12
 80028f0:	d128      	bne.n	8002944 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5a8>
    {
      UNMASK_HOST_INT_CHH (num);
 80028f2:	687a      	ldr	r2, [r7, #4]
 80028f4:	683b      	ldr	r3, [r7, #0]
 80028f6:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80028fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80028fe:	18d3      	adds	r3, r2, r3
 8002900:	689b      	ldr	r3, [r3, #8]
 8002902:	68db      	ldr	r3, [r3, #12]
 8002904:	613b      	str	r3, [r7, #16]
 8002906:	693b      	ldr	r3, [r7, #16]
 8002908:	f043 0302 	orr.w	r3, r3, #2
 800290c:	613b      	str	r3, [r7, #16]
 800290e:	687a      	ldr	r2, [r7, #4]
 8002910:	683b      	ldr	r3, [r7, #0]
 8002912:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002916:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800291a:	18d3      	adds	r3, r2, r3
 800291c:	689b      	ldr	r3, [r3, #8]
 800291e:	693a      	ldr	r2, [r7, #16]
 8002920:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 8002922:	683b      	ldr	r3, [r7, #0]
 8002924:	b2db      	uxtb	r3, r3
 8002926:	6878      	ldr	r0, [r7, #4]
 8002928:	4619      	mov	r1, r3
 800292a:	f7fe fd23 	bl	8001374 <USB_OTG_HC_Halt>
      CLEAR_HC_INT(hcreg , nak);   
 800292e:	f04f 0300 	mov.w	r3, #0
 8002932:	60fb      	str	r3, [r7, #12]
 8002934:	68fb      	ldr	r3, [r7, #12]
 8002936:	f043 0310 	orr.w	r3, r3, #16
 800293a:	60fb      	str	r3, [r7, #12]
 800293c:	68fa      	ldr	r2, [r7, #12]
 800293e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002940:	609a      	str	r2, [r3, #8]
 8002942:	e01f      	b.n	8002984 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5e8>
    }
     else if  ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8002944:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8002948:	f003 030c 	and.w	r3, r3, #12
 800294c:	b2db      	uxtb	r3, r3
 800294e:	2b00      	cmp	r3, #0
 8002950:	d006      	beq.n	8002960 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5c4>
             (hcchar.b.eptype == EP_TYPE_BULK))
 8002952:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8002956:	f003 030c 	and.w	r3, r3, #12
 800295a:	b2db      	uxtb	r3, r3
    {
      UNMASK_HOST_INT_CHH (num);
      USB_OTG_HC_Halt(pdev, num);
      CLEAR_HC_INT(hcreg , nak);   
    }
     else if  ((hcchar.b.eptype == EP_TYPE_CTRL)||
 800295c:	2b08      	cmp	r3, #8
 800295e:	d111      	bne.n	8002984 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5e8>
             (hcchar.b.eptype == EP_TYPE_BULK))
    {
      /* re-activate the channel  */
      hcchar.b.chen = 1;
 8002960:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8002962:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002966:	663b      	str	r3, [r7, #96]	; 0x60
      hcchar.b.chdis = 0;
 8002968:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800296a:	f36f 739e 	bfc	r3, #30, #1
 800296e:	663b      	str	r3, [r7, #96]	; 0x60
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
 8002970:	687a      	ldr	r2, [r7, #4]
 8002972:	683b      	ldr	r3, [r7, #0]
 8002974:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002978:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800297c:	18d3      	adds	r3, r2, r3
 800297e:	689b      	ldr	r3, [r3, #8]
 8002980:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8002982:	601a      	str	r2, [r3, #0]
    }
    pdev->host.HC_Status[num] = HC_NAK;
 8002984:	687a      	ldr	r2, [r7, #4]
 8002986:	683b      	ldr	r3, [r7, #0]
 8002988:	18d3      	adds	r3, r2, r3
 800298a:	f503 7322 	add.w	r3, r3, #648	; 0x288
 800298e:	f04f 0203 	mov.w	r2, #3
 8002992:	711a      	strb	r2, [r3, #4]
 8002994:	e000      	b.n	8002998 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5fc>
    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
    {
      hcchar.b.oddfrm  = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
      pdev->host.URB_State[num] = URB_DONE;  
 8002996:	bf00      	nop
    }
    pdev->host.HC_Status[num] = HC_NAK;
  }

  
  return 1;
 8002998:	f04f 0301 	mov.w	r3, #1
  
}
 800299c:	4618      	mov	r0, r3
 800299e:	f107 0770 	add.w	r7, r7, #112	; 0x70
 80029a2:	46bd      	mov	sp, r7
 80029a4:	bd80      	pop	{r7, pc}
 80029a6:	bf00      	nop

080029a8 <USB_OTG_USBH_handle_rx_qlvl_ISR>:
  * @param  pdev: Selected device
  * @retval status 
  */

static uint32_t USB_OTG_USBH_handle_rx_qlvl_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 80029a8:	b580      	push	{r7, lr}
 80029aa:	b088      	sub	sp, #32
 80029ac:	af00      	add	r7, sp, #0
 80029ae:	6078      	str	r0, [r7, #4]
  USB_OTG_GRXFSTS_TypeDef       grxsts;
  USB_OTG_GINTMSK_TypeDef       intmsk;
  USB_OTG_HCTSIZn_TypeDef       hctsiz; 
  USB_OTG_HCCHAR_TypeDef        hcchar;
  __IO uint8_t                  channelnum =0;  
 80029b0:	f04f 0300 	mov.w	r3, #0
 80029b4:	72fb      	strb	r3, [r7, #11]
  uint32_t                      count;    
  
  /* Disable the Rx Status Queue Level interrupt */
  intmsk.d32 = 0;
 80029b6:	f04f 0300 	mov.w	r3, #0
 80029ba:	617b      	str	r3, [r7, #20]
  intmsk.b.rxstsqlvl = 1;
 80029bc:	697b      	ldr	r3, [r7, #20]
 80029be:	f043 0310 	orr.w	r3, r3, #16
 80029c2:	617b      	str	r3, [r7, #20]
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);
 80029c4:	687b      	ldr	r3, [r7, #4]
 80029c6:	68db      	ldr	r3, [r3, #12]
 80029c8:	687a      	ldr	r2, [r7, #4]
 80029ca:	68d2      	ldr	r2, [r2, #12]
 80029cc:	6992      	ldr	r2, [r2, #24]
 80029ce:	4611      	mov	r1, r2
 80029d0:	697a      	ldr	r2, [r7, #20]
 80029d2:	ea6f 0202 	mvn.w	r2, r2
 80029d6:	400a      	ands	r2, r1
 80029d8:	619a      	str	r2, [r3, #24]
  
  grxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRXSTSP);
 80029da:	687b      	ldr	r3, [r7, #4]
 80029dc:	68db      	ldr	r3, [r3, #12]
 80029de:	6a1b      	ldr	r3, [r3, #32]
 80029e0:	61bb      	str	r3, [r7, #24]
  channelnum = grxsts.b.chnum;  
 80029e2:	69bb      	ldr	r3, [r7, #24]
 80029e4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80029e8:	b2db      	uxtb	r3, r3
 80029ea:	72fb      	strb	r3, [r7, #11]
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR);
 80029ec:	7afb      	ldrb	r3, [r7, #11]
 80029ee:	b2db      	uxtb	r3, r3
 80029f0:	687a      	ldr	r2, [r7, #4]
 80029f2:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80029f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80029fa:	18d3      	adds	r3, r2, r3
 80029fc:	689b      	ldr	r3, [r3, #8]
 80029fe:	681b      	ldr	r3, [r3, #0]
 8002a00:	60fb      	str	r3, [r7, #12]
  
  switch (grxsts.b.pktsts)
 8002a02:	69bb      	ldr	r3, [r7, #24]
 8002a04:	f3c3 4343 	ubfx	r3, r3, #17, #4
 8002a08:	b2db      	uxtb	r3, r3
 8002a0a:	2b02      	cmp	r3, #2
 8002a0c:	f040 809b 	bne.w	8002b46 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x19e>
  {
  case GRXSTS_PKTSTS_IN:
    /* Read the data into the host buffer. */
    if ((grxsts.b.bcnt > 0) && (pdev->host.hc[channelnum].xfer_buff != (void  *)0))
 8002a10:	69bb      	ldr	r3, [r7, #24]
 8002a12:	f3c3 130a 	ubfx	r3, r3, #4, #11
 8002a16:	b29b      	uxth	r3, r3
 8002a18:	2b00      	cmp	r3, #0
 8002a1a:	f340 8095 	ble.w	8002b48 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1a0>
 8002a1e:	7afb      	ldrb	r3, [r7, #11]
 8002a20:	b2db      	uxtb	r3, r3
 8002a22:	687a      	ldr	r2, [r7, #4]
 8002a24:	f103 030d 	add.w	r3, r3, #13
 8002a28:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8002a2c:	18d3      	adds	r3, r2, r3
 8002a2e:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002a32:	681b      	ldr	r3, [r3, #0]
 8002a34:	2b00      	cmp	r3, #0
 8002a36:	f000 8087 	beq.w	8002b48 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1a0>
    {  
      
      USB_OTG_ReadPacket(pdev, pdev->host.hc[channelnum].xfer_buff, grxsts.b.bcnt);
 8002a3a:	7afb      	ldrb	r3, [r7, #11]
 8002a3c:	b2db      	uxtb	r3, r3
 8002a3e:	687a      	ldr	r2, [r7, #4]
 8002a40:	f103 030d 	add.w	r3, r3, #13
 8002a44:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8002a48:	18d3      	adds	r3, r2, r3
 8002a4a:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002a4e:	681a      	ldr	r2, [r3, #0]
 8002a50:	69bb      	ldr	r3, [r7, #24]
 8002a52:	f3c3 130a 	ubfx	r3, r3, #4, #11
 8002a56:	b29b      	uxth	r3, r3
 8002a58:	6878      	ldr	r0, [r7, #4]
 8002a5a:	4611      	mov	r1, r2
 8002a5c:	461a      	mov	r2, r3
 8002a5e:	f7fd fc75 	bl	800034c <USB_OTG_ReadPacket>
      /*manage multiple Xfer */
      pdev->host.hc[grxsts.b.chnum].xfer_buff += grxsts.b.bcnt;           
 8002a62:	69bb      	ldr	r3, [r7, #24]
 8002a64:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8002a68:	b2db      	uxtb	r3, r3
 8002a6a:	69ba      	ldr	r2, [r7, #24]
 8002a6c:	f3c2 0203 	ubfx	r2, r2, #0, #4
 8002a70:	b2d2      	uxtb	r2, r2
 8002a72:	6879      	ldr	r1, [r7, #4]
 8002a74:	f102 020d 	add.w	r2, r2, #13
 8002a78:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8002a7c:	188a      	adds	r2, r1, r2
 8002a7e:	f502 728c 	add.w	r2, r2, #280	; 0x118
 8002a82:	6811      	ldr	r1, [r2, #0]
 8002a84:	69ba      	ldr	r2, [r7, #24]
 8002a86:	f3c2 120a 	ubfx	r2, r2, #4, #11
 8002a8a:	b292      	uxth	r2, r2
 8002a8c:	188a      	adds	r2, r1, r2
 8002a8e:	6879      	ldr	r1, [r7, #4]
 8002a90:	f103 030d 	add.w	r3, r3, #13
 8002a94:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8002a98:	18cb      	adds	r3, r1, r3
 8002a9a:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002a9e:	601a      	str	r2, [r3, #0]
      pdev->host.hc[grxsts.b.chnum].xfer_count  += grxsts.b.bcnt;
 8002aa0:	69bb      	ldr	r3, [r7, #24]
 8002aa2:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8002aa6:	b2db      	uxtb	r3, r3
 8002aa8:	69ba      	ldr	r2, [r7, #24]
 8002aaa:	f3c2 0203 	ubfx	r2, r2, #0, #4
 8002aae:	b2d2      	uxtb	r2, r2
 8002ab0:	6879      	ldr	r1, [r7, #4]
 8002ab2:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8002ab6:	188a      	adds	r2, r1, r2
 8002ab8:	f502 7230 	add.w	r2, r2, #704	; 0x2c0
 8002abc:	6811      	ldr	r1, [r2, #0]
 8002abe:	69ba      	ldr	r2, [r7, #24]
 8002ac0:	f3c2 120a 	ubfx	r2, r2, #4, #11
 8002ac4:	b292      	uxth	r2, r2
 8002ac6:	188a      	adds	r2, r1, r2
 8002ac8:	6879      	ldr	r1, [r7, #4]
 8002aca:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8002ace:	18cb      	adds	r3, r1, r3
 8002ad0:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8002ad4:	601a      	str	r2, [r3, #0]
      
     
      count = pdev->host.hc[channelnum].xfer_count;
 8002ad6:	7afb      	ldrb	r3, [r7, #11]
 8002ad8:	b2db      	uxtb	r3, r3
 8002ada:	687a      	ldr	r2, [r7, #4]
 8002adc:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8002ae0:	18d3      	adds	r3, r2, r3
 8002ae2:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8002ae6:	681b      	ldr	r3, [r3, #0]
 8002ae8:	61fb      	str	r3, [r7, #28]
      pdev->host.XferCnt[channelnum]  = count;
 8002aea:	7afb      	ldrb	r3, [r7, #11]
 8002aec:	b2db      	uxtb	r3, r3
 8002aee:	461a      	mov	r2, r3
 8002af0:	687b      	ldr	r3, [r7, #4]
 8002af2:	f102 0294 	add.w	r2, r2, #148	; 0x94
 8002af6:	69f9      	ldr	r1, [r7, #28]
 8002af8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      
      hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCTSIZ);
 8002afc:	7afb      	ldrb	r3, [r7, #11]
 8002afe:	b2db      	uxtb	r3, r3
 8002b00:	687a      	ldr	r2, [r7, #4]
 8002b02:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002b06:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002b0a:	18d3      	adds	r3, r2, r3
 8002b0c:	689b      	ldr	r3, [r3, #8]
 8002b0e:	691b      	ldr	r3, [r3, #16]
 8002b10:	613b      	str	r3, [r7, #16]
      if(hctsiz.b.pktcnt > 0)
 8002b12:	693b      	ldr	r3, [r7, #16]
 8002b14:	f3c3 43c9 	ubfx	r3, r3, #19, #10
 8002b18:	b29b      	uxth	r3, r3
 8002b1a:	2b00      	cmp	r3, #0
 8002b1c:	dd14      	ble.n	8002b48 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1a0>
      {
        /* re-activate the channel when more packets are expected */
        hcchar.b.chen = 1;
 8002b1e:	68fb      	ldr	r3, [r7, #12]
 8002b20:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002b24:	60fb      	str	r3, [r7, #12]
        hcchar.b.chdis = 0;
 8002b26:	68fb      	ldr	r3, [r7, #12]
 8002b28:	f36f 739e 	bfc	r3, #30, #1
 8002b2c:	60fb      	str	r3, [r7, #12]
        USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR, hcchar.d32);
 8002b2e:	7afb      	ldrb	r3, [r7, #11]
 8002b30:	b2db      	uxtb	r3, r3
 8002b32:	687a      	ldr	r2, [r7, #4]
 8002b34:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8002b38:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002b3c:	18d3      	adds	r3, r2, r3
 8002b3e:	689b      	ldr	r3, [r3, #8]
 8002b40:	68fa      	ldr	r2, [r7, #12]
 8002b42:	601a      	str	r2, [r3, #0]
      }
    }
    break;
 8002b44:	e000      	b.n	8002b48 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1a0>
    case GRXSTS_PKTSTS_IN_XFER_COMP:
   
    case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
  case GRXSTS_PKTSTS_CH_HALTED:
  default:
    break;
 8002b46:	e000      	b.n	8002b4a <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1a2>
        hcchar.b.chen = 1;
        hcchar.b.chdis = 0;
        USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR, hcchar.d32);
      }
    }
    break;
 8002b48:	bf00      	nop
  default:
    break;
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  intmsk.b.rxstsqlvl = 1;
 8002b4a:	697b      	ldr	r3, [r7, #20]
 8002b4c:	f043 0310 	orr.w	r3, r3, #16
 8002b50:	617b      	str	r3, [r7, #20]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);
 8002b52:	687b      	ldr	r3, [r7, #4]
 8002b54:	68db      	ldr	r3, [r3, #12]
 8002b56:	687a      	ldr	r2, [r7, #4]
 8002b58:	68d2      	ldr	r2, [r2, #12]
 8002b5a:	6992      	ldr	r2, [r2, #24]
 8002b5c:	4611      	mov	r1, r2
 8002b5e:	697a      	ldr	r2, [r7, #20]
 8002b60:	430a      	orrs	r2, r1
 8002b62:	619a      	str	r2, [r3, #24]
  return 1;
 8002b64:	f04f 0301 	mov.w	r3, #1
}
 8002b68:	4618      	mov	r0, r3
 8002b6a:	f107 0720 	add.w	r7, r7, #32
 8002b6e:	46bd      	mov	sp, r7
 8002b70:	bd80      	pop	{r7, pc}
 8002b72:	bf00      	nop

08002b74 <USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR>:
  *         Handles the incomplete Periodic transfer Interrupt
  * @param  pdev: Selected device
  * @retval status 
  */
static uint32_t USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8002b74:	b480      	push	{r7}
 8002b76:	b085      	sub	sp, #20
 8002b78:	af00      	add	r7, sp, #0
 8002b7a:	6078      	str	r0, [r7, #4]
    USB_OTG_HCCHAR_TypeDef        hcchar; 
   
    

    
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[0]->HCCHAR);
 8002b7c:	687b      	ldr	r3, [r7, #4]
 8002b7e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002b82:	681b      	ldr	r3, [r3, #0]
 8002b84:	60bb      	str	r3, [r7, #8]
    hcchar.b.chen = 1;
 8002b86:	68bb      	ldr	r3, [r7, #8]
 8002b88:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002b8c:	60bb      	str	r3, [r7, #8]
    hcchar.b.chdis = 1;
 8002b8e:	68bb      	ldr	r3, [r7, #8]
 8002b90:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8002b94:	60bb      	str	r3, [r7, #8]
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[0]->HCCHAR, hcchar.d32);  
 8002b96:	687b      	ldr	r3, [r7, #4]
 8002b98:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002b9c:	68ba      	ldr	r2, [r7, #8]
 8002b9e:	601a      	str	r2, [r3, #0]
    
    gintsts.d32 = 0;
 8002ba0:	f04f 0300 	mov.w	r3, #0
 8002ba4:	60fb      	str	r3, [r7, #12]
    /* Clear interrupt */
    gintsts.b.incomplisoout = 1;
 8002ba6:	68fb      	ldr	r3, [r7, #12]
 8002ba8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002bac:	60fb      	str	r3, [r7, #12]
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8002bae:	687b      	ldr	r3, [r7, #4]
 8002bb0:	68db      	ldr	r3, [r3, #12]
 8002bb2:	68fa      	ldr	r2, [r7, #12]
 8002bb4:	615a      	str	r2, [r3, #20]

    return 1;
 8002bb6:	f04f 0301 	mov.w	r3, #1
}
 8002bba:	4618      	mov	r0, r3
 8002bbc:	f107 0714 	add.w	r7, r7, #20
 8002bc0:	46bd      	mov	sp, r7
 8002bc2:	bc80      	pop	{r7}
 8002bc4:	4770      	bx	lr
 8002bc6:	bf00      	nop

08002bc8 <USBH_Connect>:
  *         USB Connect callback function from the Interrupt. 
  * @param  selected device
  * @retval none
  */
void USBH_Connect (void *pdev)
{
 8002bc8:	b480      	push	{r7}
 8002bca:	b085      	sub	sp, #20
 8002bcc:	af00      	add	r7, sp, #0
 8002bce:	6078      	str	r0, [r7, #4]
  USB_OTG_CORE_HANDLE *ppdev = pdev;
 8002bd0:	687b      	ldr	r3, [r7, #4]
 8002bd2:	60fb      	str	r3, [r7, #12]
  ppdev->host.port_cb->ConnStatus = 1;
 8002bd4:	68fb      	ldr	r3, [r7, #12]
 8002bd6:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002bda:	f04f 0201 	mov.w	r2, #1
 8002bde:	721a      	strb	r2, [r3, #8]
  ppdev->host.port_cb->ConnHandled = 0; 
 8002be0:	68fb      	ldr	r3, [r7, #12]
 8002be2:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002be6:	f04f 0200 	mov.w	r2, #0
 8002bea:	729a      	strb	r2, [r3, #10]
}
 8002bec:	f107 0714 	add.w	r7, r7, #20
 8002bf0:	46bd      	mov	sp, r7
 8002bf2:	bc80      	pop	{r7}
 8002bf4:	4770      	bx	lr
 8002bf6:	bf00      	nop

08002bf8 <USBH_Disconnect>:
  * @param  selected device
  * @retval none
  */

void USBH_Disconnect (void *pdev)
{
 8002bf8:	b480      	push	{r7}
 8002bfa:	b085      	sub	sp, #20
 8002bfc:	af00      	add	r7, sp, #0
 8002bfe:	6078      	str	r0, [r7, #4]
  
  USB_OTG_CORE_HANDLE *ppdev = pdev;
 8002c00:	687b      	ldr	r3, [r7, #4]
 8002c02:	60fb      	str	r3, [r7, #12]
    
  /* Make device Not connected flag true */
  ppdev->host.port_cb->DisconnStatus = 1; 
 8002c04:	68fb      	ldr	r3, [r7, #12]
 8002c06:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002c0a:	f04f 0201 	mov.w	r2, #1
 8002c0e:	725a      	strb	r2, [r3, #9]
  ppdev->host.port_cb->DisconnHandled = 0;
 8002c10:	68fb      	ldr	r3, [r7, #12]
 8002c12:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002c16:	f04f 0200 	mov.w	r2, #0
 8002c1a:	72da      	strb	r2, [r3, #11]
}
 8002c1c:	f107 0714 	add.w	r7, r7, #20
 8002c20:	46bd      	mov	sp, r7
 8002c22:	bc80      	pop	{r7}
 8002c24:	4770      	bx	lr
 8002c26:	bf00      	nop

08002c28 <USBH_Init>:
void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
               USB_OTG_CORE_ID_TypeDef coreID,
               USBH_HOST *phost,               
               USBH_Class_cb_TypeDef *class_cb, 
               USBH_Usr_cb_TypeDef *usr_cb)
{
 8002c28:	b580      	push	{r7, lr}
 8002c2a:	b084      	sub	sp, #16
 8002c2c:	af00      	add	r7, sp, #0
 8002c2e:	60f8      	str	r0, [r7, #12]
 8002c30:	607a      	str	r2, [r7, #4]
 8002c32:	603b      	str	r3, [r7, #0]
 8002c34:	460b      	mov	r3, r1
 8002c36:	72fb      	strb	r3, [r7, #11]
     
  /* Hardware Init */
  USB_OTG_BSP_Init(pdev);  
 8002c38:	68f8      	ldr	r0, [r7, #12]
 8002c3a:	f019 fe6b 	bl	801c914 <USB_OTG_BSP_Init>
  
  /* configure GPIO pin used for switching VBUS power */
  USB_OTG_BSP_ConfigVBUS(0);  
 8002c3e:	f04f 0000 	mov.w	r0, #0
 8002c42:	f019 ff13 	bl	801ca6c <USB_OTG_BSP_ConfigVBUS>
  
  
  /* Host de-initializations */
  USBH_DeInit(pdev, phost);
 8002c46:	68f8      	ldr	r0, [r7, #12]
 8002c48:	6879      	ldr	r1, [r7, #4]
 8002c4a:	f000 f82b 	bl	8002ca4 <USBH_DeInit>
  
  /*Register class and user callbacks */
  phost->class_cb = class_cb;
 8002c4e:	687b      	ldr	r3, [r7, #4]
 8002c50:	683a      	ldr	r2, [r7, #0]
 8002c52:	67da      	str	r2, [r3, #124]	; 0x7c
  phost->usr_cb = usr_cb;  
 8002c54:	687b      	ldr	r3, [r7, #4]
 8002c56:	69ba      	ldr	r2, [r7, #24]
 8002c58:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  pdev->host.port_cb = &USBH_DeviceConnStatus_cb;
 8002c5c:	68fa      	ldr	r2, [r7, #12]
 8002c5e:	f240 0304 	movw	r3, #4
 8002c62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c66:	f8c2 34ac 	str.w	r3, [r2, #1196]	; 0x4ac
  
  pdev->host.port_cb->ConnStatus = 0;   
 8002c6a:	68fb      	ldr	r3, [r7, #12]
 8002c6c:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002c70:	f04f 0200 	mov.w	r2, #0
 8002c74:	721a      	strb	r2, [r3, #8]
  pdev->host.port_cb->DisconnStatus = 0; 
 8002c76:	68fb      	ldr	r3, [r7, #12]
 8002c78:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002c7c:	f04f 0200 	mov.w	r2, #0
 8002c80:	725a      	strb	r2, [r3, #9]
  
    
  /* Start the USB OTG core */     
   HCD_Init(pdev , coreID);
 8002c82:	7afb      	ldrb	r3, [r7, #11]
 8002c84:	68f8      	ldr	r0, [r7, #12]
 8002c86:	4619      	mov	r1, r3
 8002c88:	f7fe fc56 	bl	8001538 <HCD_Init>
   
  /* Upon Init call usr call back */
  phost->usr_cb->Init();
 8002c8c:	687b      	ldr	r3, [r7, #4]
 8002c8e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002c92:	681b      	ldr	r3, [r3, #0]
 8002c94:	4798      	blx	r3
  
  /* Enable Interrupts */
  USB_OTG_BSP_EnableInterrupt(pdev);
 8002c96:	68f8      	ldr	r0, [r7, #12]
 8002c98:	f019 feac 	bl	801c9f4 <USB_OTG_BSP_EnableInterrupt>
}
 8002c9c:	f107 0710 	add.w	r7, r7, #16
 8002ca0:	46bd      	mov	sp, r7
 8002ca2:	bd80      	pop	{r7, pc}

08002ca4 <USBH_DeInit>:
  *         Re-Initialize Host
  * @param  None 
  * @retval status: USBH_Status
  */
USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
{
 8002ca4:	b580      	push	{r7, lr}
 8002ca6:	b082      	sub	sp, #8
 8002ca8:	af00      	add	r7, sp, #0
 8002caa:	6078      	str	r0, [r7, #4]
 8002cac:	6039      	str	r1, [r7, #0]
  /* Software Init */
  
  phost->gState = HOST_IDLE;
 8002cae:	683b      	ldr	r3, [r7, #0]
 8002cb0:	f04f 0200 	mov.w	r2, #0
 8002cb4:	701a      	strb	r2, [r3, #0]
  phost->gStateBkp = HOST_IDLE; 
 8002cb6:	683b      	ldr	r3, [r7, #0]
 8002cb8:	f04f 0200 	mov.w	r2, #0
 8002cbc:	705a      	strb	r2, [r3, #1]
  phost->EnumState = ENUM_IDLE;
 8002cbe:	683b      	ldr	r3, [r7, #0]
 8002cc0:	f04f 0200 	mov.w	r2, #0
 8002cc4:	709a      	strb	r2, [r3, #2]
  phost->RequestState = CMD_SEND;  
 8002cc6:	683b      	ldr	r3, [r7, #0]
 8002cc8:	f04f 0201 	mov.w	r2, #1
 8002ccc:	70da      	strb	r2, [r3, #3]
  
  phost->Control.state = CTRL_SETUP;
 8002cce:	683b      	ldr	r3, [r7, #0]
 8002cd0:	f04f 0201 	mov.w	r2, #1
 8002cd4:	771a      	strb	r2, [r3, #28]
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 8002cd6:	683b      	ldr	r3, [r7, #0]
 8002cd8:	f04f 0240 	mov.w	r2, #64	; 0x40
 8002cdc:	719a      	strb	r2, [r3, #6]
  
  phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
 8002cde:	683b      	ldr	r3, [r7, #0]
 8002ce0:	f04f 0200 	mov.w	r2, #0
 8002ce4:	f883 2020 	strb.w	r2, [r3, #32]
  phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
 8002ce8:	683b      	ldr	r3, [r7, #0]
 8002cea:	f04f 0201 	mov.w	r2, #1
 8002cee:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  
  USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
 8002cf2:	683b      	ldr	r3, [r7, #0]
 8002cf4:	791b      	ldrb	r3, [r3, #4]
 8002cf6:	6878      	ldr	r0, [r7, #4]
 8002cf8:	4619      	mov	r1, r3
 8002cfa:	f000 fde7 	bl	80038cc <USBH_Free_Channel>
  USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
 8002cfe:	683b      	ldr	r3, [r7, #0]
 8002d00:	795b      	ldrb	r3, [r3, #5]
 8002d02:	6878      	ldr	r0, [r7, #4]
 8002d04:	4619      	mov	r1, r3
 8002d06:	f000 fde1 	bl	80038cc <USBH_Free_Channel>
  return USBH_OK;
 8002d0a:	f04f 0300 	mov.w	r3, #0
}
 8002d0e:	4618      	mov	r0, r3
 8002d10:	f107 0708 	add.w	r7, r7, #8
 8002d14:	46bd      	mov	sp, r7
 8002d16:	bd80      	pop	{r7, pc}

08002d18 <USBH_Process>:
*         USB Host core main state machine process
* @param  None 
* @retval None
*/
void USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
{
 8002d18:	b590      	push	{r4, r7, lr}
 8002d1a:	b087      	sub	sp, #28
 8002d1c:	af02      	add	r7, sp, #8
 8002d1e:	6078      	str	r0, [r7, #4]
 8002d20:	6039      	str	r1, [r7, #0]
  volatile USBH_Status status = USBH_FAIL;
 8002d22:	f04f 0302 	mov.w	r3, #2
 8002d26:	73fb      	strb	r3, [r7, #15]
    
  switch (phost->gState)
 8002d28:	683b      	ldr	r3, [r7, #0]
 8002d2a:	781b      	ldrb	r3, [r3, #0]
 8002d2c:	2b0c      	cmp	r3, #12
 8002d2e:	f200 8105 	bhi.w	8002f3c <USBH_Process+0x224>
 8002d32:	a201      	add	r2, pc, #4	; (adr r2, 8002d38 <USBH_Process+0x20>)
 8002d34:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002d38:	08002d85 	.word	0x08002d85
 8002d3c:	08002d6d 	.word	0x08002d6d
 8002d40:	08002da3 	.word	0x08002da3
 8002d44:	08002f3d 	.word	0x08002f3d
 8002d48:	08002f3d 	.word	0x08002f3d
 8002d4c:	08002f3d 	.word	0x08002f3d
 8002d50:	08002e71 	.word	0x08002e71
 8002d54:	08002ebf 	.word	0x08002ebf
 8002d58:	08002eef 	.word	0x08002eef
 8002d5c:	08002f0d 	.word	0x08002f0d
 8002d60:	08002e93 	.word	0x08002e93
 8002d64:	08002f3d 	.word	0x08002f3d
 8002d68:	08002f17 	.word	0x08002f17
  {
  case HOST_ISSUE_CORE_RESET :
     
    if ( HCD_ResetPort(pdev) == 0)
 8002d6c:	6878      	ldr	r0, [r7, #4]
 8002d6e:	f7fe fc4b 	bl	8001608 <HCD_ResetPort>
 8002d72:	4603      	mov	r3, r0
 8002d74:	2b00      	cmp	r3, #0
 8002d76:	f040 80e3 	bne.w	8002f40 <USBH_Process+0x228>
    {
      phost->gState = HOST_IDLE;
 8002d7a:	683b      	ldr	r3, [r7, #0]
 8002d7c:	f04f 0200 	mov.w	r2, #0
 8002d80:	701a      	strb	r2, [r3, #0]
    }
    break;
 8002d82:	e0dd      	b.n	8002f40 <USBH_Process+0x228>
    
  case HOST_IDLE :
    
    if (HCD_IsDeviceConnected(pdev))  
 8002d84:	6878      	ldr	r0, [r7, #4]
 8002d86:	f7fe fc4d 	bl	8001624 <HCD_IsDeviceConnected>
 8002d8a:	4603      	mov	r3, r0
 8002d8c:	2b00      	cmp	r3, #0
 8002d8e:	f000 80d9 	beq.w	8002f44 <USBH_Process+0x22c>
    {
      /* Wait for USB Connect Interrupt void USBH_ISR_Connected(void) */     
      USBH_DeAllocate_AllChannel(pdev);
 8002d92:	6878      	ldr	r0, [r7, #4]
 8002d94:	f000 fdc0 	bl	8003918 <USBH_DeAllocate_AllChannel>
      phost->gState = HOST_DEV_ATTACHED;
 8002d98:	683b      	ldr	r3, [r7, #0]
 8002d9a:	f04f 0202 	mov.w	r2, #2
 8002d9e:	701a      	strb	r2, [r3, #0]
    }
    break;
 8002da0:	e0d0      	b.n	8002f44 <USBH_Process+0x22c>
   
  case HOST_DEV_ATTACHED :
    
    phost->usr_cb->DeviceAttached();
 8002da2:	683b      	ldr	r3, [r7, #0]
 8002da4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002da8:	689b      	ldr	r3, [r3, #8]
 8002daa:	4798      	blx	r3
    pdev->host.port_cb->DisconnStatus = 0; 
 8002dac:	687b      	ldr	r3, [r7, #4]
 8002dae:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002db2:	f04f 0200 	mov.w	r2, #0
 8002db6:	725a      	strb	r2, [r3, #9]
    pdev->host.port_cb->ConnHandled = 1;  
 8002db8:	687b      	ldr	r3, [r7, #4]
 8002dba:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002dbe:	f04f 0201 	mov.w	r2, #1
 8002dc2:	729a      	strb	r2, [r3, #10]

    phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
 8002dc4:	6878      	ldr	r0, [r7, #4]
 8002dc6:	f04f 0100 	mov.w	r1, #0
 8002dca:	f000 fd59 	bl	8003880 <USBH_Alloc_Channel>
 8002dce:	4603      	mov	r3, r0
 8002dd0:	461a      	mov	r2, r3
 8002dd2:	683b      	ldr	r3, [r7, #0]
 8002dd4:	715a      	strb	r2, [r3, #5]
    phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
 8002dd6:	6878      	ldr	r0, [r7, #4]
 8002dd8:	f04f 0180 	mov.w	r1, #128	; 0x80
 8002ddc:	f000 fd50 	bl	8003880 <USBH_Alloc_Channel>
 8002de0:	4603      	mov	r3, r0
 8002de2:	461a      	mov	r2, r3
 8002de4:	683b      	ldr	r3, [r7, #0]
 8002de6:	711a      	strb	r2, [r3, #4]
  
    /* Reset USB Device */
    if ( HCD_ResetPort(pdev) == 0)
 8002de8:	6878      	ldr	r0, [r7, #4]
 8002dea:	f7fe fc0d 	bl	8001608 <HCD_ResetPort>
 8002dee:	4603      	mov	r3, r0
 8002df0:	2b00      	cmp	r3, #0
 8002df2:	f040 80a9 	bne.w	8002f48 <USBH_Process+0x230>
    {
      phost->usr_cb->ResetDevice();
 8002df6:	683b      	ldr	r3, [r7, #0]
 8002df8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002dfc:	68db      	ldr	r3, [r3, #12]
 8002dfe:	4798      	blx	r3
      /*  Wait for USB USBH_ISR_PrtEnDisableChange()  
      Host is Now ready to start the Enumeration 
      */
      
      phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
 8002e00:	6878      	ldr	r0, [r7, #4]
 8002e02:	f7fe fbed 	bl	80015e0 <HCD_GetCurrentSpeed>
 8002e06:	4603      	mov	r3, r0
 8002e08:	b2da      	uxtb	r2, r3
 8002e0a:	683b      	ldr	r3, [r7, #0]
 8002e0c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
      
      phost->gState = HOST_ENUMERATION;
 8002e10:	683b      	ldr	r3, [r7, #0]
 8002e12:	f04f 0206 	mov.w	r2, #6
 8002e16:	701a      	strb	r2, [r3, #0]
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
 8002e18:	683b      	ldr	r3, [r7, #0]
 8002e1a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002e1e:	699b      	ldr	r3, [r3, #24]
 8002e20:	683a      	ldr	r2, [r7, #0]
 8002e22:	f892 2021 	ldrb.w	r2, [r2, #33]	; 0x21
 8002e26:	4610      	mov	r0, r2
 8002e28:	4798      	blx	r3
        
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
                           phost->Control.hc_num_in,
 8002e2a:	683b      	ldr	r3, [r7, #0]
      
      phost->gState = HOST_ENUMERATION;
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
        
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
 8002e2c:	7919      	ldrb	r1, [r3, #4]
                           phost->Control.hc_num_in,
                           phost->device_prop.address,
 8002e2e:	683b      	ldr	r3, [r7, #0]
      
      phost->gState = HOST_ENUMERATION;
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
        
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
 8002e30:	f893 2020 	ldrb.w	r2, [r3, #32]
                           phost->Control.hc_num_in,
                           phost->device_prop.address,
                           phost->device_prop.speed,
 8002e34:	683b      	ldr	r3, [r7, #0]
      
      phost->gState = HOST_ENUMERATION;
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
        
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
 8002e36:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
                           phost->Control.hc_num_in,
                           phost->device_prop.address,
                           phost->device_prop.speed,
                           EP_TYPE_CTRL,
                           phost->Control.ep0size); 
 8002e3a:	6838      	ldr	r0, [r7, #0]
 8002e3c:	7980      	ldrb	r0, [r0, #6]
      
      phost->gState = HOST_ENUMERATION;
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
        
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
 8002e3e:	f04f 0400 	mov.w	r4, #0
 8002e42:	9400      	str	r4, [sp, #0]
 8002e44:	9001      	str	r0, [sp, #4]
 8002e46:	6878      	ldr	r0, [r7, #4]
 8002e48:	f000 fc48 	bl	80036dc <USBH_Open_Channel>
                           EP_TYPE_CTRL,
                           phost->Control.ep0size); 
      
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
                           phost->Control.hc_num_out,
 8002e4c:	683b      	ldr	r3, [r7, #0]
                           phost->device_prop.speed,
                           EP_TYPE_CTRL,
                           phost->Control.ep0size); 
      
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
 8002e4e:	7959      	ldrb	r1, [r3, #5]
                           phost->Control.hc_num_out,
                           phost->device_prop.address,
 8002e50:	683b      	ldr	r3, [r7, #0]
                           phost->device_prop.speed,
                           EP_TYPE_CTRL,
                           phost->Control.ep0size); 
      
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
 8002e52:	f893 2020 	ldrb.w	r2, [r3, #32]
                           phost->Control.hc_num_out,
                           phost->device_prop.address,
                           phost->device_prop.speed,
 8002e56:	683b      	ldr	r3, [r7, #0]
                           phost->device_prop.speed,
                           EP_TYPE_CTRL,
                           phost->Control.ep0size); 
      
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
 8002e58:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
                           phost->Control.hc_num_out,
                           phost->device_prop.address,
                           phost->device_prop.speed,
                           EP_TYPE_CTRL,
                           phost->Control.ep0size);          
 8002e5c:	6838      	ldr	r0, [r7, #0]
 8002e5e:	7980      	ldrb	r0, [r0, #6]
                           phost->device_prop.speed,
                           EP_TYPE_CTRL,
                           phost->Control.ep0size); 
      
      /* Open Control pipes */
      USBH_Open_Channel (pdev,
 8002e60:	f04f 0400 	mov.w	r4, #0
 8002e64:	9400      	str	r4, [sp, #0]
 8002e66:	9001      	str	r0, [sp, #4]
 8002e68:	6878      	ldr	r0, [r7, #4]
 8002e6a:	f000 fc37 	bl	80036dc <USBH_Open_Channel>
                           phost->device_prop.address,
                           phost->device_prop.speed,
                           EP_TYPE_CTRL,
                           phost->Control.ep0size);          
   }
    break;
 8002e6e:	e06b      	b.n	8002f48 <USBH_Process+0x230>
    
  case HOST_ENUMERATION:     
    /* Check for enumeration status */  
    if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
 8002e70:	6878      	ldr	r0, [r7, #4]
 8002e72:	6839      	ldr	r1, [r7, #0]
 8002e74:	f000 f8c0 	bl	8002ff8 <USBH_HandleEnum>
 8002e78:	4603      	mov	r3, r0
 8002e7a:	2b00      	cmp	r3, #0
 8002e7c:	d166      	bne.n	8002f4c <USBH_Process+0x234>
    { 
      /* The function shall return USBH_OK when full enumeration is complete */
      
      /* user callback for end of device basic enumeration */
      phost->usr_cb->EnumerationDone();
 8002e7e:	683b      	ldr	r3, [r7, #0]
 8002e80:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002e84:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002e86:	4798      	blx	r3
      
      phost->gState  = HOST_USR_INPUT;    
 8002e88:	683b      	ldr	r3, [r7, #0]
 8002e8a:	f04f 020a 	mov.w	r2, #10
 8002e8e:	701a      	strb	r2, [r3, #0]
    }
    break;
 8002e90:	e05c      	b.n	8002f4c <USBH_Process+0x234>
    
  case HOST_USR_INPUT:    
    /*The function should return user response true to move to class state */
    if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
 8002e92:	683b      	ldr	r3, [r7, #0]
 8002e94:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002e98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002e9a:	4798      	blx	r3
 8002e9c:	4603      	mov	r3, r0
 8002e9e:	2b01      	cmp	r3, #1
 8002ea0:	d156      	bne.n	8002f50 <USBH_Process+0x238>
    {
      if((phost->class_cb->Init(pdev, phost))\
 8002ea2:	683b      	ldr	r3, [r7, #0]
 8002ea4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8002ea6:	681b      	ldr	r3, [r3, #0]
 8002ea8:	6878      	ldr	r0, [r7, #4]
 8002eaa:	6839      	ldr	r1, [r7, #0]
 8002eac:	4798      	blx	r3
 8002eae:	4603      	mov	r3, r0
 8002eb0:	2b00      	cmp	r3, #0
 8002eb2:	d14d      	bne.n	8002f50 <USBH_Process+0x238>
        == USBH_OK)
      {
        phost->gState  = HOST_CLASS_REQUEST;     
 8002eb4:	683b      	ldr	r3, [r7, #0]
 8002eb6:	f04f 0207 	mov.w	r2, #7
 8002eba:	701a      	strb	r2, [r3, #0]
      }     
    }   
    break;
 8002ebc:	e048      	b.n	8002f50 <USBH_Process+0x238>
    
  case HOST_CLASS_REQUEST:  
    /* process class standard contol requests state machine */ 
    status = phost->class_cb->Requests(pdev, phost);
 8002ebe:	683b      	ldr	r3, [r7, #0]
 8002ec0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8002ec2:	689b      	ldr	r3, [r3, #8]
 8002ec4:	6878      	ldr	r0, [r7, #4]
 8002ec6:	6839      	ldr	r1, [r7, #0]
 8002ec8:	4798      	blx	r3
 8002eca:	4603      	mov	r3, r0
 8002ecc:	73fb      	strb	r3, [r7, #15]
    
     if(status == USBH_OK)
 8002ece:	7bfb      	ldrb	r3, [r7, #15]
 8002ed0:	b2db      	uxtb	r3, r3
 8002ed2:	2b00      	cmp	r3, #0
 8002ed4:	d104      	bne.n	8002ee0 <USBH_Process+0x1c8>
     {
       phost->gState  = HOST_CLASS;
 8002ed6:	683b      	ldr	r3, [r7, #0]
 8002ed8:	f04f 0208 	mov.w	r2, #8
 8002edc:	701a      	strb	r2, [r3, #0]
     {
       USBH_ErrorHandle(phost, status);
     }
 
    
    break;    
 8002ede:	e038      	b.n	8002f52 <USBH_Process+0x23a>
       phost->gState  = HOST_CLASS;
     }  
     
     else
     {
       USBH_ErrorHandle(phost, status);
 8002ee0:	7bfb      	ldrb	r3, [r7, #15]
 8002ee2:	b2db      	uxtb	r3, r3
 8002ee4:	6838      	ldr	r0, [r7, #0]
 8002ee6:	4619      	mov	r1, r3
 8002ee8:	f000 f860 	bl	8002fac <USBH_ErrorHandle>
     }
 
    
    break;    
 8002eec:	e031      	b.n	8002f52 <USBH_Process+0x23a>
  case HOST_CLASS:   
    /* process class state machine */
    status = phost->class_cb->Machine(pdev, phost);
 8002eee:	683b      	ldr	r3, [r7, #0]
 8002ef0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8002ef2:	68db      	ldr	r3, [r3, #12]
 8002ef4:	6878      	ldr	r0, [r7, #4]
 8002ef6:	6839      	ldr	r1, [r7, #0]
 8002ef8:	4798      	blx	r3
 8002efa:	4603      	mov	r3, r0
 8002efc:	73fb      	strb	r3, [r7, #15]
    USBH_ErrorHandle(phost, status);
 8002efe:	7bfb      	ldrb	r3, [r7, #15]
 8002f00:	b2db      	uxtb	r3, r3
 8002f02:	6838      	ldr	r0, [r7, #0]
 8002f04:	4619      	mov	r1, r3
 8002f06:	f000 f851 	bl	8002fac <USBH_ErrorHandle>
    break;       
 8002f0a:	e022      	b.n	8002f52 <USBH_Process+0x23a>
    
  case HOST_CTRL_XFER:
    /* process control transfer state machine */
    USBH_HandleControl(pdev, phost);    
 8002f0c:	6878      	ldr	r0, [r7, #4]
 8002f0e:	6839      	ldr	r1, [r7, #0]
 8002f10:	f000 fa0e 	bl	8003330 <USBH_HandleControl>
    break;
 8002f14:	e01d      	b.n	8002f52 <USBH_Process+0x23a>
  case HOST_SUSPENDED:
    break;
  
  case HOST_ERROR_STATE:
    /* Re-Initilaize Host for new Enumeration */
    USBH_DeInit(pdev, phost);
 8002f16:	6878      	ldr	r0, [r7, #4]
 8002f18:	6839      	ldr	r1, [r7, #0]
 8002f1a:	f7ff fec3 	bl	8002ca4 <USBH_DeInit>
    phost->usr_cb->DeInit();
 8002f1e:	683b      	ldr	r3, [r7, #0]
 8002f20:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002f24:	685b      	ldr	r3, [r3, #4]
 8002f26:	4798      	blx	r3
    phost->class_cb->DeInit(pdev, &phost->device_prop);
 8002f28:	683b      	ldr	r3, [r7, #0]
 8002f2a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8002f2c:	685b      	ldr	r3, [r3, #4]
 8002f2e:	683a      	ldr	r2, [r7, #0]
 8002f30:	f102 0220 	add.w	r2, r2, #32
 8002f34:	6878      	ldr	r0, [r7, #4]
 8002f36:	4611      	mov	r1, r2
 8002f38:	4798      	blx	r3
    break;
 8002f3a:	e00a      	b.n	8002f52 <USBH_Process+0x23a>
    
  default :
    break;
 8002f3c:	bf00      	nop
 8002f3e:	e008      	b.n	8002f52 <USBH_Process+0x23a>
     
    if ( HCD_ResetPort(pdev) == 0)
    {
      phost->gState = HOST_IDLE;
    }
    break;
 8002f40:	bf00      	nop
 8002f42:	e006      	b.n	8002f52 <USBH_Process+0x23a>
    {
      /* Wait for USB Connect Interrupt void USBH_ISR_Connected(void) */     
      USBH_DeAllocate_AllChannel(pdev);
      phost->gState = HOST_DEV_ATTACHED;
    }
    break;
 8002f44:	bf00      	nop
 8002f46:	e004      	b.n	8002f52 <USBH_Process+0x23a>
                           phost->device_prop.address,
                           phost->device_prop.speed,
                           EP_TYPE_CTRL,
                           phost->Control.ep0size);          
   }
    break;
 8002f48:	bf00      	nop
 8002f4a:	e002      	b.n	8002f52 <USBH_Process+0x23a>
      /* user callback for end of device basic enumeration */
      phost->usr_cb->EnumerationDone();
      
      phost->gState  = HOST_USR_INPUT;    
    }
    break;
 8002f4c:	bf00      	nop
 8002f4e:	e000      	b.n	8002f52 <USBH_Process+0x23a>
        == USBH_OK)
      {
        phost->gState  = HOST_CLASS_REQUEST;     
      }     
    }   
    break;
 8002f50:	bf00      	nop
  default :
    break;
  }
  
  /* check device disconnection event */
   if (!(HCD_IsDeviceConnected(pdev)) && 
 8002f52:	6878      	ldr	r0, [r7, #4]
 8002f54:	f7fe fb66 	bl	8001624 <HCD_IsDeviceConnected>
 8002f58:	4603      	mov	r3, r0
 8002f5a:	2b00      	cmp	r3, #0
 8002f5c:	d122      	bne.n	8002fa4 <USBH_Process+0x28c>
       (pdev->host.port_cb->DisconnHandled == 0))
 8002f5e:	687b      	ldr	r3, [r7, #4]
 8002f60:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002f64:	7adb      	ldrb	r3, [r3, #11]
  default :
    break;
  }
  
  /* check device disconnection event */
   if (!(HCD_IsDeviceConnected(pdev)) && 
 8002f66:	2b00      	cmp	r3, #0
 8002f68:	d11c      	bne.n	8002fa4 <USBH_Process+0x28c>
       (pdev->host.port_cb->DisconnHandled == 0))
  { 
    /* Manage User disconnect operations*/
    phost->usr_cb->DeviceDisconnected();
 8002f6a:	683b      	ldr	r3, [r7, #0]
 8002f6c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002f70:	691b      	ldr	r3, [r3, #16]
 8002f72:	4798      	blx	r3
    
    pdev->host.port_cb->DisconnHandled = 1; /* Handle to avoid the Re-entry*/
 8002f74:	687b      	ldr	r3, [r7, #4]
 8002f76:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002f7a:	f04f 0201 	mov.w	r2, #1
 8002f7e:	72da      	strb	r2, [r3, #11]
    
    /* Re-Initilaize Host for new Enumeration */
    USBH_DeInit(pdev, phost);
 8002f80:	6878      	ldr	r0, [r7, #4]
 8002f82:	6839      	ldr	r1, [r7, #0]
 8002f84:	f7ff fe8e 	bl	8002ca4 <USBH_DeInit>
    phost->usr_cb->DeInit();
 8002f88:	683b      	ldr	r3, [r7, #0]
 8002f8a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002f8e:	685b      	ldr	r3, [r3, #4]
 8002f90:	4798      	blx	r3
    phost->class_cb->DeInit(pdev, &phost->device_prop);
 8002f92:	683b      	ldr	r3, [r7, #0]
 8002f94:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8002f96:	685b      	ldr	r3, [r3, #4]
 8002f98:	683a      	ldr	r2, [r7, #0]
 8002f9a:	f102 0220 	add.w	r2, r2, #32
 8002f9e:	6878      	ldr	r0, [r7, #4]
 8002fa0:	4611      	mov	r1, r2
 8002fa2:	4798      	blx	r3
  }   
}
 8002fa4:	f107 0714 	add.w	r7, r7, #20
 8002fa8:	46bd      	mov	sp, r7
 8002faa:	bd90      	pop	{r4, r7, pc}

08002fac <USBH_ErrorHandle>:
  *         This function handles the Error on Host side.
  * @param  errType : Type of Error or Busy/OK state
  * @retval None
  */
void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
{
 8002fac:	b580      	push	{r7, lr}
 8002fae:	b082      	sub	sp, #8
 8002fb0:	af00      	add	r7, sp, #0
 8002fb2:	6078      	str	r0, [r7, #4]
 8002fb4:	460b      	mov	r3, r1
 8002fb6:	70fb      	strb	r3, [r7, #3]
  /* Error unrecovered or not supported device speed */
  if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
 8002fb8:	78fb      	ldrb	r3, [r7, #3]
 8002fba:	2b05      	cmp	r3, #5
 8002fbc:	d002      	beq.n	8002fc4 <USBH_ErrorHandle+0x18>
 8002fbe:	78fb      	ldrb	r3, [r7, #3]
 8002fc0:	2b04      	cmp	r3, #4
 8002fc2:	d109      	bne.n	8002fd8 <USBH_ErrorHandle+0x2c>
       (errType == USBH_UNRECOVERED_ERROR) )
  {
    phost->usr_cb->UnrecoveredError(); 
 8002fc4:	687b      	ldr	r3, [r7, #4]
 8002fc6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002fca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002fcc:	4798      	blx	r3
    phost->gState = HOST_ERROR_STATE;   
 8002fce:	687b      	ldr	r3, [r7, #4]
 8002fd0:	f04f 020c 	mov.w	r2, #12
 8002fd4:	701a      	strb	r2, [r3, #0]
 8002fd6:	e00b      	b.n	8002ff0 <USBH_ErrorHandle+0x44>
  }  
  /* USB host restart requested from application layer */
  else if(errType == USBH_APPLY_DEINIT)
 8002fd8:	78fb      	ldrb	r3, [r7, #3]
 8002fda:	2b06      	cmp	r3, #6
 8002fdc:	d108      	bne.n	8002ff0 <USBH_ErrorHandle+0x44>
  {
    phost->gState = HOST_ERROR_STATE;  
 8002fde:	687b      	ldr	r3, [r7, #4]
 8002fe0:	f04f 020c 	mov.w	r2, #12
 8002fe4:	701a      	strb	r2, [r3, #0]
    /* user callback for initalization */
    phost->usr_cb->Init();
 8002fe6:	687b      	ldr	r3, [r7, #4]
 8002fe8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8002fec:	681b      	ldr	r3, [r3, #0]
 8002fee:	4798      	blx	r3
  } 
}
 8002ff0:	f107 0708 	add.w	r7, r7, #8
 8002ff4:	46bd      	mov	sp, r7
 8002ff6:	bd80      	pop	{r7, pc}

08002ff8 <USBH_HandleEnum>:
  *         This function includes the complete enumeration process
  * @param  pdev: Selected device
  * @retval USBH_Status
  */
static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
{
 8002ff8:	b580      	push	{r7, lr}
 8002ffa:	b096      	sub	sp, #88	; 0x58
 8002ffc:	af02      	add	r7, sp, #8
 8002ffe:	6078      	str	r0, [r7, #4]
 8003000:	6039      	str	r1, [r7, #0]
  USBH_Status Status = USBH_BUSY;  
 8003002:	f04f 0301 	mov.w	r3, #1
 8003006:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
  uint8_t Local_Buffer[64];
  
  switch (phost->EnumState)
 800300a:	683b      	ldr	r3, [r7, #0]
 800300c:	789b      	ldrb	r3, [r3, #2]
 800300e:	2b09      	cmp	r3, #9
 8003010:	f200 8174 	bhi.w	80032fc <USBH_HandleEnum+0x304>
 8003014:	a201      	add	r2, pc, #4	; (adr r2, 800301c <USBH_HandleEnum+0x24>)
 8003016:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800301a:	bf00      	nop
 800301c:	08003045 	.word	0x08003045
 8003020:	080030b3 	.word	0x080030b3
 8003024:	080030e3 	.word	0x080030e3
 8003028:	0800315d 	.word	0x0800315d
 800302c:	0800317b 	.word	0x0800317b
 8003030:	080031b7 	.word	0x080031b7
 8003034:	08003217 	.word	0x08003217
 8003038:	08003275 	.word	0x08003275
 800303c:	080032d3 	.word	0x080032d3
 8003040:	080032f3 	.word	0x080032f3
  {
  case ENUM_IDLE:  
    /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
    if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
 8003044:	6878      	ldr	r0, [r7, #4]
 8003046:	6839      	ldr	r1, [r7, #0]
 8003048:	f04f 0208 	mov.w	r2, #8
 800304c:	f000 ff7c 	bl	8003f48 <USBH_Get_DevDesc>
 8003050:	4603      	mov	r3, r0
 8003052:	2b00      	cmp	r3, #0
 8003054:	f040 8154 	bne.w	8003300 <USBH_HandleEnum+0x308>
    {
      phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
 8003058:	683b      	ldr	r3, [r7, #0]
 800305a:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 800305e:	683b      	ldr	r3, [r7, #0]
 8003060:	719a      	strb	r2, [r3, #6]
      
      /* Issue Reset  */
      HCD_ResetPort(pdev);
 8003062:	6878      	ldr	r0, [r7, #4]
 8003064:	f7fe fad0 	bl	8001608 <HCD_ResetPort>
      phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 8003068:	683b      	ldr	r3, [r7, #0]
 800306a:	f04f 0201 	mov.w	r2, #1
 800306e:	709a      	strb	r2, [r3, #2]
      
      /* modify control channels configuration for MaxPacket size */
      USBH_Modify_Channel (pdev,
                           phost->Control.hc_num_out,
 8003070:	683b      	ldr	r3, [r7, #0]
      /* Issue Reset  */
      HCD_ResetPort(pdev);
      phost->EnumState = ENUM_GET_FULL_DEV_DESC;
      
      /* modify control channels configuration for MaxPacket size */
      USBH_Modify_Channel (pdev,
 8003072:	795b      	ldrb	r3, [r3, #5]
                           phost->Control.hc_num_out,
                           0,
                           0,
                           0,
                           phost->Control.ep0size);
 8003074:	683a      	ldr	r2, [r7, #0]
 8003076:	7992      	ldrb	r2, [r2, #6]
      /* Issue Reset  */
      HCD_ResetPort(pdev);
      phost->EnumState = ENUM_GET_FULL_DEV_DESC;
      
      /* modify control channels configuration for MaxPacket size */
      USBH_Modify_Channel (pdev,
 8003078:	f04f 0100 	mov.w	r1, #0
 800307c:	9100      	str	r1, [sp, #0]
 800307e:	9201      	str	r2, [sp, #4]
 8003080:	6878      	ldr	r0, [r7, #4]
 8003082:	4619      	mov	r1, r3
 8003084:	f04f 0200 	mov.w	r2, #0
 8003088:	f04f 0300 	mov.w	r3, #0
 800308c:	f000 fbaa 	bl	80037e4 <USBH_Modify_Channel>
                           0,
                           0,
                           phost->Control.ep0size);
      
      USBH_Modify_Channel (pdev,
                           phost->Control.hc_num_in,
 8003090:	683b      	ldr	r3, [r7, #0]
                           0,
                           0,
                           0,
                           phost->Control.ep0size);
      
      USBH_Modify_Channel (pdev,
 8003092:	791b      	ldrb	r3, [r3, #4]
                           phost->Control.hc_num_in,
                           0,
                           0,
                           0,
                           phost->Control.ep0size);      
 8003094:	683a      	ldr	r2, [r7, #0]
 8003096:	7992      	ldrb	r2, [r2, #6]
                           0,
                           0,
                           0,
                           phost->Control.ep0size);
      
      USBH_Modify_Channel (pdev,
 8003098:	f04f 0100 	mov.w	r1, #0
 800309c:	9100      	str	r1, [sp, #0]
 800309e:	9201      	str	r2, [sp, #4]
 80030a0:	6878      	ldr	r0, [r7, #4]
 80030a2:	4619      	mov	r1, r3
 80030a4:	f04f 0200 	mov.w	r2, #0
 80030a8:	f04f 0300 	mov.w	r3, #0
 80030ac:	f000 fb9a 	bl	80037e4 <USBH_Modify_Channel>
                           0,
                           0,
                           0,
                           phost->Control.ep0size);      
    }
    break;
 80030b0:	e126      	b.n	8003300 <USBH_HandleEnum+0x308>
    
  case ENUM_GET_FULL_DEV_DESC:  
    /* Get FULL Device Desc  */
    if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
 80030b2:	6878      	ldr	r0, [r7, #4]
 80030b4:	6839      	ldr	r1, [r7, #0]
 80030b6:	f04f 0212 	mov.w	r2, #18
 80030ba:	f000 ff45 	bl	8003f48 <USBH_Get_DevDesc>
 80030be:	4603      	mov	r3, r0
 80030c0:	2b00      	cmp	r3, #0
 80030c2:	f040 811f 	bne.w	8003304 <USBH_HandleEnum+0x30c>
      == USBH_OK)
    {
      /* user callback for device descriptor available */
      phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
 80030c6:	683b      	ldr	r3, [r7, #0]
 80030c8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80030cc:	69db      	ldr	r3, [r3, #28]
 80030ce:	683a      	ldr	r2, [r7, #0]
 80030d0:	f102 0222 	add.w	r2, r2, #34	; 0x22
 80030d4:	4610      	mov	r0, r2
 80030d6:	4798      	blx	r3
      phost->EnumState = ENUM_SET_ADDR;
 80030d8:	683b      	ldr	r3, [r7, #0]
 80030da:	f04f 0202 	mov.w	r2, #2
 80030de:	709a      	strb	r2, [r3, #2]
    }
    break;
 80030e0:	e110      	b.n	8003304 <USBH_HandleEnum+0x30c>
   
  case ENUM_SET_ADDR: 
    /* set address */
    if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
 80030e2:	6878      	ldr	r0, [r7, #4]
 80030e4:	6839      	ldr	r1, [r7, #0]
 80030e6:	f04f 0201 	mov.w	r2, #1
 80030ea:	f000 ffeb 	bl	80040c4 <USBH_SetAddress>
 80030ee:	4603      	mov	r3, r0
 80030f0:	2b00      	cmp	r3, #0
 80030f2:	f040 8109 	bne.w	8003308 <USBH_HandleEnum+0x310>
    {
      phost->device_prop.address = USBH_DEVICE_ADDRESS;
 80030f6:	683b      	ldr	r3, [r7, #0]
 80030f8:	f04f 0201 	mov.w	r2, #1
 80030fc:	f883 2020 	strb.w	r2, [r3, #32]
      
      /* user callback for device address assigned */
      phost->usr_cb->DeviceAddressAssigned();
 8003100:	683b      	ldr	r3, [r7, #0]
 8003102:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003106:	6a1b      	ldr	r3, [r3, #32]
 8003108:	4798      	blx	r3
      phost->EnumState = ENUM_GET_CFG_DESC;
 800310a:	683b      	ldr	r3, [r7, #0]
 800310c:	f04f 0203 	mov.w	r2, #3
 8003110:	709a      	strb	r2, [r3, #2]
      
      /* modify control channels to update device address */
      USBH_Modify_Channel (pdev,
                           phost->Control.hc_num_in,
 8003112:	683b      	ldr	r3, [r7, #0]
      /* user callback for device address assigned */
      phost->usr_cb->DeviceAddressAssigned();
      phost->EnumState = ENUM_GET_CFG_DESC;
      
      /* modify control channels to update device address */
      USBH_Modify_Channel (pdev,
 8003114:	791a      	ldrb	r2, [r3, #4]
                           phost->Control.hc_num_in,
                           phost->device_prop.address,
 8003116:	683b      	ldr	r3, [r7, #0]
      /* user callback for device address assigned */
      phost->usr_cb->DeviceAddressAssigned();
      phost->EnumState = ENUM_GET_CFG_DESC;
      
      /* modify control channels to update device address */
      USBH_Modify_Channel (pdev,
 8003118:	f893 3020 	ldrb.w	r3, [r3, #32]
 800311c:	f04f 0100 	mov.w	r1, #0
 8003120:	9100      	str	r1, [sp, #0]
 8003122:	f04f 0100 	mov.w	r1, #0
 8003126:	9101      	str	r1, [sp, #4]
 8003128:	6878      	ldr	r0, [r7, #4]
 800312a:	4611      	mov	r1, r2
 800312c:	461a      	mov	r2, r3
 800312e:	f04f 0300 	mov.w	r3, #0
 8003132:	f000 fb57 	bl	80037e4 <USBH_Modify_Channel>
                           0,
                           0,
                           0);
      
      USBH_Modify_Channel (pdev,
                           phost->Control.hc_num_out,
 8003136:	683b      	ldr	r3, [r7, #0]
                           phost->device_prop.address,
                           0,
                           0,
                           0);
      
      USBH_Modify_Channel (pdev,
 8003138:	795a      	ldrb	r2, [r3, #5]
                           phost->Control.hc_num_out,
                           phost->device_prop.address,
 800313a:	683b      	ldr	r3, [r7, #0]
                           phost->device_prop.address,
                           0,
                           0,
                           0);
      
      USBH_Modify_Channel (pdev,
 800313c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8003140:	f04f 0100 	mov.w	r1, #0
 8003144:	9100      	str	r1, [sp, #0]
 8003146:	f04f 0100 	mov.w	r1, #0
 800314a:	9101      	str	r1, [sp, #4]
 800314c:	6878      	ldr	r0, [r7, #4]
 800314e:	4611      	mov	r1, r2
 8003150:	461a      	mov	r2, r3
 8003152:	f04f 0300 	mov.w	r3, #0
 8003156:	f000 fb45 	bl	80037e4 <USBH_Modify_Channel>
                           phost->device_prop.address,
                           0,
                           0,
                           0);         
    }
    break;
 800315a:	e0d5      	b.n	8003308 <USBH_HandleEnum+0x310>
    
  case ENUM_GET_CFG_DESC:  
    /* get standard configuration descriptor */
    if ( USBH_Get_CfgDesc(pdev, 
 800315c:	6878      	ldr	r0, [r7, #4]
 800315e:	6839      	ldr	r1, [r7, #0]
 8003160:	f04f 0209 	mov.w	r2, #9
 8003164:	f000 ff1e 	bl	8003fa4 <USBH_Get_CfgDesc>
 8003168:	4603      	mov	r3, r0
 800316a:	2b00      	cmp	r3, #0
 800316c:	f040 80ce 	bne.w	800330c <USBH_HandleEnum+0x314>
                          phost,
                          USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
    {
      phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 8003170:	683b      	ldr	r3, [r7, #0]
 8003172:	f04f 0204 	mov.w	r2, #4
 8003176:	709a      	strb	r2, [r3, #2]
    }
    break;
 8003178:	e0c8      	b.n	800330c <USBH_HandleEnum+0x314>
    
  case ENUM_GET_FULL_CFG_DESC:  
    /* get FULL config descriptor (config, interface, endpoints) */
    if (USBH_Get_CfgDesc(pdev, 
                         phost,
                         phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
 800317a:	683b      	ldr	r3, [r7, #0]
    }
    break;
    
  case ENUM_GET_FULL_CFG_DESC:  
    /* get FULL config descriptor (config, interface, endpoints) */
    if (USBH_Get_CfgDesc(pdev, 
 800317c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800317e:	6878      	ldr	r0, [r7, #4]
 8003180:	6839      	ldr	r1, [r7, #0]
 8003182:	461a      	mov	r2, r3
 8003184:	f000 ff0e 	bl	8003fa4 <USBH_Get_CfgDesc>
 8003188:	4603      	mov	r3, r0
 800318a:	2b00      	cmp	r3, #0
 800318c:	f040 80c0 	bne.w	8003310 <USBH_HandleEnum+0x318>
                         phost,
                         phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
    {
      /* User callback for configuration descriptors available */
      phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
 8003190:	683b      	ldr	r3, [r7, #0]
 8003192:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003196:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003198:	683a      	ldr	r2, [r7, #0]
 800319a:	f102 0034 	add.w	r0, r2, #52	; 0x34
                                                      phost->device_prop.Itf_Desc,
 800319e:	683a      	ldr	r2, [r7, #0]
 80031a0:	f102 013e 	add.w	r1, r2, #62	; 0x3e
                                                      phost->device_prop.Ep_Desc[0]);
 80031a4:	683a      	ldr	r2, [r7, #0]
 80031a6:	f102 0250 	add.w	r2, r2, #80	; 0x50
    if (USBH_Get_CfgDesc(pdev, 
                         phost,
                         phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
    {
      /* User callback for configuration descriptors available */
      phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
 80031aa:	4798      	blx	r3
                                                      phost->device_prop.Itf_Desc,
                                                      phost->device_prop.Ep_Desc[0]);
      
      phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 80031ac:	683b      	ldr	r3, [r7, #0]
 80031ae:	f04f 0205 	mov.w	r2, #5
 80031b2:	709a      	strb	r2, [r3, #2]
    }
    break;
 80031b4:	e0ac      	b.n	8003310 <USBH_HandleEnum+0x318>
    
  case ENUM_GET_MFC_STRING_DESC:  
    if (phost->device_prop.Dev_Desc.iManufacturer != 0)
 80031b6:	683b      	ldr	r3, [r7, #0]
 80031b8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80031bc:	2b00      	cmp	r3, #0
 80031be:	d01c      	beq.n	80031fa <USBH_HandleEnum+0x202>
    { /* Check that Manufacturer String is available */
      
      if ( USBH_Get_StringDesc(pdev,
                               phost,
                               phost->device_prop.Dev_Desc.iManufacturer, 
 80031c0:	683b      	ldr	r3, [r7, #0]
    
  case ENUM_GET_MFC_STRING_DESC:  
    if (phost->device_prop.Dev_Desc.iManufacturer != 0)
    { /* Check that Manufacturer String is available */
      
      if ( USBH_Get_StringDesc(pdev,
 80031c2:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 80031c6:	f107 030c 	add.w	r3, r7, #12
 80031ca:	f04f 01ff 	mov.w	r1, #255	; 0xff
 80031ce:	9100      	str	r1, [sp, #0]
 80031d0:	6878      	ldr	r0, [r7, #4]
 80031d2:	6839      	ldr	r1, [r7, #0]
 80031d4:	f000 ff16 	bl	8004004 <USBH_Get_StringDesc>
 80031d8:	4603      	mov	r3, r0
 80031da:	2b00      	cmp	r3, #0
 80031dc:	f040 809a 	bne.w	8003314 <USBH_HandleEnum+0x31c>
                               phost->device_prop.Dev_Desc.iManufacturer, 
                               Local_Buffer , 
                               0xff) == USBH_OK)
      {
        /* User callback for Manufacturing string */
        phost->usr_cb->ManufacturerString(Local_Buffer);
 80031e0:	683b      	ldr	r3, [r7, #0]
 80031e2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80031e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80031e8:	f107 020c 	add.w	r2, r7, #12
 80031ec:	4610      	mov	r0, r2
 80031ee:	4798      	blx	r3
        phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 80031f0:	683b      	ldr	r3, [r7, #0]
 80031f2:	f04f 0206 	mov.w	r2, #6
 80031f6:	709a      	strb	r2, [r3, #2]
    else
    {
      phost->usr_cb->ManufacturerString("N/A");      
      phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
    }
    break;
 80031f8:	e08c      	b.n	8003314 <USBH_HandleEnum+0x31c>
        phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
      }
    }
    else
    {
      phost->usr_cb->ManufacturerString("N/A");      
 80031fa:	683b      	ldr	r3, [r7, #0]
 80031fc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003200:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003202:	f64b 206c 	movw	r0, #47724	; 0xba6c
 8003206:	f6c0 0002 	movt	r0, #2050	; 0x802
 800320a:	4798      	blx	r3
      phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 800320c:	683b      	ldr	r3, [r7, #0]
 800320e:	f04f 0206 	mov.w	r2, #6
 8003212:	709a      	strb	r2, [r3, #2]
    }
    break;
 8003214:	e07e      	b.n	8003314 <USBH_HandleEnum+0x31c>
    
  case ENUM_GET_PRODUCT_STRING_DESC:   
    if (phost->device_prop.Dev_Desc.iProduct != 0)
 8003216:	683b      	ldr	r3, [r7, #0]
 8003218:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 800321c:	2b00      	cmp	r3, #0
 800321e:	d01b      	beq.n	8003258 <USBH_HandleEnum+0x260>
    { /* Check that Product string is available */
      if ( USBH_Get_StringDesc(pdev,
                               phost,
                               phost->device_prop.Dev_Desc.iProduct, 
 8003220:	683b      	ldr	r3, [r7, #0]
    break;
    
  case ENUM_GET_PRODUCT_STRING_DESC:   
    if (phost->device_prop.Dev_Desc.iProduct != 0)
    { /* Check that Product string is available */
      if ( USBH_Get_StringDesc(pdev,
 8003222:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
 8003226:	f107 030c 	add.w	r3, r7, #12
 800322a:	f04f 01ff 	mov.w	r1, #255	; 0xff
 800322e:	9100      	str	r1, [sp, #0]
 8003230:	6878      	ldr	r0, [r7, #4]
 8003232:	6839      	ldr	r1, [r7, #0]
 8003234:	f000 fee6 	bl	8004004 <USBH_Get_StringDesc>
 8003238:	4603      	mov	r3, r0
 800323a:	2b00      	cmp	r3, #0
 800323c:	d16c      	bne.n	8003318 <USBH_HandleEnum+0x320>
                               phost->device_prop.Dev_Desc.iProduct, 
                               Local_Buffer, 
                               0xff) == USBH_OK)
      {
        /* User callback for Product string */
        phost->usr_cb->ProductString(Local_Buffer);
 800323e:	683b      	ldr	r3, [r7, #0]
 8003240:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003244:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003246:	f107 020c 	add.w	r2, r7, #12
 800324a:	4610      	mov	r0, r2
 800324c:	4798      	blx	r3
        phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800324e:	683b      	ldr	r3, [r7, #0]
 8003250:	f04f 0207 	mov.w	r2, #7
 8003254:	709a      	strb	r2, [r3, #2]
    else
    {
      phost->usr_cb->ProductString("N/A");
      phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
    } 
    break;
 8003256:	e05f      	b.n	8003318 <USBH_HandleEnum+0x320>
        phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
      }
    }
    else
    {
      phost->usr_cb->ProductString("N/A");
 8003258:	683b      	ldr	r3, [r7, #0]
 800325a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800325e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003260:	f64b 206c 	movw	r0, #47724	; 0xba6c
 8003264:	f6c0 0002 	movt	r0, #2050	; 0x802
 8003268:	4798      	blx	r3
      phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 800326a:	683b      	ldr	r3, [r7, #0]
 800326c:	f04f 0207 	mov.w	r2, #7
 8003270:	709a      	strb	r2, [r3, #2]
    } 
    break;
 8003272:	e051      	b.n	8003318 <USBH_HandleEnum+0x320>
    
  case ENUM_GET_SERIALNUM_STRING_DESC:   
    if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
 8003274:	683b      	ldr	r3, [r7, #0]
 8003276:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 800327a:	2b00      	cmp	r3, #0
 800327c:	d01b      	beq.n	80032b6 <USBH_HandleEnum+0x2be>
    { /* Check that Serial number string is available */    
      if ( USBH_Get_StringDesc(pdev, 
                               phost,
                               phost->device_prop.Dev_Desc.iSerialNumber, 
 800327e:	683b      	ldr	r3, [r7, #0]
    break;
    
  case ENUM_GET_SERIALNUM_STRING_DESC:   
    if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
    { /* Check that Serial number string is available */    
      if ( USBH_Get_StringDesc(pdev, 
 8003280:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8003284:	f107 030c 	add.w	r3, r7, #12
 8003288:	f04f 01ff 	mov.w	r1, #255	; 0xff
 800328c:	9100      	str	r1, [sp, #0]
 800328e:	6878      	ldr	r0, [r7, #4]
 8003290:	6839      	ldr	r1, [r7, #0]
 8003292:	f000 feb7 	bl	8004004 <USBH_Get_StringDesc>
 8003296:	4603      	mov	r3, r0
 8003298:	2b00      	cmp	r3, #0
 800329a:	d13f      	bne.n	800331c <USBH_HandleEnum+0x324>
                               phost->device_prop.Dev_Desc.iSerialNumber, 
                               Local_Buffer, 
                               0xff) == USBH_OK)
      {
        /* User callback for Serial number string */
        phost->usr_cb->SerialNumString(Local_Buffer);
 800329c:	683b      	ldr	r3, [r7, #0]
 800329e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80032a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80032a4:	f107 020c 	add.w	r2, r7, #12
 80032a8:	4610      	mov	r0, r2
 80032aa:	4798      	blx	r3
        phost->EnumState = ENUM_SET_CONFIGURATION;
 80032ac:	683b      	ldr	r3, [r7, #0]
 80032ae:	f04f 0208 	mov.w	r2, #8
 80032b2:	709a      	strb	r2, [r3, #2]
    else
    {
      phost->usr_cb->SerialNumString("N/A");      
      phost->EnumState = ENUM_SET_CONFIGURATION;
    }  
    break;
 80032b4:	e032      	b.n	800331c <USBH_HandleEnum+0x324>
        phost->EnumState = ENUM_SET_CONFIGURATION;
      }
    }
    else
    {
      phost->usr_cb->SerialNumString("N/A");      
 80032b6:	683b      	ldr	r3, [r7, #0]
 80032b8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80032bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80032be:	f64b 206c 	movw	r0, #47724	; 0xba6c
 80032c2:	f6c0 0002 	movt	r0, #2050	; 0x802
 80032c6:	4798      	blx	r3
      phost->EnumState = ENUM_SET_CONFIGURATION;
 80032c8:	683b      	ldr	r3, [r7, #0]
 80032ca:	f04f 0208 	mov.w	r2, #8
 80032ce:	709a      	strb	r2, [r3, #2]
    }  
    break;
 80032d0:	e024      	b.n	800331c <USBH_HandleEnum+0x324>
      
  case ENUM_SET_CONFIGURATION:
    /* set configuration  (default config) */
    if (USBH_SetCfg(pdev, 
                    phost,
                    phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
 80032d2:	683b      	ldr	r3, [r7, #0]
 80032d4:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    }  
    break;
      
  case ENUM_SET_CONFIGURATION:
    /* set configuration  (default config) */
    if (USBH_SetCfg(pdev, 
 80032d8:	6878      	ldr	r0, [r7, #4]
 80032da:	6839      	ldr	r1, [r7, #0]
 80032dc:	461a      	mov	r2, r3
 80032de:	f000 ff1b 	bl	8004118 <USBH_SetCfg>
 80032e2:	4603      	mov	r3, r0
 80032e4:	2b00      	cmp	r3, #0
 80032e6:	d11b      	bne.n	8003320 <USBH_HandleEnum+0x328>
                    phost,
                    phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
    {
      phost->EnumState = ENUM_DEV_CONFIGURED;
 80032e8:	683b      	ldr	r3, [r7, #0]
 80032ea:	f04f 0209 	mov.w	r2, #9
 80032ee:	709a      	strb	r2, [r3, #2]
    }
    break;
 80032f0:	e016      	b.n	8003320 <USBH_HandleEnum+0x328>

    
  case ENUM_DEV_CONFIGURED:
    /* user callback for enumeration done */
    Status = USBH_OK;
 80032f2:	f04f 0300 	mov.w	r3, #0
 80032f6:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
    break;
 80032fa:	e012      	b.n	8003322 <USBH_HandleEnum+0x32a>
    
  default:
    break;
 80032fc:	bf00      	nop
 80032fe:	e010      	b.n	8003322 <USBH_HandleEnum+0x32a>
                           0,
                           0,
                           0,
                           phost->Control.ep0size);      
    }
    break;
 8003300:	bf00      	nop
 8003302:	e00e      	b.n	8003322 <USBH_HandleEnum+0x32a>
    {
      /* user callback for device descriptor available */
      phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
      phost->EnumState = ENUM_SET_ADDR;
    }
    break;
 8003304:	bf00      	nop
 8003306:	e00c      	b.n	8003322 <USBH_HandleEnum+0x32a>
                           phost->device_prop.address,
                           0,
                           0,
                           0);         
    }
    break;
 8003308:	bf00      	nop
 800330a:	e00a      	b.n	8003322 <USBH_HandleEnum+0x32a>
                          phost,
                          USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
    {
      phost->EnumState = ENUM_GET_FULL_CFG_DESC;
    }
    break;
 800330c:	bf00      	nop
 800330e:	e008      	b.n	8003322 <USBH_HandleEnum+0x32a>
                                                      phost->device_prop.Itf_Desc,
                                                      phost->device_prop.Ep_Desc[0]);
      
      phost->EnumState = ENUM_GET_MFC_STRING_DESC;
    }
    break;
 8003310:	bf00      	nop
 8003312:	e006      	b.n	8003322 <USBH_HandleEnum+0x32a>
    else
    {
      phost->usr_cb->ManufacturerString("N/A");      
      phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
    }
    break;
 8003314:	bf00      	nop
 8003316:	e004      	b.n	8003322 <USBH_HandleEnum+0x32a>
    else
    {
      phost->usr_cb->ProductString("N/A");
      phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
    } 
    break;
 8003318:	bf00      	nop
 800331a:	e002      	b.n	8003322 <USBH_HandleEnum+0x32a>
    else
    {
      phost->usr_cb->SerialNumString("N/A");      
      phost->EnumState = ENUM_SET_CONFIGURATION;
    }  
    break;
 800331c:	bf00      	nop
 800331e:	e000      	b.n	8003322 <USBH_HandleEnum+0x32a>
                    phost,
                    phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
    {
      phost->EnumState = ENUM_DEV_CONFIGURED;
    }
    break;
 8003320:	bf00      	nop
    break;
    
  default:
    break;
  }  
  return Status;
 8003322:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
}
 8003326:	4618      	mov	r0, r3
 8003328:	f107 0750 	add.w	r7, r7, #80	; 0x50
 800332c:	46bd      	mov	sp, r7
 800332e:	bd80      	pop	{r7, pc}

08003330 <USBH_HandleControl>:
  *         Handles the USB control transfer state machine
  * @param  pdev: Selected device
  * @retval Status
  */
USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
{
 8003330:	b580      	push	{r7, lr}
 8003332:	b084      	sub	sp, #16
 8003334:	af00      	add	r7, sp, #0
 8003336:	6078      	str	r0, [r7, #4]
 8003338:	6039      	str	r1, [r7, #0]
  uint8_t direction;  
  static uint16_t timeout = 0;
  USBH_Status status = USBH_OK;
 800333a:	f04f 0300 	mov.w	r3, #0
 800333e:	73fb      	strb	r3, [r7, #15]
  URB_STATE URB_Status = URB_IDLE;
 8003340:	f04f 0300 	mov.w	r3, #0
 8003344:	73bb      	strb	r3, [r7, #14]
  
  phost->Control.status = CTRL_START;
 8003346:	683b      	ldr	r3, [r7, #0]
 8003348:	f04f 0200 	mov.w	r2, #0
 800334c:	749a      	strb	r2, [r3, #18]

  
  switch (phost->Control.state)
 800334e:	683b      	ldr	r3, [r7, #0]
 8003350:	7f1b      	ldrb	r3, [r3, #28]
 8003352:	f103 33ff 	add.w	r3, r3, #4294967295
 8003356:	2b0a      	cmp	r3, #10
 8003358:	f200 81af 	bhi.w	80036ba <USBH_HandleControl+0x38a>
 800335c:	a201      	add	r2, pc, #4	; (adr r2, 8003364 <USBH_HandleControl+0x34>)
 800335e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003362:	bf00      	nop
 8003364:	08003391 	.word	0x08003391
 8003368:	080033af 	.word	0x080033af
 800336c:	0800344f 	.word	0x0800344f
 8003370:	0800346d 	.word	0x0800346d
 8003374:	080034d3 	.word	0x080034d3
 8003378:	0800351b 	.word	0x0800351b
 800337c:	0800356d 	.word	0x0800356d
 8003380:	08003589 	.word	0x08003589
 8003384:	080035fd 	.word	0x080035fd
 8003388:	08003643 	.word	0x08003643
 800338c:	08003683 	.word	0x08003683
  {
  case CTRL_SETUP:
    /* send a SETUP packet */
    USBH_CtlSendSetup     (pdev, 
	                   phost->Control.setup.d8 , 
 8003390:	683b      	ldr	r3, [r7, #0]
 8003392:	f103 0214 	add.w	r2, r3, #20
	                   phost->Control.hc_num_out);  
 8003396:	683b      	ldr	r3, [r7, #0]
  
  switch (phost->Control.state)
  {
  case CTRL_SETUP:
    /* send a SETUP packet */
    USBH_CtlSendSetup     (pdev, 
 8003398:	795b      	ldrb	r3, [r3, #5]
 800339a:	6878      	ldr	r0, [r7, #4]
 800339c:	4611      	mov	r1, r2
 800339e:	461a      	mov	r2, r3
 80033a0:	f000 fb5a 	bl	8003a58 <USBH_CtlSendSetup>
	                   phost->Control.setup.d8 , 
	                   phost->Control.hc_num_out);  
    phost->Control.state = CTRL_SETUP_WAIT;  
 80033a4:	683b      	ldr	r3, [r7, #0]
 80033a6:	f04f 0202 	mov.w	r2, #2
 80033aa:	771a      	strb	r2, [r3, #28]
    break; 
 80033ac:	e190      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    
  case CTRL_SETUP_WAIT:
    
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
 80033ae:	683b      	ldr	r3, [r7, #0]
 80033b0:	795b      	ldrb	r3, [r3, #5]
 80033b2:	6878      	ldr	r0, [r7, #4]
 80033b4:	4619      	mov	r1, r3
 80033b6:	f7fe f955 	bl	8001664 <HCD_GetURB_State>
 80033ba:	4603      	mov	r3, r0
 80033bc:	73bb      	strb	r3, [r7, #14]
    /* case SETUP packet sent successfully */
    if(URB_Status == URB_DONE)
 80033be:	7bbb      	ldrb	r3, [r7, #14]
 80033c0:	2b01      	cmp	r3, #1
 80033c2:	d137      	bne.n	8003434 <USBH_HandleControl+0x104>
    { 
      direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 80033c4:	683b      	ldr	r3, [r7, #0]
 80033c6:	7d1b      	ldrb	r3, [r3, #20]
 80033c8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80033cc:	737b      	strb	r3, [r7, #13]
      
      /* check if there is a data stage */
      if (phost->Control.setup.b.wLength.w != 0 )
 80033ce:	683b      	ldr	r3, [r7, #0]
 80033d0:	8b5b      	ldrh	r3, [r3, #26]
 80033d2:	2b00      	cmp	r3, #0
 80033d4:	d013      	beq.n	80033fe <USBH_HandleControl+0xce>
      {        
        timeout = DATA_STAGE_TIMEOUT;
 80033d6:	f640 13ec 	movw	r3, #2540	; 0x9ec
 80033da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80033de:	f241 3288 	movw	r2, #5000	; 0x1388
 80033e2:	801a      	strh	r2, [r3, #0]
        if (direction == USB_D2H)
 80033e4:	7b7b      	ldrb	r3, [r7, #13]
 80033e6:	2b80      	cmp	r3, #128	; 0x80
 80033e8:	d104      	bne.n	80033f4 <USBH_HandleControl+0xc4>
        {
          /* Data Direction is IN */
          phost->Control.state = CTRL_DATA_IN;
 80033ea:	683b      	ldr	r3, [r7, #0]
 80033ec:	f04f 0203 	mov.w	r2, #3
 80033f0:	771a      	strb	r2, [r3, #28]
 80033f2:	e017      	b.n	8003424 <USBH_HandleControl+0xf4>
        }
        else
        {
          /* Data Direction is OUT */
          phost->Control.state = CTRL_DATA_OUT;
 80033f4:	683b      	ldr	r3, [r7, #0]
 80033f6:	f04f 0205 	mov.w	r2, #5
 80033fa:	771a      	strb	r2, [r3, #28]
 80033fc:	e012      	b.n	8003424 <USBH_HandleControl+0xf4>
        } 
      }
      /* No DATA stage */
      else
      {
        timeout = NODATA_STAGE_TIMEOUT;
 80033fe:	f640 13ec 	movw	r3, #2540	; 0x9ec
 8003402:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003406:	f04f 0232 	mov.w	r2, #50	; 0x32
 800340a:	801a      	strh	r2, [r3, #0]
        
        /* If there is No Data Transfer Stage */
        if (direction == USB_D2H)
 800340c:	7b7b      	ldrb	r3, [r7, #13]
 800340e:	2b80      	cmp	r3, #128	; 0x80
 8003410:	d104      	bne.n	800341c <USBH_HandleControl+0xec>
        {
          /* Data Direction is IN */
          phost->Control.state = CTRL_STATUS_OUT;
 8003412:	683b      	ldr	r3, [r7, #0]
 8003414:	f04f 0209 	mov.w	r2, #9
 8003418:	771a      	strb	r2, [r3, #28]
 800341a:	e003      	b.n	8003424 <USBH_HandleControl+0xf4>
        }
        else
        {
          /* Data Direction is OUT */
          phost->Control.state = CTRL_STATUS_IN;
 800341c:	683b      	ldr	r3, [r7, #0]
 800341e:	f04f 0207 	mov.w	r2, #7
 8003422:	771a      	strb	r2, [r3, #28]
        } 
      }          
      /* Set the delay timer to enable timeout for data stage completion */
      phost->Control.timer = HCD_GetCurrentFrame(pdev);
 8003424:	6878      	ldr	r0, [r7, #4]
 8003426:	f7fe f90b 	bl	8001640 <HCD_GetCurrentFrame>
 800342a:	4603      	mov	r3, r0
 800342c:	b29a      	uxth	r2, r3
 800342e:	683b      	ldr	r3, [r7, #0]
 8003430:	821a      	strh	r2, [r3, #16]
    else if(URB_Status == URB_ERROR)
    {
      phost->Control.state = CTRL_ERROR;     
      phost->Control.status = CTRL_XACTERR;
    }    
    break;
 8003432:	e144      	b.n	80036be <USBH_HandleControl+0x38e>
        } 
      }          
      /* Set the delay timer to enable timeout for data stage completion */
      phost->Control.timer = HCD_GetCurrentFrame(pdev);
    }
    else if(URB_Status == URB_ERROR)
 8003434:	7bbb      	ldrb	r3, [r7, #14]
 8003436:	2b03      	cmp	r3, #3
 8003438:	f040 8141 	bne.w	80036be <USBH_HandleControl+0x38e>
    {
      phost->Control.state = CTRL_ERROR;     
 800343c:	683b      	ldr	r3, [r7, #0]
 800343e:	f04f 020b 	mov.w	r2, #11
 8003442:	771a      	strb	r2, [r3, #28]
      phost->Control.status = CTRL_XACTERR;
 8003444:	683b      	ldr	r3, [r7, #0]
 8003446:	f04f 0205 	mov.w	r2, #5
 800344a:	749a      	strb	r2, [r3, #18]
    }    
    break;
 800344c:	e137      	b.n	80036be <USBH_HandleControl+0x38e>
    
  case CTRL_DATA_IN:  
    /* Issue an IN token */ 
    USBH_CtlReceiveData(pdev,
                        phost->Control.buff, 
 800344e:	683b      	ldr	r3, [r7, #0]
    }    
    break;
    
  case CTRL_DATA_IN:  
    /* Issue an IN token */ 
    USBH_CtlReceiveData(pdev,
 8003450:	6899      	ldr	r1, [r3, #8]
                        phost->Control.buff, 
                        phost->Control.length,
 8003452:	683b      	ldr	r3, [r7, #0]
 8003454:	899b      	ldrh	r3, [r3, #12]
    }    
    break;
    
  case CTRL_DATA_IN:  
    /* Issue an IN token */ 
    USBH_CtlReceiveData(pdev,
 8003456:	b2da      	uxtb	r2, r3
                        phost->Control.buff, 
                        phost->Control.length,
                        phost->Control.hc_num_in);
 8003458:	683b      	ldr	r3, [r7, #0]
    }    
    break;
    
  case CTRL_DATA_IN:  
    /* Issue an IN token */ 
    USBH_CtlReceiveData(pdev,
 800345a:	791b      	ldrb	r3, [r3, #4]
 800345c:	6878      	ldr	r0, [r7, #4]
 800345e:	f000 fb9b 	bl	8003b98 <USBH_CtlReceiveData>
                        phost->Control.buff, 
                        phost->Control.length,
                        phost->Control.hc_num_in);
 
    phost->Control.state = CTRL_DATA_IN_WAIT;
 8003462:	683b      	ldr	r3, [r7, #0]
 8003464:	f04f 0204 	mov.w	r2, #4
 8003468:	771a      	strb	r2, [r3, #28]
    break;    
 800346a:	e131      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    
  case CTRL_DATA_IN_WAIT:
    
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
 800346c:	683b      	ldr	r3, [r7, #0]
 800346e:	791b      	ldrb	r3, [r3, #4]
 8003470:	6878      	ldr	r0, [r7, #4]
 8003472:	4619      	mov	r1, r3
 8003474:	f7fe f8f6 	bl	8001664 <HCD_GetURB_State>
 8003478:	4603      	mov	r3, r0
 800347a:	73bb      	strb	r3, [r7, #14]
    
    /* check is DATA packet transfered successfully */
    if  (URB_Status == URB_DONE)
 800347c:	7bbb      	ldrb	r3, [r7, #14]
 800347e:	2b01      	cmp	r3, #1
 8003480:	d103      	bne.n	800348a <USBH_HandleControl+0x15a>
    { 
      phost->Control.state = CTRL_STATUS_OUT;
 8003482:	683b      	ldr	r3, [r7, #0]
 8003484:	f04f 0209 	mov.w	r2, #9
 8003488:	771a      	strb	r2, [r3, #28]
    }
   
    /* manage error cases*/
    if  (URB_Status == URB_STALL) 
 800348a:	7bbb      	ldrb	r3, [r7, #14]
 800348c:	2b04      	cmp	r3, #4
 800348e:	d104      	bne.n	800349a <USBH_HandleControl+0x16a>
    { 
      /* In stall case, return to previous machine state*/
      phost->gState =   phost->gStateBkp;
 8003490:	683b      	ldr	r3, [r7, #0]
 8003492:	785a      	ldrb	r2, [r3, #1]
 8003494:	683b      	ldr	r3, [r7, #0]
 8003496:	701a      	strb	r2, [r3, #0]
    else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
    {
      /* timeout for IN transfer */
      phost->Control.state = CTRL_ERROR; 
    }   
    break;
 8003498:	e113      	b.n	80036c2 <USBH_HandleControl+0x392>
    if  (URB_Status == URB_STALL) 
    { 
      /* In stall case, return to previous machine state*/
      phost->gState =   phost->gStateBkp;
    }   
    else if (URB_Status == URB_ERROR)
 800349a:	7bbb      	ldrb	r3, [r7, #14]
 800349c:	2b03      	cmp	r3, #3
 800349e:	d104      	bne.n	80034aa <USBH_HandleControl+0x17a>
    {
      /* Device error */
      phost->Control.state = CTRL_ERROR;    
 80034a0:	683b      	ldr	r3, [r7, #0]
 80034a2:	f04f 020b 	mov.w	r2, #11
 80034a6:	771a      	strb	r2, [r3, #28]
    else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
    {
      /* timeout for IN transfer */
      phost->Control.state = CTRL_ERROR; 
    }   
    break;
 80034a8:	e10b      	b.n	80036c2 <USBH_HandleControl+0x392>
    else if (URB_Status == URB_ERROR)
    {
      /* Device error */
      phost->Control.state = CTRL_ERROR;    
    }
    else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
 80034aa:	6878      	ldr	r0, [r7, #4]
 80034ac:	f7fe f8c8 	bl	8001640 <HCD_GetCurrentFrame>
 80034b0:	4602      	mov	r2, r0
 80034b2:	683b      	ldr	r3, [r7, #0]
 80034b4:	8a1b      	ldrh	r3, [r3, #16]
 80034b6:	1ad2      	subs	r2, r2, r3
 80034b8:	f640 13ec 	movw	r3, #2540	; 0x9ec
 80034bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80034c0:	881b      	ldrh	r3, [r3, #0]
 80034c2:	429a      	cmp	r2, r3
 80034c4:	f240 80fd 	bls.w	80036c2 <USBH_HandleControl+0x392>
    {
      /* timeout for IN transfer */
      phost->Control.state = CTRL_ERROR; 
 80034c8:	683b      	ldr	r3, [r7, #0]
 80034ca:	f04f 020b 	mov.w	r2, #11
 80034ce:	771a      	strb	r2, [r3, #28]
    }   
    break;
 80034d0:	e0f7      	b.n	80036c2 <USBH_HandleControl+0x392>
    
  case CTRL_DATA_OUT:
    /* Start DATA out transfer (only one DATA packet)*/
    
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
 80034d2:	683b      	ldr	r3, [r7, #0]
 80034d4:	795b      	ldrb	r3, [r3, #5]
 80034d6:	683a      	ldr	r2, [r7, #0]
 80034d8:	7952      	ldrb	r2, [r2, #5]
 80034da:	6879      	ldr	r1, [r7, #4]
 80034dc:	f102 0216 	add.w	r2, r2, #22
 80034e0:	ea4f 1242 	mov.w	r2, r2, lsl #5
 80034e4:	188a      	adds	r2, r1, r2
 80034e6:	7952      	ldrb	r2, [r2, #5]
 80034e8:	f082 0201 	eor.w	r2, r2, #1
 80034ec:	b2d2      	uxtb	r2, r2
 80034ee:	6879      	ldr	r1, [r7, #4]
 80034f0:	f103 0316 	add.w	r3, r3, #22
 80034f4:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80034f8:	18cb      	adds	r3, r1, r3
 80034fa:	715a      	strb	r2, [r3, #5]
    
    USBH_CtlSendData (pdev,
                      phost->Control.buff, 
 80034fc:	683b      	ldr	r3, [r7, #0]
  case CTRL_DATA_OUT:
    /* Start DATA out transfer (only one DATA packet)*/
    
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
    
    USBH_CtlSendData (pdev,
 80034fe:	6899      	ldr	r1, [r3, #8]
                      phost->Control.buff, 
                      phost->Control.length , 
 8003500:	683b      	ldr	r3, [r7, #0]
 8003502:	899b      	ldrh	r3, [r3, #12]
  case CTRL_DATA_OUT:
    /* Start DATA out transfer (only one DATA packet)*/
    
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
    
    USBH_CtlSendData (pdev,
 8003504:	b2da      	uxtb	r2, r3
                      phost->Control.buff, 
                      phost->Control.length , 
                      phost->Control.hc_num_out);
 8003506:	683b      	ldr	r3, [r7, #0]
  case CTRL_DATA_OUT:
    /* Start DATA out transfer (only one DATA packet)*/
    
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
    
    USBH_CtlSendData (pdev,
 8003508:	795b      	ldrb	r3, [r3, #5]
 800350a:	6878      	ldr	r0, [r7, #4]
 800350c:	f000 fae2 	bl	8003ad4 <USBH_CtlSendData>
                      phost->Control.buff, 
                      phost->Control.length , 
                      phost->Control.hc_num_out);
    
    phost->Control.state = CTRL_DATA_OUT_WAIT;
 8003510:	683b      	ldr	r3, [r7, #0]
 8003512:	f04f 0206 	mov.w	r2, #6
 8003516:	771a      	strb	r2, [r3, #28]
    break;
 8003518:	e0da      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    
  case CTRL_DATA_OUT_WAIT:
    
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
 800351a:	683b      	ldr	r3, [r7, #0]
 800351c:	795b      	ldrb	r3, [r3, #5]
 800351e:	6878      	ldr	r0, [r7, #4]
 8003520:	4619      	mov	r1, r3
 8003522:	f7fe f89f 	bl	8001664 <HCD_GetURB_State>
 8003526:	4603      	mov	r3, r0
 8003528:	73bb      	strb	r3, [r7, #14]
    if  (URB_Status == URB_DONE)
 800352a:	7bbb      	ldrb	r3, [r7, #14]
 800352c:	2b01      	cmp	r3, #1
 800352e:	d104      	bne.n	800353a <USBH_HandleControl+0x20a>
    { /* If the Setup Pkt is sent successful, then change the state */
      phost->Control.state = CTRL_STATUS_IN;
 8003530:	683b      	ldr	r3, [r7, #0]
 8003532:	f04f 0207 	mov.w	r2, #7
 8003536:	771a      	strb	r2, [r3, #28]
    else if (URB_Status == URB_ERROR)
    {
      /* device error */
      phost->Control.state = CTRL_ERROR;      
    } 
    break;
 8003538:	e0c5      	b.n	80036c6 <USBH_HandleControl+0x396>
    { /* If the Setup Pkt is sent successful, then change the state */
      phost->Control.state = CTRL_STATUS_IN;
    }
    
    /* handle error cases */
    else if  (URB_Status == URB_STALL) 
 800353a:	7bbb      	ldrb	r3, [r7, #14]
 800353c:	2b04      	cmp	r3, #4
 800353e:	d104      	bne.n	800354a <USBH_HandleControl+0x21a>
    { 
      /* In stall case, return to previous machine state*/
      phost->gState =   phost->gStateBkp;
 8003540:	683b      	ldr	r3, [r7, #0]
 8003542:	785a      	ldrb	r2, [r3, #1]
 8003544:	683b      	ldr	r3, [r7, #0]
 8003546:	701a      	strb	r2, [r3, #0]
    else if (URB_Status == URB_ERROR)
    {
      /* device error */
      phost->Control.state = CTRL_ERROR;      
    } 
    break;
 8003548:	e0bd      	b.n	80036c6 <USBH_HandleControl+0x396>
    else if  (URB_Status == URB_STALL) 
    { 
      /* In stall case, return to previous machine state*/
      phost->gState =   phost->gStateBkp;
    } 
    else if  (URB_Status == URB_NOTREADY)
 800354a:	7bbb      	ldrb	r3, [r7, #14]
 800354c:	2b02      	cmp	r3, #2
 800354e:	d104      	bne.n	800355a <USBH_HandleControl+0x22a>
    { 
      /* Nack received from device */
      phost->Control.state = CTRL_DATA_OUT;
 8003550:	683b      	ldr	r3, [r7, #0]
 8003552:	f04f 0205 	mov.w	r2, #5
 8003556:	771a      	strb	r2, [r3, #28]
    else if (URB_Status == URB_ERROR)
    {
      /* device error */
      phost->Control.state = CTRL_ERROR;      
    } 
    break;
 8003558:	e0b5      	b.n	80036c6 <USBH_HandleControl+0x396>
    else if  (URB_Status == URB_NOTREADY)
    { 
      /* Nack received from device */
      phost->Control.state = CTRL_DATA_OUT;
    }    
    else if (URB_Status == URB_ERROR)
 800355a:	7bbb      	ldrb	r3, [r7, #14]
 800355c:	2b03      	cmp	r3, #3
 800355e:	f040 80b2 	bne.w	80036c6 <USBH_HandleControl+0x396>
    {
      /* device error */
      phost->Control.state = CTRL_ERROR;      
 8003562:	683b      	ldr	r3, [r7, #0]
 8003564:	f04f 020b 	mov.w	r2, #11
 8003568:	771a      	strb	r2, [r3, #28]
    } 
    break;
 800356a:	e0ac      	b.n	80036c6 <USBH_HandleControl+0x396>
  case CTRL_STATUS_IN:
    /* Send 0 bytes out packet */
    USBH_CtlReceiveData (pdev,
                         0,
                         0,
                         phost->Control.hc_num_in);
 800356c:	683b      	ldr	r3, [r7, #0]
    break;
    
    
  case CTRL_STATUS_IN:
    /* Send 0 bytes out packet */
    USBH_CtlReceiveData (pdev,
 800356e:	791b      	ldrb	r3, [r3, #4]
 8003570:	6878      	ldr	r0, [r7, #4]
 8003572:	f04f 0100 	mov.w	r1, #0
 8003576:	f04f 0200 	mov.w	r2, #0
 800357a:	f000 fb0d 	bl	8003b98 <USBH_CtlReceiveData>
                         0,
                         0,
                         phost->Control.hc_num_in);
    
    phost->Control.state = CTRL_STATUS_IN_WAIT;
 800357e:	683b      	ldr	r3, [r7, #0]
 8003580:	f04f 0208 	mov.w	r2, #8
 8003584:	771a      	strb	r2, [r3, #28]
    
    break;
 8003586:	e0a3      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    
  case CTRL_STATUS_IN_WAIT:
    
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
 8003588:	683b      	ldr	r3, [r7, #0]
 800358a:	791b      	ldrb	r3, [r3, #4]
 800358c:	6878      	ldr	r0, [r7, #4]
 800358e:	4619      	mov	r1, r3
 8003590:	f7fe f868 	bl	8001664 <HCD_GetURB_State>
 8003594:	4603      	mov	r3, r0
 8003596:	73bb      	strb	r3, [r7, #14]
    
    if  ( URB_Status == URB_DONE)
 8003598:	7bbb      	ldrb	r3, [r7, #14]
 800359a:	2b01      	cmp	r3, #1
 800359c:	d104      	bne.n	80035a8 <USBH_HandleControl+0x278>
    { /* Control transfers completed, Exit the State Machine */
      phost->gState =   phost->gStateBkp;
 800359e:	683b      	ldr	r3, [r7, #0]
 80035a0:	785a      	ldrb	r2, [r3, #1]
 80035a2:	683b      	ldr	r3, [r7, #0]
 80035a4:	701a      	strb	r2, [r3, #0]
      /* Control transfers completed, Exit the State Machine */
      phost->gState =   phost->gStateBkp;
      phost->Control.status = CTRL_STALL;
      status = USBH_NOT_SUPPORTED;
    }
    break;
 80035a6:	e090      	b.n	80036ca <USBH_HandleControl+0x39a>
    if  ( URB_Status == URB_DONE)
    { /* Control transfers completed, Exit the State Machine */
      phost->gState =   phost->gStateBkp;
    }
    
    else if (URB_Status == URB_ERROR)
 80035a8:	7bbb      	ldrb	r3, [r7, #14]
 80035aa:	2b03      	cmp	r3, #3
 80035ac:	d104      	bne.n	80035b8 <USBH_HandleControl+0x288>
    {
      phost->Control.state = CTRL_ERROR;  
 80035ae:	683b      	ldr	r3, [r7, #0]
 80035b0:	f04f 020b 	mov.w	r2, #11
 80035b4:	771a      	strb	r2, [r3, #28]
      /* Control transfers completed, Exit the State Machine */
      phost->gState =   phost->gStateBkp;
      phost->Control.status = CTRL_STALL;
      status = USBH_NOT_SUPPORTED;
    }
    break;
 80035b6:	e088      	b.n	80036ca <USBH_HandleControl+0x39a>
    else if (URB_Status == URB_ERROR)
    {
      phost->Control.state = CTRL_ERROR;  
    }
    
    else if((HCD_GetCurrentFrame(pdev)\
 80035b8:	6878      	ldr	r0, [r7, #4]
 80035ba:	f7fe f841 	bl	8001640 <HCD_GetCurrentFrame>
 80035be:	4602      	mov	r2, r0
      - phost->Control.timer) > timeout)
 80035c0:	683b      	ldr	r3, [r7, #0]
 80035c2:	8a1b      	ldrh	r3, [r3, #16]
 80035c4:	1ad2      	subs	r2, r2, r3
 80035c6:	f640 13ec 	movw	r3, #2540	; 0x9ec
 80035ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035ce:	881b      	ldrh	r3, [r3, #0]
    else if (URB_Status == URB_ERROR)
    {
      phost->Control.state = CTRL_ERROR;  
    }
    
    else if((HCD_GetCurrentFrame(pdev)\
 80035d0:	429a      	cmp	r2, r3
 80035d2:	d904      	bls.n	80035de <USBH_HandleControl+0x2ae>
      - phost->Control.timer) > timeout)
    {
      phost->Control.state = CTRL_ERROR; 
 80035d4:	683b      	ldr	r3, [r7, #0]
 80035d6:	f04f 020b 	mov.w	r2, #11
 80035da:	771a      	strb	r2, [r3, #28]
      /* Control transfers completed, Exit the State Machine */
      phost->gState =   phost->gStateBkp;
      phost->Control.status = CTRL_STALL;
      status = USBH_NOT_SUPPORTED;
    }
    break;
 80035dc:	e075      	b.n	80036ca <USBH_HandleControl+0x39a>
    else if((HCD_GetCurrentFrame(pdev)\
      - phost->Control.timer) > timeout)
    {
      phost->Control.state = CTRL_ERROR; 
    }
     else if(URB_Status == URB_STALL)
 80035de:	7bbb      	ldrb	r3, [r7, #14]
 80035e0:	2b04      	cmp	r3, #4
 80035e2:	d172      	bne.n	80036ca <USBH_HandleControl+0x39a>
    {
      /* Control transfers completed, Exit the State Machine */
      phost->gState =   phost->gStateBkp;
 80035e4:	683b      	ldr	r3, [r7, #0]
 80035e6:	785a      	ldrb	r2, [r3, #1]
 80035e8:	683b      	ldr	r3, [r7, #0]
 80035ea:	701a      	strb	r2, [r3, #0]
      phost->Control.status = CTRL_STALL;
 80035ec:	683b      	ldr	r3, [r7, #0]
 80035ee:	f04f 0204 	mov.w	r2, #4
 80035f2:	749a      	strb	r2, [r3, #18]
      status = USBH_NOT_SUPPORTED;
 80035f4:	f04f 0303 	mov.w	r3, #3
 80035f8:	73fb      	strb	r3, [r7, #15]
    }
    break;
 80035fa:	e066      	b.n	80036ca <USBH_HandleControl+0x39a>
    
  case CTRL_STATUS_OUT:
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
 80035fc:	683b      	ldr	r3, [r7, #0]
 80035fe:	795b      	ldrb	r3, [r3, #5]
 8003600:	683a      	ldr	r2, [r7, #0]
 8003602:	7952      	ldrb	r2, [r2, #5]
 8003604:	6879      	ldr	r1, [r7, #4]
 8003606:	f102 0216 	add.w	r2, r2, #22
 800360a:	ea4f 1242 	mov.w	r2, r2, lsl #5
 800360e:	188a      	adds	r2, r1, r2
 8003610:	7952      	ldrb	r2, [r2, #5]
 8003612:	f082 0201 	eor.w	r2, r2, #1
 8003616:	b2d2      	uxtb	r2, r2
 8003618:	6879      	ldr	r1, [r7, #4]
 800361a:	f103 0316 	add.w	r3, r3, #22
 800361e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003622:	18cb      	adds	r3, r1, r3
 8003624:	715a      	strb	r2, [r3, #5]
    USBH_CtlSendData (pdev,
                      0,
                      0,
                      phost->Control.hc_num_out);
 8003626:	683b      	ldr	r3, [r7, #0]
    }
    break;
    
  case CTRL_STATUS_OUT:
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
    USBH_CtlSendData (pdev,
 8003628:	795b      	ldrb	r3, [r3, #5]
 800362a:	6878      	ldr	r0, [r7, #4]
 800362c:	f04f 0100 	mov.w	r1, #0
 8003630:	f04f 0200 	mov.w	r2, #0
 8003634:	f000 fa4e 	bl	8003ad4 <USBH_CtlSendData>
                      0,
                      0,
                      phost->Control.hc_num_out);
    
    phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8003638:	683b      	ldr	r3, [r7, #0]
 800363a:	f04f 020a 	mov.w	r2, #10
 800363e:	771a      	strb	r2, [r3, #28]
    break;
 8003640:	e046      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    
  case CTRL_STATUS_OUT_WAIT: 
    
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
 8003642:	683b      	ldr	r3, [r7, #0]
 8003644:	795b      	ldrb	r3, [r3, #5]
 8003646:	6878      	ldr	r0, [r7, #4]
 8003648:	4619      	mov	r1, r3
 800364a:	f7fe f80b 	bl	8001664 <HCD_GetURB_State>
 800364e:	4603      	mov	r3, r0
 8003650:	73bb      	strb	r3, [r7, #14]
    if  (URB_Status == URB_DONE)
 8003652:	7bbb      	ldrb	r3, [r7, #14]
 8003654:	2b01      	cmp	r3, #1
 8003656:	d104      	bne.n	8003662 <USBH_HandleControl+0x332>
    { 
      phost->gState =   phost->gStateBkp;    
 8003658:	683b      	ldr	r3, [r7, #0]
 800365a:	785a      	ldrb	r2, [r3, #1]
 800365c:	683b      	ldr	r3, [r7, #0]
 800365e:	701a      	strb	r2, [r3, #0]
    }      
    else if (URB_Status == URB_ERROR)
    {
      phost->Control.state = CTRL_ERROR;      
    }
    break;
 8003660:	e035      	b.n	80036ce <USBH_HandleControl+0x39e>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
    if  (URB_Status == URB_DONE)
    { 
      phost->gState =   phost->gStateBkp;    
    }
    else if  (URB_Status == URB_NOTREADY)
 8003662:	7bbb      	ldrb	r3, [r7, #14]
 8003664:	2b02      	cmp	r3, #2
 8003666:	d104      	bne.n	8003672 <USBH_HandleControl+0x342>
    { 
      phost->Control.state = CTRL_STATUS_OUT;
 8003668:	683b      	ldr	r3, [r7, #0]
 800366a:	f04f 0209 	mov.w	r2, #9
 800366e:	771a      	strb	r2, [r3, #28]
    }      
    else if (URB_Status == URB_ERROR)
    {
      phost->Control.state = CTRL_ERROR;      
    }
    break;
 8003670:	e02d      	b.n	80036ce <USBH_HandleControl+0x39e>
    }
    else if  (URB_Status == URB_NOTREADY)
    { 
      phost->Control.state = CTRL_STATUS_OUT;
    }      
    else if (URB_Status == URB_ERROR)
 8003672:	7bbb      	ldrb	r3, [r7, #14]
 8003674:	2b03      	cmp	r3, #3
 8003676:	d12a      	bne.n	80036ce <USBH_HandleControl+0x39e>
    {
      phost->Control.state = CTRL_ERROR;      
 8003678:	683b      	ldr	r3, [r7, #0]
 800367a:	f04f 020b 	mov.w	r2, #11
 800367e:	771a      	strb	r2, [r3, #28]
    }
    break;
 8003680:	e025      	b.n	80036ce <USBH_HandleControl+0x39e>
    PID; i.e., recovery actions via some other pipe are not required for control
    endpoints. For the Default Control Pipe, a device reset will ultimately be 
    required to clear the halt or error condition if the next Setup PID is not 
    accepted.
    */
    if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8003682:	683b      	ldr	r3, [r7, #0]
 8003684:	7b9b      	ldrb	r3, [r3, #14]
 8003686:	f103 0301 	add.w	r3, r3, #1
 800368a:	b2da      	uxtb	r2, r3
 800368c:	683b      	ldr	r3, [r7, #0]
 800368e:	739a      	strb	r2, [r3, #14]
 8003690:	683b      	ldr	r3, [r7, #0]
 8003692:	7b9b      	ldrb	r3, [r3, #14]
 8003694:	2b02      	cmp	r3, #2
 8003696:	d804      	bhi.n	80036a2 <USBH_HandleControl+0x372>
    {
      /* Do the transmission again, starting from SETUP Packet */
      phost->Control.state = CTRL_SETUP; 
 8003698:	683b      	ldr	r3, [r7, #0]
 800369a:	f04f 0201 	mov.w	r2, #1
 800369e:	771a      	strb	r2, [r3, #28]
      phost->Control.status = CTRL_FAIL;
      phost->gState =   phost->gStateBkp;
      
      status = USBH_FAIL;
    }
    break;
 80036a0:	e016      	b.n	80036d0 <USBH_HandleControl+0x3a0>
      /* Do the transmission again, starting from SETUP Packet */
      phost->Control.state = CTRL_SETUP; 
    }
    else
    {
      phost->Control.status = CTRL_FAIL;
 80036a2:	683b      	ldr	r3, [r7, #0]
 80036a4:	f04f 0208 	mov.w	r2, #8
 80036a8:	749a      	strb	r2, [r3, #18]
      phost->gState =   phost->gStateBkp;
 80036aa:	683b      	ldr	r3, [r7, #0]
 80036ac:	785a      	ldrb	r2, [r3, #1]
 80036ae:	683b      	ldr	r3, [r7, #0]
 80036b0:	701a      	strb	r2, [r3, #0]
      
      status = USBH_FAIL;
 80036b2:	f04f 0302 	mov.w	r3, #2
 80036b6:	73fb      	strb	r3, [r7, #15]
    }
    break;
 80036b8:	e00a      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    
  default:
    break;
 80036ba:	bf00      	nop
 80036bc:	e008      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    else if(URB_Status == URB_ERROR)
    {
      phost->Control.state = CTRL_ERROR;     
      phost->Control.status = CTRL_XACTERR;
    }    
    break;
 80036be:	bf00      	nop
 80036c0:	e006      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
    {
      /* timeout for IN transfer */
      phost->Control.state = CTRL_ERROR; 
    }   
    break;
 80036c2:	bf00      	nop
 80036c4:	e004      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    else if (URB_Status == URB_ERROR)
    {
      /* device error */
      phost->Control.state = CTRL_ERROR;      
    } 
    break;
 80036c6:	bf00      	nop
 80036c8:	e002      	b.n	80036d0 <USBH_HandleControl+0x3a0>
      /* Control transfers completed, Exit the State Machine */
      phost->gState =   phost->gStateBkp;
      phost->Control.status = CTRL_STALL;
      status = USBH_NOT_SUPPORTED;
    }
    break;
 80036ca:	bf00      	nop
 80036cc:	e000      	b.n	80036d0 <USBH_HandleControl+0x3a0>
    }      
    else if (URB_Status == URB_ERROR)
    {
      phost->Control.state = CTRL_ERROR;      
    }
    break;
 80036ce:	bf00      	nop
    break;
    
  default:
    break;
  }
  return status;
 80036d0:	7bfb      	ldrb	r3, [r7, #15]
}
 80036d2:	4618      	mov	r0, r3
 80036d4:	f107 0710 	add.w	r7, r7, #16
 80036d8:	46bd      	mov	sp, r7
 80036da:	bd80      	pop	{r7, pc}

080036dc <USBH_Open_Channel>:
                            uint8_t hc_num,
                            uint8_t dev_address,
                            uint8_t speed,
                            uint8_t ep_type,
                            uint16_t mps)
{
 80036dc:	b580      	push	{r7, lr}
 80036de:	b082      	sub	sp, #8
 80036e0:	af00      	add	r7, sp, #0
 80036e2:	6078      	str	r0, [r7, #4]
 80036e4:	70f9      	strb	r1, [r7, #3]
 80036e6:	70ba      	strb	r2, [r7, #2]
 80036e8:	707b      	strb	r3, [r7, #1]

  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
 80036ea:	78f8      	ldrb	r0, [r7, #3]
 80036ec:	78fb      	ldrb	r3, [r7, #3]
 80036ee:	687a      	ldr	r2, [r7, #4]
 80036f0:	f503 7311 	add.w	r3, r3, #580	; 0x244
 80036f4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80036f8:	18d3      	adds	r3, r2, r3
 80036fa:	889b      	ldrh	r3, [r3, #4]
 80036fc:	b2db      	uxtb	r3, r3
 80036fe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8003702:	b2da      	uxtb	r2, r3
 8003704:	6879      	ldr	r1, [r7, #4]
 8003706:	ea4f 1340 	mov.w	r3, r0, lsl #5
 800370a:	18cb      	adds	r3, r1, r3
 800370c:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003710:	715a      	strb	r2, [r3, #5]
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
 8003712:	78f8      	ldrb	r0, [r7, #3]
 8003714:	78fb      	ldrb	r3, [r7, #3]
 8003716:	687a      	ldr	r2, [r7, #4]
 8003718:	f503 7311 	add.w	r3, r3, #580	; 0x244
 800371c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003720:	18d3      	adds	r3, r2, r3
 8003722:	889b      	ldrh	r3, [r3, #4]
 8003724:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003728:	2b00      	cmp	r3, #0
 800372a:	bf0c      	ite	eq
 800372c:	2300      	moveq	r3, #0
 800372e:	2301      	movne	r3, #1
 8003730:	b2da      	uxtb	r2, r3
 8003732:	6879      	ldr	r1, [r7, #4]
 8003734:	ea4f 1340 	mov.w	r3, r0, lsl #5
 8003738:	18cb      	adds	r3, r1, r3
 800373a:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 800373e:	719a      	strb	r2, [r3, #6]
  pdev->host.hc[hc_num].dev_addr = dev_address;  
 8003740:	78fb      	ldrb	r3, [r7, #3]
 8003742:	687a      	ldr	r2, [r7, #4]
 8003744:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003748:	18d3      	adds	r3, r2, r3
 800374a:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 800374e:	78ba      	ldrb	r2, [r7, #2]
 8003750:	711a      	strb	r2, [r3, #4]
  pdev->host.hc[hc_num].ep_type = ep_type;  
 8003752:	78fb      	ldrb	r3, [r7, #3]
 8003754:	687a      	ldr	r2, [r7, #4]
 8003756:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800375a:	18d3      	adds	r3, r2, r3
 800375c:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003760:	7c3a      	ldrb	r2, [r7, #16]
 8003762:	725a      	strb	r2, [r3, #9]
  pdev->host.hc[hc_num].max_packet = mps; 
 8003764:	78fb      	ldrb	r3, [r7, #3]
 8003766:	687a      	ldr	r2, [r7, #4]
 8003768:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800376c:	18d3      	adds	r3, r2, r3
 800376e:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003772:	8aba      	ldrh	r2, [r7, #20]
 8003774:	815a      	strh	r2, [r3, #10]
  pdev->host.hc[hc_num].speed = speed; 
 8003776:	78fb      	ldrb	r3, [r7, #3]
 8003778:	687a      	ldr	r2, [r7, #4]
 800377a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800377e:	18d3      	adds	r3, r2, r3
 8003780:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003784:	787a      	ldrb	r2, [r7, #1]
 8003786:	71da      	strb	r2, [r3, #7]
  pdev->host.hc[hc_num].toggle_in = 0; 
 8003788:	78fb      	ldrb	r3, [r7, #3]
 800378a:	687a      	ldr	r2, [r7, #4]
 800378c:	f103 0316 	add.w	r3, r3, #22
 8003790:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003794:	18d3      	adds	r3, r2, r3
 8003796:	f04f 0200 	mov.w	r2, #0
 800379a:	711a      	strb	r2, [r3, #4]
  pdev->host.hc[hc_num].toggle_out = 0;   
 800379c:	78fb      	ldrb	r3, [r7, #3]
 800379e:	687a      	ldr	r2, [r7, #4]
 80037a0:	f103 0316 	add.w	r3, r3, #22
 80037a4:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80037a8:	18d3      	adds	r3, r2, r3
 80037aa:	f04f 0200 	mov.w	r2, #0
 80037ae:	715a      	strb	r2, [r3, #5]
  if(speed == HPRT0_PRTSPD_HIGH_SPEED)
 80037b0:	787b      	ldrb	r3, [r7, #1]
 80037b2:	2b00      	cmp	r3, #0
 80037b4:	d109      	bne.n	80037ca <USBH_Open_Channel+0xee>
  {
    pdev->host.hc[hc_num].do_ping = 1;
 80037b6:	78fb      	ldrb	r3, [r7, #3]
 80037b8:	687a      	ldr	r2, [r7, #4]
 80037ba:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80037be:	18d3      	adds	r3, r2, r3
 80037c0:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 80037c4:	f04f 0201 	mov.w	r2, #1
 80037c8:	721a      	strb	r2, [r3, #8]
  }
  
  USB_OTG_HC_Init(pdev, hc_num) ;
 80037ca:	78fb      	ldrb	r3, [r7, #3]
 80037cc:	6878      	ldr	r0, [r7, #4]
 80037ce:	4619      	mov	r1, r3
 80037d0:	f7fd fadc 	bl	8000d8c <USB_OTG_HC_Init>
  
  return HC_OK; 
 80037d4:	f04f 0300 	mov.w	r3, #0

}
 80037d8:	4618      	mov	r0, r3
 80037da:	f107 0708 	add.w	r7, r7, #8
 80037de:	46bd      	mov	sp, r7
 80037e0:	bd80      	pop	{r7, pc}
 80037e2:	bf00      	nop

080037e4 <USBH_Modify_Channel>:
                            uint8_t hc_num,
                            uint8_t dev_address,
                            uint8_t speed,
                            uint8_t ep_type,
                            uint16_t mps)
{
 80037e4:	b580      	push	{r7, lr}
 80037e6:	b082      	sub	sp, #8
 80037e8:	af00      	add	r7, sp, #0
 80037ea:	6078      	str	r0, [r7, #4]
 80037ec:	70f9      	strb	r1, [r7, #3]
 80037ee:	70ba      	strb	r2, [r7, #2]
 80037f0:	707b      	strb	r3, [r7, #1]
  
  if(dev_address != 0)
 80037f2:	78bb      	ldrb	r3, [r7, #2]
 80037f4:	2b00      	cmp	r3, #0
 80037f6:	d008      	beq.n	800380a <USBH_Modify_Channel+0x26>
  {
    pdev->host.hc[hc_num].dev_addr = dev_address;  
 80037f8:	78fb      	ldrb	r3, [r7, #3]
 80037fa:	687a      	ldr	r2, [r7, #4]
 80037fc:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003800:	18d3      	adds	r3, r2, r3
 8003802:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003806:	78ba      	ldrb	r2, [r7, #2]
 8003808:	711a      	strb	r2, [r3, #4]
  }
  
  if((pdev->host.hc[hc_num].max_packet != mps) && (mps != 0))
 800380a:	78fb      	ldrb	r3, [r7, #3]
 800380c:	687a      	ldr	r2, [r7, #4]
 800380e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003812:	18d3      	adds	r3, r2, r3
 8003814:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003818:	895b      	ldrh	r3, [r3, #10]
 800381a:	8aba      	ldrh	r2, [r7, #20]
 800381c:	429a      	cmp	r2, r3
 800381e:	d00b      	beq.n	8003838 <USBH_Modify_Channel+0x54>
 8003820:	8abb      	ldrh	r3, [r7, #20]
 8003822:	2b00      	cmp	r3, #0
 8003824:	d008      	beq.n	8003838 <USBH_Modify_Channel+0x54>
  {
    pdev->host.hc[hc_num].max_packet = mps; 
 8003826:	78fb      	ldrb	r3, [r7, #3]
 8003828:	687a      	ldr	r2, [r7, #4]
 800382a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800382e:	18d3      	adds	r3, r2, r3
 8003830:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003834:	8aba      	ldrh	r2, [r7, #20]
 8003836:	815a      	strh	r2, [r3, #10]
  }
  
  if((pdev->host.hc[hc_num].speed != speed ) && (speed != 0 )) 
 8003838:	78fb      	ldrb	r3, [r7, #3]
 800383a:	687a      	ldr	r2, [r7, #4]
 800383c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003840:	18d3      	adds	r3, r2, r3
 8003842:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003846:	79db      	ldrb	r3, [r3, #7]
 8003848:	787a      	ldrb	r2, [r7, #1]
 800384a:	429a      	cmp	r2, r3
 800384c:	d00b      	beq.n	8003866 <USBH_Modify_Channel+0x82>
 800384e:	787b      	ldrb	r3, [r7, #1]
 8003850:	2b00      	cmp	r3, #0
 8003852:	d008      	beq.n	8003866 <USBH_Modify_Channel+0x82>
  {
    pdev->host.hc[hc_num].speed = speed; 
 8003854:	78fb      	ldrb	r3, [r7, #3]
 8003856:	687a      	ldr	r2, [r7, #4]
 8003858:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800385c:	18d3      	adds	r3, r2, r3
 800385e:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003862:	787a      	ldrb	r2, [r7, #1]
 8003864:	71da      	strb	r2, [r3, #7]
  }
  
  USB_OTG_HC_Init(pdev, hc_num);
 8003866:	78fb      	ldrb	r3, [r7, #3]
 8003868:	6878      	ldr	r0, [r7, #4]
 800386a:	4619      	mov	r1, r3
 800386c:	f7fd fa8e 	bl	8000d8c <USB_OTG_HC_Init>
  return HC_OK; 
 8003870:	f04f 0300 	mov.w	r3, #0

}
 8003874:	4618      	mov	r0, r3
 8003876:	f107 0708 	add.w	r7, r7, #8
 800387a:	46bd      	mov	sp, r7
 800387c:	bd80      	pop	{r7, pc}
 800387e:	bf00      	nop

08003880 <USBH_Alloc_Channel>:
  *         Allocate a new channel for the pipe
  * @param  ep_addr: End point for which the channel to be allocated
  * @retval hc_num: Host channel number
  */
uint8_t USBH_Alloc_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t ep_addr)
{
 8003880:	b580      	push	{r7, lr}
 8003882:	b084      	sub	sp, #16
 8003884:	af00      	add	r7, sp, #0
 8003886:	6078      	str	r0, [r7, #4]
 8003888:	460b      	mov	r3, r1
 800388a:	70fb      	strb	r3, [r7, #3]
  uint16_t hc_num;
  
  hc_num =  USBH_GetFreeChannel(pdev);
 800388c:	6878      	ldr	r0, [r7, #4]
 800388e:	f000 f865 	bl	800395c <USBH_GetFreeChannel>
 8003892:	4603      	mov	r3, r0
 8003894:	81fb      	strh	r3, [r7, #14]

  if (hc_num != HC_ERROR)
 8003896:	89fa      	ldrh	r2, [r7, #14]
 8003898:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800389c:	429a      	cmp	r2, r3
 800389e:	d00e      	beq.n	80038be <USBH_Alloc_Channel+0x3e>
  {
	pdev->host.channel[hc_num] = HC_USED | ep_addr;
 80038a0:	89f8      	ldrh	r0, [r7, #14]
 80038a2:	78fb      	ldrb	r3, [r7, #3]
 80038a4:	b29b      	uxth	r3, r3
 80038a6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80038aa:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80038ae:	b29a      	uxth	r2, r3
 80038b0:	6879      	ldr	r1, [r7, #4]
 80038b2:	f500 7311 	add.w	r3, r0, #580	; 0x244
 80038b6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80038ba:	18cb      	adds	r3, r1, r3
 80038bc:	809a      	strh	r2, [r3, #4]
  }
  return hc_num;
 80038be:	89fb      	ldrh	r3, [r7, #14]
 80038c0:	b2db      	uxtb	r3, r3
}
 80038c2:	4618      	mov	r0, r3
 80038c4:	f107 0710 	add.w	r7, r7, #16
 80038c8:	46bd      	mov	sp, r7
 80038ca:	bd80      	pop	{r7, pc}

080038cc <USBH_Free_Channel>:
  *         Free the USB host channel
  * @param  idx: Channel number to be freed 
  * @retval Status
  */
uint8_t USBH_Free_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t idx)
{
 80038cc:	b480      	push	{r7}
 80038ce:	b083      	sub	sp, #12
 80038d0:	af00      	add	r7, sp, #0
 80038d2:	6078      	str	r0, [r7, #4]
 80038d4:	460b      	mov	r3, r1
 80038d6:	70fb      	strb	r3, [r7, #3]
   if(idx < HC_MAX)
 80038d8:	78fb      	ldrb	r3, [r7, #3]
 80038da:	2b07      	cmp	r3, #7
 80038dc:	d814      	bhi.n	8003908 <USBH_Free_Channel+0x3c>
   {
	 pdev->host.channel[idx] &= HC_USED_MASK;
 80038de:	78f8      	ldrb	r0, [r7, #3]
 80038e0:	78fb      	ldrb	r3, [r7, #3]
 80038e2:	687a      	ldr	r2, [r7, #4]
 80038e4:	f503 7311 	add.w	r3, r3, #580	; 0x244
 80038e8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80038ec:	18d3      	adds	r3, r2, r3
 80038ee:	889b      	ldrh	r3, [r3, #4]
 80038f0:	ea4f 4343 	mov.w	r3, r3, lsl #17
 80038f4:	ea4f 4353 	mov.w	r3, r3, lsr #17
 80038f8:	b29a      	uxth	r2, r3
 80038fa:	6879      	ldr	r1, [r7, #4]
 80038fc:	f500 7311 	add.w	r3, r0, #580	; 0x244
 8003900:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003904:	18cb      	adds	r3, r1, r3
 8003906:	809a      	strh	r2, [r3, #4]
   }
   return USBH_OK;
 8003908:	f04f 0300 	mov.w	r3, #0
}
 800390c:	4618      	mov	r0, r3
 800390e:	f107 070c 	add.w	r7, r7, #12
 8003912:	46bd      	mov	sp, r7
 8003914:	bc80      	pop	{r7}
 8003916:	4770      	bx	lr

08003918 <USBH_DeAllocate_AllChannel>:
  *         Free all USB host channel
* @param  pdev : core instance
  * @retval Status
  */
uint8_t USBH_DeAllocate_AllChannel  (USB_OTG_CORE_HANDLE *pdev)
{
 8003918:	b480      	push	{r7}
 800391a:	b085      	sub	sp, #20
 800391c:	af00      	add	r7, sp, #0
 800391e:	6078      	str	r0, [r7, #4]
   uint8_t idx;
   
   for (idx = 2; idx < HC_MAX ; idx ++)
 8003920:	f04f 0302 	mov.w	r3, #2
 8003924:	73fb      	strb	r3, [r7, #15]
 8003926:	e00d      	b.n	8003944 <USBH_DeAllocate_AllChannel+0x2c>
   {
	 pdev->host.channel[idx] = 0;
 8003928:	7bfb      	ldrb	r3, [r7, #15]
 800392a:	687a      	ldr	r2, [r7, #4]
 800392c:	f503 7311 	add.w	r3, r3, #580	; 0x244
 8003930:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003934:	18d3      	adds	r3, r2, r3
 8003936:	f04f 0200 	mov.w	r2, #0
 800393a:	809a      	strh	r2, [r3, #4]
  */
uint8_t USBH_DeAllocate_AllChannel  (USB_OTG_CORE_HANDLE *pdev)
{
   uint8_t idx;
   
   for (idx = 2; idx < HC_MAX ; idx ++)
 800393c:	7bfb      	ldrb	r3, [r7, #15]
 800393e:	f103 0301 	add.w	r3, r3, #1
 8003942:	73fb      	strb	r3, [r7, #15]
 8003944:	7bfb      	ldrb	r3, [r7, #15]
 8003946:	2b07      	cmp	r3, #7
 8003948:	d9ee      	bls.n	8003928 <USBH_DeAllocate_AllChannel+0x10>
   {
	 pdev->host.channel[idx] = 0;
   }
   return USBH_OK;
 800394a:	f04f 0300 	mov.w	r3, #0
}
 800394e:	4618      	mov	r0, r3
 8003950:	f107 0714 	add.w	r7, r7, #20
 8003954:	46bd      	mov	sp, r7
 8003956:	bc80      	pop	{r7}
 8003958:	4770      	bx	lr
 800395a:	bf00      	nop

0800395c <USBH_GetFreeChannel>:
  *         Get a free channel number for allocation to a device endpoint
  * @param  None
  * @retval idx: Free Channel number
  */
static uint16_t USBH_GetFreeChannel (USB_OTG_CORE_HANDLE *pdev)
{
 800395c:	b480      	push	{r7}
 800395e:	b085      	sub	sp, #20
 8003960:	af00      	add	r7, sp, #0
 8003962:	6078      	str	r0, [r7, #4]
  uint8_t idx = 0;
 8003964:	f04f 0300 	mov.w	r3, #0
 8003968:	73fb      	strb	r3, [r7, #15]
  
  for (idx = 0 ; idx < HC_MAX ; idx++)
 800396a:	f04f 0300 	mov.w	r3, #0
 800396e:	73fb      	strb	r3, [r7, #15]
 8003970:	e012      	b.n	8003998 <USBH_GetFreeChannel+0x3c>
  {
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 8003972:	7bfb      	ldrb	r3, [r7, #15]
 8003974:	687a      	ldr	r2, [r7, #4]
 8003976:	f503 7311 	add.w	r3, r3, #580	; 0x244
 800397a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800397e:	18d3      	adds	r3, r2, r3
 8003980:	889b      	ldrh	r3, [r3, #4]
 8003982:	b29b      	uxth	r3, r3
 8003984:	b21b      	sxth	r3, r3
 8003986:	2b00      	cmp	r3, #0
 8003988:	db02      	blt.n	8003990 <USBH_GetFreeChannel+0x34>
	{
	   return idx;
 800398a:	7bfb      	ldrb	r3, [r7, #15]
 800398c:	b29b      	uxth	r3, r3
 800398e:	e008      	b.n	80039a2 <USBH_GetFreeChannel+0x46>
  */
static uint16_t USBH_GetFreeChannel (USB_OTG_CORE_HANDLE *pdev)
{
  uint8_t idx = 0;
  
  for (idx = 0 ; idx < HC_MAX ; idx++)
 8003990:	7bfb      	ldrb	r3, [r7, #15]
 8003992:	f103 0301 	add.w	r3, r3, #1
 8003996:	73fb      	strb	r3, [r7, #15]
 8003998:	7bfb      	ldrb	r3, [r7, #15]
 800399a:	2b07      	cmp	r3, #7
 800399c:	d9e9      	bls.n	8003972 <USBH_GetFreeChannel+0x16>
	if ((pdev->host.channel[idx] & HC_USED) == 0)
	{
	   return idx;
	} 
  }
  return HC_ERROR;
 800399e:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
 80039a2:	4618      	mov	r0, r3
 80039a4:	f107 0714 	add.w	r7, r7, #20
 80039a8:	46bd      	mov	sp, r7
 80039aa:	bc80      	pop	{r7}
 80039ac:	4770      	bx	lr
 80039ae:	bf00      	nop

080039b0 <USBH_CtlReq>:
  */
USBH_Status USBH_CtlReq     (USB_OTG_CORE_HANDLE *pdev, 
                             USBH_HOST           *phost, 
                             uint8_t             *buff,
                             uint16_t            length)
{
 80039b0:	b580      	push	{r7, lr}
 80039b2:	b086      	sub	sp, #24
 80039b4:	af00      	add	r7, sp, #0
 80039b6:	60f8      	str	r0, [r7, #12]
 80039b8:	60b9      	str	r1, [r7, #8]
 80039ba:	607a      	str	r2, [r7, #4]
 80039bc:	807b      	strh	r3, [r7, #2]
  USBH_Status status;
  URB_STATE URB_Status = URB_IDLE;
 80039be:	f04f 0300 	mov.w	r3, #0
 80039c2:	75bb      	strb	r3, [r7, #22]
  
  URB_Status = HCD_GetURB_State(pdev, phost->Control.hc_num_out); 
 80039c4:	68bb      	ldr	r3, [r7, #8]
 80039c6:	795b      	ldrb	r3, [r3, #5]
 80039c8:	68f8      	ldr	r0, [r7, #12]
 80039ca:	4619      	mov	r1, r3
 80039cc:	f7fd fe4a 	bl	8001664 <HCD_GetURB_State>
 80039d0:	4603      	mov	r3, r0
 80039d2:	75bb      	strb	r3, [r7, #22]
  
  status = USBH_BUSY;
 80039d4:	f04f 0301 	mov.w	r3, #1
 80039d8:	75fb      	strb	r3, [r7, #23]
  
  switch (phost->RequestState)
 80039da:	68bb      	ldr	r3, [r7, #8]
 80039dc:	78db      	ldrb	r3, [r3, #3]
 80039de:	2b01      	cmp	r3, #1
 80039e0:	d002      	beq.n	80039e8 <USBH_CtlReq+0x38>
 80039e2:	2b02      	cmp	r3, #2
 80039e4:	d00e      	beq.n	8003a04 <USBH_CtlReq+0x54>
 80039e6:	e02e      	b.n	8003a46 <USBH_CtlReq+0x96>
  {
  case CMD_SEND:
    /* Start a SETUP transfer */
    USBH_SubmitSetupRequest(phost, buff, length);
 80039e8:	887b      	ldrh	r3, [r7, #2]
 80039ea:	68b8      	ldr	r0, [r7, #8]
 80039ec:	6879      	ldr	r1, [r7, #4]
 80039ee:	461a      	mov	r2, r3
 80039f0:	f000 fa88 	bl	8003f04 <USBH_SubmitSetupRequest>
    phost->RequestState = CMD_WAIT;
 80039f4:	68bb      	ldr	r3, [r7, #8]
 80039f6:	f04f 0202 	mov.w	r2, #2
 80039fa:	70da      	strb	r2, [r3, #3]
    status = USBH_BUSY;
 80039fc:	f04f 0301 	mov.w	r3, #1
 8003a00:	75fb      	strb	r3, [r7, #23]
    break;
 8003a02:	e022      	b.n	8003a4a <USBH_CtlReq+0x9a>
    
  case CMD_WAIT:
    if  (URB_Status == URB_DONE)
 8003a04:	7dbb      	ldrb	r3, [r7, #22]
 8003a06:	2b01      	cmp	r3, #1
 8003a08:	d107      	bne.n	8003a1a <USBH_CtlReq+0x6a>
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
 8003a0a:	68bb      	ldr	r3, [r7, #8]
 8003a0c:	f04f 0201 	mov.w	r2, #1
 8003a10:	70da      	strb	r2, [r3, #3]
      status = USBH_OK;
 8003a12:	f04f 0300 	mov.w	r3, #0
 8003a16:	75fb      	strb	r3, [r7, #23]
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
      status = USBH_NOT_SUPPORTED;
    }
    break;
 8003a18:	e016      	b.n	8003a48 <USBH_CtlReq+0x98>
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
      status = USBH_OK;
    }
    else if  (URB_Status == URB_ERROR)
 8003a1a:	7dbb      	ldrb	r3, [r7, #22]
 8003a1c:	2b03      	cmp	r3, #3
 8003a1e:	d107      	bne.n	8003a30 <USBH_CtlReq+0x80>
    {
      /* Failure Mode */
      phost->RequestState = CMD_SEND;
 8003a20:	68bb      	ldr	r3, [r7, #8]
 8003a22:	f04f 0201 	mov.w	r2, #1
 8003a26:	70da      	strb	r2, [r3, #3]
      status = USBH_FAIL;
 8003a28:	f04f 0302 	mov.w	r3, #2
 8003a2c:	75fb      	strb	r3, [r7, #23]
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
      status = USBH_NOT_SUPPORTED;
    }
    break;
 8003a2e:	e00b      	b.n	8003a48 <USBH_CtlReq+0x98>
    {
      /* Failure Mode */
      phost->RequestState = CMD_SEND;
      status = USBH_FAIL;
    }   
     else if  (URB_Status == URB_STALL)
 8003a30:	7dbb      	ldrb	r3, [r7, #22]
 8003a32:	2b04      	cmp	r3, #4
 8003a34:	d108      	bne.n	8003a48 <USBH_CtlReq+0x98>
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
 8003a36:	68bb      	ldr	r3, [r7, #8]
 8003a38:	f04f 0201 	mov.w	r2, #1
 8003a3c:	70da      	strb	r2, [r3, #3]
      status = USBH_NOT_SUPPORTED;
 8003a3e:	f04f 0303 	mov.w	r3, #3
 8003a42:	75fb      	strb	r3, [r7, #23]
    }
    break;
 8003a44:	e000      	b.n	8003a48 <USBH_CtlReq+0x98>
    
  default:
    break; 
 8003a46:	e000      	b.n	8003a4a <USBH_CtlReq+0x9a>
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
      status = USBH_NOT_SUPPORTED;
    }
    break;
 8003a48:	bf00      	nop
    
  default:
    break; 
  }
  return status;
 8003a4a:	7dfb      	ldrb	r3, [r7, #23]
}
 8003a4c:	4618      	mov	r0, r3
 8003a4e:	f107 0718 	add.w	r7, r7, #24
 8003a52:	46bd      	mov	sp, r7
 8003a54:	bd80      	pop	{r7, pc}
 8003a56:	bf00      	nop

08003a58 <USBH_CtlSendSetup>:
  * @param  hc_num: Host channel Number
  * @retval Status
  */
USBH_Status USBH_CtlSendSetup ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t hc_num){
 8003a58:	b580      	push	{r7, lr}
 8003a5a:	b084      	sub	sp, #16
 8003a5c:	af00      	add	r7, sp, #0
 8003a5e:	60f8      	str	r0, [r7, #12]
 8003a60:	60b9      	str	r1, [r7, #8]
 8003a62:	4613      	mov	r3, r2
 8003a64:	71fb      	strb	r3, [r7, #7]
  pdev->host.hc[hc_num].ep_is_in = 0;
 8003a66:	79fb      	ldrb	r3, [r7, #7]
 8003a68:	68fa      	ldr	r2, [r7, #12]
 8003a6a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003a6e:	18d3      	adds	r3, r2, r3
 8003a70:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003a74:	f04f 0200 	mov.w	r2, #0
 8003a78:	719a      	strb	r2, [r3, #6]
  pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
 8003a7a:	79fb      	ldrb	r3, [r7, #7]
 8003a7c:	68fa      	ldr	r2, [r7, #12]
 8003a7e:	f103 030d 	add.w	r3, r3, #13
 8003a82:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003a86:	18d3      	adds	r3, r2, r3
 8003a88:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003a8c:	f04f 0203 	mov.w	r2, #3
 8003a90:	711a      	strb	r2, [r3, #4]
  pdev->host.hc[hc_num].xfer_buff = buff;
 8003a92:	79fb      	ldrb	r3, [r7, #7]
 8003a94:	68fa      	ldr	r2, [r7, #12]
 8003a96:	f103 030d 	add.w	r3, r3, #13
 8003a9a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003a9e:	18d3      	adds	r3, r2, r3
 8003aa0:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8003aa4:	68ba      	ldr	r2, [r7, #8]
 8003aa6:	601a      	str	r2, [r3, #0]
  pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   
 8003aa8:	79fb      	ldrb	r3, [r7, #7]
 8003aaa:	68fa      	ldr	r2, [r7, #12]
 8003aac:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003ab0:	18d3      	adds	r3, r2, r3
 8003ab2:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8003ab6:	f04f 0208 	mov.w	r2, #8
 8003aba:	601a      	str	r2, [r3, #0]

  return (USBH_Status)HCD_SubmitRequest (pdev , hc_num);   
 8003abc:	79fb      	ldrb	r3, [r7, #7]
 8003abe:	68f8      	ldr	r0, [r7, #12]
 8003ac0:	4619      	mov	r1, r3
 8003ac2:	f7fd fe17 	bl	80016f4 <HCD_SubmitRequest>
 8003ac6:	4603      	mov	r3, r0
 8003ac8:	b2db      	uxtb	r3, r3
}
 8003aca:	4618      	mov	r0, r3
 8003acc:	f107 0710 	add.w	r7, r7, #16
 8003ad0:	46bd      	mov	sp, r7
 8003ad2:	bd80      	pop	{r7, pc}

08003ad4 <USBH_CtlSendData>:
  */
USBH_Status USBH_CtlSendData ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t length,
                                uint8_t hc_num)
{
 8003ad4:	b580      	push	{r7, lr}
 8003ad6:	b084      	sub	sp, #16
 8003ad8:	af00      	add	r7, sp, #0
 8003ada:	60f8      	str	r0, [r7, #12]
 8003adc:	60b9      	str	r1, [r7, #8]
 8003ade:	71fa      	strb	r2, [r7, #7]
 8003ae0:	71bb      	strb	r3, [r7, #6]
  pdev->host.hc[hc_num].ep_is_in = 0;
 8003ae2:	79bb      	ldrb	r3, [r7, #6]
 8003ae4:	68fa      	ldr	r2, [r7, #12]
 8003ae6:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003aea:	18d3      	adds	r3, r2, r3
 8003aec:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003af0:	f04f 0200 	mov.w	r2, #0
 8003af4:	719a      	strb	r2, [r3, #6]
  pdev->host.hc[hc_num].xfer_buff = buff;
 8003af6:	79bb      	ldrb	r3, [r7, #6]
 8003af8:	68fa      	ldr	r2, [r7, #12]
 8003afa:	f103 030d 	add.w	r3, r3, #13
 8003afe:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003b02:	18d3      	adds	r3, r2, r3
 8003b04:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8003b08:	68ba      	ldr	r2, [r7, #8]
 8003b0a:	601a      	str	r2, [r3, #0]
  pdev->host.hc[hc_num].xfer_len = length;
 8003b0c:	79bb      	ldrb	r3, [r7, #6]
 8003b0e:	79fa      	ldrb	r2, [r7, #7]
 8003b10:	68f9      	ldr	r1, [r7, #12]
 8003b12:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003b16:	18cb      	adds	r3, r1, r3
 8003b18:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8003b1c:	601a      	str	r2, [r3, #0]
 
  if ( length == 0 )
 8003b1e:	79fb      	ldrb	r3, [r7, #7]
 8003b20:	2b00      	cmp	r3, #0
 8003b22:	d109      	bne.n	8003b38 <USBH_CtlSendData+0x64>
  { /* For Status OUT stage, Length==0, Status Out PID = 1 */
    pdev->host.hc[hc_num].toggle_out = 1;   
 8003b24:	79bb      	ldrb	r3, [r7, #6]
 8003b26:	68fa      	ldr	r2, [r7, #12]
 8003b28:	f103 0316 	add.w	r3, r3, #22
 8003b2c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003b30:	18d3      	adds	r3, r2, r3
 8003b32:	f04f 0201 	mov.w	r2, #1
 8003b36:	715a      	strb	r2, [r3, #5]
  }
 
 /* Set the Data Toggle bit as per the Flag */
  if ( pdev->host.hc[hc_num].toggle_out == 0)
 8003b38:	79bb      	ldrb	r3, [r7, #6]
 8003b3a:	68fa      	ldr	r2, [r7, #12]
 8003b3c:	f103 0316 	add.w	r3, r3, #22
 8003b40:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003b44:	18d3      	adds	r3, r2, r3
 8003b46:	795b      	ldrb	r3, [r3, #5]
 8003b48:	2b00      	cmp	r3, #0
 8003b4a:	d10c      	bne.n	8003b66 <USBH_CtlSendData+0x92>
  { /* Put the PID 0 */
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
 8003b4c:	79bb      	ldrb	r3, [r7, #6]
 8003b4e:	68fa      	ldr	r2, [r7, #12]
 8003b50:	f103 030d 	add.w	r3, r3, #13
 8003b54:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003b58:	18d3      	adds	r3, r2, r3
 8003b5a:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003b5e:	f04f 0200 	mov.w	r2, #0
 8003b62:	711a      	strb	r2, [r3, #4]
 8003b64:	e00b      	b.n	8003b7e <USBH_CtlSendData+0xaa>
  }
 else
 { /* Put the PID 1 */
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
 8003b66:	79bb      	ldrb	r3, [r7, #6]
 8003b68:	68fa      	ldr	r2, [r7, #12]
 8003b6a:	f103 030d 	add.w	r3, r3, #13
 8003b6e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003b72:	18d3      	adds	r3, r2, r3
 8003b74:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003b78:	f04f 0202 	mov.w	r2, #2
 8003b7c:	711a      	strb	r2, [r3, #4]
 }

  HCD_SubmitRequest (pdev , hc_num);   
 8003b7e:	79bb      	ldrb	r3, [r7, #6]
 8003b80:	68f8      	ldr	r0, [r7, #12]
 8003b82:	4619      	mov	r1, r3
 8003b84:	f7fd fdb6 	bl	80016f4 <HCD_SubmitRequest>
   
  return USBH_OK;
 8003b88:	f04f 0300 	mov.w	r3, #0
}
 8003b8c:	4618      	mov	r0, r3
 8003b8e:	f107 0710 	add.w	r7, r7, #16
 8003b92:	46bd      	mov	sp, r7
 8003b94:	bd80      	pop	{r7, pc}
 8003b96:	bf00      	nop

08003b98 <USBH_CtlReceiveData>:
  */
USBH_Status USBH_CtlReceiveData(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t* buff, 
                                uint8_t length,
                                uint8_t hc_num)
{
 8003b98:	b580      	push	{r7, lr}
 8003b9a:	b084      	sub	sp, #16
 8003b9c:	af00      	add	r7, sp, #0
 8003b9e:	60f8      	str	r0, [r7, #12]
 8003ba0:	60b9      	str	r1, [r7, #8]
 8003ba2:	71fa      	strb	r2, [r7, #7]
 8003ba4:	71bb      	strb	r3, [r7, #6]

  pdev->host.hc[hc_num].ep_is_in = 1;
 8003ba6:	79bb      	ldrb	r3, [r7, #6]
 8003ba8:	68fa      	ldr	r2, [r7, #12]
 8003baa:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003bae:	18d3      	adds	r3, r2, r3
 8003bb0:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003bb4:	f04f 0201 	mov.w	r2, #1
 8003bb8:	719a      	strb	r2, [r3, #6]
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8003bba:	79bb      	ldrb	r3, [r7, #6]
 8003bbc:	68fa      	ldr	r2, [r7, #12]
 8003bbe:	f103 030d 	add.w	r3, r3, #13
 8003bc2:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003bc6:	18d3      	adds	r3, r2, r3
 8003bc8:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003bcc:	f04f 0202 	mov.w	r2, #2
 8003bd0:	711a      	strb	r2, [r3, #4]
  pdev->host.hc[hc_num].xfer_buff = buff;
 8003bd2:	79bb      	ldrb	r3, [r7, #6]
 8003bd4:	68fa      	ldr	r2, [r7, #12]
 8003bd6:	f103 030d 	add.w	r3, r3, #13
 8003bda:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003bde:	18d3      	adds	r3, r2, r3
 8003be0:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8003be4:	68ba      	ldr	r2, [r7, #8]
 8003be6:	601a      	str	r2, [r3, #0]
  pdev->host.hc[hc_num].xfer_len = length;  
 8003be8:	79bb      	ldrb	r3, [r7, #6]
 8003bea:	79fa      	ldrb	r2, [r7, #7]
 8003bec:	68f9      	ldr	r1, [r7, #12]
 8003bee:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003bf2:	18cb      	adds	r3, r1, r3
 8003bf4:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8003bf8:	601a      	str	r2, [r3, #0]

  HCD_SubmitRequest (pdev , hc_num);   
 8003bfa:	79bb      	ldrb	r3, [r7, #6]
 8003bfc:	68f8      	ldr	r0, [r7, #12]
 8003bfe:	4619      	mov	r1, r3
 8003c00:	f7fd fd78 	bl	80016f4 <HCD_SubmitRequest>
  
  return USBH_OK;
 8003c04:	f04f 0300 	mov.w	r3, #0
  
}
 8003c08:	4618      	mov	r0, r3
 8003c0a:	f107 0710 	add.w	r7, r7, #16
 8003c0e:	46bd      	mov	sp, r7
 8003c10:	bd80      	pop	{r7, pc}
 8003c12:	bf00      	nop

08003c14 <USBH_BulkSendData>:
  */
USBH_Status USBH_BulkSendData ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint16_t length,
                                uint8_t hc_num)
{ 
 8003c14:	b580      	push	{r7, lr}
 8003c16:	b084      	sub	sp, #16
 8003c18:	af00      	add	r7, sp, #0
 8003c1a:	60f8      	str	r0, [r7, #12]
 8003c1c:	60b9      	str	r1, [r7, #8]
 8003c1e:	80fa      	strh	r2, [r7, #6]
 8003c20:	717b      	strb	r3, [r7, #5]
  pdev->host.hc[hc_num].ep_is_in = 0;
 8003c22:	797b      	ldrb	r3, [r7, #5]
 8003c24:	68fa      	ldr	r2, [r7, #12]
 8003c26:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003c2a:	18d3      	adds	r3, r2, r3
 8003c2c:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003c30:	f04f 0200 	mov.w	r2, #0
 8003c34:	719a      	strb	r2, [r3, #6]
  pdev->host.hc[hc_num].xfer_buff = buff;
 8003c36:	797b      	ldrb	r3, [r7, #5]
 8003c38:	68fa      	ldr	r2, [r7, #12]
 8003c3a:	f103 030d 	add.w	r3, r3, #13
 8003c3e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003c42:	18d3      	adds	r3, r2, r3
 8003c44:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8003c48:	68ba      	ldr	r2, [r7, #8]
 8003c4a:	601a      	str	r2, [r3, #0]
  pdev->host.hc[hc_num].xfer_len = length;  
 8003c4c:	797b      	ldrb	r3, [r7, #5]
 8003c4e:	88fa      	ldrh	r2, [r7, #6]
 8003c50:	68f9      	ldr	r1, [r7, #12]
 8003c52:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003c56:	18cb      	adds	r3, r1, r3
 8003c58:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8003c5c:	601a      	str	r2, [r3, #0]

 /* Set the Data Toggle bit as per the Flag */
  if ( pdev->host.hc[hc_num].toggle_out == 0)
 8003c5e:	797b      	ldrb	r3, [r7, #5]
 8003c60:	68fa      	ldr	r2, [r7, #12]
 8003c62:	f103 0316 	add.w	r3, r3, #22
 8003c66:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003c6a:	18d3      	adds	r3, r2, r3
 8003c6c:	795b      	ldrb	r3, [r3, #5]
 8003c6e:	2b00      	cmp	r3, #0
 8003c70:	d10c      	bne.n	8003c8c <USBH_BulkSendData+0x78>
  { /* Put the PID 0 */
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
 8003c72:	797b      	ldrb	r3, [r7, #5]
 8003c74:	68fa      	ldr	r2, [r7, #12]
 8003c76:	f103 030d 	add.w	r3, r3, #13
 8003c7a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003c7e:	18d3      	adds	r3, r2, r3
 8003c80:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003c84:	f04f 0200 	mov.w	r2, #0
 8003c88:	711a      	strb	r2, [r3, #4]
 8003c8a:	e00b      	b.n	8003ca4 <USBH_BulkSendData+0x90>
  }
 else
 { /* Put the PID 1 */
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
 8003c8c:	797b      	ldrb	r3, [r7, #5]
 8003c8e:	68fa      	ldr	r2, [r7, #12]
 8003c90:	f103 030d 	add.w	r3, r3, #13
 8003c94:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003c98:	18d3      	adds	r3, r2, r3
 8003c9a:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003c9e:	f04f 0202 	mov.w	r2, #2
 8003ca2:	711a      	strb	r2, [r3, #4]
 }

  HCD_SubmitRequest (pdev , hc_num);   
 8003ca4:	797b      	ldrb	r3, [r7, #5]
 8003ca6:	68f8      	ldr	r0, [r7, #12]
 8003ca8:	4619      	mov	r1, r3
 8003caa:	f7fd fd23 	bl	80016f4 <HCD_SubmitRequest>
  return USBH_OK;
 8003cae:	f04f 0300 	mov.w	r3, #0
}
 8003cb2:	4618      	mov	r0, r3
 8003cb4:	f107 0710 	add.w	r7, r7, #16
 8003cb8:	46bd      	mov	sp, r7
 8003cba:	bd80      	pop	{r7, pc}

08003cbc <USBH_BulkReceiveData>:
  */
USBH_Status USBH_BulkReceiveData( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint16_t length,
                                uint8_t hc_num)
{
 8003cbc:	b580      	push	{r7, lr}
 8003cbe:	b084      	sub	sp, #16
 8003cc0:	af00      	add	r7, sp, #0
 8003cc2:	60f8      	str	r0, [r7, #12]
 8003cc4:	60b9      	str	r1, [r7, #8]
 8003cc6:	80fa      	strh	r2, [r7, #6]
 8003cc8:	717b      	strb	r3, [r7, #5]
  pdev->host.hc[hc_num].ep_is_in = 1;   
 8003cca:	797b      	ldrb	r3, [r7, #5]
 8003ccc:	68fa      	ldr	r2, [r7, #12]
 8003cce:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003cd2:	18d3      	adds	r3, r2, r3
 8003cd4:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003cd8:	f04f 0201 	mov.w	r2, #1
 8003cdc:	719a      	strb	r2, [r3, #6]
  pdev->host.hc[hc_num].xfer_buff = buff;
 8003cde:	797b      	ldrb	r3, [r7, #5]
 8003ce0:	68fa      	ldr	r2, [r7, #12]
 8003ce2:	f103 030d 	add.w	r3, r3, #13
 8003ce6:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003cea:	18d3      	adds	r3, r2, r3
 8003cec:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8003cf0:	68ba      	ldr	r2, [r7, #8]
 8003cf2:	601a      	str	r2, [r3, #0]
  pdev->host.hc[hc_num].xfer_len = length;
 8003cf4:	797b      	ldrb	r3, [r7, #5]
 8003cf6:	88fa      	ldrh	r2, [r7, #6]
 8003cf8:	68f9      	ldr	r1, [r7, #12]
 8003cfa:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003cfe:	18cb      	adds	r3, r1, r3
 8003d00:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8003d04:	601a      	str	r2, [r3, #0]
  

  if( pdev->host.hc[hc_num].toggle_in == 0)
 8003d06:	797b      	ldrb	r3, [r7, #5]
 8003d08:	68fa      	ldr	r2, [r7, #12]
 8003d0a:	f103 0316 	add.w	r3, r3, #22
 8003d0e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003d12:	18d3      	adds	r3, r2, r3
 8003d14:	791b      	ldrb	r3, [r3, #4]
 8003d16:	2b00      	cmp	r3, #0
 8003d18:	d10c      	bne.n	8003d34 <USBH_BulkReceiveData+0x78>
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
 8003d1a:	797b      	ldrb	r3, [r7, #5]
 8003d1c:	68fa      	ldr	r2, [r7, #12]
 8003d1e:	f103 030d 	add.w	r3, r3, #13
 8003d22:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003d26:	18d3      	adds	r3, r2, r3
 8003d28:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003d2c:	f04f 0200 	mov.w	r2, #0
 8003d30:	711a      	strb	r2, [r3, #4]
 8003d32:	e00b      	b.n	8003d4c <USBH_BulkReceiveData+0x90>
  }
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8003d34:	797b      	ldrb	r3, [r7, #5]
 8003d36:	68fa      	ldr	r2, [r7, #12]
 8003d38:	f103 030d 	add.w	r3, r3, #13
 8003d3c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003d40:	18d3      	adds	r3, r2, r3
 8003d42:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003d46:	f04f 0202 	mov.w	r2, #2
 8003d4a:	711a      	strb	r2, [r3, #4]
  }

  HCD_SubmitRequest (pdev , hc_num);  
 8003d4c:	797b      	ldrb	r3, [r7, #5]
 8003d4e:	68f8      	ldr	r0, [r7, #12]
 8003d50:	4619      	mov	r1, r3
 8003d52:	f7fd fccf 	bl	80016f4 <HCD_SubmitRequest>
  return USBH_OK;
 8003d56:	f04f 0300 	mov.w	r3, #0
}
 8003d5a:	4618      	mov	r0, r3
 8003d5c:	f107 0710 	add.w	r7, r7, #16
 8003d60:	46bd      	mov	sp, r7
 8003d62:	bd80      	pop	{r7, pc}

08003d64 <USBH_InterruptReceiveData>:
  */
USBH_Status USBH_InterruptReceiveData( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t length,
                                uint8_t hc_num)
{
 8003d64:	b580      	push	{r7, lr}
 8003d66:	b084      	sub	sp, #16
 8003d68:	af00      	add	r7, sp, #0
 8003d6a:	60f8      	str	r0, [r7, #12]
 8003d6c:	60b9      	str	r1, [r7, #8]
 8003d6e:	71fa      	strb	r2, [r7, #7]
 8003d70:	71bb      	strb	r3, [r7, #6]

  pdev->host.hc[hc_num].ep_is_in = 1;  
 8003d72:	79bb      	ldrb	r3, [r7, #6]
 8003d74:	68fa      	ldr	r2, [r7, #12]
 8003d76:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003d7a:	18d3      	adds	r3, r2, r3
 8003d7c:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003d80:	f04f 0201 	mov.w	r2, #1
 8003d84:	719a      	strb	r2, [r3, #6]
  pdev->host.hc[hc_num].xfer_buff = buff;
 8003d86:	79bb      	ldrb	r3, [r7, #6]
 8003d88:	68fa      	ldr	r2, [r7, #12]
 8003d8a:	f103 030d 	add.w	r3, r3, #13
 8003d8e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003d92:	18d3      	adds	r3, r2, r3
 8003d94:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8003d98:	68ba      	ldr	r2, [r7, #8]
 8003d9a:	601a      	str	r2, [r3, #0]
  pdev->host.hc[hc_num].xfer_len = length;
 8003d9c:	79bb      	ldrb	r3, [r7, #6]
 8003d9e:	79fa      	ldrb	r2, [r7, #7]
 8003da0:	68f9      	ldr	r1, [r7, #12]
 8003da2:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003da6:	18cb      	adds	r3, r1, r3
 8003da8:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8003dac:	601a      	str	r2, [r3, #0]
  

  
  if(pdev->host.hc[hc_num].toggle_in == 0)
 8003dae:	79bb      	ldrb	r3, [r7, #6]
 8003db0:	68fa      	ldr	r2, [r7, #12]
 8003db2:	f103 0316 	add.w	r3, r3, #22
 8003db6:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003dba:	18d3      	adds	r3, r2, r3
 8003dbc:	791b      	ldrb	r3, [r3, #4]
 8003dbe:	2b00      	cmp	r3, #0
 8003dc0:	d10c      	bne.n	8003ddc <USBH_InterruptReceiveData+0x78>
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
 8003dc2:	79bb      	ldrb	r3, [r7, #6]
 8003dc4:	68fa      	ldr	r2, [r7, #12]
 8003dc6:	f103 030d 	add.w	r3, r3, #13
 8003dca:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003dce:	18d3      	adds	r3, r2, r3
 8003dd0:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003dd4:	f04f 0200 	mov.w	r2, #0
 8003dd8:	711a      	strb	r2, [r3, #4]
 8003dda:	e00b      	b.n	8003df4 <USBH_InterruptReceiveData+0x90>
  }
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8003ddc:	79bb      	ldrb	r3, [r7, #6]
 8003dde:	68fa      	ldr	r2, [r7, #12]
 8003de0:	f103 030d 	add.w	r3, r3, #13
 8003de4:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003de8:	18d3      	adds	r3, r2, r3
 8003dea:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003dee:	f04f 0202 	mov.w	r2, #2
 8003df2:	711a      	strb	r2, [r3, #4]
  }

  /* toggle DATA PID */
  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8003df4:	79bb      	ldrb	r3, [r7, #6]
 8003df6:	79ba      	ldrb	r2, [r7, #6]
 8003df8:	68f9      	ldr	r1, [r7, #12]
 8003dfa:	f102 0216 	add.w	r2, r2, #22
 8003dfe:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8003e02:	188a      	adds	r2, r1, r2
 8003e04:	7912      	ldrb	r2, [r2, #4]
 8003e06:	f082 0201 	eor.w	r2, r2, #1
 8003e0a:	b2d2      	uxtb	r2, r2
 8003e0c:	68f9      	ldr	r1, [r7, #12]
 8003e0e:	f103 0316 	add.w	r3, r3, #22
 8003e12:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003e16:	18cb      	adds	r3, r1, r3
 8003e18:	711a      	strb	r2, [r3, #4]
  
  HCD_SubmitRequest (pdev , hc_num);  
 8003e1a:	79bb      	ldrb	r3, [r7, #6]
 8003e1c:	68f8      	ldr	r0, [r7, #12]
 8003e1e:	4619      	mov	r1, r3
 8003e20:	f7fd fc68 	bl	80016f4 <HCD_SubmitRequest>
  
  return USBH_OK;
 8003e24:	f04f 0300 	mov.w	r3, #0
}
 8003e28:	4618      	mov	r0, r3
 8003e2a:	f107 0710 	add.w	r7, r7, #16
 8003e2e:	46bd      	mov	sp, r7
 8003e30:	bd80      	pop	{r7, pc}
 8003e32:	bf00      	nop

08003e34 <USBH_InterruptSendData>:
  */
USBH_Status USBH_InterruptSendData( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t length,
                                uint8_t hc_num)
{
 8003e34:	b580      	push	{r7, lr}
 8003e36:	b084      	sub	sp, #16
 8003e38:	af00      	add	r7, sp, #0
 8003e3a:	60f8      	str	r0, [r7, #12]
 8003e3c:	60b9      	str	r1, [r7, #8]
 8003e3e:	71fa      	strb	r2, [r7, #7]
 8003e40:	71bb      	strb	r3, [r7, #6]

  pdev->host.hc[hc_num].ep_is_in = 0;  
 8003e42:	79bb      	ldrb	r3, [r7, #6]
 8003e44:	68fa      	ldr	r2, [r7, #12]
 8003e46:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003e4a:	18d3      	adds	r3, r2, r3
 8003e4c:	f503 732a 	add.w	r3, r3, #680	; 0x2a8
 8003e50:	f04f 0200 	mov.w	r2, #0
 8003e54:	719a      	strb	r2, [r3, #6]
  pdev->host.hc[hc_num].xfer_buff = buff;
 8003e56:	79bb      	ldrb	r3, [r7, #6]
 8003e58:	68fa      	ldr	r2, [r7, #12]
 8003e5a:	f103 030d 	add.w	r3, r3, #13
 8003e5e:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003e62:	18d3      	adds	r3, r2, r3
 8003e64:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8003e68:	68ba      	ldr	r2, [r7, #8]
 8003e6a:	601a      	str	r2, [r3, #0]
  pdev->host.hc[hc_num].xfer_len = length;
 8003e6c:	79bb      	ldrb	r3, [r7, #6]
 8003e6e:	79fa      	ldrb	r2, [r7, #7]
 8003e70:	68f9      	ldr	r1, [r7, #12]
 8003e72:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003e76:	18cb      	adds	r3, r1, r3
 8003e78:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8003e7c:	601a      	str	r2, [r3, #0]
  
  if(pdev->host.hc[hc_num].toggle_in == 0)
 8003e7e:	79bb      	ldrb	r3, [r7, #6]
 8003e80:	68fa      	ldr	r2, [r7, #12]
 8003e82:	f103 0316 	add.w	r3, r3, #22
 8003e86:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003e8a:	18d3      	adds	r3, r2, r3
 8003e8c:	791b      	ldrb	r3, [r3, #4]
 8003e8e:	2b00      	cmp	r3, #0
 8003e90:	d10c      	bne.n	8003eac <USBH_InterruptSendData+0x78>
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
 8003e92:	79bb      	ldrb	r3, [r7, #6]
 8003e94:	68fa      	ldr	r2, [r7, #12]
 8003e96:	f103 030d 	add.w	r3, r3, #13
 8003e9a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003e9e:	18d3      	adds	r3, r2, r3
 8003ea0:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003ea4:	f04f 0200 	mov.w	r2, #0
 8003ea8:	711a      	strb	r2, [r3, #4]
 8003eaa:	e00b      	b.n	8003ec4 <USBH_InterruptSendData+0x90>
  }
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8003eac:	79bb      	ldrb	r3, [r7, #6]
 8003eae:	68fa      	ldr	r2, [r7, #12]
 8003eb0:	f103 030d 	add.w	r3, r3, #13
 8003eb4:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003eb8:	18d3      	adds	r3, r2, r3
 8003eba:	f503 7388 	add.w	r3, r3, #272	; 0x110
 8003ebe:	f04f 0202 	mov.w	r2, #2
 8003ec2:	711a      	strb	r2, [r3, #4]
  }

  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8003ec4:	79bb      	ldrb	r3, [r7, #6]
 8003ec6:	79ba      	ldrb	r2, [r7, #6]
 8003ec8:	68f9      	ldr	r1, [r7, #12]
 8003eca:	f102 0216 	add.w	r2, r2, #22
 8003ece:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8003ed2:	188a      	adds	r2, r1, r2
 8003ed4:	7912      	ldrb	r2, [r2, #4]
 8003ed6:	f082 0201 	eor.w	r2, r2, #1
 8003eda:	b2d2      	uxtb	r2, r2
 8003edc:	68f9      	ldr	r1, [r7, #12]
 8003ede:	f103 0316 	add.w	r3, r3, #22
 8003ee2:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8003ee6:	18cb      	adds	r3, r1, r3
 8003ee8:	711a      	strb	r2, [r3, #4]
  
  HCD_SubmitRequest (pdev , hc_num);  
 8003eea:	79bb      	ldrb	r3, [r7, #6]
 8003eec:	68f8      	ldr	r0, [r7, #12]
 8003eee:	4619      	mov	r1, r3
 8003ef0:	f7fd fc00 	bl	80016f4 <HCD_SubmitRequest>
  
  return USBH_OK;
 8003ef4:	f04f 0300 	mov.w	r3, #0
}
 8003ef8:	4618      	mov	r0, r3
 8003efa:	f107 0710 	add.w	r7, r7, #16
 8003efe:	46bd      	mov	sp, r7
 8003f00:	bd80      	pop	{r7, pc}
 8003f02:	bf00      	nop

08003f04 <USBH_SubmitSetupRequest>:
  * @retval Status. 
*/
static USBH_Status USBH_SubmitSetupRequest(USBH_HOST *phost,
                                           uint8_t* buff, 
                                           uint16_t length)
{
 8003f04:	b480      	push	{r7}
 8003f06:	b085      	sub	sp, #20
 8003f08:	af00      	add	r7, sp, #0
 8003f0a:	60f8      	str	r0, [r7, #12]
 8003f0c:	60b9      	str	r1, [r7, #8]
 8003f0e:	4613      	mov	r3, r2
 8003f10:	80fb      	strh	r3, [r7, #6]
  
  /* Save Global State */
  phost->gStateBkp =   phost->gState; 
 8003f12:	68fb      	ldr	r3, [r7, #12]
 8003f14:	781a      	ldrb	r2, [r3, #0]
 8003f16:	68fb      	ldr	r3, [r7, #12]
 8003f18:	705a      	strb	r2, [r3, #1]
  
  /* Prepare the Transactions */
  phost->gState = HOST_CTRL_XFER;
 8003f1a:	68fb      	ldr	r3, [r7, #12]
 8003f1c:	f04f 0209 	mov.w	r2, #9
 8003f20:	701a      	strb	r2, [r3, #0]
  phost->Control.buff = buff; 
 8003f22:	68fb      	ldr	r3, [r7, #12]
 8003f24:	68ba      	ldr	r2, [r7, #8]
 8003f26:	609a      	str	r2, [r3, #8]
  phost->Control.length = length;
 8003f28:	68fb      	ldr	r3, [r7, #12]
 8003f2a:	88fa      	ldrh	r2, [r7, #6]
 8003f2c:	819a      	strh	r2, [r3, #12]
  phost->Control.state = CTRL_SETUP;  
 8003f2e:	68fb      	ldr	r3, [r7, #12]
 8003f30:	f04f 0201 	mov.w	r2, #1
 8003f34:	771a      	strb	r2, [r3, #28]

  return USBH_OK;  
 8003f36:	f04f 0300 	mov.w	r3, #0
}
 8003f3a:	4618      	mov	r0, r3
 8003f3c:	f107 0714 	add.w	r7, r7, #20
 8003f40:	46bd      	mov	sp, r7
 8003f42:	bc80      	pop	{r7}
 8003f44:	4770      	bx	lr
 8003f46:	bf00      	nop

08003f48 <USBH_Get_DevDesc>:
* @retval Status
*/
USBH_Status USBH_Get_DevDesc(USB_OTG_CORE_HANDLE *pdev,
                             USBH_HOST *phost,
                             uint8_t length)
{
 8003f48:	b580      	push	{r7, lr}
 8003f4a:	b088      	sub	sp, #32
 8003f4c:	af02      	add	r7, sp, #8
 8003f4e:	60f8      	str	r0, [r7, #12]
 8003f50:	60b9      	str	r1, [r7, #8]
 8003f52:	4613      	mov	r3, r2
 8003f54:	71fb      	strb	r3, [r7, #7]
  
  if((status = USBH_GetDescriptor(pdev, 
                                  phost,
                                  USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
                                  USB_DESC_DEVICE, 
                                  pdev->host.Rx_Buffer,
 8003f56:	68fb      	ldr	r3, [r7, #12]
 8003f58:	f503 7288 	add.w	r2, r3, #272	; 0x110
                             uint8_t length)
{
  
  USBH_Status status;
  
  if((status = USBH_GetDescriptor(pdev, 
 8003f5c:	79fb      	ldrb	r3, [r7, #7]
 8003f5e:	b29b      	uxth	r3, r3
 8003f60:	9200      	str	r2, [sp, #0]
 8003f62:	9301      	str	r3, [sp, #4]
 8003f64:	68f8      	ldr	r0, [r7, #12]
 8003f66:	68b9      	ldr	r1, [r7, #8]
 8003f68:	f04f 0200 	mov.w	r2, #0
 8003f6c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003f70:	f000 f876 	bl	8004060 <USBH_GetDescriptor>
 8003f74:	4603      	mov	r3, r0
 8003f76:	75fb      	strb	r3, [r7, #23]
 8003f78:	7dfb      	ldrb	r3, [r7, #23]
 8003f7a:	2b00      	cmp	r3, #0
 8003f7c:	d10c      	bne.n	8003f98 <USBH_Get_DevDesc+0x50>
                                  USB_DESC_DEVICE, 
                                  pdev->host.Rx_Buffer,
                                  length)) == USBH_OK)
  {
    /* Commands successfully sent and Response Received */       
    USBH_ParseDevDesc(&phost->device_prop.Dev_Desc, pdev->host.Rx_Buffer, length);
 8003f7e:	68bb      	ldr	r3, [r7, #8]
 8003f80:	f103 0122 	add.w	r1, r3, #34	; 0x22
 8003f84:	68fb      	ldr	r3, [r7, #12]
 8003f86:	f503 7288 	add.w	r2, r3, #272	; 0x110
 8003f8a:	79fb      	ldrb	r3, [r7, #7]
 8003f8c:	b29b      	uxth	r3, r3
 8003f8e:	4608      	mov	r0, r1
 8003f90:	4611      	mov	r1, r2
 8003f92:	461a      	mov	r2, r3
 8003f94:	f000 f92a 	bl	80041ec <USBH_ParseDevDesc>
  }
  return status;      
 8003f98:	7dfb      	ldrb	r3, [r7, #23]
}
 8003f9a:	4618      	mov	r0, r3
 8003f9c:	f107 0718 	add.w	r7, r7, #24
 8003fa0:	46bd      	mov	sp, r7
 8003fa2:	bd80      	pop	{r7, pc}

08003fa4 <USBH_Get_CfgDesc>:
*/
USBH_Status USBH_Get_CfgDesc(USB_OTG_CORE_HANDLE *pdev, 
                             USBH_HOST           *phost,                      
                             uint16_t length)

{
 8003fa4:	b590      	push	{r4, r7, lr}
 8003fa6:	b089      	sub	sp, #36	; 0x24
 8003fa8:	af02      	add	r7, sp, #8
 8003faa:	60f8      	str	r0, [r7, #12]
 8003fac:	60b9      	str	r1, [r7, #8]
 8003fae:	4613      	mov	r3, r2
 8003fb0:	80fb      	strh	r3, [r7, #6]
  
  if((status = USBH_GetDescriptor(pdev,
                                  phost,
                                  USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
                                  USB_DESC_CONFIGURATION, 
                                  pdev->host.Rx_Buffer,
 8003fb2:	68fb      	ldr	r3, [r7, #12]
 8003fb4:	f503 7388 	add.w	r3, r3, #272	; 0x110
                             uint16_t length)

{
  USBH_Status status;
  
  if((status = USBH_GetDescriptor(pdev,
 8003fb8:	9300      	str	r3, [sp, #0]
 8003fba:	88fb      	ldrh	r3, [r7, #6]
 8003fbc:	9301      	str	r3, [sp, #4]
 8003fbe:	68f8      	ldr	r0, [r7, #12]
 8003fc0:	68b9      	ldr	r1, [r7, #8]
 8003fc2:	f04f 0200 	mov.w	r2, #0
 8003fc6:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003fca:	f000 f849 	bl	8004060 <USBH_GetDescriptor>
 8003fce:	4603      	mov	r3, r0
 8003fd0:	75fb      	strb	r3, [r7, #23]
 8003fd2:	7dfb      	ldrb	r3, [r7, #23]
 8003fd4:	2b00      	cmp	r3, #0
 8003fd6:	d10f      	bne.n	8003ff8 <USBH_Get_CfgDesc+0x54>
                                  USB_DESC_CONFIGURATION, 
                                  pdev->host.Rx_Buffer,
                                  length)) == USBH_OK)
  {
    /* Commands successfully sent and Response Received  */       
    USBH_ParseCfgDesc (&phost->device_prop.Cfg_Desc,
 8003fd8:	68bb      	ldr	r3, [r7, #8]
 8003fda:	f103 0034 	add.w	r0, r3, #52	; 0x34
                       phost->device_prop.Itf_Desc,
 8003fde:	68bb      	ldr	r3, [r7, #8]
 8003fe0:	f103 013e 	add.w	r1, r3, #62	; 0x3e
                       phost->device_prop.Ep_Desc[0], 
 8003fe4:	68bb      	ldr	r3, [r7, #8]
 8003fe6:	f103 0250 	add.w	r2, r3, #80	; 0x50
                       pdev->host.Rx_Buffer,
 8003fea:	68fb      	ldr	r3, [r7, #12]
 8003fec:	f503 7388 	add.w	r3, r3, #272	; 0x110
                                  USB_DESC_CONFIGURATION, 
                                  pdev->host.Rx_Buffer,
                                  length)) == USBH_OK)
  {
    /* Commands successfully sent and Response Received  */       
    USBH_ParseCfgDesc (&phost->device_prop.Cfg_Desc,
 8003ff0:	88fc      	ldrh	r4, [r7, #6]
 8003ff2:	9400      	str	r4, [sp, #0]
 8003ff4:	f000 f972 	bl	80042dc <USBH_ParseCfgDesc>
                       phost->device_prop.Ep_Desc[0], 
                       pdev->host.Rx_Buffer,
                       length); 
    
  }
  return status;
 8003ff8:	7dfb      	ldrb	r3, [r7, #23]
}
 8003ffa:	4618      	mov	r0, r3
 8003ffc:	f107 071c 	add.w	r7, r7, #28
 8004000:	46bd      	mov	sp, r7
 8004002:	bd90      	pop	{r4, r7, pc}

08004004 <USBH_Get_StringDesc>:
USBH_Status USBH_Get_StringDesc(USB_OTG_CORE_HANDLE *pdev,
                                USBH_HOST *phost,
                                uint8_t string_index, 
                                uint8_t *buff, 
                                uint16_t length)
{
 8004004:	b580      	push	{r7, lr}
 8004006:	b088      	sub	sp, #32
 8004008:	af02      	add	r7, sp, #8
 800400a:	60f8      	str	r0, [r7, #12]
 800400c:	60b9      	str	r1, [r7, #8]
 800400e:	603b      	str	r3, [r7, #0]
 8004010:	4613      	mov	r3, r2
 8004012:	71fb      	strb	r3, [r7, #7]
  USBH_Status status;
  
  if((status = USBH_GetDescriptor(pdev,
 8004014:	79fb      	ldrb	r3, [r7, #7]
 8004016:	b29b      	uxth	r3, r3
 8004018:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 800401c:	b29b      	uxth	r3, r3
                                  phost,
                                  USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                                    
                                  USB_DESC_STRING | string_index, 
                                  pdev->host.Rx_Buffer,
 800401e:	68fa      	ldr	r2, [r7, #12]
 8004020:	f502 7288 	add.w	r2, r2, #272	; 0x110
                                uint8_t *buff, 
                                uint16_t length)
{
  USBH_Status status;
  
  if((status = USBH_GetDescriptor(pdev,
 8004024:	9200      	str	r2, [sp, #0]
 8004026:	8c3a      	ldrh	r2, [r7, #32]
 8004028:	9201      	str	r2, [sp, #4]
 800402a:	68f8      	ldr	r0, [r7, #12]
 800402c:	68b9      	ldr	r1, [r7, #8]
 800402e:	f04f 0200 	mov.w	r2, #0
 8004032:	f000 f815 	bl	8004060 <USBH_GetDescriptor>
 8004036:	4603      	mov	r3, r0
 8004038:	75fb      	strb	r3, [r7, #23]
 800403a:	7dfb      	ldrb	r3, [r7, #23]
 800403c:	2b00      	cmp	r3, #0
 800403e:	d108      	bne.n	8004052 <USBH_Get_StringDesc+0x4e>
                                  USB_DESC_STRING | string_index, 
                                  pdev->host.Rx_Buffer,
                                  length)) == USBH_OK)
  {
    /* Commands successfully sent and Response Received  */       
    USBH_ParseStringDesc(pdev->host.Rx_Buffer,buff, length);    
 8004040:	68fb      	ldr	r3, [r7, #12]
 8004042:	f503 7288 	add.w	r2, r3, #272	; 0x110
 8004046:	8c3b      	ldrh	r3, [r7, #32]
 8004048:	4610      	mov	r0, r2
 800404a:	6839      	ldr	r1, [r7, #0]
 800404c:	461a      	mov	r2, r3
 800404e:	f000 fa53 	bl	80044f8 <USBH_ParseStringDesc>
  }
  return status;
 8004052:	7dfb      	ldrb	r3, [r7, #23]
}
 8004054:	4618      	mov	r0, r3
 8004056:	f107 0718 	add.w	r7, r7, #24
 800405a:	46bd      	mov	sp, r7
 800405c:	bd80      	pop	{r7, pc}
 800405e:	bf00      	nop

08004060 <USBH_GetDescriptor>:
                               USBH_HOST           *phost,                                
                               uint8_t  req_type,
                               uint16_t value_idx, 
                               uint8_t* buff, 
                               uint16_t length )
{ 
 8004060:	b580      	push	{r7, lr}
 8004062:	b084      	sub	sp, #16
 8004064:	af00      	add	r7, sp, #0
 8004066:	60f8      	str	r0, [r7, #12]
 8004068:	60b9      	str	r1, [r7, #8]
 800406a:	71fa      	strb	r2, [r7, #7]
 800406c:	80bb      	strh	r3, [r7, #4]
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 800406e:	79fb      	ldrb	r3, [r7, #7]
 8004070:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8004074:	b2da      	uxtb	r2, r3
 8004076:	68bb      	ldr	r3, [r7, #8]
 8004078:	751a      	strb	r2, [r3, #20]
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 800407a:	68bb      	ldr	r3, [r7, #8]
 800407c:	f04f 0206 	mov.w	r2, #6
 8004080:	755a      	strb	r2, [r3, #21]
  phost->Control.setup.b.wValue.w = value_idx;
 8004082:	68bb      	ldr	r3, [r7, #8]
 8004084:	88ba      	ldrh	r2, [r7, #4]
 8004086:	82da      	strh	r2, [r3, #22]
  
  if ((value_idx & 0xff00) == USB_DESC_STRING)
 8004088:	88bb      	ldrh	r3, [r7, #4]
 800408a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800408e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8004092:	d104      	bne.n	800409e <USBH_GetDescriptor+0x3e>
  {
    phost->Control.setup.b.wIndex.w = 0x0409;
 8004094:	68bb      	ldr	r3, [r7, #8]
 8004096:	f240 4209 	movw	r2, #1033	; 0x409
 800409a:	831a      	strh	r2, [r3, #24]
 800409c:	e003      	b.n	80040a6 <USBH_GetDescriptor+0x46>
  }
  else
  {
    phost->Control.setup.b.wIndex.w = 0;
 800409e:	68bb      	ldr	r3, [r7, #8]
 80040a0:	f04f 0200 	mov.w	r2, #0
 80040a4:	831a      	strh	r2, [r3, #24]
  }
  phost->Control.setup.b.wLength.w = length;           
 80040a6:	68bb      	ldr	r3, [r7, #8]
 80040a8:	8bba      	ldrh	r2, [r7, #28]
 80040aa:	835a      	strh	r2, [r3, #26]
  return USBH_CtlReq(pdev, phost, buff , length );     
 80040ac:	8bbb      	ldrh	r3, [r7, #28]
 80040ae:	68f8      	ldr	r0, [r7, #12]
 80040b0:	68b9      	ldr	r1, [r7, #8]
 80040b2:	69ba      	ldr	r2, [r7, #24]
 80040b4:	f7ff fc7c 	bl	80039b0 <USBH_CtlReq>
 80040b8:	4603      	mov	r3, r0
}
 80040ba:	4618      	mov	r0, r3
 80040bc:	f107 0710 	add.w	r7, r7, #16
 80040c0:	46bd      	mov	sp, r7
 80040c2:	bd80      	pop	{r7, pc}

080040c4 <USBH_SetAddress>:
* @retval Status
*/
USBH_Status USBH_SetAddress(USB_OTG_CORE_HANDLE *pdev, 
                            USBH_HOST *phost,
                            uint8_t DeviceAddress)
{
 80040c4:	b580      	push	{r7, lr}
 80040c6:	b084      	sub	sp, #16
 80040c8:	af00      	add	r7, sp, #0
 80040ca:	60f8      	str	r0, [r7, #12]
 80040cc:	60b9      	str	r1, [r7, #8]
 80040ce:	4613      	mov	r3, r2
 80040d0:	71fb      	strb	r3, [r7, #7]
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 80040d2:	68bb      	ldr	r3, [r7, #8]
 80040d4:	f04f 0200 	mov.w	r2, #0
 80040d8:	751a      	strb	r2, [r3, #20]
    USB_REQ_TYPE_STANDARD;
  
  phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
 80040da:	68bb      	ldr	r3, [r7, #8]
 80040dc:	f04f 0205 	mov.w	r2, #5
 80040e0:	755a      	strb	r2, [r3, #21]
  
  phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 80040e2:	79fb      	ldrb	r3, [r7, #7]
 80040e4:	b29a      	uxth	r2, r3
 80040e6:	68bb      	ldr	r3, [r7, #8]
 80040e8:	82da      	strh	r2, [r3, #22]
  phost->Control.setup.b.wIndex.w = 0;
 80040ea:	68bb      	ldr	r3, [r7, #8]
 80040ec:	f04f 0200 	mov.w	r2, #0
 80040f0:	831a      	strh	r2, [r3, #24]
  phost->Control.setup.b.wLength.w = 0;
 80040f2:	68bb      	ldr	r3, [r7, #8]
 80040f4:	f04f 0200 	mov.w	r2, #0
 80040f8:	835a      	strh	r2, [r3, #26]
  
  return USBH_CtlReq(pdev, phost, 0 , 0 );
 80040fa:	68f8      	ldr	r0, [r7, #12]
 80040fc:	68b9      	ldr	r1, [r7, #8]
 80040fe:	f04f 0200 	mov.w	r2, #0
 8004102:	f04f 0300 	mov.w	r3, #0
 8004106:	f7ff fc53 	bl	80039b0 <USBH_CtlReq>
 800410a:	4603      	mov	r3, r0
}
 800410c:	4618      	mov	r0, r3
 800410e:	f107 0710 	add.w	r7, r7, #16
 8004112:	46bd      	mov	sp, r7
 8004114:	bd80      	pop	{r7, pc}
 8004116:	bf00      	nop

08004118 <USBH_SetCfg>:
* @retval Status
*/
USBH_Status USBH_SetCfg(USB_OTG_CORE_HANDLE *pdev, 
                        USBH_HOST *phost,
                        uint16_t cfg_idx)
{
 8004118:	b580      	push	{r7, lr}
 800411a:	b084      	sub	sp, #16
 800411c:	af00      	add	r7, sp, #0
 800411e:	60f8      	str	r0, [r7, #12]
 8004120:	60b9      	str	r1, [r7, #8]
 8004122:	4613      	mov	r3, r2
 8004124:	80fb      	strh	r3, [r7, #6]
  
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
 8004126:	68bb      	ldr	r3, [r7, #8]
 8004128:	f04f 0200 	mov.w	r2, #0
 800412c:	751a      	strb	r2, [r3, #20]
    USB_REQ_TYPE_STANDARD;
  phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
 800412e:	68bb      	ldr	r3, [r7, #8]
 8004130:	f04f 0209 	mov.w	r2, #9
 8004134:	755a      	strb	r2, [r3, #21]
  phost->Control.setup.b.wValue.w = cfg_idx;
 8004136:	68bb      	ldr	r3, [r7, #8]
 8004138:	88fa      	ldrh	r2, [r7, #6]
 800413a:	82da      	strh	r2, [r3, #22]
  phost->Control.setup.b.wIndex.w = 0;
 800413c:	68bb      	ldr	r3, [r7, #8]
 800413e:	f04f 0200 	mov.w	r2, #0
 8004142:	831a      	strh	r2, [r3, #24]
  phost->Control.setup.b.wLength.w = 0;           
 8004144:	68bb      	ldr	r3, [r7, #8]
 8004146:	f04f 0200 	mov.w	r2, #0
 800414a:	835a      	strh	r2, [r3, #26]
  
  return USBH_CtlReq(pdev, phost, 0 , 0 );      
 800414c:	68f8      	ldr	r0, [r7, #12]
 800414e:	68b9      	ldr	r1, [r7, #8]
 8004150:	f04f 0200 	mov.w	r2, #0
 8004154:	f04f 0300 	mov.w	r3, #0
 8004158:	f7ff fc2a 	bl	80039b0 <USBH_CtlReq>
 800415c:	4603      	mov	r3, r0
}
 800415e:	4618      	mov	r0, r3
 8004160:	f107 0710 	add.w	r7, r7, #16
 8004164:	46bd      	mov	sp, r7
 8004166:	bd80      	pop	{r7, pc}

08004168 <USBH_ClrFeature>:
*/
USBH_Status USBH_ClrFeature(USB_OTG_CORE_HANDLE *pdev,
                            USBH_HOST *phost,
                            uint8_t ep_num, 
                            uint8_t hc_num) 
{
 8004168:	b580      	push	{r7, lr}
 800416a:	b084      	sub	sp, #16
 800416c:	af00      	add	r7, sp, #0
 800416e:	60f8      	str	r0, [r7, #12]
 8004170:	60b9      	str	r1, [r7, #8]
 8004172:	71fa      	strb	r2, [r7, #7]
 8004174:	71bb      	strb	r3, [r7, #6]
  
  phost->Control.setup.b.bmRequestType = USB_H2D | 
 8004176:	68bb      	ldr	r3, [r7, #8]
 8004178:	f04f 0202 	mov.w	r2, #2
 800417c:	751a      	strb	r2, [r3, #20]
                                         USB_REQ_RECIPIENT_ENDPOINT |
                                         USB_REQ_TYPE_STANDARD;
  
  phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
 800417e:	68bb      	ldr	r3, [r7, #8]
 8004180:	f04f 0201 	mov.w	r2, #1
 8004184:	755a      	strb	r2, [r3, #21]
  phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
 8004186:	68bb      	ldr	r3, [r7, #8]
 8004188:	f04f 0200 	mov.w	r2, #0
 800418c:	82da      	strh	r2, [r3, #22]
  phost->Control.setup.b.wIndex.w = ep_num;
 800418e:	79fb      	ldrb	r3, [r7, #7]
 8004190:	b29a      	uxth	r2, r3
 8004192:	68bb      	ldr	r3, [r7, #8]
 8004194:	831a      	strh	r2, [r3, #24]
  phost->Control.setup.b.wLength.w = 0;           
 8004196:	68bb      	ldr	r3, [r7, #8]
 8004198:	f04f 0200 	mov.w	r2, #0
 800419c:	835a      	strh	r2, [r3, #26]
  
  if ((ep_num & USB_REQ_DIR_MASK ) == USB_D2H)
 800419e:	79fb      	ldrb	r3, [r7, #7]
 80041a0:	b25b      	sxtb	r3, r3
 80041a2:	2b00      	cmp	r3, #0
 80041a4:	da0a      	bge.n	80041bc <USBH_ClrFeature+0x54>
  { /* EP Type is IN */
    pdev->host.hc[hc_num].toggle_in = 0; 
 80041a6:	79bb      	ldrb	r3, [r7, #6]
 80041a8:	68fa      	ldr	r2, [r7, #12]
 80041aa:	f103 0316 	add.w	r3, r3, #22
 80041ae:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80041b2:	18d3      	adds	r3, r2, r3
 80041b4:	f04f 0200 	mov.w	r2, #0
 80041b8:	711a      	strb	r2, [r3, #4]
 80041ba:	e009      	b.n	80041d0 <USBH_ClrFeature+0x68>
  }
  else
  {/* EP Type is OUT */
    pdev->host.hc[hc_num].toggle_out = 0; 
 80041bc:	79bb      	ldrb	r3, [r7, #6]
 80041be:	68fa      	ldr	r2, [r7, #12]
 80041c0:	f103 0316 	add.w	r3, r3, #22
 80041c4:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80041c8:	18d3      	adds	r3, r2, r3
 80041ca:	f04f 0200 	mov.w	r2, #0
 80041ce:	715a      	strb	r2, [r3, #5]
  }
  
  return USBH_CtlReq(pdev, phost, 0 , 0 );   
 80041d0:	68f8      	ldr	r0, [r7, #12]
 80041d2:	68b9      	ldr	r1, [r7, #8]
 80041d4:	f04f 0200 	mov.w	r2, #0
 80041d8:	f04f 0300 	mov.w	r3, #0
 80041dc:	f7ff fbe8 	bl	80039b0 <USBH_CtlReq>
 80041e0:	4603      	mov	r3, r0
}
 80041e2:	4618      	mov	r0, r3
 80041e4:	f107 0710 	add.w	r7, r7, #16
 80041e8:	46bd      	mov	sp, r7
 80041ea:	bd80      	pop	{r7, pc}

080041ec <USBH_ParseDevDesc>:
* @retval None
*/
static void  USBH_ParseDevDesc (USBH_DevDesc_TypeDef* dev_desc,
                                uint8_t *buf, 
                                uint16_t length)
{
 80041ec:	b480      	push	{r7}
 80041ee:	b085      	sub	sp, #20
 80041f0:	af00      	add	r7, sp, #0
 80041f2:	60f8      	str	r0, [r7, #12]
 80041f4:	60b9      	str	r1, [r7, #8]
 80041f6:	4613      	mov	r3, r2
 80041f8:	80fb      	strh	r3, [r7, #6]
  dev_desc->bLength            = *(uint8_t  *) (buf +  0);
 80041fa:	68bb      	ldr	r3, [r7, #8]
 80041fc:	781a      	ldrb	r2, [r3, #0]
 80041fe:	68fb      	ldr	r3, [r7, #12]
 8004200:	701a      	strb	r2, [r3, #0]
  dev_desc->bDescriptorType    = *(uint8_t  *) (buf +  1);
 8004202:	68bb      	ldr	r3, [r7, #8]
 8004204:	785a      	ldrb	r2, [r3, #1]
 8004206:	68fb      	ldr	r3, [r7, #12]
 8004208:	705a      	strb	r2, [r3, #1]
  dev_desc->bcdUSB             = LE16 (buf +  2);
 800420a:	68bb      	ldr	r3, [r7, #8]
 800420c:	f103 0302 	add.w	r3, r3, #2
 8004210:	781b      	ldrb	r3, [r3, #0]
 8004212:	461a      	mov	r2, r3
 8004214:	68bb      	ldr	r3, [r7, #8]
 8004216:	f103 0303 	add.w	r3, r3, #3
 800421a:	781b      	ldrb	r3, [r3, #0]
 800421c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8004220:	b29b      	uxth	r3, r3
 8004222:	18d3      	adds	r3, r2, r3
 8004224:	b29a      	uxth	r2, r3
 8004226:	68fb      	ldr	r3, [r7, #12]
 8004228:	805a      	strh	r2, [r3, #2]
  dev_desc->bDeviceClass       = *(uint8_t  *) (buf +  4);
 800422a:	68bb      	ldr	r3, [r7, #8]
 800422c:	791a      	ldrb	r2, [r3, #4]
 800422e:	68fb      	ldr	r3, [r7, #12]
 8004230:	711a      	strb	r2, [r3, #4]
  dev_desc->bDeviceSubClass    = *(uint8_t  *) (buf +  5);
 8004232:	68bb      	ldr	r3, [r7, #8]
 8004234:	795a      	ldrb	r2, [r3, #5]
 8004236:	68fb      	ldr	r3, [r7, #12]
 8004238:	715a      	strb	r2, [r3, #5]
  dev_desc->bDeviceProtocol    = *(uint8_t  *) (buf +  6);
 800423a:	68bb      	ldr	r3, [r7, #8]
 800423c:	799a      	ldrb	r2, [r3, #6]
 800423e:	68fb      	ldr	r3, [r7, #12]
 8004240:	719a      	strb	r2, [r3, #6]
  dev_desc->bMaxPacketSize     = *(uint8_t  *) (buf +  7);
 8004242:	68bb      	ldr	r3, [r7, #8]
 8004244:	79da      	ldrb	r2, [r3, #7]
 8004246:	68fb      	ldr	r3, [r7, #12]
 8004248:	71da      	strb	r2, [r3, #7]
  
  if (length > 8)
 800424a:	88fb      	ldrh	r3, [r7, #6]
 800424c:	2b08      	cmp	r3, #8
 800424e:	d93f      	bls.n	80042d0 <USBH_ParseDevDesc+0xe4>
  { /* For 1st time after device connection, Host may issue only 8 bytes for 
    Device Descriptor Length  */
    dev_desc->idVendor           = LE16 (buf +  8);
 8004250:	68bb      	ldr	r3, [r7, #8]
 8004252:	f103 0308 	add.w	r3, r3, #8
 8004256:	781b      	ldrb	r3, [r3, #0]
 8004258:	461a      	mov	r2, r3
 800425a:	68bb      	ldr	r3, [r7, #8]
 800425c:	f103 0309 	add.w	r3, r3, #9
 8004260:	781b      	ldrb	r3, [r3, #0]
 8004262:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8004266:	b29b      	uxth	r3, r3
 8004268:	18d3      	adds	r3, r2, r3
 800426a:	b29a      	uxth	r2, r3
 800426c:	68fb      	ldr	r3, [r7, #12]
 800426e:	811a      	strh	r2, [r3, #8]
    dev_desc->idProduct          = LE16 (buf + 10);
 8004270:	68bb      	ldr	r3, [r7, #8]
 8004272:	f103 030a 	add.w	r3, r3, #10
 8004276:	781b      	ldrb	r3, [r3, #0]
 8004278:	461a      	mov	r2, r3
 800427a:	68bb      	ldr	r3, [r7, #8]
 800427c:	f103 030b 	add.w	r3, r3, #11
 8004280:	781b      	ldrb	r3, [r3, #0]
 8004282:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8004286:	b29b      	uxth	r3, r3
 8004288:	18d3      	adds	r3, r2, r3
 800428a:	b29a      	uxth	r2, r3
 800428c:	68fb      	ldr	r3, [r7, #12]
 800428e:	815a      	strh	r2, [r3, #10]
    dev_desc->bcdDevice          = LE16 (buf + 12);
 8004290:	68bb      	ldr	r3, [r7, #8]
 8004292:	f103 030c 	add.w	r3, r3, #12
 8004296:	781b      	ldrb	r3, [r3, #0]
 8004298:	461a      	mov	r2, r3
 800429a:	68bb      	ldr	r3, [r7, #8]
 800429c:	f103 030d 	add.w	r3, r3, #13
 80042a0:	781b      	ldrb	r3, [r3, #0]
 80042a2:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80042a6:	b29b      	uxth	r3, r3
 80042a8:	18d3      	adds	r3, r2, r3
 80042aa:	b29a      	uxth	r2, r3
 80042ac:	68fb      	ldr	r3, [r7, #12]
 80042ae:	819a      	strh	r2, [r3, #12]
    dev_desc->iManufacturer      = *(uint8_t  *) (buf + 14);
 80042b0:	68bb      	ldr	r3, [r7, #8]
 80042b2:	7b9a      	ldrb	r2, [r3, #14]
 80042b4:	68fb      	ldr	r3, [r7, #12]
 80042b6:	739a      	strb	r2, [r3, #14]
    dev_desc->iProduct           = *(uint8_t  *) (buf + 15);
 80042b8:	68bb      	ldr	r3, [r7, #8]
 80042ba:	7bda      	ldrb	r2, [r3, #15]
 80042bc:	68fb      	ldr	r3, [r7, #12]
 80042be:	73da      	strb	r2, [r3, #15]
    dev_desc->iSerialNumber      = *(uint8_t  *) (buf + 16);
 80042c0:	68bb      	ldr	r3, [r7, #8]
 80042c2:	7c1a      	ldrb	r2, [r3, #16]
 80042c4:	68fb      	ldr	r3, [r7, #12]
 80042c6:	741a      	strb	r2, [r3, #16]
    dev_desc->bNumConfigurations = *(uint8_t  *) (buf + 17);
 80042c8:	68bb      	ldr	r3, [r7, #8]
 80042ca:	7c5a      	ldrb	r2, [r3, #17]
 80042cc:	68fb      	ldr	r3, [r7, #12]
 80042ce:	745a      	strb	r2, [r3, #17]
  }
}
 80042d0:	f107 0714 	add.w	r7, r7, #20
 80042d4:	46bd      	mov	sp, r7
 80042d6:	bc80      	pop	{r7}
 80042d8:	4770      	bx	lr
 80042da:	bf00      	nop

080042dc <USBH_ParseCfgDesc>:
static void  USBH_ParseCfgDesc (USBH_CfgDesc_TypeDef* cfg_desc,
                                USBH_InterfaceDesc_TypeDef* itf_desc,
                                USBH_EpDesc_TypeDef*  ep_desc, 
                                uint8_t *buf, 
                                uint16_t length)
{  
 80042dc:	b580      	push	{r7, lr}
 80042de:	b08a      	sub	sp, #40	; 0x28
 80042e0:	af00      	add	r7, sp, #0
 80042e2:	60f8      	str	r0, [r7, #12]
 80042e4:	60b9      	str	r1, [r7, #8]
 80042e6:	607a      	str	r2, [r7, #4]
 80042e8:	603b      	str	r3, [r7, #0]
  USBH_InterfaceDesc_TypeDef    *pif ;
  USBH_EpDesc_TypeDef           *pep;  
  USBH_DescHeader_t             *pdesc = (USBH_DescHeader_t *)buf;
 80042ea:	683b      	ldr	r3, [r7, #0]
 80042ec:	627b      	str	r3, [r7, #36]	; 0x24
  uint16_t                      ptr;
  int8_t                        if_ix;
  int8_t                        ep_ix;  
  
  pdesc   = (USBH_DescHeader_t *)buf;
 80042ee:	683b      	ldr	r3, [r7, #0]
 80042f0:	627b      	str	r3, [r7, #36]	; 0x24
  
  /* Parse configuration descriptor */
  cfg_desc->bLength             = *(uint8_t  *) (buf + 0);
 80042f2:	683b      	ldr	r3, [r7, #0]
 80042f4:	781a      	ldrb	r2, [r3, #0]
 80042f6:	68fb      	ldr	r3, [r7, #12]
 80042f8:	701a      	strb	r2, [r3, #0]
  cfg_desc->bDescriptorType     = *(uint8_t  *) (buf + 1);
 80042fa:	683b      	ldr	r3, [r7, #0]
 80042fc:	785a      	ldrb	r2, [r3, #1]
 80042fe:	68fb      	ldr	r3, [r7, #12]
 8004300:	705a      	strb	r2, [r3, #1]
  cfg_desc->wTotalLength        = LE16 (buf + 2);
 8004302:	683b      	ldr	r3, [r7, #0]
 8004304:	f103 0302 	add.w	r3, r3, #2
 8004308:	781b      	ldrb	r3, [r3, #0]
 800430a:	461a      	mov	r2, r3
 800430c:	683b      	ldr	r3, [r7, #0]
 800430e:	f103 0303 	add.w	r3, r3, #3
 8004312:	781b      	ldrb	r3, [r3, #0]
 8004314:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8004318:	b29b      	uxth	r3, r3
 800431a:	18d3      	adds	r3, r2, r3
 800431c:	b29a      	uxth	r2, r3
 800431e:	68fb      	ldr	r3, [r7, #12]
 8004320:	805a      	strh	r2, [r3, #2]
  cfg_desc->bNumInterfaces      = *(uint8_t  *) (buf + 4);
 8004322:	683b      	ldr	r3, [r7, #0]
 8004324:	791a      	ldrb	r2, [r3, #4]
 8004326:	68fb      	ldr	r3, [r7, #12]
 8004328:	711a      	strb	r2, [r3, #4]
  cfg_desc->bConfigurationValue = *(uint8_t  *) (buf + 5);
 800432a:	683b      	ldr	r3, [r7, #0]
 800432c:	795a      	ldrb	r2, [r3, #5]
 800432e:	68fb      	ldr	r3, [r7, #12]
 8004330:	715a      	strb	r2, [r3, #5]
  cfg_desc->iConfiguration      = *(uint8_t  *) (buf + 6);
 8004332:	683b      	ldr	r3, [r7, #0]
 8004334:	799a      	ldrb	r2, [r3, #6]
 8004336:	68fb      	ldr	r3, [r7, #12]
 8004338:	719a      	strb	r2, [r3, #6]
  cfg_desc->bmAttributes        = *(uint8_t  *) (buf + 7);
 800433a:	683b      	ldr	r3, [r7, #0]
 800433c:	79da      	ldrb	r2, [r3, #7]
 800433e:	68fb      	ldr	r3, [r7, #12]
 8004340:	71da      	strb	r2, [r3, #7]
  cfg_desc->bMaxPower           = *(uint8_t  *) (buf + 8);    
 8004342:	683b      	ldr	r3, [r7, #0]
 8004344:	7a1a      	ldrb	r2, [r3, #8]
 8004346:	68fb      	ldr	r3, [r7, #12]
 8004348:	721a      	strb	r2, [r3, #8]
  
  
  if (length > USB_CONFIGURATION_DESC_SIZE)
 800434a:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800434c:	2b09      	cmp	r3, #9
 800434e:	d973      	bls.n	8004438 <USBH_ParseCfgDesc+0x15c>
  {
    ptr = USB_LEN_CFG_DESC;
 8004350:	f04f 0309 	mov.w	r3, #9
 8004354:	82fb      	strh	r3, [r7, #22]
    
    if ( cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES) 
 8004356:	68fb      	ldr	r3, [r7, #12]
 8004358:	791b      	ldrb	r3, [r3, #4]
 800435a:	2b02      	cmp	r3, #2
 800435c:	d86c      	bhi.n	8004438 <USBH_ParseCfgDesc+0x15c>
    {
      if_ix = 0;
 800435e:	f04f 0300 	mov.w	r3, #0
 8004362:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
      pif = (USBH_InterfaceDesc_TypeDef *)0;
 8004366:	f04f 0300 	mov.w	r3, #0
 800436a:	61fb      	str	r3, [r7, #28]
      
      /* Parse Interface descriptor relative to the current configuration */
      if(cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES)
 800436c:	68fb      	ldr	r3, [r7, #12]
 800436e:	791b      	ldrb	r3, [r3, #4]
 8004370:	2b02      	cmp	r3, #2
 8004372:	d861      	bhi.n	8004438 <USBH_ParseCfgDesc+0x15c>
      {
        while (if_ix < cfg_desc->bNumInterfaces) 
 8004374:	e05a      	b.n	800442c <USBH_ParseCfgDesc+0x150>
        {
          pdesc = USBH_GetNextDesc((uint8_t *)pdesc, &ptr);
 8004376:	f107 0316 	add.w	r3, r7, #22
 800437a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800437c:	4619      	mov	r1, r3
 800437e:	f000 f8f5 	bl	800456c <USBH_GetNextDesc>
 8004382:	4603      	mov	r3, r0
 8004384:	627b      	str	r3, [r7, #36]	; 0x24
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE) 
 8004386:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004388:	785b      	ldrb	r3, [r3, #1]
 800438a:	2b04      	cmp	r3, #4
 800438c:	d147      	bne.n	800441e <USBH_ParseCfgDesc+0x142>
          {  
            pif               = &itf_desc[if_ix];
 800438e:	f997 2023 	ldrsb.w	r2, [r7, #35]	; 0x23
 8004392:	4613      	mov	r3, r2
 8004394:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8004398:	189b      	adds	r3, r3, r2
 800439a:	68ba      	ldr	r2, [r7, #8]
 800439c:	18d3      	adds	r3, r2, r3
 800439e:	61fb      	str	r3, [r7, #28]
            USBH_ParseInterfaceDesc (pif, (uint8_t *)pdesc);
 80043a0:	69f8      	ldr	r0, [r7, #28]
 80043a2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80043a4:	f000 f84c 	bl	8004440 <USBH_ParseInterfaceDesc>
            ep_ix = 0;
 80043a8:	f04f 0300 	mov.w	r3, #0
 80043ac:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
            
            /* Parse Ep descriptors relative to the current interface */
            if(pif->bNumEndpoints <= USBH_MAX_NUM_ENDPOINTS)
 80043b0:	69fb      	ldr	r3, [r7, #28]
 80043b2:	791b      	ldrb	r3, [r3, #4]
 80043b4:	2b02      	cmp	r3, #2
 80043b6:	d82b      	bhi.n	8004410 <USBH_ParseCfgDesc+0x134>
            {          
              while (ep_ix < pif->bNumEndpoints) 
 80043b8:	e024      	b.n	8004404 <USBH_ParseCfgDesc+0x128>
              {
                pdesc = USBH_GetNextDesc((void* )pdesc, &ptr);
 80043ba:	f107 0316 	add.w	r3, r7, #22
 80043be:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80043c0:	4619      	mov	r1, r3
 80043c2:	f000 f8d3 	bl	800456c <USBH_GetNextDesc>
 80043c6:	4603      	mov	r3, r0
 80043c8:	627b      	str	r3, [r7, #36]	; 0x24
                if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT) 
 80043ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80043cc:	785b      	ldrb	r3, [r3, #1]
 80043ce:	2b05      	cmp	r3, #5
 80043d0:	d111      	bne.n	80043f6 <USBH_ParseCfgDesc+0x11a>
                {  
                  pep               = &ep_desc[ep_ix];
 80043d2:	f997 3022 	ldrsb.w	r3, [r7, #34]	; 0x22
 80043d6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80043da:	687a      	ldr	r2, [r7, #4]
 80043dc:	18d3      	adds	r3, r2, r3
 80043de:	61bb      	str	r3, [r7, #24]
                  USBH_ParseEPDesc (pep, (uint8_t *)pdesc);
 80043e0:	69b8      	ldr	r0, [r7, #24]
 80043e2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80043e4:	f000 f85a 	bl	800449c <USBH_ParseEPDesc>
                  ep_ix++;
 80043e8:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 80043ec:	f103 0301 	add.w	r3, r3, #1
 80043f0:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 80043f4:	e006      	b.n	8004404 <USBH_ParseCfgDesc+0x128>
                }
                else
                {
                  ptr += pdesc->bLength;
 80043f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80043f8:	781b      	ldrb	r3, [r3, #0]
 80043fa:	461a      	mov	r2, r3
 80043fc:	8afb      	ldrh	r3, [r7, #22]
 80043fe:	18d3      	adds	r3, r2, r3
 8004400:	b29b      	uxth	r3, r3
 8004402:	82fb      	strh	r3, [r7, #22]
            ep_ix = 0;
            
            /* Parse Ep descriptors relative to the current interface */
            if(pif->bNumEndpoints <= USBH_MAX_NUM_ENDPOINTS)
            {          
              while (ep_ix < pif->bNumEndpoints) 
 8004404:	f997 2022 	ldrsb.w	r2, [r7, #34]	; 0x22
 8004408:	69fb      	ldr	r3, [r7, #28]
 800440a:	791b      	ldrb	r3, [r3, #4]
 800440c:	429a      	cmp	r2, r3
 800440e:	dbd4      	blt.n	80043ba <USBH_ParseCfgDesc+0xde>
                {
                  ptr += pdesc->bLength;
                }
              }
            }
            if_ix++;
 8004410:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8004414:	f103 0301 	add.w	r3, r3, #1
 8004418:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800441c:	e006      	b.n	800442c <USBH_ParseCfgDesc+0x150>
          }
          else
          {
            ptr += pdesc->bLength;
 800441e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004420:	781b      	ldrb	r3, [r3, #0]
 8004422:	461a      	mov	r2, r3
 8004424:	8afb      	ldrh	r3, [r7, #22]
 8004426:	18d3      	adds	r3, r2, r3
 8004428:	b29b      	uxth	r3, r3
 800442a:	82fb      	strh	r3, [r7, #22]
      pif = (USBH_InterfaceDesc_TypeDef *)0;
      
      /* Parse Interface descriptor relative to the current configuration */
      if(cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES)
      {
        while (if_ix < cfg_desc->bNumInterfaces) 
 800442c:	f997 2023 	ldrsb.w	r2, [r7, #35]	; 0x23
 8004430:	68fb      	ldr	r3, [r7, #12]
 8004432:	791b      	ldrb	r3, [r3, #4]
 8004434:	429a      	cmp	r2, r3
 8004436:	db9e      	blt.n	8004376 <USBH_ParseCfgDesc+0x9a>
          }
        }
      }
    }
  }  
}
 8004438:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800443c:	46bd      	mov	sp, r7
 800443e:	bd80      	pop	{r7, pc}

08004440 <USBH_ParseInterfaceDesc>:
* @param  buf: Buffer where the descriptor data is available
* @retval None
*/
static void  USBH_ParseInterfaceDesc (USBH_InterfaceDesc_TypeDef *if_descriptor, 
                                      uint8_t *buf)
{
 8004440:	b480      	push	{r7}
 8004442:	b083      	sub	sp, #12
 8004444:	af00      	add	r7, sp, #0
 8004446:	6078      	str	r0, [r7, #4]
 8004448:	6039      	str	r1, [r7, #0]
  if_descriptor->bLength            = *(uint8_t  *) (buf + 0);
 800444a:	683b      	ldr	r3, [r7, #0]
 800444c:	781a      	ldrb	r2, [r3, #0]
 800444e:	687b      	ldr	r3, [r7, #4]
 8004450:	701a      	strb	r2, [r3, #0]
  if_descriptor->bDescriptorType    = *(uint8_t  *) (buf + 1);
 8004452:	683b      	ldr	r3, [r7, #0]
 8004454:	785a      	ldrb	r2, [r3, #1]
 8004456:	687b      	ldr	r3, [r7, #4]
 8004458:	705a      	strb	r2, [r3, #1]
  if_descriptor->bInterfaceNumber   = *(uint8_t  *) (buf + 2);
 800445a:	683b      	ldr	r3, [r7, #0]
 800445c:	789a      	ldrb	r2, [r3, #2]
 800445e:	687b      	ldr	r3, [r7, #4]
 8004460:	709a      	strb	r2, [r3, #2]
  if_descriptor->bAlternateSetting  = *(uint8_t  *) (buf + 3);
 8004462:	683b      	ldr	r3, [r7, #0]
 8004464:	78da      	ldrb	r2, [r3, #3]
 8004466:	687b      	ldr	r3, [r7, #4]
 8004468:	70da      	strb	r2, [r3, #3]
  if_descriptor->bNumEndpoints      = *(uint8_t  *) (buf + 4);
 800446a:	683b      	ldr	r3, [r7, #0]
 800446c:	791a      	ldrb	r2, [r3, #4]
 800446e:	687b      	ldr	r3, [r7, #4]
 8004470:	711a      	strb	r2, [r3, #4]
  if_descriptor->bInterfaceClass    = *(uint8_t  *) (buf + 5);
 8004472:	683b      	ldr	r3, [r7, #0]
 8004474:	795a      	ldrb	r2, [r3, #5]
 8004476:	687b      	ldr	r3, [r7, #4]
 8004478:	715a      	strb	r2, [r3, #5]
  if_descriptor->bInterfaceSubClass = *(uint8_t  *) (buf + 6);
 800447a:	683b      	ldr	r3, [r7, #0]
 800447c:	799a      	ldrb	r2, [r3, #6]
 800447e:	687b      	ldr	r3, [r7, #4]
 8004480:	719a      	strb	r2, [r3, #6]
  if_descriptor->bInterfaceProtocol = *(uint8_t  *) (buf + 7);
 8004482:	683b      	ldr	r3, [r7, #0]
 8004484:	79da      	ldrb	r2, [r3, #7]
 8004486:	687b      	ldr	r3, [r7, #4]
 8004488:	71da      	strb	r2, [r3, #7]
  if_descriptor->iInterface         = *(uint8_t  *) (buf + 8);
 800448a:	683b      	ldr	r3, [r7, #0]
 800448c:	7a1a      	ldrb	r2, [r3, #8]
 800448e:	687b      	ldr	r3, [r7, #4]
 8004490:	721a      	strb	r2, [r3, #8]
}
 8004492:	f107 070c 	add.w	r7, r7, #12
 8004496:	46bd      	mov	sp, r7
 8004498:	bc80      	pop	{r7}
 800449a:	4770      	bx	lr

0800449c <USBH_ParseEPDesc>:
* @param  buf: Buffer where the parsed descriptor stored
* @retval None
*/
static void  USBH_ParseEPDesc (USBH_EpDesc_TypeDef  *ep_descriptor, 
                               uint8_t *buf)
{
 800449c:	b480      	push	{r7}
 800449e:	b083      	sub	sp, #12
 80044a0:	af00      	add	r7, sp, #0
 80044a2:	6078      	str	r0, [r7, #4]
 80044a4:	6039      	str	r1, [r7, #0]
  
  ep_descriptor->bLength          = *(uint8_t  *) (buf + 0);
 80044a6:	683b      	ldr	r3, [r7, #0]
 80044a8:	781a      	ldrb	r2, [r3, #0]
 80044aa:	687b      	ldr	r3, [r7, #4]
 80044ac:	701a      	strb	r2, [r3, #0]
  ep_descriptor->bDescriptorType  = *(uint8_t  *) (buf + 1);
 80044ae:	683b      	ldr	r3, [r7, #0]
 80044b0:	785a      	ldrb	r2, [r3, #1]
 80044b2:	687b      	ldr	r3, [r7, #4]
 80044b4:	705a      	strb	r2, [r3, #1]
  ep_descriptor->bEndpointAddress = *(uint8_t  *) (buf + 2);
 80044b6:	683b      	ldr	r3, [r7, #0]
 80044b8:	789a      	ldrb	r2, [r3, #2]
 80044ba:	687b      	ldr	r3, [r7, #4]
 80044bc:	709a      	strb	r2, [r3, #2]
  ep_descriptor->bmAttributes     = *(uint8_t  *) (buf + 3);
 80044be:	683b      	ldr	r3, [r7, #0]
 80044c0:	78da      	ldrb	r2, [r3, #3]
 80044c2:	687b      	ldr	r3, [r7, #4]
 80044c4:	70da      	strb	r2, [r3, #3]
  ep_descriptor->wMaxPacketSize   = LE16 (buf + 4);
 80044c6:	683b      	ldr	r3, [r7, #0]
 80044c8:	f103 0304 	add.w	r3, r3, #4
 80044cc:	781b      	ldrb	r3, [r3, #0]
 80044ce:	461a      	mov	r2, r3
 80044d0:	683b      	ldr	r3, [r7, #0]
 80044d2:	f103 0305 	add.w	r3, r3, #5
 80044d6:	781b      	ldrb	r3, [r3, #0]
 80044d8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80044dc:	b29b      	uxth	r3, r3
 80044de:	18d3      	adds	r3, r2, r3
 80044e0:	b29a      	uxth	r2, r3
 80044e2:	687b      	ldr	r3, [r7, #4]
 80044e4:	809a      	strh	r2, [r3, #4]
  ep_descriptor->bInterval        = *(uint8_t  *) (buf + 6);
 80044e6:	683b      	ldr	r3, [r7, #0]
 80044e8:	799a      	ldrb	r2, [r3, #6]
 80044ea:	687b      	ldr	r3, [r7, #4]
 80044ec:	719a      	strb	r2, [r3, #6]
}
 80044ee:	f107 070c 	add.w	r7, r7, #12
 80044f2:	46bd      	mov	sp, r7
 80044f4:	bc80      	pop	{r7}
 80044f6:	4770      	bx	lr

080044f8 <USBH_ParseStringDesc>:
* @retval None
*/
static void USBH_ParseStringDesc (uint8_t* psrc, 
                                  uint8_t* pdest, 
                                  uint16_t length)
{
 80044f8:	b480      	push	{r7}
 80044fa:	b087      	sub	sp, #28
 80044fc:	af00      	add	r7, sp, #0
 80044fe:	60f8      	str	r0, [r7, #12]
 8004500:	60b9      	str	r1, [r7, #8]
 8004502:	4613      	mov	r3, r2
 8004504:	80fb      	strh	r3, [r7, #6]
  */
  
  /* Check which is lower size, the Size of string or the length of bytes read 
  from the device */
  
  if ( psrc[1] == USB_DESC_TYPE_STRING)
 8004506:	68fb      	ldr	r3, [r7, #12]
 8004508:	f103 0301 	add.w	r3, r3, #1
 800450c:	781b      	ldrb	r3, [r3, #0]
 800450e:	2b03      	cmp	r3, #3
 8004510:	d126      	bne.n	8004560 <USBH_ParseStringDesc+0x68>
  { /* Make sure the Descriptor is String Type */
    
    /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */      
    strlength = ( ( (psrc[0]-2) <= length) ? (psrc[0]-2) :length); 
 8004512:	68fb      	ldr	r3, [r7, #12]
 8004514:	781b      	ldrb	r3, [r3, #0]
 8004516:	f1a3 0202 	sub.w	r2, r3, #2
 800451a:	88fb      	ldrh	r3, [r7, #6]
 800451c:	429a      	cmp	r2, r3
 800451e:	bfb8      	it	lt
 8004520:	4613      	movlt	r3, r2
 8004522:	82bb      	strh	r3, [r7, #20]
    psrc += 2; /* Adjust the offset ignoring the String Len and Descriptor type */
 8004524:	68fb      	ldr	r3, [r7, #12]
 8004526:	f103 0302 	add.w	r3, r3, #2
 800452a:	60fb      	str	r3, [r7, #12]
    
    for (idx = 0; idx < strlength; idx+=2 )
 800452c:	f04f 0300 	mov.w	r3, #0
 8004530:	82fb      	strh	r3, [r7, #22]
 8004532:	e00d      	b.n	8004550 <USBH_ParseStringDesc+0x58>
    {/* Copy Only the string and ignore the UNICODE ID, hence add the src */
      *pdest =  psrc[idx];
 8004534:	8afb      	ldrh	r3, [r7, #22]
 8004536:	68fa      	ldr	r2, [r7, #12]
 8004538:	18d3      	adds	r3, r2, r3
 800453a:	781a      	ldrb	r2, [r3, #0]
 800453c:	68bb      	ldr	r3, [r7, #8]
 800453e:	701a      	strb	r2, [r3, #0]
      pdest++;
 8004540:	68bb      	ldr	r3, [r7, #8]
 8004542:	f103 0301 	add.w	r3, r3, #1
 8004546:	60bb      	str	r3, [r7, #8]
    
    /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */      
    strlength = ( ( (psrc[0]-2) <= length) ? (psrc[0]-2) :length); 
    psrc += 2; /* Adjust the offset ignoring the String Len and Descriptor type */
    
    for (idx = 0; idx < strlength; idx+=2 )
 8004548:	8afb      	ldrh	r3, [r7, #22]
 800454a:	f103 0302 	add.w	r3, r3, #2
 800454e:	82fb      	strh	r3, [r7, #22]
 8004550:	8afa      	ldrh	r2, [r7, #22]
 8004552:	8abb      	ldrh	r3, [r7, #20]
 8004554:	429a      	cmp	r2, r3
 8004556:	d3ed      	bcc.n	8004534 <USBH_ParseStringDesc+0x3c>
    {/* Copy Only the string and ignore the UNICODE ID, hence add the src */
      *pdest =  psrc[idx];
      pdest++;
    }  
    *pdest = 0; /* mark end of string */  
 8004558:	68bb      	ldr	r3, [r7, #8]
 800455a:	f04f 0200 	mov.w	r2, #0
 800455e:	701a      	strb	r2, [r3, #0]
  }
}
 8004560:	f107 071c 	add.w	r7, r7, #28
 8004564:	46bd      	mov	sp, r7
 8004566:	bc80      	pop	{r7}
 8004568:	4770      	bx	lr
 800456a:	bf00      	nop

0800456c <USBH_GetNextDesc>:
* @param  buf: Buffer where the cfg descriptor is available
* @param  ptr: data popinter inside the cfg descriptor
* @retval next header
*/
static  USBH_DescHeader_t  *USBH_GetNextDesc (uint8_t   *pbuf, uint16_t  *ptr)
{
 800456c:	b480      	push	{r7}
 800456e:	b085      	sub	sp, #20
 8004570:	af00      	add	r7, sp, #0
 8004572:	6078      	str	r0, [r7, #4]
 8004574:	6039      	str	r1, [r7, #0]
  USBH_DescHeader_t  *pnext;
 
  *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
 8004576:	683b      	ldr	r3, [r7, #0]
 8004578:	881a      	ldrh	r2, [r3, #0]
 800457a:	687b      	ldr	r3, [r7, #4]
 800457c:	781b      	ldrb	r3, [r3, #0]
 800457e:	18d3      	adds	r3, r2, r3
 8004580:	b29a      	uxth	r2, r3
 8004582:	683b      	ldr	r3, [r7, #0]
 8004584:	801a      	strh	r2, [r3, #0]
  pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
         ((USBH_DescHeader_t *)pbuf)->bLength);
 8004586:	687b      	ldr	r3, [r7, #4]
 8004588:	781b      	ldrb	r3, [r3, #0]
static  USBH_DescHeader_t  *USBH_GetNextDesc (uint8_t   *pbuf, uint16_t  *ptr)
{
  USBH_DescHeader_t  *pnext;
 
  *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
  pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
 800458a:	687a      	ldr	r2, [r7, #4]
 800458c:	18d3      	adds	r3, r2, r3
 800458e:	60fb      	str	r3, [r7, #12]
         ((USBH_DescHeader_t *)pbuf)->bLength);
 
  return(pnext);
 8004590:	68fb      	ldr	r3, [r7, #12]
}
 8004592:	4618      	mov	r0, r3
 8004594:	f107 0714 	add.w	r7, r7, #20
 8004598:	46bd      	mov	sp, r7
 800459a:	bc80      	pop	{r7}
 800459c:	4770      	bx	lr
 800459e:	bf00      	nop

080045a0 <USBH_MSC_Init>:
*         Initializes the mass storage parameters
* @param  None
* @retval None
*/
void USBH_MSC_Init(USB_OTG_CORE_HANDLE *pdev )
{
 80045a0:	b580      	push	{r7, lr}
 80045a2:	b082      	sub	sp, #8
 80045a4:	af00      	add	r7, sp, #0
 80045a6:	6078      	str	r0, [r7, #4]
  if(HCD_IsDeviceConnected(pdev))
 80045a8:	6878      	ldr	r0, [r7, #4]
 80045aa:	f7fd f83b 	bl	8001624 <HCD_IsDeviceConnected>
 80045ae:	4603      	mov	r3, r0
 80045b0:	2b00      	cmp	r3, #0
 80045b2:	d01f      	beq.n	80045f4 <USBH_MSC_Init+0x54>
  {      
    USBH_MSC_CBWData.field.CBWSignature = USBH_MSC_BOT_CBW_SIGNATURE;
 80045b4:	f244 1300 	movw	r3, #16640	; 0x4100
 80045b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045bc:	f245 3255 	movw	r2, #21333	; 0x5355
 80045c0:	f2c4 3242 	movt	r2, #17218	; 0x4342
 80045c4:	601a      	str	r2, [r3, #0]
    USBH_MSC_CBWData.field.CBWTag = USBH_MSC_BOT_CBW_TAG;
 80045c6:	f244 1300 	movw	r3, #16640	; 0x4100
 80045ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045ce:	f244 0250 	movw	r2, #16464	; 0x4050
 80045d2:	f2c2 0230 	movt	r2, #8240	; 0x2030
 80045d6:	605a      	str	r2, [r3, #4]
    USBH_MSC_CBWData.field.CBWLUN = 0;  /*Only one LUN is supported*/
 80045d8:	f244 1300 	movw	r3, #16640	; 0x4100
 80045dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045e0:	f04f 0200 	mov.w	r2, #0
 80045e4:	735a      	strb	r2, [r3, #13]
    USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;  
 80045e6:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80045ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045ee:	f04f 0201 	mov.w	r2, #1
 80045f2:	70da      	strb	r2, [r3, #3]
  }
  
  BOTStallErrorCount = 0;
 80045f4:	f640 13f0 	movw	r3, #2544	; 0x9f0
 80045f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045fc:	f04f 0200 	mov.w	r2, #0
 8004600:	601a      	str	r2, [r3, #0]
  MSCErrorCount = 0;
 8004602:	f640 13fd 	movw	r3, #2557	; 0x9fd
 8004606:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800460a:	f04f 0200 	mov.w	r2, #0
 800460e:	701a      	strb	r2, [r3, #0]
}
 8004610:	f107 0708 	add.w	r7, r7, #8
 8004614:	46bd      	mov	sp, r7
 8004616:	bd80      	pop	{r7, pc}

08004618 <USBH_MSC_HandleBOTXfer>:
* @param  None
* @retval None
* 
*/
void USBH_MSC_HandleBOTXfer (USB_OTG_CORE_HANDLE *pdev ,USBH_HOST *phost)
{
 8004618:	b580      	push	{r7, lr}
 800461a:	b084      	sub	sp, #16
 800461c:	af00      	add	r7, sp, #0
 800461e:	6078      	str	r0, [r7, #4]
 8004620:	6039      	str	r1, [r7, #0]
  static uint32_t remainingDataLength;
  static uint8_t *datapointer;
  static uint8_t error_direction;
  USBH_Status status;
  
  URB_STATE URB_Status = URB_IDLE;
 8004622:	f04f 0300 	mov.w	r3, #0
 8004626:	73bb      	strb	r3, [r7, #14]
  
  if(HCD_IsDeviceConnected(pdev))
 8004628:	6878      	ldr	r0, [r7, #4]
 800462a:	f7fc fffb 	bl	8001624 <HCD_IsDeviceConnected>
 800462e:	4603      	mov	r3, r0
 8004630:	2b00      	cmp	r3, #0
 8004632:	f000 82de 	beq.w	8004bf2 <USBH_MSC_HandleBOTXfer+0x5da>
  {  
    
    switch (USBH_MSC_BOTXferParam.BOTState)
 8004636:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800463a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800463e:	791b      	ldrb	r3, [r3, #4]
 8004640:	f103 33ff 	add.w	r3, r3, #4294967295
 8004644:	2b07      	cmp	r3, #7
 8004646:	f200 82c7 	bhi.w	8004bd8 <USBH_MSC_HandleBOTXfer+0x5c0>
 800464a:	a201      	add	r2, pc, #4	; (adr r2, 8004650 <USBH_MSC_HandleBOTXfer+0x38>)
 800464c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004650:	08004671 	.word	0x08004671
 8004654:	080046ab 	.word	0x080046ab
 8004658:	080047a1 	.word	0x080047a1
 800465c:	080048d1 	.word	0x080048d1
 8004660:	08004a1d 	.word	0x08004a1d
 8004664:	08004aaf 	.word	0x08004aaf
 8004668:	08004b37 	.word	0x08004b37
 800466c:	08004b97 	.word	0x08004b97
    {
    case USBH_MSC_SEND_CBW:
      /* send CBW */    
      USBH_BulkSendData (pdev,
 8004670:	f244 1320 	movw	r3, #16672	; 0x4120
 8004674:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004678:	785b      	ldrb	r3, [r3, #1]
 800467a:	6878      	ldr	r0, [r7, #4]
 800467c:	f244 1100 	movw	r1, #16640	; 0x4100
 8004680:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8004684:	f04f 021f 	mov.w	r2, #31
 8004688:	f7ff fac4 	bl	8003c14 <USBH_BulkSendData>
                         &USBH_MSC_CBWData.CBWArray[0], 
                         USBH_MSC_BOT_CBW_PACKET_LENGTH , 
                         MSC_Machine.hc_num_out);
      
      USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_SEND_CBW;
 800468c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004690:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004694:	f04f 0201 	mov.w	r2, #1
 8004698:	715a      	strb	r2, [r3, #5]
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SENT_CBW;
 800469a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800469e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046a2:	f04f 0202 	mov.w	r2, #2
 80046a6:	711a      	strb	r2, [r3, #4]
      
      break;
 80046a8:	e2a3      	b.n	8004bf2 <USBH_MSC_HandleBOTXfer+0x5da>
      
    case USBH_MSC_SENT_CBW:
      URB_Status = HCD_GetURB_State(pdev , MSC_Machine.hc_num_out);
 80046aa:	f244 1320 	movw	r3, #16672	; 0x4120
 80046ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046b2:	785b      	ldrb	r3, [r3, #1]
 80046b4:	6878      	ldr	r0, [r7, #4]
 80046b6:	4619      	mov	r1, r3
 80046b8:	f7fc ffd4 	bl	8001664 <HCD_GetURB_State>
 80046bc:	4603      	mov	r3, r0
 80046be:	73bb      	strb	r3, [r7, #14]
      
      if(URB_Status == URB_DONE)
 80046c0:	7bbb      	ldrb	r3, [r7, #14]
 80046c2:	2b01      	cmp	r3, #1
 80046c4:	d14b      	bne.n	800475e <USBH_MSC_HandleBOTXfer+0x146>
      { 
        BOTStallErrorCount = 0;
 80046c6:	f640 13f0 	movw	r3, #2544	; 0x9f0
 80046ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046ce:	f04f 0200 	mov.w	r2, #0
 80046d2:	601a      	str	r2, [r3, #0]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_SENT_CBW; 
 80046d4:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80046d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046dc:	f04f 0202 	mov.w	r2, #2
 80046e0:	715a      	strb	r2, [r3, #5]
        
        /* If the CBW Pkt is sent successful, then change the state */
        xferDirection = (USBH_MSC_CBWData.field.CBWFlags & USB_REQ_DIR_MASK);
 80046e2:	f244 1300 	movw	r3, #16640	; 0x4100
 80046e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046ea:	7b1b      	ldrb	r3, [r3, #12]
 80046ec:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80046f0:	737b      	strb	r3, [r7, #13]
        
        if ( USBH_MSC_CBWData.field.CBWTransferLength != 0 )
 80046f2:	f244 1300 	movw	r3, #16640	; 0x4100
 80046f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046fa:	689b      	ldr	r3, [r3, #8]
 80046fc:	2b00      	cmp	r3, #0
 80046fe:	d026      	beq.n	800474e <USBH_MSC_HandleBOTXfer+0x136>
        {
          remainingDataLength = USBH_MSC_CBWData.field.CBWTransferLength ;
 8004700:	f244 1300 	movw	r3, #16640	; 0x4100
 8004704:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004708:	689a      	ldr	r2, [r3, #8]
 800470a:	f640 13f4 	movw	r3, #2548	; 0x9f4
 800470e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004712:	601a      	str	r2, [r3, #0]
          datapointer = USBH_MSC_BOTXferParam.pRxTxBuff;
 8004714:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004718:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800471c:	689a      	ldr	r2, [r3, #8]
 800471e:	f640 13f8 	movw	r3, #2552	; 0x9f8
 8004722:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004726:	601a      	str	r2, [r3, #0]
          
          /* If there is Data Transfer Stage */
          if (xferDirection == USB_D2H)
 8004728:	7b7b      	ldrb	r3, [r7, #13]
 800472a:	2b80      	cmp	r3, #128	; 0x80
 800472c:	d107      	bne.n	800473e <USBH_MSC_HandleBOTXfer+0x126>
          {
            /* Data Direction is IN */
            USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_DATAIN_STATE;
 800472e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004732:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004736:	f04f 0203 	mov.w	r2, #3
 800473a:	711a      	strb	r2, [r3, #4]
      else if(URB_Status == URB_STALL)
      {
        error_direction = USBH_MSC_DIR_OUT;
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
      }
      break;
 800473c:	e24e      	b.n	8004bdc <USBH_MSC_HandleBOTXfer+0x5c4>
            USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_DATAIN_STATE;
          }
          else
          {
            /* Data Direction is OUT */
            USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_DATAOUT_STATE;
 800473e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004742:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004746:	f04f 0204 	mov.w	r2, #4
 800474a:	711a      	strb	r2, [r3, #4]
      else if(URB_Status == URB_STALL)
      {
        error_direction = USBH_MSC_DIR_OUT;
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
      }
      break;
 800474c:	e246      	b.n	8004bdc <USBH_MSC_HandleBOTXfer+0x5c4>
          } 
        }
        
        else
        {/* If there is NO Data Transfer Stage */
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
 800474e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004752:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004756:	f04f 0205 	mov.w	r2, #5
 800475a:	711a      	strb	r2, [r3, #4]
      else if(URB_Status == URB_STALL)
      {
        error_direction = USBH_MSC_DIR_OUT;
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
      }
      break;
 800475c:	e23e      	b.n	8004bdc <USBH_MSC_HandleBOTXfer+0x5c4>
        {/* If there is NO Data Transfer Stage */
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
        }
        
      }   
      else if(URB_Status == URB_NOTREADY)
 800475e:	7bbb      	ldrb	r3, [r7, #14]
 8004760:	2b02      	cmp	r3, #2
 8004762:	d10a      	bne.n	800477a <USBH_MSC_HandleBOTXfer+0x162>
      {
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOTXferParam.BOTStateBkp;    
 8004764:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004768:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800476c:	795a      	ldrb	r2, [r3, #5]
 800476e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004772:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004776:	711a      	strb	r2, [r3, #4]
      else if(URB_Status == URB_STALL)
      {
        error_direction = USBH_MSC_DIR_OUT;
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
      }
      break;
 8004778:	e230      	b.n	8004bdc <USBH_MSC_HandleBOTXfer+0x5c4>
      }   
      else if(URB_Status == URB_NOTREADY)
      {
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOTXferParam.BOTStateBkp;    
      }     
      else if(URB_Status == URB_STALL)
 800477a:	7bbb      	ldrb	r3, [r7, #14]
 800477c:	2b04      	cmp	r3, #4
 800477e:	f040 822d 	bne.w	8004bdc <USBH_MSC_HandleBOTXfer+0x5c4>
      {
        error_direction = USBH_MSC_DIR_OUT;
 8004782:	f640 13fc 	movw	r3, #2556	; 0x9fc
 8004786:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800478a:	f04f 0201 	mov.w	r2, #1
 800478e:	701a      	strb	r2, [r3, #0]
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
 8004790:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004794:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004798:	f04f 0208 	mov.w	r2, #8
 800479c:	711a      	strb	r2, [r3, #4]
      }
      break;
 800479e:	e21d      	b.n	8004bdc <USBH_MSC_HandleBOTXfer+0x5c4>
      
    case USBH_MSC_BOT_DATAIN_STATE:
      
      URB_Status =   HCD_GetURB_State(pdev , MSC_Machine.hc_num_in);
 80047a0:	f244 1320 	movw	r3, #16672	; 0x4120
 80047a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047a8:	781b      	ldrb	r3, [r3, #0]
 80047aa:	6878      	ldr	r0, [r7, #4]
 80047ac:	4619      	mov	r1, r3
 80047ae:	f7fc ff59 	bl	8001664 <HCD_GetURB_State>
 80047b2:	4603      	mov	r3, r0
 80047b4:	73bb      	strb	r3, [r7, #14]
      /* BOT DATA IN stage */
      if((URB_Status == URB_DONE) ||(USBH_MSC_BOTXferParam.BOTStateBkp != USBH_MSC_BOT_DATAIN_STATE))
 80047b6:	7bbb      	ldrb	r3, [r7, #14]
 80047b8:	2b01      	cmp	r3, #1
 80047ba:	d006      	beq.n	80047ca <USBH_MSC_HandleBOTXfer+0x1b2>
 80047bc:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80047c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047c4:	795b      	ldrb	r3, [r3, #5]
 80047c6:	2b03      	cmp	r3, #3
 80047c8:	d067      	beq.n	800489a <USBH_MSC_HandleBOTXfer+0x282>
      {
        BOTStallErrorCount = 0;
 80047ca:	f640 13f0 	movw	r3, #2544	; 0x9f0
 80047ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047d2:	f04f 0200 	mov.w	r2, #0
 80047d6:	601a      	str	r2, [r3, #0]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAIN_STATE;    
 80047d8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80047dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047e0:	f04f 0203 	mov.w	r2, #3
 80047e4:	715a      	strb	r2, [r3, #5]
        
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 80047e6:	f640 13f4 	movw	r3, #2548	; 0x9f4
 80047ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047ee:	681b      	ldr	r3, [r3, #0]
 80047f0:	2b40      	cmp	r3, #64	; 0x40
 80047f2:	d928      	bls.n	8004846 <USBH_MSC_HandleBOTXfer+0x22e>
        {
          USBH_BulkReceiveData (pdev,
 80047f4:	f640 13f8 	movw	r3, #2552	; 0x9f8
 80047f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047fc:	681a      	ldr	r2, [r3, #0]
 80047fe:	f244 1320 	movw	r3, #16672	; 0x4120
 8004802:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004806:	781b      	ldrb	r3, [r3, #0]
 8004808:	6878      	ldr	r0, [r7, #4]
 800480a:	4611      	mov	r1, r2
 800480c:	f04f 0240 	mov.w	r2, #64	; 0x40
 8004810:	f7ff fa54 	bl	8003cbc <USBH_BulkReceiveData>
	                        datapointer, 
			        USBH_MSC_MPS_SIZE , 
			        MSC_Machine.hc_num_in);
          
          remainingDataLength -= USBH_MSC_MPS_SIZE;
 8004814:	f640 13f4 	movw	r3, #2548	; 0x9f4
 8004818:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800481c:	681b      	ldr	r3, [r3, #0]
 800481e:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
 8004822:	f640 13f4 	movw	r3, #2548	; 0x9f4
 8004826:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800482a:	601a      	str	r2, [r3, #0]
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
 800482c:	f640 13f8 	movw	r3, #2552	; 0x9f8
 8004830:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004834:	681b      	ldr	r3, [r3, #0]
 8004836:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800483a:	f640 13f8 	movw	r3, #2552	; 0x9f8
 800483e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004842:	601a      	str	r2, [r3, #0]
      if((URB_Status == URB_DONE) ||(USBH_MSC_BOTXferParam.BOTStateBkp != USBH_MSC_BOT_DATAIN_STATE))
      {
        BOTStallErrorCount = 0;
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAIN_STATE;    
        
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 8004844:	e043      	b.n	80048ce <USBH_MSC_HandleBOTXfer+0x2b6>
			        MSC_Machine.hc_num_in);
          
          remainingDataLength -= USBH_MSC_MPS_SIZE;
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
        }
        else if ( remainingDataLength == 0)
 8004846:	f640 13f4 	movw	r3, #2548	; 0x9f4
 800484a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800484e:	681b      	ldr	r3, [r3, #0]
 8004850:	2b00      	cmp	r3, #0
 8004852:	d107      	bne.n	8004864 <USBH_MSC_HandleBOTXfer+0x24c>
        {
          /* If value was 0, and successful transfer, then change the state */
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
 8004854:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004858:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800485c:	f04f 0205 	mov.w	r2, #5
 8004860:	711a      	strb	r2, [r3, #4]
      if((URB_Status == URB_DONE) ||(USBH_MSC_BOTXferParam.BOTStateBkp != USBH_MSC_BOT_DATAIN_STATE))
      {
        BOTStallErrorCount = 0;
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAIN_STATE;    
        
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 8004862:	e034      	b.n	80048ce <USBH_MSC_HandleBOTXfer+0x2b6>
          /* If value was 0, and successful transfer, then change the state */
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
        }
        else
        {       
          USBH_BulkReceiveData (pdev,
 8004864:	f640 13f8 	movw	r3, #2552	; 0x9f8
 8004868:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800486c:	6819      	ldr	r1, [r3, #0]
 800486e:	f640 13f4 	movw	r3, #2548	; 0x9f4
 8004872:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004876:	681b      	ldr	r3, [r3, #0]
 8004878:	b29a      	uxth	r2, r3
 800487a:	f244 1320 	movw	r3, #16672	; 0x4120
 800487e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004882:	781b      	ldrb	r3, [r3, #0]
 8004884:	6878      	ldr	r0, [r7, #4]
 8004886:	f7ff fa19 	bl	8003cbc <USBH_BulkReceiveData>
	                        datapointer, 
			        remainingDataLength , 
			        MSC_Machine.hc_num_in);
          
          remainingDataLength = 0; /* Reset this value and keep in same state */
 800488a:	f640 13f4 	movw	r3, #2548	; 0x9f4
 800488e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004892:	f04f 0200 	mov.w	r2, #0
 8004896:	601a      	str	r2, [r3, #0]
      if((URB_Status == URB_DONE) ||(USBH_MSC_BOTXferParam.BOTStateBkp != USBH_MSC_BOT_DATAIN_STATE))
      {
        BOTStallErrorCount = 0;
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAIN_STATE;    
        
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 8004898:	e019      	b.n	80048ce <USBH_MSC_HandleBOTXfer+0x2b6>
			        MSC_Machine.hc_num_in);
          
          remainingDataLength = 0; /* Reset this value and keep in same state */
        }
      }
      else if(URB_Status == URB_STALL)
 800489a:	7bbb      	ldrb	r3, [r7, #14]
 800489c:	2b04      	cmp	r3, #4
 800489e:	f040 819f 	bne.w	8004be0 <USBH_MSC_HandleBOTXfer+0x5c8>
      {
        /* This is Data Stage STALL Condition */
        
        error_direction = USBH_MSC_DIR_IN;
 80048a2:	f640 13fc 	movw	r3, #2556	; 0x9fc
 80048a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048aa:	f04f 0200 	mov.w	r2, #0
 80048ae:	701a      	strb	r2, [r3, #0]
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
 80048b0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80048b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048b8:	f04f 0207 	mov.w	r2, #7
 80048bc:	711a      	strb	r2, [r3, #4]
        4. The host shall attempt to receive a CSW.
        
        USBH_MSC_BOTXferParam.BOTStateBkp is used to switch to the Original 
        state after the ClearFeature Command is issued.
        */
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 80048be:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80048c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048c6:	f04f 0205 	mov.w	r2, #5
 80048ca:	715a      	strb	r2, [r3, #5]
        
      }     
      break;   
 80048cc:	e188      	b.n	8004be0 <USBH_MSC_HandleBOTXfer+0x5c8>
 80048ce:	e187      	b.n	8004be0 <USBH_MSC_HandleBOTXfer+0x5c8>
      
      
    case USBH_MSC_BOT_DATAOUT_STATE:
      /* BOT DATA OUT stage */
      URB_Status = HCD_GetURB_State(pdev , MSC_Machine.hc_num_out);       
 80048d0:	f244 1320 	movw	r3, #16672	; 0x4120
 80048d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048d8:	785b      	ldrb	r3, [r3, #1]
 80048da:	6878      	ldr	r0, [r7, #4]
 80048dc:	4619      	mov	r1, r3
 80048de:	f7fc fec1 	bl	8001664 <HCD_GetURB_State>
 80048e2:	4603      	mov	r3, r0
 80048e4:	73bb      	strb	r3, [r7, #14]
      if(URB_Status == URB_DONE)
 80048e6:	7bbb      	ldrb	r3, [r7, #14]
 80048e8:	2b01      	cmp	r3, #1
 80048ea:	d167      	bne.n	80049bc <USBH_MSC_HandleBOTXfer+0x3a4>
      {
        BOTStallErrorCount = 0;
 80048ec:	f640 13f0 	movw	r3, #2544	; 0x9f0
 80048f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048f4:	f04f 0200 	mov.w	r2, #0
 80048f8:	601a      	str	r2, [r3, #0]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAOUT_STATE;    
 80048fa:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80048fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004902:	f04f 0204 	mov.w	r2, #4
 8004906:	715a      	strb	r2, [r3, #5]
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 8004908:	f640 13f4 	movw	r3, #2548	; 0x9f4
 800490c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004910:	681b      	ldr	r3, [r3, #0]
 8004912:	2b40      	cmp	r3, #64	; 0x40
 8004914:	d928      	bls.n	8004968 <USBH_MSC_HandleBOTXfer+0x350>
        {
          USBH_BulkSendData (pdev,
 8004916:	f640 13f8 	movw	r3, #2552	; 0x9f8
 800491a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800491e:	681a      	ldr	r2, [r3, #0]
 8004920:	f244 1320 	movw	r3, #16672	; 0x4120
 8004924:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004928:	785b      	ldrb	r3, [r3, #1]
 800492a:	6878      	ldr	r0, [r7, #4]
 800492c:	4611      	mov	r1, r2
 800492e:	f04f 0240 	mov.w	r2, #64	; 0x40
 8004932:	f7ff f96f 	bl	8003c14 <USBH_BulkSendData>
                             datapointer, 
                             USBH_MSC_MPS_SIZE , 
                             MSC_Machine.hc_num_out);
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
 8004936:	f640 13f8 	movw	r3, #2552	; 0x9f8
 800493a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800493e:	681b      	ldr	r3, [r3, #0]
 8004940:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8004944:	f640 13f8 	movw	r3, #2552	; 0x9f8
 8004948:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800494c:	601a      	str	r2, [r3, #0]
          remainingDataLength = remainingDataLength - USBH_MSC_MPS_SIZE;
 800494e:	f640 13f4 	movw	r3, #2548	; 0x9f4
 8004952:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004956:	681b      	ldr	r3, [r3, #0]
 8004958:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
 800495c:	f640 13f4 	movw	r3, #2548	; 0x9f4
 8004960:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004964:	601a      	str	r2, [r3, #0]
        */
        
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
        
      }
      break;
 8004966:	e13d      	b.n	8004be4 <USBH_MSC_HandleBOTXfer+0x5cc>
                             USBH_MSC_MPS_SIZE , 
                             MSC_Machine.hc_num_out);
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
          remainingDataLength = remainingDataLength - USBH_MSC_MPS_SIZE;
        }
        else if ( remainingDataLength == 0)
 8004968:	f640 13f4 	movw	r3, #2548	; 0x9f4
 800496c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004970:	681b      	ldr	r3, [r3, #0]
 8004972:	2b00      	cmp	r3, #0
 8004974:	d107      	bne.n	8004986 <USBH_MSC_HandleBOTXfer+0x36e>
        {
          /* If value was 0, and successful transfer, then change the state */
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
 8004976:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800497a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800497e:	f04f 0205 	mov.w	r2, #5
 8004982:	711a      	strb	r2, [r3, #4]
        */
        
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
        
      }
      break;
 8004984:	e12e      	b.n	8004be4 <USBH_MSC_HandleBOTXfer+0x5cc>
          /* If value was 0, and successful transfer, then change the state */
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
        }
        else
        {
          USBH_BulkSendData (pdev,
 8004986:	f640 13f8 	movw	r3, #2552	; 0x9f8
 800498a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800498e:	6819      	ldr	r1, [r3, #0]
 8004990:	f640 13f4 	movw	r3, #2548	; 0x9f4
 8004994:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004998:	681b      	ldr	r3, [r3, #0]
 800499a:	b29a      	uxth	r2, r3
 800499c:	f244 1320 	movw	r3, #16672	; 0x4120
 80049a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049a4:	785b      	ldrb	r3, [r3, #1]
 80049a6:	6878      	ldr	r0, [r7, #4]
 80049a8:	f7ff f934 	bl	8003c14 <USBH_BulkSendData>
	                     datapointer, 
			     remainingDataLength , 
			     MSC_Machine.hc_num_out);
          
          remainingDataLength = 0; /* Reset this value and keep in same state */   
 80049ac:	f640 13f4 	movw	r3, #2548	; 0x9f4
 80049b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049b4:	f04f 0200 	mov.w	r2, #0
 80049b8:	601a      	str	r2, [r3, #0]
        */
        
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
        
      }
      break;
 80049ba:	e113      	b.n	8004be4 <USBH_MSC_HandleBOTXfer+0x5cc>
          
          remainingDataLength = 0; /* Reset this value and keep in same state */   
        }      
      }
      
      else if(URB_Status == URB_NOTREADY)
 80049bc:	7bbb      	ldrb	r3, [r7, #14]
 80049be:	2b02      	cmp	r3, #2
 80049c0:	d112      	bne.n	80049e8 <USBH_MSC_HandleBOTXfer+0x3d0>
      {
        USBH_BulkSendData (pdev,
 80049c2:	f640 13f8 	movw	r3, #2552	; 0x9f8
 80049c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049ca:	681b      	ldr	r3, [r3, #0]
 80049cc:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
 80049d0:	f244 1320 	movw	r3, #16672	; 0x4120
 80049d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049d8:	785b      	ldrb	r3, [r3, #1]
 80049da:	6878      	ldr	r0, [r7, #4]
 80049dc:	4611      	mov	r1, r2
 80049de:	f04f 0240 	mov.w	r2, #64	; 0x40
 80049e2:	f7ff f917 	bl	8003c14 <USBH_BulkSendData>
        */
        
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
        
      }
      break;
 80049e6:	e0fd      	b.n	8004be4 <USBH_MSC_HandleBOTXfer+0x5cc>
	                   (datapointer - USBH_MSC_MPS_SIZE), 
			   USBH_MSC_MPS_SIZE , 
			   MSC_Machine.hc_num_out);
      }
      
      else if(URB_Status == URB_STALL)
 80049e8:	7bbb      	ldrb	r3, [r7, #14]
 80049ea:	2b04      	cmp	r3, #4
 80049ec:	f040 80fa 	bne.w	8004be4 <USBH_MSC_HandleBOTXfer+0x5cc>
      {
        error_direction = USBH_MSC_DIR_OUT;
 80049f0:	f640 13fc 	movw	r3, #2556	; 0x9fc
 80049f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049f8:	f04f 0201 	mov.w	r2, #1
 80049fc:	701a      	strb	r2, [r3, #0]
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
 80049fe:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004a02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a06:	f04f 0208 	mov.w	r2, #8
 8004a0a:	711a      	strb	r2, [r3, #4]
        
        USBH_MSC_BOTXferParam.BOTStateBkp is used to switch to the Original 
        state after the ClearFeature Command is issued.
        */
        
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 8004a0c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004a10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a14:	f04f 0205 	mov.w	r2, #5
 8004a18:	715a      	strb	r2, [r3, #5]
        
      }
      break;
 8004a1a:	e0e3      	b.n	8004be4 <USBH_MSC_HandleBOTXfer+0x5cc>
    case USBH_MSC_RECEIVE_CSW_STATE:
      /* BOT CSW stage */     
        /* NOTE: We cannot reset the BOTStallErrorCount here as it may come from 
        the clearFeature from previous command */
        
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 8004a1c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004a20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a24:	f04f 0205 	mov.w	r2, #5
 8004a28:	715a      	strb	r2, [r3, #5]
        
        USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
 8004a2a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004a2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a32:	f244 02e0 	movw	r2, #16608	; 0x40e0
 8004a36:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004a3a:	609a      	str	r2, [r3, #8]
        USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
 8004a3c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004a40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a44:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8004a48:	819a      	strh	r2, [r3, #12]
        
        for(index = USBH_MSC_CSW_LENGTH; index != 0; index--)
 8004a4a:	f04f 030d 	mov.w	r3, #13
 8004a4e:	73fb      	strb	r3, [r7, #15]
 8004a50:	e00b      	b.n	8004a6a <USBH_MSC_HandleBOTXfer+0x452>
        {
          USBH_MSC_CSWData.CSWArray[index] = 0;
 8004a52:	7bfa      	ldrb	r2, [r7, #15]
 8004a54:	f244 03e0 	movw	r3, #16608	; 0x40e0
 8004a58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a5c:	f04f 0100 	mov.w	r1, #0
 8004a60:	5499      	strb	r1, [r3, r2]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
        
        USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
        USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
        
        for(index = USBH_MSC_CSW_LENGTH; index != 0; index--)
 8004a62:	7bfb      	ldrb	r3, [r7, #15]
 8004a64:	f103 33ff 	add.w	r3, r3, #4294967295
 8004a68:	73fb      	strb	r3, [r7, #15]
 8004a6a:	7bfb      	ldrb	r3, [r7, #15]
 8004a6c:	2b00      	cmp	r3, #0
 8004a6e:	d1f0      	bne.n	8004a52 <USBH_MSC_HandleBOTXfer+0x43a>
        {
          USBH_MSC_CSWData.CSWArray[index] = 0;
        }
        
        USBH_MSC_CSWData.CSWArray[0] = 0;
 8004a70:	f244 03e0 	movw	r3, #16608	; 0x40e0
 8004a74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a78:	f04f 0200 	mov.w	r2, #0
 8004a7c:	701a      	strb	r2, [r3, #0]
        
        USBH_BulkReceiveData (pdev,
 8004a7e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004a82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a86:	689a      	ldr	r2, [r3, #8]
 8004a88:	f244 1320 	movw	r3, #16672	; 0x4120
 8004a8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a90:	781b      	ldrb	r3, [r3, #0]
 8004a92:	6878      	ldr	r0, [r7, #4]
 8004a94:	4611      	mov	r1, r2
 8004a96:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8004a9a:	f7ff f90f 	bl	8003cbc <USBH_BulkReceiveData>
                              USBH_MSC_BOTXferParam.pRxTxBuff, 
                              USBH_MSC_CSW_MAX_LENGTH , 
                              MSC_Machine.hc_num_in);
        USBH_MSC_BOTXferParam.BOTState = USBH_MSC_DECODE_CSW;    
 8004a9e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004aa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004aa6:	f04f 0206 	mov.w	r2, #6
 8004aaa:	711a      	strb	r2, [r3, #4]

      break;
 8004aac:	e0a1      	b.n	8004bf2 <USBH_MSC_HandleBOTXfer+0x5da>
      
    case USBH_MSC_DECODE_CSW:
      URB_Status = HCD_GetURB_State(pdev , MSC_Machine.hc_num_in);
 8004aae:	f244 1320 	movw	r3, #16672	; 0x4120
 8004ab2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ab6:	781b      	ldrb	r3, [r3, #0]
 8004ab8:	6878      	ldr	r0, [r7, #4]
 8004aba:	4619      	mov	r1, r3
 8004abc:	f7fc fdd2 	bl	8001664 <HCD_GetURB_State>
 8004ac0:	4603      	mov	r3, r0
 8004ac2:	73bb      	strb	r3, [r7, #14]
      /* Decode CSW */
      if(URB_Status == URB_DONE)
 8004ac4:	7bbb      	ldrb	r3, [r7, #14]
 8004ac6:	2b01      	cmp	r3, #1
 8004ac8:	d123      	bne.n	8004b12 <USBH_MSC_HandleBOTXfer+0x4fa>
      {
        BOTStallErrorCount = 0;
 8004aca:	f640 13f0 	movw	r3, #2544	; 0x9f0
 8004ace:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ad2:	f04f 0200 	mov.w	r2, #0
 8004ad6:	601a      	str	r2, [r3, #0]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 8004ad8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004adc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ae0:	f04f 0205 	mov.w	r2, #5
 8004ae4:	715a      	strb	r2, [r3, #5]
        
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateCurrent ;
 8004ae6:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004aea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004aee:	789a      	ldrb	r2, [r3, #2]
 8004af0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004af8:	701a      	strb	r2, [r3, #0]
        
        USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_DecodeCSW(pdev , phost);
 8004afa:	6878      	ldr	r0, [r7, #4]
 8004afc:	6839      	ldr	r1, [r7, #0]
 8004afe:	f000 f8cd 	bl	8004c9c <USBH_MSC_DecodeCSW>
 8004b02:	4603      	mov	r3, r0
 8004b04:	461a      	mov	r2, r3
 8004b06:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004b0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b0e:	73da      	strb	r2, [r3, #15]
      else if(URB_Status == URB_STALL)     
      {
        error_direction = USBH_MSC_DIR_IN;
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
      }
      break;
 8004b10:	e06a      	b.n	8004be8 <USBH_MSC_HandleBOTXfer+0x5d0>
        
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateCurrent ;
        
        USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_DecodeCSW(pdev , phost);
      }
      else if(URB_Status == URB_STALL)     
 8004b12:	7bbb      	ldrb	r3, [r7, #14]
 8004b14:	2b04      	cmp	r3, #4
 8004b16:	d167      	bne.n	8004be8 <USBH_MSC_HandleBOTXfer+0x5d0>
      {
        error_direction = USBH_MSC_DIR_IN;
 8004b18:	f640 13fc 	movw	r3, #2556	; 0x9fc
 8004b1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b20:	f04f 0200 	mov.w	r2, #0
 8004b24:	701a      	strb	r2, [r3, #0]
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
 8004b26:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004b2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b2e:	f04f 0207 	mov.w	r2, #7
 8004b32:	711a      	strb	r2, [r3, #4]
      }
      break;
 8004b34:	e058      	b.n	8004be8 <USBH_MSC_HandleBOTXfer+0x5d0>
      
    case USBH_MSC_BOT_ERROR_IN: 
      status = USBH_MSC_BOT_Abort(pdev, phost, USBH_MSC_DIR_IN);
 8004b36:	6878      	ldr	r0, [r7, #4]
 8004b38:	6839      	ldr	r1, [r7, #0]
 8004b3a:	f04f 0200 	mov.w	r2, #0
 8004b3e:	f000 f85d 	bl	8004bfc <USBH_MSC_BOT_Abort>
 8004b42:	4603      	mov	r3, r0
 8004b44:	733b      	strb	r3, [r7, #12]
      if (status == USBH_OK)
 8004b46:	7b3b      	ldrb	r3, [r7, #12]
 8004b48:	2b00      	cmp	r3, #0
 8004b4a:	d119      	bne.n	8004b80 <USBH_MSC_HandleBOTXfer+0x568>
      {
        /* Check if the error was due in Both the directions */
        if (error_direction == USBH_MSC_BOTH_DIR)
 8004b4c:	f640 13fc 	movw	r3, #2556	; 0x9fc
 8004b50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b54:	781b      	ldrb	r3, [r3, #0]
 8004b56:	2b02      	cmp	r3, #2
 8004b58:	d107      	bne.n	8004b6a <USBH_MSC_HandleBOTXfer+0x552>
        {/* If Both directions are Needed, Switch to OUT Direction */
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_ERROR_OUT;
 8004b5a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004b5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b62:	f04f 0208 	mov.w	r2, #8
 8004b66:	711a      	strb	r2, [r3, #4]
      else if (status == USBH_UNRECOVERED_ERROR)
      {
        /* This means that there is a STALL Error limit, Do Reset Recovery */
        USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_PHASE_ERROR;
      }
      break;
 8004b68:	e040      	b.n	8004bec <USBH_MSC_HandleBOTXfer+0x5d4>
        }
        else
        {
          /* Switch Back to the Original State, In many cases this will be 
          USBH_MSC_RECEIVE_CSW_STATE state */
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOTXferParam.BOTStateBkp;
 8004b6a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004b6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b72:	795a      	ldrb	r2, [r3, #5]
 8004b74:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004b78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b7c:	711a      	strb	r2, [r3, #4]
      else if (status == USBH_UNRECOVERED_ERROR)
      {
        /* This means that there is a STALL Error limit, Do Reset Recovery */
        USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_PHASE_ERROR;
      }
      break;
 8004b7e:	e035      	b.n	8004bec <USBH_MSC_HandleBOTXfer+0x5d4>
          /* Switch Back to the Original State, In many cases this will be 
          USBH_MSC_RECEIVE_CSW_STATE state */
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOTXferParam.BOTStateBkp;
        }
      }
      else if (status == USBH_UNRECOVERED_ERROR)
 8004b80:	7b3b      	ldrb	r3, [r7, #12]
 8004b82:	2b04      	cmp	r3, #4
 8004b84:	d132      	bne.n	8004bec <USBH_MSC_HandleBOTXfer+0x5d4>
      {
        /* This means that there is a STALL Error limit, Do Reset Recovery */
        USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_PHASE_ERROR;
 8004b86:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004b8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b8e:	f04f 0202 	mov.w	r2, #2
 8004b92:	73da      	strb	r2, [r3, #15]
      }
      break;
 8004b94:	e02a      	b.n	8004bec <USBH_MSC_HandleBOTXfer+0x5d4>
      
    case USBH_MSC_BOT_ERROR_OUT: 
      status = USBH_MSC_BOT_Abort(pdev, phost, USBH_MSC_DIR_OUT);
 8004b96:	6878      	ldr	r0, [r7, #4]
 8004b98:	6839      	ldr	r1, [r7, #0]
 8004b9a:	f04f 0201 	mov.w	r2, #1
 8004b9e:	f000 f82d 	bl	8004bfc <USBH_MSC_BOT_Abort>
 8004ba2:	4603      	mov	r3, r0
 8004ba4:	733b      	strb	r3, [r7, #12]
      if ( status == USBH_OK)
 8004ba6:	7b3b      	ldrb	r3, [r7, #12]
 8004ba8:	2b00      	cmp	r3, #0
 8004baa:	d10a      	bne.n	8004bc2 <USBH_MSC_HandleBOTXfer+0x5aa>
      { /* Switch Back to the Original State */
        USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOTXferParam.BOTStateBkp;        
 8004bac:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004bb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004bb4:	795a      	ldrb	r2, [r3, #5]
 8004bb6:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004bbe:	711a      	strb	r2, [r3, #4]
      else if (status == USBH_UNRECOVERED_ERROR)
      {
        /* This means that there is a STALL Error limit, Do Reset Recovery */
        USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_PHASE_ERROR;
      }
      break;
 8004bc0:	e016      	b.n	8004bf0 <USBH_MSC_HandleBOTXfer+0x5d8>
      status = USBH_MSC_BOT_Abort(pdev, phost, USBH_MSC_DIR_OUT);
      if ( status == USBH_OK)
      { /* Switch Back to the Original State */
        USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOTXferParam.BOTStateBkp;        
      }
      else if (status == USBH_UNRECOVERED_ERROR)
 8004bc2:	7b3b      	ldrb	r3, [r7, #12]
 8004bc4:	2b04      	cmp	r3, #4
 8004bc6:	d113      	bne.n	8004bf0 <USBH_MSC_HandleBOTXfer+0x5d8>
      {
        /* This means that there is a STALL Error limit, Do Reset Recovery */
        USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_PHASE_ERROR;
 8004bc8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004bcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004bd0:	f04f 0202 	mov.w	r2, #2
 8004bd4:	73da      	strb	r2, [r3, #15]
      }
      break;
 8004bd6:	e00b      	b.n	8004bf0 <USBH_MSC_HandleBOTXfer+0x5d8>
      
    default:      
      break;
 8004bd8:	bf00      	nop
 8004bda:	e00a      	b.n	8004bf2 <USBH_MSC_HandleBOTXfer+0x5da>
      else if(URB_Status == URB_STALL)
      {
        error_direction = USBH_MSC_DIR_OUT;
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
      }
      break;
 8004bdc:	bf00      	nop
 8004bde:	e008      	b.n	8004bf2 <USBH_MSC_HandleBOTXfer+0x5da>
        state after the ClearFeature Command is issued.
        */
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
        
      }     
      break;   
 8004be0:	bf00      	nop
 8004be2:	e006      	b.n	8004bf2 <USBH_MSC_HandleBOTXfer+0x5da>
        */
        
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
        
      }
      break;
 8004be4:	bf00      	nop
 8004be6:	e004      	b.n	8004bf2 <USBH_MSC_HandleBOTXfer+0x5da>
      else if(URB_Status == URB_STALL)     
      {
        error_direction = USBH_MSC_DIR_IN;
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
      }
      break;
 8004be8:	bf00      	nop
 8004bea:	e002      	b.n	8004bf2 <USBH_MSC_HandleBOTXfer+0x5da>
      else if (status == USBH_UNRECOVERED_ERROR)
      {
        /* This means that there is a STALL Error limit, Do Reset Recovery */
        USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_PHASE_ERROR;
      }
      break;
 8004bec:	bf00      	nop
 8004bee:	e000      	b.n	8004bf2 <USBH_MSC_HandleBOTXfer+0x5da>
      else if (status == USBH_UNRECOVERED_ERROR)
      {
        /* This means that there is a STALL Error limit, Do Reset Recovery */
        USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_PHASE_ERROR;
      }
      break;
 8004bf0:	bf00      	nop
      
    default:      
      break;
    }
  }
}
 8004bf2:	f107 0710 	add.w	r7, r7, #16
 8004bf6:	46bd      	mov	sp, r7
 8004bf8:	bd80      	pop	{r7, pc}
 8004bfa:	bf00      	nop

08004bfc <USBH_MSC_BOT_Abort>:
* @retval None
*/
USBH_Status USBH_MSC_BOT_Abort(USB_OTG_CORE_HANDLE *pdev, 
                               USBH_HOST *phost,
                               uint8_t direction)
{
 8004bfc:	b580      	push	{r7, lr}
 8004bfe:	b086      	sub	sp, #24
 8004c00:	af00      	add	r7, sp, #0
 8004c02:	60f8      	str	r0, [r7, #12]
 8004c04:	60b9      	str	r1, [r7, #8]
 8004c06:	4613      	mov	r3, r2
 8004c08:	71fb      	strb	r3, [r7, #7]
  USBH_Status status;
  
  status = USBH_BUSY;
 8004c0a:	f04f 0301 	mov.w	r3, #1
 8004c0e:	75fb      	strb	r3, [r7, #23]
  
  switch (direction)
 8004c10:	79fb      	ldrb	r3, [r7, #7]
 8004c12:	2b00      	cmp	r3, #0
 8004c14:	d002      	beq.n	8004c1c <USBH_MSC_BOT_Abort+0x20>
 8004c16:	2b01      	cmp	r3, #1
 8004c18:	d011      	beq.n	8004c3e <USBH_MSC_BOT_Abort+0x42>
 8004c1a:	e021      	b.n	8004c60 <USBH_MSC_BOT_Abort+0x64>
  {
  case USBH_MSC_DIR_IN :
    /* send ClrFeture on Bulk IN endpoint */
    status = USBH_ClrFeature(pdev,
 8004c1c:	f244 1320 	movw	r3, #16672	; 0x4120
 8004c20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c24:	78da      	ldrb	r2, [r3, #3]
 8004c26:	f244 1320 	movw	r3, #16672	; 0x4120
 8004c2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c2e:	781b      	ldrb	r3, [r3, #0]
 8004c30:	68f8      	ldr	r0, [r7, #12]
 8004c32:	68b9      	ldr	r1, [r7, #8]
 8004c34:	f7ff fa98 	bl	8004168 <USBH_ClrFeature>
 8004c38:	4603      	mov	r3, r0
 8004c3a:	75fb      	strb	r3, [r7, #23]
                             phost,
                             MSC_Machine.MSBulkInEp,
                             MSC_Machine.hc_num_in);
    
    break;
 8004c3c:	e011      	b.n	8004c62 <USBH_MSC_BOT_Abort+0x66>
    
  case USBH_MSC_DIR_OUT :
    /*send ClrFeature on Bulk OUT endpoint */
    status = USBH_ClrFeature(pdev, 
 8004c3e:	f244 1320 	movw	r3, #16672	; 0x4120
 8004c42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c46:	789a      	ldrb	r2, [r3, #2]
 8004c48:	f244 1320 	movw	r3, #16672	; 0x4120
 8004c4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c50:	785b      	ldrb	r3, [r3, #1]
 8004c52:	68f8      	ldr	r0, [r7, #12]
 8004c54:	68b9      	ldr	r1, [r7, #8]
 8004c56:	f7ff fa87 	bl	8004168 <USBH_ClrFeature>
 8004c5a:	4603      	mov	r3, r0
 8004c5c:	75fb      	strb	r3, [r7, #23]
                             phost,
                             MSC_Machine.MSBulkOutEp,
                             MSC_Machine.hc_num_out);
    break;
 8004c5e:	e000      	b.n	8004c62 <USBH_MSC_BOT_Abort+0x66>
    
  default:
    break;
 8004c60:	bf00      	nop
  }
  
  BOTStallErrorCount++; /* Check Continous Number of times, STALL has Occured */ 
 8004c62:	f640 13f0 	movw	r3, #2544	; 0x9f0
 8004c66:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c6a:	681b      	ldr	r3, [r3, #0]
 8004c6c:	f103 0201 	add.w	r2, r3, #1
 8004c70:	f640 13f0 	movw	r3, #2544	; 0x9f0
 8004c74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c78:	601a      	str	r2, [r3, #0]
  if (BOTStallErrorCount > MAX_BULK_STALL_COUNT_LIMIT )
 8004c7a:	f640 13f0 	movw	r3, #2544	; 0x9f0
 8004c7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c82:	681b      	ldr	r3, [r3, #0]
 8004c84:	2b04      	cmp	r3, #4
 8004c86:	d902      	bls.n	8004c8e <USBH_MSC_BOT_Abort+0x92>
  {
    status = USBH_UNRECOVERED_ERROR;
 8004c88:	f04f 0304 	mov.w	r3, #4
 8004c8c:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
 8004c8e:	7dfb      	ldrb	r3, [r7, #23]
}
 8004c90:	4618      	mov	r0, r3
 8004c92:	f107 0718 	add.w	r7, r7, #24
 8004c96:	46bd      	mov	sp, r7
 8004c98:	bd80      	pop	{r7, pc}
 8004c9a:	bf00      	nop

08004c9c <USBH_MSC_DecodeCSW>:
*     2. the CSW is 13 (Dh) bytes in length,
*     3. dCSWTag matches the dCBWTag from the corresponding CBW.
*/

uint8_t USBH_MSC_DecodeCSW(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
{
 8004c9c:	b580      	push	{r7, lr}
 8004c9e:	b084      	sub	sp, #16
 8004ca0:	af00      	add	r7, sp, #0
 8004ca2:	6078      	str	r0, [r7, #4]
 8004ca4:	6039      	str	r1, [r7, #0]
  uint8_t status;
  uint32_t dataXferCount = 0;
 8004ca6:	f04f 0300 	mov.w	r3, #0
 8004caa:	60bb      	str	r3, [r7, #8]
  status = USBH_MSC_FAIL;
 8004cac:	f04f 0301 	mov.w	r3, #1
 8004cb0:	73fb      	strb	r3, [r7, #15]
  
  if(HCD_IsDeviceConnected(pdev))
 8004cb2:	6878      	ldr	r0, [r7, #4]
 8004cb4:	f7fc fcb6 	bl	8001624 <HCD_IsDeviceConnected>
 8004cb8:	4603      	mov	r3, r0
 8004cba:	2b00      	cmp	r3, #0
 8004cbc:	d04c      	beq.n	8004d58 <USBH_MSC_DecodeCSW+0xbc>
  {
    /*Checking if the transfer length is diffrent than 13*/
    dataXferCount = HCD_GetXferCnt(pdev, MSC_Machine.hc_num_in); 
 8004cbe:	f244 1320 	movw	r3, #16672	; 0x4120
 8004cc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cc6:	781b      	ldrb	r3, [r3, #0]
 8004cc8:	6878      	ldr	r0, [r7, #4]
 8004cca:	4619      	mov	r1, r3
 8004ccc:	f7fc fcdc 	bl	8001688 <HCD_GetXferCnt>
 8004cd0:	4603      	mov	r3, r0
 8004cd2:	60bb      	str	r3, [r7, #8]
    
    if(dataXferCount != USBH_MSC_CSW_LENGTH)
 8004cd4:	68bb      	ldr	r3, [r7, #8]
 8004cd6:	2b0d      	cmp	r3, #13
 8004cd8:	d003      	beq.n	8004ce2 <USBH_MSC_DecodeCSW+0x46>
      Device intends to transfer no data)
      (11) Ho > Do  (Host expects to send data to the device,
      Device intends to receive data from the host)*/
      
      
      status = USBH_MSC_PHASE_ERROR;
 8004cda:	f04f 0302 	mov.w	r3, #2
 8004cde:	73fb      	strb	r3, [r7, #15]
 8004ce0:	e03a      	b.n	8004d58 <USBH_MSC_DecodeCSW+0xbc>
    }
    else
    { /* CSW length is Correct */
      
      /* Check validity of the CSW Signature and CSWStatus */
      if(USBH_MSC_CSWData.field.CSWSignature == USBH_MSC_BOT_CSW_SIGNATURE)
 8004ce2:	f244 03e0 	movw	r3, #16608	; 0x40e0
 8004ce6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cea:	681a      	ldr	r2, [r3, #0]
 8004cec:	f245 3355 	movw	r3, #21333	; 0x5355
 8004cf0:	f2c5 3342 	movt	r3, #21314	; 0x5342
 8004cf4:	429a      	cmp	r2, r3
 8004cf6:	d12c      	bne.n	8004d52 <USBH_MSC_DecodeCSW+0xb6>
      {/* Check Condition 1. dCSWSignature is equal to 53425355h */
        
        if(USBH_MSC_CSWData.field.CSWTag == USBH_MSC_CBWData.field.CBWTag)
 8004cf8:	f244 03e0 	movw	r3, #16608	; 0x40e0
 8004cfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d00:	685a      	ldr	r2, [r3, #4]
 8004d02:	f244 1300 	movw	r3, #16640	; 0x4100
 8004d06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d0a:	685b      	ldr	r3, [r3, #4]
 8004d0c:	429a      	cmp	r2, r3
 8004d0e:	d123      	bne.n	8004d58 <USBH_MSC_DecodeCSW+0xbc>
        {
          /* Check Condition 3. dCSWTag matches the dCBWTag from the 
          corresponding CBW */
          
          if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_OK) 
 8004d10:	f244 03e0 	movw	r3, #16608	; 0x40e0
 8004d14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d18:	7b1b      	ldrb	r3, [r3, #12]
 8004d1a:	2b00      	cmp	r3, #0
 8004d1c:	d103      	bne.n	8004d26 <USBH_MSC_DecodeCSW+0x8a>
            (12) Ho = Do (Host expects to send data to the device, 
            Device intends to receive data from the host)
            
            */
            
            status = USBH_MSC_OK;
 8004d1e:	f04f 0300 	mov.w	r3, #0
 8004d22:	73fb      	strb	r3, [r7, #15]
 8004d24:	e018      	b.n	8004d58 <USBH_MSC_DecodeCSW+0xbc>
          }
          else if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_FAIL)
 8004d26:	f244 03e0 	movw	r3, #16608	; 0x40e0
 8004d2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d2e:	7b1b      	ldrb	r3, [r3, #12]
 8004d30:	2b01      	cmp	r3, #1
 8004d32:	d103      	bne.n	8004d3c <USBH_MSC_DecodeCSW+0xa0>
          {
            status = USBH_MSC_FAIL;
 8004d34:	f04f 0301 	mov.w	r3, #1
 8004d38:	73fb      	strb	r3, [r7, #15]
 8004d3a:	e00d      	b.n	8004d58 <USBH_MSC_DecodeCSW+0xbc>
          }
          
          else if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_PHASE_ERROR)
 8004d3c:	f244 03e0 	movw	r3, #16608	; 0x40e0
 8004d40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d44:	7b1b      	ldrb	r3, [r3, #12]
 8004d46:	2b02      	cmp	r3, #2
 8004d48:	d106      	bne.n	8004d58 <USBH_MSC_DecodeCSW+0xbc>
            Di Device intends to send data to the host)
            (13) Ho < Do (Host expects to send data to the device, 
            Device intends to receive data from the host)
            */
            
            status = USBH_MSC_PHASE_ERROR;
 8004d4a:	f04f 0302 	mov.w	r3, #2
 8004d4e:	73fb      	strb	r3, [r7, #15]
 8004d50:	e002      	b.n	8004d58 <USBH_MSC_DecodeCSW+0xbc>
      else
      {
        /* If the CSW Signature is not valid, We sall return the Phase Error to
        Upper Layers for Reset Recovery */
        
        status = USBH_MSC_PHASE_ERROR;
 8004d52:	f04f 0302 	mov.w	r3, #2
 8004d56:	73fb      	strb	r3, [r7, #15]
      }
    } /* CSW Length Check*/
  }
  
  USBH_MSC_BOTXferParam.BOTXferStatus  = status;
 8004d58:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004d5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d60:	7bfa      	ldrb	r2, [r7, #15]
 8004d62:	73da      	strb	r2, [r3, #15]
  return status;
 8004d64:	7bfb      	ldrb	r3, [r7, #15]
}
 8004d66:	4618      	mov	r0, r3
 8004d68:	f107 0710 	add.w	r7, r7, #16
 8004d6c:	46bd      	mov	sp, r7
 8004d6e:	bd80      	pop	{r7, pc}

08004d70 <USBH_MSC_InterfaceInit>:
  * @param  hdev: Selected device property
  * @retval USBH_Status : Status of class request handled.
  */
static USBH_Status USBH_MSC_InterfaceInit ( USB_OTG_CORE_HANDLE *pdev, 
                                        void *phost)
{	 
 8004d70:	b590      	push	{r4, r7, lr}
 8004d72:	b087      	sub	sp, #28
 8004d74:	af02      	add	r7, sp, #8
 8004d76:	6078      	str	r0, [r7, #4]
 8004d78:	6039      	str	r1, [r7, #0]
  USBH_HOST *pphost = phost;
 8004d7a:	683b      	ldr	r3, [r7, #0]
 8004d7c:	60fb      	str	r3, [r7, #12]
  
  if((pphost->device_prop.Itf_Desc[0].bInterfaceClass == MSC_CLASS) && \
 8004d7e:	68fb      	ldr	r3, [r7, #12]
 8004d80:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 8004d84:	2b08      	cmp	r3, #8
 8004d86:	f040 80a7 	bne.w	8004ed8 <USBH_MSC_InterfaceInit+0x168>
     (pphost->device_prop.Itf_Desc[0].bInterfaceProtocol == MSC_PROTOCOL))
 8004d8a:	68fb      	ldr	r3, [r7, #12]
 8004d8c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
static USBH_Status USBH_MSC_InterfaceInit ( USB_OTG_CORE_HANDLE *pdev, 
                                        void *phost)
{	 
  USBH_HOST *pphost = phost;
  
  if((pphost->device_prop.Itf_Desc[0].bInterfaceClass == MSC_CLASS) && \
 8004d90:	2b50      	cmp	r3, #80	; 0x50
 8004d92:	f040 80a1 	bne.w	8004ed8 <USBH_MSC_InterfaceInit+0x168>
     (pphost->device_prop.Itf_Desc[0].bInterfaceProtocol == MSC_PROTOCOL))
  {
    if(pphost->device_prop.Ep_Desc[0][0].bEndpointAddress & 0x80)
 8004d96:	68fb      	ldr	r3, [r7, #12]
 8004d98:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 8004d9c:	b2db      	uxtb	r3, r3
 8004d9e:	b25b      	sxtb	r3, r3
 8004da0:	2b00      	cmp	r3, #0
 8004da2:	da10      	bge.n	8004dc6 <USBH_MSC_InterfaceInit+0x56>
    {
      MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
 8004da4:	68fb      	ldr	r3, [r7, #12]
 8004da6:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
 8004daa:	f244 1320 	movw	r3, #16672	; 0x4120
 8004dae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004db2:	70da      	strb	r2, [r3, #3]
      MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][0].wMaxPacketSize;
 8004db4:	68fb      	ldr	r3, [r7, #12]
 8004db6:	f8b3 2054 	ldrh.w	r2, [r3, #84]	; 0x54
 8004dba:	f244 1320 	movw	r3, #16672	; 0x4120
 8004dbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004dc2:	809a      	strh	r2, [r3, #4]
 8004dc4:	e00f      	b.n	8004de6 <USBH_MSC_InterfaceInit+0x76>
    }
    else
    {
      MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
 8004dc6:	68fb      	ldr	r3, [r7, #12]
 8004dc8:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
 8004dcc:	f244 1320 	movw	r3, #16672	; 0x4120
 8004dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004dd4:	709a      	strb	r2, [r3, #2]
      MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0] [0].wMaxPacketSize;      
 8004dd6:	68fb      	ldr	r3, [r7, #12]
 8004dd8:	f8b3 2054 	ldrh.w	r2, [r3, #84]	; 0x54
 8004ddc:	f244 1320 	movw	r3, #16672	; 0x4120
 8004de0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004de4:	80da      	strh	r2, [r3, #6]
    }
    
    if(pphost->device_prop.Ep_Desc[0][1].bEndpointAddress & 0x80)
 8004de6:	68fb      	ldr	r3, [r7, #12]
 8004de8:	f893 305a 	ldrb.w	r3, [r3, #90]	; 0x5a
 8004dec:	b2db      	uxtb	r3, r3
 8004dee:	b25b      	sxtb	r3, r3
 8004df0:	2b00      	cmp	r3, #0
 8004df2:	da10      	bge.n	8004e16 <USBH_MSC_InterfaceInit+0xa6>
    {
      MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
 8004df4:	68fb      	ldr	r3, [r7, #12]
 8004df6:	f893 205a 	ldrb.w	r2, [r3, #90]	; 0x5a
 8004dfa:	f244 1320 	movw	r3, #16672	; 0x4120
 8004dfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e02:	70da      	strb	r2, [r3, #3]
      MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
 8004e04:	68fb      	ldr	r3, [r7, #12]
 8004e06:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 8004e0a:	f244 1320 	movw	r3, #16672	; 0x4120
 8004e0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e12:	809a      	strh	r2, [r3, #4]
 8004e14:	e00f      	b.n	8004e36 <USBH_MSC_InterfaceInit+0xc6>
    }
    else
    {
      MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
 8004e16:	68fb      	ldr	r3, [r7, #12]
 8004e18:	f893 205a 	ldrb.w	r2, [r3, #90]	; 0x5a
 8004e1c:	f244 1320 	movw	r3, #16672	; 0x4120
 8004e20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e24:	709a      	strb	r2, [r3, #2]
      MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
 8004e26:	68fb      	ldr	r3, [r7, #12]
 8004e28:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 8004e2c:	f244 1320 	movw	r3, #16672	; 0x4120
 8004e30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e34:	80da      	strh	r2, [r3, #6]
    }
    
    MSC_Machine.hc_num_out = USBH_Alloc_Channel(pdev, 
 8004e36:	f244 1320 	movw	r3, #16672	; 0x4120
 8004e3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e3e:	789b      	ldrb	r3, [r3, #2]
 8004e40:	6878      	ldr	r0, [r7, #4]
 8004e42:	4619      	mov	r1, r3
 8004e44:	f7fe fd1c 	bl	8003880 <USBH_Alloc_Channel>
 8004e48:	4603      	mov	r3, r0
 8004e4a:	461a      	mov	r2, r3
 8004e4c:	f244 1320 	movw	r3, #16672	; 0x4120
 8004e50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e54:	705a      	strb	r2, [r3, #1]
                                                MSC_Machine.MSBulkOutEp);
    MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
 8004e56:	f244 1320 	movw	r3, #16672	; 0x4120
 8004e5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e5e:	78db      	ldrb	r3, [r3, #3]
 8004e60:	6878      	ldr	r0, [r7, #4]
 8004e62:	4619      	mov	r1, r3
 8004e64:	f7fe fd0c 	bl	8003880 <USBH_Alloc_Channel>
 8004e68:	4603      	mov	r3, r0
 8004e6a:	461a      	mov	r2, r3
 8004e6c:	f244 1320 	movw	r3, #16672	; 0x4120
 8004e70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e74:	701a      	strb	r2, [r3, #0]
                                                MSC_Machine.MSBulkInEp);  
    
    /* Open the new channels */
    USBH_Open_Channel  (pdev,
 8004e76:	f244 1320 	movw	r3, #16672	; 0x4120
 8004e7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e7e:	7859      	ldrb	r1, [r3, #1]
                        MSC_Machine.hc_num_out,
                        pphost->device_prop.address,
 8004e80:	68fb      	ldr	r3, [r7, #12]
                                                MSC_Machine.MSBulkOutEp);
    MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
                                                MSC_Machine.MSBulkInEp);  
    
    /* Open the new channels */
    USBH_Open_Channel  (pdev,
 8004e82:	f893 2020 	ldrb.w	r2, [r3, #32]
                        MSC_Machine.hc_num_out,
                        pphost->device_prop.address,
                        pphost->device_prop.speed,
 8004e86:	68fb      	ldr	r3, [r7, #12]
                                                MSC_Machine.MSBulkOutEp);
    MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
                                                MSC_Machine.MSBulkInEp);  
    
    /* Open the new channels */
    USBH_Open_Channel  (pdev,
 8004e88:	f893 4021 	ldrb.w	r4, [r3, #33]	; 0x21
 8004e8c:	f244 1320 	movw	r3, #16672	; 0x4120
 8004e90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e94:	88db      	ldrh	r3, [r3, #6]
 8004e96:	f04f 0002 	mov.w	r0, #2
 8004e9a:	9000      	str	r0, [sp, #0]
 8004e9c:	9301      	str	r3, [sp, #4]
 8004e9e:	6878      	ldr	r0, [r7, #4]
 8004ea0:	4623      	mov	r3, r4
 8004ea2:	f7fe fc1b 	bl	80036dc <USBH_Open_Channel>
                        pphost->device_prop.address,
                        pphost->device_prop.speed,
                        EP_TYPE_BULK,
                        MSC_Machine.MSBulkOutEpSize);  
    
    USBH_Open_Channel  (pdev,
 8004ea6:	f244 1320 	movw	r3, #16672	; 0x4120
 8004eaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004eae:	7819      	ldrb	r1, [r3, #0]
                        MSC_Machine.hc_num_in,
                        pphost->device_prop.address,
 8004eb0:	68fb      	ldr	r3, [r7, #12]
                        pphost->device_prop.address,
                        pphost->device_prop.speed,
                        EP_TYPE_BULK,
                        MSC_Machine.MSBulkOutEpSize);  
    
    USBH_Open_Channel  (pdev,
 8004eb2:	f893 2020 	ldrb.w	r2, [r3, #32]
                        MSC_Machine.hc_num_in,
                        pphost->device_prop.address,
                        pphost->device_prop.speed,
 8004eb6:	68fb      	ldr	r3, [r7, #12]
                        pphost->device_prop.address,
                        pphost->device_prop.speed,
                        EP_TYPE_BULK,
                        MSC_Machine.MSBulkOutEpSize);  
    
    USBH_Open_Channel  (pdev,
 8004eb8:	f893 4021 	ldrb.w	r4, [r3, #33]	; 0x21
 8004ebc:	f244 1320 	movw	r3, #16672	; 0x4120
 8004ec0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ec4:	889b      	ldrh	r3, [r3, #4]
 8004ec6:	f04f 0002 	mov.w	r0, #2
 8004eca:	9000      	str	r0, [sp, #0]
 8004ecc:	9301      	str	r3, [sp, #4]
 8004ece:	6878      	ldr	r0, [r7, #4]
 8004ed0:	4623      	mov	r3, r4
 8004ed2:	f7fe fc03 	bl	80036dc <USBH_Open_Channel>
 8004ed6:	e004      	b.n	8004ee2 <USBH_MSC_InterfaceInit+0x172>
    
  }
  
  else
  {
    pphost->usr_cb->USBH_USR_DeviceNotSupported(); 
 8004ed8:	68fb      	ldr	r3, [r7, #12]
 8004eda:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8004ede:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004ee0:	4798      	blx	r3
  }
  
  return USBH_OK ;
 8004ee2:	f04f 0300 	mov.w	r3, #0
 
}
 8004ee6:	4618      	mov	r0, r3
 8004ee8:	f107 0714 	add.w	r7, r7, #20
 8004eec:	46bd      	mov	sp, r7
 8004eee:	bd90      	pop	{r4, r7, pc}

08004ef0 <USBH_MSC_InterfaceDeInit>:
  * @param  hdev: Selected device property
  * @retval None
  */
void USBH_MSC_InterfaceDeInit ( USB_OTG_CORE_HANDLE *pdev,
                                void *phost)
{	
 8004ef0:	b580      	push	{r7, lr}
 8004ef2:	b082      	sub	sp, #8
 8004ef4:	af00      	add	r7, sp, #0
 8004ef6:	6078      	str	r0, [r7, #4]
 8004ef8:	6039      	str	r1, [r7, #0]
  if ( MSC_Machine.hc_num_out)
 8004efa:	f244 1320 	movw	r3, #16672	; 0x4120
 8004efe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f02:	785b      	ldrb	r3, [r3, #1]
 8004f04:	2b00      	cmp	r3, #0
 8004f06:	d018      	beq.n	8004f3a <USBH_MSC_InterfaceDeInit+0x4a>
  {
    USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_out);
 8004f08:	f244 1320 	movw	r3, #16672	; 0x4120
 8004f0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f10:	785b      	ldrb	r3, [r3, #1]
 8004f12:	6878      	ldr	r0, [r7, #4]
 8004f14:	4619      	mov	r1, r3
 8004f16:	f7fc fa2d 	bl	8001374 <USB_OTG_HC_Halt>
    USBH_Free_Channel  (pdev, MSC_Machine.hc_num_out);
 8004f1a:	f244 1320 	movw	r3, #16672	; 0x4120
 8004f1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f22:	785b      	ldrb	r3, [r3, #1]
 8004f24:	6878      	ldr	r0, [r7, #4]
 8004f26:	4619      	mov	r1, r3
 8004f28:	f7fe fcd0 	bl	80038cc <USBH_Free_Channel>
    MSC_Machine.hc_num_out = 0;     /* Reset the Channel as Free */
 8004f2c:	f244 1320 	movw	r3, #16672	; 0x4120
 8004f30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f34:	f04f 0200 	mov.w	r2, #0
 8004f38:	705a      	strb	r2, [r3, #1]
  }
   
  if ( MSC_Machine.hc_num_in)
 8004f3a:	f244 1320 	movw	r3, #16672	; 0x4120
 8004f3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f42:	781b      	ldrb	r3, [r3, #0]
 8004f44:	2b00      	cmp	r3, #0
 8004f46:	d018      	beq.n	8004f7a <USBH_MSC_InterfaceDeInit+0x8a>
  {
    USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_in);
 8004f48:	f244 1320 	movw	r3, #16672	; 0x4120
 8004f4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f50:	781b      	ldrb	r3, [r3, #0]
 8004f52:	6878      	ldr	r0, [r7, #4]
 8004f54:	4619      	mov	r1, r3
 8004f56:	f7fc fa0d 	bl	8001374 <USB_OTG_HC_Halt>
    USBH_Free_Channel  (pdev, MSC_Machine.hc_num_in);
 8004f5a:	f244 1320 	movw	r3, #16672	; 0x4120
 8004f5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f62:	781b      	ldrb	r3, [r3, #0]
 8004f64:	6878      	ldr	r0, [r7, #4]
 8004f66:	4619      	mov	r1, r3
 8004f68:	f7fe fcb0 	bl	80038cc <USBH_Free_Channel>
    MSC_Machine.hc_num_in = 0;     /* Reset the Channel as Free */
 8004f6c:	f244 1320 	movw	r3, #16672	; 0x4120
 8004f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f74:	f04f 0200 	mov.w	r2, #0
 8004f78:	701a      	strb	r2, [r3, #0]
  } 
}
 8004f7a:	f107 0708 	add.w	r7, r7, #8
 8004f7e:	46bd      	mov	sp, r7
 8004f80:	bd80      	pop	{r7, pc}
 8004f82:	bf00      	nop

08004f84 <USBH_MSC_ClassRequest>:
  * @retval USBH_Status : Status of class request handled.
  */

static USBH_Status USBH_MSC_ClassRequest(USB_OTG_CORE_HANDLE *pdev , 
                                        void *phost)
{   
 8004f84:	b480      	push	{r7}
 8004f86:	b085      	sub	sp, #20
 8004f88:	af00      	add	r7, sp, #0
 8004f8a:	6078      	str	r0, [r7, #4]
 8004f8c:	6039      	str	r1, [r7, #0]
  
  USBH_Status status = USBH_OK ;
 8004f8e:	f04f 0300 	mov.w	r3, #0
 8004f92:	73fb      	strb	r3, [r7, #15]
  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_INIT_STATE;
 8004f94:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004f98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f9c:	f04f 0200 	mov.w	r2, #0
 8004fa0:	701a      	strb	r2, [r3, #0]
  
  return status; 
 8004fa2:	7bfb      	ldrb	r3, [r7, #15]
}
 8004fa4:	4618      	mov	r0, r3
 8004fa6:	f107 0714 	add.w	r7, r7, #20
 8004faa:	46bd      	mov	sp, r7
 8004fac:	bc80      	pop	{r7}
 8004fae:	4770      	bx	lr

08004fb0 <USBH_MSC_Handle>:
  * @retval USBH_Status
  */

static USBH_Status USBH_MSC_Handle(USB_OTG_CORE_HANDLE *pdev , 
                                   void   *phost)
{
 8004fb0:	b580      	push	{r7, lr}
 8004fb2:	b086      	sub	sp, #24
 8004fb4:	af00      	add	r7, sp, #0
 8004fb6:	6078      	str	r0, [r7, #4]
 8004fb8:	6039      	str	r1, [r7, #0]
  USBH_HOST *pphost = phost;
 8004fba:	683b      	ldr	r3, [r7, #0]
 8004fbc:	613b      	str	r3, [r7, #16]
    
  USBH_Status status = USBH_BUSY;
 8004fbe:	f04f 0301 	mov.w	r3, #1
 8004fc2:	75fb      	strb	r3, [r7, #23]
  uint8_t mscStatus = USBH_MSC_BUSY;
 8004fc4:	f04f 0303 	mov.w	r3, #3
 8004fc8:	73fb      	strb	r3, [r7, #15]
  uint8_t appliStatus = 0;
 8004fca:	f04f 0300 	mov.w	r3, #0
 8004fce:	73bb      	strb	r3, [r7, #14]
  
  static uint8_t maxLunExceed = FALSE;
  
    
  if(HCD_IsDeviceConnected(pdev))
 8004fd0:	6878      	ldr	r0, [r7, #4]
 8004fd2:	f7fc fb27 	bl	8001624 <HCD_IsDeviceConnected>
 8004fd6:	4603      	mov	r3, r0
 8004fd8:	2b00      	cmp	r3, #0
 8004fda:	f000 815d 	beq.w	8005298 <USBH_MSC_Handle+0x2e8>
  {   
    switch(USBH_MSC_BOTXferParam.MSCState)
 8004fde:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8004fe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004fe6:	781b      	ldrb	r3, [r3, #0]
 8004fe8:	2b0a      	cmp	r3, #10
 8004fea:	f200 814c 	bhi.w	8005286 <USBH_MSC_Handle+0x2d6>
 8004fee:	a201      	add	r2, pc, #4	; (adr r2, 8004ff4 <USBH_MSC_Handle+0x44>)
 8004ff0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004ff4:	08005021 	.word	0x08005021
 8004ff8:	08005037 	.word	0x08005037
 8004ffc:	0800507d 	.word	0x0800507d
 8005000:	08005153 	.word	0x08005153
 8005004:	08005191 	.word	0x08005191
 8005008:	080051cf 	.word	0x080051cf
 800500c:	0800520d 	.word	0x0800520d
 8005010:	08005243 	.word	0x08005243
 8005014:	0800524d 	.word	0x0800524d
 8005018:	08005111 	.word	0x08005111
 800501c:	0800527f 	.word	0x0800527f
    {
    case USBH_MSC_BOT_INIT_STATE:
      USBH_MSC_Init(pdev);
 8005020:	6878      	ldr	r0, [r7, #4]
 8005022:	f7ff fabd 	bl	80045a0 <USBH_MSC_Init>
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_RESET;  
 8005026:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800502a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800502e:	f04f 0201 	mov.w	r2, #1
 8005032:	701a      	strb	r2, [r3, #0]
      break;
 8005034:	e130      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
      
    case USBH_MSC_BOT_RESET:   
      /* Issue BOT RESET request */
      status = USBH_MSC_BOTReset(pdev, phost);
 8005036:	6878      	ldr	r0, [r7, #4]
 8005038:	6839      	ldr	r1, [r7, #0]
 800503a:	f000 f933 	bl	80052a4 <USBH_MSC_BOTReset>
 800503e:	4603      	mov	r3, r0
 8005040:	75fb      	strb	r3, [r7, #23]
      if(status == USBH_OK )
 8005042:	7dfb      	ldrb	r3, [r7, #23]
 8005044:	2b00      	cmp	r3, #0
 8005046:	d106      	bne.n	8005056 <USBH_MSC_Handle+0xa6>
      {
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_GET_MAX_LUN;
 8005048:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800504c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005050:	f04f 0202 	mov.w	r2, #2
 8005054:	701a      	strb	r2, [r3, #0]
      }
      
      if(status == USBH_NOT_SUPPORTED )
 8005056:	7dfb      	ldrb	r3, [r7, #23]
 8005058:	2b03      	cmp	r3, #3
 800505a:	f040 8116 	bne.w	800528a <USBH_MSC_Handle+0x2da>
      {
       /* If the Command has failed, then we need to move to Next State, after
        STALL condition is cleared by Control-Transfer */
        USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_GET_MAX_LUN; 
 800505e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005062:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005066:	f04f 0202 	mov.w	r2, #2
 800506a:	705a      	strb	r2, [r3, #1]

        /* a Clear Feature should be issued here */
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
 800506c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005070:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005074:	f04f 0209 	mov.w	r2, #9
 8005078:	701a      	strb	r2, [r3, #0]
      }  
      break;
 800507a:	e106      	b.n	800528a <USBH_MSC_Handle+0x2da>
      
    case USBH_MSC_GET_MAX_LUN:
      /* Issue GetMaxLUN request */
      status = USBH_MSC_GETMaxLUN(pdev, phost);
 800507c:	6878      	ldr	r0, [r7, #4]
 800507e:	6839      	ldr	r1, [r7, #0]
 8005080:	f000 f938 	bl	80052f4 <USBH_MSC_GETMaxLUN>
 8005084:	4603      	mov	r3, r0
 8005086:	75fb      	strb	r3, [r7, #23]
      
      if(status == USBH_OK )
 8005088:	7dfb      	ldrb	r3, [r7, #23]
 800508a:	2b00      	cmp	r3, #0
 800508c:	d12d      	bne.n	80050ea <USBH_MSC_Handle+0x13a>
      {
        MSC_Machine.maxLun = *(MSC_Machine.buff) ;
 800508e:	f244 1320 	movw	r3, #16672	; 0x4120
 8005092:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005096:	7a1a      	ldrb	r2, [r3, #8]
 8005098:	f244 1320 	movw	r3, #16672	; 0x4120
 800509c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050a0:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
        
        /* If device has more that one logical unit then it is not supported */
        if((MSC_Machine.maxLun > 0) && (maxLunExceed == FALSE))
 80050a4:	f244 1320 	movw	r3, #16672	; 0x4120
 80050a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050ac:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 80050b0:	2b00      	cmp	r3, #0
 80050b2:	d013      	beq.n	80050dc <USBH_MSC_Handle+0x12c>
 80050b4:	f640 13fe 	movw	r3, #2558	; 0x9fe
 80050b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050bc:	781b      	ldrb	r3, [r3, #0]
 80050be:	2b00      	cmp	r3, #0
 80050c0:	d10c      	bne.n	80050dc <USBH_MSC_Handle+0x12c>
        {
          maxLunExceed = TRUE;
 80050c2:	f640 13fe 	movw	r3, #2558	; 0x9fe
 80050c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050ca:	f04f 0201 	mov.w	r2, #1
 80050ce:	701a      	strb	r2, [r3, #0]
          pphost->usr_cb->USBH_USR_DeviceNotSupported();
 80050d0:	693b      	ldr	r3, [r7, #16]
 80050d2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80050d6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80050d8:	4798      	blx	r3
          
          break;
 80050da:	e0dd      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
        }
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_TEST_UNIT_READY;
 80050dc:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80050e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050e4:	f04f 0203 	mov.w	r2, #3
 80050e8:	701a      	strb	r2, [r3, #0]
      }
      
      if(status == USBH_NOT_SUPPORTED )
 80050ea:	7dfb      	ldrb	r3, [r7, #23]
 80050ec:	2b03      	cmp	r3, #3
 80050ee:	f040 80ce 	bne.w	800528e <USBH_MSC_Handle+0x2de>
      {
               /* If the Command has failed, then we need to move to Next State, after
        STALL condition is cleared by Control-Transfer */
        USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_TEST_UNIT_READY; 
 80050f2:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80050f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050fa:	f04f 0203 	mov.w	r2, #3
 80050fe:	705a      	strb	r2, [r3, #1]
        
        /* a Clear Feature should be issued here */
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
 8005100:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005104:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005108:	f04f 0209 	mov.w	r2, #9
 800510c:	701a      	strb	r2, [r3, #0]
      }    
      break;
 800510e:	e0be      	b.n	800528e <USBH_MSC_Handle+0x2de>
    case USBH_MSC_CTRL_ERROR_STATE:
      /* Issue Clearfeature request */
      status = USBH_ClrFeature(pdev,
                               phost,
                               0x00,
                               pphost->Control.hc_num_out);
 8005110:	693b      	ldr	r3, [r7, #16]
      }    
      break;
      
    case USBH_MSC_CTRL_ERROR_STATE:
      /* Issue Clearfeature request */
      status = USBH_ClrFeature(pdev,
 8005112:	795b      	ldrb	r3, [r3, #5]
 8005114:	6878      	ldr	r0, [r7, #4]
 8005116:	6839      	ldr	r1, [r7, #0]
 8005118:	f04f 0200 	mov.w	r2, #0
 800511c:	f7ff f824 	bl	8004168 <USBH_ClrFeature>
 8005120:	4603      	mov	r3, r0
 8005122:	75fb      	strb	r3, [r7, #23]
                               phost,
                               0x00,
                               pphost->Control.hc_num_out);
      if(status == USBH_OK )
 8005124:	7dfb      	ldrb	r3, [r7, #23]
 8005126:	2b00      	cmp	r3, #0
 8005128:	f040 80b3 	bne.w	8005292 <USBH_MSC_Handle+0x2e2>
      {
        /* If GetMaxLun Request not support, assume Single LUN configuration */
        MSC_Machine.maxLun = 0;  
 800512c:	f244 1320 	movw	r3, #16672	; 0x4120
 8005130:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005134:	f04f 0200 	mov.w	r2, #0
 8005138:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
        
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;     
 800513c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005140:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005144:	785a      	ldrb	r2, [r3, #1]
 8005146:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800514a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800514e:	701a      	strb	r2, [r3, #0]
      }
      break;  
 8005150:	e09f      	b.n	8005292 <USBH_MSC_Handle+0x2e2>
      
    case USBH_MSC_TEST_UNIT_READY:
      /* Issue SCSI command TestUnitReady */ 
      mscStatus = USBH_MSC_TestUnitReady(pdev);
 8005152:	6878      	ldr	r0, [r7, #4]
 8005154:	f000 fa9a 	bl	800568c <USBH_MSC_TestUnitReady>
 8005158:	4603      	mov	r3, r0
 800515a:	73fb      	strb	r3, [r7, #15]
      
      if(mscStatus == USBH_MSC_OK )
 800515c:	7bfb      	ldrb	r3, [r7, #15]
 800515e:	2b00      	cmp	r3, #0
 8005160:	d111      	bne.n	8005186 <USBH_MSC_Handle+0x1d6>
      {
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_READ_CAPACITY10;
 8005162:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005166:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800516a:	f04f 0204 	mov.w	r2, #4
 800516e:	701a      	strb	r2, [r3, #0]
        MSCErrorCount = 0;
 8005170:	f640 13fd 	movw	r3, #2557	; 0x9fd
 8005174:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005178:	f04f 0200 	mov.w	r2, #0
 800517c:	701a      	strb	r2, [r3, #0]
        status = USBH_OK;
 800517e:	f04f 0300 	mov.w	r3, #0
 8005182:	75fb      	strb	r3, [r7, #23]
      }
      else
      {
        USBH_MSC_ErrorHandle(mscStatus);
      } 
      break;
 8005184:	e088      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
        MSCErrorCount = 0;
        status = USBH_OK;
      }
      else
      {
        USBH_MSC_ErrorHandle(mscStatus);
 8005186:	7bfb      	ldrb	r3, [r7, #15]
 8005188:	4618      	mov	r0, r3
 800518a:	f000 f8db 	bl	8005344 <USBH_MSC_ErrorHandle>
      } 
      break;
 800518e:	e083      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
      
    case USBH_MSC_READ_CAPACITY10:
      /* Issue READ_CAPACITY10 SCSI command */
      mscStatus = USBH_MSC_ReadCapacity10(pdev);
 8005190:	6878      	ldr	r0, [r7, #4]
 8005192:	f000 fb39 	bl	8005808 <USBH_MSC_ReadCapacity10>
 8005196:	4603      	mov	r3, r0
 8005198:	73fb      	strb	r3, [r7, #15]
      if(mscStatus == USBH_MSC_OK )
 800519a:	7bfb      	ldrb	r3, [r7, #15]
 800519c:	2b00      	cmp	r3, #0
 800519e:	d111      	bne.n	80051c4 <USBH_MSC_Handle+0x214>
      {
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_MODE_SENSE6;
 80051a0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80051a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051a8:	f04f 0205 	mov.w	r2, #5
 80051ac:	701a      	strb	r2, [r3, #0]
        MSCErrorCount = 0;
 80051ae:	f640 13fd 	movw	r3, #2557	; 0x9fd
 80051b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051b6:	f04f 0200 	mov.w	r2, #0
 80051ba:	701a      	strb	r2, [r3, #0]
        status = USBH_OK;
 80051bc:	f04f 0300 	mov.w	r3, #0
 80051c0:	75fb      	strb	r3, [r7, #23]
      }
      else
      {
        USBH_MSC_ErrorHandle(mscStatus);
      }
      break;
 80051c2:	e069      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
        MSCErrorCount = 0;
        status = USBH_OK;
      }
      else
      {
        USBH_MSC_ErrorHandle(mscStatus);
 80051c4:	7bfb      	ldrb	r3, [r7, #15]
 80051c6:	4618      	mov	r0, r3
 80051c8:	f000 f8bc 	bl	8005344 <USBH_MSC_ErrorHandle>
      }
      break;
 80051cc:	e064      	b.n	8005298 <USBH_MSC_Handle+0x2e8>

    case USBH_MSC_MODE_SENSE6:
      /* Issue ModeSense6 SCSI command for detecting if device is write-protected */
      mscStatus = USBH_MSC_ModeSense6(pdev);
 80051ce:	6878      	ldr	r0, [r7, #4]
 80051d0:	f000 fc08 	bl	80059e4 <USBH_MSC_ModeSense6>
 80051d4:	4603      	mov	r3, r0
 80051d6:	73fb      	strb	r3, [r7, #15]
      if(mscStatus == USBH_MSC_OK )
 80051d8:	7bfb      	ldrb	r3, [r7, #15]
 80051da:	2b00      	cmp	r3, #0
 80051dc:	d111      	bne.n	8005202 <USBH_MSC_Handle+0x252>
      {
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
 80051de:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80051e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051e6:	f04f 0208 	mov.w	r2, #8
 80051ea:	701a      	strb	r2, [r3, #0]
        MSCErrorCount = 0;
 80051ec:	f640 13fd 	movw	r3, #2557	; 0x9fd
 80051f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051f4:	f04f 0200 	mov.w	r2, #0
 80051f8:	701a      	strb	r2, [r3, #0]
        status = USBH_OK;
 80051fa:	f04f 0300 	mov.w	r3, #0
 80051fe:	75fb      	strb	r3, [r7, #23]
      }
      else
      {
        USBH_MSC_ErrorHandle(mscStatus);
      }
      break;
 8005200:	e04a      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
        MSCErrorCount = 0;
        status = USBH_OK;
      }
      else
      {
        USBH_MSC_ErrorHandle(mscStatus);
 8005202:	7bfb      	ldrb	r3, [r7, #15]
 8005204:	4618      	mov	r0, r3
 8005206:	f000 f89d 	bl	8005344 <USBH_MSC_ErrorHandle>
      }
      break;
 800520a:	e045      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
      
    case USBH_MSC_REQUEST_SENSE:
      /* Issue RequestSense SCSI command for retreiving error code */
      mscStatus = USBH_MSC_RequestSense(pdev);
 800520c:	6878      	ldr	r0, [r7, #4]
 800520e:	f000 fcc5 	bl	8005b9c <USBH_MSC_RequestSense>
 8005212:	4603      	mov	r3, r0
 8005214:	73fb      	strb	r3, [r7, #15]
      if(mscStatus == USBH_MSC_OK )
 8005216:	7bfb      	ldrb	r3, [r7, #15]
 8005218:	2b00      	cmp	r3, #0
 800521a:	d10d      	bne.n	8005238 <USBH_MSC_Handle+0x288>
      {
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;
 800521c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005220:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005224:	785a      	ldrb	r2, [r3, #1]
 8005226:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800522a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800522e:	701a      	strb	r2, [r3, #0]
        status = USBH_OK;
 8005230:	f04f 0300 	mov.w	r3, #0
 8005234:	75fb      	strb	r3, [r7, #23]
      }
      else
      {
        USBH_MSC_ErrorHandle(mscStatus);
      }  
      break;
 8005236:	e02f      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;
        status = USBH_OK;
      }
      else
      {
        USBH_MSC_ErrorHandle(mscStatus);
 8005238:	7bfb      	ldrb	r3, [r7, #15]
 800523a:	4618      	mov	r0, r3
 800523c:	f000 f882 	bl	8005344 <USBH_MSC_ErrorHandle>
      }  
      break;
 8005240:	e02a      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
      
    case USBH_MSC_BOT_USB_TRANSFERS:
      /* Process the BOT state machine */
      USBH_MSC_HandleBOTXfer(pdev , phost);
 8005242:	6878      	ldr	r0, [r7, #4]
 8005244:	6839      	ldr	r1, [r7, #0]
 8005246:	f7ff f9e7 	bl	8004618 <USBH_MSC_HandleBOTXfer>
      break;
 800524a:	e025      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
    
    case USBH_MSC_DEFAULT_APPLI_STATE:
      /* Process Application callback for MSC */
      appliStatus = pphost->usr_cb->USBH_USR_MSC_Application();
 800524c:	693b      	ldr	r3, [r7, #16]
 800524e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8005252:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005254:	4798      	blx	r3
 8005256:	4603      	mov	r3, r0
 8005258:	73bb      	strb	r3, [r7, #14]
      if(appliStatus == 0)
 800525a:	7bbb      	ldrb	r3, [r7, #14]
 800525c:	2b00      	cmp	r3, #0
 800525e:	d107      	bne.n	8005270 <USBH_MSC_Handle+0x2c0>
      {
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
 8005260:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005264:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005268:	f04f 0208 	mov.w	r2, #8
 800526c:	701a      	strb	r2, [r3, #0]
      else if (appliStatus == 1) 
      {
        /* De-init requested from application layer */
        status =  USBH_APPLY_DEINIT;
      }
      break;
 800526e:	e012      	b.n	8005296 <USBH_MSC_Handle+0x2e6>
      appliStatus = pphost->usr_cb->USBH_USR_MSC_Application();
      if(appliStatus == 0)
      {
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
      }
      else if (appliStatus == 1) 
 8005270:	7bbb      	ldrb	r3, [r7, #14]
 8005272:	2b01      	cmp	r3, #1
 8005274:	d10f      	bne.n	8005296 <USBH_MSC_Handle+0x2e6>
      {
        /* De-init requested from application layer */
        status =  USBH_APPLY_DEINIT;
 8005276:	f04f 0306 	mov.w	r3, #6
 800527a:	75fb      	strb	r3, [r7, #23]
      }
      break;
 800527c:	e00b      	b.n	8005296 <USBH_MSC_Handle+0x2e6>
      
    case USBH_MSC_UNRECOVERED_STATE:
      
      status = USBH_UNRECOVERED_ERROR;
 800527e:	f04f 0304 	mov.w	r3, #4
 8005282:	75fb      	strb	r3, [r7, #23]
      
      break;
 8005284:	e008      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
      
    default:
      break; 
 8005286:	bf00      	nop
 8005288:	e006      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
        USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_GET_MAX_LUN; 

        /* a Clear Feature should be issued here */
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
      }  
      break;
 800528a:	bf00      	nop
 800528c:	e004      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
        USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_TEST_UNIT_READY; 
        
        /* a Clear Feature should be issued here */
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
      }    
      break;
 800528e:	bf00      	nop
 8005290:	e002      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
        /* If GetMaxLun Request not support, assume Single LUN configuration */
        MSC_Machine.maxLun = 0;  
        
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;     
      }
      break;  
 8005292:	bf00      	nop
 8005294:	e000      	b.n	8005298 <USBH_MSC_Handle+0x2e8>
      else if (appliStatus == 1) 
      {
        /* De-init requested from application layer */
        status =  USBH_APPLY_DEINIT;
      }
      break;
 8005296:	bf00      	nop
    default:
      break; 
      
    }
  }
   return status;
 8005298:	7dfb      	ldrb	r3, [r7, #23]
}
 800529a:	4618      	mov	r0, r3
 800529c:	f107 0718 	add.w	r7, r7, #24
 80052a0:	46bd      	mov	sp, r7
 80052a2:	bd80      	pop	{r7, pc}

080052a4 <USBH_MSC_BOTReset>:
  * @param  pdev: Selected device
  * @retval USBH_Status : Status of class request handled.
  */
static USBH_Status USBH_MSC_BOTReset(USB_OTG_CORE_HANDLE *pdev,
                              USBH_HOST *phost)
{
 80052a4:	b580      	push	{r7, lr}
 80052a6:	b082      	sub	sp, #8
 80052a8:	af00      	add	r7, sp, #0
 80052aa:	6078      	str	r0, [r7, #4]
 80052ac:	6039      	str	r1, [r7, #0]
  
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \
 80052ae:	683b      	ldr	r3, [r7, #0]
 80052b0:	f04f 0221 	mov.w	r2, #33	; 0x21
 80052b4:	751a      	strb	r2, [r3, #20]
                              USB_REQ_RECIPIENT_INTERFACE;
  
  phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
 80052b6:	683b      	ldr	r3, [r7, #0]
 80052b8:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80052bc:	755a      	strb	r2, [r3, #21]
  phost->Control.setup.b.wValue.w = 0;
 80052be:	683b      	ldr	r3, [r7, #0]
 80052c0:	f04f 0200 	mov.w	r2, #0
 80052c4:	82da      	strh	r2, [r3, #22]
  phost->Control.setup.b.wIndex.w = 0;
 80052c6:	683b      	ldr	r3, [r7, #0]
 80052c8:	f04f 0200 	mov.w	r2, #0
 80052cc:	831a      	strh	r2, [r3, #24]
  phost->Control.setup.b.wLength.w = 0;           
 80052ce:	683b      	ldr	r3, [r7, #0]
 80052d0:	f04f 0200 	mov.w	r2, #0
 80052d4:	835a      	strh	r2, [r3, #26]
  
  return USBH_CtlReq(pdev, phost, 0 , 0 ); 
 80052d6:	6878      	ldr	r0, [r7, #4]
 80052d8:	6839      	ldr	r1, [r7, #0]
 80052da:	f04f 0200 	mov.w	r2, #0
 80052de:	f04f 0300 	mov.w	r3, #0
 80052e2:	f7fe fb65 	bl	80039b0 <USBH_CtlReq>
 80052e6:	4603      	mov	r3, r0
}
 80052e8:	4618      	mov	r0, r3
 80052ea:	f107 0708 	add.w	r7, r7, #8
 80052ee:	46bd      	mov	sp, r7
 80052f0:	bd80      	pop	{r7, pc}
 80052f2:	bf00      	nop

080052f4 <USBH_MSC_GETMaxLUN>:
  *         device for the next CBW from the host.
  * @param  pdev: Selected device
  * @retval USBH_Status : USB ctl xfer status
  */
static USBH_Status USBH_MSC_GETMaxLUN(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
{
 80052f4:	b580      	push	{r7, lr}
 80052f6:	b082      	sub	sp, #8
 80052f8:	af00      	add	r7, sp, #0
 80052fa:	6078      	str	r0, [r7, #4]
 80052fc:	6039      	str	r1, [r7, #0]
  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
 80052fe:	683b      	ldr	r3, [r7, #0]
 8005300:	f04f 02a1 	mov.w	r2, #161	; 0xa1
 8005304:	751a      	strb	r2, [r3, #20]
                              USB_REQ_RECIPIENT_INTERFACE;
  
  phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
 8005306:	683b      	ldr	r3, [r7, #0]
 8005308:	f04f 02fe 	mov.w	r2, #254	; 0xfe
 800530c:	755a      	strb	r2, [r3, #21]
  phost->Control.setup.b.wValue.w = 0;
 800530e:	683b      	ldr	r3, [r7, #0]
 8005310:	f04f 0200 	mov.w	r2, #0
 8005314:	82da      	strh	r2, [r3, #22]
  phost->Control.setup.b.wIndex.w = 0;
 8005316:	683b      	ldr	r3, [r7, #0]
 8005318:	f04f 0200 	mov.w	r2, #0
 800531c:	831a      	strh	r2, [r3, #24]
  phost->Control.setup.b.wLength.w = 1;           
 800531e:	683b      	ldr	r3, [r7, #0]
 8005320:	f04f 0201 	mov.w	r2, #1
 8005324:	835a      	strh	r2, [r3, #26]
  
  return USBH_CtlReq(pdev, phost, MSC_Machine.buff , 1 ); 
 8005326:	6878      	ldr	r0, [r7, #4]
 8005328:	6839      	ldr	r1, [r7, #0]
 800532a:	4a05      	ldr	r2, [pc, #20]	; (8005340 <USBH_MSC_GETMaxLUN+0x4c>)
 800532c:	f04f 0301 	mov.w	r3, #1
 8005330:	f7fe fb3e 	bl	80039b0 <USBH_CtlReq>
 8005334:	4603      	mov	r3, r0
}
 8005336:	4618      	mov	r0, r3
 8005338:	f107 0708 	add.w	r7, r7, #8
 800533c:	46bd      	mov	sp, r7
 800533e:	bd80      	pop	{r7, pc}
 8005340:	20004128 	.word	0x20004128

08005344 <USBH_MSC_ErrorHandle>:
  * @param  status
  * @retval None
  */

void USBH_MSC_ErrorHandle(uint8_t status)
{  
 8005344:	b480      	push	{r7}
 8005346:	b083      	sub	sp, #12
 8005348:	af00      	add	r7, sp, #0
 800534a:	4603      	mov	r3, r0
 800534c:	71fb      	strb	r3, [r7, #7]
    if(status == USBH_MSC_FAIL)
 800534e:	79fb      	ldrb	r3, [r7, #7]
 8005350:	2b01      	cmp	r3, #1
 8005352:	d12a      	bne.n	80053aa <USBH_MSC_ErrorHandle+0x66>
    { 
      MSCErrorCount++;
 8005354:	f640 13fd 	movw	r3, #2557	; 0x9fd
 8005358:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800535c:	781b      	ldrb	r3, [r3, #0]
 800535e:	f103 0301 	add.w	r3, r3, #1
 8005362:	b2da      	uxtb	r2, r3
 8005364:	f640 13fd 	movw	r3, #2557	; 0x9fd
 8005368:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800536c:	701a      	strb	r2, [r3, #0]
      if(MSCErrorCount < USBH_MSC_ERROR_RETRY_LIMIT)
 800536e:	f640 13fd 	movw	r3, #2557	; 0x9fd
 8005372:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005376:	781b      	ldrb	r3, [r3, #0]
 8005378:	2b09      	cmp	r3, #9
 800537a:	d80e      	bhi.n	800539a <USBH_MSC_ErrorHandle+0x56>
      { /* Try MSC level error recovery, Issue the request Sense to get 
        Drive error reason  */
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_REQUEST_SENSE;
 800537c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005380:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005384:	f04f 0206 	mov.w	r2, #6
 8005388:	701a      	strb	r2, [r3, #0]
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 800538a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800538e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005392:	f04f 0201 	mov.w	r2, #1
 8005396:	70da      	strb	r2, [r3, #3]
 8005398:	e011      	b.n	80053be <USBH_MSC_ErrorHandle+0x7a>
      }
      else
      {
        /* Error trials exceeded the limit, go to unrecovered state */
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
 800539a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800539e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053a2:	f04f 020a 	mov.w	r2, #10
 80053a6:	701a      	strb	r2, [r3, #0]
 80053a8:	e009      	b.n	80053be <USBH_MSC_ErrorHandle+0x7a>
      }
    } 
    else if(status == USBH_MSC_PHASE_ERROR)
 80053aa:	79fb      	ldrb	r3, [r7, #7]
 80053ac:	2b02      	cmp	r3, #2
 80053ae:	d106      	bne.n	80053be <USBH_MSC_ErrorHandle+0x7a>
    {
      /* Phase error, Go to Unrecoovered state */
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
 80053b0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80053b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053b8:	f04f 020a 	mov.w	r2, #10
 80053bc:	701a      	strb	r2, [r3, #0]
    }
    else if(status == USBH_MSC_BUSY)
    {
      /*No change in state*/
    }
}
 80053be:	f107 070c 	add.w	r7, r7, #12
 80053c2:	46bd      	mov	sp, r7
 80053c4:	bc80      	pop	{r7}
 80053c6:	4770      	bx	lr

080053c8 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
                         BYTE drv		/* Physical drive number (0) */
                           )
{
 80053c8:	b580      	push	{r7, lr}
 80053ca:	b082      	sub	sp, #8
 80053cc:	af00      	add	r7, sp, #0
 80053ce:	4603      	mov	r3, r0
 80053d0:	71fb      	strb	r3, [r7, #7]

  if(HCD_IsDeviceConnected(&USB_OTG_Core))
 80053d2:	f640 30b4 	movw	r0, #2996	; 0xbb4
 80053d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80053da:	f7fc f923 	bl	8001624 <HCD_IsDeviceConnected>
 80053de:	4603      	mov	r3, r0
 80053e0:	2b00      	cmp	r3, #0
 80053e2:	d00d      	beq.n	8005400 <disk_initialize+0x38>
  {  
    Stat &= ~STA_NOINIT;
 80053e4:	f240 0320 	movw	r3, #32
 80053e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053ec:	781b      	ldrb	r3, [r3, #0]
 80053ee:	b2db      	uxtb	r3, r3
 80053f0:	f023 0301 	bic.w	r3, r3, #1
 80053f4:	b2da      	uxtb	r2, r3
 80053f6:	f240 0320 	movw	r3, #32
 80053fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053fe:	701a      	strb	r2, [r3, #0]
  }
  
  return Stat;
 8005400:	f240 0320 	movw	r3, #32
 8005404:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005408:	781b      	ldrb	r3, [r3, #0]
 800540a:	b2db      	uxtb	r3, r3
  
  
}
 800540c:	4618      	mov	r0, r3
 800540e:	f107 0708 	add.w	r7, r7, #8
 8005412:	46bd      	mov	sp, r7
 8005414:	bd80      	pop	{r7, pc}
 8005416:	bf00      	nop

08005418 <disk_status>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_status (
                     BYTE drv		/* Physical drive number (0) */
                       )
{
 8005418:	b480      	push	{r7}
 800541a:	b083      	sub	sp, #12
 800541c:	af00      	add	r7, sp, #0
 800541e:	4603      	mov	r3, r0
 8005420:	71fb      	strb	r3, [r7, #7]
  if (drv) return STA_NOINIT;		/* Supports only single drive */
 8005422:	79fb      	ldrb	r3, [r7, #7]
 8005424:	2b00      	cmp	r3, #0
 8005426:	d002      	beq.n	800542e <disk_status+0x16>
 8005428:	f04f 0301 	mov.w	r3, #1
 800542c:	e005      	b.n	800543a <disk_status+0x22>
  return Stat;
 800542e:	f240 0320 	movw	r3, #32
 8005432:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005436:	781b      	ldrb	r3, [r3, #0]
 8005438:	b2db      	uxtb	r3, r3
}
 800543a:	4618      	mov	r0, r3
 800543c:	f107 070c 	add.w	r7, r7, #12
 8005440:	46bd      	mov	sp, r7
 8005442:	bc80      	pop	{r7}
 8005444:	4770      	bx	lr
 8005446:	bf00      	nop

08005448 <disk_read>:
                   BYTE drv,			/* Physical drive number (0) */
                   BYTE *buff,			/* Pointer to the data buffer to store read data */
                   DWORD sector,		/* Start sector number (LBA) */
                   BYTE count			/* Sector count (1..255) */
                     )
{
 8005448:	b580      	push	{r7, lr}
 800544a:	b086      	sub	sp, #24
 800544c:	af00      	add	r7, sp, #0
 800544e:	60b9      	str	r1, [r7, #8]
 8005450:	607a      	str	r2, [r7, #4]
 8005452:	4602      	mov	r2, r0
 8005454:	73fa      	strb	r2, [r7, #15]
 8005456:	73bb      	strb	r3, [r7, #14]
  BYTE status = USBH_MSC_OK;
 8005458:	f04f 0300 	mov.w	r3, #0
 800545c:	75fb      	strb	r3, [r7, #23]
  
  if (drv || !count) return RES_PARERR;
 800545e:	7bfb      	ldrb	r3, [r7, #15]
 8005460:	2b00      	cmp	r3, #0
 8005462:	d102      	bne.n	800546a <disk_read+0x22>
 8005464:	7bbb      	ldrb	r3, [r7, #14]
 8005466:	2b00      	cmp	r3, #0
 8005468:	d102      	bne.n	8005470 <disk_read+0x28>
 800546a:	f04f 0304 	mov.w	r3, #4
 800546e:	e044      	b.n	80054fa <disk_read+0xb2>
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8005470:	f240 0320 	movw	r3, #32
 8005474:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005478:	781b      	ldrb	r3, [r3, #0]
 800547a:	b2db      	uxtb	r3, r3
 800547c:	f003 0301 	and.w	r3, r3, #1
 8005480:	b2db      	uxtb	r3, r3
 8005482:	2b00      	cmp	r3, #0
 8005484:	d002      	beq.n	800548c <disk_read+0x44>
 8005486:	f04f 0303 	mov.w	r3, #3
 800548a:	e036      	b.n	80054fa <disk_read+0xb2>
  
  
  if(HCD_IsDeviceConnected(&USB_OTG_Core))
 800548c:	f640 30b4 	movw	r0, #2996	; 0xbb4
 8005490:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005494:	f7fc f8c6 	bl	8001624 <HCD_IsDeviceConnected>
 8005498:	4603      	mov	r3, r0
 800549a:	2b00      	cmp	r3, #0
 800549c:	d025      	beq.n	80054ea <disk_read+0xa2>
  {  
    
    do
    {
      status = USBH_MSC_Read10(&USB_OTG_Core, buff, sector, 512*count);
 800549e:	7bbb      	ldrb	r3, [r7, #14]
 80054a0:	ea4f 2343 	mov.w	r3, r3, lsl #9
 80054a4:	f640 30b4 	movw	r0, #2996	; 0xbb4
 80054a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80054ac:	68b9      	ldr	r1, [r7, #8]
 80054ae:	687a      	ldr	r2, [r7, #4]
 80054b0:	f000 fd48 	bl	8005f44 <USBH_MSC_Read10>
 80054b4:	4603      	mov	r3, r0
 80054b6:	75fb      	strb	r3, [r7, #23]
      USBH_MSC_HandleBOTXfer(&USB_OTG_Core ,&USB_Host);
 80054b8:	f640 30b4 	movw	r0, #2996	; 0xbb4
 80054bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80054c0:	f241 0164 	movw	r1, #4196	; 0x1064
 80054c4:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80054c8:	f7ff f8a6 	bl	8004618 <USBH_MSC_HandleBOTXfer>
      
      if(!HCD_IsDeviceConnected(&USB_OTG_Core))
 80054cc:	f640 30b4 	movw	r0, #2996	; 0xbb4
 80054d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80054d4:	f7fc f8a6 	bl	8001624 <HCD_IsDeviceConnected>
 80054d8:	4603      	mov	r3, r0
 80054da:	2b00      	cmp	r3, #0
 80054dc:	d102      	bne.n	80054e4 <disk_read+0x9c>
      { 
        return RES_ERROR;
 80054de:	f04f 0301 	mov.w	r3, #1
 80054e2:	e00a      	b.n	80054fa <disk_read+0xb2>
      }      
    }
    while(status == USBH_MSC_BUSY );
 80054e4:	7dfb      	ldrb	r3, [r7, #23]
 80054e6:	2b03      	cmp	r3, #3
 80054e8:	d0d9      	beq.n	800549e <disk_read+0x56>
  }
  
  if(status == USBH_MSC_OK)
 80054ea:	7dfb      	ldrb	r3, [r7, #23]
 80054ec:	2b00      	cmp	r3, #0
 80054ee:	d102      	bne.n	80054f6 <disk_read+0xae>
    return RES_OK;
 80054f0:	f04f 0300 	mov.w	r3, #0
 80054f4:	e001      	b.n	80054fa <disk_read+0xb2>
  return RES_ERROR;
 80054f6:	f04f 0301 	mov.w	r3, #1
  
}
 80054fa:	4618      	mov	r0, r3
 80054fc:	f107 0718 	add.w	r7, r7, #24
 8005500:	46bd      	mov	sp, r7
 8005502:	bd80      	pop	{r7, pc}

08005504 <disk_write>:
                    BYTE drv,			/* Physical drive number (0) */
                    const BYTE *buff,	/* Pointer to the data to be written */
                    DWORD sector,		/* Start sector number (LBA) */
                    BYTE count			/* Sector count (1..255) */
                      )
{
 8005504:	b580      	push	{r7, lr}
 8005506:	b086      	sub	sp, #24
 8005508:	af00      	add	r7, sp, #0
 800550a:	60b9      	str	r1, [r7, #8]
 800550c:	607a      	str	r2, [r7, #4]
 800550e:	4602      	mov	r2, r0
 8005510:	73fa      	strb	r2, [r7, #15]
 8005512:	73bb      	strb	r3, [r7, #14]
  BYTE status = USBH_MSC_OK;
 8005514:	f04f 0300 	mov.w	r3, #0
 8005518:	75fb      	strb	r3, [r7, #23]
  if (drv || !count) return RES_PARERR;
 800551a:	7bfb      	ldrb	r3, [r7, #15]
 800551c:	2b00      	cmp	r3, #0
 800551e:	d102      	bne.n	8005526 <disk_write+0x22>
 8005520:	7bbb      	ldrb	r3, [r7, #14]
 8005522:	2b00      	cmp	r3, #0
 8005524:	d102      	bne.n	800552c <disk_write+0x28>
 8005526:	f04f 0304 	mov.w	r3, #4
 800552a:	e051      	b.n	80055d0 <disk_write+0xcc>
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 800552c:	f240 0320 	movw	r3, #32
 8005530:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005534:	781b      	ldrb	r3, [r3, #0]
 8005536:	b2db      	uxtb	r3, r3
 8005538:	f003 0301 	and.w	r3, r3, #1
 800553c:	b2db      	uxtb	r3, r3
 800553e:	2b00      	cmp	r3, #0
 8005540:	d002      	beq.n	8005548 <disk_write+0x44>
 8005542:	f04f 0303 	mov.w	r3, #3
 8005546:	e043      	b.n	80055d0 <disk_write+0xcc>
  if (Stat & STA_PROTECT) return RES_WRPRT;
 8005548:	f240 0320 	movw	r3, #32
 800554c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005550:	781b      	ldrb	r3, [r3, #0]
 8005552:	b2db      	uxtb	r3, r3
 8005554:	f003 0304 	and.w	r3, r3, #4
 8005558:	2b00      	cmp	r3, #0
 800555a:	d002      	beq.n	8005562 <disk_write+0x5e>
 800555c:	f04f 0302 	mov.w	r3, #2
 8005560:	e036      	b.n	80055d0 <disk_write+0xcc>
  
  
  if(HCD_IsDeviceConnected(&USB_OTG_Core))
 8005562:	f640 30b4 	movw	r0, #2996	; 0xbb4
 8005566:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800556a:	f7fc f85b 	bl	8001624 <HCD_IsDeviceConnected>
 800556e:	4603      	mov	r3, r0
 8005570:	2b00      	cmp	r3, #0
 8005572:	d025      	beq.n	80055c0 <disk_write+0xbc>
  {  
    do
    {
      status = USBH_MSC_Write10(&USB_OTG_Core,(BYTE*)buff, sector, 512*count);
 8005574:	7bbb      	ldrb	r3, [r7, #14]
 8005576:	ea4f 2343 	mov.w	r3, r3, lsl #9
 800557a:	f640 30b4 	movw	r0, #2996	; 0xbb4
 800557e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005582:	68b9      	ldr	r1, [r7, #8]
 8005584:	687a      	ldr	r2, [r7, #4]
 8005586:	f000 fbfb 	bl	8005d80 <USBH_MSC_Write10>
 800558a:	4603      	mov	r3, r0
 800558c:	75fb      	strb	r3, [r7, #23]
      USBH_MSC_HandleBOTXfer(&USB_OTG_Core, &USB_Host);
 800558e:	f640 30b4 	movw	r0, #2996	; 0xbb4
 8005592:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005596:	f241 0164 	movw	r1, #4196	; 0x1064
 800559a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800559e:	f7ff f83b 	bl	8004618 <USBH_MSC_HandleBOTXfer>
      
      if(!HCD_IsDeviceConnected(&USB_OTG_Core))
 80055a2:	f640 30b4 	movw	r0, #2996	; 0xbb4
 80055a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80055aa:	f7fc f83b 	bl	8001624 <HCD_IsDeviceConnected>
 80055ae:	4603      	mov	r3, r0
 80055b0:	2b00      	cmp	r3, #0
 80055b2:	d102      	bne.n	80055ba <disk_write+0xb6>
      { 
        return RES_ERROR;
 80055b4:	f04f 0301 	mov.w	r3, #1
 80055b8:	e00a      	b.n	80055d0 <disk_write+0xcc>
      }
    }
    
    while(status == USBH_MSC_BUSY );
 80055ba:	7dfb      	ldrb	r3, [r7, #23]
 80055bc:	2b03      	cmp	r3, #3
 80055be:	d0d9      	beq.n	8005574 <disk_write+0x70>
    
  }
  
  if(status == USBH_MSC_OK)
 80055c0:	7dfb      	ldrb	r3, [r7, #23]
 80055c2:	2b00      	cmp	r3, #0
 80055c4:	d102      	bne.n	80055cc <disk_write+0xc8>
    return RES_OK;
 80055c6:	f04f 0300 	mov.w	r3, #0
 80055ca:	e001      	b.n	80055d0 <disk_write+0xcc>
  return RES_ERROR;
 80055cc:	f04f 0301 	mov.w	r3, #1
}
 80055d0:	4618      	mov	r0, r3
 80055d2:	f107 0718 	add.w	r7, r7, #24
 80055d6:	46bd      	mov	sp, r7
 80055d8:	bd80      	pop	{r7, pc}
 80055da:	bf00      	nop

080055dc <disk_ioctl>:
DRESULT disk_ioctl (
                    BYTE drv,		/* Physical drive number (0) */
                    BYTE ctrl,		/* Control code */
                    void *buff		/* Buffer to send/receive control data */
                      )
{
 80055dc:	b480      	push	{r7}
 80055de:	b085      	sub	sp, #20
 80055e0:	af00      	add	r7, sp, #0
 80055e2:	460b      	mov	r3, r1
 80055e4:	603a      	str	r2, [r7, #0]
 80055e6:	4602      	mov	r2, r0
 80055e8:	71fa      	strb	r2, [r7, #7]
 80055ea:	71bb      	strb	r3, [r7, #6]
  DRESULT res = RES_OK;
 80055ec:	f04f 0300 	mov.w	r3, #0
 80055f0:	73fb      	strb	r3, [r7, #15]
  
  if (drv) return RES_PARERR;
 80055f2:	79fb      	ldrb	r3, [r7, #7]
 80055f4:	2b00      	cmp	r3, #0
 80055f6:	d002      	beq.n	80055fe <disk_ioctl+0x22>
 80055f8:	f04f 0304 	mov.w	r3, #4
 80055fc:	e03f      	b.n	800567e <disk_ioctl+0xa2>
  
  res = RES_ERROR;
 80055fe:	f04f 0301 	mov.w	r3, #1
 8005602:	73fb      	strb	r3, [r7, #15]
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8005604:	f240 0320 	movw	r3, #32
 8005608:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800560c:	781b      	ldrb	r3, [r3, #0]
 800560e:	b2db      	uxtb	r3, r3
 8005610:	f003 0301 	and.w	r3, r3, #1
 8005614:	b2db      	uxtb	r3, r3
 8005616:	2b00      	cmp	r3, #0
 8005618:	d002      	beq.n	8005620 <disk_ioctl+0x44>
 800561a:	f04f 0303 	mov.w	r3, #3
 800561e:	e02e      	b.n	800567e <disk_ioctl+0xa2>
  
  switch (ctrl) {
 8005620:	79bb      	ldrb	r3, [r7, #6]
 8005622:	2b03      	cmp	r3, #3
 8005624:	d826      	bhi.n	8005674 <disk_ioctl+0x98>
 8005626:	a201      	add	r2, pc, #4	; (adr r2, 800562c <disk_ioctl+0x50>)
 8005628:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800562c:	0800563d 	.word	0x0800563d
 8005630:	08005645 	.word	0x08005645
 8005634:	0800565b 	.word	0x0800565b
 8005638:	0800566b 	.word	0x0800566b
  case CTRL_SYNC :		/* Make sure that no pending write process */
    
    res = RES_OK;
 800563c:	f04f 0300 	mov.w	r3, #0
 8005640:	73fb      	strb	r3, [r7, #15]
    break;
 8005642:	e01b      	b.n	800567c <disk_ioctl+0xa0>
    
  case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
    
    *(DWORD*)buff = (DWORD) USBH_MSC_Param.MSCapacity;
 8005644:	f244 3374 	movw	r3, #17268	; 0x4374
 8005648:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800564c:	681a      	ldr	r2, [r3, #0]
 800564e:	683b      	ldr	r3, [r7, #0]
 8005650:	601a      	str	r2, [r3, #0]
    res = RES_OK;
 8005652:	f04f 0300 	mov.w	r3, #0
 8005656:	73fb      	strb	r3, [r7, #15]
    break;
 8005658:	e010      	b.n	800567c <disk_ioctl+0xa0>
    
  case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
    *(WORD*)buff = 512;
 800565a:	683b      	ldr	r3, [r7, #0]
 800565c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005660:	801a      	strh	r2, [r3, #0]
    res = RES_OK;
 8005662:	f04f 0300 	mov.w	r3, #0
 8005666:	73fb      	strb	r3, [r7, #15]
    break;
 8005668:	e008      	b.n	800567c <disk_ioctl+0xa0>
    
  case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
    
    *(DWORD*)buff = 512;
 800566a:	683b      	ldr	r3, [r7, #0]
 800566c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005670:	601a      	str	r2, [r3, #0]
    
    break;
 8005672:	e003      	b.n	800567c <disk_ioctl+0xa0>
    
    
  default:
    res = RES_PARERR;
 8005674:	f04f 0304 	mov.w	r3, #4
 8005678:	73fb      	strb	r3, [r7, #15]
    break;
 800567a:	bf00      	nop
  }
  
  
  
  return res;
 800567c:	7bfb      	ldrb	r3, [r7, #15]
}
 800567e:	4618      	mov	r0, r3
 8005680:	f107 0714 	add.w	r7, r7, #20
 8005684:	46bd      	mov	sp, r7
 8005686:	bc80      	pop	{r7}
 8005688:	4770      	bx	lr
 800568a:	bf00      	nop

0800568c <USBH_MSC_TestUnitReady>:
  *         received, it updates the status to upper layer.
  * @param  None
  * @retval Status
  */
uint8_t USBH_MSC_TestUnitReady (USB_OTG_CORE_HANDLE *pdev)
{
 800568c:	b580      	push	{r7, lr}
 800568e:	b084      	sub	sp, #16
 8005690:	af00      	add	r7, sp, #0
 8005692:	6078      	str	r0, [r7, #4]
  uint8_t index;
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 8005694:	f04f 0303 	mov.w	r3, #3
 8005698:	73bb      	strb	r3, [r7, #14]
  
  if(HCD_IsDeviceConnected(pdev))
 800569a:	6878      	ldr	r0, [r7, #4]
 800569c:	f7fb ffc2 	bl	8001624 <HCD_IsDeviceConnected>
 80056a0:	4603      	mov	r3, r0
 80056a2:	2b00      	cmp	r3, #0
 80056a4:	f000 80a9 	beq.w	80057fa <USBH_MSC_TestUnitReady+0x16e>
  {  
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 80056a8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80056ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056b0:	78db      	ldrb	r3, [r3, #3]
 80056b2:	2b01      	cmp	r3, #1
 80056b4:	d002      	beq.n	80056bc <USBH_MSC_TestUnitReady+0x30>
 80056b6:	2b02      	cmp	r3, #2
 80056b8:	d067      	beq.n	800578a <USBH_MSC_TestUnitReady+0xfe>
 80056ba:	e09c      	b.n	80057f6 <USBH_MSC_TestUnitReady+0x16a>
    {
    case CMD_SEND_STATE:  
      /*Prepare the CBW and relevent field*/
      USBH_MSC_CBWData.field.CBWTransferLength = 0;       /* No Data Transfer */
 80056bc:	f244 1300 	movw	r3, #16640	; 0x4100
 80056c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056c4:	f04f 0200 	mov.w	r2, #0
 80056c8:	609a      	str	r2, [r3, #8]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_OUT;
 80056ca:	f244 1300 	movw	r3, #16640	; 0x4100
 80056ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056d2:	f04f 0200 	mov.w	r2, #0
 80056d6:	731a      	strb	r2, [r3, #12]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH_TEST_UNIT_READY;
 80056d8:	f244 1300 	movw	r3, #16640	; 0x4100
 80056dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056e0:	f04f 0206 	mov.w	r2, #6
 80056e4:	739a      	strb	r2, [r3, #14]
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
 80056e6:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80056ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056ee:	f244 02e0 	movw	r2, #16608	; 0x40e0
 80056f2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80056f6:	609a      	str	r2, [r3, #8]
      USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
 80056f8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80056fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005700:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8005704:	819a      	strh	r2, [r3, #12]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_TEST_UNIT_READY;
 8005706:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800570a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800570e:	f04f 0203 	mov.w	r2, #3
 8005712:	709a      	strb	r2, [r3, #2]
      
      for(index = CBW_CB_LENGTH; index != 0; index--)
 8005714:	f04f 0310 	mov.w	r3, #16
 8005718:	73fb      	strb	r3, [r7, #15]
 800571a:	e00c      	b.n	8005736 <USBH_MSC_TestUnitReady+0xaa>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
 800571c:	7bfa      	ldrb	r2, [r7, #15]
 800571e:	f244 1300 	movw	r3, #16640	; 0x4100
 8005722:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005726:	189b      	adds	r3, r3, r2
 8005728:	f04f 0200 	mov.w	r2, #0
 800572c:	73da      	strb	r2, [r3, #15]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH_TEST_UNIT_READY;
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
      USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_TEST_UNIT_READY;
      
      for(index = CBW_CB_LENGTH; index != 0; index--)
 800572e:	7bfb      	ldrb	r3, [r7, #15]
 8005730:	f103 33ff 	add.w	r3, r3, #4294967295
 8005734:	73fb      	strb	r3, [r7, #15]
 8005736:	7bfb      	ldrb	r3, [r7, #15]
 8005738:	2b00      	cmp	r3, #0
 800573a:	d1ef      	bne.n	800571c <USBH_MSC_TestUnitReady+0x90>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
      }
      
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_TEST_UNIT_READY; 
 800573c:	f244 1300 	movw	r3, #16640	; 0x4100
 8005740:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005744:	f04f 0200 	mov.w	r2, #0
 8005748:	73da      	strb	r2, [r3, #15]
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 800574a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800574e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005752:	f04f 0201 	mov.w	r2, #1
 8005756:	711a      	strb	r2, [r3, #4]
      /* Start the transfer, then let the state 
      machine magage the other transactions */
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8005758:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800575c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005760:	f04f 0207 	mov.w	r2, #7
 8005764:	701a      	strb	r2, [r3, #0]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8005766:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800576a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800576e:	f04f 0203 	mov.w	r2, #3
 8005772:	73da      	strb	r2, [r3, #15]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8005774:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005778:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800577c:	f04f 0202 	mov.w	r2, #2
 8005780:	70da      	strb	r2, [r3, #3]
      
      status = USBH_MSC_BUSY; 
 8005782:	f04f 0303 	mov.w	r3, #3
 8005786:	73bb      	strb	r3, [r7, #14]
      break;
 8005788:	e037      	b.n	80057fa <USBH_MSC_TestUnitReady+0x16e>
      
    case CMD_WAIT_STATUS: 
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 800578a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800578e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005792:	7bdb      	ldrb	r3, [r3, #15]
 8005794:	2b00      	cmp	r3, #0
 8005796:	d10a      	bne.n	80057ae <USBH_MSC_TestUnitReady+0x122>
      { 
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005798:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800579c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057a0:	f04f 0201 	mov.w	r2, #1
 80057a4:	70da      	strb	r2, [r3, #3]
       
        status = USBH_MSC_OK;      
 80057a6:	f04f 0300 	mov.w	r3, #0
 80057aa:	73bb      	strb	r3, [r7, #14]
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_PHASE_ERROR;    
      }  
      break;
 80057ac:	e024      	b.n	80057f8 <USBH_MSC_TestUnitReady+0x16c>
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
       
        status = USBH_MSC_OK;      
      }
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 80057ae:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80057b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057b6:	7bdb      	ldrb	r3, [r3, #15]
 80057b8:	2b01      	cmp	r3, #1
 80057ba:	d10a      	bne.n	80057d2 <USBH_MSC_TestUnitReady+0x146>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 80057bc:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80057c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057c4:	f04f 0201 	mov.w	r2, #1
 80057c8:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_FAIL;
 80057ca:	f04f 0301 	mov.w	r3, #1
 80057ce:	73bb      	strb	r3, [r7, #14]
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_PHASE_ERROR;    
      }  
      break;
 80057d0:	e012      	b.n	80057f8 <USBH_MSC_TestUnitReady+0x16c>
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_FAIL;
      }
      
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 80057d2:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80057d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057da:	7bdb      	ldrb	r3, [r3, #15]
 80057dc:	2b02      	cmp	r3, #2
 80057de:	d10b      	bne.n	80057f8 <USBH_MSC_TestUnitReady+0x16c>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 80057e0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80057e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057e8:	f04f 0201 	mov.w	r2, #1
 80057ec:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_PHASE_ERROR;    
 80057ee:	f04f 0302 	mov.w	r3, #2
 80057f2:	73bb      	strb	r3, [r7, #14]
      }  
      break;
 80057f4:	e000      	b.n	80057f8 <USBH_MSC_TestUnitReady+0x16c>
      
    default:
      break;
 80057f6:	e000      	b.n	80057fa <USBH_MSC_TestUnitReady+0x16e>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_PHASE_ERROR;    
      }  
      break;
 80057f8:	bf00      	nop
      
    default:
      break;
    }
  }
  return status;
 80057fa:	7bbb      	ldrb	r3, [r7, #14]
}
 80057fc:	4618      	mov	r0, r3
 80057fe:	f107 0710 	add.w	r7, r7, #16
 8005802:	46bd      	mov	sp, r7
 8005804:	bd80      	pop	{r7, pc}
 8005806:	bf00      	nop

08005808 <USBH_MSC_ReadCapacity10>:
  *         received, it updates the status to upper layer
  * @param  None
  * @retval Status
  */
uint8_t USBH_MSC_ReadCapacity10(USB_OTG_CORE_HANDLE *pdev)
{
 8005808:	b580      	push	{r7, lr}
 800580a:	b084      	sub	sp, #16
 800580c:	af00      	add	r7, sp, #0
 800580e:	6078      	str	r0, [r7, #4]
  uint8_t index;
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 8005810:	f04f 0303 	mov.w	r3, #3
 8005814:	73bb      	strb	r3, [r7, #14]
  
  if(HCD_IsDeviceConnected(pdev))
 8005816:	6878      	ldr	r0, [r7, #4]
 8005818:	f7fb ff04 	bl	8001624 <HCD_IsDeviceConnected>
 800581c:	4603      	mov	r3, r0
 800581e:	2b00      	cmp	r3, #0
 8005820:	f000 80cf 	beq.w	80059c2 <USBH_MSC_ReadCapacity10+0x1ba>
  {  
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8005824:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005828:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800582c:	78db      	ldrb	r3, [r3, #3]
 800582e:	2b01      	cmp	r3, #1
 8005830:	d002      	beq.n	8005838 <USBH_MSC_ReadCapacity10+0x30>
 8005832:	2b02      	cmp	r3, #2
 8005834:	d060      	beq.n	80058f8 <USBH_MSC_ReadCapacity10+0xf0>
 8005836:	e0c2      	b.n	80059be <USBH_MSC_ReadCapacity10+0x1b6>
    {
    case CMD_SEND_STATE:
      /*Prepare the CBW and relevent field*/
      USBH_MSC_CBWData.field.CBWTransferLength = XFER_LEN_READ_CAPACITY10;
 8005838:	f244 1300 	movw	r3, #16640	; 0x4100
 800583c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005840:	f04f 0208 	mov.w	r2, #8
 8005844:	609a      	str	r2, [r3, #8]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8005846:	f244 1300 	movw	r3, #16640	; 0x4100
 800584a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800584e:	f04f 0280 	mov.w	r2, #128	; 0x80
 8005852:	731a      	strb	r2, [r3, #12]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8005854:	f244 1300 	movw	r3, #16640	; 0x4100
 8005858:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800585c:	f04f 020a 	mov.w	r2, #10
 8005860:	739a      	strb	r2, [r3, #14]
      
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
 8005862:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005866:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800586a:	f244 1274 	movw	r2, #16756	; 0x4174
 800586e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005872:	609a      	str	r2, [r3, #8]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_READ_CAPACITY10;
 8005874:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005878:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800587c:	f04f 0204 	mov.w	r2, #4
 8005880:	709a      	strb	r2, [r3, #2]
      
      for(index = CBW_CB_LENGTH; index != 0; index--)
 8005882:	f04f 0310 	mov.w	r3, #16
 8005886:	73fb      	strb	r3, [r7, #15]
 8005888:	e00c      	b.n	80058a4 <USBH_MSC_ReadCapacity10+0x9c>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
 800588a:	7bfa      	ldrb	r2, [r7, #15]
 800588c:	f244 1300 	movw	r3, #16640	; 0x4100
 8005890:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005894:	189b      	adds	r3, r3, r2
 8005896:	f04f 0200 	mov.w	r2, #0
 800589a:	73da      	strb	r2, [r3, #15]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
      
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_READ_CAPACITY10;
      
      for(index = CBW_CB_LENGTH; index != 0; index--)
 800589c:	7bfb      	ldrb	r3, [r7, #15]
 800589e:	f103 33ff 	add.w	r3, r3, #4294967295
 80058a2:	73fb      	strb	r3, [r7, #15]
 80058a4:	7bfb      	ldrb	r3, [r7, #15]
 80058a6:	2b00      	cmp	r3, #0
 80058a8:	d1ef      	bne.n	800588a <USBH_MSC_ReadCapacity10+0x82>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
      }    
      
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_READ_CAPACITY10; 
 80058aa:	f244 1300 	movw	r3, #16640	; 0x4100
 80058ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058b2:	f04f 0225 	mov.w	r2, #37	; 0x25
 80058b6:	73da      	strb	r2, [r3, #15]
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 80058b8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80058bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058c0:	f04f 0201 	mov.w	r2, #1
 80058c4:	711a      	strb	r2, [r3, #4]
      
      /* Start the transfer, then let the state machine manage the other 
                                                                transactions */
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 80058c6:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80058ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058ce:	f04f 0207 	mov.w	r2, #7
 80058d2:	701a      	strb	r2, [r3, #0]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 80058d4:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80058d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058dc:	f04f 0203 	mov.w	r2, #3
 80058e0:	73da      	strb	r2, [r3, #15]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 80058e2:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80058e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058ea:	f04f 0202 	mov.w	r2, #2
 80058ee:	70da      	strb	r2, [r3, #3]
      
      status = USBH_MSC_BUSY;
 80058f0:	f04f 0303 	mov.w	r3, #3
 80058f4:	73bb      	strb	r3, [r7, #14]
      break;
 80058f6:	e064      	b.n	80059c2 <USBH_MSC_ReadCapacity10+0x1ba>
      
    case CMD_WAIT_STATUS:
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 80058f8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80058fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005900:	7bdb      	ldrb	r3, [r3, #15]
 8005902:	2b00      	cmp	r3, #0
 8005904:	d137      	bne.n	8005976 <USBH_MSC_ReadCapacity10+0x16e>
      {
        /*assign the capacity*/
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[3]) = USBH_DataInBuffer[0];
 8005906:	4a32      	ldr	r2, [pc, #200]	; (80059d0 <USBH_MSC_ReadCapacity10+0x1c8>)
 8005908:	f244 1374 	movw	r3, #16756	; 0x4174
 800590c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005910:	781b      	ldrb	r3, [r3, #0]
 8005912:	7013      	strb	r3, [r2, #0]
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[2]) = USBH_DataInBuffer[1];
 8005914:	4a2f      	ldr	r2, [pc, #188]	; (80059d4 <USBH_MSC_ReadCapacity10+0x1cc>)
 8005916:	f244 1374 	movw	r3, #16756	; 0x4174
 800591a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800591e:	785b      	ldrb	r3, [r3, #1]
 8005920:	7013      	strb	r3, [r2, #0]
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[1]) = USBH_DataInBuffer[2];
 8005922:	4a2d      	ldr	r2, [pc, #180]	; (80059d8 <USBH_MSC_ReadCapacity10+0x1d0>)
 8005924:	f244 1374 	movw	r3, #16756	; 0x4174
 8005928:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800592c:	789b      	ldrb	r3, [r3, #2]
 800592e:	7013      	strb	r3, [r2, #0]
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[0]) = USBH_DataInBuffer[3];
 8005930:	f244 3374 	movw	r3, #17268	; 0x4374
 8005934:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005938:	f244 1274 	movw	r2, #16756	; 0x4174
 800593c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005940:	78d2      	ldrb	r2, [r2, #3]
 8005942:	701a      	strb	r2, [r3, #0]
        
        /*assign the page length*/
        (((uint8_t*)&USBH_MSC_Param.MSPageLength )[1]) = USBH_DataInBuffer[6];
 8005944:	4a25      	ldr	r2, [pc, #148]	; (80059dc <USBH_MSC_ReadCapacity10+0x1d4>)
 8005946:	f244 1374 	movw	r3, #16756	; 0x4174
 800594a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800594e:	799b      	ldrb	r3, [r3, #6]
 8005950:	7013      	strb	r3, [r2, #0]
        (((uint8_t*)&USBH_MSC_Param.MSPageLength )[0]) = USBH_DataInBuffer[7];
 8005952:	4a23      	ldr	r2, [pc, #140]	; (80059e0 <USBH_MSC_ReadCapacity10+0x1d8>)
 8005954:	f244 1374 	movw	r3, #16756	; 0x4174
 8005958:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800595c:	79db      	ldrb	r3, [r3, #7]
 800595e:	7013      	strb	r3, [r2, #0]
        
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005960:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005964:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005968:	f04f 0201 	mov.w	r2, #1
 800596c:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_OK;      
 800596e:	f04f 0300 	mov.w	r3, #0
 8005972:	73bb      	strb	r3, [r7, #14]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005974:	e024      	b.n	80059c0 <USBH_MSC_ReadCapacity10+0x1b8>
        
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_OK;      
      }
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 8005976:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800597a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800597e:	7bdb      	ldrb	r3, [r3, #15]
 8005980:	2b01      	cmp	r3, #1
 8005982:	d10a      	bne.n	800599a <USBH_MSC_ReadCapacity10+0x192>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005984:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005988:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800598c:	f04f 0201 	mov.w	r2, #1
 8005990:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_FAIL;
 8005992:	f04f 0301 	mov.w	r3, #1
 8005996:	73bb      	strb	r3, [r7, #14]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005998:	e012      	b.n	80059c0 <USBH_MSC_ReadCapacity10+0x1b8>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_FAIL;
      }  
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 800599a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800599e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059a2:	7bdb      	ldrb	r3, [r3, #15]
 80059a4:	2b02      	cmp	r3, #2
 80059a6:	d10b      	bne.n	80059c0 <USBH_MSC_ReadCapacity10+0x1b8>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 80059a8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80059ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059b0:	f04f 0201 	mov.w	r2, #1
 80059b4:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_PHASE_ERROR;    
 80059b6:	f04f 0302 	mov.w	r3, #2
 80059ba:	73bb      	strb	r3, [r7, #14]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 80059bc:	e000      	b.n	80059c0 <USBH_MSC_ReadCapacity10+0x1b8>
      
    default:
      break;
 80059be:	e000      	b.n	80059c2 <USBH_MSC_ReadCapacity10+0x1ba>
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 80059c0:	bf00      	nop
      
    default:
      break;
    }
  }
  return status;
 80059c2:	7bbb      	ldrb	r3, [r7, #14]
}
 80059c4:	4618      	mov	r0, r3
 80059c6:	f107 0710 	add.w	r7, r7, #16
 80059ca:	46bd      	mov	sp, r7
 80059cc:	bd80      	pop	{r7, pc}
 80059ce:	bf00      	nop
 80059d0:	20004377 	.word	0x20004377
 80059d4:	20004376 	.word	0x20004376
 80059d8:	20004375 	.word	0x20004375
 80059dc:	2000437d 	.word	0x2000437d
 80059e0:	2000437c 	.word	0x2000437c

080059e4 <USBH_MSC_ModeSense6>:
  *          for reading the WriteProtect Status of the Mass-Storage device. 
  * @param  None
  * @retval Status
  */
uint8_t USBH_MSC_ModeSense6(USB_OTG_CORE_HANDLE *pdev)
{
 80059e4:	b580      	push	{r7, lr}
 80059e6:	b084      	sub	sp, #16
 80059e8:	af00      	add	r7, sp, #0
 80059ea:	6078      	str	r0, [r7, #4]
  uint8_t index;
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 80059ec:	f04f 0303 	mov.w	r3, #3
 80059f0:	73bb      	strb	r3, [r7, #14]
  
  if(HCD_IsDeviceConnected(pdev))
 80059f2:	6878      	ldr	r0, [r7, #4]
 80059f4:	f7fb fe16 	bl	8001624 <HCD_IsDeviceConnected>
 80059f8:	4603      	mov	r3, r0
 80059fa:	2b00      	cmp	r3, #0
 80059fc:	f000 80c8 	beq.w	8005b90 <USBH_MSC_ModeSense6+0x1ac>
  {  
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8005a00:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005a04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a08:	78db      	ldrb	r3, [r3, #3]
 8005a0a:	2b01      	cmp	r3, #1
 8005a0c:	d002      	beq.n	8005a14 <USBH_MSC_ModeSense6+0x30>
 8005a0e:	2b02      	cmp	r3, #2
 8005a10:	d06e      	beq.n	8005af0 <USBH_MSC_ModeSense6+0x10c>
 8005a12:	e0bb      	b.n	8005b8c <USBH_MSC_ModeSense6+0x1a8>
    {
    case CMD_SEND_STATE:
      /*Prepare the CBW and relevent field*/
      USBH_MSC_CBWData.field.CBWTransferLength = XFER_LEN_MODE_SENSE6;
 8005a14:	f244 1300 	movw	r3, #16640	; 0x4100
 8005a18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a1c:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8005a20:	609a      	str	r2, [r3, #8]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8005a22:	f244 1300 	movw	r3, #16640	; 0x4100
 8005a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a2a:	f04f 0280 	mov.w	r2, #128	; 0x80
 8005a2e:	731a      	strb	r2, [r3, #12]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8005a30:	f244 1300 	movw	r3, #16640	; 0x4100
 8005a34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a38:	f04f 020a 	mov.w	r2, #10
 8005a3c:	739a      	strb	r2, [r3, #14]
      
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
 8005a3e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005a42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a46:	f244 1274 	movw	r2, #16756	; 0x4174
 8005a4a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005a4e:	609a      	str	r2, [r3, #8]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_MODE_SENSE6;
 8005a50:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005a54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a58:	f04f 0205 	mov.w	r2, #5
 8005a5c:	709a      	strb	r2, [r3, #2]
      
      for(index = CBW_CB_LENGTH; index != 0; index--)
 8005a5e:	f04f 0310 	mov.w	r3, #16
 8005a62:	73fb      	strb	r3, [r7, #15]
 8005a64:	e00c      	b.n	8005a80 <USBH_MSC_ModeSense6+0x9c>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
 8005a66:	7bfa      	ldrb	r2, [r7, #15]
 8005a68:	f244 1300 	movw	r3, #16640	; 0x4100
 8005a6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a70:	189b      	adds	r3, r3, r2
 8005a72:	f04f 0200 	mov.w	r2, #0
 8005a76:	73da      	strb	r2, [r3, #15]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
      
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_MODE_SENSE6;
      
      for(index = CBW_CB_LENGTH; index != 0; index--)
 8005a78:	7bfb      	ldrb	r3, [r7, #15]
 8005a7a:	f103 33ff 	add.w	r3, r3, #4294967295
 8005a7e:	73fb      	strb	r3, [r7, #15]
 8005a80:	7bfb      	ldrb	r3, [r7, #15]
 8005a82:	2b00      	cmp	r3, #0
 8005a84:	d1ef      	bne.n	8005a66 <USBH_MSC_ModeSense6+0x82>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
      }    
      
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_MODE_SENSE6; 
 8005a86:	f244 1300 	movw	r3, #16640	; 0x4100
 8005a8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a8e:	f04f 021a 	mov.w	r2, #26
 8005a92:	73da      	strb	r2, [r3, #15]
      USBH_MSC_CBWData.field.CBWCB[2]  = MODE_SENSE_PAGE_CONTROL_FIELD | \
 8005a94:	f244 1300 	movw	r3, #16640	; 0x4100
 8005a98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a9c:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8005aa0:	745a      	strb	r2, [r3, #17]
                                         MODE_SENSE_PAGE_CODE;
                                           
      USBH_MSC_CBWData.field.CBWCB[4]  = XFER_LEN_MODE_SENSE6;
 8005aa2:	f244 1300 	movw	r3, #16640	; 0x4100
 8005aa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005aaa:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8005aae:	74da      	strb	r2, [r3, #19]
                                                                                      
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 8005ab0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005ab4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ab8:	f04f 0201 	mov.w	r2, #1
 8005abc:	711a      	strb	r2, [r3, #4]
      
      /* Start the transfer, then let the state machine manage the other 
                                                                transactions */
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8005abe:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005ac2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ac6:	f04f 0207 	mov.w	r2, #7
 8005aca:	701a      	strb	r2, [r3, #0]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8005acc:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005ad0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ad4:	f04f 0203 	mov.w	r2, #3
 8005ad8:	73da      	strb	r2, [r3, #15]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8005ada:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005ade:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ae2:	f04f 0202 	mov.w	r2, #2
 8005ae6:	70da      	strb	r2, [r3, #3]
      
      status = USBH_MSC_BUSY;
 8005ae8:	f04f 0303 	mov.w	r3, #3
 8005aec:	73bb      	strb	r3, [r7, #14]
      break;
 8005aee:	e04f      	b.n	8005b90 <USBH_MSC_ModeSense6+0x1ac>
      
    case CMD_WAIT_STATUS:
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 8005af0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005af8:	7bdb      	ldrb	r3, [r3, #15]
 8005afa:	2b00      	cmp	r3, #0
 8005afc:	d122      	bne.n	8005b44 <USBH_MSC_ModeSense6+0x160>
      {
        /* Assign the Write Protect status */
        /* If WriteProtect = 0, Writing is allowed 
           If WriteProtect != 0, Disk is Write Protected */
        if ( USBH_DataInBuffer[2] & MASK_MODE_SENSE_WRITE_PROTECT)
 8005afe:	f244 1374 	movw	r3, #16756	; 0x4174
 8005b02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b06:	789b      	ldrb	r3, [r3, #2]
 8005b08:	b2db      	uxtb	r3, r3
 8005b0a:	b25b      	sxtb	r3, r3
 8005b0c:	2b00      	cmp	r3, #0
 8005b0e:	da07      	bge.n	8005b20 <USBH_MSC_ModeSense6+0x13c>
        {
          USBH_MSC_Param.MSWriteProtect   = DISK_WRITE_PROTECTED;
 8005b10:	f244 3374 	movw	r3, #17268	; 0x4374
 8005b14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b18:	f04f 0201 	mov.w	r2, #1
 8005b1c:	731a      	strb	r2, [r3, #12]
 8005b1e:	e006      	b.n	8005b2e <USBH_MSC_ModeSense6+0x14a>
        }
        else
        {
          USBH_MSC_Param.MSWriteProtect   = 0;
 8005b20:	f244 3374 	movw	r3, #17268	; 0x4374
 8005b24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b28:	f04f 0200 	mov.w	r2, #0
 8005b2c:	731a      	strb	r2, [r3, #12]
        }
        
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005b2e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005b32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b36:	f04f 0201 	mov.w	r2, #1
 8005b3a:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_OK;      
 8005b3c:	f04f 0300 	mov.w	r3, #0
 8005b40:	73bb      	strb	r3, [r7, #14]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005b42:	e024      	b.n	8005b8e <USBH_MSC_ModeSense6+0x1aa>
        
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_OK;      
      }
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 8005b44:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005b48:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b4c:	7bdb      	ldrb	r3, [r3, #15]
 8005b4e:	2b01      	cmp	r3, #1
 8005b50:	d10a      	bne.n	8005b68 <USBH_MSC_ModeSense6+0x184>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005b52:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005b56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b5a:	f04f 0201 	mov.w	r2, #1
 8005b5e:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_FAIL;
 8005b60:	f04f 0301 	mov.w	r3, #1
 8005b64:	73bb      	strb	r3, [r7, #14]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005b66:	e012      	b.n	8005b8e <USBH_MSC_ModeSense6+0x1aa>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_FAIL;
      }
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8005b68:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b70:	7bdb      	ldrb	r3, [r3, #15]
 8005b72:	2b02      	cmp	r3, #2
 8005b74:	d10b      	bne.n	8005b8e <USBH_MSC_ModeSense6+0x1aa>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005b76:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005b7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b7e:	f04f 0201 	mov.w	r2, #1
 8005b82:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_PHASE_ERROR;    
 8005b84:	f04f 0302 	mov.w	r3, #2
 8005b88:	73bb      	strb	r3, [r7, #14]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005b8a:	e000      	b.n	8005b8e <USBH_MSC_ModeSense6+0x1aa>
      
    default:
      break;
 8005b8c:	e000      	b.n	8005b90 <USBH_MSC_ModeSense6+0x1ac>
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005b8e:	bf00      	nop
      
    default:
      break;
    }
  }
  return status;
 8005b90:	7bbb      	ldrb	r3, [r7, #14]
}
 8005b92:	4618      	mov	r0, r3
 8005b94:	f107 0710 	add.w	r7, r7, #16
 8005b98:	46bd      	mov	sp, r7
 8005b9a:	bd80      	pop	{r7, pc}

08005b9c <USBH_MSC_RequestSense>:
  *         received, it updates the status to upper layer
  * @param  None
  * @retval Status
  */
uint8_t USBH_MSC_RequestSense(USB_OTG_CORE_HANDLE *pdev)
{
 8005b9c:	b580      	push	{r7, lr}
 8005b9e:	b084      	sub	sp, #16
 8005ba0:	af00      	add	r7, sp, #0
 8005ba2:	6078      	str	r0, [r7, #4]
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 8005ba4:	f04f 0303 	mov.w	r3, #3
 8005ba8:	73fb      	strb	r3, [r7, #15]
  
  uint8_t index;
  
  
  if(HCD_IsDeviceConnected(pdev))
 8005baa:	6878      	ldr	r0, [r7, #4]
 8005bac:	f7fb fd3a 	bl	8001624 <HCD_IsDeviceConnected>
 8005bb0:	4603      	mov	r3, r0
 8005bb2:	2b00      	cmp	r3, #0
 8005bb4:	f000 80d6 	beq.w	8005d64 <USBH_MSC_RequestSense+0x1c8>
  {  
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8005bb8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005bbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bc0:	78db      	ldrb	r3, [r3, #3]
 8005bc2:	2b01      	cmp	r3, #1
 8005bc4:	d002      	beq.n	8005bcc <USBH_MSC_RequestSense+0x30>
 8005bc6:	2b02      	cmp	r3, #2
 8005bc8:	d078      	beq.n	8005cbc <USBH_MSC_RequestSense+0x120>
 8005bca:	e0c9      	b.n	8005d60 <USBH_MSC_RequestSense+0x1c4>
    {
    case CMD_SEND_STATE:
      
      /*Prepare the CBW and relevent field*/
      USBH_MSC_CBWData.field.CBWTransferLength = \
 8005bcc:	f244 1300 	movw	r3, #16640	; 0x4100
 8005bd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bd4:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8005bd8:	609a      	str	r2, [r3, #8]
                                                ALLOCATION_LENGTH_REQUEST_SENSE;
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8005bda:	f244 1300 	movw	r3, #16640	; 0x4100
 8005bde:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005be2:	f04f 0280 	mov.w	r2, #128	; 0x80
 8005be6:	731a      	strb	r2, [r3, #12]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8005be8:	f244 1300 	movw	r3, #16640	; 0x4100
 8005bec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bf0:	f04f 020a 	mov.w	r2, #10
 8005bf4:	739a      	strb	r2, [r3, #14]
      
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
 8005bf6:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005bfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bfe:	f244 1274 	movw	r2, #16756	; 0x4174
 8005c02:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005c06:	609a      	str	r2, [r3, #8]
      USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_BOTXferParam.MSCStateCurrent;
 8005c08:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005c0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c10:	789a      	ldrb	r2, [r3, #2]
 8005c12:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005c16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c1a:	705a      	strb	r2, [r3, #1]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_REQUEST_SENSE;
 8005c1c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005c20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c24:	f04f 0206 	mov.w	r2, #6
 8005c28:	709a      	strb	r2, [r3, #2]
      

      for(index = CBW_CB_LENGTH; index != 0; index--)
 8005c2a:	f04f 0310 	mov.w	r3, #16
 8005c2e:	73bb      	strb	r3, [r7, #14]
 8005c30:	e00c      	b.n	8005c4c <USBH_MSC_RequestSense+0xb0>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
 8005c32:	7bba      	ldrb	r2, [r7, #14]
 8005c34:	f244 1300 	movw	r3, #16640	; 0x4100
 8005c38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c3c:	189b      	adds	r3, r3, r2
 8005c3e:	f04f 0200 	mov.w	r2, #0
 8005c42:	73da      	strb	r2, [r3, #15]
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
      USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_BOTXferParam.MSCStateCurrent;
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_REQUEST_SENSE;
      

      for(index = CBW_CB_LENGTH; index != 0; index--)
 8005c44:	7bbb      	ldrb	r3, [r7, #14]
 8005c46:	f103 33ff 	add.w	r3, r3, #4294967295
 8005c4a:	73bb      	strb	r3, [r7, #14]
 8005c4c:	7bbb      	ldrb	r3, [r7, #14]
 8005c4e:	2b00      	cmp	r3, #0
 8005c50:	d1ef      	bne.n	8005c32 <USBH_MSC_RequestSense+0x96>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
      }    
      
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_REQUEST_SENSE; 
 8005c52:	f244 1300 	movw	r3, #16640	; 0x4100
 8005c56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c5a:	f04f 0203 	mov.w	r2, #3
 8005c5e:	73da      	strb	r2, [r3, #15]
      USBH_MSC_CBWData.field.CBWCB[1]  = DESC_REQUEST_SENSE;
 8005c60:	f244 1300 	movw	r3, #16640	; 0x4100
 8005c64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c68:	f04f 0200 	mov.w	r2, #0
 8005c6c:	741a      	strb	r2, [r3, #16]
      USBH_MSC_CBWData.field.CBWCB[4]  = ALLOCATION_LENGTH_REQUEST_SENSE;
 8005c6e:	f244 1300 	movw	r3, #16640	; 0x4100
 8005c72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c76:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8005c7a:	74da      	strb	r2, [r3, #19]
      
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 8005c7c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c84:	f04f 0201 	mov.w	r2, #1
 8005c88:	711a      	strb	r2, [r3, #4]
      /* Start the transfer, then let the state machine magage 
      the other transactions */
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8005c8a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005c8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c92:	f04f 0207 	mov.w	r2, #7
 8005c96:	701a      	strb	r2, [r3, #0]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8005c98:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005c9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ca0:	f04f 0203 	mov.w	r2, #3
 8005ca4:	73da      	strb	r2, [r3, #15]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8005ca6:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005caa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cae:	f04f 0202 	mov.w	r2, #2
 8005cb2:	70da      	strb	r2, [r3, #3]
      
      status = USBH_MSC_BUSY;
 8005cb4:	f04f 0303 	mov.w	r3, #3
 8005cb8:	73fb      	strb	r3, [r7, #15]
      
      break;
 8005cba:	e053      	b.n	8005d64 <USBH_MSC_RequestSense+0x1c8>
      
    case CMD_WAIT_STATUS:
      
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 8005cbc:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005cc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cc4:	7bdb      	ldrb	r3, [r3, #15]
 8005cc6:	2b00      	cmp	r3, #0
 8005cc8:	d126      	bne.n	8005d18 <USBH_MSC_RequestSense+0x17c>
      {
        /* Get Sense data*/
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[3]) = USBH_DataInBuffer[0];
 8005cca:	4a29      	ldr	r2, [pc, #164]	; (8005d70 <USBH_MSC_RequestSense+0x1d4>)
 8005ccc:	f244 1374 	movw	r3, #16756	; 0x4174
 8005cd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cd4:	781b      	ldrb	r3, [r3, #0]
 8005cd6:	7013      	strb	r3, [r2, #0]
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[2]) = USBH_DataInBuffer[1];
 8005cd8:	4a26      	ldr	r2, [pc, #152]	; (8005d74 <USBH_MSC_RequestSense+0x1d8>)
 8005cda:	f244 1374 	movw	r3, #16756	; 0x4174
 8005cde:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ce2:	785b      	ldrb	r3, [r3, #1]
 8005ce4:	7013      	strb	r3, [r2, #0]
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[1]) = USBH_DataInBuffer[2];
 8005ce6:	4a24      	ldr	r2, [pc, #144]	; (8005d78 <USBH_MSC_RequestSense+0x1dc>)
 8005ce8:	f244 1374 	movw	r3, #16756	; 0x4174
 8005cec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cf0:	789b      	ldrb	r3, [r3, #2]
 8005cf2:	7013      	strb	r3, [r2, #0]
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[0]) = USBH_DataInBuffer[3];
 8005cf4:	4a21      	ldr	r2, [pc, #132]	; (8005d7c <USBH_MSC_RequestSense+0x1e0>)
 8005cf6:	f244 1374 	movw	r3, #16756	; 0x4174
 8005cfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cfe:	78db      	ldrb	r3, [r3, #3]
 8005d00:	7013      	strb	r3, [r2, #0]
        
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005d02:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005d06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d0a:	f04f 0201 	mov.w	r2, #1
 8005d0e:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_OK;      
 8005d10:	f04f 0300 	mov.w	r3, #0
 8005d14:	73fb      	strb	r3, [r7, #15]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005d16:	e024      	b.n	8005d62 <USBH_MSC_RequestSense+0x1c6>
        
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_OK;      
      }
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 8005d18:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005d1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d20:	7bdb      	ldrb	r3, [r3, #15]
 8005d22:	2b01      	cmp	r3, #1
 8005d24:	d10a      	bne.n	8005d3c <USBH_MSC_RequestSense+0x1a0>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005d26:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005d2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d2e:	f04f 0201 	mov.w	r2, #1
 8005d32:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_FAIL;
 8005d34:	f04f 0301 	mov.w	r3, #1
 8005d38:	73fb      	strb	r3, [r7, #15]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005d3a:	e012      	b.n	8005d62 <USBH_MSC_RequestSense+0x1c6>
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_FAIL;
      }
      
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8005d3c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005d40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d44:	7bdb      	ldrb	r3, [r3, #15]
 8005d46:	2b02      	cmp	r3, #2
 8005d48:	d10b      	bne.n	8005d62 <USBH_MSC_RequestSense+0x1c6>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005d4a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005d4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d52:	f04f 0201 	mov.w	r2, #1
 8005d56:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_PHASE_ERROR;    
 8005d58:	f04f 0302 	mov.w	r3, #2
 8005d5c:	73fb      	strb	r3, [r7, #15]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005d5e:	e000      	b.n	8005d62 <USBH_MSC_RequestSense+0x1c6>
      
    default:
      break;
 8005d60:	e000      	b.n	8005d64 <USBH_MSC_RequestSense+0x1c8>
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8005d62:	bf00      	nop
      
    default:
      break;
    }
  }
  return status;
 8005d64:	7bfb      	ldrb	r3, [r7, #15]
}
 8005d66:	4618      	mov	r0, r3
 8005d68:	f107 0710 	add.w	r7, r7, #16
 8005d6c:	46bd      	mov	sp, r7
 8005d6e:	bd80      	pop	{r7, pc}
 8005d70:	2000437b 	.word	0x2000437b
 8005d74:	2000437a 	.word	0x2000437a
 8005d78:	20004379 	.word	0x20004379
 8005d7c:	20004378 	.word	0x20004378

08005d80 <USBH_MSC_Write10>:
  */
uint8_t USBH_MSC_Write10(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dataBuffer,
                         uint32_t address,
                         uint32_t nbOfbytes)
{
 8005d80:	b580      	push	{r7, lr}
 8005d82:	b086      	sub	sp, #24
 8005d84:	af00      	add	r7, sp, #0
 8005d86:	60f8      	str	r0, [r7, #12]
 8005d88:	60b9      	str	r1, [r7, #8]
 8005d8a:	607a      	str	r2, [r7, #4]
 8005d8c:	603b      	str	r3, [r7, #0]
  uint8_t index;
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 8005d8e:	f04f 0303 	mov.w	r3, #3
 8005d92:	75bb      	strb	r3, [r7, #22]
  uint16_t nbOfPages;
  
  if(HCD_IsDeviceConnected(pdev))
 8005d94:	68f8      	ldr	r0, [r7, #12]
 8005d96:	f7fb fc45 	bl	8001624 <HCD_IsDeviceConnected>
 8005d9a:	4603      	mov	r3, r0
 8005d9c:	2b00      	cmp	r3, #0
 8005d9e:	f000 80ca 	beq.w	8005f36 <USBH_MSC_Write10+0x1b6>
  {  
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8005da2:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005da6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005daa:	78db      	ldrb	r3, [r3, #3]
 8005dac:	2b01      	cmp	r3, #1
 8005dae:	d003      	beq.n	8005db8 <USBH_MSC_Write10+0x38>
 8005db0:	2b02      	cmp	r3, #2
 8005db2:	f000 808b 	beq.w	8005ecc <USBH_MSC_Write10+0x14c>
 8005db6:	e0bc      	b.n	8005f32 <USBH_MSC_Write10+0x1b2>
    {
    case CMD_SEND_STATE:   
      USBH_MSC_CBWData.field.CBWTransferLength = nbOfbytes;
 8005db8:	f244 1300 	movw	r3, #16640	; 0x4100
 8005dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005dc0:	683a      	ldr	r2, [r7, #0]
 8005dc2:	609a      	str	r2, [r3, #8]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_OUT;
 8005dc4:	f244 1300 	movw	r3, #16640	; 0x4100
 8005dc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005dcc:	f04f 0200 	mov.w	r2, #0
 8005dd0:	731a      	strb	r2, [r3, #12]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8005dd2:	f244 1300 	movw	r3, #16640	; 0x4100
 8005dd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005dda:	f04f 020a 	mov.w	r2, #10
 8005dde:	739a      	strb	r2, [r3, #14]
      USBH_MSC_BOTXferParam.pRxTxBuff = dataBuffer;
 8005de0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005de4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005de8:	68ba      	ldr	r2, [r7, #8]
 8005dea:	609a      	str	r2, [r3, #8]
      
      
      for(index = CBW_CB_LENGTH; index != 0; index--)  
 8005dec:	f04f 0310 	mov.w	r3, #16
 8005df0:	75fb      	strb	r3, [r7, #23]
 8005df2:	e00c      	b.n	8005e0e <USBH_MSC_Write10+0x8e>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
 8005df4:	7dfa      	ldrb	r2, [r7, #23]
 8005df6:	f244 1300 	movw	r3, #16640	; 0x4100
 8005dfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005dfe:	189b      	adds	r3, r3, r2
 8005e00:	f04f 0200 	mov.w	r2, #0
 8005e04:	73da      	strb	r2, [r3, #15]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_OUT;
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
      USBH_MSC_BOTXferParam.pRxTxBuff = dataBuffer;
      
      
      for(index = CBW_CB_LENGTH; index != 0; index--)  
 8005e06:	7dfb      	ldrb	r3, [r7, #23]
 8005e08:	f103 33ff 	add.w	r3, r3, #4294967295
 8005e0c:	75fb      	strb	r3, [r7, #23]
 8005e0e:	7dfb      	ldrb	r3, [r7, #23]
 8005e10:	2b00      	cmp	r3, #0
 8005e12:	d1ef      	bne.n	8005df4 <USBH_MSC_Write10+0x74>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
      }
      
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_WRITE10; 
 8005e14:	f244 1300 	movw	r3, #16640	; 0x4100
 8005e18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e1c:	f04f 022a 	mov.w	r2, #42	; 0x2a
 8005e20:	73da      	strb	r2, [r3, #15]
      
      /*logical block address*/
      USBH_MSC_CBWData.field.CBWCB[2]  = (((uint8_t*)&address)[3]) ;
 8005e22:	f107 0304 	add.w	r3, r7, #4
 8005e26:	78da      	ldrb	r2, [r3, #3]
 8005e28:	f244 1300 	movw	r3, #16640	; 0x4100
 8005e2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e30:	745a      	strb	r2, [r3, #17]
      USBH_MSC_CBWData.field.CBWCB[3]  = (((uint8_t*)&address)[2]);
 8005e32:	f107 0304 	add.w	r3, r7, #4
 8005e36:	789a      	ldrb	r2, [r3, #2]
 8005e38:	f244 1300 	movw	r3, #16640	; 0x4100
 8005e3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e40:	749a      	strb	r2, [r3, #18]
      USBH_MSC_CBWData.field.CBWCB[4]  = (((uint8_t*)&address)[1]);
 8005e42:	f107 0304 	add.w	r3, r7, #4
 8005e46:	785a      	ldrb	r2, [r3, #1]
 8005e48:	f244 1300 	movw	r3, #16640	; 0x4100
 8005e4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e50:	74da      	strb	r2, [r3, #19]
      USBH_MSC_CBWData.field.CBWCB[5]  = (((uint8_t*)&address)[0]);
 8005e52:	f107 0304 	add.w	r3, r7, #4
 8005e56:	781a      	ldrb	r2, [r3, #0]
 8005e58:	f244 1300 	movw	r3, #16640	; 0x4100
 8005e5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e60:	751a      	strb	r2, [r3, #20]
      
      /*USBH_MSC_PAGE_LENGTH = 512*/
      nbOfPages = nbOfbytes/ USBH_MSC_PAGE_LENGTH; 
 8005e62:	683b      	ldr	r3, [r7, #0]
 8005e64:	ea4f 2353 	mov.w	r3, r3, lsr #9
 8005e68:	b29b      	uxth	r3, r3
 8005e6a:	82bb      	strh	r3, [r7, #20]
      
      /*Tranfer length */
      USBH_MSC_CBWData.field.CBWCB[7]  = (((uint8_t *)&nbOfPages)[1]) ; 
 8005e6c:	f107 0314 	add.w	r3, r7, #20
 8005e70:	785a      	ldrb	r2, [r3, #1]
 8005e72:	f244 1300 	movw	r3, #16640	; 0x4100
 8005e76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e7a:	759a      	strb	r2, [r3, #22]
      USBH_MSC_CBWData.field.CBWCB[8]  = (((uint8_t *)&nbOfPages)[0]) ; 
 8005e7c:	f107 0314 	add.w	r3, r7, #20
 8005e80:	781a      	ldrb	r2, [r3, #0]
 8005e82:	f244 1300 	movw	r3, #16640	; 0x4100
 8005e86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e8a:	75da      	strb	r2, [r3, #23]
      
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 8005e8c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005e90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e94:	f04f 0201 	mov.w	r2, #1
 8005e98:	711a      	strb	r2, [r3, #4]
      /* Start the transfer, then let the state machine 
      magage the other transactions */
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8005e9a:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005e9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ea2:	f04f 0207 	mov.w	r2, #7
 8005ea6:	701a      	strb	r2, [r3, #0]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8005ea8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005eac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005eb0:	f04f 0203 	mov.w	r2, #3
 8005eb4:	73da      	strb	r2, [r3, #15]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8005eb6:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005eba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ebe:	f04f 0202 	mov.w	r2, #2
 8005ec2:	70da      	strb	r2, [r3, #3]
      
      status = USBH_MSC_BUSY;
 8005ec4:	f04f 0303 	mov.w	r3, #3
 8005ec8:	75bb      	strb	r3, [r7, #22]
      
      break;
 8005eca:	e034      	b.n	8005f36 <USBH_MSC_Write10+0x1b6>
      
    case CMD_WAIT_STATUS:
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 8005ecc:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005ed0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ed4:	7bdb      	ldrb	r3, [r3, #15]
 8005ed6:	2b00      	cmp	r3, #0
 8005ed8:	d10a      	bne.n	8005ef0 <USBH_MSC_Write10+0x170>
      { 
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005eda:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005ede:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ee2:	f04f 0201 	mov.w	r2, #1
 8005ee6:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_OK;      
 8005ee8:	f04f 0300 	mov.w	r3, #0
 8005eec:	75bb      	strb	r3, [r7, #22]
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_PHASE_ERROR;    
      }
      break;
 8005eee:	e021      	b.n	8005f34 <USBH_MSC_Write10+0x1b4>
      { 
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_OK;      
      }
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 8005ef0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005ef4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ef8:	7bdb      	ldrb	r3, [r3, #15]
 8005efa:	2b01      	cmp	r3, #1
 8005efc:	d107      	bne.n	8005f0e <USBH_MSC_Write10+0x18e>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005efe:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005f02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f06:	f04f 0201 	mov.w	r2, #1
 8005f0a:	70da      	strb	r2, [r3, #3]
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_PHASE_ERROR;    
      }
      break;
 8005f0c:	e012      	b.n	8005f34 <USBH_MSC_Write10+0x1b4>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
      }
      
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8005f0e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005f12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f16:	7bdb      	ldrb	r3, [r3, #15]
 8005f18:	2b02      	cmp	r3, #2
 8005f1a:	d10b      	bne.n	8005f34 <USBH_MSC_Write10+0x1b4>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8005f1c:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005f20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f24:	f04f 0201 	mov.w	r2, #1
 8005f28:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_PHASE_ERROR;    
 8005f2a:	f04f 0302 	mov.w	r3, #2
 8005f2e:	75bb      	strb	r3, [r7, #22]
      }
      break;
 8005f30:	e000      	b.n	8005f34 <USBH_MSC_Write10+0x1b4>
      
    default:
      break;
 8005f32:	e000      	b.n	8005f36 <USBH_MSC_Write10+0x1b6>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_PHASE_ERROR;    
      }
      break;
 8005f34:	bf00      	nop
      
    default:
      break;
    }
  }
  return status;
 8005f36:	7dbb      	ldrb	r3, [r7, #22]
}
 8005f38:	4618      	mov	r0, r3
 8005f3a:	f107 0718 	add.w	r7, r7, #24
 8005f3e:	46bd      	mov	sp, r7
 8005f40:	bd80      	pop	{r7, pc}
 8005f42:	bf00      	nop

08005f44 <USBH_MSC_Read10>:
  */
uint8_t USBH_MSC_Read10(USB_OTG_CORE_HANDLE *pdev,
                        uint8_t *dataBuffer,
                        uint32_t address,
                        uint32_t nbOfbytes)
{
 8005f44:	b580      	push	{r7, lr}
 8005f46:	b086      	sub	sp, #24
 8005f48:	af00      	add	r7, sp, #0
 8005f4a:	60f8      	str	r0, [r7, #12]
 8005f4c:	60b9      	str	r1, [r7, #8]
 8005f4e:	607a      	str	r2, [r7, #4]
 8005f50:	603b      	str	r3, [r7, #0]
  uint8_t index;
  static USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
  uint16_t nbOfPages;
  status = USBH_MSC_BUSY;
 8005f52:	f240 0321 	movw	r3, #33	; 0x21
 8005f56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f5a:	f04f 0203 	mov.w	r2, #3
 8005f5e:	701a      	strb	r2, [r3, #0]
  
  if(HCD_IsDeviceConnected(pdev))
 8005f60:	68f8      	ldr	r0, [r7, #12]
 8005f62:	f7fb fb5f 	bl	8001624 <HCD_IsDeviceConnected>
 8005f66:	4603      	mov	r3, r0
 8005f68:	2b00      	cmp	r3, #0
 8005f6a:	f000 80e3 	beq.w	8006134 <USBH_MSC_Read10+0x1f0>
  {
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8005f6e:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005f72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f76:	78db      	ldrb	r3, [r3, #3]
 8005f78:	2b01      	cmp	r3, #1
 8005f7a:	d003      	beq.n	8005f84 <USBH_MSC_Read10+0x40>
 8005f7c:	2b02      	cmp	r3, #2
 8005f7e:	f000 808f 	beq.w	80060a0 <USBH_MSC_Read10+0x15c>
 8005f82:	e0d5      	b.n	8006130 <USBH_MSC_Read10+0x1ec>
    {
    case CMD_SEND_STATE:
      /*Prepare the CBW and relevent field*/
      USBH_MSC_CBWData.field.CBWTransferLength = nbOfbytes;
 8005f84:	f244 1300 	movw	r3, #16640	; 0x4100
 8005f88:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f8c:	683a      	ldr	r2, [r7, #0]
 8005f8e:	609a      	str	r2, [r3, #8]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8005f90:	f244 1300 	movw	r3, #16640	; 0x4100
 8005f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f98:	f04f 0280 	mov.w	r2, #128	; 0x80
 8005f9c:	731a      	strb	r2, [r3, #12]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8005f9e:	f244 1300 	movw	r3, #16640	; 0x4100
 8005fa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005fa6:	f04f 020a 	mov.w	r2, #10
 8005faa:	739a      	strb	r2, [r3, #14]
      
      USBH_MSC_BOTXferParam.pRxTxBuff = dataBuffer;
 8005fac:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8005fb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005fb4:	68ba      	ldr	r2, [r7, #8]
 8005fb6:	609a      	str	r2, [r3, #8]
      
      for(index = CBW_CB_LENGTH; index != 0; index--)
 8005fb8:	f04f 0310 	mov.w	r3, #16
 8005fbc:	75fb      	strb	r3, [r7, #23]
 8005fbe:	e00c      	b.n	8005fda <USBH_MSC_Read10+0x96>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
 8005fc0:	7dfa      	ldrb	r2, [r7, #23]
 8005fc2:	f244 1300 	movw	r3, #16640	; 0x4100
 8005fc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005fca:	189b      	adds	r3, r3, r2
 8005fcc:	f04f 0200 	mov.w	r2, #0
 8005fd0:	73da      	strb	r2, [r3, #15]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
      
      USBH_MSC_BOTXferParam.pRxTxBuff = dataBuffer;
      
      for(index = CBW_CB_LENGTH; index != 0; index--)
 8005fd2:	7dfb      	ldrb	r3, [r7, #23]
 8005fd4:	f103 33ff 	add.w	r3, r3, #4294967295
 8005fd8:	75fb      	strb	r3, [r7, #23]
 8005fda:	7dfb      	ldrb	r3, [r7, #23]
 8005fdc:	2b00      	cmp	r3, #0
 8005fde:	d1ef      	bne.n	8005fc0 <USBH_MSC_Read10+0x7c>
      {
        USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
      }
      
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_READ10; 
 8005fe0:	f244 1300 	movw	r3, #16640	; 0x4100
 8005fe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005fe8:	f04f 0228 	mov.w	r2, #40	; 0x28
 8005fec:	73da      	strb	r2, [r3, #15]
      
      /*logical block address*/
      
      USBH_MSC_CBWData.field.CBWCB[2]  = (((uint8_t*)&address)[3]);
 8005fee:	f107 0304 	add.w	r3, r7, #4
 8005ff2:	78da      	ldrb	r2, [r3, #3]
 8005ff4:	f244 1300 	movw	r3, #16640	; 0x4100
 8005ff8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ffc:	745a      	strb	r2, [r3, #17]
      USBH_MSC_CBWData.field.CBWCB[3]  = (((uint8_t*)&address)[2]);
 8005ffe:	f107 0304 	add.w	r3, r7, #4
 8006002:	789a      	ldrb	r2, [r3, #2]
 8006004:	f244 1300 	movw	r3, #16640	; 0x4100
 8006008:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800600c:	749a      	strb	r2, [r3, #18]
      USBH_MSC_CBWData.field.CBWCB[4]  = (((uint8_t*)&address)[1]);
 800600e:	f107 0304 	add.w	r3, r7, #4
 8006012:	785a      	ldrb	r2, [r3, #1]
 8006014:	f244 1300 	movw	r3, #16640	; 0x4100
 8006018:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800601c:	74da      	strb	r2, [r3, #19]
      USBH_MSC_CBWData.field.CBWCB[5]  = (((uint8_t*)&address)[0]);
 800601e:	f107 0304 	add.w	r3, r7, #4
 8006022:	781a      	ldrb	r2, [r3, #0]
 8006024:	f244 1300 	movw	r3, #16640	; 0x4100
 8006028:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800602c:	751a      	strb	r2, [r3, #20]
      
      /*USBH_MSC_PAGE_LENGTH = 512*/
      nbOfPages = nbOfbytes/ USBH_MSC_PAGE_LENGTH;  
 800602e:	683b      	ldr	r3, [r7, #0]
 8006030:	ea4f 2353 	mov.w	r3, r3, lsr #9
 8006034:	b29b      	uxth	r3, r3
 8006036:	82bb      	strh	r3, [r7, #20]
      
      /*Tranfer length */
      USBH_MSC_CBWData.field.CBWCB[7]  = (((uint8_t *)&nbOfPages)[1]) ; 
 8006038:	f107 0314 	add.w	r3, r7, #20
 800603c:	785a      	ldrb	r2, [r3, #1]
 800603e:	f244 1300 	movw	r3, #16640	; 0x4100
 8006042:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006046:	759a      	strb	r2, [r3, #22]
      USBH_MSC_CBWData.field.CBWCB[8]  = (((uint8_t *)&nbOfPages)[0]) ; 
 8006048:	f107 0314 	add.w	r3, r7, #20
 800604c:	781a      	ldrb	r2, [r3, #0]
 800604e:	f244 1300 	movw	r3, #16640	; 0x4100
 8006052:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006056:	75da      	strb	r2, [r3, #23]
      
      
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 8006058:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800605c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006060:	f04f 0201 	mov.w	r2, #1
 8006064:	711a      	strb	r2, [r3, #4]
      /* Start the transfer, then let the state machine 
      magage the other transactions */
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8006066:	f244 03f0 	movw	r3, #16624	; 0x40f0
 800606a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800606e:	f04f 0207 	mov.w	r2, #7
 8006072:	701a      	strb	r2, [r3, #0]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8006074:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8006078:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800607c:	f04f 0203 	mov.w	r2, #3
 8006080:	73da      	strb	r2, [r3, #15]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8006082:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8006086:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800608a:	f04f 0202 	mov.w	r2, #2
 800608e:	70da      	strb	r2, [r3, #3]
      
      status = USBH_MSC_BUSY;
 8006090:	f240 0321 	movw	r3, #33	; 0x21
 8006094:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006098:	f04f 0203 	mov.w	r2, #3
 800609c:	701a      	strb	r2, [r3, #0]
      
      break;
 800609e:	e049      	b.n	8006134 <USBH_MSC_Read10+0x1f0>
      
    case CMD_WAIT_STATUS:
      
      if((USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK) && \
 80060a0:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80060a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060a8:	7bdb      	ldrb	r3, [r3, #15]
 80060aa:	2b00      	cmp	r3, #0
 80060ac:	d114      	bne.n	80060d8 <USBH_MSC_Read10+0x194>
        (HCD_IsDeviceConnected(pdev)))
 80060ae:	68f8      	ldr	r0, [r7, #12]
 80060b0:	f7fb fab8 	bl	8001624 <HCD_IsDeviceConnected>
 80060b4:	4603      	mov	r3, r0
      
      break;
      
    case CMD_WAIT_STATUS:
      
      if((USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK) && \
 80060b6:	2b00      	cmp	r3, #0
 80060b8:	d00e      	beq.n	80060d8 <USBH_MSC_Read10+0x194>
        (HCD_IsDeviceConnected(pdev)))
      { 
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 80060ba:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80060be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060c2:	f04f 0201 	mov.w	r2, #1
 80060c6:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_OK;      
 80060c8:	f240 0321 	movw	r3, #33	; 0x21
 80060cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060d0:	f04f 0200 	mov.w	r2, #0
 80060d4:	701a      	strb	r2, [r3, #0]
 80060d6:	e02a      	b.n	800612e <USBH_MSC_Read10+0x1ea>
      }
      else if (( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL ) && \
 80060d8:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80060dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060e0:	7bdb      	ldrb	r3, [r3, #15]
 80060e2:	2b01      	cmp	r3, #1
 80060e4:	d10d      	bne.n	8006102 <USBH_MSC_Read10+0x1be>
        (HCD_IsDeviceConnected(pdev)))
 80060e6:	68f8      	ldr	r0, [r7, #12]
 80060e8:	f7fb fa9c 	bl	8001624 <HCD_IsDeviceConnected>
 80060ec:	4603      	mov	r3, r0
      { 
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_OK;      
      }
      else if (( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL ) && \
 80060ee:	2b00      	cmp	r3, #0
 80060f0:	d007      	beq.n	8006102 <USBH_MSC_Read10+0x1be>
        (HCD_IsDeviceConnected(pdev)))
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 80060f2:	f244 03f0 	movw	r3, #16624	; 0x40f0
 80060f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060fa:	f04f 0201 	mov.w	r2, #1
 80060fe:	70da      	strb	r2, [r3, #3]
 8006100:	e015      	b.n	800612e <USBH_MSC_Read10+0x1ea>
      }
      
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8006102:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8006106:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800610a:	7bdb      	ldrb	r3, [r3, #15]
 800610c:	2b02      	cmp	r3, #2
 800610e:	d110      	bne.n	8006132 <USBH_MSC_Read10+0x1ee>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8006110:	f244 03f0 	movw	r3, #16624	; 0x40f0
 8006114:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006118:	f04f 0201 	mov.w	r2, #1
 800611c:	70da      	strb	r2, [r3, #3]
        status = USBH_MSC_PHASE_ERROR;    
 800611e:	f240 0321 	movw	r3, #33	; 0x21
 8006122:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006126:	f04f 0202 	mov.w	r2, #2
 800612a:	701a      	strb	r2, [r3, #0]
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 800612c:	e001      	b.n	8006132 <USBH_MSC_Read10+0x1ee>
 800612e:	e000      	b.n	8006132 <USBH_MSC_Read10+0x1ee>
      
    default:
      break;
 8006130:	e000      	b.n	8006134 <USBH_MSC_Read10+0x1f0>
      else
      {
        /* Wait for the Commands to get Completed */
        /* NO Change in state Machine */
      }
      break;
 8006132:	bf00      	nop
      
    default:
      break;
    }
  }
  return status;
 8006134:	f240 0321 	movw	r3, #33	; 0x21
 8006138:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800613c:	781b      	ldrb	r3, [r3, #0]
}
 800613e:	4618      	mov	r0, r3
 8006140:	f107 0718 	add.w	r7, r7, #24
 8006144:	46bd      	mov	sp, r7
 8006146:	bd80      	pop	{r7, pc}

08006148 <NVIC_PriorityGroupConfig>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 8006148:	b480      	push	{r7}
 800614a:	b083      	sub	sp, #12
 800614c:	af00      	add	r7, sp, #0
 800614e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8006150:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8006154:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8006158:	687a      	ldr	r2, [r7, #4]
 800615a:	f042 62be 	orr.w	r2, r2, #99614720	; 0x5f00000
 800615e:	f442 2220 	orr.w	r2, r2, #655360	; 0xa0000
 8006162:	60da      	str	r2, [r3, #12]
}
 8006164:	f107 070c 	add.w	r7, r7, #12
 8006168:	46bd      	mov	sp, r7
 800616a:	bc80      	pop	{r7}
 800616c:	4770      	bx	lr
 800616e:	bf00      	nop

08006170 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8006170:	b480      	push	{r7}
 8006172:	b085      	sub	sp, #20
 8006174:	af00      	add	r7, sp, #0
 8006176:	6078      	str	r0, [r7, #4]
  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 8006178:	f04f 0300 	mov.w	r3, #0
 800617c:	73fb      	strb	r3, [r7, #15]
 800617e:	f04f 0300 	mov.w	r3, #0
 8006182:	73bb      	strb	r3, [r7, #14]
 8006184:	f04f 030f 	mov.w	r3, #15
 8006188:	737b      	strb	r3, [r7, #13]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 800618a:	687b      	ldr	r3, [r7, #4]
 800618c:	78db      	ldrb	r3, [r3, #3]
 800618e:	2b00      	cmp	r3, #0
 8006190:	d045      	beq.n	800621e <NVIC_Init+0xae>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8006192:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8006196:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800619a:	68db      	ldr	r3, [r3, #12]
 800619c:	ea6f 0303 	mvn.w	r3, r3
 80061a0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80061a4:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80061a8:	73fb      	strb	r3, [r7, #15]
    tmppre = (0x4 - tmppriority);
 80061aa:	7bfb      	ldrb	r3, [r7, #15]
 80061ac:	f1c3 0304 	rsb	r3, r3, #4
 80061b0:	73bb      	strb	r3, [r7, #14]
    tmpsub = tmpsub >> tmppriority;
 80061b2:	7b7a      	ldrb	r2, [r7, #13]
 80061b4:	7bfb      	ldrb	r3, [r7, #15]
 80061b6:	fa42 f303 	asr.w	r3, r2, r3
 80061ba:	737b      	strb	r3, [r7, #13]

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80061bc:	687b      	ldr	r3, [r7, #4]
 80061be:	785b      	ldrb	r3, [r3, #1]
 80061c0:	461a      	mov	r2, r3
 80061c2:	7bbb      	ldrb	r3, [r7, #14]
 80061c4:	fa02 f303 	lsl.w	r3, r2, r3
 80061c8:	73fb      	strb	r3, [r7, #15]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80061ca:	687b      	ldr	r3, [r7, #4]
 80061cc:	789a      	ldrb	r2, [r3, #2]
 80061ce:	7b7b      	ldrb	r3, [r7, #13]
 80061d0:	4013      	ands	r3, r2
 80061d2:	b2da      	uxtb	r2, r3
 80061d4:	7bfb      	ldrb	r3, [r7, #15]
 80061d6:	4313      	orrs	r3, r2
 80061d8:	73fb      	strb	r3, [r7, #15]
        
    tmppriority = tmppriority << 0x04;
 80061da:	7bfb      	ldrb	r3, [r7, #15]
 80061dc:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80061e0:	73fb      	strb	r3, [r7, #15]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80061e2:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80061e6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80061ea:	687a      	ldr	r2, [r7, #4]
 80061ec:	7812      	ldrb	r2, [r2, #0]
 80061ee:	189b      	adds	r3, r3, r2
 80061f0:	7bfa      	ldrb	r2, [r7, #15]
 80061f2:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80061f6:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80061fa:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80061fe:	687a      	ldr	r2, [r7, #4]
 8006200:	7812      	ldrb	r2, [r2, #0]
 8006202:	ea4f 1252 	mov.w	r2, r2, lsr #5
 8006206:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8006208:	6879      	ldr	r1, [r7, #4]
 800620a:	7809      	ldrb	r1, [r1, #0]
 800620c:	f001 011f 	and.w	r1, r1, #31
 8006210:	f04f 0001 	mov.w	r0, #1
 8006214:	fa00 f101 	lsl.w	r1, r0, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8006218:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800621c:	e014      	b.n	8006248 <NVIC_Init+0xd8>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800621e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8006222:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8006226:	687a      	ldr	r2, [r7, #4]
 8006228:	7812      	ldrb	r2, [r2, #0]
 800622a:	ea4f 1252 	mov.w	r2, r2, lsr #5
 800622e:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8006230:	6879      	ldr	r1, [r7, #4]
 8006232:	7809      	ldrb	r1, [r1, #0]
 8006234:	f001 011f 	and.w	r1, r1, #31
 8006238:	f04f 0001 	mov.w	r0, #1
 800623c:	fa00 f101 	lsl.w	r1, r0, r1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8006240:	f102 0220 	add.w	r2, r2, #32
 8006244:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8006248:	f107 0714 	add.w	r7, r7, #20
 800624c:	46bd      	mov	sp, r7
 800624e:	bc80      	pop	{r7}
 8006250:	4770      	bx	lr
 8006252:	bf00      	nop

08006254 <NVIC_SetVectorTable>:
  *     @arg NVIC_VectTab_FLASH: Vector Table in internal FLASH.
  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x200.
  * @retval None
  */
void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
{ 
 8006254:	b480      	push	{r7}
 8006256:	b083      	sub	sp, #12
 8006258:	af00      	add	r7, sp, #0
 800625a:	6078      	str	r0, [r7, #4]
 800625c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 800625e:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8006262:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8006266:	683a      	ldr	r2, [r7, #0]
 8006268:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 800626c:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 8006270:	6879      	ldr	r1, [r7, #4]
 8006272:	430a      	orrs	r2, r1
 8006274:	609a      	str	r2, [r3, #8]
}
 8006276:	f107 070c 	add.w	r7, r7, #12
 800627a:	46bd      	mov	sp, r7
 800627c:	bc80      	pop	{r7}
 800627e:	4770      	bx	lr

08006280 <NVIC_SystemLPConfig>:
  *     @arg NVIC_LP_SLEEPONEXIT: Low Power Sleep on Exit.
  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
{
 8006280:	b480      	push	{r7}
 8006282:	b083      	sub	sp, #12
 8006284:	af00      	add	r7, sp, #0
 8006286:	4602      	mov	r2, r0
 8006288:	460b      	mov	r3, r1
 800628a:	71fa      	strb	r2, [r7, #7]
 800628c:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 800628e:	79bb      	ldrb	r3, [r7, #6]
 8006290:	2b00      	cmp	r3, #0
 8006292:	d00d      	beq.n	80062b0 <NVIC_SystemLPConfig+0x30>
  {
    SCB->SCR |= LowPowerMode;
 8006294:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8006298:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800629c:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 80062a0:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80062a4:	6912      	ldr	r2, [r2, #16]
 80062a6:	4611      	mov	r1, r2
 80062a8:	79fa      	ldrb	r2, [r7, #7]
 80062aa:	430a      	orrs	r2, r1
 80062ac:	611a      	str	r2, [r3, #16]
 80062ae:	e00e      	b.n	80062ce <NVIC_SystemLPConfig+0x4e>
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 80062b0:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80062b4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80062b8:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 80062bc:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80062c0:	6912      	ldr	r2, [r2, #16]
 80062c2:	4611      	mov	r1, r2
 80062c4:	79fa      	ldrb	r2, [r7, #7]
 80062c6:	ea6f 0202 	mvn.w	r2, r2
 80062ca:	400a      	ands	r2, r1
 80062cc:	611a      	str	r2, [r3, #16]
  }
}
 80062ce:	f107 070c 	add.w	r7, r7, #12
 80062d2:	46bd      	mov	sp, r7
 80062d4:	bc80      	pop	{r7}
 80062d6:	4770      	bx	lr

080062d8 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 80062d8:	b480      	push	{r7}
 80062da:	b083      	sub	sp, #12
 80062dc:	af00      	add	r7, sp, #0
 80062de:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 80062e0:	687b      	ldr	r3, [r7, #4]
 80062e2:	2b04      	cmp	r3, #4
 80062e4:	d10c      	bne.n	8006300 <SysTick_CLKSourceConfig+0x28>
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80062e6:	f24e 0310 	movw	r3, #57360	; 0xe010
 80062ea:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80062ee:	f24e 0210 	movw	r2, #57360	; 0xe010
 80062f2:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80062f6:	6812      	ldr	r2, [r2, #0]
 80062f8:	f042 0204 	orr.w	r2, r2, #4
 80062fc:	601a      	str	r2, [r3, #0]
 80062fe:	e00b      	b.n	8006318 <SysTick_CLKSourceConfig+0x40>
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8006300:	f24e 0310 	movw	r3, #57360	; 0xe010
 8006304:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8006308:	f24e 0210 	movw	r2, #57360	; 0xe010
 800630c:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8006310:	6812      	ldr	r2, [r2, #0]
 8006312:	f022 0204 	bic.w	r2, r2, #4
 8006316:	601a      	str	r2, [r3, #0]
  }
}
 8006318:	f107 070c 	add.w	r7, r7, #12
 800631c:	46bd      	mov	sp, r7
 800631e:	bc80      	pop	{r7}
 8006320:	4770      	bx	lr
 8006322:	bf00      	nop

08006324 <DAC_DeInit>:
  * @brief  Deinitializes the DAC peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void DAC_DeInit(void)
{
 8006324:	b580      	push	{r7, lr}
 8006326:	af00      	add	r7, sp, #0
  /* Enable DAC reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
 8006328:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 800632c:	f04f 0101 	mov.w	r1, #1
 8006330:	f002 fdfc 	bl	8008f2c <RCC_APB1PeriphResetCmd>
  /* Release DAC from reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
 8006334:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8006338:	f04f 0100 	mov.w	r1, #0
 800633c:	f002 fdf6 	bl	8008f2c <RCC_APB1PeriphResetCmd>
}
 8006340:	bd80      	pop	{r7, pc}
 8006342:	bf00      	nop

08006344 <DAC_Init>:
  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
  *         the configuration information for the  specified DAC channel.
  * @retval None
  */
void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
{
 8006344:	b480      	push	{r7}
 8006346:	b085      	sub	sp, #20
 8006348:	af00      	add	r7, sp, #0
 800634a:	6078      	str	r0, [r7, #4]
 800634c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
 800634e:	f04f 0300 	mov.w	r3, #0
 8006352:	60fb      	str	r3, [r7, #12]
 8006354:	f04f 0300 	mov.w	r3, #0
 8006358:	60bb      	str	r3, [r7, #8]
  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));

/*---------------------------- DAC CR Configuration --------------------------*/
  /* Get the DAC CR value */
  tmpreg1 = DAC->CR;
 800635a:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 800635e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006362:	681b      	ldr	r3, [r3, #0]
 8006364:	60fb      	str	r3, [r7, #12]
  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
  tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
 8006366:	687b      	ldr	r3, [r7, #4]
 8006368:	f640 72fe 	movw	r2, #4094	; 0xffe
 800636c:	fa02 f303 	lsl.w	r3, r2, r3
 8006370:	ea6f 0303 	mvn.w	r3, r3
 8006374:	68fa      	ldr	r2, [r7, #12]
 8006376:	4013      	ands	r3, r2
 8006378:	60fb      	str	r3, [r7, #12]
     wave generation, mask/amplitude for wave generation */
  /* Set TSELx and TENx bits according to DAC_Trigger value */
  /* Set WAVEx bits according to DAC_WaveGeneration value */
  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
  /* Set BOFFx bit according to DAC_OutputBuffer value */   
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 800637a:	683b      	ldr	r3, [r7, #0]
 800637c:	681a      	ldr	r2, [r3, #0]
 800637e:	683b      	ldr	r3, [r7, #0]
 8006380:	685b      	ldr	r3, [r3, #4]
 8006382:	431a      	orrs	r2, r3
             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
 8006384:	683b      	ldr	r3, [r7, #0]
 8006386:	689b      	ldr	r3, [r3, #8]
     wave generation, mask/amplitude for wave generation */
  /* Set TSELx and TENx bits according to DAC_Trigger value */
  /* Set WAVEx bits according to DAC_WaveGeneration value */
  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
  /* Set BOFFx bit according to DAC_OutputBuffer value */   
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 8006388:	431a      	orrs	r2, r3
             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
             DAC_InitStruct->DAC_OutputBuffer);
 800638a:	683b      	ldr	r3, [r7, #0]
 800638c:	68db      	ldr	r3, [r3, #12]
     wave generation, mask/amplitude for wave generation */
  /* Set TSELx and TENx bits according to DAC_Trigger value */
  /* Set WAVEx bits according to DAC_WaveGeneration value */
  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
  /* Set BOFFx bit according to DAC_OutputBuffer value */   
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 800638e:	4313      	orrs	r3, r2
 8006390:	60bb      	str	r3, [r7, #8]
             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
             DAC_InitStruct->DAC_OutputBuffer);
  /* Calculate CR register value depending on DAC_Channel */
  tmpreg1 |= tmpreg2 << DAC_Channel;
 8006392:	687b      	ldr	r3, [r7, #4]
 8006394:	68ba      	ldr	r2, [r7, #8]
 8006396:	fa02 f303 	lsl.w	r3, r2, r3
 800639a:	68fa      	ldr	r2, [r7, #12]
 800639c:	4313      	orrs	r3, r2
 800639e:	60fb      	str	r3, [r7, #12]
  /* Write to DAC CR */
  DAC->CR = tmpreg1;
 80063a0:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 80063a4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80063a8:	68fa      	ldr	r2, [r7, #12]
 80063aa:	601a      	str	r2, [r3, #0]
}
 80063ac:	f107 0714 	add.w	r7, r7, #20
 80063b0:	46bd      	mov	sp, r7
 80063b2:	bc80      	pop	{r7}
 80063b4:	4770      	bx	lr
 80063b6:	bf00      	nop

080063b8 <DAC_StructInit>:
  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will 
  *         be initialized.
  * @retval None
  */
void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
{
 80063b8:	b480      	push	{r7}
 80063ba:	b083      	sub	sp, #12
 80063bc:	af00      	add	r7, sp, #0
 80063be:	6078      	str	r0, [r7, #4]
/*--------------- Reset DAC init structure parameters values -----------------*/
  /* Initialize the DAC_Trigger member */
  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
 80063c0:	687b      	ldr	r3, [r7, #4]
 80063c2:	f04f 0200 	mov.w	r2, #0
 80063c6:	601a      	str	r2, [r3, #0]
  /* Initialize the DAC_WaveGeneration member */
  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
 80063c8:	687b      	ldr	r3, [r7, #4]
 80063ca:	f04f 0200 	mov.w	r2, #0
 80063ce:	605a      	str	r2, [r3, #4]
  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
 80063d0:	687b      	ldr	r3, [r7, #4]
 80063d2:	f04f 0200 	mov.w	r2, #0
 80063d6:	609a      	str	r2, [r3, #8]
  /* Initialize the DAC_OutputBuffer member */
  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
 80063d8:	687b      	ldr	r3, [r7, #4]
 80063da:	f04f 0200 	mov.w	r2, #0
 80063de:	60da      	str	r2, [r3, #12]
}
 80063e0:	f107 070c 	add.w	r7, r7, #12
 80063e4:	46bd      	mov	sp, r7
 80063e6:	bc80      	pop	{r7}
 80063e8:	4770      	bx	lr
 80063ea:	bf00      	nop

080063ec <DAC_Cmd>:
  *          This parameter can be: ENABLE or DISABLE.
  * @note   When the DAC channel is enabled the trigger source can no more be modified.
  * @retval None
  */
void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
{
 80063ec:	b480      	push	{r7}
 80063ee:	b083      	sub	sp, #12
 80063f0:	af00      	add	r7, sp, #0
 80063f2:	6078      	str	r0, [r7, #4]
 80063f4:	460b      	mov	r3, r1
 80063f6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80063f8:	78fb      	ldrb	r3, [r7, #3]
 80063fa:	2b00      	cmp	r3, #0
 80063fc:	d011      	beq.n	8006422 <DAC_Cmd+0x36>
  {
    /* Enable the selected DAC channel */
    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
 80063fe:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8006402:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006406:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 800640a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800640e:	6812      	ldr	r2, [r2, #0]
 8006410:	4611      	mov	r1, r2
 8006412:	687a      	ldr	r2, [r7, #4]
 8006414:	f04f 0001 	mov.w	r0, #1
 8006418:	fa00 f202 	lsl.w	r2, r0, r2
 800641c:	430a      	orrs	r2, r1
 800641e:	601a      	str	r2, [r3, #0]
 8006420:	e012      	b.n	8006448 <DAC_Cmd+0x5c>
  }
  else
  {
    /* Disable the selected DAC channel */
    DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
 8006422:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8006426:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800642a:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 800642e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006432:	6812      	ldr	r2, [r2, #0]
 8006434:	4611      	mov	r1, r2
 8006436:	687a      	ldr	r2, [r7, #4]
 8006438:	f04f 0001 	mov.w	r0, #1
 800643c:	fa00 f202 	lsl.w	r2, r0, r2
 8006440:	ea6f 0202 	mvn.w	r2, r2
 8006444:	400a      	ands	r2, r1
 8006446:	601a      	str	r2, [r3, #0]
  }
}
 8006448:	f107 070c 	add.w	r7, r7, #12
 800644c:	46bd      	mov	sp, r7
 800644e:	bc80      	pop	{r7}
 8006450:	4770      	bx	lr
 8006452:	bf00      	nop

08006454 <DAC_SoftwareTriggerCmd>:
  * @param  NewState: new state of the selected DAC channel software trigger.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
{
 8006454:	b480      	push	{r7}
 8006456:	b083      	sub	sp, #12
 8006458:	af00      	add	r7, sp, #0
 800645a:	6078      	str	r0, [r7, #4]
 800645c:	460b      	mov	r3, r1
 800645e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8006460:	78fb      	ldrb	r3, [r7, #3]
 8006462:	2b00      	cmp	r3, #0
 8006464:	d013      	beq.n	800648e <DAC_SoftwareTriggerCmd+0x3a>
  {
    /* Enable software trigger for the selected DAC channel */
    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
 8006466:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 800646a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800646e:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 8006472:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006476:	6852      	ldr	r2, [r2, #4]
 8006478:	4611      	mov	r1, r2
 800647a:	687a      	ldr	r2, [r7, #4]
 800647c:	ea4f 1212 	mov.w	r2, r2, lsr #4
 8006480:	f04f 0001 	mov.w	r0, #1
 8006484:	fa00 f202 	lsl.w	r2, r0, r2
 8006488:	430a      	orrs	r2, r1
 800648a:	605a      	str	r2, [r3, #4]
 800648c:	e014      	b.n	80064b8 <DAC_SoftwareTriggerCmd+0x64>
  }
  else
  {
    /* Disable software trigger for the selected DAC channel */
    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
 800648e:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8006492:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006496:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 800649a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800649e:	6852      	ldr	r2, [r2, #4]
 80064a0:	4611      	mov	r1, r2
 80064a2:	687a      	ldr	r2, [r7, #4]
 80064a4:	ea4f 1212 	mov.w	r2, r2, lsr #4
 80064a8:	f04f 0001 	mov.w	r0, #1
 80064ac:	fa00 f202 	lsl.w	r2, r0, r2
 80064b0:	ea6f 0202 	mvn.w	r2, r2
 80064b4:	400a      	ands	r2, r1
 80064b6:	605a      	str	r2, [r3, #4]
  }
}
 80064b8:	f107 070c 	add.w	r7, r7, #12
 80064bc:	46bd      	mov	sp, r7
 80064be:	bc80      	pop	{r7}
 80064c0:	4770      	bx	lr
 80064c2:	bf00      	nop

080064c4 <DAC_DualSoftwareTriggerCmd>:
  * @param  NewState: new state of the DAC channels software triggers.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
{
 80064c4:	b480      	push	{r7}
 80064c6:	b083      	sub	sp, #12
 80064c8:	af00      	add	r7, sp, #0
 80064ca:	4603      	mov	r3, r0
 80064cc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80064ce:	79fb      	ldrb	r3, [r7, #7]
 80064d0:	2b00      	cmp	r3, #0
 80064d2:	d00c      	beq.n	80064ee <DAC_DualSoftwareTriggerCmd+0x2a>
  {
    /* Enable software trigger for both DAC channels */
    DAC->SWTRIGR |= DUAL_SWTRIG_SET;
 80064d4:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 80064d8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80064dc:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 80064e0:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80064e4:	6852      	ldr	r2, [r2, #4]
 80064e6:	f042 0203 	orr.w	r2, r2, #3
 80064ea:	605a      	str	r2, [r3, #4]
 80064ec:	e00b      	b.n	8006506 <DAC_DualSoftwareTriggerCmd+0x42>
  }
  else
  {
    /* Disable software trigger for both DAC channels */
    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
 80064ee:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 80064f2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80064f6:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 80064fa:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80064fe:	6852      	ldr	r2, [r2, #4]
 8006500:	f022 0203 	bic.w	r2, r2, #3
 8006504:	605a      	str	r2, [r3, #4]
  }
}
 8006506:	f107 070c 	add.w	r7, r7, #12
 800650a:	46bd      	mov	sp, r7
 800650c:	bc80      	pop	{r7}
 800650e:	4770      	bx	lr

08006510 <DAC_WaveGenerationCmd>:
  * @param  NewState: new state of the selected DAC channel wave generation.
  *          This parameter can be: ENABLE or DISABLE.  
  * @retval None
  */
void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
{
 8006510:	b480      	push	{r7}
 8006512:	b085      	sub	sp, #20
 8006514:	af00      	add	r7, sp, #0
 8006516:	60f8      	str	r0, [r7, #12]
 8006518:	60b9      	str	r1, [r7, #8]
 800651a:	4613      	mov	r3, r2
 800651c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_WAVE(DAC_Wave)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800651e:	79fb      	ldrb	r3, [r7, #7]
 8006520:	2b00      	cmp	r3, #0
 8006522:	d010      	beq.n	8006546 <DAC_WaveGenerationCmd+0x36>
  {
    /* Enable the selected wave generation for the selected DAC channel */
    DAC->CR |= DAC_Wave << DAC_Channel;
 8006524:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8006528:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800652c:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 8006530:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006534:	6812      	ldr	r2, [r2, #0]
 8006536:	4611      	mov	r1, r2
 8006538:	68fa      	ldr	r2, [r7, #12]
 800653a:	68b8      	ldr	r0, [r7, #8]
 800653c:	fa00 f202 	lsl.w	r2, r0, r2
 8006540:	430a      	orrs	r2, r1
 8006542:	601a      	str	r2, [r3, #0]
 8006544:	e011      	b.n	800656a <DAC_WaveGenerationCmd+0x5a>
  }
  else
  {
    /* Disable the selected wave generation for the selected DAC channel */
    DAC->CR &= ~(DAC_Wave << DAC_Channel);
 8006546:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 800654a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800654e:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 8006552:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006556:	6812      	ldr	r2, [r2, #0]
 8006558:	4611      	mov	r1, r2
 800655a:	68fa      	ldr	r2, [r7, #12]
 800655c:	68b8      	ldr	r0, [r7, #8]
 800655e:	fa00 f202 	lsl.w	r2, r0, r2
 8006562:	ea6f 0202 	mvn.w	r2, r2
 8006566:	400a      	ands	r2, r1
 8006568:	601a      	str	r2, [r3, #0]
  }
}
 800656a:	f107 0714 	add.w	r7, r7, #20
 800656e:	46bd      	mov	sp, r7
 8006570:	bc80      	pop	{r7}
 8006572:	4770      	bx	lr

08006574 <DAC_SetChannel1Data>:
  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
  * @param  Data: Data to be loaded in the selected data holding register.
  * @retval None
  */
void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
{  
 8006574:	b480      	push	{r7}
 8006576:	b085      	sub	sp, #20
 8006578:	af00      	add	r7, sp, #0
 800657a:	6078      	str	r0, [r7, #4]
 800657c:	460b      	mov	r3, r1
 800657e:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = 0;
 8006580:	f04f 0300 	mov.w	r3, #0
 8006584:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE; 
 8006586:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 800658a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800658e:	60fb      	str	r3, [r7, #12]
  tmp += DHR12R1_OFFSET + DAC_Align;
 8006590:	68fa      	ldr	r2, [r7, #12]
 8006592:	687b      	ldr	r3, [r7, #4]
 8006594:	18d3      	adds	r3, r2, r3
 8006596:	f103 0308 	add.w	r3, r3, #8
 800659a:	60fb      	str	r3, [r7, #12]

  /* Set the DAC channel1 selected data holding register */
  *(__IO uint32_t *) tmp = Data;
 800659c:	68fb      	ldr	r3, [r7, #12]
 800659e:	887a      	ldrh	r2, [r7, #2]
 80065a0:	601a      	str	r2, [r3, #0]
}
 80065a2:	f107 0714 	add.w	r7, r7, #20
 80065a6:	46bd      	mov	sp, r7
 80065a8:	bc80      	pop	{r7}
 80065aa:	4770      	bx	lr

080065ac <DAC_SetChannel2Data>:
  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
  * @param  Data: Data to be loaded in the selected data holding register.
  * @retval None
  */
void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
{
 80065ac:	b480      	push	{r7}
 80065ae:	b085      	sub	sp, #20
 80065b0:	af00      	add	r7, sp, #0
 80065b2:	6078      	str	r0, [r7, #4]
 80065b4:	460b      	mov	r3, r1
 80065b6:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = 0;
 80065b8:	f04f 0300 	mov.w	r3, #0
 80065bc:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE;
 80065be:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 80065c2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80065c6:	60fb      	str	r3, [r7, #12]
  tmp += DHR12R2_OFFSET + DAC_Align;
 80065c8:	68fa      	ldr	r2, [r7, #12]
 80065ca:	687b      	ldr	r3, [r7, #4]
 80065cc:	18d3      	adds	r3, r2, r3
 80065ce:	f103 0314 	add.w	r3, r3, #20
 80065d2:	60fb      	str	r3, [r7, #12]

  /* Set the DAC channel2 selected data holding register */
  *(__IO uint32_t *)tmp = Data;
 80065d4:	68fb      	ldr	r3, [r7, #12]
 80065d6:	887a      	ldrh	r2, [r7, #2]
 80065d8:	601a      	str	r2, [r3, #0]
}
 80065da:	f107 0714 	add.w	r7, r7, #20
 80065de:	46bd      	mov	sp, r7
 80065e0:	bc80      	pop	{r7}
 80065e2:	4770      	bx	lr

080065e4 <DAC_SetDualChannelData>:
  * @note   In dual mode, a unique register access is required to write in both
  *          DAC channels at the same time.
  * @retval None
  */
void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
{
 80065e4:	b480      	push	{r7}
 80065e6:	b085      	sub	sp, #20
 80065e8:	af00      	add	r7, sp, #0
 80065ea:	6078      	str	r0, [r7, #4]
 80065ec:	4613      	mov	r3, r2
 80065ee:	460a      	mov	r2, r1
 80065f0:	807a      	strh	r2, [r7, #2]
 80065f2:	803b      	strh	r3, [r7, #0]
  uint32_t data = 0, tmp = 0;
 80065f4:	f04f 0300 	mov.w	r3, #0
 80065f8:	60fb      	str	r3, [r7, #12]
 80065fa:	f04f 0300 	mov.w	r3, #0
 80065fe:	60bb      	str	r3, [r7, #8]
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data1));
  assert_param(IS_DAC_DATA(Data2));
  
  /* Calculate and set dual DAC data holding register value */
  if (DAC_Align == DAC_Align_8b_R)
 8006600:	687b      	ldr	r3, [r7, #4]
 8006602:	2b08      	cmp	r3, #8
 8006604:	d106      	bne.n	8006614 <DAC_SetDualChannelData+0x30>
  {
    data = ((uint32_t)Data2 << 8) | Data1; 
 8006606:	887b      	ldrh	r3, [r7, #2]
 8006608:	ea4f 2203 	mov.w	r2, r3, lsl #8
 800660c:	883b      	ldrh	r3, [r7, #0]
 800660e:	4313      	orrs	r3, r2
 8006610:	60fb      	str	r3, [r7, #12]
 8006612:	e005      	b.n	8006620 <DAC_SetDualChannelData+0x3c>
  }
  else
  {
    data = ((uint32_t)Data2 << 16) | Data1;
 8006614:	887b      	ldrh	r3, [r7, #2]
 8006616:	ea4f 4203 	mov.w	r2, r3, lsl #16
 800661a:	883b      	ldrh	r3, [r7, #0]
 800661c:	4313      	orrs	r3, r2
 800661e:	60fb      	str	r3, [r7, #12]
  }
  
  tmp = (uint32_t)DAC_BASE;
 8006620:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8006624:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006628:	60bb      	str	r3, [r7, #8]
  tmp += DHR12RD_OFFSET + DAC_Align;
 800662a:	687a      	ldr	r2, [r7, #4]
 800662c:	68bb      	ldr	r3, [r7, #8]
 800662e:	18d3      	adds	r3, r2, r3
 8006630:	f103 0320 	add.w	r3, r3, #32
 8006634:	60bb      	str	r3, [r7, #8]

  /* Set the dual DAC selected data holding register */
  *(__IO uint32_t *)tmp = data;
 8006636:	68bb      	ldr	r3, [r7, #8]
 8006638:	68fa      	ldr	r2, [r7, #12]
 800663a:	601a      	str	r2, [r3, #0]
}
 800663c:	f107 0714 	add.w	r7, r7, #20
 8006640:	46bd      	mov	sp, r7
 8006642:	bc80      	pop	{r7}
 8006644:	4770      	bx	lr
 8006646:	bf00      	nop

08006648 <DAC_GetDataOutputValue>:
  *            @arg DAC_Channel_1: DAC Channel1 selected
  *            @arg DAC_Channel_2: DAC Channel2 selected
  * @retval The selected DAC channel data output value.
  */
uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
{
 8006648:	b480      	push	{r7}
 800664a:	b085      	sub	sp, #20
 800664c:	af00      	add	r7, sp, #0
 800664e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmp = 0;
 8006650:	f04f 0300 	mov.w	r3, #0
 8006654:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  
  tmp = (uint32_t) DAC_BASE ;
 8006656:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 800665a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800665e:	60fb      	str	r3, [r7, #12]
  tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
 8006660:	687b      	ldr	r3, [r7, #4]
 8006662:	ea4f 0293 	mov.w	r2, r3, lsr #2
 8006666:	68fb      	ldr	r3, [r7, #12]
 8006668:	18d3      	adds	r3, r2, r3
 800666a:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 800666e:	60fb      	str	r3, [r7, #12]
  
  /* Returns the DAC channel data output register value */
  return (uint16_t) (*(__IO uint32_t*) tmp);
 8006670:	68fb      	ldr	r3, [r7, #12]
 8006672:	681b      	ldr	r3, [r3, #0]
 8006674:	b29b      	uxth	r3, r3
}
 8006676:	4618      	mov	r0, r3
 8006678:	f107 0714 	add.w	r7, r7, #20
 800667c:	46bd      	mov	sp, r7
 800667e:	bc80      	pop	{r7}
 8006680:	4770      	bx	lr
 8006682:	bf00      	nop

08006684 <DAC_DMACmd>:
  * @note   The DAC channel2 is mapped on DMA1 Stream 6 channel7 which must be
  *          already configured.    
  * @retval None
  */
void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
{
 8006684:	b480      	push	{r7}
 8006686:	b083      	sub	sp, #12
 8006688:	af00      	add	r7, sp, #0
 800668a:	6078      	str	r0, [r7, #4]
 800668c:	460b      	mov	r3, r1
 800668e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8006690:	78fb      	ldrb	r3, [r7, #3]
 8006692:	2b00      	cmp	r3, #0
 8006694:	d011      	beq.n	80066ba <DAC_DMACmd+0x36>
  {
    /* Enable the selected DAC channel DMA request */
    DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
 8006696:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 800669a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800669e:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 80066a2:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80066a6:	6812      	ldr	r2, [r2, #0]
 80066a8:	4611      	mov	r1, r2
 80066aa:	687a      	ldr	r2, [r7, #4]
 80066ac:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80066b0:	fa00 f202 	lsl.w	r2, r0, r2
 80066b4:	430a      	orrs	r2, r1
 80066b6:	601a      	str	r2, [r3, #0]
 80066b8:	e012      	b.n	80066e0 <DAC_DMACmd+0x5c>
  }
  else
  {
    /* Disable the selected DAC channel DMA request */
    DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
 80066ba:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 80066be:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80066c2:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 80066c6:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80066ca:	6812      	ldr	r2, [r2, #0]
 80066cc:	4611      	mov	r1, r2
 80066ce:	687a      	ldr	r2, [r7, #4]
 80066d0:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80066d4:	fa00 f202 	lsl.w	r2, r0, r2
 80066d8:	ea6f 0202 	mvn.w	r2, r2
 80066dc:	400a      	ands	r2, r1
 80066de:	601a      	str	r2, [r3, #0]
  }
}
 80066e0:	f107 070c 	add.w	r7, r7, #12
 80066e4:	46bd      	mov	sp, r7
 80066e6:	bc80      	pop	{r7}
 80066e8:	4770      	bx	lr
 80066ea:	bf00      	nop

080066ec <DAC_ITConfig>:
  * @param  NewState: new state of the specified DAC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */ 
void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
{
 80066ec:	b480      	push	{r7}
 80066ee:	b085      	sub	sp, #20
 80066f0:	af00      	add	r7, sp, #0
 80066f2:	60f8      	str	r0, [r7, #12]
 80066f4:	60b9      	str	r1, [r7, #8]
 80066f6:	4613      	mov	r3, r2
 80066f8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_DAC_IT(DAC_IT)); 

  if (NewState != DISABLE)
 80066fa:	79fb      	ldrb	r3, [r7, #7]
 80066fc:	2b00      	cmp	r3, #0
 80066fe:	d010      	beq.n	8006722 <DAC_ITConfig+0x36>
  {
    /* Enable the selected DAC interrupts */
    DAC->CR |=  (DAC_IT << DAC_Channel);
 8006700:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8006704:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006708:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 800670c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006710:	6812      	ldr	r2, [r2, #0]
 8006712:	4611      	mov	r1, r2
 8006714:	68fa      	ldr	r2, [r7, #12]
 8006716:	68b8      	ldr	r0, [r7, #8]
 8006718:	fa00 f202 	lsl.w	r2, r0, r2
 800671c:	430a      	orrs	r2, r1
 800671e:	601a      	str	r2, [r3, #0]
 8006720:	e011      	b.n	8006746 <DAC_ITConfig+0x5a>
  }
  else
  {
    /* Disable the selected DAC interrupts */
    DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
 8006722:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8006726:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800672a:	f44f 42e8 	mov.w	r2, #29696	; 0x7400
 800672e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8006732:	6812      	ldr	r2, [r2, #0]
 8006734:	4611      	mov	r1, r2
 8006736:	68fa      	ldr	r2, [r7, #12]
 8006738:	68b8      	ldr	r0, [r7, #8]
 800673a:	fa00 f202 	lsl.w	r2, r0, r2
 800673e:	ea6f 0202 	mvn.w	r2, r2
 8006742:	400a      	ands	r2, r1
 8006744:	601a      	str	r2, [r3, #0]
  }
}
 8006746:	f107 0714 	add.w	r7, r7, #20
 800674a:	46bd      	mov	sp, r7
 800674c:	bc80      	pop	{r7}
 800674e:	4770      	bx	lr

08006750 <DAC_GetFlagStatus>:
  * @note   The DMA underrun occurs when a second external trigger arrives before the 
  *         acknowledgement for the first external trigger is received (first request).
  * @retval The new state of DAC_FLAG (SET or RESET).
  */
FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
{
 8006750:	b480      	push	{r7}
 8006752:	b085      	sub	sp, #20
 8006754:	af00      	add	r7, sp, #0
 8006756:	6078      	str	r0, [r7, #4]
 8006758:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 800675a:	f04f 0300 	mov.w	r3, #0
 800675e:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_FLAG(DAC_FLAG));

  /* Check the status of the specified DAC flag */
  if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
 8006760:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8006764:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8006768:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800676a:	461a      	mov	r2, r3
 800676c:	687b      	ldr	r3, [r7, #4]
 800676e:	6839      	ldr	r1, [r7, #0]
 8006770:	fa01 f303 	lsl.w	r3, r1, r3
 8006774:	4013      	ands	r3, r2
 8006776:	2b00      	cmp	r3, #0
 8006778:	d003      	beq.n	8006782 <DAC_GetFlagStatus+0x32>
  {
    /* DAC_FLAG is set */
    bitstatus = SET;
 800677a:	f04f 0301 	mov.w	r3, #1
 800677e:	73fb      	strb	r3, [r7, #15]
 8006780:	e002      	b.n	8006788 <DAC_GetFlagStatus+0x38>
  }
  else
  {
    /* DAC_FLAG is reset */
    bitstatus = RESET;
 8006782:	f04f 0300 	mov.w	r3, #0
 8006786:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the DAC_FLAG status */
  return  bitstatus;
 8006788:	7bfb      	ldrb	r3, [r7, #15]
}
 800678a:	4618      	mov	r0, r3
 800678c:	f107 0714 	add.w	r7, r7, #20
 8006790:	46bd      	mov	sp, r7
 8006792:	bc80      	pop	{r7}
 8006794:	4770      	bx	lr
 8006796:	bf00      	nop

08006798 <DAC_ClearFlag>:
  * @note   The DMA underrun occurs when a second external trigger arrives before the 
  *         acknowledgement for the first external trigger is received (first request).                           
  * @retval None
  */
void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
{
 8006798:	b480      	push	{r7}
 800679a:	b083      	sub	sp, #12
 800679c:	af00      	add	r7, sp, #0
 800679e:	6078      	str	r0, [r7, #4]
 80067a0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_FLAG(DAC_FLAG));

  /* Clear the selected DAC flags */
  DAC->SR = (DAC_FLAG << DAC_Channel);
 80067a2:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 80067a6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80067aa:	687a      	ldr	r2, [r7, #4]
 80067ac:	6839      	ldr	r1, [r7, #0]
 80067ae:	fa01 f202 	lsl.w	r2, r1, r2
 80067b2:	635a      	str	r2, [r3, #52]	; 0x34
}
 80067b4:	f107 070c 	add.w	r7, r7, #12
 80067b8:	46bd      	mov	sp, r7
 80067ba:	bc80      	pop	{r7}
 80067bc:	4770      	bx	lr
 80067be:	bf00      	nop

080067c0 <DAC_GetITStatus>:
  * @note   The DMA underrun occurs when a second external trigger arrives before the 
  *         acknowledgement for the first external trigger is received (first request).
  * @retval The new state of DAC_IT (SET or RESET).
  */
ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
{
 80067c0:	b480      	push	{r7}
 80067c2:	b085      	sub	sp, #20
 80067c4:	af00      	add	r7, sp, #0
 80067c6:	6078      	str	r0, [r7, #4]
 80067c8:	6039      	str	r1, [r7, #0]
  ITStatus bitstatus = RESET;
 80067ca:	f04f 0300 	mov.w	r3, #0
 80067ce:	73fb      	strb	r3, [r7, #15]
  uint32_t enablestatus = 0;
 80067d0:	f04f 0300 	mov.w	r3, #0
 80067d4:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_IT(DAC_IT));

  /* Get the DAC_IT enable bit status */
  enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
 80067d6:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 80067da:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80067de:	681b      	ldr	r3, [r3, #0]
 80067e0:	461a      	mov	r2, r3
 80067e2:	687b      	ldr	r3, [r7, #4]
 80067e4:	6839      	ldr	r1, [r7, #0]
 80067e6:	fa01 f303 	lsl.w	r3, r1, r3
 80067ea:	4013      	ands	r3, r2
 80067ec:	60bb      	str	r3, [r7, #8]
  
  /* Check the status of the specified DAC interrupt */
  if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
 80067ee:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 80067f2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80067f6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80067f8:	461a      	mov	r2, r3
 80067fa:	687b      	ldr	r3, [r7, #4]
 80067fc:	6839      	ldr	r1, [r7, #0]
 80067fe:	fa01 f303 	lsl.w	r3, r1, r3
 8006802:	4013      	ands	r3, r2
 8006804:	2b00      	cmp	r3, #0
 8006806:	d006      	beq.n	8006816 <DAC_GetITStatus+0x56>
 8006808:	68bb      	ldr	r3, [r7, #8]
 800680a:	2b00      	cmp	r3, #0
 800680c:	d003      	beq.n	8006816 <DAC_GetITStatus+0x56>
  {
    /* DAC_IT is set */
    bitstatus = SET;
 800680e:	f04f 0301 	mov.w	r3, #1
 8006812:	73fb      	strb	r3, [r7, #15]
 8006814:	e002      	b.n	800681c <DAC_GetITStatus+0x5c>
  }
  else
  {
    /* DAC_IT is reset */
    bitstatus = RESET;
 8006816:	f04f 0300 	mov.w	r3, #0
 800681a:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the DAC_IT status */
  return  bitstatus;
 800681c:	7bfb      	ldrb	r3, [r7, #15]
}
 800681e:	4618      	mov	r0, r3
 8006820:	f107 0714 	add.w	r7, r7, #20
 8006824:	46bd      	mov	sp, r7
 8006826:	bc80      	pop	{r7}
 8006828:	4770      	bx	lr
 800682a:	bf00      	nop

0800682c <DAC_ClearITPendingBit>:
  * @note   The DMA underrun occurs when a second external trigger arrives before the 
  *         acknowledgement for the first external trigger is received (first request).                           
  * @retval None
  */
void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
{
 800682c:	b480      	push	{r7}
 800682e:	b083      	sub	sp, #12
 8006830:	af00      	add	r7, sp, #0
 8006832:	6078      	str	r0, [r7, #4]
 8006834:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_IT(DAC_IT)); 

  /* Clear the selected DAC interrupt pending bits */
  DAC->SR = (DAC_IT << DAC_Channel);
 8006836:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 800683a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800683e:	687a      	ldr	r2, [r7, #4]
 8006840:	6839      	ldr	r1, [r7, #0]
 8006842:	fa01 f202 	lsl.w	r2, r1, r2
 8006846:	635a      	str	r2, [r3, #52]	; 0x34
}
 8006848:	f107 070c 	add.w	r7, r7, #12
 800684c:	46bd      	mov	sp, r7
 800684e:	bc80      	pop	{r7}
 8006850:	4770      	bx	lr
 8006852:	bf00      	nop

08006854 <DMA_DeInit>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *         to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
{
 8006854:	b480      	push	{r7}
 8006856:	b083      	sub	sp, #12
 8006858:	af00      	add	r7, sp, #0
 800685a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 800685c:	687b      	ldr	r3, [r7, #4]
 800685e:	681b      	ldr	r3, [r3, #0]
 8006860:	f023 0201 	bic.w	r2, r3, #1
 8006864:	687b      	ldr	r3, [r7, #4]
 8006866:	601a      	str	r2, [r3, #0]

  /* Reset DMAy Streamx control register */
  DMAy_Streamx->CR  = 0;
 8006868:	687b      	ldr	r3, [r7, #4]
 800686a:	f04f 0200 	mov.w	r2, #0
 800686e:	601a      	str	r2, [r3, #0]
  
  /* Reset DMAy Streamx Number of Data to Transfer register */
  DMAy_Streamx->NDTR = 0;
 8006870:	687b      	ldr	r3, [r7, #4]
 8006872:	f04f 0200 	mov.w	r2, #0
 8006876:	605a      	str	r2, [r3, #4]
  
  /* Reset DMAy Streamx peripheral address register */
  DMAy_Streamx->PAR  = 0;
 8006878:	687b      	ldr	r3, [r7, #4]
 800687a:	f04f 0200 	mov.w	r2, #0
 800687e:	609a      	str	r2, [r3, #8]
  
  /* Reset DMAy Streamx memory 0 address register */
  DMAy_Streamx->M0AR = 0;
 8006880:	687b      	ldr	r3, [r7, #4]
 8006882:	f04f 0200 	mov.w	r2, #0
 8006886:	60da      	str	r2, [r3, #12]

  /* Reset DMAy Streamx memory 1 address register */
  DMAy_Streamx->M1AR = 0;
 8006888:	687b      	ldr	r3, [r7, #4]
 800688a:	f04f 0200 	mov.w	r2, #0
 800688e:	611a      	str	r2, [r3, #16]

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 8006890:	687b      	ldr	r3, [r7, #4]
 8006892:	f04f 0221 	mov.w	r2, #33	; 0x21
 8006896:	615a      	str	r2, [r3, #20]

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 8006898:	687a      	ldr	r2, [r7, #4]
 800689a:	f246 0310 	movw	r3, #24592	; 0x6010
 800689e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80068a2:	429a      	cmp	r2, r3
 80068a4:	d107      	bne.n	80068b6 <DMA_DeInit+0x62>
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
 80068a6:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80068aa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80068ae:	f04f 023d 	mov.w	r2, #61	; 0x3d
 80068b2:	609a      	str	r2, [r3, #8]
 80068b4:	e0eb      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA1_Stream1)
 80068b6:	687a      	ldr	r2, [r7, #4]
 80068b8:	f246 0328 	movw	r3, #24616	; 0x6028
 80068bc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80068c0:	429a      	cmp	r2, r3
 80068c2:	d107      	bne.n	80068d4 <DMA_DeInit+0x80>
  {
    /* Reset interrupt pending bits for DMA1 Stream1 */
    DMA1->LIFCR = DMA_Stream1_IT_MASK;
 80068c4:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80068c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80068cc:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 80068d0:	609a      	str	r2, [r3, #8]
 80068d2:	e0dc      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA1_Stream2)
 80068d4:	687a      	ldr	r2, [r7, #4]
 80068d6:	f246 0340 	movw	r3, #24640	; 0x6040
 80068da:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80068de:	429a      	cmp	r2, r3
 80068e0:	d107      	bne.n	80068f2 <DMA_DeInit+0x9e>
  {
    /* Reset interrupt pending bits for DMA1 Stream2 */
    DMA1->LIFCR = DMA_Stream2_IT_MASK;
 80068e2:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80068e6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80068ea:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 80068ee:	609a      	str	r2, [r3, #8]
 80068f0:	e0cd      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA1_Stream3)
 80068f2:	687a      	ldr	r2, [r7, #4]
 80068f4:	f246 0358 	movw	r3, #24664	; 0x6058
 80068f8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80068fc:	429a      	cmp	r2, r3
 80068fe:	d107      	bne.n	8006910 <DMA_DeInit+0xbc>
  {
    /* Reset interrupt pending bits for DMA1 Stream3 */
    DMA1->LIFCR = DMA_Stream3_IT_MASK;
 8006900:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8006904:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006908:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 800690c:	609a      	str	r2, [r3, #8]
 800690e:	e0be      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA1_Stream4)
 8006910:	687a      	ldr	r2, [r7, #4]
 8006912:	f246 0370 	movw	r3, #24688	; 0x6070
 8006916:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800691a:	429a      	cmp	r2, r3
 800691c:	d109      	bne.n	8006932 <DMA_DeInit+0xde>
  {
    /* Reset interrupt pending bits for DMA1 Stream4 */
    DMA1->HIFCR = DMA_Stream4_IT_MASK;
 800691e:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8006922:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006926:	f04f 023d 	mov.w	r2, #61	; 0x3d
 800692a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800692e:	60da      	str	r2, [r3, #12]
 8006930:	e0ad      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA1_Stream5)
 8006932:	687a      	ldr	r2, [r7, #4]
 8006934:	f246 0388 	movw	r3, #24712	; 0x6088
 8006938:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800693c:	429a      	cmp	r2, r3
 800693e:	d109      	bne.n	8006954 <DMA_DeInit+0x100>
  {
    /* Reset interrupt pending bits for DMA1 Stream5 */
    DMA1->HIFCR = DMA_Stream5_IT_MASK;
 8006940:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8006944:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006948:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 800694c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006950:	60da      	str	r2, [r3, #12]
 8006952:	e09c      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA1_Stream6)
 8006954:	687a      	ldr	r2, [r7, #4]
 8006956:	f246 03a0 	movw	r3, #24736	; 0x60a0
 800695a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800695e:	429a      	cmp	r2, r3
 8006960:	d109      	bne.n	8006976 <DMA_DeInit+0x122>
  {
    /* Reset interrupt pending bits for DMA1 Stream6 */
    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
 8006962:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8006966:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800696a:	f04f 0200 	mov.w	r2, #0
 800696e:	f2c2 023d 	movt	r2, #8253	; 0x203d
 8006972:	60da      	str	r2, [r3, #12]
 8006974:	e08b      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA1_Stream7)
 8006976:	687a      	ldr	r2, [r7, #4]
 8006978:	f246 03b8 	movw	r3, #24760	; 0x60b8
 800697c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006980:	429a      	cmp	r2, r3
 8006982:	d107      	bne.n	8006994 <DMA_DeInit+0x140>
  {
    /* Reset interrupt pending bits for DMA1 Stream7 */
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
 8006984:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8006988:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800698c:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 8006990:	60da      	str	r2, [r3, #12]
 8006992:	e07c      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA2_Stream0)
 8006994:	687a      	ldr	r2, [r7, #4]
 8006996:	f246 4310 	movw	r3, #25616	; 0x6410
 800699a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800699e:	429a      	cmp	r2, r3
 80069a0:	d107      	bne.n	80069b2 <DMA_DeInit+0x15e>
  {
    /* Reset interrupt pending bits for DMA2 Stream0 */
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
 80069a2:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 80069a6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80069aa:	f04f 023d 	mov.w	r2, #61	; 0x3d
 80069ae:	609a      	str	r2, [r3, #8]
 80069b0:	e06d      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA2_Stream1)
 80069b2:	687a      	ldr	r2, [r7, #4]
 80069b4:	f246 4328 	movw	r3, #25640	; 0x6428
 80069b8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80069bc:	429a      	cmp	r2, r3
 80069be:	d107      	bne.n	80069d0 <DMA_DeInit+0x17c>
  {
    /* Reset interrupt pending bits for DMA2 Stream1 */
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
 80069c0:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 80069c4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80069c8:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 80069cc:	609a      	str	r2, [r3, #8]
 80069ce:	e05e      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA2_Stream2)
 80069d0:	687a      	ldr	r2, [r7, #4]
 80069d2:	f246 4340 	movw	r3, #25664	; 0x6440
 80069d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80069da:	429a      	cmp	r2, r3
 80069dc:	d107      	bne.n	80069ee <DMA_DeInit+0x19a>
  {
    /* Reset interrupt pending bits for DMA2 Stream2 */
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
 80069de:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 80069e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80069e6:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 80069ea:	609a      	str	r2, [r3, #8]
 80069ec:	e04f      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA2_Stream3)
 80069ee:	687a      	ldr	r2, [r7, #4]
 80069f0:	f246 4358 	movw	r3, #25688	; 0x6458
 80069f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80069f8:	429a      	cmp	r2, r3
 80069fa:	d107      	bne.n	8006a0c <DMA_DeInit+0x1b8>
  {
    /* Reset interrupt pending bits for DMA2 Stream3 */
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
 80069fc:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8006a00:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a04:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 8006a08:	609a      	str	r2, [r3, #8]
 8006a0a:	e040      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA2_Stream4)
 8006a0c:	687a      	ldr	r2, [r7, #4]
 8006a0e:	f246 4370 	movw	r3, #25712	; 0x6470
 8006a12:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a16:	429a      	cmp	r2, r3
 8006a18:	d109      	bne.n	8006a2e <DMA_DeInit+0x1da>
  {
    /* Reset interrupt pending bits for DMA2 Stream4 */
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
 8006a1a:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8006a1e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a22:	f04f 023d 	mov.w	r2, #61	; 0x3d
 8006a26:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006a2a:	60da      	str	r2, [r3, #12]
 8006a2c:	e02f      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA2_Stream5)
 8006a2e:	687a      	ldr	r2, [r7, #4]
 8006a30:	f246 4388 	movw	r3, #25736	; 0x6488
 8006a34:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a38:	429a      	cmp	r2, r3
 8006a3a:	d109      	bne.n	8006a50 <DMA_DeInit+0x1fc>
  {
    /* Reset interrupt pending bits for DMA2 Stream5 */
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
 8006a3c:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8006a40:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a44:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8006a48:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006a4c:	60da      	str	r2, [r3, #12]
 8006a4e:	e01e      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else if (DMAy_Streamx == DMA2_Stream6)
 8006a50:	687a      	ldr	r2, [r7, #4]
 8006a52:	f246 43a0 	movw	r3, #25760	; 0x64a0
 8006a56:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a5a:	429a      	cmp	r2, r3
 8006a5c:	d109      	bne.n	8006a72 <DMA_DeInit+0x21e>
  {
    /* Reset interrupt pending bits for DMA2 Stream6 */
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
 8006a5e:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8006a62:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a66:	f04f 0200 	mov.w	r2, #0
 8006a6a:	f2c2 023d 	movt	r2, #8253	; 0x203d
 8006a6e:	60da      	str	r2, [r3, #12]
 8006a70:	e00d      	b.n	8006a8e <DMA_DeInit+0x23a>
  }
  else 
  {
    if (DMAy_Streamx == DMA2_Stream7)
 8006a72:	687a      	ldr	r2, [r7, #4]
 8006a74:	f246 43b8 	movw	r3, #25784	; 0x64b8
 8006a78:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a7c:	429a      	cmp	r2, r3
 8006a7e:	d106      	bne.n	8006a8e <DMA_DeInit+0x23a>
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
 8006a80:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8006a84:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a88:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 8006a8c:	60da      	str	r2, [r3, #12]
    }
  }
}
 8006a8e:	f107 070c 	add.w	r7, r7, #12
 8006a92:	46bd      	mov	sp, r7
 8006a94:	bc80      	pop	{r7}
 8006a96:	4770      	bx	lr

08006a98 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Stream.  
  * @retval None
  */
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
{
 8006a98:	b480      	push	{r7}
 8006a9a:	b085      	sub	sp, #20
 8006a9c:	af00      	add	r7, sp, #0
 8006a9e:	6078      	str	r0, [r7, #4]
 8006aa0:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8006aa2:	f04f 0300 	mov.w	r3, #0
 8006aa6:	60fb      	str	r3, [r7, #12]
  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));

  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;
 8006aa8:	687b      	ldr	r3, [r7, #4]
 8006aaa:	681b      	ldr	r3, [r3, #0]
 8006aac:	60fb      	str	r3, [r7, #12]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8006aae:	68fa      	ldr	r2, [r7, #12]
 8006ab0:	f248 033f 	movw	r3, #32831	; 0x803f
 8006ab4:	f2cf 031c 	movt	r3, #61468	; 0xf01c
 8006ab8:	4013      	ands	r3, r2
 8006aba:	60fb      	str	r3, [r7, #12]
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8006abc:	683b      	ldr	r3, [r7, #0]
 8006abe:	681a      	ldr	r2, [r3, #0]
 8006ac0:	683b      	ldr	r3, [r7, #0]
 8006ac2:	68db      	ldr	r3, [r3, #12]
 8006ac4:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8006ac6:	683b      	ldr	r3, [r7, #0]
 8006ac8:	695b      	ldr	r3, [r3, #20]
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8006aca:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8006acc:	683b      	ldr	r3, [r7, #0]
 8006ace:	699b      	ldr	r3, [r3, #24]
 8006ad0:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8006ad2:	683b      	ldr	r3, [r7, #0]
 8006ad4:	69db      	ldr	r3, [r3, #28]
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8006ad6:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8006ad8:	683b      	ldr	r3, [r7, #0]
 8006ada:	6a1b      	ldr	r3, [r3, #32]
 8006adc:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8006ade:	683b      	ldr	r3, [r7, #0]
 8006ae0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8006ae2:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8006ae4:	683b      	ldr	r3, [r7, #0]
 8006ae6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006ae8:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 8006aea:	683b      	ldr	r3, [r7, #0]
 8006aec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8006aee:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 8006af0:	683b      	ldr	r3, [r7, #0]
 8006af2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006af4:	4313      	orrs	r3, r2
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8006af6:	68fa      	ldr	r2, [r7, #12]
 8006af8:	4313      	orrs	r3, r2
 8006afa:	60fb      	str	r3, [r7, #12]
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;

  /* Write to DMAy Streamx CR register */
  DMAy_Streamx->CR = tmpreg;
 8006afc:	687b      	ldr	r3, [r7, #4]
 8006afe:	68fa      	ldr	r2, [r7, #12]
 8006b00:	601a      	str	r2, [r3, #0]

  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;
 8006b02:	687b      	ldr	r3, [r7, #4]
 8006b04:	695b      	ldr	r3, [r3, #20]
 8006b06:	60fb      	str	r3, [r7, #12]

  /* Clear DMDIS and FTH bits */
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8006b08:	68fb      	ldr	r3, [r7, #12]
 8006b0a:	f023 0307 	bic.w	r3, r3, #7
 8006b0e:	60fb      	str	r3, [r7, #12]

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8006b10:	683b      	ldr	r3, [r7, #0]
 8006b12:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006b14:	683b      	ldr	r3, [r7, #0]
 8006b16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006b18:	4313      	orrs	r3, r2
 8006b1a:	68fa      	ldr	r2, [r7, #12]
 8006b1c:	4313      	orrs	r3, r2
 8006b1e:	60fb      	str	r3, [r7, #12]

  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;
 8006b20:	687b      	ldr	r3, [r7, #4]
 8006b22:	68fa      	ldr	r2, [r7, #12]
 8006b24:	615a      	str	r2, [r3, #20]

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 8006b26:	683b      	ldr	r3, [r7, #0]
 8006b28:	691a      	ldr	r2, [r3, #16]
 8006b2a:	687b      	ldr	r3, [r7, #4]
 8006b2c:	605a      	str	r2, [r3, #4]

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8006b2e:	683b      	ldr	r3, [r7, #0]
 8006b30:	685a      	ldr	r2, [r3, #4]
 8006b32:	687b      	ldr	r3, [r7, #4]
 8006b34:	609a      	str	r2, [r3, #8]

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 8006b36:	683b      	ldr	r3, [r7, #0]
 8006b38:	689a      	ldr	r2, [r3, #8]
 8006b3a:	687b      	ldr	r3, [r7, #4]
 8006b3c:	60da      	str	r2, [r3, #12]
}
 8006b3e:	f107 0714 	add.w	r7, r7, #20
 8006b42:	46bd      	mov	sp, r7
 8006b44:	bc80      	pop	{r7}
 8006b46:	4770      	bx	lr

08006b48 <DMA_StructInit>:
  * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will 
  *         be initialized.
  * @retval None
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
 8006b48:	b480      	push	{r7}
 8006b4a:	b083      	sub	sp, #12
 8006b4c:	af00      	add	r7, sp, #0
 8006b4e:	6078      	str	r0, [r7, #4]
  /*-------------- Reset DMA init structure parameters values ----------------*/
  /* Initialize the DMA_Channel member */
  DMA_InitStruct->DMA_Channel = 0;
 8006b50:	687b      	ldr	r3, [r7, #4]
 8006b52:	f04f 0200 	mov.w	r2, #0
 8006b56:	601a      	str	r2, [r3, #0]

  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8006b58:	687b      	ldr	r3, [r7, #4]
 8006b5a:	f04f 0200 	mov.w	r2, #0
 8006b5e:	605a      	str	r2, [r3, #4]

  /* Initialize the DMA_Memory0BaseAddr member */
  DMA_InitStruct->DMA_Memory0BaseAddr = 0;
 8006b60:	687b      	ldr	r3, [r7, #4]
 8006b62:	f04f 0200 	mov.w	r2, #0
 8006b66:	609a      	str	r2, [r3, #8]

  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
 8006b68:	687b      	ldr	r3, [r7, #4]
 8006b6a:	f04f 0200 	mov.w	r2, #0
 8006b6e:	60da      	str	r2, [r3, #12]

  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 8006b70:	687b      	ldr	r3, [r7, #4]
 8006b72:	f04f 0200 	mov.w	r2, #0
 8006b76:	611a      	str	r2, [r3, #16]

  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8006b78:	687b      	ldr	r3, [r7, #4]
 8006b7a:	f04f 0200 	mov.w	r2, #0
 8006b7e:	615a      	str	r2, [r3, #20]

  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8006b80:	687b      	ldr	r3, [r7, #4]
 8006b82:	f04f 0200 	mov.w	r2, #0
 8006b86:	619a      	str	r2, [r3, #24]

  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8006b88:	687b      	ldr	r3, [r7, #4]
 8006b8a:	f04f 0200 	mov.w	r2, #0
 8006b8e:	61da      	str	r2, [r3, #28]

  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8006b90:	687b      	ldr	r3, [r7, #4]
 8006b92:	f04f 0200 	mov.w	r2, #0
 8006b96:	621a      	str	r2, [r3, #32]

  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8006b98:	687b      	ldr	r3, [r7, #4]
 8006b9a:	f04f 0200 	mov.w	r2, #0
 8006b9e:	625a      	str	r2, [r3, #36]	; 0x24

  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 8006ba0:	687b      	ldr	r3, [r7, #4]
 8006ba2:	f04f 0200 	mov.w	r2, #0
 8006ba6:	629a      	str	r2, [r3, #40]	; 0x28

  /* Initialize the DMA_FIFOMode member */
  DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
 8006ba8:	687b      	ldr	r3, [r7, #4]
 8006baa:	f04f 0200 	mov.w	r2, #0
 8006bae:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Initialize the DMA_FIFOThreshold member */
  DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 8006bb0:	687b      	ldr	r3, [r7, #4]
 8006bb2:	f04f 0200 	mov.w	r2, #0
 8006bb6:	631a      	str	r2, [r3, #48]	; 0x30

  /* Initialize the DMA_MemoryBurst member */
  DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
 8006bb8:	687b      	ldr	r3, [r7, #4]
 8006bba:	f04f 0200 	mov.w	r2, #0
 8006bbe:	635a      	str	r2, [r3, #52]	; 0x34

  /* Initialize the DMA_PeripheralBurst member */
  DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 8006bc0:	687b      	ldr	r3, [r7, #4]
 8006bc2:	f04f 0200 	mov.w	r2, #0
 8006bc6:	639a      	str	r2, [r3, #56]	; 0x38
}
 8006bc8:	f107 070c 	add.w	r7, r7, #12
 8006bcc:	46bd      	mov	sp, r7
 8006bce:	bc80      	pop	{r7}
 8006bd0:	4770      	bx	lr
 8006bd2:	bf00      	nop

08006bd4 <DMA_Cmd>:
  *        this single data is finished.            
  *    
  * @retval None
  */
void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
{
 8006bd4:	b480      	push	{r7}
 8006bd6:	b083      	sub	sp, #12
 8006bd8:	af00      	add	r7, sp, #0
 8006bda:	6078      	str	r0, [r7, #4]
 8006bdc:	460b      	mov	r3, r1
 8006bde:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8006be0:	78fb      	ldrb	r3, [r7, #3]
 8006be2:	2b00      	cmp	r3, #0
 8006be4:	d006      	beq.n	8006bf4 <DMA_Cmd+0x20>
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 8006be6:	687b      	ldr	r3, [r7, #4]
 8006be8:	681b      	ldr	r3, [r3, #0]
 8006bea:	f043 0201 	orr.w	r2, r3, #1
 8006bee:	687b      	ldr	r3, [r7, #4]
 8006bf0:	601a      	str	r2, [r3, #0]
 8006bf2:	e005      	b.n	8006c00 <DMA_Cmd+0x2c>
  }
  else
  {
    /* Disable the selected DMAy Streamx by clearing EN bit */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 8006bf4:	687b      	ldr	r3, [r7, #4]
 8006bf6:	681b      	ldr	r3, [r3, #0]
 8006bf8:	f023 0201 	bic.w	r2, r3, #1
 8006bfc:	687b      	ldr	r3, [r7, #4]
 8006bfe:	601a      	str	r2, [r3, #0]
  }
}
 8006c00:	f107 070c 	add.w	r7, r7, #12
 8006c04:	46bd      	mov	sp, r7
 8006c06:	bc80      	pop	{r7}
 8006c08:	4770      	bx	lr
 8006c0a:	bf00      	nop

08006c0c <DMA_PeriphIncOffsetSizeConfig>:
  *            @arg DMA_PINCOS_WordAligned: Peripheral address increment offset is 
  *                                         fixed to 4 (32-bit aligned addresses). 
  * @retval None
  */
void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
{
 8006c0c:	b480      	push	{r7}
 8006c0e:	b083      	sub	sp, #12
 8006c10:	af00      	add	r7, sp, #0
 8006c12:	6078      	str	r0, [r7, #4]
 8006c14:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
 8006c16:	683b      	ldr	r3, [r7, #0]
 8006c18:	2b00      	cmp	r3, #0
 8006c1a:	d006      	beq.n	8006c2a <DMA_PeriphIncOffsetSizeConfig+0x1e>
  {
    /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 8006c1c:	687b      	ldr	r3, [r7, #4]
 8006c1e:	681b      	ldr	r3, [r3, #0]
 8006c20:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8006c24:	687b      	ldr	r3, [r7, #4]
 8006c26:	601a      	str	r2, [r3, #0]
 8006c28:	e005      	b.n	8006c36 <DMA_PeriphIncOffsetSizeConfig+0x2a>
  }
  else
  {
    /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
 8006c2a:	687b      	ldr	r3, [r7, #4]
 8006c2c:	681b      	ldr	r3, [r3, #0]
 8006c2e:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 8006c32:	687b      	ldr	r3, [r7, #4]
 8006c34:	601a      	str	r2, [r3, #0]
  }
}
 8006c36:	f107 070c 	add.w	r7, r7, #12
 8006c3a:	46bd      	mov	sp, r7
 8006c3c:	bc80      	pop	{r7}
 8006c3e:	4770      	bx	lr

08006c40 <DMA_FlowControllerConfig>:
  *            @arg DMA_FlowCtrl_Peripheral: DMAy_Streamx transactions flow controller 
  *                                          is the peripheral.    
  * @retval None
  */
void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
{
 8006c40:	b480      	push	{r7}
 8006c42:	b083      	sub	sp, #12
 8006c44:	af00      	add	r7, sp, #0
 8006c46:	6078      	str	r0, [r7, #4]
 8006c48:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
 8006c4a:	683b      	ldr	r3, [r7, #0]
 8006c4c:	2b00      	cmp	r3, #0
 8006c4e:	d006      	beq.n	8006c5e <DMA_FlowControllerConfig+0x1e>
  {
    /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 8006c50:	687b      	ldr	r3, [r7, #4]
 8006c52:	681b      	ldr	r3, [r3, #0]
 8006c54:	f043 0220 	orr.w	r2, r3, #32
 8006c58:	687b      	ldr	r3, [r7, #4]
 8006c5a:	601a      	str	r2, [r3, #0]
 8006c5c:	e005      	b.n	8006c6a <DMA_FlowControllerConfig+0x2a>
  }
  else
  {
    /* Clear the PFCTRL bit: Memory is the flow controller */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
 8006c5e:	687b      	ldr	r3, [r7, #4]
 8006c60:	681b      	ldr	r3, [r3, #0]
 8006c62:	f023 0220 	bic.w	r2, r3, #32
 8006c66:	687b      	ldr	r3, [r7, #4]
 8006c68:	601a      	str	r2, [r3, #0]
  }
}
 8006c6a:	f107 070c 	add.w	r7, r7, #12
 8006c6e:	46bd      	mov	sp, r7
 8006c70:	bc80      	pop	{r7}
 8006c72:	4770      	bx	lr

08006c74 <DMA_SetCurrDataCounter>:
  *         DMAy_SxPAR register is considered as Peripheral.
  *      
  * @retval The number of remaining data units in the current DMAy Streamx transfer.
  */
void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
{
 8006c74:	b480      	push	{r7}
 8006c76:	b083      	sub	sp, #12
 8006c78:	af00      	add	r7, sp, #0
 8006c7a:	6078      	str	r0, [r7, #4]
 8006c7c:	460b      	mov	r3, r1
 8006c7e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Write the number of data units to be transferred */
  DMAy_Streamx->NDTR = (uint16_t)Counter;
 8006c80:	887a      	ldrh	r2, [r7, #2]
 8006c82:	687b      	ldr	r3, [r7, #4]
 8006c84:	605a      	str	r2, [r3, #4]
}
 8006c86:	f107 070c 	add.w	r7, r7, #12
 8006c8a:	46bd      	mov	sp, r7
 8006c8c:	bc80      	pop	{r7}
 8006c8e:	4770      	bx	lr

08006c90 <DMA_GetCurrDataCounter>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *          to 7 to select the DMA Stream.
  * @retval The number of remaining data units in the current DMAy Streamx transfer.
  */
uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
{
 8006c90:	b480      	push	{r7}
 8006c92:	b083      	sub	sp, #12
 8006c94:	af00      	add	r7, sp, #0
 8006c96:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Return the number of remaining data units for DMAy Streamx */
  return ((uint16_t)(DMAy_Streamx->NDTR));
 8006c98:	687b      	ldr	r3, [r7, #4]
 8006c9a:	685b      	ldr	r3, [r3, #4]
 8006c9c:	b29b      	uxth	r3, r3
}
 8006c9e:	4618      	mov	r0, r3
 8006ca0:	f107 070c 	add.w	r7, r7, #12
 8006ca4:	46bd      	mov	sp, r7
 8006ca6:	bc80      	pop	{r7}
 8006ca8:	4770      	bx	lr
 8006caa:	bf00      	nop

08006cac <DMA_DoubleBufferModeConfig>:
  *   
  * @retval None
  */
void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
                                uint32_t DMA_CurrentMemory)
{  
 8006cac:	b480      	push	{r7}
 8006cae:	b085      	sub	sp, #20
 8006cb0:	af00      	add	r7, sp, #0
 8006cb2:	60f8      	str	r0, [r7, #12]
 8006cb4:	60b9      	str	r1, [r7, #8]
 8006cb6:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
 8006cb8:	687b      	ldr	r3, [r7, #4]
 8006cba:	2b00      	cmp	r3, #0
 8006cbc:	d006      	beq.n	8006ccc <DMA_DoubleBufferModeConfig+0x20>
  {
    /* Set Memory 1 as current memory address */
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 8006cbe:	68fb      	ldr	r3, [r7, #12]
 8006cc0:	681b      	ldr	r3, [r3, #0]
 8006cc2:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
 8006cc6:	68fb      	ldr	r3, [r7, #12]
 8006cc8:	601a      	str	r2, [r3, #0]
 8006cca:	e005      	b.n	8006cd8 <DMA_DoubleBufferModeConfig+0x2c>
  }
  else
  {
    /* Set Memory 0 as current memory address */
    DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
 8006ccc:	68fb      	ldr	r3, [r7, #12]
 8006cce:	681b      	ldr	r3, [r3, #0]
 8006cd0:	f423 2200 	bic.w	r2, r3, #524288	; 0x80000
 8006cd4:	68fb      	ldr	r3, [r7, #12]
 8006cd6:	601a      	str	r2, [r3, #0]
  }

  /* Write to DMAy Streamx M1AR */
  DMAy_Streamx->M1AR = Memory1BaseAddr;
 8006cd8:	68fb      	ldr	r3, [r7, #12]
 8006cda:	68ba      	ldr	r2, [r7, #8]
 8006cdc:	611a      	str	r2, [r3, #16]
}
 8006cde:	f107 0714 	add.w	r7, r7, #20
 8006ce2:	46bd      	mov	sp, r7
 8006ce4:	bc80      	pop	{r7}
 8006ce6:	4770      	bx	lr

08006ce8 <DMA_DoubleBufferModeCmd>:
  * @param  NewState: new state of the DMAy Streamx double buffer mode. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
{  
 8006ce8:	b480      	push	{r7}
 8006cea:	b083      	sub	sp, #12
 8006cec:	af00      	add	r7, sp, #0
 8006cee:	6078      	str	r0, [r7, #4]
 8006cf0:	460b      	mov	r3, r1
 8006cf2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
 8006cf4:	78fb      	ldrb	r3, [r7, #3]
 8006cf6:	2b00      	cmp	r3, #0
 8006cf8:	d006      	beq.n	8006d08 <DMA_DoubleBufferModeCmd+0x20>
  {
    /* Enable the Double buffer mode */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 8006cfa:	687b      	ldr	r3, [r7, #4]
 8006cfc:	681b      	ldr	r3, [r3, #0]
 8006cfe:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 8006d02:	687b      	ldr	r3, [r7, #4]
 8006d04:	601a      	str	r2, [r3, #0]
 8006d06:	e005      	b.n	8006d14 <DMA_DoubleBufferModeCmd+0x2c>
  }
  else
  {
    /* Disable the Double buffer mode */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
 8006d08:	687b      	ldr	r3, [r7, #4]
 8006d0a:	681b      	ldr	r3, [r3, #0]
 8006d0c:	f423 2280 	bic.w	r2, r3, #262144	; 0x40000
 8006d10:	687b      	ldr	r3, [r7, #4]
 8006d12:	601a      	str	r2, [r3, #0]
  }
}
 8006d14:	f107 070c 	add.w	r7, r7, #12
 8006d18:	46bd      	mov	sp, r7
 8006d1a:	bc80      	pop	{r7}
 8006d1c:	4770      	bx	lr
 8006d1e:	bf00      	nop

08006d20 <DMA_MemoryTargetConfig>:
  *  
  * @retval None
  */
void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
                           uint32_t DMA_MemoryTarget)
{
 8006d20:	b480      	push	{r7}
 8006d22:	b085      	sub	sp, #20
 8006d24:	af00      	add	r7, sp, #0
 8006d26:	60f8      	str	r0, [r7, #12]
 8006d28:	60b9      	str	r1, [r7, #8]
 8006d2a:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
    
  /* Check the Memory target to be configured */
  if (DMA_MemoryTarget != DMA_Memory_0)
 8006d2c:	687b      	ldr	r3, [r7, #4]
 8006d2e:	2b00      	cmp	r3, #0
 8006d30:	d003      	beq.n	8006d3a <DMA_MemoryTargetConfig+0x1a>
  {
    /* Write to DMAy Streamx M1AR */
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
 8006d32:	68fb      	ldr	r3, [r7, #12]
 8006d34:	68ba      	ldr	r2, [r7, #8]
 8006d36:	611a      	str	r2, [r3, #16]
 8006d38:	e002      	b.n	8006d40 <DMA_MemoryTargetConfig+0x20>
  }  
  else
  {
    /* Write to DMAy Streamx M0AR */
    DMAy_Streamx->M0AR = MemoryBaseAddr;  
 8006d3a:	68fb      	ldr	r3, [r7, #12]
 8006d3c:	68ba      	ldr	r2, [r7, #8]
 8006d3e:	60da      	str	r2, [r3, #12]
  }
}
 8006d40:	f107 0714 	add.w	r7, r7, #20
 8006d44:	46bd      	mov	sp, r7
 8006d46:	bc80      	pop	{r7}
 8006d48:	4770      	bx	lr
 8006d4a:	bf00      	nop

08006d4c <DMA_GetCurrentMemoryTarget>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *          to 7 to select the DMA Stream.
  * @retval The memory target number: 0 for Memory0 or 1 for Memory1. 
  */
uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
{
 8006d4c:	b480      	push	{r7}
 8006d4e:	b085      	sub	sp, #20
 8006d50:	af00      	add	r7, sp, #0
 8006d52:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 8006d54:	f04f 0300 	mov.w	r3, #0
 8006d58:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Get the current memory target */
  if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
 8006d5a:	687b      	ldr	r3, [r7, #4]
 8006d5c:	681b      	ldr	r3, [r3, #0]
 8006d5e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8006d62:	2b00      	cmp	r3, #0
 8006d64:	d003      	beq.n	8006d6e <DMA_GetCurrentMemoryTarget+0x22>
  {
    /* Current memory buffer used is Memory 1 */
    tmp = 1;
 8006d66:	f04f 0301 	mov.w	r3, #1
 8006d6a:	60fb      	str	r3, [r7, #12]
 8006d6c:	e002      	b.n	8006d74 <DMA_GetCurrentMemoryTarget+0x28>
  }  
  else
  {
    /* Current memory buffer used is Memory 0 */
    tmp = 0;    
 8006d6e:	f04f 0300 	mov.w	r3, #0
 8006d72:	60fb      	str	r3, [r7, #12]
  }
  return tmp;
 8006d74:	68fb      	ldr	r3, [r7, #12]
}
 8006d76:	4618      	mov	r0, r3
 8006d78:	f107 0714 	add.w	r7, r7, #20
 8006d7c:	46bd      	mov	sp, r7
 8006d7e:	bc80      	pop	{r7}
 8006d80:	4770      	bx	lr
 8006d82:	bf00      	nop

08006d84 <DMA_GetCmdStatus>:
  *          of this single data is finished.  
  *      
  * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
  */
FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
{
 8006d84:	b480      	push	{r7}
 8006d86:	b085      	sub	sp, #20
 8006d88:	af00      	add	r7, sp, #0
 8006d8a:	6078      	str	r0, [r7, #4]
  FunctionalState state = DISABLE;
 8006d8c:	f04f 0300 	mov.w	r3, #0
 8006d90:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
 8006d92:	687b      	ldr	r3, [r7, #4]
 8006d94:	681b      	ldr	r3, [r3, #0]
 8006d96:	f003 0301 	and.w	r3, r3, #1
 8006d9a:	b2db      	uxtb	r3, r3
 8006d9c:	2b00      	cmp	r3, #0
 8006d9e:	d003      	beq.n	8006da8 <DMA_GetCmdStatus+0x24>
  {
    /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
    state = ENABLE;
 8006da0:	f04f 0301 	mov.w	r3, #1
 8006da4:	73fb      	strb	r3, [r7, #15]
 8006da6:	e002      	b.n	8006dae <DMA_GetCmdStatus+0x2a>
  }
  else
  {
    /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
        all transfers are complete) */
    state = DISABLE;
 8006da8:	f04f 0300 	mov.w	r3, #0
 8006dac:	73fb      	strb	r3, [r7, #15]
  }
  return state;
 8006dae:	7bfb      	ldrb	r3, [r7, #15]
}
 8006db0:	4618      	mov	r0, r3
 8006db2:	f107 0714 	add.w	r7, r7, #20
 8006db6:	46bd      	mov	sp, r7
 8006db8:	bc80      	pop	{r7}
 8006dba:	4770      	bx	lr

08006dbc <DMA_GetFIFOStatus>:
  *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
  *           - DMA_FIFOStatus_Empty: when FIFO is empty
  *           - DMA_FIFOStatus_Full: when FIFO is full
  */
uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
{
 8006dbc:	b480      	push	{r7}
 8006dbe:	b085      	sub	sp, #20
 8006dc0:	af00      	add	r7, sp, #0
 8006dc2:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8006dc4:	f04f 0300 	mov.w	r3, #0
 8006dc8:	60fb      	str	r3, [r7, #12]
 
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  
  /* Get the FIFO level bits */
  tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
 8006dca:	687b      	ldr	r3, [r7, #4]
 8006dcc:	695b      	ldr	r3, [r3, #20]
 8006dce:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8006dd2:	60fb      	str	r3, [r7, #12]
  
  return tmpreg;
 8006dd4:	68fb      	ldr	r3, [r7, #12]
}
 8006dd6:	4618      	mov	r0, r3
 8006dd8:	f107 0714 	add.w	r7, r7, #20
 8006ddc:	46bd      	mov	sp, r7
 8006dde:	bc80      	pop	{r7}
 8006de0:	4770      	bx	lr
 8006de2:	bf00      	nop

08006de4 <DMA_GetFlagStatus>:
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_FLAG (SET or RESET).
  */
FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 8006de4:	b480      	push	{r7}
 8006de6:	b087      	sub	sp, #28
 8006de8:	af00      	add	r7, sp, #0
 8006dea:	6078      	str	r0, [r7, #4]
 8006dec:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 8006dee:	f04f 0300 	mov.w	r3, #0
 8006df2:	75fb      	strb	r3, [r7, #23]
  DMA_TypeDef* DMAy;
  uint32_t tmpreg = 0;
 8006df4:	f04f 0300 	mov.w	r3, #0
 8006df8:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8006dfa:	687a      	ldr	r2, [r7, #4]
 8006dfc:	f246 430f 	movw	r3, #25615	; 0x640f
 8006e00:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006e04:	429a      	cmp	r2, r3
 8006e06:	d805      	bhi.n	8006e14 <DMA_GetFlagStatus+0x30>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8006e08:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8006e0c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006e10:	613b      	str	r3, [r7, #16]
 8006e12:	e004      	b.n	8006e1e <DMA_GetFlagStatus+0x3a>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 8006e14:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8006e18:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006e1c:	613b      	str	r3, [r7, #16]
  }

  /* Check if the flag is in HISR or LISR */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 8006e1e:	683b      	ldr	r3, [r7, #0]
 8006e20:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8006e24:	2b00      	cmp	r3, #0
 8006e26:	d003      	beq.n	8006e30 <DMA_GetFlagStatus+0x4c>
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR;
 8006e28:	693b      	ldr	r3, [r7, #16]
 8006e2a:	685b      	ldr	r3, [r3, #4]
 8006e2c:	60fb      	str	r3, [r7, #12]
 8006e2e:	e002      	b.n	8006e36 <DMA_GetFlagStatus+0x52>
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR;
 8006e30:	693b      	ldr	r3, [r7, #16]
 8006e32:	681b      	ldr	r3, [r3, #0]
 8006e34:	60fb      	str	r3, [r7, #12]
  }   
 
  /* Mask the reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 8006e36:	68fa      	ldr	r2, [r7, #12]
 8006e38:	f640 737d 	movw	r3, #3965	; 0xf7d
 8006e3c:	f6c0 737d 	movt	r3, #3965	; 0xf7d
 8006e40:	4013      	ands	r3, r2
 8006e42:	60fb      	str	r3, [r7, #12]

  /* Check the status of the specified DMA flag */
  if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
 8006e44:	68fa      	ldr	r2, [r7, #12]
 8006e46:	683b      	ldr	r3, [r7, #0]
 8006e48:	4013      	ands	r3, r2
 8006e4a:	2b00      	cmp	r3, #0
 8006e4c:	d003      	beq.n	8006e56 <DMA_GetFlagStatus+0x72>
  {
    /* DMA_FLAG is set */
    bitstatus = SET;
 8006e4e:	f04f 0301 	mov.w	r3, #1
 8006e52:	75fb      	strb	r3, [r7, #23]
 8006e54:	e002      	b.n	8006e5c <DMA_GetFlagStatus+0x78>
  }
  else
  {
    /* DMA_FLAG is reset */
    bitstatus = RESET;
 8006e56:	f04f 0300 	mov.w	r3, #0
 8006e5a:	75fb      	strb	r3, [r7, #23]
  }

  /* Return the DMA_FLAG status */
  return  bitstatus;
 8006e5c:	7dfb      	ldrb	r3, [r7, #23]
}
 8006e5e:	4618      	mov	r0, r3
 8006e60:	f107 071c 	add.w	r7, r7, #28
 8006e64:	46bd      	mov	sp, r7
 8006e66:	bc80      	pop	{r7}
 8006e68:	4770      	bx	lr
 8006e6a:	bf00      	nop

08006e6c <DMA_ClearFlag>:
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.   
  * @retval None
  */
void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 8006e6c:	b480      	push	{r7}
 8006e6e:	b085      	sub	sp, #20
 8006e70:	af00      	add	r7, sp, #0
 8006e72:	6078      	str	r0, [r7, #4]
 8006e74:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8006e76:	687a      	ldr	r2, [r7, #4]
 8006e78:	f246 430f 	movw	r3, #25615	; 0x640f
 8006e7c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006e80:	429a      	cmp	r2, r3
 8006e82:	d805      	bhi.n	8006e90 <DMA_ClearFlag+0x24>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8006e84:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8006e88:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006e8c:	60fb      	str	r3, [r7, #12]
 8006e8e:	e004      	b.n	8006e9a <DMA_ClearFlag+0x2e>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 8006e90:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8006e94:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006e98:	60fb      	str	r3, [r7, #12]
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 8006e9a:	683b      	ldr	r3, [r7, #0]
 8006e9c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8006ea0:	2b00      	cmp	r3, #0
 8006ea2:	d008      	beq.n	8006eb6 <DMA_ClearFlag+0x4a>
  {
    /* Set DMAy HIFCR register clear flag bits */
    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8006ea4:	683a      	ldr	r2, [r7, #0]
 8006ea6:	f640 737d 	movw	r3, #3965	; 0xf7d
 8006eaa:	f6c0 737d 	movt	r3, #3965	; 0xf7d
 8006eae:	4013      	ands	r3, r2
 8006eb0:	68fa      	ldr	r2, [r7, #12]
 8006eb2:	60d3      	str	r3, [r2, #12]
 8006eb4:	e007      	b.n	8006ec6 <DMA_ClearFlag+0x5a>
  }
  else 
  {
    /* Set DMAy LIFCR register clear flag bits */
    DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8006eb6:	683a      	ldr	r2, [r7, #0]
 8006eb8:	f640 737d 	movw	r3, #3965	; 0xf7d
 8006ebc:	f6c0 737d 	movt	r3, #3965	; 0xf7d
 8006ec0:	4013      	ands	r3, r2
 8006ec2:	68fa      	ldr	r2, [r7, #12]
 8006ec4:	6093      	str	r3, [r2, #8]
  }    
}
 8006ec6:	f107 0714 	add.w	r7, r7, #20
 8006eca:	46bd      	mov	sp, r7
 8006ecc:	bc80      	pop	{r7}
 8006ece:	4770      	bx	lr

08006ed0 <DMA_ITConfig>:
  * @param  NewState: new state of the specified DMA interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
{
 8006ed0:	b480      	push	{r7}
 8006ed2:	b085      	sub	sp, #20
 8006ed4:	af00      	add	r7, sp, #0
 8006ed6:	60f8      	str	r0, [r7, #12]
 8006ed8:	60b9      	str	r1, [r7, #8]
 8006eda:	4613      	mov	r3, r2
 8006edc:	71fb      	strb	r3, [r7, #7]
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
 8006ede:	68bb      	ldr	r3, [r7, #8]
 8006ee0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006ee4:	2b00      	cmp	r3, #0
 8006ee6:	d00f      	beq.n	8006f08 <DMA_ITConfig+0x38>
  {
    if (NewState != DISABLE)
 8006ee8:	79fb      	ldrb	r3, [r7, #7]
 8006eea:	2b00      	cmp	r3, #0
 8006eec:	d006      	beq.n	8006efc <DMA_ITConfig+0x2c>
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8006eee:	68fb      	ldr	r3, [r7, #12]
 8006ef0:	695b      	ldr	r3, [r3, #20]
 8006ef2:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8006ef6:	68fb      	ldr	r3, [r7, #12]
 8006ef8:	615a      	str	r2, [r3, #20]
 8006efa:	e005      	b.n	8006f08 <DMA_ITConfig+0x38>
    }    
    else 
    {
      /* Disable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 8006efc:	68fb      	ldr	r3, [r7, #12]
 8006efe:	695b      	ldr	r3, [r3, #20]
 8006f00:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8006f04:	68fb      	ldr	r3, [r7, #12]
 8006f06:	615a      	str	r2, [r3, #20]
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8006f08:	68bb      	ldr	r3, [r7, #8]
 8006f0a:	2b80      	cmp	r3, #128	; 0x80
 8006f0c:	d017      	beq.n	8006f3e <DMA_ITConfig+0x6e>
  {
    if (NewState != DISABLE)
 8006f0e:	79fb      	ldrb	r3, [r7, #7]
 8006f10:	2b00      	cmp	r3, #0
 8006f12:	d009      	beq.n	8006f28 <DMA_ITConfig+0x58>
    {
      /* Enable the selected DMA transfer interrupts */
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
 8006f14:	68fb      	ldr	r3, [r7, #12]
 8006f16:	681b      	ldr	r3, [r3, #0]
 8006f18:	461a      	mov	r2, r3
 8006f1a:	68bb      	ldr	r3, [r7, #8]
 8006f1c:	f003 031e 	and.w	r3, r3, #30
 8006f20:	431a      	orrs	r2, r3
 8006f22:	68fb      	ldr	r3, [r7, #12]
 8006f24:	601a      	str	r2, [r3, #0]
 8006f26:	e00a      	b.n	8006f3e <DMA_ITConfig+0x6e>
    }
    else
    {
      /* Disable the selected DMA transfer interrupts */
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
 8006f28:	68fb      	ldr	r3, [r7, #12]
 8006f2a:	681b      	ldr	r3, [r3, #0]
 8006f2c:	461a      	mov	r2, r3
 8006f2e:	68bb      	ldr	r3, [r7, #8]
 8006f30:	f003 031e 	and.w	r3, r3, #30
 8006f34:	ea6f 0303 	mvn.w	r3, r3
 8006f38:	401a      	ands	r2, r3
 8006f3a:	68fb      	ldr	r3, [r7, #12]
 8006f3c:	601a      	str	r2, [r3, #0]
    }    
  }
}
 8006f3e:	f107 0714 	add.w	r7, r7, #20
 8006f42:	46bd      	mov	sp, r7
 8006f44:	bc80      	pop	{r7}
 8006f46:	4770      	bx	lr

08006f48 <DMA_GetITStatus>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_IT (SET or RESET).
  */
ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 8006f48:	b480      	push	{r7}
 8006f4a:	b087      	sub	sp, #28
 8006f4c:	af00      	add	r7, sp, #0
 8006f4e:	6078      	str	r0, [r7, #4]
 8006f50:	6039      	str	r1, [r7, #0]
  ITStatus bitstatus = RESET;
 8006f52:	f04f 0300 	mov.w	r3, #0
 8006f56:	75fb      	strb	r3, [r7, #23]
  DMA_TypeDef* DMAy;
  uint32_t tmpreg = 0, enablestatus = 0;
 8006f58:	f04f 0300 	mov.w	r3, #0
 8006f5c:	60fb      	str	r3, [r7, #12]
 8006f5e:	f04f 0300 	mov.w	r3, #0
 8006f62:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_IT(DMA_IT));
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8006f64:	687a      	ldr	r2, [r7, #4]
 8006f66:	f246 430f 	movw	r3, #25615	; 0x640f
 8006f6a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006f6e:	429a      	cmp	r2, r3
 8006f70:	d805      	bhi.n	8006f7e <DMA_GetITStatus+0x36>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8006f72:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8006f76:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006f7a:	613b      	str	r3, [r7, #16]
 8006f7c:	e004      	b.n	8006f88 <DMA_GetITStatus+0x40>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 8006f7e:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8006f82:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006f86:	613b      	str	r3, [r7, #16]
  }

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 8006f88:	683a      	ldr	r2, [r7, #0]
 8006f8a:	f640 733c 	movw	r3, #3900	; 0xf3c
 8006f8e:	f6c0 733c 	movt	r3, #3900	; 0xf3c
 8006f92:	4013      	ands	r3, r2
 8006f94:	2b00      	cmp	r3, #0
 8006f96:	d00c      	beq.n	8006fb2 <DMA_GetITStatus+0x6a>
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
 8006f98:	683b      	ldr	r3, [r7, #0]
 8006f9a:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8006f9e:	f003 031e 	and.w	r3, r3, #30
 8006fa2:	60fb      	str	r3, [r7, #12]
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 8006fa4:	687b      	ldr	r3, [r7, #4]
 8006fa6:	681b      	ldr	r3, [r3, #0]
 8006fa8:	461a      	mov	r2, r3
 8006faa:	68fb      	ldr	r3, [r7, #12]
 8006fac:	4013      	ands	r3, r2
 8006fae:	60bb      	str	r3, [r7, #8]
 8006fb0:	e004      	b.n	8006fbc <DMA_GetITStatus+0x74>
  }
  else 
  {
    /* Check the enable bit in FCR register */
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
 8006fb2:	687b      	ldr	r3, [r7, #4]
 8006fb4:	695b      	ldr	r3, [r3, #20]
 8006fb6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006fba:	60bb      	str	r3, [r7, #8]
  }
 
  /* Check if the interrupt pending flag is in LISR or HISR */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8006fbc:	683b      	ldr	r3, [r7, #0]
 8006fbe:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8006fc2:	2b00      	cmp	r3, #0
 8006fc4:	d003      	beq.n	8006fce <DMA_GetITStatus+0x86>
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR ;
 8006fc6:	693b      	ldr	r3, [r7, #16]
 8006fc8:	685b      	ldr	r3, [r3, #4]
 8006fca:	60fb      	str	r3, [r7, #12]
 8006fcc:	e002      	b.n	8006fd4 <DMA_GetITStatus+0x8c>
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR ;
 8006fce:	693b      	ldr	r3, [r7, #16]
 8006fd0:	681b      	ldr	r3, [r3, #0]
 8006fd2:	60fb      	str	r3, [r7, #12]
  } 

  /* mask all reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 8006fd4:	68fa      	ldr	r2, [r7, #12]
 8006fd6:	f640 737d 	movw	r3, #3965	; 0xf7d
 8006fda:	f6c0 737d 	movt	r3, #3965	; 0xf7d
 8006fde:	4013      	ands	r3, r2
 8006fe0:	60fb      	str	r3, [r7, #12]

  /* Check the status of the specified DMA interrupt */
  if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8006fe2:	68fa      	ldr	r2, [r7, #12]
 8006fe4:	683b      	ldr	r3, [r7, #0]
 8006fe6:	4013      	ands	r3, r2
 8006fe8:	2b00      	cmp	r3, #0
 8006fea:	d006      	beq.n	8006ffa <DMA_GetITStatus+0xb2>
 8006fec:	68bb      	ldr	r3, [r7, #8]
 8006fee:	2b00      	cmp	r3, #0
 8006ff0:	d003      	beq.n	8006ffa <DMA_GetITStatus+0xb2>
  {
    /* DMA_IT is set */
    bitstatus = SET;
 8006ff2:	f04f 0301 	mov.w	r3, #1
 8006ff6:	75fb      	strb	r3, [r7, #23]
 8006ff8:	e002      	b.n	8007000 <DMA_GetITStatus+0xb8>
  }
  else
  {
    /* DMA_IT is reset */
    bitstatus = RESET;
 8006ffa:	f04f 0300 	mov.w	r3, #0
 8006ffe:	75fb      	strb	r3, [r7, #23]
  }

  /* Return the DMA_IT status */
  return  bitstatus;
 8007000:	7dfb      	ldrb	r3, [r7, #23]
}
 8007002:	4618      	mov	r0, r3
 8007004:	f107 071c 	add.w	r7, r7, #28
 8007008:	46bd      	mov	sp, r7
 800700a:	bc80      	pop	{r7}
 800700c:	4770      	bx	lr
 800700e:	bf00      	nop

08007010 <DMA_ClearITPendingBit>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 8007010:	b480      	push	{r7}
 8007012:	b085      	sub	sp, #20
 8007014:	af00      	add	r7, sp, #0
 8007016:	6078      	str	r0, [r7, #4]
 8007018:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_IT(DMA_IT));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 800701a:	687a      	ldr	r2, [r7, #4]
 800701c:	f246 430f 	movw	r3, #25615	; 0x640f
 8007020:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007024:	429a      	cmp	r2, r3
 8007026:	d805      	bhi.n	8007034 <DMA_ClearITPendingBit+0x24>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8007028:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 800702c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007030:	60fb      	str	r3, [r7, #12]
 8007032:	e004      	b.n	800703e <DMA_ClearITPendingBit+0x2e>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 8007034:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8007038:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800703c:	60fb      	str	r3, [r7, #12]
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 800703e:	683b      	ldr	r3, [r7, #0]
 8007040:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8007044:	2b00      	cmp	r3, #0
 8007046:	d008      	beq.n	800705a <DMA_ClearITPendingBit+0x4a>
  {
    /* Set DMAy HIFCR register clear interrupt bits */
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8007048:	683a      	ldr	r2, [r7, #0]
 800704a:	f640 737d 	movw	r3, #3965	; 0xf7d
 800704e:	f6c0 737d 	movt	r3, #3965	; 0xf7d
 8007052:	4013      	ands	r3, r2
 8007054:	68fa      	ldr	r2, [r7, #12]
 8007056:	60d3      	str	r3, [r2, #12]
 8007058:	e007      	b.n	800706a <DMA_ClearITPendingBit+0x5a>
  }
  else 
  {
    /* Set DMAy LIFCR register clear interrupt bits */
    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 800705a:	683a      	ldr	r2, [r7, #0]
 800705c:	f640 737d 	movw	r3, #3965	; 0xf7d
 8007060:	f6c0 737d 	movt	r3, #3965	; 0xf7d
 8007064:	4013      	ands	r3, r2
 8007066:	68fa      	ldr	r2, [r7, #12]
 8007068:	6093      	str	r3, [r2, #8]
  }   
}
 800706a:	f107 0714 	add.w	r7, r7, #20
 800706e:	46bd      	mov	sp, r7
 8007070:	bc80      	pop	{r7}
 8007072:	4770      	bx	lr

08007074 <EXTI_DeInit>:
  * @brief  Deinitializes the EXTI peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
 8007074:	b480      	push	{r7}
 8007076:	af00      	add	r7, sp, #0
  EXTI->IMR = 0x00000000;
 8007078:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800707c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007080:	f04f 0200 	mov.w	r2, #0
 8007084:	601a      	str	r2, [r3, #0]
  EXTI->EMR = 0x00000000;
 8007086:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800708a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800708e:	f04f 0200 	mov.w	r2, #0
 8007092:	605a      	str	r2, [r3, #4]
  EXTI->RTSR = 0x00000000;
 8007094:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8007098:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800709c:	f04f 0200 	mov.w	r2, #0
 80070a0:	609a      	str	r2, [r3, #8]
  EXTI->FTSR = 0x00000000;
 80070a2:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80070a6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80070aa:	f04f 0200 	mov.w	r2, #0
 80070ae:	60da      	str	r2, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 80070b0:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80070b4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80070b8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80070bc:	f2c0 027f 	movt	r2, #127	; 0x7f
 80070c0:	615a      	str	r2, [r3, #20]
}
 80070c2:	46bd      	mov	sp, r7
 80070c4:	bc80      	pop	{r7}
 80070c6:	4770      	bx	lr

080070c8 <EXTI_Init>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 80070c8:	b480      	push	{r7}
 80070ca:	b085      	sub	sp, #20
 80070cc:	af00      	add	r7, sp, #0
 80070ce:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 80070d0:	f04f 0300 	mov.w	r3, #0
 80070d4:	60fb      	str	r3, [r7, #12]
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
 80070d6:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80070da:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80070de:	60fb      	str	r3, [r7, #12]
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 80070e0:	687b      	ldr	r3, [r7, #4]
 80070e2:	799b      	ldrb	r3, [r3, #6]
 80070e4:	2b00      	cmp	r3, #0
 80070e6:	d07e      	beq.n	80071e6 <EXTI_Init+0x11e>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 80070e8:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80070ec:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80070f0:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 80070f4:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80070f8:	6812      	ldr	r2, [r2, #0]
 80070fa:	4611      	mov	r1, r2
 80070fc:	687a      	ldr	r2, [r7, #4]
 80070fe:	6812      	ldr	r2, [r2, #0]
 8007100:	ea6f 0202 	mvn.w	r2, r2
 8007104:	400a      	ands	r2, r1
 8007106:	601a      	str	r2, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8007108:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800710c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007110:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8007114:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8007118:	6852      	ldr	r2, [r2, #4]
 800711a:	4611      	mov	r1, r2
 800711c:	687a      	ldr	r2, [r7, #4]
 800711e:	6812      	ldr	r2, [r2, #0]
 8007120:	ea6f 0202 	mvn.w	r2, r2
 8007124:	400a      	ands	r2, r1
 8007126:	605a      	str	r2, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8007128:	687b      	ldr	r3, [r7, #4]
 800712a:	791b      	ldrb	r3, [r3, #4]
 800712c:	68fa      	ldr	r2, [r7, #12]
 800712e:	18d3      	adds	r3, r2, r3
 8007130:	60fb      	str	r3, [r7, #12]

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8007132:	68fb      	ldr	r3, [r7, #12]
 8007134:	68fa      	ldr	r2, [r7, #12]
 8007136:	6811      	ldr	r1, [r2, #0]
 8007138:	687a      	ldr	r2, [r7, #4]
 800713a:	6812      	ldr	r2, [r2, #0]
 800713c:	430a      	orrs	r2, r1
 800713e:	601a      	str	r2, [r3, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8007140:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8007144:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007148:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 800714c:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8007150:	6892      	ldr	r2, [r2, #8]
 8007152:	4611      	mov	r1, r2
 8007154:	687a      	ldr	r2, [r7, #4]
 8007156:	6812      	ldr	r2, [r2, #0]
 8007158:	ea6f 0202 	mvn.w	r2, r2
 800715c:	400a      	ands	r2, r1
 800715e:	609a      	str	r2, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8007160:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8007164:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007168:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 800716c:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8007170:	68d2      	ldr	r2, [r2, #12]
 8007172:	4611      	mov	r1, r2
 8007174:	687a      	ldr	r2, [r7, #4]
 8007176:	6812      	ldr	r2, [r2, #0]
 8007178:	ea6f 0202 	mvn.w	r2, r2
 800717c:	400a      	ands	r2, r1
 800717e:	60da      	str	r2, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8007180:	687b      	ldr	r3, [r7, #4]
 8007182:	795b      	ldrb	r3, [r3, #5]
 8007184:	2b10      	cmp	r3, #16
 8007186:	d11c      	bne.n	80071c2 <EXTI_Init+0xfa>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8007188:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800718c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007190:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8007194:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8007198:	6892      	ldr	r2, [r2, #8]
 800719a:	4611      	mov	r1, r2
 800719c:	687a      	ldr	r2, [r7, #4]
 800719e:	6812      	ldr	r2, [r2, #0]
 80071a0:	430a      	orrs	r2, r1
 80071a2:	609a      	str	r2, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 80071a4:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80071a8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80071ac:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 80071b0:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80071b4:	68d2      	ldr	r2, [r2, #12]
 80071b6:	4611      	mov	r1, r2
 80071b8:	687a      	ldr	r2, [r7, #4]
 80071ba:	6812      	ldr	r2, [r2, #0]
 80071bc:	430a      	orrs	r2, r1
 80071be:	60da      	str	r2, [r3, #12]
 80071c0:	e01f      	b.n	8007202 <EXTI_Init+0x13a>
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
 80071c2:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80071c6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80071ca:	60fb      	str	r3, [r7, #12]
      tmp += EXTI_InitStruct->EXTI_Trigger;
 80071cc:	687b      	ldr	r3, [r7, #4]
 80071ce:	795b      	ldrb	r3, [r3, #5]
 80071d0:	68fa      	ldr	r2, [r7, #12]
 80071d2:	18d3      	adds	r3, r2, r3
 80071d4:	60fb      	str	r3, [r7, #12]

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80071d6:	68fb      	ldr	r3, [r7, #12]
 80071d8:	68fa      	ldr	r2, [r7, #12]
 80071da:	6811      	ldr	r1, [r2, #0]
 80071dc:	687a      	ldr	r2, [r7, #4]
 80071de:	6812      	ldr	r2, [r2, #0]
 80071e0:	430a      	orrs	r2, r1
 80071e2:	601a      	str	r2, [r3, #0]
 80071e4:	e00d      	b.n	8007202 <EXTI_Init+0x13a>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80071e6:	687b      	ldr	r3, [r7, #4]
 80071e8:	791b      	ldrb	r3, [r3, #4]
 80071ea:	68fa      	ldr	r2, [r7, #12]
 80071ec:	18d3      	adds	r3, r2, r3
 80071ee:	60fb      	str	r3, [r7, #12]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80071f0:	68fb      	ldr	r3, [r7, #12]
 80071f2:	68fa      	ldr	r2, [r7, #12]
 80071f4:	6811      	ldr	r1, [r2, #0]
 80071f6:	687a      	ldr	r2, [r7, #4]
 80071f8:	6812      	ldr	r2, [r2, #0]
 80071fa:	ea6f 0202 	mvn.w	r2, r2
 80071fe:	400a      	ands	r2, r1
 8007200:	601a      	str	r2, [r3, #0]
  }
}
 8007202:	f107 0714 	add.w	r7, r7, #20
 8007206:	46bd      	mov	sp, r7
 8007208:	bc80      	pop	{r7}
 800720a:	4770      	bx	lr

0800720c <EXTI_StructInit>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
 800720c:	b480      	push	{r7}
 800720e:	b083      	sub	sp, #12
 8007210:	af00      	add	r7, sp, #0
 8007212:	6078      	str	r0, [r7, #4]
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8007214:	687b      	ldr	r3, [r7, #4]
 8007216:	f04f 0200 	mov.w	r2, #0
 800721a:	601a      	str	r2, [r3, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 800721c:	687b      	ldr	r3, [r7, #4]
 800721e:	f04f 0200 	mov.w	r2, #0
 8007222:	711a      	strb	r2, [r3, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8007224:	687b      	ldr	r3, [r7, #4]
 8007226:	f04f 020c 	mov.w	r2, #12
 800722a:	715a      	strb	r2, [r3, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 800722c:	687b      	ldr	r3, [r7, #4]
 800722e:	f04f 0200 	mov.w	r2, #0
 8007232:	719a      	strb	r2, [r3, #6]
}
 8007234:	f107 070c 	add.w	r7, r7, #12
 8007238:	46bd      	mov	sp, r7
 800723a:	bc80      	pop	{r7}
 800723c:	4770      	bx	lr
 800723e:	bf00      	nop

08007240 <EXTI_GenerateSWInterrupt>:
  *         will be generated.
  *         This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
 8007240:	b480      	push	{r7}
 8007242:	b083      	sub	sp, #12
 8007244:	af00      	add	r7, sp, #0
 8007246:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 8007248:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800724c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007250:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8007254:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8007258:	6912      	ldr	r2, [r2, #16]
 800725a:	4611      	mov	r1, r2
 800725c:	687a      	ldr	r2, [r7, #4]
 800725e:	430a      	orrs	r2, r1
 8007260:	611a      	str	r2, [r3, #16]
}
 8007262:	f107 070c 	add.w	r7, r7, #12
 8007266:	46bd      	mov	sp, r7
 8007268:	bc80      	pop	{r7}
 800726a:	4770      	bx	lr

0800726c <EXTI_GetFlagStatus>:
  * @param  EXTI_Line: specifies the EXTI line flag to check.
  *          This parameter can be EXTI_Linex where x can be(0..22)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)
{
 800726c:	b480      	push	{r7}
 800726e:	b085      	sub	sp, #20
 8007270:	af00      	add	r7, sp, #0
 8007272:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8007274:	f04f 0300 	mov.w	r3, #0
 8007278:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 800727a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800727e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007282:	695b      	ldr	r3, [r3, #20]
 8007284:	461a      	mov	r2, r3
 8007286:	687b      	ldr	r3, [r7, #4]
 8007288:	4013      	ands	r3, r2
 800728a:	2b00      	cmp	r3, #0
 800728c:	d003      	beq.n	8007296 <EXTI_GetFlagStatus+0x2a>
  {
    bitstatus = SET;
 800728e:	f04f 0301 	mov.w	r3, #1
 8007292:	73fb      	strb	r3, [r7, #15]
 8007294:	e002      	b.n	800729c <EXTI_GetFlagStatus+0x30>
  }
  else
  {
    bitstatus = RESET;
 8007296:	f04f 0300 	mov.w	r3, #0
 800729a:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800729c:	7bfb      	ldrb	r3, [r7, #15]
}
 800729e:	4618      	mov	r0, r3
 80072a0:	f107 0714 	add.w	r7, r7, #20
 80072a4:	46bd      	mov	sp, r7
 80072a6:	bc80      	pop	{r7}
 80072a8:	4770      	bx	lr
 80072aa:	bf00      	nop

080072ac <EXTI_ClearFlag>:
  * @param  EXTI_Line: specifies the EXTI lines flags to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
 80072ac:	b480      	push	{r7}
 80072ae:	b083      	sub	sp, #12
 80072b0:	af00      	add	r7, sp, #0
 80072b2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 80072b4:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80072b8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80072bc:	687a      	ldr	r2, [r7, #4]
 80072be:	615a      	str	r2, [r3, #20]
}
 80072c0:	f107 070c 	add.w	r7, r7, #12
 80072c4:	46bd      	mov	sp, r7
 80072c6:	bc80      	pop	{r7}
 80072c8:	4770      	bx	lr
 80072ca:	bf00      	nop

080072cc <EXTI_GetITStatus>:
  * @param  EXTI_Line: specifies the EXTI line to check.
  *          This parameter can be EXTI_Linex where x can be(0..22)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
{
 80072cc:	b480      	push	{r7}
 80072ce:	b085      	sub	sp, #20
 80072d0:	af00      	add	r7, sp, #0
 80072d2:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 80072d4:	f04f 0300 	mov.w	r3, #0
 80072d8:	73fb      	strb	r3, [r7, #15]
  uint32_t enablestatus = 0;
 80072da:	f04f 0300 	mov.w	r3, #0
 80072de:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 80072e0:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80072e4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80072e8:	681b      	ldr	r3, [r3, #0]
 80072ea:	461a      	mov	r2, r3
 80072ec:	687b      	ldr	r3, [r7, #4]
 80072ee:	4013      	ands	r3, r2
 80072f0:	60bb      	str	r3, [r7, #8]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 80072f2:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80072f6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80072fa:	695b      	ldr	r3, [r3, #20]
 80072fc:	461a      	mov	r2, r3
 80072fe:	687b      	ldr	r3, [r7, #4]
 8007300:	4013      	ands	r3, r2
 8007302:	2b00      	cmp	r3, #0
 8007304:	d006      	beq.n	8007314 <EXTI_GetITStatus+0x48>
 8007306:	68bb      	ldr	r3, [r7, #8]
 8007308:	2b00      	cmp	r3, #0
 800730a:	d003      	beq.n	8007314 <EXTI_GetITStatus+0x48>
  {
    bitstatus = SET;
 800730c:	f04f 0301 	mov.w	r3, #1
 8007310:	73fb      	strb	r3, [r7, #15]
 8007312:	e002      	b.n	800731a <EXTI_GetITStatus+0x4e>
  }
  else
  {
    bitstatus = RESET;
 8007314:	f04f 0300 	mov.w	r3, #0
 8007318:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800731a:	7bfb      	ldrb	r3, [r7, #15]
}
 800731c:	4618      	mov	r0, r3
 800731e:	f107 0714 	add.w	r7, r7, #20
 8007322:	46bd      	mov	sp, r7
 8007324:	bc80      	pop	{r7}
 8007326:	4770      	bx	lr

08007328 <EXTI_ClearITPendingBit>:
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
 8007328:	b480      	push	{r7}
 800732a:	b083      	sub	sp, #12
 800732c:	af00      	add	r7, sp, #0
 800732e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8007330:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8007334:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007338:	687a      	ldr	r2, [r7, #4]
 800733a:	615a      	str	r2, [r3, #20]
}
 800733c:	f107 070c 	add.w	r7, r7, #12
 8007340:	46bd      	mov	sp, r7
 8007342:	bc80      	pop	{r7}
 8007344:	4770      	bx	lr
 8007346:	bf00      	nop

08007348 <GPIO_DeInit>:
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8007348:	b580      	push	{r7, lr}
 800734a:	b082      	sub	sp, #8
 800734c:	af00      	add	r7, sp, #0
 800734e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8007350:	687a      	ldr	r2, [r7, #4]
 8007352:	f04f 0300 	mov.w	r3, #0
 8007356:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800735a:	429a      	cmp	r2, r3
 800735c:	d10c      	bne.n	8007378 <GPIO_DeInit+0x30>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 800735e:	f04f 0001 	mov.w	r0, #1
 8007362:	f04f 0101 	mov.w	r1, #1
 8007366:	f001 fd5d 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 800736a:	f04f 0001 	mov.w	r0, #1
 800736e:	f04f 0100 	mov.w	r1, #0
 8007372:	f001 fd57 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
 8007376:	e09e      	b.n	80074b6 <GPIO_DeInit+0x16e>
  }
  else if (GPIOx == GPIOB)
 8007378:	687a      	ldr	r2, [r7, #4]
 800737a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800737e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007382:	429a      	cmp	r2, r3
 8007384:	d10c      	bne.n	80073a0 <GPIO_DeInit+0x58>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8007386:	f04f 0002 	mov.w	r0, #2
 800738a:	f04f 0101 	mov.w	r1, #1
 800738e:	f001 fd49 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 8007392:	f04f 0002 	mov.w	r0, #2
 8007396:	f04f 0100 	mov.w	r1, #0
 800739a:	f001 fd43 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
 800739e:	e08a      	b.n	80074b6 <GPIO_DeInit+0x16e>
  }
  else if (GPIOx == GPIOC)
 80073a0:	687a      	ldr	r2, [r7, #4]
 80073a2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80073a6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80073aa:	429a      	cmp	r2, r3
 80073ac:	d10c      	bne.n	80073c8 <GPIO_DeInit+0x80>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 80073ae:	f04f 0004 	mov.w	r0, #4
 80073b2:	f04f 0101 	mov.w	r1, #1
 80073b6:	f001 fd35 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 80073ba:	f04f 0004 	mov.w	r0, #4
 80073be:	f04f 0100 	mov.w	r1, #0
 80073c2:	f001 fd2f 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
 80073c6:	e076      	b.n	80074b6 <GPIO_DeInit+0x16e>
  }
  else if (GPIOx == GPIOD)
 80073c8:	687a      	ldr	r2, [r7, #4]
 80073ca:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80073ce:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80073d2:	429a      	cmp	r2, r3
 80073d4:	d10c      	bne.n	80073f0 <GPIO_DeInit+0xa8>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 80073d6:	f04f 0008 	mov.w	r0, #8
 80073da:	f04f 0101 	mov.w	r1, #1
 80073de:	f001 fd21 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 80073e2:	f04f 0008 	mov.w	r0, #8
 80073e6:	f04f 0100 	mov.w	r1, #0
 80073ea:	f001 fd1b 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
 80073ee:	e062      	b.n	80074b6 <GPIO_DeInit+0x16e>
  }
  else if (GPIOx == GPIOE)
 80073f0:	687a      	ldr	r2, [r7, #4]
 80073f2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80073f6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80073fa:	429a      	cmp	r2, r3
 80073fc:	d10c      	bne.n	8007418 <GPIO_DeInit+0xd0>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 80073fe:	f04f 0010 	mov.w	r0, #16
 8007402:	f04f 0101 	mov.w	r1, #1
 8007406:	f001 fd0d 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 800740a:	f04f 0010 	mov.w	r0, #16
 800740e:	f04f 0100 	mov.w	r1, #0
 8007412:	f001 fd07 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
 8007416:	e04e      	b.n	80074b6 <GPIO_DeInit+0x16e>
  }
  else if (GPIOx == GPIOF)
 8007418:	687a      	ldr	r2, [r7, #4]
 800741a:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800741e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007422:	429a      	cmp	r2, r3
 8007424:	d10c      	bne.n	8007440 <GPIO_DeInit+0xf8>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 8007426:	f04f 0020 	mov.w	r0, #32
 800742a:	f04f 0101 	mov.w	r1, #1
 800742e:	f001 fcf9 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 8007432:	f04f 0020 	mov.w	r0, #32
 8007436:	f04f 0100 	mov.w	r1, #0
 800743a:	f001 fcf3 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
 800743e:	e03a      	b.n	80074b6 <GPIO_DeInit+0x16e>
  }
  else if (GPIOx == GPIOG)
 8007440:	687a      	ldr	r2, [r7, #4]
 8007442:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8007446:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800744a:	429a      	cmp	r2, r3
 800744c:	d10c      	bne.n	8007468 <GPIO_DeInit+0x120>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 800744e:	f04f 0040 	mov.w	r0, #64	; 0x40
 8007452:	f04f 0101 	mov.w	r1, #1
 8007456:	f001 fce5 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 800745a:	f04f 0040 	mov.w	r0, #64	; 0x40
 800745e:	f04f 0100 	mov.w	r1, #0
 8007462:	f001 fcdf 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
 8007466:	e026      	b.n	80074b6 <GPIO_DeInit+0x16e>
  }
  else if (GPIOx == GPIOH)
 8007468:	687a      	ldr	r2, [r7, #4]
 800746a:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800746e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007472:	429a      	cmp	r2, r3
 8007474:	d10c      	bne.n	8007490 <GPIO_DeInit+0x148>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 8007476:	f04f 0080 	mov.w	r0, #128	; 0x80
 800747a:	f04f 0101 	mov.w	r1, #1
 800747e:	f001 fcd1 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 8007482:	f04f 0080 	mov.w	r0, #128	; 0x80
 8007486:	f04f 0100 	mov.w	r1, #0
 800748a:	f001 fccb 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
 800748e:	e012      	b.n	80074b6 <GPIO_DeInit+0x16e>
  }
  else
  {
    if (GPIOx == GPIOI)
 8007490:	687a      	ldr	r2, [r7, #4]
 8007492:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8007496:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800749a:	429a      	cmp	r2, r3
 800749c:	d10b      	bne.n	80074b6 <GPIO_DeInit+0x16e>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 800749e:	f44f 7080 	mov.w	r0, #256	; 0x100
 80074a2:	f04f 0101 	mov.w	r1, #1
 80074a6:	f001 fcbd 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80074aa:	f44f 7080 	mov.w	r0, #256	; 0x100
 80074ae:	f04f 0100 	mov.w	r1, #0
 80074b2:	f001 fcb7 	bl	8008e24 <RCC_AHB1PeriphResetCmd>
    }
  }
}
 80074b6:	f107 0708 	add.w	r7, r7, #8
 80074ba:	46bd      	mov	sp, r7
 80074bc:	bd80      	pop	{r7, pc}
 80074be:	bf00      	nop

080074c0 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80074c0:	b480      	push	{r7}
 80074c2:	b087      	sub	sp, #28
 80074c4:	af00      	add	r7, sp, #0
 80074c6:	6078      	str	r0, [r7, #4]
 80074c8:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 80074ca:	f04f 0300 	mov.w	r3, #0
 80074ce:	617b      	str	r3, [r7, #20]
 80074d0:	f04f 0300 	mov.w	r3, #0
 80074d4:	613b      	str	r3, [r7, #16]
 80074d6:	f04f 0300 	mov.w	r3, #0
 80074da:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80074dc:	f04f 0300 	mov.w	r3, #0
 80074e0:	617b      	str	r3, [r7, #20]
 80074e2:	e08e      	b.n	8007602 <GPIO_Init+0x142>
  {
    pos = ((uint32_t)0x01) << pinpos;
 80074e4:	697b      	ldr	r3, [r7, #20]
 80074e6:	f04f 0201 	mov.w	r2, #1
 80074ea:	fa02 f303 	lsl.w	r3, r2, r3
 80074ee:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80074f0:	683b      	ldr	r3, [r7, #0]
 80074f2:	681a      	ldr	r2, [r3, #0]
 80074f4:	693b      	ldr	r3, [r7, #16]
 80074f6:	4013      	ands	r3, r2
 80074f8:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 80074fa:	68fa      	ldr	r2, [r7, #12]
 80074fc:	693b      	ldr	r3, [r7, #16]
 80074fe:	429a      	cmp	r2, r3
 8007500:	d17b      	bne.n	80075fa <GPIO_Init+0x13a>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8007502:	687b      	ldr	r3, [r7, #4]
 8007504:	681b      	ldr	r3, [r3, #0]
 8007506:	461a      	mov	r2, r3
 8007508:	697b      	ldr	r3, [r7, #20]
 800750a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800750e:	f04f 0103 	mov.w	r1, #3
 8007512:	fa01 f303 	lsl.w	r3, r1, r3
 8007516:	ea6f 0303 	mvn.w	r3, r3
 800751a:	401a      	ands	r2, r3
 800751c:	687b      	ldr	r3, [r7, #4]
 800751e:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8007520:	687b      	ldr	r3, [r7, #4]
 8007522:	681b      	ldr	r3, [r3, #0]
 8007524:	461a      	mov	r2, r3
 8007526:	683b      	ldr	r3, [r7, #0]
 8007528:	791b      	ldrb	r3, [r3, #4]
 800752a:	4619      	mov	r1, r3
 800752c:	697b      	ldr	r3, [r7, #20]
 800752e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8007532:	fa01 f303 	lsl.w	r3, r1, r3
 8007536:	431a      	orrs	r2, r3
 8007538:	687b      	ldr	r3, [r7, #4]
 800753a:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800753c:	683b      	ldr	r3, [r7, #0]
 800753e:	791b      	ldrb	r3, [r3, #4]
 8007540:	2b01      	cmp	r3, #1
 8007542:	d003      	beq.n	800754c <GPIO_Init+0x8c>
 8007544:	683b      	ldr	r3, [r7, #0]
 8007546:	791b      	ldrb	r3, [r3, #4]
 8007548:	2b02      	cmp	r3, #2
 800754a:	d138      	bne.n	80075be <GPIO_Init+0xfe>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800754c:	687b      	ldr	r3, [r7, #4]
 800754e:	689b      	ldr	r3, [r3, #8]
 8007550:	461a      	mov	r2, r3
 8007552:	697b      	ldr	r3, [r7, #20]
 8007554:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8007558:	f04f 0103 	mov.w	r1, #3
 800755c:	fa01 f303 	lsl.w	r3, r1, r3
 8007560:	ea6f 0303 	mvn.w	r3, r3
 8007564:	401a      	ands	r2, r3
 8007566:	687b      	ldr	r3, [r7, #4]
 8007568:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800756a:	687b      	ldr	r3, [r7, #4]
 800756c:	689b      	ldr	r3, [r3, #8]
 800756e:	461a      	mov	r2, r3
 8007570:	683b      	ldr	r3, [r7, #0]
 8007572:	795b      	ldrb	r3, [r3, #5]
 8007574:	4619      	mov	r1, r3
 8007576:	697b      	ldr	r3, [r7, #20]
 8007578:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800757c:	fa01 f303 	lsl.w	r3, r1, r3
 8007580:	431a      	orrs	r2, r3
 8007582:	687b      	ldr	r3, [r7, #4]
 8007584:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8007586:	687b      	ldr	r3, [r7, #4]
 8007588:	685b      	ldr	r3, [r3, #4]
 800758a:	461a      	mov	r2, r3
 800758c:	697b      	ldr	r3, [r7, #20]
 800758e:	b29b      	uxth	r3, r3
 8007590:	f04f 0101 	mov.w	r1, #1
 8007594:	fa01 f303 	lsl.w	r3, r1, r3
 8007598:	ea6f 0303 	mvn.w	r3, r3
 800759c:	401a      	ands	r2, r3
 800759e:	687b      	ldr	r3, [r7, #4]
 80075a0:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80075a2:	687b      	ldr	r3, [r7, #4]
 80075a4:	685b      	ldr	r3, [r3, #4]
 80075a6:	461a      	mov	r2, r3
 80075a8:	683b      	ldr	r3, [r7, #0]
 80075aa:	799b      	ldrb	r3, [r3, #6]
 80075ac:	4619      	mov	r1, r3
 80075ae:	697b      	ldr	r3, [r7, #20]
 80075b0:	b29b      	uxth	r3, r3
 80075b2:	fa01 f303 	lsl.w	r3, r1, r3
 80075b6:	b29b      	uxth	r3, r3
 80075b8:	431a      	orrs	r2, r3
 80075ba:	687b      	ldr	r3, [r7, #4]
 80075bc:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80075be:	687b      	ldr	r3, [r7, #4]
 80075c0:	68db      	ldr	r3, [r3, #12]
 80075c2:	461a      	mov	r2, r3
 80075c4:	697b      	ldr	r3, [r7, #20]
 80075c6:	b29b      	uxth	r3, r3
 80075c8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80075cc:	f04f 0103 	mov.w	r1, #3
 80075d0:	fa01 f303 	lsl.w	r3, r1, r3
 80075d4:	ea6f 0303 	mvn.w	r3, r3
 80075d8:	401a      	ands	r2, r3
 80075da:	687b      	ldr	r3, [r7, #4]
 80075dc:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80075de:	687b      	ldr	r3, [r7, #4]
 80075e0:	68db      	ldr	r3, [r3, #12]
 80075e2:	461a      	mov	r2, r3
 80075e4:	683b      	ldr	r3, [r7, #0]
 80075e6:	79db      	ldrb	r3, [r3, #7]
 80075e8:	4619      	mov	r1, r3
 80075ea:	697b      	ldr	r3, [r7, #20]
 80075ec:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80075f0:	fa01 f303 	lsl.w	r3, r1, r3
 80075f4:	431a      	orrs	r2, r3
 80075f6:	687b      	ldr	r3, [r7, #4]
 80075f8:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80075fa:	697b      	ldr	r3, [r7, #20]
 80075fc:	f103 0301 	add.w	r3, r3, #1
 8007600:	617b      	str	r3, [r7, #20]
 8007602:	697b      	ldr	r3, [r7, #20]
 8007604:	2b0f      	cmp	r3, #15
 8007606:	f67f af6d 	bls.w	80074e4 <GPIO_Init+0x24>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 800760a:	f107 071c 	add.w	r7, r7, #28
 800760e:	46bd      	mov	sp, r7
 8007610:	bc80      	pop	{r7}
 8007612:	4770      	bx	lr

08007614 <GPIO_StructInit>:
  * @brief  Fills each GPIO_InitStruct member with its default value.
  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
 8007614:	b480      	push	{r7}
 8007616:	b083      	sub	sp, #12
 8007618:	af00      	add	r7, sp, #0
 800761a:	6078      	str	r0, [r7, #4]
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800761c:	687b      	ldr	r3, [r7, #4]
 800761e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007622:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8007624:	687b      	ldr	r3, [r7, #4]
 8007626:	f04f 0200 	mov.w	r2, #0
 800762a:	711a      	strb	r2, [r3, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 800762c:	687b      	ldr	r3, [r7, #4]
 800762e:	f04f 0200 	mov.w	r2, #0
 8007632:	715a      	strb	r2, [r3, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 8007634:	687b      	ldr	r3, [r7, #4]
 8007636:	f04f 0200 	mov.w	r2, #0
 800763a:	719a      	strb	r2, [r3, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 800763c:	687b      	ldr	r3, [r7, #4]
 800763e:	f04f 0200 	mov.w	r2, #0
 8007642:	71da      	strb	r2, [r3, #7]
}
 8007644:	f107 070c 	add.w	r7, r7, #12
 8007648:	46bd      	mov	sp, r7
 800764a:	bc80      	pop	{r7}
 800764c:	4770      	bx	lr
 800764e:	bf00      	nop

08007650 <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8007650:	b480      	push	{r7}
 8007652:	b085      	sub	sp, #20
 8007654:	af00      	add	r7, sp, #0
 8007656:	6078      	str	r0, [r7, #4]
 8007658:	460b      	mov	r3, r1
 800765a:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = 0x00010000;
 800765c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8007660:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 8007662:	887a      	ldrh	r2, [r7, #2]
 8007664:	68fb      	ldr	r3, [r7, #12]
 8007666:	4313      	orrs	r3, r2
 8007668:	60fb      	str	r3, [r7, #12]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800766a:	68fa      	ldr	r2, [r7, #12]
 800766c:	687b      	ldr	r3, [r7, #4]
 800766e:	61da      	str	r2, [r3, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8007670:	887a      	ldrh	r2, [r7, #2]
 8007672:	687b      	ldr	r3, [r7, #4]
 8007674:	61da      	str	r2, [r3, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8007676:	68fa      	ldr	r2, [r7, #12]
 8007678:	687b      	ldr	r3, [r7, #4]
 800767a:	61da      	str	r2, [r3, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800767c:	687b      	ldr	r3, [r7, #4]
 800767e:	69db      	ldr	r3, [r3, #28]
 8007680:	60fb      	str	r3, [r7, #12]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8007682:	687b      	ldr	r3, [r7, #4]
 8007684:	69db      	ldr	r3, [r3, #28]
 8007686:	60fb      	str	r3, [r7, #12]
}
 8007688:	f107 0714 	add.w	r7, r7, #20
 800768c:	46bd      	mov	sp, r7
 800768e:	bc80      	pop	{r7}
 8007690:	4770      	bx	lr
 8007692:	bf00      	nop

08007694 <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8007694:	b480      	push	{r7}
 8007696:	b085      	sub	sp, #20
 8007698:	af00      	add	r7, sp, #0
 800769a:	6078      	str	r0, [r7, #4]
 800769c:	460b      	mov	r3, r1
 800769e:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 80076a0:	f04f 0300 	mov.w	r3, #0
 80076a4:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80076a6:	687b      	ldr	r3, [r7, #4]
 80076a8:	691b      	ldr	r3, [r3, #16]
 80076aa:	461a      	mov	r2, r3
 80076ac:	887b      	ldrh	r3, [r7, #2]
 80076ae:	4013      	ands	r3, r2
 80076b0:	2b00      	cmp	r3, #0
 80076b2:	d003      	beq.n	80076bc <GPIO_ReadInputDataBit+0x28>
  {
    bitstatus = (uint8_t)Bit_SET;
 80076b4:	f04f 0301 	mov.w	r3, #1
 80076b8:	73fb      	strb	r3, [r7, #15]
 80076ba:	e002      	b.n	80076c2 <GPIO_ReadInputDataBit+0x2e>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 80076bc:	f04f 0300 	mov.w	r3, #0
 80076c0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80076c2:	7bfb      	ldrb	r3, [r7, #15]
}
 80076c4:	4618      	mov	r0, r3
 80076c6:	f107 0714 	add.w	r7, r7, #20
 80076ca:	46bd      	mov	sp, r7
 80076cc:	bc80      	pop	{r7}
 80076ce:	4770      	bx	lr

080076d0 <GPIO_ReadInputData>:
  * @brief  Reads the specified GPIO input data port.
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval GPIO input data port value.
  */
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
 80076d0:	b480      	push	{r7}
 80076d2:	b083      	sub	sp, #12
 80076d4:	af00      	add	r7, sp, #0
 80076d6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 80076d8:	687b      	ldr	r3, [r7, #4]
 80076da:	691b      	ldr	r3, [r3, #16]
 80076dc:	b29b      	uxth	r3, r3
}
 80076de:	4618      	mov	r0, r3
 80076e0:	f107 070c 	add.w	r7, r7, #12
 80076e4:	46bd      	mov	sp, r7
 80076e6:	bc80      	pop	{r7}
 80076e8:	4770      	bx	lr
 80076ea:	bf00      	nop

080076ec <GPIO_ReadOutputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *          This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The output port pin value.
  */
uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80076ec:	b480      	push	{r7}
 80076ee:	b085      	sub	sp, #20
 80076f0:	af00      	add	r7, sp, #0
 80076f2:	6078      	str	r0, [r7, #4]
 80076f4:	460b      	mov	r3, r1
 80076f6:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 80076f8:	f04f 0300 	mov.w	r3, #0
 80076fc:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80076fe:	687b      	ldr	r3, [r7, #4]
 8007700:	695b      	ldr	r3, [r3, #20]
 8007702:	461a      	mov	r2, r3
 8007704:	887b      	ldrh	r3, [r7, #2]
 8007706:	4013      	ands	r3, r2
 8007708:	2b00      	cmp	r3, #0
 800770a:	d003      	beq.n	8007714 <GPIO_ReadOutputDataBit+0x28>
  {
    bitstatus = (uint8_t)Bit_SET;
 800770c:	f04f 0301 	mov.w	r3, #1
 8007710:	73fb      	strb	r3, [r7, #15]
 8007712:	e002      	b.n	800771a <GPIO_ReadOutputDataBit+0x2e>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 8007714:	f04f 0300 	mov.w	r3, #0
 8007718:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800771a:	7bfb      	ldrb	r3, [r7, #15]
}
 800771c:	4618      	mov	r0, r3
 800771e:	f107 0714 	add.w	r7, r7, #20
 8007722:	46bd      	mov	sp, r7
 8007724:	bc80      	pop	{r7}
 8007726:	4770      	bx	lr

08007728 <GPIO_ReadOutputData>:
  * @brief  Reads the specified GPIO output data port.
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval GPIO output data port value.
  */
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
 8007728:	b480      	push	{r7}
 800772a:	b083      	sub	sp, #12
 800772c:	af00      	add	r7, sp, #0
 800772e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 8007730:	687b      	ldr	r3, [r7, #4]
 8007732:	695b      	ldr	r3, [r3, #20]
 8007734:	b29b      	uxth	r3, r3
}
 8007736:	4618      	mov	r0, r3
 8007738:	f107 070c 	add.w	r7, r7, #12
 800773c:	46bd      	mov	sp, r7
 800773e:	bc80      	pop	{r7}
 8007740:	4770      	bx	lr
 8007742:	bf00      	nop

08007744 <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8007744:	b480      	push	{r7}
 8007746:	b083      	sub	sp, #12
 8007748:	af00      	add	r7, sp, #0
 800774a:	6078      	str	r0, [r7, #4]
 800774c:	460b      	mov	r3, r1
 800774e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 8007750:	687b      	ldr	r3, [r7, #4]
 8007752:	887a      	ldrh	r2, [r7, #2]
 8007754:	831a      	strh	r2, [r3, #24]
}
 8007756:	f107 070c 	add.w	r7, r7, #12
 800775a:	46bd      	mov	sp, r7
 800775c:	bc80      	pop	{r7}
 800775e:	4770      	bx	lr

08007760 <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8007760:	b480      	push	{r7}
 8007762:	b083      	sub	sp, #12
 8007764:	af00      	add	r7, sp, #0
 8007766:	6078      	str	r0, [r7, #4]
 8007768:	460b      	mov	r3, r1
 800776a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 800776c:	687b      	ldr	r3, [r7, #4]
 800776e:	887a      	ldrh	r2, [r7, #2]
 8007770:	835a      	strh	r2, [r3, #26]
}
 8007772:	f107 070c 	add.w	r7, r7, #12
 8007776:	46bd      	mov	sp, r7
 8007778:	bc80      	pop	{r7}
 800777a:	4770      	bx	lr

0800777c <GPIO_WriteBit>:
  *            @arg Bit_RESET: to clear the port pin
  *            @arg Bit_SET: to set the port pin
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 800777c:	b480      	push	{r7}
 800777e:	b083      	sub	sp, #12
 8007780:	af00      	add	r7, sp, #0
 8007782:	6078      	str	r0, [r7, #4]
 8007784:	4613      	mov	r3, r2
 8007786:	460a      	mov	r2, r1
 8007788:	807a      	strh	r2, [r7, #2]
 800778a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 800778c:	787b      	ldrb	r3, [r7, #1]
 800778e:	2b00      	cmp	r3, #0
 8007790:	d003      	beq.n	800779a <GPIO_WriteBit+0x1e>
  {
    GPIOx->BSRRL = GPIO_Pin;
 8007792:	687b      	ldr	r3, [r7, #4]
 8007794:	887a      	ldrh	r2, [r7, #2]
 8007796:	831a      	strh	r2, [r3, #24]
 8007798:	e002      	b.n	80077a0 <GPIO_WriteBit+0x24>
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 800779a:	687b      	ldr	r3, [r7, #4]
 800779c:	887a      	ldrh	r2, [r7, #2]
 800779e:	835a      	strh	r2, [r3, #26]
  }
}
 80077a0:	f107 070c 	add.w	r7, r7, #12
 80077a4:	46bd      	mov	sp, r7
 80077a6:	bc80      	pop	{r7}
 80077a8:	4770      	bx	lr
 80077aa:	bf00      	nop

080077ac <GPIO_Write>:
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @param  PortVal: specifies the value to be written to the port output data register.
  * @retval None
  */
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
 80077ac:	b480      	push	{r7}
 80077ae:	b083      	sub	sp, #12
 80077b0:	af00      	add	r7, sp, #0
 80077b2:	6078      	str	r0, [r7, #4]
 80077b4:	460b      	mov	r3, r1
 80077b6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 80077b8:	887a      	ldrh	r2, [r7, #2]
 80077ba:	687b      	ldr	r3, [r7, #4]
 80077bc:	615a      	str	r2, [r3, #20]
}
 80077be:	f107 070c 	add.w	r7, r7, #12
 80077c2:	46bd      	mov	sp, r7
 80077c4:	bc80      	pop	{r7}
 80077c6:	4770      	bx	lr

080077c8 <GPIO_ToggleBits>:
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80077c8:	b480      	push	{r7}
 80077ca:	b083      	sub	sp, #12
 80077cc:	af00      	add	r7, sp, #0
 80077ce:	6078      	str	r0, [r7, #4]
 80077d0:	460b      	mov	r3, r1
 80077d2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 80077d4:	687b      	ldr	r3, [r7, #4]
 80077d6:	695b      	ldr	r3, [r3, #20]
 80077d8:	461a      	mov	r2, r3
 80077da:	887b      	ldrh	r3, [r7, #2]
 80077dc:	405a      	eors	r2, r3
 80077de:	687b      	ldr	r3, [r7, #4]
 80077e0:	615a      	str	r2, [r3, #20]
}
 80077e2:	f107 070c 	add.w	r7, r7, #12
 80077e6:	46bd      	mov	sp, r7
 80077e8:	bc80      	pop	{r7}
 80077ea:	4770      	bx	lr

080077ec <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 80077ec:	b480      	push	{r7}
 80077ee:	b085      	sub	sp, #20
 80077f0:	af00      	add	r7, sp, #0
 80077f2:	6078      	str	r0, [r7, #4]
 80077f4:	4613      	mov	r3, r2
 80077f6:	460a      	mov	r2, r1
 80077f8:	807a      	strh	r2, [r7, #2]
 80077fa:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 80077fc:	f04f 0300 	mov.w	r3, #0
 8007800:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 8007802:	f04f 0300 	mov.w	r3, #0
 8007806:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8007808:	787a      	ldrb	r2, [r7, #1]
 800780a:	887b      	ldrh	r3, [r7, #2]
 800780c:	f003 0307 	and.w	r3, r3, #7
 8007810:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007814:	fa02 f303 	lsl.w	r3, r2, r3
 8007818:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800781a:	887b      	ldrh	r3, [r7, #2]
 800781c:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8007820:	b29b      	uxth	r3, r3
 8007822:	461a      	mov	r2, r3
 8007824:	887b      	ldrh	r3, [r7, #2]
 8007826:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800782a:	b29b      	uxth	r3, r3
 800782c:	4619      	mov	r1, r3
 800782e:	687b      	ldr	r3, [r7, #4]
 8007830:	f101 0108 	add.w	r1, r1, #8
 8007834:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8007838:	4619      	mov	r1, r3
 800783a:	887b      	ldrh	r3, [r7, #2]
 800783c:	f003 0307 	and.w	r3, r3, #7
 8007840:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007844:	f04f 000f 	mov.w	r0, #15
 8007848:	fa00 f303 	lsl.w	r3, r0, r3
 800784c:	ea6f 0303 	mvn.w	r3, r3
 8007850:	4019      	ands	r1, r3
 8007852:	687b      	ldr	r3, [r7, #4]
 8007854:	f102 0208 	add.w	r2, r2, #8
 8007858:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 800785c:	887b      	ldrh	r3, [r7, #2]
 800785e:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8007862:	b29b      	uxth	r3, r3
 8007864:	461a      	mov	r2, r3
 8007866:	687b      	ldr	r3, [r7, #4]
 8007868:	f102 0208 	add.w	r2, r2, #8
 800786c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007870:	461a      	mov	r2, r3
 8007872:	68fb      	ldr	r3, [r7, #12]
 8007874:	4313      	orrs	r3, r2
 8007876:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8007878:	887b      	ldrh	r3, [r7, #2]
 800787a:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800787e:	b29b      	uxth	r3, r3
 8007880:	461a      	mov	r2, r3
 8007882:	687b      	ldr	r3, [r7, #4]
 8007884:	f102 0208 	add.w	r2, r2, #8
 8007888:	68b9      	ldr	r1, [r7, #8]
 800788a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 800788e:	f107 0714 	add.w	r7, r7, #20
 8007892:	46bd      	mov	sp, r7
 8007894:	bc80      	pop	{r7}
 8007896:	4770      	bx	lr

08007898 <I2C_DeInit>:
  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 8007898:	b580      	push	{r7, lr}
 800789a:	b082      	sub	sp, #8
 800789c:	af00      	add	r7, sp, #0
 800789e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 80078a0:	687a      	ldr	r2, [r7, #4]
 80078a2:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
 80078a6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80078aa:	429a      	cmp	r2, r3
 80078ac:	d10c      	bne.n	80078c8 <I2C_DeInit+0x30>
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 80078ae:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80078b2:	f04f 0101 	mov.w	r1, #1
 80078b6:	f001 fb39 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
 80078ba:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80078be:	f04f 0100 	mov.w	r1, #0
 80078c2:	f001 fb33 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 80078c6:	e026      	b.n	8007916 <I2C_DeInit+0x7e>
  }
  else if (I2Cx == I2C2)
 80078c8:	687a      	ldr	r2, [r7, #4]
 80078ca:	f44f 43b0 	mov.w	r3, #22528	; 0x5800
 80078ce:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80078d2:	429a      	cmp	r2, r3
 80078d4:	d10c      	bne.n	80078f0 <I2C_DeInit+0x58>
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 80078d6:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80078da:	f04f 0101 	mov.w	r1, #1
 80078de:	f001 fb25 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
 80078e2:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80078e6:	f04f 0100 	mov.w	r1, #0
 80078ea:	f001 fb1f 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 80078ee:	e012      	b.n	8007916 <I2C_DeInit+0x7e>
  }
  else 
  {
    if (I2Cx == I2C3)
 80078f0:	687a      	ldr	r2, [r7, #4]
 80078f2:	f44f 43b8 	mov.w	r3, #23552	; 0x5c00
 80078f6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80078fa:	429a      	cmp	r2, r3
 80078fc:	d10b      	bne.n	8007916 <I2C_DeInit+0x7e>
    {
      /* Enable I2C3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
 80078fe:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8007902:	f04f 0101 	mov.w	r1, #1
 8007906:	f001 fb11 	bl	8008f2c <RCC_APB1PeriphResetCmd>
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 800790a:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 800790e:	f04f 0100 	mov.w	r1, #0
 8007912:	f001 fb0b 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    }
  }
}
 8007916:	f107 0708 	add.w	r7, r7, #8
 800791a:	46bd      	mov	sp, r7
 800791c:	bd80      	pop	{r7, pc}
 800791e:	bf00      	nop

08007920 <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 8007920:	b580      	push	{r7, lr}
 8007922:	b08a      	sub	sp, #40	; 0x28
 8007924:	af00      	add	r7, sp, #0
 8007926:	6078      	str	r0, [r7, #4]
 8007928:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0, freqrange = 0;
 800792a:	f04f 0300 	mov.w	r3, #0
 800792e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8007930:	f04f 0300 	mov.w	r3, #0
 8007934:	847b      	strh	r3, [r7, #34]	; 0x22
  uint16_t result = 0x04;
 8007936:	f04f 0304 	mov.w	r3, #4
 800793a:	84bb      	strh	r3, [r7, #36]	; 0x24
  uint32_t pclk1 = 8000000;
 800793c:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8007940:	f2c0 037a 	movt	r3, #122	; 0x7a
 8007944:	61fb      	str	r3, [r7, #28]
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 8007946:	687b      	ldr	r3, [r7, #4]
 8007948:	889b      	ldrh	r3, [r3, #4]
 800794a:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 800794c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800794e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8007952:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8007954:	f107 030c 	add.w	r3, r7, #12
 8007958:	4618      	mov	r0, r3
 800795a:	f001 f833 	bl	80089c4 <RCC_GetClocksFreq>
  pclk1 = rcc_clocks.PCLK1_Frequency;
 800795e:	697b      	ldr	r3, [r7, #20]
 8007960:	61fb      	str	r3, [r7, #28]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8007962:	69fa      	ldr	r2, [r7, #28]
 8007964:	f64d 6383 	movw	r3, #56963	; 0xde83
 8007968:	f2c4 331b 	movt	r3, #17179	; 0x431b
 800796c:	fba3 1302 	umull	r1, r3, r3, r2
 8007970:	ea4f 4393 	mov.w	r3, r3, lsr #18
 8007974:	847b      	strh	r3, [r7, #34]	; 0x22
  tmpreg |= freqrange;
 8007976:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8007978:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800797a:	4313      	orrs	r3, r2
 800797c:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 800797e:	687b      	ldr	r3, [r7, #4]
 8007980:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8007982:	809a      	strh	r2, [r3, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 8007984:	687b      	ldr	r3, [r7, #4]
 8007986:	881b      	ldrh	r3, [r3, #0]
 8007988:	b29b      	uxth	r3, r3
 800798a:	f023 0301 	bic.w	r3, r3, #1
 800798e:	b29a      	uxth	r2, r3
 8007990:	687b      	ldr	r3, [r7, #4]
 8007992:	801a      	strh	r2, [r3, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;
 8007994:	f04f 0300 	mov.w	r3, #0
 8007998:	84fb      	strh	r3, [r7, #38]	; 0x26

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 800799a:	683b      	ldr	r3, [r7, #0]
 800799c:	681a      	ldr	r2, [r3, #0]
 800799e:	f248 63a0 	movw	r3, #34464	; 0x86a0
 80079a2:	f2c0 0301 	movt	r3, #1
 80079a6:	429a      	cmp	r2, r3
 80079a8:	d818      	bhi.n	80079dc <I2C_Init+0xbc>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 80079aa:	683b      	ldr	r3, [r7, #0]
 80079ac:	681b      	ldr	r3, [r3, #0]
 80079ae:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80079b2:	69fa      	ldr	r2, [r7, #28]
 80079b4:	fbb2 f3f3 	udiv	r3, r2, r3
 80079b8:	84bb      	strh	r3, [r7, #36]	; 0x24
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
 80079ba:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80079bc:	2b03      	cmp	r3, #3
 80079be:	d802      	bhi.n	80079c6 <I2C_Init+0xa6>
    {
      /* Set minimum allowed value */
      result = 0x04;  
 80079c0:	f04f 0304 	mov.w	r3, #4
 80079c4:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
 80079c6:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80079c8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80079ca:	4313      	orrs	r3, r2
 80079cc:	84fb      	strh	r3, [r7, #38]	; 0x26
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 80079ce:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80079d0:	f103 0301 	add.w	r3, r3, #1
 80079d4:	b29a      	uxth	r2, r3
 80079d6:	687b      	ldr	r3, [r7, #4]
 80079d8:	841a      	strh	r2, [r3, #32]
 80079da:	e04b      	b.n	8007a74 <I2C_Init+0x154>
  /* Configure speed in fast mode */
  /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
     input clock) must be a multiple of 10 MHz */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 80079dc:	683b      	ldr	r3, [r7, #0]
 80079de:	88da      	ldrh	r2, [r3, #6]
 80079e0:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 80079e4:	429a      	cmp	r2, r3
 80079e6:	d10a      	bne.n	80079fe <I2C_Init+0xde>
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 80079e8:	683b      	ldr	r3, [r7, #0]
 80079ea:	681a      	ldr	r2, [r3, #0]
 80079ec:	4613      	mov	r3, r2
 80079ee:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80079f2:	189b      	adds	r3, r3, r2
 80079f4:	69fa      	ldr	r2, [r7, #28]
 80079f6:	fbb2 f3f3 	udiv	r3, r2, r3
 80079fa:	84bb      	strh	r3, [r7, #36]	; 0x24
 80079fc:	e010      	b.n	8007a20 <I2C_Init+0x100>
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 80079fe:	683b      	ldr	r3, [r7, #0]
 8007a00:	681a      	ldr	r2, [r3, #0]
 8007a02:	4613      	mov	r3, r2
 8007a04:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007a08:	189b      	adds	r3, r3, r2
 8007a0a:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8007a0e:	189b      	adds	r3, r3, r2
 8007a10:	69fa      	ldr	r2, [r7, #28]
 8007a12:	fbb2 f3f3 	udiv	r3, r2, r3
 8007a16:	84bb      	strh	r3, [r7, #36]	; 0x24
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
 8007a18:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8007a1a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8007a1e:	84bb      	strh	r3, [r7, #36]	; 0x24
    }

    /* Test if CCR value is under 0x1*/
    if ((result & I2C_CCR_CCR) == 0)
 8007a20:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8007a22:	ea4f 5303 	mov.w	r3, r3, lsl #20
 8007a26:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8007a2a:	2b00      	cmp	r3, #0
 8007a2c:	d103      	bne.n	8007a36 <I2C_Init+0x116>
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 8007a2e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8007a30:	f043 0301 	orr.w	r3, r3, #1
 8007a34:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
 8007a36:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8007a38:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8007a3a:	4313      	orrs	r3, r2
 8007a3c:	b29b      	uxth	r3, r3
 8007a3e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8007a42:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8007a46:	84fb      	strh	r3, [r7, #38]	; 0x26
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8007a48:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8007a4a:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8007a4e:	fb02 f203 	mul.w	r2, r2, r3
 8007a52:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 8007a56:	f2c1 0362 	movt	r3, #4194	; 0x1062
 8007a5a:	fb83 1302 	smull	r1, r3, r3, r2
 8007a5e:	ea4f 11a3 	mov.w	r1, r3, asr #6
 8007a62:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8007a66:	1acb      	subs	r3, r1, r3
 8007a68:	b29b      	uxth	r3, r3
 8007a6a:	f103 0301 	add.w	r3, r3, #1
 8007a6e:	b29a      	uxth	r2, r3
 8007a70:	687b      	ldr	r3, [r7, #4]
 8007a72:	841a      	strh	r2, [r3, #32]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 8007a74:	687b      	ldr	r3, [r7, #4]
 8007a76:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8007a78:	839a      	strh	r2, [r3, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8007a7a:	687b      	ldr	r3, [r7, #4]
 8007a7c:	881b      	ldrh	r3, [r3, #0]
 8007a7e:	b29b      	uxth	r3, r3
 8007a80:	f043 0301 	orr.w	r3, r3, #1
 8007a84:	b29a      	uxth	r2, r3
 8007a86:	687b      	ldr	r3, [r7, #4]
 8007a88:	801a      	strh	r2, [r3, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 8007a8a:	687b      	ldr	r3, [r7, #4]
 8007a8c:	881b      	ldrh	r3, [r3, #0]
 8007a8e:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 8007a90:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8007a92:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8007a96:	f023 030a 	bic.w	r3, r3, #10
 8007a9a:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8007a9c:	683b      	ldr	r3, [r7, #0]
 8007a9e:	889a      	ldrh	r2, [r3, #4]
 8007aa0:	683b      	ldr	r3, [r7, #0]
 8007aa2:	895b      	ldrh	r3, [r3, #10]
 8007aa4:	4313      	orrs	r3, r2
 8007aa6:	b29a      	uxth	r2, r3
 8007aa8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8007aaa:	4313      	orrs	r3, r2
 8007aac:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 8007aae:	687b      	ldr	r3, [r7, #4]
 8007ab0:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8007ab2:	801a      	strh	r2, [r3, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8007ab4:	683b      	ldr	r3, [r7, #0]
 8007ab6:	899a      	ldrh	r2, [r3, #12]
 8007ab8:	683b      	ldr	r3, [r7, #0]
 8007aba:	891b      	ldrh	r3, [r3, #8]
 8007abc:	4313      	orrs	r3, r2
 8007abe:	b29a      	uxth	r2, r3
 8007ac0:	687b      	ldr	r3, [r7, #4]
 8007ac2:	811a      	strh	r2, [r3, #8]
}
 8007ac4:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8007ac8:	46bd      	mov	sp, r7
 8007aca:	bd80      	pop	{r7, pc}

08007acc <I2C_StructInit>:
  * @brief  Fills each I2C_InitStruct member with its default value.
  * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
  * @retval None
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
 8007acc:	b480      	push	{r7}
 8007ace:	b083      	sub	sp, #12
 8007ad0:	af00      	add	r7, sp, #0
 8007ad2:	6078      	str	r0, [r7, #4]
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
 8007ad4:	687b      	ldr	r3, [r7, #4]
 8007ad6:	f241 3288 	movw	r2, #5000	; 0x1388
 8007ada:	601a      	str	r2, [r3, #0]
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 8007adc:	687b      	ldr	r3, [r7, #4]
 8007ade:	f04f 0200 	mov.w	r2, #0
 8007ae2:	809a      	strh	r2, [r3, #4]
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 8007ae4:	687b      	ldr	r3, [r7, #4]
 8007ae6:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 8007aea:	80da      	strh	r2, [r3, #6]
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 8007aec:	687b      	ldr	r3, [r7, #4]
 8007aee:	f04f 0200 	mov.w	r2, #0
 8007af2:	811a      	strh	r2, [r3, #8]
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8007af4:	687b      	ldr	r3, [r7, #4]
 8007af6:	f04f 0200 	mov.w	r2, #0
 8007afa:	815a      	strh	r2, [r3, #10]
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8007afc:	687b      	ldr	r3, [r7, #4]
 8007afe:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8007b02:	819a      	strh	r2, [r3, #12]
}
 8007b04:	f107 070c 	add.w	r7, r7, #12
 8007b08:	46bd      	mov	sp, r7
 8007b0a:	bc80      	pop	{r7}
 8007b0c:	4770      	bx	lr
 8007b0e:	bf00      	nop

08007b10 <I2C_Cmd>:
  * @param  NewState: new state of the I2Cx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007b10:	b480      	push	{r7}
 8007b12:	b083      	sub	sp, #12
 8007b14:	af00      	add	r7, sp, #0
 8007b16:	6078      	str	r0, [r7, #4]
 8007b18:	460b      	mov	r3, r1
 8007b1a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007b1c:	78fb      	ldrb	r3, [r7, #3]
 8007b1e:	2b00      	cmp	r3, #0
 8007b20:	d008      	beq.n	8007b34 <I2C_Cmd+0x24>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8007b22:	687b      	ldr	r3, [r7, #4]
 8007b24:	881b      	ldrh	r3, [r3, #0]
 8007b26:	b29b      	uxth	r3, r3
 8007b28:	f043 0301 	orr.w	r3, r3, #1
 8007b2c:	b29a      	uxth	r2, r3
 8007b2e:	687b      	ldr	r3, [r7, #4]
 8007b30:	801a      	strh	r2, [r3, #0]
 8007b32:	e007      	b.n	8007b44 <I2C_Cmd+0x34>
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 8007b34:	687b      	ldr	r3, [r7, #4]
 8007b36:	881b      	ldrh	r3, [r3, #0]
 8007b38:	b29b      	uxth	r3, r3
 8007b3a:	f023 0301 	bic.w	r3, r3, #1
 8007b3e:	b29a      	uxth	r2, r3
 8007b40:	687b      	ldr	r3, [r7, #4]
 8007b42:	801a      	strh	r2, [r3, #0]
  }
}
 8007b44:	f107 070c 	add.w	r7, r7, #12
 8007b48:	46bd      	mov	sp, r7
 8007b4a:	bc80      	pop	{r7}
 8007b4c:	4770      	bx	lr
 8007b4e:	bf00      	nop

08007b50 <I2C_GenerateSTART>:
  * @param  NewState: new state of the I2C START condition generation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007b50:	b480      	push	{r7}
 8007b52:	b083      	sub	sp, #12
 8007b54:	af00      	add	r7, sp, #0
 8007b56:	6078      	str	r0, [r7, #4]
 8007b58:	460b      	mov	r3, r1
 8007b5a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007b5c:	78fb      	ldrb	r3, [r7, #3]
 8007b5e:	2b00      	cmp	r3, #0
 8007b60:	d008      	beq.n	8007b74 <I2C_GenerateSTART+0x24>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= I2C_CR1_START;
 8007b62:	687b      	ldr	r3, [r7, #4]
 8007b64:	881b      	ldrh	r3, [r3, #0]
 8007b66:	b29b      	uxth	r3, r3
 8007b68:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8007b6c:	b29a      	uxth	r2, r3
 8007b6e:	687b      	ldr	r3, [r7, #4]
 8007b70:	801a      	strh	r2, [r3, #0]
 8007b72:	e007      	b.n	8007b84 <I2C_GenerateSTART+0x34>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
 8007b74:	687b      	ldr	r3, [r7, #4]
 8007b76:	881b      	ldrh	r3, [r3, #0]
 8007b78:	b29b      	uxth	r3, r3
 8007b7a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007b7e:	b29a      	uxth	r2, r3
 8007b80:	687b      	ldr	r3, [r7, #4]
 8007b82:	801a      	strh	r2, [r3, #0]
  }
}
 8007b84:	f107 070c 	add.w	r7, r7, #12
 8007b88:	46bd      	mov	sp, r7
 8007b8a:	bc80      	pop	{r7}
 8007b8c:	4770      	bx	lr
 8007b8e:	bf00      	nop

08007b90 <I2C_GenerateSTOP>:
  * @param  NewState: new state of the I2C STOP condition generation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007b90:	b480      	push	{r7}
 8007b92:	b083      	sub	sp, #12
 8007b94:	af00      	add	r7, sp, #0
 8007b96:	6078      	str	r0, [r7, #4]
 8007b98:	460b      	mov	r3, r1
 8007b9a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007b9c:	78fb      	ldrb	r3, [r7, #3]
 8007b9e:	2b00      	cmp	r3, #0
 8007ba0:	d008      	beq.n	8007bb4 <I2C_GenerateSTOP+0x24>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
 8007ba2:	687b      	ldr	r3, [r7, #4]
 8007ba4:	881b      	ldrh	r3, [r3, #0]
 8007ba6:	b29b      	uxth	r3, r3
 8007ba8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8007bac:	b29a      	uxth	r2, r3
 8007bae:	687b      	ldr	r3, [r7, #4]
 8007bb0:	801a      	strh	r2, [r3, #0]
 8007bb2:	e007      	b.n	8007bc4 <I2C_GenerateSTOP+0x34>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
 8007bb4:	687b      	ldr	r3, [r7, #4]
 8007bb6:	881b      	ldrh	r3, [r3, #0]
 8007bb8:	b29b      	uxth	r3, r3
 8007bba:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007bbe:	b29a      	uxth	r2, r3
 8007bc0:	687b      	ldr	r3, [r7, #4]
 8007bc2:	801a      	strh	r2, [r3, #0]
  }
}
 8007bc4:	f107 070c 	add.w	r7, r7, #12
 8007bc8:	46bd      	mov	sp, r7
 8007bca:	bc80      	pop	{r7}
 8007bcc:	4770      	bx	lr
 8007bce:	bf00      	nop

08007bd0 <I2C_Send7bitAddress>:
  *            @arg I2C_Direction_Transmitter: Transmitter mode
  *            @arg I2C_Direction_Receiver: Receiver mode
  * @retval None.
  */
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
{
 8007bd0:	b480      	push	{r7}
 8007bd2:	b083      	sub	sp, #12
 8007bd4:	af00      	add	r7, sp, #0
 8007bd6:	6078      	str	r0, [r7, #4]
 8007bd8:	4613      	mov	r3, r2
 8007bda:	460a      	mov	r2, r1
 8007bdc:	70fa      	strb	r2, [r7, #3]
 8007bde:	70bb      	strb	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 8007be0:	78bb      	ldrb	r3, [r7, #2]
 8007be2:	2b00      	cmp	r3, #0
 8007be4:	d004      	beq.n	8007bf0 <I2C_Send7bitAddress+0x20>
  {
    /* Set the address bit0 for read */
    Address |= I2C_OAR1_ADD0;
 8007be6:	78fb      	ldrb	r3, [r7, #3]
 8007be8:	f043 0301 	orr.w	r3, r3, #1
 8007bec:	70fb      	strb	r3, [r7, #3]
 8007bee:	e003      	b.n	8007bf8 <I2C_Send7bitAddress+0x28>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
 8007bf0:	78fb      	ldrb	r3, [r7, #3]
 8007bf2:	f023 0301 	bic.w	r3, r3, #1
 8007bf6:	70fb      	strb	r3, [r7, #3]
  }
  /* Send the address */
  I2Cx->DR = Address;
 8007bf8:	78fb      	ldrb	r3, [r7, #3]
 8007bfa:	b29a      	uxth	r2, r3
 8007bfc:	687b      	ldr	r3, [r7, #4]
 8007bfe:	821a      	strh	r2, [r3, #16]
}
 8007c00:	f107 070c 	add.w	r7, r7, #12
 8007c04:	46bd      	mov	sp, r7
 8007c06:	bc80      	pop	{r7}
 8007c08:	4770      	bx	lr
 8007c0a:	bf00      	nop

08007c0c <I2C_AcknowledgeConfig>:
  * @param  NewState: new state of the I2C Acknowledgement.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007c0c:	b480      	push	{r7}
 8007c0e:	b083      	sub	sp, #12
 8007c10:	af00      	add	r7, sp, #0
 8007c12:	6078      	str	r0, [r7, #4]
 8007c14:	460b      	mov	r3, r1
 8007c16:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007c18:	78fb      	ldrb	r3, [r7, #3]
 8007c1a:	2b00      	cmp	r3, #0
 8007c1c:	d008      	beq.n	8007c30 <I2C_AcknowledgeConfig+0x24>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= I2C_CR1_ACK;
 8007c1e:	687b      	ldr	r3, [r7, #4]
 8007c20:	881b      	ldrh	r3, [r3, #0]
 8007c22:	b29b      	uxth	r3, r3
 8007c24:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8007c28:	b29a      	uxth	r2, r3
 8007c2a:	687b      	ldr	r3, [r7, #4]
 8007c2c:	801a      	strh	r2, [r3, #0]
 8007c2e:	e007      	b.n	8007c40 <I2C_AcknowledgeConfig+0x34>
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
 8007c30:	687b      	ldr	r3, [r7, #4]
 8007c32:	881b      	ldrh	r3, [r3, #0]
 8007c34:	b29b      	uxth	r3, r3
 8007c36:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8007c3a:	b29a      	uxth	r2, r3
 8007c3c:	687b      	ldr	r3, [r7, #4]
 8007c3e:	801a      	strh	r2, [r3, #0]
  }
}
 8007c40:	f107 070c 	add.w	r7, r7, #12
 8007c44:	46bd      	mov	sp, r7
 8007c46:	bc80      	pop	{r7}
 8007c48:	4770      	bx	lr
 8007c4a:	bf00      	nop

08007c4c <I2C_OwnAddress2Config>:
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @param  Address: specifies the 7bit I2C own address2.
  * @retval None.
  */
void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
{
 8007c4c:	b480      	push	{r7}
 8007c4e:	b085      	sub	sp, #20
 8007c50:	af00      	add	r7, sp, #0
 8007c52:	6078      	str	r0, [r7, #4]
 8007c54:	460b      	mov	r3, r1
 8007c56:	70fb      	strb	r3, [r7, #3]
  uint16_t tmpreg = 0;
 8007c58:	f04f 0300 	mov.w	r3, #0
 8007c5c:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 8007c5e:	687b      	ldr	r3, [r7, #4]
 8007c60:	899b      	ldrh	r3, [r3, #12]
 8007c62:	81fb      	strh	r3, [r7, #14]

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
 8007c64:	89fb      	ldrh	r3, [r7, #14]
 8007c66:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8007c6a:	81fb      	strh	r3, [r7, #14]

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 8007c6c:	78fb      	ldrb	r3, [r7, #3]
 8007c6e:	b29b      	uxth	r3, r3
 8007c70:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8007c74:	b29a      	uxth	r2, r3
 8007c76:	89fb      	ldrh	r3, [r7, #14]
 8007c78:	4313      	orrs	r3, r2
 8007c7a:	b29b      	uxth	r3, r3
 8007c7c:	81fb      	strh	r3, [r7, #14]

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 8007c7e:	687b      	ldr	r3, [r7, #4]
 8007c80:	89fa      	ldrh	r2, [r7, #14]
 8007c82:	819a      	strh	r2, [r3, #12]
}
 8007c84:	f107 0714 	add.w	r7, r7, #20
 8007c88:	46bd      	mov	sp, r7
 8007c8a:	bc80      	pop	{r7}
 8007c8c:	4770      	bx	lr
 8007c8e:	bf00      	nop

08007c90 <I2C_DualAddressCmd>:
  * @param  NewState: new state of the I2C dual addressing mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007c90:	b480      	push	{r7}
 8007c92:	b083      	sub	sp, #12
 8007c94:	af00      	add	r7, sp, #0
 8007c96:	6078      	str	r0, [r7, #4]
 8007c98:	460b      	mov	r3, r1
 8007c9a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007c9c:	78fb      	ldrb	r3, [r7, #3]
 8007c9e:	2b00      	cmp	r3, #0
 8007ca0:	d008      	beq.n	8007cb4 <I2C_DualAddressCmd+0x24>
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
 8007ca2:	687b      	ldr	r3, [r7, #4]
 8007ca4:	899b      	ldrh	r3, [r3, #12]
 8007ca6:	b29b      	uxth	r3, r3
 8007ca8:	f043 0301 	orr.w	r3, r3, #1
 8007cac:	b29a      	uxth	r2, r3
 8007cae:	687b      	ldr	r3, [r7, #4]
 8007cb0:	819a      	strh	r2, [r3, #12]
 8007cb2:	e007      	b.n	8007cc4 <I2C_DualAddressCmd+0x34>
  }
  else
  {
    /* Disable dual addressing mode */
    I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
 8007cb4:	687b      	ldr	r3, [r7, #4]
 8007cb6:	899b      	ldrh	r3, [r3, #12]
 8007cb8:	b29b      	uxth	r3, r3
 8007cba:	f023 0301 	bic.w	r3, r3, #1
 8007cbe:	b29a      	uxth	r2, r3
 8007cc0:	687b      	ldr	r3, [r7, #4]
 8007cc2:	819a      	strh	r2, [r3, #12]
  }
}
 8007cc4:	f107 070c 	add.w	r7, r7, #12
 8007cc8:	46bd      	mov	sp, r7
 8007cca:	bc80      	pop	{r7}
 8007ccc:	4770      	bx	lr
 8007cce:	bf00      	nop

08007cd0 <I2C_GeneralCallCmd>:
  * @param  NewState: new state of the I2C General call.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007cd0:	b480      	push	{r7}
 8007cd2:	b083      	sub	sp, #12
 8007cd4:	af00      	add	r7, sp, #0
 8007cd6:	6078      	str	r0, [r7, #4]
 8007cd8:	460b      	mov	r3, r1
 8007cda:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007cdc:	78fb      	ldrb	r3, [r7, #3]
 8007cde:	2b00      	cmp	r3, #0
 8007ce0:	d008      	beq.n	8007cf4 <I2C_GeneralCallCmd+0x24>
  {
    /* Enable generall call */
    I2Cx->CR1 |= I2C_CR1_ENGC;
 8007ce2:	687b      	ldr	r3, [r7, #4]
 8007ce4:	881b      	ldrh	r3, [r3, #0]
 8007ce6:	b29b      	uxth	r3, r3
 8007ce8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007cec:	b29a      	uxth	r2, r3
 8007cee:	687b      	ldr	r3, [r7, #4]
 8007cf0:	801a      	strh	r2, [r3, #0]
 8007cf2:	e007      	b.n	8007d04 <I2C_GeneralCallCmd+0x34>
  }
  else
  {
    /* Disable generall call */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
 8007cf4:	687b      	ldr	r3, [r7, #4]
 8007cf6:	881b      	ldrh	r3, [r3, #0]
 8007cf8:	b29b      	uxth	r3, r3
 8007cfa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8007cfe:	b29a      	uxth	r2, r3
 8007d00:	687b      	ldr	r3, [r7, #4]
 8007d02:	801a      	strh	r2, [r3, #0]
  }
}
 8007d04:	f107 070c 	add.w	r7, r7, #12
 8007d08:	46bd      	mov	sp, r7
 8007d0a:	bc80      	pop	{r7}
 8007d0c:	4770      	bx	lr
 8007d0e:	bf00      	nop

08007d10 <I2C_SoftwareResetCmd>:
  * @param  NewState: new state of the I2C software reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007d10:	b480      	push	{r7}
 8007d12:	b083      	sub	sp, #12
 8007d14:	af00      	add	r7, sp, #0
 8007d16:	6078      	str	r0, [r7, #4]
 8007d18:	460b      	mov	r3, r1
 8007d1a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007d1c:	78fb      	ldrb	r3, [r7, #3]
 8007d1e:	2b00      	cmp	r3, #0
 8007d20:	d00a      	beq.n	8007d38 <I2C_SoftwareResetCmd+0x28>
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= I2C_CR1_SWRST;
 8007d22:	687b      	ldr	r3, [r7, #4]
 8007d24:	881b      	ldrh	r3, [r3, #0]
 8007d26:	b29b      	uxth	r3, r3
 8007d28:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8007d2c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8007d30:	b29a      	uxth	r2, r3
 8007d32:	687b      	ldr	r3, [r7, #4]
 8007d34:	801a      	strh	r2, [r3, #0]
 8007d36:	e009      	b.n	8007d4c <I2C_SoftwareResetCmd+0x3c>
  }
  else
  {
    /* Peripheral not under reset */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
 8007d38:	687b      	ldr	r3, [r7, #4]
 8007d3a:	881b      	ldrh	r3, [r3, #0]
 8007d3c:	b29b      	uxth	r3, r3
 8007d3e:	ea4f 4343 	mov.w	r3, r3, lsl #17
 8007d42:	ea4f 4353 	mov.w	r3, r3, lsr #17
 8007d46:	b29a      	uxth	r2, r3
 8007d48:	687b      	ldr	r3, [r7, #4]
 8007d4a:	801a      	strh	r2, [r3, #0]
  }
}
 8007d4c:	f107 070c 	add.w	r7, r7, #12
 8007d50:	46bd      	mov	sp, r7
 8007d52:	bc80      	pop	{r7}
 8007d54:	4770      	bx	lr
 8007d56:	bf00      	nop

08007d58 <I2C_StretchClockCmd>:
  * @param  NewState: new state of the I2Cx Clock stretching.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007d58:	b480      	push	{r7}
 8007d5a:	b083      	sub	sp, #12
 8007d5c:	af00      	add	r7, sp, #0
 8007d5e:	6078      	str	r0, [r7, #4]
 8007d60:	460b      	mov	r3, r1
 8007d62:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
 8007d64:	78fb      	ldrb	r3, [r7, #3]
 8007d66:	2b00      	cmp	r3, #0
 8007d68:	d108      	bne.n	8007d7c <I2C_StretchClockCmd+0x24>
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 8007d6a:	687b      	ldr	r3, [r7, #4]
 8007d6c:	881b      	ldrh	r3, [r3, #0]
 8007d6e:	b29b      	uxth	r3, r3
 8007d70:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007d74:	b29a      	uxth	r2, r3
 8007d76:	687b      	ldr	r3, [r7, #4]
 8007d78:	801a      	strh	r2, [r3, #0]
 8007d7a:	e007      	b.n	8007d8c <I2C_StretchClockCmd+0x34>
  }
  else
  {
    /* Disable the selected I2C Clock stretching */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
 8007d7c:	687b      	ldr	r3, [r7, #4]
 8007d7e:	881b      	ldrh	r3, [r3, #0]
 8007d80:	b29b      	uxth	r3, r3
 8007d82:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8007d86:	b29a      	uxth	r2, r3
 8007d88:	687b      	ldr	r3, [r7, #4]
 8007d8a:	801a      	strh	r2, [r3, #0]
  }
}
 8007d8c:	f107 070c 	add.w	r7, r7, #12
 8007d90:	46bd      	mov	sp, r7
 8007d92:	bc80      	pop	{r7}
 8007d94:	4770      	bx	lr
 8007d96:	bf00      	nop

08007d98 <I2C_FastModeDutyCycleConfig>:
  *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
  *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
  * @retval None
  */
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
 8007d98:	b480      	push	{r7}
 8007d9a:	b083      	sub	sp, #12
 8007d9c:	af00      	add	r7, sp, #0
 8007d9e:	6078      	str	r0, [r7, #4]
 8007da0:	460b      	mov	r3, r1
 8007da2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 8007da4:	887b      	ldrh	r3, [r7, #2]
 8007da6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8007daa:	d008      	beq.n	8007dbe <I2C_FastModeDutyCycleConfig+0x26>
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 8007dac:	687b      	ldr	r3, [r7, #4]
 8007dae:	8b9b      	ldrh	r3, [r3, #28]
 8007db0:	b29b      	uxth	r3, r3
 8007db2:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8007db6:	b29a      	uxth	r2, r3
 8007db8:	687b      	ldr	r3, [r7, #4]
 8007dba:	839a      	strh	r2, [r3, #28]
 8007dbc:	e007      	b.n	8007dce <I2C_FastModeDutyCycleConfig+0x36>
  }
  else
  {
    /* I2C fast mode Tlow/Thigh=16/9 */
    I2Cx->CCR |= I2C_DutyCycle_16_9;
 8007dbe:	687b      	ldr	r3, [r7, #4]
 8007dc0:	8b9b      	ldrh	r3, [r3, #28]
 8007dc2:	b29b      	uxth	r3, r3
 8007dc4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8007dc8:	b29a      	uxth	r2, r3
 8007dca:	687b      	ldr	r3, [r7, #4]
 8007dcc:	839a      	strh	r2, [r3, #28]
  }
}
 8007dce:	f107 070c 	add.w	r7, r7, #12
 8007dd2:	46bd      	mov	sp, r7
 8007dd4:	bc80      	pop	{r7}
 8007dd6:	4770      	bx	lr

08007dd8 <I2C_NACKPositionConfig>:
  *          is intended to used in SMBUS mode. 
  *            
  * @retval None
  */
void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
{
 8007dd8:	b480      	push	{r7}
 8007dda:	b083      	sub	sp, #12
 8007ddc:	af00      	add	r7, sp, #0
 8007dde:	6078      	str	r0, [r7, #4]
 8007de0:	460b      	mov	r3, r1
 8007de2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
 8007de4:	887b      	ldrh	r3, [r7, #2]
 8007de6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8007dea:	d108      	bne.n	8007dfe <I2C_NACKPositionConfig+0x26>
  {
    /* Next byte in shift register is the last received byte */
    I2Cx->CR1 |= I2C_NACKPosition_Next;
 8007dec:	687b      	ldr	r3, [r7, #4]
 8007dee:	881b      	ldrh	r3, [r3, #0]
 8007df0:	b29b      	uxth	r3, r3
 8007df2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8007df6:	b29a      	uxth	r2, r3
 8007df8:	687b      	ldr	r3, [r7, #4]
 8007dfa:	801a      	strh	r2, [r3, #0]
 8007dfc:	e007      	b.n	8007e0e <I2C_NACKPositionConfig+0x36>
  }
  else
  {
    /* Current byte in shift register is the last received byte */
    I2Cx->CR1 &= I2C_NACKPosition_Current;
 8007dfe:	687b      	ldr	r3, [r7, #4]
 8007e00:	881b      	ldrh	r3, [r3, #0]
 8007e02:	b29b      	uxth	r3, r3
 8007e04:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8007e08:	b29a      	uxth	r2, r3
 8007e0a:	687b      	ldr	r3, [r7, #4]
 8007e0c:	801a      	strh	r2, [r3, #0]
  }
}
 8007e0e:	f107 070c 	add.w	r7, r7, #12
 8007e12:	46bd      	mov	sp, r7
 8007e14:	bc80      	pop	{r7}
 8007e16:	4770      	bx	lr

08007e18 <I2C_SMBusAlertConfig>:
  *            @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
  *            @arg I2C_SMBusAlert_High: SMBAlert pin driven high
  * @retval None
  */
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
 8007e18:	b480      	push	{r7}
 8007e1a:	b083      	sub	sp, #12
 8007e1c:	af00      	add	r7, sp, #0
 8007e1e:	6078      	str	r0, [r7, #4]
 8007e20:	460b      	mov	r3, r1
 8007e22:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 8007e24:	887b      	ldrh	r3, [r7, #2]
 8007e26:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8007e2a:	d108      	bne.n	8007e3e <I2C_SMBusAlertConfig+0x26>
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 8007e2c:	687b      	ldr	r3, [r7, #4]
 8007e2e:	881b      	ldrh	r3, [r3, #0]
 8007e30:	b29b      	uxth	r3, r3
 8007e32:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8007e36:	b29a      	uxth	r2, r3
 8007e38:	687b      	ldr	r3, [r7, #4]
 8007e3a:	801a      	strh	r2, [r3, #0]
 8007e3c:	e007      	b.n	8007e4e <I2C_SMBusAlertConfig+0x36>
  }
  else
  {
    /* Drive the SMBusAlert pin High  */
    I2Cx->CR1 &= I2C_SMBusAlert_High;
 8007e3e:	687b      	ldr	r3, [r7, #4]
 8007e40:	881b      	ldrh	r3, [r3, #0]
 8007e42:	b29b      	uxth	r3, r3
 8007e44:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8007e48:	b29a      	uxth	r2, r3
 8007e4a:	687b      	ldr	r3, [r7, #4]
 8007e4c:	801a      	strh	r2, [r3, #0]
  }
}
 8007e4e:	f107 070c 	add.w	r7, r7, #12
 8007e52:	46bd      	mov	sp, r7
 8007e54:	bc80      	pop	{r7}
 8007e56:	4770      	bx	lr

08007e58 <I2C_ARPCmd>:
  * @param  NewState: new state of the I2Cx ARP. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007e58:	b480      	push	{r7}
 8007e5a:	b083      	sub	sp, #12
 8007e5c:	af00      	add	r7, sp, #0
 8007e5e:	6078      	str	r0, [r7, #4]
 8007e60:	460b      	mov	r3, r1
 8007e62:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007e64:	78fb      	ldrb	r3, [r7, #3]
 8007e66:	2b00      	cmp	r3, #0
 8007e68:	d008      	beq.n	8007e7c <I2C_ARPCmd+0x24>
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= I2C_CR1_ENARP;
 8007e6a:	687b      	ldr	r3, [r7, #4]
 8007e6c:	881b      	ldrh	r3, [r3, #0]
 8007e6e:	b29b      	uxth	r3, r3
 8007e70:	f043 0310 	orr.w	r3, r3, #16
 8007e74:	b29a      	uxth	r2, r3
 8007e76:	687b      	ldr	r3, [r7, #4]
 8007e78:	801a      	strh	r2, [r3, #0]
 8007e7a:	e007      	b.n	8007e8c <I2C_ARPCmd+0x34>
  }
  else
  {
    /* Disable the selected I2C ARP */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
 8007e7c:	687b      	ldr	r3, [r7, #4]
 8007e7e:	881b      	ldrh	r3, [r3, #0]
 8007e80:	b29b      	uxth	r3, r3
 8007e82:	f023 0310 	bic.w	r3, r3, #16
 8007e86:	b29a      	uxth	r2, r3
 8007e88:	687b      	ldr	r3, [r7, #4]
 8007e8a:	801a      	strh	r2, [r3, #0]
  }
}
 8007e8c:	f107 070c 	add.w	r7, r7, #12
 8007e90:	46bd      	mov	sp, r7
 8007e92:	bc80      	pop	{r7}
 8007e94:	4770      	bx	lr
 8007e96:	bf00      	nop

08007e98 <I2C_SendData>:
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @param  Data: Byte to be transmitted..
  * @retval None
  */
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
 8007e98:	b480      	push	{r7}
 8007e9a:	b083      	sub	sp, #12
 8007e9c:	af00      	add	r7, sp, #0
 8007e9e:	6078      	str	r0, [r7, #4]
 8007ea0:	460b      	mov	r3, r1
 8007ea2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8007ea4:	78fb      	ldrb	r3, [r7, #3]
 8007ea6:	b29a      	uxth	r2, r3
 8007ea8:	687b      	ldr	r3, [r7, #4]
 8007eaa:	821a      	strh	r2, [r3, #16]
}
 8007eac:	f107 070c 	add.w	r7, r7, #12
 8007eb0:	46bd      	mov	sp, r7
 8007eb2:	bc80      	pop	{r7}
 8007eb4:	4770      	bx	lr
 8007eb6:	bf00      	nop

08007eb8 <I2C_ReceiveData>:
  * @brief  Returns the most recent received data by the I2Cx peripheral.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval The value of the received data.
  */
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
 8007eb8:	b480      	push	{r7}
 8007eba:	b083      	sub	sp, #12
 8007ebc:	af00      	add	r7, sp, #0
 8007ebe:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 8007ec0:	687b      	ldr	r3, [r7, #4]
 8007ec2:	8a1b      	ldrh	r3, [r3, #16]
 8007ec4:	b29b      	uxth	r3, r3
 8007ec6:	b2db      	uxtb	r3, r3
}
 8007ec8:	4618      	mov	r0, r3
 8007eca:	f107 070c 	add.w	r7, r7, #12
 8007ece:	46bd      	mov	sp, r7
 8007ed0:	bc80      	pop	{r7}
 8007ed2:	4770      	bx	lr

08007ed4 <I2C_TransmitPEC>:
  * @param  NewState: new state of the I2C PEC transmission.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007ed4:	b480      	push	{r7}
 8007ed6:	b083      	sub	sp, #12
 8007ed8:	af00      	add	r7, sp, #0
 8007eda:	6078      	str	r0, [r7, #4]
 8007edc:	460b      	mov	r3, r1
 8007ede:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007ee0:	78fb      	ldrb	r3, [r7, #3]
 8007ee2:	2b00      	cmp	r3, #0
 8007ee4:	d008      	beq.n	8007ef8 <I2C_TransmitPEC+0x24>
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= I2C_CR1_PEC;
 8007ee6:	687b      	ldr	r3, [r7, #4]
 8007ee8:	881b      	ldrh	r3, [r3, #0]
 8007eea:	b29b      	uxth	r3, r3
 8007eec:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8007ef0:	b29a      	uxth	r2, r3
 8007ef2:	687b      	ldr	r3, [r7, #4]
 8007ef4:	801a      	strh	r2, [r3, #0]
 8007ef6:	e007      	b.n	8007f08 <I2C_TransmitPEC+0x34>
  }
  else
  {
    /* Disable the selected I2C PEC transmission */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
 8007ef8:	687b      	ldr	r3, [r7, #4]
 8007efa:	881b      	ldrh	r3, [r3, #0]
 8007efc:	b29b      	uxth	r3, r3
 8007efe:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8007f02:	b29a      	uxth	r2, r3
 8007f04:	687b      	ldr	r3, [r7, #4]
 8007f06:	801a      	strh	r2, [r3, #0]
  }
}
 8007f08:	f107 070c 	add.w	r7, r7, #12
 8007f0c:	46bd      	mov	sp, r7
 8007f0e:	bc80      	pop	{r7}
 8007f10:	4770      	bx	lr
 8007f12:	bf00      	nop

08007f14 <I2C_PECPositionConfig>:
  *          is intended to used in I2C mode.
  *                
  * @retval None
  */
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
 8007f14:	b480      	push	{r7}
 8007f16:	b083      	sub	sp, #12
 8007f18:	af00      	add	r7, sp, #0
 8007f1a:	6078      	str	r0, [r7, #4]
 8007f1c:	460b      	mov	r3, r1
 8007f1e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 8007f20:	887b      	ldrh	r3, [r7, #2]
 8007f22:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8007f26:	d108      	bne.n	8007f3a <I2C_PECPositionConfig+0x26>
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
 8007f28:	687b      	ldr	r3, [r7, #4]
 8007f2a:	881b      	ldrh	r3, [r3, #0]
 8007f2c:	b29b      	uxth	r3, r3
 8007f2e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8007f32:	b29a      	uxth	r2, r3
 8007f34:	687b      	ldr	r3, [r7, #4]
 8007f36:	801a      	strh	r2, [r3, #0]
 8007f38:	e007      	b.n	8007f4a <I2C_PECPositionConfig+0x36>
  }
  else
  {
    /* Current byte in shift register is PEC */
    I2Cx->CR1 &= I2C_PECPosition_Current;
 8007f3a:	687b      	ldr	r3, [r7, #4]
 8007f3c:	881b      	ldrh	r3, [r3, #0]
 8007f3e:	b29b      	uxth	r3, r3
 8007f40:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8007f44:	b29a      	uxth	r2, r3
 8007f46:	687b      	ldr	r3, [r7, #4]
 8007f48:	801a      	strh	r2, [r3, #0]
  }
}
 8007f4a:	f107 070c 	add.w	r7, r7, #12
 8007f4e:	46bd      	mov	sp, r7
 8007f50:	bc80      	pop	{r7}
 8007f52:	4770      	bx	lr

08007f54 <I2C_CalculatePEC>:
  * @param  NewState: new state of the I2Cx PEC value calculation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007f54:	b480      	push	{r7}
 8007f56:	b083      	sub	sp, #12
 8007f58:	af00      	add	r7, sp, #0
 8007f5a:	6078      	str	r0, [r7, #4]
 8007f5c:	460b      	mov	r3, r1
 8007f5e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007f60:	78fb      	ldrb	r3, [r7, #3]
 8007f62:	2b00      	cmp	r3, #0
 8007f64:	d008      	beq.n	8007f78 <I2C_CalculatePEC+0x24>
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= I2C_CR1_ENPEC;
 8007f66:	687b      	ldr	r3, [r7, #4]
 8007f68:	881b      	ldrh	r3, [r3, #0]
 8007f6a:	b29b      	uxth	r3, r3
 8007f6c:	f043 0320 	orr.w	r3, r3, #32
 8007f70:	b29a      	uxth	r2, r3
 8007f72:	687b      	ldr	r3, [r7, #4]
 8007f74:	801a      	strh	r2, [r3, #0]
 8007f76:	e007      	b.n	8007f88 <I2C_CalculatePEC+0x34>
  }
  else
  {
    /* Disable the selected I2C PEC calculation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
 8007f78:	687b      	ldr	r3, [r7, #4]
 8007f7a:	881b      	ldrh	r3, [r3, #0]
 8007f7c:	b29b      	uxth	r3, r3
 8007f7e:	f023 0320 	bic.w	r3, r3, #32
 8007f82:	b29a      	uxth	r2, r3
 8007f84:	687b      	ldr	r3, [r7, #4]
 8007f86:	801a      	strh	r2, [r3, #0]
  }
}
 8007f88:	f107 070c 	add.w	r7, r7, #12
 8007f8c:	46bd      	mov	sp, r7
 8007f8e:	bc80      	pop	{r7}
 8007f90:	4770      	bx	lr
 8007f92:	bf00      	nop

08007f94 <I2C_GetPEC>:
  * @brief  Returns the PEC value for the specified I2C.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval The PEC value.
  */
uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
{
 8007f94:	b480      	push	{r7}
 8007f96:	b083      	sub	sp, #12
 8007f98:	af00      	add	r7, sp, #0
 8007f9a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the selected I2C PEC value */
  return ((I2Cx->SR2) >> 8);
 8007f9c:	687b      	ldr	r3, [r7, #4]
 8007f9e:	8b1b      	ldrh	r3, [r3, #24]
 8007fa0:	b29b      	uxth	r3, r3
 8007fa2:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8007fa6:	b29b      	uxth	r3, r3
 8007fa8:	b2db      	uxtb	r3, r3
}
 8007faa:	4618      	mov	r0, r3
 8007fac:	f107 070c 	add.w	r7, r7, #12
 8007fb0:	46bd      	mov	sp, r7
 8007fb2:	bc80      	pop	{r7}
 8007fb4:	4770      	bx	lr
 8007fb6:	bf00      	nop

08007fb8 <I2C_DMACmd>:
  * @param  NewState: new state of the I2C DMA transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007fb8:	b480      	push	{r7}
 8007fba:	b083      	sub	sp, #12
 8007fbc:	af00      	add	r7, sp, #0
 8007fbe:	6078      	str	r0, [r7, #4]
 8007fc0:	460b      	mov	r3, r1
 8007fc2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007fc4:	78fb      	ldrb	r3, [r7, #3]
 8007fc6:	2b00      	cmp	r3, #0
 8007fc8:	d008      	beq.n	8007fdc <I2C_DMACmd+0x24>
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= I2C_CR2_DMAEN;
 8007fca:	687b      	ldr	r3, [r7, #4]
 8007fcc:	889b      	ldrh	r3, [r3, #4]
 8007fce:	b29b      	uxth	r3, r3
 8007fd0:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8007fd4:	b29a      	uxth	r2, r3
 8007fd6:	687b      	ldr	r3, [r7, #4]
 8007fd8:	809a      	strh	r2, [r3, #4]
 8007fda:	e007      	b.n	8007fec <I2C_DMACmd+0x34>
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
 8007fdc:	687b      	ldr	r3, [r7, #4]
 8007fde:	889b      	ldrh	r3, [r3, #4]
 8007fe0:	b29b      	uxth	r3, r3
 8007fe2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8007fe6:	b29a      	uxth	r2, r3
 8007fe8:	687b      	ldr	r3, [r7, #4]
 8007fea:	809a      	strh	r2, [r3, #4]
  }
}
 8007fec:	f107 070c 	add.w	r7, r7, #12
 8007ff0:	46bd      	mov	sp, r7
 8007ff2:	bc80      	pop	{r7}
 8007ff4:	4770      	bx	lr
 8007ff6:	bf00      	nop

08007ff8 <I2C_DMALastTransferCmd>:
  * @param  NewState: new state of the I2C DMA last transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8007ff8:	b480      	push	{r7}
 8007ffa:	b083      	sub	sp, #12
 8007ffc:	af00      	add	r7, sp, #0
 8007ffe:	6078      	str	r0, [r7, #4]
 8008000:	460b      	mov	r3, r1
 8008002:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008004:	78fb      	ldrb	r3, [r7, #3]
 8008006:	2b00      	cmp	r3, #0
 8008008:	d008      	beq.n	800801c <I2C_DMALastTransferCmd+0x24>
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= I2C_CR2_LAST;
 800800a:	687b      	ldr	r3, [r7, #4]
 800800c:	889b      	ldrh	r3, [r3, #4]
 800800e:	b29b      	uxth	r3, r3
 8008010:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8008014:	b29a      	uxth	r2, r3
 8008016:	687b      	ldr	r3, [r7, #4]
 8008018:	809a      	strh	r2, [r3, #4]
 800801a:	e007      	b.n	800802c <I2C_DMALastTransferCmd+0x34>
  }
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
 800801c:	687b      	ldr	r3, [r7, #4]
 800801e:	889b      	ldrh	r3, [r3, #4]
 8008020:	b29b      	uxth	r3, r3
 8008022:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8008026:	b29a      	uxth	r2, r3
 8008028:	687b      	ldr	r3, [r7, #4]
 800802a:	809a      	strh	r2, [r3, #4]
  }
}
 800802c:	f107 070c 	add.w	r7, r7, #12
 8008030:	46bd      	mov	sp, r7
 8008032:	bc80      	pop	{r7}
 8008034:	4770      	bx	lr
 8008036:	bf00      	nop

08008038 <I2C_ReadRegister>:
  *            @arg I2C_Register_CCR:   CCR register.
  *            @arg I2C_Register_TRISE: TRISE register.
  * @retval The value of the read register.
  */
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 8008038:	b480      	push	{r7}
 800803a:	b085      	sub	sp, #20
 800803c:	af00      	add	r7, sp, #0
 800803e:	6078      	str	r0, [r7, #4]
 8008040:	460b      	mov	r3, r1
 8008042:	70fb      	strb	r3, [r7, #3]
  __IO uint32_t tmp = 0;
 8008044:	f04f 0300 	mov.w	r3, #0
 8008048:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t) I2Cx;
 800804a:	687b      	ldr	r3, [r7, #4]
 800804c:	60fb      	str	r3, [r7, #12]
  tmp += I2C_Register;
 800804e:	78fa      	ldrb	r2, [r7, #3]
 8008050:	68fb      	ldr	r3, [r7, #12]
 8008052:	18d3      	adds	r3, r2, r3
 8008054:	60fb      	str	r3, [r7, #12]

  /* Return the selected register value */
  return (*(__IO uint16_t *) tmp);
 8008056:	68fb      	ldr	r3, [r7, #12]
 8008058:	881b      	ldrh	r3, [r3, #0]
 800805a:	b29b      	uxth	r3, r3
}
 800805c:	4618      	mov	r0, r3
 800805e:	f107 0714 	add.w	r7, r7, #20
 8008062:	46bd      	mov	sp, r7
 8008064:	bc80      	pop	{r7}
 8008066:	4770      	bx	lr

08008068 <I2C_ITConfig>:
  * @param  NewState: new state of the specified I2C interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
{
 8008068:	b480      	push	{r7}
 800806a:	b083      	sub	sp, #12
 800806c:	af00      	add	r7, sp, #0
 800806e:	6078      	str	r0, [r7, #4]
 8008070:	4613      	mov	r3, r2
 8008072:	460a      	mov	r2, r1
 8008074:	807a      	strh	r2, [r7, #2]
 8008076:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8008078:	787b      	ldrb	r3, [r7, #1]
 800807a:	2b00      	cmp	r3, #0
 800807c:	d008      	beq.n	8008090 <I2C_ITConfig+0x28>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 800807e:	687b      	ldr	r3, [r7, #4]
 8008080:	889b      	ldrh	r3, [r3, #4]
 8008082:	b29a      	uxth	r2, r3
 8008084:	887b      	ldrh	r3, [r7, #2]
 8008086:	4313      	orrs	r3, r2
 8008088:	b29a      	uxth	r2, r3
 800808a:	687b      	ldr	r3, [r7, #4]
 800808c:	809a      	strh	r2, [r3, #4]
 800808e:	e00a      	b.n	80080a6 <I2C_ITConfig+0x3e>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8008090:	687b      	ldr	r3, [r7, #4]
 8008092:	889b      	ldrh	r3, [r3, #4]
 8008094:	b29a      	uxth	r2, r3
 8008096:	887b      	ldrh	r3, [r7, #2]
 8008098:	ea6f 0303 	mvn.w	r3, r3
 800809c:	b29b      	uxth	r3, r3
 800809e:	4013      	ands	r3, r2
 80080a0:	b29a      	uxth	r2, r3
 80080a2:	687b      	ldr	r3, [r7, #4]
 80080a4:	809a      	strh	r2, [r3, #4]
  }
}
 80080a6:	f107 070c 	add.w	r7, r7, #12
 80080aa:	46bd      	mov	sp, r7
 80080ac:	bc80      	pop	{r7}
 80080ae:	4770      	bx	lr

080080b0 <I2C_CheckEvent>:
  * @retval An ErrorStatus enumeration value:
  *           - SUCCESS: Last event is equal to the I2C_EVENT
  *           - ERROR: Last event is different from the I2C_EVENT
  */
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
{
 80080b0:	b480      	push	{r7}
 80080b2:	b087      	sub	sp, #28
 80080b4:	af00      	add	r7, sp, #0
 80080b6:	6078      	str	r0, [r7, #4]
 80080b8:	6039      	str	r1, [r7, #0]
  uint32_t lastevent = 0;
 80080ba:	f04f 0300 	mov.w	r3, #0
 80080be:	613b      	str	r3, [r7, #16]
  uint32_t flag1 = 0, flag2 = 0;
 80080c0:	f04f 0300 	mov.w	r3, #0
 80080c4:	60fb      	str	r3, [r7, #12]
 80080c6:	f04f 0300 	mov.w	r3, #0
 80080ca:	60bb      	str	r3, [r7, #8]
  ErrorStatus status = ERROR;
 80080cc:	f04f 0300 	mov.w	r3, #0
 80080d0:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80080d2:	687b      	ldr	r3, [r7, #4]
 80080d4:	8a9b      	ldrh	r3, [r3, #20]
 80080d6:	b29b      	uxth	r3, r3
 80080d8:	60fb      	str	r3, [r7, #12]
  flag2 = I2Cx->SR2;
 80080da:	687b      	ldr	r3, [r7, #4]
 80080dc:	8b1b      	ldrh	r3, [r3, #24]
 80080de:	b29b      	uxth	r3, r3
 80080e0:	60bb      	str	r3, [r7, #8]
  flag2 = flag2 << 16;
 80080e2:	68bb      	ldr	r3, [r7, #8]
 80080e4:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80080e8:	60bb      	str	r3, [r7, #8]

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 80080ea:	68fa      	ldr	r2, [r7, #12]
 80080ec:	68bb      	ldr	r3, [r7, #8]
 80080ee:	4313      	orrs	r3, r2
 80080f0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80080f4:	613b      	str	r3, [r7, #16]

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
 80080f6:	693a      	ldr	r2, [r7, #16]
 80080f8:	683b      	ldr	r3, [r7, #0]
 80080fa:	401a      	ands	r2, r3
 80080fc:	683b      	ldr	r3, [r7, #0]
 80080fe:	429a      	cmp	r2, r3
 8008100:	d103      	bne.n	800810a <I2C_CheckEvent+0x5a>
  {
    /* SUCCESS: last event is equal to I2C_EVENT */
    status = SUCCESS;
 8008102:	f04f 0301 	mov.w	r3, #1
 8008106:	75fb      	strb	r3, [r7, #23]
 8008108:	e002      	b.n	8008110 <I2C_CheckEvent+0x60>
  }
  else
  {
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
 800810a:	f04f 0300 	mov.w	r3, #0
 800810e:	75fb      	strb	r3, [r7, #23]
  }
  /* Return status */
  return status;
 8008110:	7dfb      	ldrb	r3, [r7, #23]
}
 8008112:	4618      	mov	r0, r3
 8008114:	f107 071c 	add.w	r7, r7, #28
 8008118:	46bd      	mov	sp, r7
 800811a:	bc80      	pop	{r7}
 800811c:	4770      	bx	lr
 800811e:	bf00      	nop

08008120 <I2C_GetLastEvent>:
  *         in stm32f4xx_i2c.h file.
  *    
  * @retval The last event
  */
uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
{
 8008120:	b480      	push	{r7}
 8008122:	b087      	sub	sp, #28
 8008124:	af00      	add	r7, sp, #0
 8008126:	6078      	str	r0, [r7, #4]
  uint32_t lastevent = 0;
 8008128:	f04f 0300 	mov.w	r3, #0
 800812c:	617b      	str	r3, [r7, #20]
  uint32_t flag1 = 0, flag2 = 0;
 800812e:	f04f 0300 	mov.w	r3, #0
 8008132:	613b      	str	r3, [r7, #16]
 8008134:	f04f 0300 	mov.w	r3, #0
 8008138:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 800813a:	687b      	ldr	r3, [r7, #4]
 800813c:	8a9b      	ldrh	r3, [r3, #20]
 800813e:	b29b      	uxth	r3, r3
 8008140:	613b      	str	r3, [r7, #16]
  flag2 = I2Cx->SR2;
 8008142:	687b      	ldr	r3, [r7, #4]
 8008144:	8b1b      	ldrh	r3, [r3, #24]
 8008146:	b29b      	uxth	r3, r3
 8008148:	60fb      	str	r3, [r7, #12]
  flag2 = flag2 << 16;
 800814a:	68fb      	ldr	r3, [r7, #12]
 800814c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8008150:	60fb      	str	r3, [r7, #12]

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 8008152:	693a      	ldr	r2, [r7, #16]
 8008154:	68fb      	ldr	r3, [r7, #12]
 8008156:	4313      	orrs	r3, r2
 8008158:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800815c:	617b      	str	r3, [r7, #20]

  /* Return status */
  return lastevent;
 800815e:	697b      	ldr	r3, [r7, #20]
}
 8008160:	4618      	mov	r0, r3
 8008162:	f107 071c 	add.w	r7, r7, #28
 8008166:	46bd      	mov	sp, r7
 8008168:	bc80      	pop	{r7}
 800816a:	4770      	bx	lr

0800816c <I2C_GetFlagStatus>:
  *                                Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 800816c:	b480      	push	{r7}
 800816e:	b087      	sub	sp, #28
 8008170:	af00      	add	r7, sp, #0
 8008172:	6078      	str	r0, [r7, #4]
 8008174:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 8008176:	f04f 0300 	mov.w	r3, #0
 800817a:	75fb      	strb	r3, [r7, #23]
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 800817c:	f04f 0300 	mov.w	r3, #0
 8008180:	613b      	str	r3, [r7, #16]
 8008182:	f04f 0300 	mov.w	r3, #0
 8008186:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 8008188:	687b      	ldr	r3, [r7, #4]
 800818a:	60fb      	str	r3, [r7, #12]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 800818c:	683b      	ldr	r3, [r7, #0]
 800818e:	ea4f 7313 	mov.w	r3, r3, lsr #28
 8008192:	613b      	str	r3, [r7, #16]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
 8008194:	683b      	ldr	r3, [r7, #0]
 8008196:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800819a:	603b      	str	r3, [r7, #0]
  
  if(i2creg != 0)
 800819c:	693b      	ldr	r3, [r7, #16]
 800819e:	2b00      	cmp	r3, #0
 80081a0:	d004      	beq.n	80081ac <I2C_GetFlagStatus+0x40>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 80081a2:	68fb      	ldr	r3, [r7, #12]
 80081a4:	f103 0314 	add.w	r3, r3, #20
 80081a8:	60fb      	str	r3, [r7, #12]
 80081aa:	e007      	b.n	80081bc <I2C_GetFlagStatus+0x50>
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 80081ac:	683b      	ldr	r3, [r7, #0]
 80081ae:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80081b2:	603b      	str	r3, [r7, #0]
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 80081b4:	68fb      	ldr	r3, [r7, #12]
 80081b6:	f103 0318 	add.w	r3, r3, #24
 80081ba:	60fb      	str	r3, [r7, #12]
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 80081bc:	68fb      	ldr	r3, [r7, #12]
 80081be:	681a      	ldr	r2, [r3, #0]
 80081c0:	683b      	ldr	r3, [r7, #0]
 80081c2:	4013      	ands	r3, r2
 80081c4:	2b00      	cmp	r3, #0
 80081c6:	d003      	beq.n	80081d0 <I2C_GetFlagStatus+0x64>
  {
    /* I2C_FLAG is set */
    bitstatus = SET;
 80081c8:	f04f 0301 	mov.w	r3, #1
 80081cc:	75fb      	strb	r3, [r7, #23]
 80081ce:	e002      	b.n	80081d6 <I2C_GetFlagStatus+0x6a>
  }
  else
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
 80081d0:	f04f 0300 	mov.w	r3, #0
 80081d4:	75fb      	strb	r3, [r7, #23]
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
 80081d6:	7dfb      	ldrb	r3, [r7, #23]
}
 80081d8:	4618      	mov	r0, r3
 80081da:	f107 071c 	add.w	r7, r7, #28
 80081de:	46bd      	mov	sp, r7
 80081e0:	bc80      	pop	{r7}
 80081e2:	4770      	bx	lr

080081e4 <I2C_ClearFlag>:
  *          register (I2C_SendData()).
  *  
  * @retval None
  */
void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 80081e4:	b480      	push	{r7}
 80081e6:	b085      	sub	sp, #20
 80081e8:	af00      	add	r7, sp, #0
 80081ea:	6078      	str	r0, [r7, #4]
 80081ec:	6039      	str	r1, [r7, #0]
  uint32_t flagpos = 0;
 80081ee:	f04f 0300 	mov.w	r3, #0
 80081f2:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_MASK;
 80081f4:	683b      	ldr	r3, [r7, #0]
 80081f6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80081fa:	60fb      	str	r3, [r7, #12]
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 80081fc:	68fb      	ldr	r3, [r7, #12]
 80081fe:	b29b      	uxth	r3, r3
 8008200:	ea6f 0303 	mvn.w	r3, r3
 8008204:	b29a      	uxth	r2, r3
 8008206:	687b      	ldr	r3, [r7, #4]
 8008208:	829a      	strh	r2, [r3, #20]
}
 800820a:	f107 0714 	add.w	r7, r7, #20
 800820e:	46bd      	mov	sp, r7
 8008210:	bc80      	pop	{r7}
 8008212:	4770      	bx	lr

08008214 <I2C_GetITStatus>:
  *                              Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_IT_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_IT (SET or RESET).
  */
ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
 8008214:	b480      	push	{r7}
 8008216:	b085      	sub	sp, #20
 8008218:	af00      	add	r7, sp, #0
 800821a:	6078      	str	r0, [r7, #4]
 800821c:	6039      	str	r1, [r7, #0]
  ITStatus bitstatus = RESET;
 800821e:	f04f 0300 	mov.w	r3, #0
 8008222:	73fb      	strb	r3, [r7, #15]
  uint32_t enablestatus = 0;
 8008224:	f04f 0300 	mov.w	r3, #0
 8008228:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 800822a:	683b      	ldr	r3, [r7, #0]
 800822c:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
 8008230:	ea4f 4213 	mov.w	r2, r3, lsr #16
 8008234:	687b      	ldr	r3, [r7, #4]
 8008236:	889b      	ldrh	r3, [r3, #4]
 8008238:	b29b      	uxth	r3, r3
 800823a:	4013      	ands	r3, r2
 800823c:	60bb      	str	r3, [r7, #8]
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;
 800823e:	683b      	ldr	r3, [r7, #0]
 8008240:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8008244:	603b      	str	r3, [r7, #0]

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 8008246:	687b      	ldr	r3, [r7, #4]
 8008248:	8a9b      	ldrh	r3, [r3, #20]
 800824a:	b29b      	uxth	r3, r3
 800824c:	461a      	mov	r2, r3
 800824e:	683b      	ldr	r3, [r7, #0]
 8008250:	4013      	ands	r3, r2
 8008252:	2b00      	cmp	r3, #0
 8008254:	d006      	beq.n	8008264 <I2C_GetITStatus+0x50>
 8008256:	68bb      	ldr	r3, [r7, #8]
 8008258:	2b00      	cmp	r3, #0
 800825a:	d003      	beq.n	8008264 <I2C_GetITStatus+0x50>
  {
    /* I2C_IT is set */
    bitstatus = SET;
 800825c:	f04f 0301 	mov.w	r3, #1
 8008260:	73fb      	strb	r3, [r7, #15]
 8008262:	e002      	b.n	800826a <I2C_GetITStatus+0x56>
  }
  else
  {
    /* I2C_IT is reset */
    bitstatus = RESET;
 8008264:	f04f 0300 	mov.w	r3, #0
 8008268:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the I2C_IT status */
  return  bitstatus;
 800826a:	7bfb      	ldrb	r3, [r7, #15]
}
 800826c:	4618      	mov	r0, r3
 800826e:	f107 0714 	add.w	r7, r7, #20
 8008272:	46bd      	mov	sp, r7
 8008274:	bc80      	pop	{r7}
 8008276:	4770      	bx	lr

08008278 <I2C_ClearITPendingBit>:
  *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
  *          I2C_DR register (I2C_SendData()).
  * @retval None
  */
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
 8008278:	b480      	push	{r7}
 800827a:	b085      	sub	sp, #20
 800827c:	af00      	add	r7, sp, #0
 800827e:	6078      	str	r0, [r7, #4]
 8008280:	6039      	str	r1, [r7, #0]
  uint32_t flagpos = 0;
 8008282:	f04f 0300 	mov.w	r3, #0
 8008286:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));

  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_MASK;
 8008288:	683b      	ldr	r3, [r7, #0]
 800828a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800828e:	60fb      	str	r3, [r7, #12]

  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8008290:	68fb      	ldr	r3, [r7, #12]
 8008292:	b29b      	uxth	r3, r3
 8008294:	ea6f 0303 	mvn.w	r3, r3
 8008298:	b29a      	uxth	r2, r3
 800829a:	687b      	ldr	r3, [r7, #4]
 800829c:	829a      	strh	r2, [r3, #20]
}
 800829e:	f107 0714 	add.w	r7, r7, #20
 80082a2:	46bd      	mov	sp, r7
 80082a4:	bc80      	pop	{r7}
 80082a6:	4770      	bx	lr

080082a8 <PWR_DeInit>:
  * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
  * @param  None
  * @retval None
  */
void PWR_DeInit(void)
{
 80082a8:	b580      	push	{r7, lr}
 80082aa:	af00      	add	r7, sp, #0
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 80082ac:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 80082b0:	f04f 0101 	mov.w	r1, #1
 80082b4:	f000 fe3a 	bl	8008f2c <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 80082b8:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 80082bc:	f04f 0100 	mov.w	r1, #0
 80082c0:	f000 fe34 	bl	8008f2c <RCC_APB1PeriphResetCmd>
}
 80082c4:	bd80      	pop	{r7, pc}
 80082c6:	bf00      	nop

080082c8 <PWR_BackupAccessCmd>:
  * @param  NewState: new state of the access to the backup domain.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
 80082c8:	b480      	push	{r7}
 80082ca:	b083      	sub	sp, #12
 80082cc:	af00      	add	r7, sp, #0
 80082ce:	4603      	mov	r3, r0
 80082d0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 80082d2:	f04f 0320 	mov.w	r3, #32
 80082d6:	f2c4 230e 	movt	r3, #16910	; 0x420e
 80082da:	79fa      	ldrb	r2, [r7, #7]
 80082dc:	601a      	str	r2, [r3, #0]
}
 80082de:	f107 070c 	add.w	r7, r7, #12
 80082e2:	46bd      	mov	sp, r7
 80082e4:	bc80      	pop	{r7}
 80082e6:	4770      	bx	lr

080082e8 <PWR_PVDLevelConfig>:
  *            @arg PWR_PVDLevel_7: PVD detection level set to 3.0V
  * @note   Refer to the electrical characteristics of you device datasheet for more details. 
  * @retval None
  */
void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
{
 80082e8:	b480      	push	{r7}
 80082ea:	b085      	sub	sp, #20
 80082ec:	af00      	add	r7, sp, #0
 80082ee:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80082f0:	f04f 0300 	mov.w	r3, #0
 80082f4:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  
  tmpreg = PWR->CR;
 80082f6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80082fa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80082fe:	681b      	ldr	r3, [r3, #0]
 8008300:	60fb      	str	r3, [r7, #12]
  
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 8008302:	68fb      	ldr	r3, [r7, #12]
 8008304:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 8008308:	60fb      	str	r3, [r7, #12]
  
  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 800830a:	68fa      	ldr	r2, [r7, #12]
 800830c:	687b      	ldr	r3, [r7, #4]
 800830e:	4313      	orrs	r3, r2
 8008310:	60fb      	str	r3, [r7, #12]
  
  /* Store the new value */
  PWR->CR = tmpreg;
 8008312:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008316:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800831a:	68fa      	ldr	r2, [r7, #12]
 800831c:	601a      	str	r2, [r3, #0]
}
 800831e:	f107 0714 	add.w	r7, r7, #20
 8008322:	46bd      	mov	sp, r7
 8008324:	bc80      	pop	{r7}
 8008326:	4770      	bx	lr

08008328 <PWR_PVDCmd>:
  * @param  NewState: new state of the PVD.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_PVDCmd(FunctionalState NewState)
{
 8008328:	b480      	push	{r7}
 800832a:	b083      	sub	sp, #12
 800832c:	af00      	add	r7, sp, #0
 800832e:	4603      	mov	r3, r0
 8008330:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 8008332:	f04f 0310 	mov.w	r3, #16
 8008336:	f2c4 230e 	movt	r3, #16910	; 0x420e
 800833a:	79fa      	ldrb	r2, [r7, #7]
 800833c:	601a      	str	r2, [r3, #0]
}
 800833e:	f107 070c 	add.w	r7, r7, #12
 8008342:	46bd      	mov	sp, r7
 8008344:	bc80      	pop	{r7}
 8008346:	4770      	bx	lr

08008348 <PWR_WakeUpPinCmd>:
  * @param  NewState: new state of the WakeUp Pin functionality.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_WakeUpPinCmd(FunctionalState NewState)
{
 8008348:	b480      	push	{r7}
 800834a:	b083      	sub	sp, #12
 800834c:	af00      	add	r7, sp, #0
 800834e:	4603      	mov	r3, r0
 8008350:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 8008352:	f04f 03a0 	mov.w	r3, #160	; 0xa0
 8008356:	f2c4 230e 	movt	r3, #16910	; 0x420e
 800835a:	79fa      	ldrb	r2, [r7, #7]
 800835c:	601a      	str	r2, [r3, #0]
}
 800835e:	f107 070c 	add.w	r7, r7, #12
 8008362:	46bd      	mov	sp, r7
 8008364:	bc80      	pop	{r7}
 8008366:	4770      	bx	lr

08008368 <PWR_BackupRegulatorCmd>:
  * @param  NewState: new state of the Backup Regulator.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_BackupRegulatorCmd(FunctionalState NewState)
{
 8008368:	b480      	push	{r7}
 800836a:	b083      	sub	sp, #12
 800836c:	af00      	add	r7, sp, #0
 800836e:	4603      	mov	r3, r0
 8008370:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
 8008372:	f04f 03a4 	mov.w	r3, #164	; 0xa4
 8008376:	f2c4 230e 	movt	r3, #16910	; 0x420e
 800837a:	79fa      	ldrb	r2, [r7, #7]
 800837c:	601a      	str	r2, [r3, #0]
}
 800837e:	f107 070c 	add.w	r7, r7, #12
 8008382:	46bd      	mov	sp, r7
 8008384:	bc80      	pop	{r7}
 8008386:	4770      	bx	lr

08008388 <PWR_MainRegulatorModeConfig>:
  *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
  *                                                System frequency up to 144 MHz.    
  * @retval None
  */
void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
{
 8008388:	b480      	push	{r7}
 800838a:	b083      	sub	sp, #12
 800838c:	af00      	add	r7, sp, #0
 800838e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));

  if (PWR_Regulator_Voltage == PWR_Regulator_Voltage_Scale2)
 8008390:	687b      	ldr	r3, [r7, #4]
 8008392:	2b00      	cmp	r3, #0
 8008394:	d10c      	bne.n	80083b0 <PWR_MainRegulatorModeConfig+0x28>
  {
    PWR->CR &= ~PWR_Regulator_Voltage_Scale1;
 8008396:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 800839a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800839e:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 80083a2:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80083a6:	6812      	ldr	r2, [r2, #0]
 80083a8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 80083ac:	601a      	str	r2, [r3, #0]
 80083ae:	e00b      	b.n	80083c8 <PWR_MainRegulatorModeConfig+0x40>
  }
  else
  {    
    PWR->CR |= PWR_Regulator_Voltage_Scale1;
 80083b0:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80083b4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80083b8:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 80083bc:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80083c0:	6812      	ldr	r2, [r2, #0]
 80083c2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80083c6:	601a      	str	r2, [r3, #0]
  }
}
 80083c8:	f107 070c 	add.w	r7, r7, #12
 80083cc:	46bd      	mov	sp, r7
 80083ce:	bc80      	pop	{r7}
 80083d0:	4770      	bx	lr
 80083d2:	bf00      	nop

080083d4 <PWR_FlashPowerDownCmd>:
  * @param  NewState: new state of the Flash power mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_FlashPowerDownCmd(FunctionalState NewState)
{
 80083d4:	b480      	push	{r7}
 80083d6:	b083      	sub	sp, #12
 80083d8:	af00      	add	r7, sp, #0
 80083da:	4603      	mov	r3, r0
 80083dc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
 80083de:	f04f 0324 	mov.w	r3, #36	; 0x24
 80083e2:	f2c4 230e 	movt	r3, #16910	; 0x420e
 80083e6:	79fa      	ldrb	r2, [r7, #7]
 80083e8:	601a      	str	r2, [r3, #0]
}
 80083ea:	f107 070c 	add.w	r7, r7, #12
 80083ee:	46bd      	mov	sp, r7
 80083f0:	bc80      	pop	{r7}
 80083f2:	4770      	bx	lr

080083f4 <PWR_EnterSTOPMode>:
  *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
  *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
  * @retval None
  */
void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
{
 80083f4:	b480      	push	{r7}
 80083f6:	b085      	sub	sp, #20
 80083f8:	af00      	add	r7, sp, #0
 80083fa:	6078      	str	r0, [r7, #4]
 80083fc:	460b      	mov	r3, r1
 80083fe:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg = 0;
 8008400:	f04f 0300 	mov.w	r3, #0
 8008404:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 8008406:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 800840a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800840e:	681b      	ldr	r3, [r3, #0]
 8008410:	60fb      	str	r3, [r7, #12]
  /* Clear PDDS and LPDSR bits */
  tmpreg &= CR_DS_MASK;
 8008412:	68fb      	ldr	r3, [r7, #12]
 8008414:	f023 0303 	bic.w	r3, r3, #3
 8008418:	60fb      	str	r3, [r7, #12]
  
  /* Set LPDSR bit according to PWR_Regulator value */
  tmpreg |= PWR_Regulator;
 800841a:	68fa      	ldr	r2, [r7, #12]
 800841c:	687b      	ldr	r3, [r7, #4]
 800841e:	4313      	orrs	r3, r2
 8008420:	60fb      	str	r3, [r7, #12]
  
  /* Store the new value */
  PWR->CR = tmpreg;
 8008422:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008426:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800842a:	68fa      	ldr	r2, [r7, #12]
 800842c:	601a      	str	r2, [r3, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 800842e:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8008432:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008436:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 800843a:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800843e:	6912      	ldr	r2, [r2, #16]
 8008440:	f042 0204 	orr.w	r2, r2, #4
 8008444:	611a      	str	r2, [r3, #16]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 8008446:	78fb      	ldrb	r3, [r7, #3]
 8008448:	2b01      	cmp	r3, #1
 800844a:	d101      	bne.n	8008450 <PWR_EnterSTOPMode+0x5c>
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 800844c:	bf30      	wfi
 800844e:	e000      	b.n	8008452 <PWR_EnterSTOPMode+0x5e>
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) static __INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 8008450:	bf20      	wfe
  {
    /* Request Wait For Event */
    __WFE();
  }
  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 8008452:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8008456:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800845a:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 800845e:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8008462:	6912      	ldr	r2, [r2, #16]
 8008464:	f022 0204 	bic.w	r2, r2, #4
 8008468:	611a      	str	r2, [r3, #16]
}
 800846a:	f107 0714 	add.w	r7, r7, #20
 800846e:	46bd      	mov	sp, r7
 8008470:	bc80      	pop	{r7}
 8008472:	4770      	bx	lr

08008474 <PWR_EnterSTANDBYMode>:
  *          - WKUP pin 1 (PA0) if enabled.       
  * @param  None
  * @retval None
  */
void PWR_EnterSTANDBYMode(void)
{
 8008474:	b480      	push	{r7}
 8008476:	af00      	add	r7, sp, #0
  /* Clear Wakeup flag */
  PWR->CR |= PWR_CR_CWUF;
 8008478:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 800847c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008480:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8008484:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8008488:	6812      	ldr	r2, [r2, #0]
 800848a:	f042 0204 	orr.w	r2, r2, #4
 800848e:	601a      	str	r2, [r3, #0]
  
  /* Select STANDBY mode */
  PWR->CR |= PWR_CR_PDDS;
 8008490:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008494:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008498:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 800849c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80084a0:	6812      	ldr	r2, [r2, #0]
 80084a2:	f042 0202 	orr.w	r2, r2, #2
 80084a6:	601a      	str	r2, [r3, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 80084a8:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80084ac:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80084b0:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 80084b4:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80084b8:	6912      	ldr	r2, [r2, #16]
 80084ba:	f042 0204 	orr.w	r2, r2, #4
 80084be:	611a      	str	r2, [r3, #16]
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 80084c0:	bf30      	wfi
#if defined ( __CC_ARM   )
  __force_stores();
#endif
  /* Request Wait For Interrupt */
  __WFI();
}
 80084c2:	46bd      	mov	sp, r7
 80084c4:	bc80      	pop	{r7}
 80084c6:	4770      	bx	lr

080084c8 <PWR_GetFlagStatus>:
  *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
  *                 scaling output selection is ready. 
  * @retval The new state of PWR_FLAG (SET or RESET).
  */
FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
{
 80084c8:	b480      	push	{r7}
 80084ca:	b085      	sub	sp, #20
 80084cc:	af00      	add	r7, sp, #0
 80084ce:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 80084d0:	f04f 0300 	mov.w	r3, #0
 80084d4:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
  
  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 80084d6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80084da:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80084de:	685b      	ldr	r3, [r3, #4]
 80084e0:	461a      	mov	r2, r3
 80084e2:	687b      	ldr	r3, [r7, #4]
 80084e4:	4013      	ands	r3, r2
 80084e6:	2b00      	cmp	r3, #0
 80084e8:	d003      	beq.n	80084f2 <PWR_GetFlagStatus+0x2a>
  {
    bitstatus = SET;
 80084ea:	f04f 0301 	mov.w	r3, #1
 80084ee:	73fb      	strb	r3, [r7, #15]
 80084f0:	e002      	b.n	80084f8 <PWR_GetFlagStatus+0x30>
  }
  else
  {
    bitstatus = RESET;
 80084f2:	f04f 0300 	mov.w	r3, #0
 80084f6:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the flag status */
  return bitstatus;
 80084f8:	7bfb      	ldrb	r3, [r7, #15]
}
 80084fa:	4618      	mov	r0, r3
 80084fc:	f107 0714 	add.w	r7, r7, #20
 8008500:	46bd      	mov	sp, r7
 8008502:	bc80      	pop	{r7}
 8008504:	4770      	bx	lr
 8008506:	bf00      	nop

08008508 <PWR_ClearFlag>:
  *            @arg PWR_FLAG_WU: Wake Up flag
  *            @arg PWR_FLAG_SB: StandBy flag
  * @retval None
  */
void PWR_ClearFlag(uint32_t PWR_FLAG)
{
 8008508:	b480      	push	{r7}
 800850a:	b083      	sub	sp, #12
 800850c:	af00      	add	r7, sp, #0
 800850e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
         
  PWR->CR |=  PWR_FLAG << 2;
 8008510:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008514:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008518:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 800851c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8008520:	6812      	ldr	r2, [r2, #0]
 8008522:	4611      	mov	r1, r2
 8008524:	687a      	ldr	r2, [r7, #4]
 8008526:	ea4f 0282 	mov.w	r2, r2, lsl #2
 800852a:	430a      	orrs	r2, r1
 800852c:	601a      	str	r2, [r3, #0]
}
 800852e:	f107 070c 	add.w	r7, r7, #12
 8008532:	46bd      	mov	sp, r7
 8008534:	bc80      	pop	{r7}
 8008536:	4770      	bx	lr

08008538 <RCC_DeInit>:
  *            - LSI, LSE and RTC clocks 
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
 8008538:	b480      	push	{r7}
 800853a:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800853c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008540:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008544:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008548:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800854c:	6812      	ldr	r2, [r2, #0]
 800854e:	f042 0201 	orr.w	r2, r2, #1
 8008552:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8008554:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008558:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800855c:	f04f 0200 	mov.w	r2, #0
 8008560:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8008562:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008566:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800856a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800856e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008572:	6812      	ldr	r2, [r2, #0]
 8008574:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8008578:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800857c:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800857e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008582:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008586:	f243 0210 	movw	r2, #12304	; 0x3010
 800858a:	f2c2 4200 	movt	r2, #9216	; 0x2400
 800858e:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8008590:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008594:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008598:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800859c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80085a0:	6812      	ldr	r2, [r2, #0]
 80085a2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80085a6:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80085a8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80085ac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80085b0:	f04f 0200 	mov.w	r2, #0
 80085b4:	60da      	str	r2, [r3, #12]
}
 80085b6:	46bd      	mov	sp, r7
 80085b8:	bc80      	pop	{r7}
 80085ba:	4770      	bx	lr

080085bc <RCC_HSEConfig>:
  *            @arg RCC_HSE_ON: turn ON the HSE oscillator
  *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_HSEConfig(uint8_t RCC_HSE)
{
 80085bc:	b480      	push	{r7}
 80085be:	b083      	sub	sp, #12
 80085c0:	af00      	add	r7, sp, #0
 80085c2:	4603      	mov	r3, r0
 80085c4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 80085c6:	f643 0302 	movw	r3, #14338	; 0x3802
 80085ca:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80085ce:	f04f 0200 	mov.w	r2, #0
 80085d2:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 80085d4:	f643 0302 	movw	r3, #14338	; 0x3802
 80085d8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80085dc:	79fa      	ldrb	r2, [r7, #7]
 80085de:	701a      	strb	r2, [r3, #0]
}
 80085e0:	f107 070c 	add.w	r7, r7, #12
 80085e4:	46bd      	mov	sp, r7
 80085e6:	bc80      	pop	{r7}
 80085e8:	4770      	bx	lr
 80085ea:	bf00      	nop

080085ec <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 80085ec:	b580      	push	{r7, lr}
 80085ee:	b082      	sub	sp, #8
 80085f0:	af00      	add	r7, sp, #0
  __IO uint32_t startupcounter = 0;
 80085f2:	f04f 0300 	mov.w	r3, #0
 80085f6:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
 80085f8:	f04f 0300 	mov.w	r3, #0
 80085fc:	71fb      	strb	r3, [r7, #7]
  FlagStatus hsestatus = RESET;
 80085fe:	f04f 0300 	mov.w	r3, #0
 8008602:	71bb      	strb	r3, [r7, #6]
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8008604:	f04f 0031 	mov.w	r0, #49	; 0x31
 8008608:	f000 fdf4 	bl	80091f4 <RCC_GetFlagStatus>
 800860c:	4603      	mov	r3, r0
 800860e:	71bb      	strb	r3, [r7, #6]
    startupcounter++;
 8008610:	683b      	ldr	r3, [r7, #0]
 8008612:	f103 0301 	add.w	r3, r3, #1
 8008616:	603b      	str	r3, [r7, #0]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8008618:	683b      	ldr	r3, [r7, #0]
 800861a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800861e:	d002      	beq.n	8008626 <RCC_WaitForHSEStartUp+0x3a>
 8008620:	79bb      	ldrb	r3, [r7, #6]
 8008622:	2b00      	cmp	r3, #0
 8008624:	d0ee      	beq.n	8008604 <RCC_WaitForHSEStartUp+0x18>

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8008626:	f04f 0031 	mov.w	r0, #49	; 0x31
 800862a:	f000 fde3 	bl	80091f4 <RCC_GetFlagStatus>
 800862e:	4603      	mov	r3, r0
 8008630:	2b00      	cmp	r3, #0
 8008632:	d003      	beq.n	800863c <RCC_WaitForHSEStartUp+0x50>
  {
    status = SUCCESS;
 8008634:	f04f 0301 	mov.w	r3, #1
 8008638:	71fb      	strb	r3, [r7, #7]
 800863a:	e002      	b.n	8008642 <RCC_WaitForHSEStartUp+0x56>
  }
  else
  {
    status = ERROR;
 800863c:	f04f 0300 	mov.w	r3, #0
 8008640:	71fb      	strb	r3, [r7, #7]
  }
  return (status);
 8008642:	79fb      	ldrb	r3, [r7, #7]
}
 8008644:	4618      	mov	r0, r3
 8008646:	f107 0708 	add.w	r7, r7, #8
 800864a:	46bd      	mov	sp, r7
 800864c:	bd80      	pop	{r7, pc}
 800864e:	bf00      	nop

08008650 <RCC_AdjustHSICalibrationValue>:
  * @param  HSICalibrationValue: specifies the calibration trimming value.
  *         This parameter must be a number between 0 and 0x1F.
  * @retval None
  */
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
 8008650:	b480      	push	{r7}
 8008652:	b085      	sub	sp, #20
 8008654:	af00      	add	r7, sp, #0
 8008656:	4603      	mov	r3, r0
 8008658:	71fb      	strb	r3, [r7, #7]
  uint32_t tmpreg = 0;
 800865a:	f04f 0300 	mov.w	r3, #0
 800865e:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 8008660:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008664:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008668:	681b      	ldr	r3, [r3, #0]
 800866a:	60fb      	str	r3, [r7, #12]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 800866c:	68fb      	ldr	r3, [r7, #12]
 800866e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8008672:	60fb      	str	r3, [r7, #12]

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8008674:	79fb      	ldrb	r3, [r7, #7]
 8008676:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800867a:	68fa      	ldr	r2, [r7, #12]
 800867c:	4313      	orrs	r3, r2
 800867e:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CR = tmpreg;
 8008680:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008684:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008688:	68fa      	ldr	r2, [r7, #12]
 800868a:	601a      	str	r2, [r3, #0]
}
 800868c:	f107 0714 	add.w	r7, r7, #20
 8008690:	46bd      	mov	sp, r7
 8008692:	bc80      	pop	{r7}
 8008694:	4770      	bx	lr
 8008696:	bf00      	nop

08008698 <RCC_HSICmd>:
  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
  *         clock cycles.  
  * @retval None
  */
void RCC_HSICmd(FunctionalState NewState)
{
 8008698:	b480      	push	{r7}
 800869a:	b083      	sub	sp, #12
 800869c:	af00      	add	r7, sp, #0
 800869e:	4603      	mov	r3, r0
 80086a0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 80086a2:	f04f 0300 	mov.w	r3, #0
 80086a6:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80086aa:	79fa      	ldrb	r2, [r7, #7]
 80086ac:	601a      	str	r2, [r3, #0]
}
 80086ae:	f107 070c 	add.w	r7, r7, #12
 80086b2:	46bd      	mov	sp, r7
 80086b4:	bc80      	pop	{r7}
 80086b6:	4770      	bx	lr

080086b8 <RCC_LSEConfig>:
  *            @arg RCC_LSE_ON: turn ON the LSE oscillator
  *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_LSEConfig(uint8_t RCC_LSE)
{
 80086b8:	b480      	push	{r7}
 80086ba:	b083      	sub	sp, #12
 80086bc:	af00      	add	r7, sp, #0
 80086be:	4603      	mov	r3, r0
 80086c0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80086c2:	f643 0370 	movw	r3, #14448	; 0x3870
 80086c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80086ca:	f04f 0200 	mov.w	r2, #0
 80086ce:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80086d0:	f643 0370 	movw	r3, #14448	; 0x3870
 80086d4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80086d8:	f04f 0200 	mov.w	r2, #0
 80086dc:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 80086de:	79fb      	ldrb	r3, [r7, #7]
 80086e0:	2b01      	cmp	r3, #1
 80086e2:	d002      	beq.n	80086ea <RCC_LSEConfig+0x32>
 80086e4:	2b04      	cmp	r3, #4
 80086e6:	d008      	beq.n	80086fa <RCC_LSEConfig+0x42>
 80086e8:	e00f      	b.n	800870a <RCC_LSEConfig+0x52>
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 80086ea:	f643 0370 	movw	r3, #14448	; 0x3870
 80086ee:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80086f2:	f04f 0201 	mov.w	r2, #1
 80086f6:	701a      	strb	r2, [r3, #0]
      break;
 80086f8:	e008      	b.n	800870c <RCC_LSEConfig+0x54>
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 80086fa:	f643 0370 	movw	r3, #14448	; 0x3870
 80086fe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008702:	f04f 0205 	mov.w	r2, #5
 8008706:	701a      	strb	r2, [r3, #0]
      break;
 8008708:	e000      	b.n	800870c <RCC_LSEConfig+0x54>
    default:
      break;
 800870a:	bf00      	nop
  }
}
 800870c:	f107 070c 	add.w	r7, r7, #12
 8008710:	46bd      	mov	sp, r7
 8008712:	bc80      	pop	{r7}
 8008714:	4770      	bx	lr
 8008716:	bf00      	nop

08008718 <RCC_LSICmd>:
  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
  *         clock cycles. 
  * @retval None
  */
void RCC_LSICmd(FunctionalState NewState)
{
 8008718:	b480      	push	{r7}
 800871a:	b083      	sub	sp, #12
 800871c:	af00      	add	r7, sp, #0
 800871e:	4603      	mov	r3, r0
 8008720:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8008722:	f44f 6368 	mov.w	r3, #3712	; 0xe80
 8008726:	f2c4 2347 	movt	r3, #16967	; 0x4247
 800872a:	79fa      	ldrb	r2, [r7, #7]
 800872c:	601a      	str	r2, [r3, #0]
}
 800872e:	f107 070c 	add.w	r7, r7, #12
 8008732:	46bd      	mov	sp, r7
 8008734:	bc80      	pop	{r7}
 8008736:	4770      	bx	lr

08008738 <RCC_PLLConfig>:
  *         correctly.
  *   
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
{
 8008738:	b480      	push	{r7}
 800873a:	b085      	sub	sp, #20
 800873c:	af00      	add	r7, sp, #0
 800873e:	60f8      	str	r0, [r7, #12]
 8008740:	60b9      	str	r1, [r7, #8]
 8008742:	607a      	str	r2, [r7, #4]
 8008744:	603b      	str	r3, [r7, #0]
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8008746:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800874a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800874e:	687a      	ldr	r2, [r7, #4]
 8008750:	ea4f 1182 	mov.w	r1, r2, lsl #6
 8008754:	68ba      	ldr	r2, [r7, #8]
 8008756:	4311      	orrs	r1, r2
 8008758:	683a      	ldr	r2, [r7, #0]
 800875a:	ea4f 0252 	mov.w	r2, r2, lsr #1
 800875e:	f102 32ff 	add.w	r2, r2, #4294967295
 8008762:	ea4f 4202 	mov.w	r2, r2, lsl #16
 8008766:	4311      	orrs	r1, r2
 8008768:	68fa      	ldr	r2, [r7, #12]
 800876a:	4311      	orrs	r1, r2
                 (PLLQ << 24);
 800876c:	69ba      	ldr	r2, [r7, #24]
 800876e:	ea4f 6202 	mov.w	r2, r2, lsl #24
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8008772:	430a      	orrs	r2, r1
 8008774:	605a      	str	r2, [r3, #4]
                 (PLLQ << 24);
}
 8008776:	f107 0714 	add.w	r7, r7, #20
 800877a:	46bd      	mov	sp, r7
 800877c:	bc80      	pop	{r7}
 800877e:	4770      	bx	lr

08008780 <RCC_PLLCmd>:
  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
  * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 8008780:	b480      	push	{r7}
 8008782:	b083      	sub	sp, #12
 8008784:	af00      	add	r7, sp, #0
 8008786:	4603      	mov	r3, r0
 8008788:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 800878a:	f04f 0360 	mov.w	r3, #96	; 0x60
 800878e:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008792:	79fa      	ldrb	r2, [r7, #7]
 8008794:	601a      	str	r2, [r3, #0]
}
 8008796:	f107 070c 	add.w	r7, r7, #12
 800879a:	46bd      	mov	sp, r7
 800879c:	bc80      	pop	{r7}
 800879e:	4770      	bx	lr

080087a0 <RCC_PLLI2SConfig>:
  *         on the I2S clock frequency.
  *   
  * @retval None
  */
void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
{
 80087a0:	b480      	push	{r7}
 80087a2:	b083      	sub	sp, #12
 80087a4:	af00      	add	r7, sp, #0
 80087a6:	6078      	str	r0, [r7, #4]
 80087a8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 80087aa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80087ae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80087b2:	687a      	ldr	r2, [r7, #4]
 80087b4:	ea4f 1182 	mov.w	r1, r2, lsl #6
 80087b8:	683a      	ldr	r2, [r7, #0]
 80087ba:	ea4f 7202 	mov.w	r2, r2, lsl #28
 80087be:	430a      	orrs	r2, r1
 80087c0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 80087c4:	f107 070c 	add.w	r7, r7, #12
 80087c8:	46bd      	mov	sp, r7
 80087ca:	bc80      	pop	{r7}
 80087cc:	4770      	bx	lr
 80087ce:	bf00      	nop

080087d0 <RCC_PLLI2SCmd>:
  * @note   The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.  
  * @param  NewState: new state of the PLLI2S. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
 80087d0:	b480      	push	{r7}
 80087d2:	b083      	sub	sp, #12
 80087d4:	af00      	add	r7, sp, #0
 80087d6:	4603      	mov	r3, r0
 80087d8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 80087da:	f04f 0368 	mov.w	r3, #104	; 0x68
 80087de:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80087e2:	79fa      	ldrb	r2, [r7, #7]
 80087e4:	601a      	str	r2, [r3, #0]
}
 80087e6:	f107 070c 	add.w	r7, r7, #12
 80087ea:	46bd      	mov	sp, r7
 80087ec:	bc80      	pop	{r7}
 80087ee:	4770      	bx	lr

080087f0 <RCC_ClockSecuritySystemCmd>:
  * @param  NewState: new state of the Clock Security System.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
 80087f0:	b480      	push	{r7}
 80087f2:	b083      	sub	sp, #12
 80087f4:	af00      	add	r7, sp, #0
 80087f6:	4603      	mov	r3, r0
 80087f8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 80087fa:	f04f 034c 	mov.w	r3, #76	; 0x4c
 80087fe:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008802:	79fa      	ldrb	r2, [r7, #7]
 8008804:	601a      	str	r2, [r3, #0]
}
 8008806:	f107 070c 	add.w	r7, r7, #12
 800880a:	46bd      	mov	sp, r7
 800880c:	bc80      	pop	{r7}
 800880e:	4770      	bx	lr

08008810 <RCC_MCO1Config>:
  *            @arg RCC_MCO1Div_4: division by 4 applied to MCO1 clock
  *            @arg RCC_MCO1Div_5: division by 5 applied to MCO1 clock
  * @retval None
  */
void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
{
 8008810:	b480      	push	{r7}
 8008812:	b085      	sub	sp, #20
 8008814:	af00      	add	r7, sp, #0
 8008816:	6078      	str	r0, [r7, #4]
 8008818:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 800881a:	f04f 0300 	mov.w	r3, #0
 800881e:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 8008820:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008824:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008828:	689b      	ldr	r3, [r3, #8]
 800882a:	60fb      	str	r3, [r7, #12]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 800882c:	68fb      	ldr	r3, [r7, #12]
 800882e:	f023 63ec 	bic.w	r3, r3, #123731968	; 0x7600000
 8008832:	60fb      	str	r3, [r7, #12]

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 8008834:	687a      	ldr	r2, [r7, #4]
 8008836:	683b      	ldr	r3, [r7, #0]
 8008838:	4313      	orrs	r3, r2
 800883a:	68fa      	ldr	r2, [r7, #12]
 800883c:	4313      	orrs	r3, r2
 800883e:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8008840:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008844:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008848:	68fa      	ldr	r2, [r7, #12]
 800884a:	609a      	str	r2, [r3, #8]
}
 800884c:	f107 0714 	add.w	r7, r7, #20
 8008850:	46bd      	mov	sp, r7
 8008852:	bc80      	pop	{r7}
 8008854:	4770      	bx	lr
 8008856:	bf00      	nop

08008858 <RCC_MCO2Config>:
  *            @arg RCC_MCO2Div_4: division by 4 applied to MCO2 clock
  *            @arg RCC_MCO2Div_5: division by 5 applied to MCO2 clock
  * @retval None
  */
void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
{
 8008858:	b480      	push	{r7}
 800885a:	b085      	sub	sp, #20
 800885c:	af00      	add	r7, sp, #0
 800885e:	6078      	str	r0, [r7, #4]
 8008860:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8008862:	f04f 0300 	mov.w	r3, #0
 8008866:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 8008868:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800886c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008870:	689b      	ldr	r3, [r3, #8]
 8008872:	60fb      	str	r3, [r7, #12]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 8008874:	68fb      	ldr	r3, [r7, #12]
 8008876:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 800887a:	60fb      	str	r3, [r7, #12]

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 800887c:	687a      	ldr	r2, [r7, #4]
 800887e:	683b      	ldr	r3, [r7, #0]
 8008880:	4313      	orrs	r3, r2
 8008882:	68fa      	ldr	r2, [r7, #12]
 8008884:	4313      	orrs	r3, r2
 8008886:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8008888:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800888c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008890:	68fa      	ldr	r2, [r7, #12]
 8008892:	609a      	str	r2, [r3, #8]
}
 8008894:	f107 0714 	add.w	r7, r7, #20
 8008898:	46bd      	mov	sp, r7
 800889a:	bc80      	pop	{r7}
 800889c:	4770      	bx	lr
 800889e:	bf00      	nop

080088a0 <RCC_SYSCLKConfig>:
  *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
  *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 80088a0:	b480      	push	{r7}
 80088a2:	b085      	sub	sp, #20
 80088a4:	af00      	add	r7, sp, #0
 80088a6:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80088a8:	f04f 0300 	mov.w	r3, #0
 80088ac:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 80088ae:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80088b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80088b6:	689b      	ldr	r3, [r3, #8]
 80088b8:	60fb      	str	r3, [r7, #12]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 80088ba:	68fb      	ldr	r3, [r7, #12]
 80088bc:	f023 0303 	bic.w	r3, r3, #3
 80088c0:	60fb      	str	r3, [r7, #12]

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80088c2:	68fa      	ldr	r2, [r7, #12]
 80088c4:	687b      	ldr	r3, [r7, #4]
 80088c6:	4313      	orrs	r3, r2
 80088c8:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80088ca:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80088ce:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80088d2:	68fa      	ldr	r2, [r7, #12]
 80088d4:	609a      	str	r2, [r3, #8]
}
 80088d6:	f107 0714 	add.w	r7, r7, #20
 80088da:	46bd      	mov	sp, r7
 80088dc:	bc80      	pop	{r7}
 80088de:	4770      	bx	lr

080088e0 <RCC_GetSYSCLKSource>:
  *              - 0x00: HSI used as system clock
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
 80088e0:	b480      	push	{r7}
 80088e2:	af00      	add	r7, sp, #0
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 80088e4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80088e8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80088ec:	689b      	ldr	r3, [r3, #8]
 80088ee:	b2db      	uxtb	r3, r3
 80088f0:	f003 030c 	and.w	r3, r3, #12
 80088f4:	b2db      	uxtb	r3, r3
}
 80088f6:	4618      	mov	r0, r3
 80088f8:	46bd      	mov	sp, r7
 80088fa:	bc80      	pop	{r7}
 80088fc:	4770      	bx	lr
 80088fe:	bf00      	nop

08008900 <RCC_HCLKConfig>:
  *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 8008900:	b480      	push	{r7}
 8008902:	b085      	sub	sp, #20
 8008904:	af00      	add	r7, sp, #0
 8008906:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8008908:	f04f 0300 	mov.w	r3, #0
 800890c:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 800890e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008912:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008916:	689b      	ldr	r3, [r3, #8]
 8008918:	60fb      	str	r3, [r7, #12]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 800891a:	68fb      	ldr	r3, [r7, #12]
 800891c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008920:	60fb      	str	r3, [r7, #12]

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8008922:	68fa      	ldr	r2, [r7, #12]
 8008924:	687b      	ldr	r3, [r7, #4]
 8008926:	4313      	orrs	r3, r2
 8008928:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800892a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800892e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008932:	68fa      	ldr	r2, [r7, #12]
 8008934:	609a      	str	r2, [r3, #8]
}
 8008936:	f107 0714 	add.w	r7, r7, #20
 800893a:	46bd      	mov	sp, r7
 800893c:	bc80      	pop	{r7}
 800893e:	4770      	bx	lr

08008940 <RCC_PCLK1Config>:
  *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
  *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
 8008940:	b480      	push	{r7}
 8008942:	b085      	sub	sp, #20
 8008944:	af00      	add	r7, sp, #0
 8008946:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8008948:	f04f 0300 	mov.w	r3, #0
 800894c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 800894e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008952:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008956:	689b      	ldr	r3, [r3, #8]
 8008958:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 800895a:	68fb      	ldr	r3, [r7, #12]
 800895c:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8008960:	60fb      	str	r3, [r7, #12]

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8008962:	68fa      	ldr	r2, [r7, #12]
 8008964:	687b      	ldr	r3, [r7, #4]
 8008966:	4313      	orrs	r3, r2
 8008968:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800896a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800896e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008972:	68fa      	ldr	r2, [r7, #12]
 8008974:	609a      	str	r2, [r3, #8]
}
 8008976:	f107 0714 	add.w	r7, r7, #20
 800897a:	46bd      	mov	sp, r7
 800897c:	bc80      	pop	{r7}
 800897e:	4770      	bx	lr

08008980 <RCC_PCLK2Config>:
  *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
  *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
 8008980:	b480      	push	{r7}
 8008982:	b085      	sub	sp, #20
 8008984:	af00      	add	r7, sp, #0
 8008986:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8008988:	f04f 0300 	mov.w	r3, #0
 800898c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 800898e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008992:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008996:	689b      	ldr	r3, [r3, #8]
 8008998:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 800899a:	68fb      	ldr	r3, [r7, #12]
 800899c:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 80089a0:	60fb      	str	r3, [r7, #12]

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 80089a2:	687b      	ldr	r3, [r7, #4]
 80089a4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80089a8:	68fa      	ldr	r2, [r7, #12]
 80089aa:	4313      	orrs	r3, r2
 80089ac:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80089ae:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80089b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80089b6:	68fa      	ldr	r2, [r7, #12]
 80089b8:	609a      	str	r2, [r3, #8]
}
 80089ba:	f107 0714 	add.w	r7, r7, #20
 80089be:	46bd      	mov	sp, r7
 80089c0:	bc80      	pop	{r7}
 80089c2:	4770      	bx	lr

080089c4 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 80089c4:	b480      	push	{r7}
 80089c6:	b089      	sub	sp, #36	; 0x24
 80089c8:	af00      	add	r7, sp, #0
 80089ca:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 80089cc:	f04f 0300 	mov.w	r3, #0
 80089d0:	61bb      	str	r3, [r7, #24]
 80089d2:	f04f 0300 	mov.w	r3, #0
 80089d6:	617b      	str	r3, [r7, #20]
 80089d8:	f04f 0300 	mov.w	r3, #0
 80089dc:	61fb      	str	r3, [r7, #28]
 80089de:	f04f 0302 	mov.w	r3, #2
 80089e2:	613b      	str	r3, [r7, #16]
 80089e4:	f04f 0300 	mov.w	r3, #0
 80089e8:	60fb      	str	r3, [r7, #12]
 80089ea:	f04f 0302 	mov.w	r3, #2
 80089ee:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80089f0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80089f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80089f8:	689b      	ldr	r3, [r3, #8]
 80089fa:	f003 030c 	and.w	r3, r3, #12
 80089fe:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 8008a00:	69bb      	ldr	r3, [r7, #24]
 8008a02:	2b04      	cmp	r3, #4
 8008a04:	d00a      	beq.n	8008a1c <RCC_GetClocksFreq+0x58>
 8008a06:	2b08      	cmp	r3, #8
 8008a08:	d00f      	beq.n	8008a2a <RCC_GetClocksFreq+0x66>
 8008a0a:	2b00      	cmp	r3, #0
 8008a0c:	d162      	bne.n	8008ad4 <RCC_GetClocksFreq+0x110>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8008a0e:	687a      	ldr	r2, [r7, #4]
 8008a10:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8008a14:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8008a18:	6013      	str	r3, [r2, #0]
      break;
 8008a1a:	e062      	b.n	8008ae2 <RCC_GetClocksFreq+0x11e>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8008a1c:	687a      	ldr	r2, [r7, #4]
 8008a1e:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8008a22:	f2c0 037a 	movt	r3, #122	; 0x7a
 8008a26:	6013      	str	r3, [r2, #0]
      break;
 8008a28:	e05b      	b.n	8008ae2 <RCC_GetClocksFreq+0x11e>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8008a2a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008a2e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008a32:	685b      	ldr	r3, [r3, #4]
 8008a34:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8008a38:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8008a3c:	60fb      	str	r3, [r7, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8008a3e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008a42:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008a46:	685b      	ldr	r3, [r3, #4]
 8008a48:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008a4c:	60bb      	str	r3, [r7, #8]
      
      if (pllsource != 0)
 8008a4e:	68fb      	ldr	r3, [r7, #12]
 8008a50:	2b00      	cmp	r3, #0
 8008a52:	d015      	beq.n	8008a80 <RCC_GetClocksFreq+0xbc>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8008a54:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8008a58:	f2c0 037a 	movt	r3, #122	; 0x7a
 8008a5c:	68ba      	ldr	r2, [r7, #8]
 8008a5e:	fbb3 f2f2 	udiv	r2, r3, r2
 8008a62:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008a66:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008a6a:	685b      	ldr	r3, [r3, #4]
 8008a6c:	4619      	mov	r1, r3
 8008a6e:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8008a72:	400b      	ands	r3, r1
 8008a74:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8008a78:	fb03 f302 	mul.w	r3, r3, r2
 8008a7c:	61fb      	str	r3, [r7, #28]
 8008a7e:	e014      	b.n	8008aaa <RCC_GetClocksFreq+0xe6>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8008a80:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8008a84:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8008a88:	68ba      	ldr	r2, [r7, #8]
 8008a8a:	fbb3 f2f2 	udiv	r2, r3, r2
 8008a8e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008a92:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008a96:	685b      	ldr	r3, [r3, #4]
 8008a98:	4619      	mov	r1, r3
 8008a9a:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8008a9e:	400b      	ands	r3, r1
 8008aa0:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8008aa4:	fb03 f302 	mul.w	r3, r3, r2
 8008aa8:	61fb      	str	r3, [r7, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8008aaa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008aae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ab2:	685b      	ldr	r3, [r3, #4]
 8008ab4:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8008ab8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8008abc:	f103 0301 	add.w	r3, r3, #1
 8008ac0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8008ac4:	613b      	str	r3, [r7, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8008ac6:	69fa      	ldr	r2, [r7, #28]
 8008ac8:	693b      	ldr	r3, [r7, #16]
 8008aca:	fbb2 f2f3 	udiv	r2, r2, r3
 8008ace:	687b      	ldr	r3, [r7, #4]
 8008ad0:	601a      	str	r2, [r3, #0]
      break;
 8008ad2:	e006      	b.n	8008ae2 <RCC_GetClocksFreq+0x11e>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8008ad4:	687a      	ldr	r2, [r7, #4]
 8008ad6:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8008ada:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8008ade:	6013      	str	r3, [r2, #0]
      break;
 8008ae0:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8008ae2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008ae6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008aea:	689b      	ldr	r3, [r3, #8]
 8008aec:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008af0:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 8008af2:	69bb      	ldr	r3, [r7, #24]
 8008af4:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8008af8:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8008afa:	f240 0324 	movw	r3, #36	; 0x24
 8008afe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008b02:	69ba      	ldr	r2, [r7, #24]
 8008b04:	189b      	adds	r3, r3, r2
 8008b06:	781b      	ldrb	r3, [r3, #0]
 8008b08:	b2db      	uxtb	r3, r3
 8008b0a:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8008b0c:	687b      	ldr	r3, [r7, #4]
 8008b0e:	681a      	ldr	r2, [r3, #0]
 8008b10:	697b      	ldr	r3, [r7, #20]
 8008b12:	fa22 f203 	lsr.w	r2, r2, r3
 8008b16:	687b      	ldr	r3, [r7, #4]
 8008b18:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8008b1a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008b1e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008b22:	689b      	ldr	r3, [r3, #8]
 8008b24:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8008b28:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 8008b2a:	69bb      	ldr	r3, [r7, #24]
 8008b2c:	ea4f 2393 	mov.w	r3, r3, lsr #10
 8008b30:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8008b32:	f240 0324 	movw	r3, #36	; 0x24
 8008b36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008b3a:	69ba      	ldr	r2, [r7, #24]
 8008b3c:	189b      	adds	r3, r3, r2
 8008b3e:	781b      	ldrb	r3, [r3, #0]
 8008b40:	b2db      	uxtb	r3, r3
 8008b42:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8008b44:	687b      	ldr	r3, [r7, #4]
 8008b46:	685a      	ldr	r2, [r3, #4]
 8008b48:	697b      	ldr	r3, [r7, #20]
 8008b4a:	fa22 f203 	lsr.w	r2, r2, r3
 8008b4e:	687b      	ldr	r3, [r7, #4]
 8008b50:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8008b52:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008b56:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008b5a:	689b      	ldr	r3, [r3, #8]
 8008b5c:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8008b60:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 8008b62:	69bb      	ldr	r3, [r7, #24]
 8008b64:	ea4f 3353 	mov.w	r3, r3, lsr #13
 8008b68:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8008b6a:	f240 0324 	movw	r3, #36	; 0x24
 8008b6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008b72:	69ba      	ldr	r2, [r7, #24]
 8008b74:	189b      	adds	r3, r3, r2
 8008b76:	781b      	ldrb	r3, [r3, #0]
 8008b78:	b2db      	uxtb	r3, r3
 8008b7a:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8008b7c:	687b      	ldr	r3, [r7, #4]
 8008b7e:	685a      	ldr	r2, [r3, #4]
 8008b80:	697b      	ldr	r3, [r7, #20]
 8008b82:	fa22 f203 	lsr.w	r2, r2, r3
 8008b86:	687b      	ldr	r3, [r7, #4]
 8008b88:	60da      	str	r2, [r3, #12]
}
 8008b8a:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8008b8e:	46bd      	mov	sp, r7
 8008b90:	bc80      	pop	{r7}
 8008b92:	4770      	bx	lr

08008b94 <RCC_RTCCLKConfig>:
  *         RTC clock source).
  *  
  * @retval None
  */
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
 8008b94:	b480      	push	{r7}
 8008b96:	b085      	sub	sp, #20
 8008b98:	af00      	add	r7, sp, #0
 8008b9a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8008b9c:	f04f 0300 	mov.w	r3, #0
 8008ba0:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 8008ba2:	687b      	ldr	r3, [r7, #4]
 8008ba4:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8008ba8:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8008bac:	d117      	bne.n	8008bde <RCC_RTCCLKConfig+0x4a>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 8008bae:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008bb2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008bb6:	689b      	ldr	r3, [r3, #8]
 8008bb8:	60fb      	str	r3, [r7, #12]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 8008bba:	68fb      	ldr	r3, [r7, #12]
 8008bbc:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8008bc0:	60fb      	str	r3, [r7, #12]

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8008bc2:	687b      	ldr	r3, [r7, #4]
 8008bc4:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8008bc8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8008bcc:	68fa      	ldr	r2, [r7, #12]
 8008bce:	4313      	orrs	r3, r2
 8008bd0:	60fb      	str	r3, [r7, #12]

    /* Store the new value */
    RCC->CFGR = tmpreg;
 8008bd2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008bd6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008bda:	68fa      	ldr	r2, [r7, #12]
 8008bdc:	609a      	str	r2, [r3, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 8008bde:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008be2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008be6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008bea:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008bee:	6f12      	ldr	r2, [r2, #112]	; 0x70
 8008bf0:	4611      	mov	r1, r2
 8008bf2:	687a      	ldr	r2, [r7, #4]
 8008bf4:	ea4f 5202 	mov.w	r2, r2, lsl #20
 8008bf8:	ea4f 5212 	mov.w	r2, r2, lsr #20
 8008bfc:	430a      	orrs	r2, r1
 8008bfe:	671a      	str	r2, [r3, #112]	; 0x70
}
 8008c00:	f107 0714 	add.w	r7, r7, #20
 8008c04:	46bd      	mov	sp, r7
 8008c06:	bc80      	pop	{r7}
 8008c08:	4770      	bx	lr
 8008c0a:	bf00      	nop

08008c0c <RCC_RTCCLKCmd>:
  *         using the RCC_RTCCLKConfig function.
  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
 8008c0c:	b480      	push	{r7}
 8008c0e:	b083      	sub	sp, #12
 8008c10:	af00      	add	r7, sp, #0
 8008c12:	4603      	mov	r3, r0
 8008c14:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8008c16:	f640 633c 	movw	r3, #3644	; 0xe3c
 8008c1a:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008c1e:	79fa      	ldrb	r2, [r7, #7]
 8008c20:	601a      	str	r2, [r3, #0]
}
 8008c22:	f107 070c 	add.w	r7, r7, #12
 8008c26:	46bd      	mov	sp, r7
 8008c28:	bc80      	pop	{r7}
 8008c2a:	4770      	bx	lr

08008c2c <RCC_BackupResetCmd>:
  * @param  NewState: new state of the Backup domain reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
 8008c2c:	b480      	push	{r7}
 8008c2e:	b083      	sub	sp, #12
 8008c30:	af00      	add	r7, sp, #0
 8008c32:	4603      	mov	r3, r0
 8008c34:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8008c36:	f44f 6364 	mov.w	r3, #3648	; 0xe40
 8008c3a:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008c3e:	79fa      	ldrb	r2, [r7, #7]
 8008c40:	601a      	str	r2, [r3, #0]
}
 8008c42:	f107 070c 	add.w	r7, r7, #12
 8008c46:	46bd      	mov	sp, r7
 8008c48:	bc80      	pop	{r7}
 8008c4a:	4770      	bx	lr

08008c4c <RCC_I2SCLKConfig>:
  *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
  *                                        used as I2S clock source
  * @retval None
  */
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
 8008c4c:	b480      	push	{r7}
 8008c4e:	b083      	sub	sp, #12
 8008c50:	af00      	add	r7, sp, #0
 8008c52:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 8008c54:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 8008c58:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8008c5c:	687a      	ldr	r2, [r7, #4]
 8008c5e:	601a      	str	r2, [r3, #0]
}
 8008c60:	f107 070c 	add.w	r7, r7, #12
 8008c64:	46bd      	mov	sp, r7
 8008c66:	bc80      	pop	{r7}
 8008c68:	4770      	bx	lr
 8008c6a:	bf00      	nop

08008c6c <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8008c6c:	b480      	push	{r7}
 8008c6e:	b083      	sub	sp, #12
 8008c70:	af00      	add	r7, sp, #0
 8008c72:	6078      	str	r0, [r7, #4]
 8008c74:	460b      	mov	r3, r1
 8008c76:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008c78:	78fb      	ldrb	r3, [r7, #3]
 8008c7a:	2b00      	cmp	r3, #0
 8008c7c:	d00d      	beq.n	8008c9a <RCC_AHB1PeriphClockCmd+0x2e>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8008c7e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008c82:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008c86:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008c8a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008c8e:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8008c90:	4611      	mov	r1, r2
 8008c92:	687a      	ldr	r2, [r7, #4]
 8008c94:	430a      	orrs	r2, r1
 8008c96:	631a      	str	r2, [r3, #48]	; 0x30
 8008c98:	e00e      	b.n	8008cb8 <RCC_AHB1PeriphClockCmd+0x4c>
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8008c9a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008c9e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ca2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008ca6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008caa:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8008cac:	4611      	mov	r1, r2
 8008cae:	687a      	ldr	r2, [r7, #4]
 8008cb0:	ea6f 0202 	mvn.w	r2, r2
 8008cb4:	400a      	ands	r2, r1
 8008cb6:	631a      	str	r2, [r3, #48]	; 0x30
  }
}
 8008cb8:	f107 070c 	add.w	r7, r7, #12
 8008cbc:	46bd      	mov	sp, r7
 8008cbe:	bc80      	pop	{r7}
 8008cc0:	4770      	bx	lr
 8008cc2:	bf00      	nop

08008cc4 <RCC_AHB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 8008cc4:	b480      	push	{r7}
 8008cc6:	b083      	sub	sp, #12
 8008cc8:	af00      	add	r7, sp, #0
 8008cca:	6078      	str	r0, [r7, #4]
 8008ccc:	460b      	mov	r3, r1
 8008cce:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008cd0:	78fb      	ldrb	r3, [r7, #3]
 8008cd2:	2b00      	cmp	r3, #0
 8008cd4:	d00d      	beq.n	8008cf2 <RCC_AHB2PeriphClockCmd+0x2e>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 8008cd6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008cda:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008cde:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008ce2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008ce6:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8008ce8:	4611      	mov	r1, r2
 8008cea:	687a      	ldr	r2, [r7, #4]
 8008cec:	430a      	orrs	r2, r1
 8008cee:	635a      	str	r2, [r3, #52]	; 0x34
 8008cf0:	e00e      	b.n	8008d10 <RCC_AHB2PeriphClockCmd+0x4c>
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 8008cf2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008cf6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008cfa:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008cfe:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008d02:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8008d04:	4611      	mov	r1, r2
 8008d06:	687a      	ldr	r2, [r7, #4]
 8008d08:	ea6f 0202 	mvn.w	r2, r2
 8008d0c:	400a      	ands	r2, r1
 8008d0e:	635a      	str	r2, [r3, #52]	; 0x34
  }
}
 8008d10:	f107 070c 	add.w	r7, r7, #12
 8008d14:	46bd      	mov	sp, r7
 8008d16:	bc80      	pop	{r7}
 8008d18:	4770      	bx	lr
 8008d1a:	bf00      	nop

08008d1c <RCC_AHB3PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 8008d1c:	b480      	push	{r7}
 8008d1e:	b083      	sub	sp, #12
 8008d20:	af00      	add	r7, sp, #0
 8008d22:	6078      	str	r0, [r7, #4]
 8008d24:	460b      	mov	r3, r1
 8008d26:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008d28:	78fb      	ldrb	r3, [r7, #3]
 8008d2a:	2b00      	cmp	r3, #0
 8008d2c:	d00d      	beq.n	8008d4a <RCC_AHB3PeriphClockCmd+0x2e>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 8008d2e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008d32:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008d36:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008d3a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008d3e:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8008d40:	4611      	mov	r1, r2
 8008d42:	687a      	ldr	r2, [r7, #4]
 8008d44:	430a      	orrs	r2, r1
 8008d46:	639a      	str	r2, [r3, #56]	; 0x38
 8008d48:	e00e      	b.n	8008d68 <RCC_AHB3PeriphClockCmd+0x4c>
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 8008d4a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008d4e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008d52:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008d56:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008d5a:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8008d5c:	4611      	mov	r1, r2
 8008d5e:	687a      	ldr	r2, [r7, #4]
 8008d60:	ea6f 0202 	mvn.w	r2, r2
 8008d64:	400a      	ands	r2, r1
 8008d66:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8008d68:	f107 070c 	add.w	r7, r7, #12
 8008d6c:	46bd      	mov	sp, r7
 8008d6e:	bc80      	pop	{r7}
 8008d70:	4770      	bx	lr
 8008d72:	bf00      	nop

08008d74 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8008d74:	b480      	push	{r7}
 8008d76:	b083      	sub	sp, #12
 8008d78:	af00      	add	r7, sp, #0
 8008d7a:	6078      	str	r0, [r7, #4]
 8008d7c:	460b      	mov	r3, r1
 8008d7e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008d80:	78fb      	ldrb	r3, [r7, #3]
 8008d82:	2b00      	cmp	r3, #0
 8008d84:	d00d      	beq.n	8008da2 <RCC_APB1PeriphClockCmd+0x2e>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8008d86:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008d8a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008d8e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008d92:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008d96:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8008d98:	4611      	mov	r1, r2
 8008d9a:	687a      	ldr	r2, [r7, #4]
 8008d9c:	430a      	orrs	r2, r1
 8008d9e:	641a      	str	r2, [r3, #64]	; 0x40
 8008da0:	e00e      	b.n	8008dc0 <RCC_APB1PeriphClockCmd+0x4c>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8008da2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008da6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008daa:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008dae:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008db2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8008db4:	4611      	mov	r1, r2
 8008db6:	687a      	ldr	r2, [r7, #4]
 8008db8:	ea6f 0202 	mvn.w	r2, r2
 8008dbc:	400a      	ands	r2, r1
 8008dbe:	641a      	str	r2, [r3, #64]	; 0x40
  }
}
 8008dc0:	f107 070c 	add.w	r7, r7, #12
 8008dc4:	46bd      	mov	sp, r7
 8008dc6:	bc80      	pop	{r7}
 8008dc8:	4770      	bx	lr
 8008dca:	bf00      	nop

08008dcc <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8008dcc:	b480      	push	{r7}
 8008dce:	b083      	sub	sp, #12
 8008dd0:	af00      	add	r7, sp, #0
 8008dd2:	6078      	str	r0, [r7, #4]
 8008dd4:	460b      	mov	r3, r1
 8008dd6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008dd8:	78fb      	ldrb	r3, [r7, #3]
 8008dda:	2b00      	cmp	r3, #0
 8008ddc:	d00d      	beq.n	8008dfa <RCC_APB2PeriphClockCmd+0x2e>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8008dde:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008de2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008de6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008dea:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008dee:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8008df0:	4611      	mov	r1, r2
 8008df2:	687a      	ldr	r2, [r7, #4]
 8008df4:	430a      	orrs	r2, r1
 8008df6:	645a      	str	r2, [r3, #68]	; 0x44
 8008df8:	e00e      	b.n	8008e18 <RCC_APB2PeriphClockCmd+0x4c>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8008dfa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008dfe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008e02:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008e06:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008e0a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8008e0c:	4611      	mov	r1, r2
 8008e0e:	687a      	ldr	r2, [r7, #4]
 8008e10:	ea6f 0202 	mvn.w	r2, r2
 8008e14:	400a      	ands	r2, r1
 8008e16:	645a      	str	r2, [r3, #68]	; 0x44
  }
}
 8008e18:	f107 070c 	add.w	r7, r7, #12
 8008e1c:	46bd      	mov	sp, r7
 8008e1e:	bc80      	pop	{r7}
 8008e20:	4770      	bx	lr
 8008e22:	bf00      	nop

08008e24 <RCC_AHB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8008e24:	b480      	push	{r7}
 8008e26:	b083      	sub	sp, #12
 8008e28:	af00      	add	r7, sp, #0
 8008e2a:	6078      	str	r0, [r7, #4]
 8008e2c:	460b      	mov	r3, r1
 8008e2e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008e30:	78fb      	ldrb	r3, [r7, #3]
 8008e32:	2b00      	cmp	r3, #0
 8008e34:	d00d      	beq.n	8008e52 <RCC_AHB1PeriphResetCmd+0x2e>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 8008e36:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008e3a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008e3e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008e42:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008e46:	6912      	ldr	r2, [r2, #16]
 8008e48:	4611      	mov	r1, r2
 8008e4a:	687a      	ldr	r2, [r7, #4]
 8008e4c:	430a      	orrs	r2, r1
 8008e4e:	611a      	str	r2, [r3, #16]
 8008e50:	e00e      	b.n	8008e70 <RCC_AHB1PeriphResetCmd+0x4c>
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 8008e52:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008e56:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008e5a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008e5e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008e62:	6912      	ldr	r2, [r2, #16]
 8008e64:	4611      	mov	r1, r2
 8008e66:	687a      	ldr	r2, [r7, #4]
 8008e68:	ea6f 0202 	mvn.w	r2, r2
 8008e6c:	400a      	ands	r2, r1
 8008e6e:	611a      	str	r2, [r3, #16]
  }
}
 8008e70:	f107 070c 	add.w	r7, r7, #12
 8008e74:	46bd      	mov	sp, r7
 8008e76:	bc80      	pop	{r7}
 8008e78:	4770      	bx	lr
 8008e7a:	bf00      	nop

08008e7c <RCC_AHB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 8008e7c:	b480      	push	{r7}
 8008e7e:	b083      	sub	sp, #12
 8008e80:	af00      	add	r7, sp, #0
 8008e82:	6078      	str	r0, [r7, #4]
 8008e84:	460b      	mov	r3, r1
 8008e86:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008e88:	78fb      	ldrb	r3, [r7, #3]
 8008e8a:	2b00      	cmp	r3, #0
 8008e8c:	d00d      	beq.n	8008eaa <RCC_AHB2PeriphResetCmd+0x2e>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 8008e8e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008e92:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008e96:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008e9a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008e9e:	6952      	ldr	r2, [r2, #20]
 8008ea0:	4611      	mov	r1, r2
 8008ea2:	687a      	ldr	r2, [r7, #4]
 8008ea4:	430a      	orrs	r2, r1
 8008ea6:	615a      	str	r2, [r3, #20]
 8008ea8:	e00e      	b.n	8008ec8 <RCC_AHB2PeriphResetCmd+0x4c>
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 8008eaa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008eae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008eb2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008eb6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008eba:	6952      	ldr	r2, [r2, #20]
 8008ebc:	4611      	mov	r1, r2
 8008ebe:	687a      	ldr	r2, [r7, #4]
 8008ec0:	ea6f 0202 	mvn.w	r2, r2
 8008ec4:	400a      	ands	r2, r1
 8008ec6:	615a      	str	r2, [r3, #20]
  }
}
 8008ec8:	f107 070c 	add.w	r7, r7, #12
 8008ecc:	46bd      	mov	sp, r7
 8008ece:	bc80      	pop	{r7}
 8008ed0:	4770      	bx	lr
 8008ed2:	bf00      	nop

08008ed4 <RCC_AHB3PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 8008ed4:	b480      	push	{r7}
 8008ed6:	b083      	sub	sp, #12
 8008ed8:	af00      	add	r7, sp, #0
 8008eda:	6078      	str	r0, [r7, #4]
 8008edc:	460b      	mov	r3, r1
 8008ede:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008ee0:	78fb      	ldrb	r3, [r7, #3]
 8008ee2:	2b00      	cmp	r3, #0
 8008ee4:	d00d      	beq.n	8008f02 <RCC_AHB3PeriphResetCmd+0x2e>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 8008ee6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008eea:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008eee:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008ef2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008ef6:	6992      	ldr	r2, [r2, #24]
 8008ef8:	4611      	mov	r1, r2
 8008efa:	687a      	ldr	r2, [r7, #4]
 8008efc:	430a      	orrs	r2, r1
 8008efe:	619a      	str	r2, [r3, #24]
 8008f00:	e00e      	b.n	8008f20 <RCC_AHB3PeriphResetCmd+0x4c>
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 8008f02:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f06:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f0a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008f0e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008f12:	6992      	ldr	r2, [r2, #24]
 8008f14:	4611      	mov	r1, r2
 8008f16:	687a      	ldr	r2, [r7, #4]
 8008f18:	ea6f 0202 	mvn.w	r2, r2
 8008f1c:	400a      	ands	r2, r1
 8008f1e:	619a      	str	r2, [r3, #24]
  }
}
 8008f20:	f107 070c 	add.w	r7, r7, #12
 8008f24:	46bd      	mov	sp, r7
 8008f26:	bc80      	pop	{r7}
 8008f28:	4770      	bx	lr
 8008f2a:	bf00      	nop

08008f2c <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8008f2c:	b480      	push	{r7}
 8008f2e:	b083      	sub	sp, #12
 8008f30:	af00      	add	r7, sp, #0
 8008f32:	6078      	str	r0, [r7, #4]
 8008f34:	460b      	mov	r3, r1
 8008f36:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008f38:	78fb      	ldrb	r3, [r7, #3]
 8008f3a:	2b00      	cmp	r3, #0
 8008f3c:	d00d      	beq.n	8008f5a <RCC_APB1PeriphResetCmd+0x2e>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8008f3e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f42:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f46:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008f4a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008f4e:	6a12      	ldr	r2, [r2, #32]
 8008f50:	4611      	mov	r1, r2
 8008f52:	687a      	ldr	r2, [r7, #4]
 8008f54:	430a      	orrs	r2, r1
 8008f56:	621a      	str	r2, [r3, #32]
 8008f58:	e00e      	b.n	8008f78 <RCC_APB1PeriphResetCmd+0x4c>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8008f5a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f5e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f62:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008f66:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008f6a:	6a12      	ldr	r2, [r2, #32]
 8008f6c:	4611      	mov	r1, r2
 8008f6e:	687a      	ldr	r2, [r7, #4]
 8008f70:	ea6f 0202 	mvn.w	r2, r2
 8008f74:	400a      	ands	r2, r1
 8008f76:	621a      	str	r2, [r3, #32]
  }
}
 8008f78:	f107 070c 	add.w	r7, r7, #12
 8008f7c:	46bd      	mov	sp, r7
 8008f7e:	bc80      	pop	{r7}
 8008f80:	4770      	bx	lr
 8008f82:	bf00      	nop

08008f84 <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8008f84:	b480      	push	{r7}
 8008f86:	b083      	sub	sp, #12
 8008f88:	af00      	add	r7, sp, #0
 8008f8a:	6078      	str	r0, [r7, #4]
 8008f8c:	460b      	mov	r3, r1
 8008f8e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008f90:	78fb      	ldrb	r3, [r7, #3]
 8008f92:	2b00      	cmp	r3, #0
 8008f94:	d00d      	beq.n	8008fb2 <RCC_APB2PeriphResetCmd+0x2e>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8008f96:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f9a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f9e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008fa2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008fa6:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8008fa8:	4611      	mov	r1, r2
 8008faa:	687a      	ldr	r2, [r7, #4]
 8008fac:	430a      	orrs	r2, r1
 8008fae:	625a      	str	r2, [r3, #36]	; 0x24
 8008fb0:	e00e      	b.n	8008fd0 <RCC_APB2PeriphResetCmd+0x4c>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8008fb2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008fb6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008fba:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008fbe:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008fc2:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8008fc4:	4611      	mov	r1, r2
 8008fc6:	687a      	ldr	r2, [r7, #4]
 8008fc8:	ea6f 0202 	mvn.w	r2, r2
 8008fcc:	400a      	ands	r2, r1
 8008fce:	625a      	str	r2, [r3, #36]	; 0x24
  }
}
 8008fd0:	f107 070c 	add.w	r7, r7, #12
 8008fd4:	46bd      	mov	sp, r7
 8008fd6:	bc80      	pop	{r7}
 8008fd8:	4770      	bx	lr
 8008fda:	bf00      	nop

08008fdc <RCC_AHB1PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8008fdc:	b480      	push	{r7}
 8008fde:	b083      	sub	sp, #12
 8008fe0:	af00      	add	r7, sp, #0
 8008fe2:	6078      	str	r0, [r7, #4]
 8008fe4:	460b      	mov	r3, r1
 8008fe6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008fe8:	78fb      	ldrb	r3, [r7, #3]
 8008fea:	2b00      	cmp	r3, #0
 8008fec:	d00d      	beq.n	800900a <RCC_AHB1PeriphClockLPModeCmd+0x2e>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 8008fee:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008ff2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ff6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008ffa:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008ffe:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8009000:	4611      	mov	r1, r2
 8009002:	687a      	ldr	r2, [r7, #4]
 8009004:	430a      	orrs	r2, r1
 8009006:	651a      	str	r2, [r3, #80]	; 0x50
 8009008:	e00e      	b.n	8009028 <RCC_AHB1PeriphClockLPModeCmd+0x4c>
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 800900a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800900e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009012:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009016:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800901a:	6d12      	ldr	r2, [r2, #80]	; 0x50
 800901c:	4611      	mov	r1, r2
 800901e:	687a      	ldr	r2, [r7, #4]
 8009020:	ea6f 0202 	mvn.w	r2, r2
 8009024:	400a      	ands	r2, r1
 8009026:	651a      	str	r2, [r3, #80]	; 0x50
  }
}
 8009028:	f107 070c 	add.w	r7, r7, #12
 800902c:	46bd      	mov	sp, r7
 800902e:	bc80      	pop	{r7}
 8009030:	4770      	bx	lr
 8009032:	bf00      	nop

08009034 <RCC_AHB2PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 8009034:	b480      	push	{r7}
 8009036:	b083      	sub	sp, #12
 8009038:	af00      	add	r7, sp, #0
 800903a:	6078      	str	r0, [r7, #4]
 800903c:	460b      	mov	r3, r1
 800903e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009040:	78fb      	ldrb	r3, [r7, #3]
 8009042:	2b00      	cmp	r3, #0
 8009044:	d00d      	beq.n	8009062 <RCC_AHB2PeriphClockLPModeCmd+0x2e>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 8009046:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800904a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800904e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009052:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009056:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8009058:	4611      	mov	r1, r2
 800905a:	687a      	ldr	r2, [r7, #4]
 800905c:	430a      	orrs	r2, r1
 800905e:	655a      	str	r2, [r3, #84]	; 0x54
 8009060:	e00e      	b.n	8009080 <RCC_AHB2PeriphClockLPModeCmd+0x4c>
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 8009062:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009066:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800906a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800906e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009072:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8009074:	4611      	mov	r1, r2
 8009076:	687a      	ldr	r2, [r7, #4]
 8009078:	ea6f 0202 	mvn.w	r2, r2
 800907c:	400a      	ands	r2, r1
 800907e:	655a      	str	r2, [r3, #84]	; 0x54
  }
}
 8009080:	f107 070c 	add.w	r7, r7, #12
 8009084:	46bd      	mov	sp, r7
 8009086:	bc80      	pop	{r7}
 8009088:	4770      	bx	lr
 800908a:	bf00      	nop

0800908c <RCC_AHB3PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 800908c:	b480      	push	{r7}
 800908e:	b083      	sub	sp, #12
 8009090:	af00      	add	r7, sp, #0
 8009092:	6078      	str	r0, [r7, #4]
 8009094:	460b      	mov	r3, r1
 8009096:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009098:	78fb      	ldrb	r3, [r7, #3]
 800909a:	2b00      	cmp	r3, #0
 800909c:	d00d      	beq.n	80090ba <RCC_AHB3PeriphClockLPModeCmd+0x2e>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 800909e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80090a2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80090a6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80090aa:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80090ae:	6d92      	ldr	r2, [r2, #88]	; 0x58
 80090b0:	4611      	mov	r1, r2
 80090b2:	687a      	ldr	r2, [r7, #4]
 80090b4:	430a      	orrs	r2, r1
 80090b6:	659a      	str	r2, [r3, #88]	; 0x58
 80090b8:	e00e      	b.n	80090d8 <RCC_AHB3PeriphClockLPModeCmd+0x4c>
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 80090ba:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80090be:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80090c2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80090c6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80090ca:	6d92      	ldr	r2, [r2, #88]	; 0x58
 80090cc:	4611      	mov	r1, r2
 80090ce:	687a      	ldr	r2, [r7, #4]
 80090d0:	ea6f 0202 	mvn.w	r2, r2
 80090d4:	400a      	ands	r2, r1
 80090d6:	659a      	str	r2, [r3, #88]	; 0x58
  }
}
 80090d8:	f107 070c 	add.w	r7, r7, #12
 80090dc:	46bd      	mov	sp, r7
 80090de:	bc80      	pop	{r7}
 80090e0:	4770      	bx	lr
 80090e2:	bf00      	nop

080090e4 <RCC_APB1PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80090e4:	b480      	push	{r7}
 80090e6:	b083      	sub	sp, #12
 80090e8:	af00      	add	r7, sp, #0
 80090ea:	6078      	str	r0, [r7, #4]
 80090ec:	460b      	mov	r3, r1
 80090ee:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80090f0:	78fb      	ldrb	r3, [r7, #3]
 80090f2:	2b00      	cmp	r3, #0
 80090f4:	d00d      	beq.n	8009112 <RCC_APB1PeriphClockLPModeCmd+0x2e>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 80090f6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80090fa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80090fe:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009102:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009106:	6e12      	ldr	r2, [r2, #96]	; 0x60
 8009108:	4611      	mov	r1, r2
 800910a:	687a      	ldr	r2, [r7, #4]
 800910c:	430a      	orrs	r2, r1
 800910e:	661a      	str	r2, [r3, #96]	; 0x60
 8009110:	e00e      	b.n	8009130 <RCC_APB1PeriphClockLPModeCmd+0x4c>
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 8009112:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009116:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800911a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800911e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009122:	6e12      	ldr	r2, [r2, #96]	; 0x60
 8009124:	4611      	mov	r1, r2
 8009126:	687a      	ldr	r2, [r7, #4]
 8009128:	ea6f 0202 	mvn.w	r2, r2
 800912c:	400a      	ands	r2, r1
 800912e:	661a      	str	r2, [r3, #96]	; 0x60
  }
}
 8009130:	f107 070c 	add.w	r7, r7, #12
 8009134:	46bd      	mov	sp, r7
 8009136:	bc80      	pop	{r7}
 8009138:	4770      	bx	lr
 800913a:	bf00      	nop

0800913c <RCC_APB2PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 800913c:	b480      	push	{r7}
 800913e:	b083      	sub	sp, #12
 8009140:	af00      	add	r7, sp, #0
 8009142:	6078      	str	r0, [r7, #4]
 8009144:	460b      	mov	r3, r1
 8009146:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009148:	78fb      	ldrb	r3, [r7, #3]
 800914a:	2b00      	cmp	r3, #0
 800914c:	d00d      	beq.n	800916a <RCC_APB2PeriphClockLPModeCmd+0x2e>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 800914e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009152:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009156:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800915a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800915e:	6e52      	ldr	r2, [r2, #100]	; 0x64
 8009160:	4611      	mov	r1, r2
 8009162:	687a      	ldr	r2, [r7, #4]
 8009164:	430a      	orrs	r2, r1
 8009166:	665a      	str	r2, [r3, #100]	; 0x64
 8009168:	e00e      	b.n	8009188 <RCC_APB2PeriphClockLPModeCmd+0x4c>
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 800916a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800916e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009172:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009176:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800917a:	6e52      	ldr	r2, [r2, #100]	; 0x64
 800917c:	4611      	mov	r1, r2
 800917e:	687a      	ldr	r2, [r7, #4]
 8009180:	ea6f 0202 	mvn.w	r2, r2
 8009184:	400a      	ands	r2, r1
 8009186:	665a      	str	r2, [r3, #100]	; 0x64
  }
}
 8009188:	f107 070c 	add.w	r7, r7, #12
 800918c:	46bd      	mov	sp, r7
 800918e:	bc80      	pop	{r7}
 8009190:	4770      	bx	lr
 8009192:	bf00      	nop

08009194 <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 8009194:	b480      	push	{r7}
 8009196:	b083      	sub	sp, #12
 8009198:	af00      	add	r7, sp, #0
 800919a:	4602      	mov	r2, r0
 800919c:	460b      	mov	r3, r1
 800919e:	71fa      	strb	r2, [r7, #7]
 80091a0:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80091a2:	79bb      	ldrb	r3, [r7, #6]
 80091a4:	2b00      	cmp	r3, #0
 80091a6:	d00e      	beq.n	80091c6 <RCC_ITConfig+0x32>
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 80091a8:	f643 030d 	movw	r3, #14349	; 0x380d
 80091ac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80091b0:	f643 020d 	movw	r2, #14349	; 0x380d
 80091b4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80091b8:	7812      	ldrb	r2, [r2, #0]
 80091ba:	b2d1      	uxtb	r1, r2
 80091bc:	79fa      	ldrb	r2, [r7, #7]
 80091be:	430a      	orrs	r2, r1
 80091c0:	b2d2      	uxtb	r2, r2
 80091c2:	701a      	strb	r2, [r3, #0]
 80091c4:	e010      	b.n	80091e8 <RCC_ITConfig+0x54>
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 80091c6:	f643 030d 	movw	r3, #14349	; 0x380d
 80091ca:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80091ce:	f643 020d 	movw	r2, #14349	; 0x380d
 80091d2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80091d6:	7812      	ldrb	r2, [r2, #0]
 80091d8:	b2d1      	uxtb	r1, r2
 80091da:	79fa      	ldrb	r2, [r7, #7]
 80091dc:	ea6f 0202 	mvn.w	r2, r2
 80091e0:	b2d2      	uxtb	r2, r2
 80091e2:	400a      	ands	r2, r1
 80091e4:	b2d2      	uxtb	r2, r2
 80091e6:	701a      	strb	r2, [r3, #0]
  }
}
 80091e8:	f107 070c 	add.w	r7, r7, #12
 80091ec:	46bd      	mov	sp, r7
 80091ee:	bc80      	pop	{r7}
 80091f0:	4770      	bx	lr
 80091f2:	bf00      	nop

080091f4 <RCC_GetFlagStatus>:
  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
  *            @arg RCC_FLAG_LPWRRST: Low Power reset
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 80091f4:	b480      	push	{r7}
 80091f6:	b087      	sub	sp, #28
 80091f8:	af00      	add	r7, sp, #0
 80091fa:	4603      	mov	r3, r0
 80091fc:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 80091fe:	f04f 0300 	mov.w	r3, #0
 8009202:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 8009204:	f04f 0300 	mov.w	r3, #0
 8009208:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
 800920a:	f04f 0300 	mov.w	r3, #0
 800920e:	74fb      	strb	r3, [r7, #19]

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8009210:	79fb      	ldrb	r3, [r7, #7]
 8009212:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8009216:	b2db      	uxtb	r3, r3
 8009218:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
 800921a:	68fb      	ldr	r3, [r7, #12]
 800921c:	2b01      	cmp	r3, #1
 800921e:	d106      	bne.n	800922e <RCC_GetFlagStatus+0x3a>
  {
    statusreg = RCC->CR;
 8009220:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009224:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009228:	681b      	ldr	r3, [r3, #0]
 800922a:	617b      	str	r3, [r7, #20]
 800922c:	e00f      	b.n	800924e <RCC_GetFlagStatus+0x5a>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 800922e:	68fb      	ldr	r3, [r7, #12]
 8009230:	2b02      	cmp	r3, #2
 8009232:	d106      	bne.n	8009242 <RCC_GetFlagStatus+0x4e>
  {
    statusreg = RCC->BDCR;
 8009234:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009238:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800923c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800923e:	617b      	str	r3, [r7, #20]
 8009240:	e005      	b.n	800924e <RCC_GetFlagStatus+0x5a>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8009242:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009246:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800924a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800924c:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 800924e:	79fb      	ldrb	r3, [r7, #7]
 8009250:	f003 031f 	and.w	r3, r3, #31
 8009254:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8009256:	68fb      	ldr	r3, [r7, #12]
 8009258:	697a      	ldr	r2, [r7, #20]
 800925a:	fa22 f303 	lsr.w	r3, r2, r3
 800925e:	f003 0301 	and.w	r3, r3, #1
 8009262:	b2db      	uxtb	r3, r3
 8009264:	2b00      	cmp	r3, #0
 8009266:	d003      	beq.n	8009270 <RCC_GetFlagStatus+0x7c>
  {
    bitstatus = SET;
 8009268:	f04f 0301 	mov.w	r3, #1
 800926c:	74fb      	strb	r3, [r7, #19]
 800926e:	e002      	b.n	8009276 <RCC_GetFlagStatus+0x82>
  }
  else
  {
    bitstatus = RESET;
 8009270:	f04f 0300 	mov.w	r3, #0
 8009274:	74fb      	strb	r3, [r7, #19]
  }
  /* Return the flag status */
  return bitstatus;
 8009276:	7cfb      	ldrb	r3, [r7, #19]
}
 8009278:	4618      	mov	r0, r3
 800927a:	f107 071c 	add.w	r7, r7, #28
 800927e:	46bd      	mov	sp, r7
 8009280:	bc80      	pop	{r7}
 8009282:	4770      	bx	lr

08009284 <RCC_ClearFlag>:
  *         RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
  * @param  None
  * @retval None
  */
void RCC_ClearFlag(void)
{
 8009284:	b480      	push	{r7}
 8009286:	af00      	add	r7, sp, #0
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 8009288:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800928c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009290:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009294:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009298:	6f52      	ldr	r2, [r2, #116]	; 0x74
 800929a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800929e:	675a      	str	r2, [r3, #116]	; 0x74
}
 80092a0:	46bd      	mov	sp, r7
 80092a2:	bc80      	pop	{r7}
 80092a4:	4770      	bx	lr
 80092a6:	bf00      	nop

080092a8 <RCC_GetITStatus>:
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval The new state of RCC_IT (SET or RESET).
  */
ITStatus RCC_GetITStatus(uint8_t RCC_IT)
{
 80092a8:	b480      	push	{r7}
 80092aa:	b085      	sub	sp, #20
 80092ac:	af00      	add	r7, sp, #0
 80092ae:	4603      	mov	r3, r0
 80092b0:	71fb      	strb	r3, [r7, #7]
  ITStatus bitstatus = RESET;
 80092b2:	f04f 0300 	mov.w	r3, #0
 80092b6:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 80092b8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80092bc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80092c0:	68db      	ldr	r3, [r3, #12]
 80092c2:	461a      	mov	r2, r3
 80092c4:	79fb      	ldrb	r3, [r7, #7]
 80092c6:	4013      	ands	r3, r2
 80092c8:	2b00      	cmp	r3, #0
 80092ca:	d003      	beq.n	80092d4 <RCC_GetITStatus+0x2c>
  {
    bitstatus = SET;
 80092cc:	f04f 0301 	mov.w	r3, #1
 80092d0:	73fb      	strb	r3, [r7, #15]
 80092d2:	e002      	b.n	80092da <RCC_GetITStatus+0x32>
  }
  else
  {
    bitstatus = RESET;
 80092d4:	f04f 0300 	mov.w	r3, #0
 80092d8:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the RCC_IT status */
  return  bitstatus;
 80092da:	7bfb      	ldrb	r3, [r7, #15]
}
 80092dc:	4618      	mov	r0, r3
 80092de:	f107 0714 	add.w	r7, r7, #20
 80092e2:	46bd      	mov	sp, r7
 80092e4:	bc80      	pop	{r7}
 80092e6:	4770      	bx	lr

080092e8 <RCC_ClearITPendingBit>:
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval None
  */
void RCC_ClearITPendingBit(uint8_t RCC_IT)
{
 80092e8:	b480      	push	{r7}
 80092ea:	b083      	sub	sp, #12
 80092ec:	af00      	add	r7, sp, #0
 80092ee:	4603      	mov	r3, r0
 80092f0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 80092f2:	f643 030e 	movw	r3, #14350	; 0x380e
 80092f6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80092fa:	79fa      	ldrb	r2, [r7, #7]
 80092fc:	701a      	strb	r2, [r3, #0]
}
 80092fe:	f107 070c 	add.w	r7, r7, #12
 8009302:	46bd      	mov	sp, r7
 8009304:	bc80      	pop	{r7}
 8009306:	4770      	bx	lr

08009308 <RTC_DeInit>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are deinitialized
  *          - ERROR: RTC registers are not deinitialized
  */
ErrorStatus RTC_DeInit(void)
{
 8009308:	b580      	push	{r7, lr}
 800930a:	b084      	sub	sp, #16
 800930c:	af00      	add	r7, sp, #0
  __IO uint32_t wutcounter = 0x00;
 800930e:	f04f 0300 	mov.w	r3, #0
 8009312:	607b      	str	r3, [r7, #4]
  uint32_t wutwfstatus = 0x00;
 8009314:	f04f 0300 	mov.w	r3, #0
 8009318:	60bb      	str	r3, [r7, #8]
  ErrorStatus status = ERROR;
 800931a:	f04f 0300 	mov.w	r3, #0
 800931e:	73fb      	strb	r3, [r7, #15]
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009320:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009324:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009328:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800932c:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800932e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009332:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009336:	f04f 0253 	mov.w	r2, #83	; 0x53
 800933a:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 800933c:	f000 f936 	bl	80095ac <RTC_EnterInitMode>
 8009340:	4603      	mov	r3, r0
 8009342:	2b00      	cmp	r3, #0
 8009344:	d103      	bne.n	800934e <RTC_DeInit+0x46>
  {
    status = ERROR;
 8009346:	f04f 0300 	mov.w	r3, #0
 800934a:	73fb      	strb	r3, [r7, #15]
 800934c:	e084      	b.n	8009458 <RTC_DeInit+0x150>
  }  
  else
  {
    /* Reset TR, DR and CR registers */
    RTC->TR = (uint32_t)0x00000000;
 800934e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009352:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009356:	f04f 0200 	mov.w	r2, #0
 800935a:	601a      	str	r2, [r3, #0]
    RTC->DR = (uint32_t)0x00002101;
 800935c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009360:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009364:	f242 1201 	movw	r2, #8449	; 0x2101
 8009368:	605a      	str	r2, [r3, #4]
    /* Reset All CR bits except CR[2:0] */
    RTC->CR &= (uint32_t)0x00000007;
 800936a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800936e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009372:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8009376:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800937a:	6892      	ldr	r2, [r2, #8]
 800937c:	f002 0207 	and.w	r2, r2, #7
 8009380:	609a      	str	r2, [r3, #8]
  
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8009382:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009386:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800938a:	68db      	ldr	r3, [r3, #12]
 800938c:	f003 0304 	and.w	r3, r3, #4
 8009390:	60bb      	str	r3, [r7, #8]
      wutcounter++;  
 8009392:	687b      	ldr	r3, [r7, #4]
 8009394:	f103 0301 	add.w	r3, r3, #1
 8009398:	607b      	str	r3, [r7, #4]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 800939a:	687b      	ldr	r3, [r7, #4]
 800939c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80093a0:	d002      	beq.n	80093a8 <RTC_DeInit+0xa0>
 80093a2:	68bb      	ldr	r3, [r7, #8]
 80093a4:	2b00      	cmp	r3, #0
 80093a6:	d0ec      	beq.n	8009382 <RTC_DeInit+0x7a>
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 80093a8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80093ac:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80093b0:	68db      	ldr	r3, [r3, #12]
 80093b2:	f003 0304 	and.w	r3, r3, #4
 80093b6:	2b00      	cmp	r3, #0
 80093b8:	d103      	bne.n	80093c2 <RTC_DeInit+0xba>
    {
      status = ERROR;
 80093ba:	f04f 0300 	mov.w	r3, #0
 80093be:	73fb      	strb	r3, [r7, #15]
 80093c0:	e04a      	b.n	8009458 <RTC_DeInit+0x150>
    }
    else
    {
      /* Reset all RTC CR register bits */
      RTC->CR &= (uint32_t)0x00000000;
 80093c2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80093c6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80093ca:	689b      	ldr	r3, [r3, #8]
 80093cc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80093d0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80093d4:	f04f 0200 	mov.w	r2, #0
 80093d8:	609a      	str	r2, [r3, #8]
      RTC->WUTR = (uint32_t)0x0000FFFF;
 80093da:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80093de:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80093e2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80093e6:	615a      	str	r2, [r3, #20]
      RTC->PRER = (uint32_t)0x007F00FF;
 80093e8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80093ec:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80093f0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80093f4:	f2c0 027f 	movt	r2, #127	; 0x7f
 80093f8:	611a      	str	r2, [r3, #16]
      RTC->CALIBR = (uint32_t)0x00000000;
 80093fa:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80093fe:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009402:	f04f 0200 	mov.w	r2, #0
 8009406:	619a      	str	r2, [r3, #24]
      RTC->ALRMAR = (uint32_t)0x00000000;        
 8009408:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800940c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009410:	f04f 0200 	mov.w	r2, #0
 8009414:	61da      	str	r2, [r3, #28]
      RTC->ALRMBR = (uint32_t)0x00000000;
 8009416:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800941a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800941e:	f04f 0200 	mov.w	r2, #0
 8009422:	621a      	str	r2, [r3, #32]
      
      /* Reset ISR register and exit initialization mode */
      RTC->ISR = (uint32_t)0x00000000;
 8009424:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009428:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800942c:	f04f 0200 	mov.w	r2, #0
 8009430:	60da      	str	r2, [r3, #12]
      
      /* Reset Tamper and alternate functions configuration register */
      RTC->TAFCR = 0x00000000;
 8009432:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009436:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800943a:	f04f 0200 	mov.w	r2, #0
 800943e:	641a      	str	r2, [r3, #64]	; 0x40
  
      if(RTC_WaitForSynchro() == ERROR)
 8009440:	f000 f910 	bl	8009664 <RTC_WaitForSynchro>
 8009444:	4603      	mov	r3, r0
 8009446:	2b00      	cmp	r3, #0
 8009448:	d103      	bne.n	8009452 <RTC_DeInit+0x14a>
      {
        status = ERROR;
 800944a:	f04f 0300 	mov.w	r3, #0
 800944e:	73fb      	strb	r3, [r7, #15]
 8009450:	e002      	b.n	8009458 <RTC_DeInit+0x150>
      }
      else
      {
        status = SUCCESS;      
 8009452:	f04f 0301 	mov.w	r3, #1
 8009456:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 8009458:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800945c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009460:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009464:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8009466:	7bfb      	ldrb	r3, [r7, #15]
}
 8009468:	4618      	mov	r0, r3
 800946a:	f107 0710 	add.w	r7, r7, #16
 800946e:	46bd      	mov	sp, r7
 8009470:	bd80      	pop	{r7, pc}
 8009472:	bf00      	nop

08009474 <RTC_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
 8009474:	b580      	push	{r7, lr}
 8009476:	b084      	sub	sp, #16
 8009478:	af00      	add	r7, sp, #0
 800947a:	6078      	str	r0, [r7, #4]
  ErrorStatus status = ERROR;
 800947c:	f04f 0300 	mov.w	r3, #0
 8009480:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009482:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009486:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800948a:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800948e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009490:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009494:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009498:	f04f 0253 	mov.w	r2, #83	; 0x53
 800949c:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 800949e:	f000 f885 	bl	80095ac <RTC_EnterInitMode>
 80094a2:	4603      	mov	r3, r0
 80094a4:	2b00      	cmp	r3, #0
 80094a6:	d103      	bne.n	80094b0 <RTC_Init+0x3c>
  {
    status = ERROR;
 80094a8:	f04f 0300 	mov.w	r3, #0
 80094ac:	73fb      	strb	r3, [r7, #15]
 80094ae:	e035      	b.n	800951c <RTC_Init+0xa8>
  } 
  else
  {
    /* Clear RTC CR FMT Bit */
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 80094b0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80094b4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80094b8:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 80094bc:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80094c0:	6892      	ldr	r2, [r2, #8]
 80094c2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80094c6:	609a      	str	r2, [r3, #8]
    /* Set RTC_CR register */
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 80094c8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80094cc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80094d0:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 80094d4:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80094d8:	6892      	ldr	r2, [r2, #8]
 80094da:	4611      	mov	r1, r2
 80094dc:	687a      	ldr	r2, [r7, #4]
 80094de:	6812      	ldr	r2, [r2, #0]
 80094e0:	430a      	orrs	r2, r1
 80094e2:	609a      	str	r2, [r3, #8]
  
    /* Configure the RTC PRER */
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 80094e4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80094e8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80094ec:	687a      	ldr	r2, [r7, #4]
 80094ee:	6892      	ldr	r2, [r2, #8]
 80094f0:	611a      	str	r2, [r3, #16]
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 80094f2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80094f6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80094fa:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 80094fe:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8009502:	6912      	ldr	r2, [r2, #16]
 8009504:	4611      	mov	r1, r2
 8009506:	687a      	ldr	r2, [r7, #4]
 8009508:	6852      	ldr	r2, [r2, #4]
 800950a:	ea4f 4202 	mov.w	r2, r2, lsl #16
 800950e:	430a      	orrs	r2, r1
 8009510:	611a      	str	r2, [r3, #16]

    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8009512:	f000 f895 	bl	8009640 <RTC_ExitInitMode>

    status = SUCCESS;    
 8009516:	f04f 0301 	mov.w	r3, #1
 800951a:	73fb      	strb	r3, [r7, #15]
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800951c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009520:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009524:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009528:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 800952a:	7bfb      	ldrb	r3, [r7, #15]
}
 800952c:	4618      	mov	r0, r3
 800952e:	f107 0710 	add.w	r7, r7, #16
 8009532:	46bd      	mov	sp, r7
 8009534:	bd80      	pop	{r7, pc}
 8009536:	bf00      	nop

08009538 <RTC_StructInit>:
  * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
{
 8009538:	b480      	push	{r7}
 800953a:	b083      	sub	sp, #12
 800953c:	af00      	add	r7, sp, #0
 800953e:	6078      	str	r0, [r7, #4]
  /* Initialize the RTC_HourFormat member */
  RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
 8009540:	687b      	ldr	r3, [r7, #4]
 8009542:	f04f 0200 	mov.w	r2, #0
 8009546:	601a      	str	r2, [r3, #0]
    
  /* Initialize the RTC_AsynchPrediv member */
  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
 8009548:	687b      	ldr	r3, [r7, #4]
 800954a:	f04f 027f 	mov.w	r2, #127	; 0x7f
 800954e:	605a      	str	r2, [r3, #4]

  /* Initialize the RTC_SynchPrediv member */
  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 8009550:	687b      	ldr	r3, [r7, #4]
 8009552:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009556:	609a      	str	r2, [r3, #8]
}
 8009558:	f107 070c 	add.w	r7, r7, #12
 800955c:	46bd      	mov	sp, r7
 800955e:	bc80      	pop	{r7}
 8009560:	4770      	bx	lr
 8009562:	bf00      	nop

08009564 <RTC_WriteProtectionCmd>:
  * @param  NewState: new state of the write protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_WriteProtectionCmd(FunctionalState NewState)
{
 8009564:	b480      	push	{r7}
 8009566:	b083      	sub	sp, #12
 8009568:	af00      	add	r7, sp, #0
 800956a:	4603      	mov	r3, r0
 800956c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 800956e:	79fb      	ldrb	r3, [r7, #7]
 8009570:	2b00      	cmp	r3, #0
 8009572:	d007      	beq.n	8009584 <RTC_WriteProtectionCmd+0x20>
  {
    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;   
 8009574:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009578:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800957c:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009580:	625a      	str	r2, [r3, #36]	; 0x24
 8009582:	e00d      	b.n	80095a0 <RTC_WriteProtectionCmd+0x3c>
  }
  else
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
 8009584:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009588:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800958c:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009590:	625a      	str	r2, [r3, #36]	; 0x24
    RTC->WPR = 0x53;    
 8009592:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009596:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800959a:	f04f 0253 	mov.w	r2, #83	; 0x53
 800959e:	625a      	str	r2, [r3, #36]	; 0x24
  }
}
 80095a0:	f107 070c 	add.w	r7, r7, #12
 80095a4:	46bd      	mov	sp, r7
 80095a6:	bc80      	pop	{r7}
 80095a8:	4770      	bx	lr
 80095aa:	bf00      	nop

080095ac <RTC_EnterInitMode>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode  
  */
ErrorStatus RTC_EnterInitMode(void)
{
 80095ac:	b480      	push	{r7}
 80095ae:	b085      	sub	sp, #20
 80095b0:	af00      	add	r7, sp, #0
  __IO uint32_t initcounter = 0x00;
 80095b2:	f04f 0300 	mov.w	r3, #0
 80095b6:	607b      	str	r3, [r7, #4]
  ErrorStatus status = ERROR;
 80095b8:	f04f 0300 	mov.w	r3, #0
 80095bc:	73fb      	strb	r3, [r7, #15]
  uint32_t initstatus = 0x00;
 80095be:	f04f 0300 	mov.w	r3, #0
 80095c2:	60bb      	str	r3, [r7, #8]
     
  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80095c4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80095c8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80095cc:	68db      	ldr	r3, [r3, #12]
 80095ce:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80095d2:	2b00      	cmp	r3, #0
 80095d4:	d12a      	bne.n	800962c <RTC_EnterInitMode+0x80>
  {
    /* Set the Initialization mode */
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
 80095d6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80095da:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80095de:	f04f 32ff 	mov.w	r2, #4294967295
 80095e2:	60da      	str	r2, [r3, #12]
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
 80095e4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80095e8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80095ec:	68db      	ldr	r3, [r3, #12]
 80095ee:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80095f2:	60bb      	str	r3, [r7, #8]
      initcounter++;  
 80095f4:	687b      	ldr	r3, [r7, #4]
 80095f6:	f103 0301 	add.w	r3, r3, #1
 80095fa:	607b      	str	r3, [r7, #4]
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 80095fc:	687b      	ldr	r3, [r7, #4]
 80095fe:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8009602:	d002      	beq.n	800960a <RTC_EnterInitMode+0x5e>
 8009604:	68bb      	ldr	r3, [r7, #8]
 8009606:	2b00      	cmp	r3, #0
 8009608:	d0ec      	beq.n	80095e4 <RTC_EnterInitMode+0x38>
    
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 800960a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800960e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009612:	68db      	ldr	r3, [r3, #12]
 8009614:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009618:	2b00      	cmp	r3, #0
 800961a:	d003      	beq.n	8009624 <RTC_EnterInitMode+0x78>
    {
      status = SUCCESS;
 800961c:	f04f 0301 	mov.w	r3, #1
 8009620:	73fb      	strb	r3, [r7, #15]
 8009622:	e006      	b.n	8009632 <RTC_EnterInitMode+0x86>
    }
    else
    {
      status = ERROR;
 8009624:	f04f 0300 	mov.w	r3, #0
 8009628:	73fb      	strb	r3, [r7, #15]
 800962a:	e002      	b.n	8009632 <RTC_EnterInitMode+0x86>
    }        
  }
  else
  {
    status = SUCCESS;  
 800962c:	f04f 0301 	mov.w	r3, #1
 8009630:	73fb      	strb	r3, [r7, #15]
  } 
    
  return (status);  
 8009632:	7bfb      	ldrb	r3, [r7, #15]
}
 8009634:	4618      	mov	r0, r3
 8009636:	f107 0714 	add.w	r7, r7, #20
 800963a:	46bd      	mov	sp, r7
 800963c:	bc80      	pop	{r7}
 800963e:	4770      	bx	lr

08009640 <RTC_ExitInitMode>:
  *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
  * @param  None
  * @retval None
  */
void RTC_ExitInitMode(void)
{ 
 8009640:	b480      	push	{r7}
 8009642:	af00      	add	r7, sp, #0
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
 8009644:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009648:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800964c:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8009650:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8009654:	68d2      	ldr	r2, [r2, #12]
 8009656:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800965a:	60da      	str	r2, [r3, #12]
}
 800965c:	46bd      	mov	sp, r7
 800965e:	bc80      	pop	{r7}
 8009660:	4770      	bx	lr
 8009662:	bf00      	nop

08009664 <RTC_WaitForSynchro>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
 8009664:	b480      	push	{r7}
 8009666:	b085      	sub	sp, #20
 8009668:	af00      	add	r7, sp, #0
  __IO uint32_t synchrocounter = 0;
 800966a:	f04f 0300 	mov.w	r3, #0
 800966e:	607b      	str	r3, [r7, #4]
  ErrorStatus status = ERROR;
 8009670:	f04f 0300 	mov.w	r3, #0
 8009674:	73fb      	strb	r3, [r7, #15]
  uint32_t synchrostatus = 0x00;
 8009676:	f04f 0300 	mov.w	r3, #0
 800967a:	60bb      	str	r3, [r7, #8]

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800967c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009680:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009684:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009688:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800968a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800968e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009692:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009696:	625a      	str	r2, [r3, #36]	; 0x24
    
  /* Clear RSF flag */
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 8009698:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800969c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80096a0:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 80096a4:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80096a8:	68d2      	ldr	r2, [r2, #12]
 80096aa:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 80096ae:	60da      	str	r2, [r3, #12]
    
  /* Wait the registers to be synchronised */
  do
  {
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
 80096b0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80096b4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80096b8:	68db      	ldr	r3, [r3, #12]
 80096ba:	f003 0320 	and.w	r3, r3, #32
 80096be:	60bb      	str	r3, [r7, #8]
    synchrocounter++;  
 80096c0:	687b      	ldr	r3, [r7, #4]
 80096c2:	f103 0301 	add.w	r3, r3, #1
 80096c6:	607b      	str	r3, [r7, #4]
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 80096c8:	687b      	ldr	r3, [r7, #4]
 80096ca:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80096ce:	d002      	beq.n	80096d6 <RTC_WaitForSynchro+0x72>
 80096d0:	68bb      	ldr	r3, [r7, #8]
 80096d2:	2b00      	cmp	r3, #0
 80096d4:	d0ec      	beq.n	80096b0 <RTC_WaitForSynchro+0x4c>
    
  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 80096d6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80096da:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80096de:	68db      	ldr	r3, [r3, #12]
 80096e0:	f003 0320 	and.w	r3, r3, #32
 80096e4:	2b00      	cmp	r3, #0
 80096e6:	d003      	beq.n	80096f0 <RTC_WaitForSynchro+0x8c>
  {
    status = SUCCESS;
 80096e8:	f04f 0301 	mov.w	r3, #1
 80096ec:	73fb      	strb	r3, [r7, #15]
 80096ee:	e002      	b.n	80096f6 <RTC_WaitForSynchro+0x92>
  }
  else
  {
    status = ERROR;
 80096f0:	f04f 0300 	mov.w	r3, #0
 80096f4:	73fb      	strb	r3, [r7, #15]
  }        

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80096f6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80096fa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80096fe:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009702:	625a      	str	r2, [r3, #36]	; 0x24
    
  return (status); 
 8009704:	7bfb      	ldrb	r3, [r7, #15]
}
 8009706:	4618      	mov	r0, r3
 8009708:	f107 0714 	add.w	r7, r7, #20
 800970c:	46bd      	mov	sp, r7
 800970e:	bc80      	pop	{r7}
 8009710:	4770      	bx	lr
 8009712:	bf00      	nop

08009714 <RTC_RefClockCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC reference clock detection is enabled
  *          - ERROR: RTC reference clock detection is disabled  
  */
ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
{ 
 8009714:	b580      	push	{r7, lr}
 8009716:	b084      	sub	sp, #16
 8009718:	af00      	add	r7, sp, #0
 800971a:	4603      	mov	r3, r0
 800971c:	71fb      	strb	r3, [r7, #7]
  ErrorStatus status = ERROR;
 800971e:	f04f 0300 	mov.w	r3, #0
 8009722:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009724:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009728:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800972c:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009730:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009732:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009736:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800973a:	f04f 0253 	mov.w	r2, #83	; 0x53
 800973e:	625a      	str	r2, [r3, #36]	; 0x24
    
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8009740:	f7ff ff34 	bl	80095ac <RTC_EnterInitMode>
 8009744:	4603      	mov	r3, r0
 8009746:	2b00      	cmp	r3, #0
 8009748:	d103      	bne.n	8009752 <RTC_RefClockCmd+0x3e>
  {
    status = ERROR;
 800974a:	f04f 0300 	mov.w	r3, #0
 800974e:	73fb      	strb	r3, [r7, #15]
 8009750:	e020      	b.n	8009794 <RTC_RefClockCmd+0x80>
  } 
  else
  {  
    if (NewState != DISABLE)
 8009752:	79fb      	ldrb	r3, [r7, #7]
 8009754:	2b00      	cmp	r3, #0
 8009756:	d00c      	beq.n	8009772 <RTC_RefClockCmd+0x5e>
    {
      /* Enable the RTC reference clock detection */
      RTC->CR |= RTC_CR_REFCKON;   
 8009758:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800975c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009760:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8009764:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8009768:	6892      	ldr	r2, [r2, #8]
 800976a:	f042 0210 	orr.w	r2, r2, #16
 800976e:	609a      	str	r2, [r3, #8]
 8009770:	e00b      	b.n	800978a <RTC_RefClockCmd+0x76>
    }
    else
    {
      /* Disable the RTC reference clock detection */
      RTC->CR &= ~RTC_CR_REFCKON;    
 8009772:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009776:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800977a:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800977e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8009782:	6892      	ldr	r2, [r2, #8]
 8009784:	f022 0210 	bic.w	r2, r2, #16
 8009788:	609a      	str	r2, [r3, #8]
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 800978a:	f7ff ff59 	bl	8009640 <RTC_ExitInitMode>
    
    status = SUCCESS;
 800978e:	f04f 0301 	mov.w	r3, #1
 8009792:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 8009794:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009798:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800979c:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80097a0:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status; 
 80097a2:	7bfb      	ldrb	r3, [r7, #15]
}
 80097a4:	4618      	mov	r0, r3
 80097a6:	f107 0710 	add.w	r7, r7, #16
 80097aa:	46bd      	mov	sp, r7
 80097ac:	bd80      	pop	{r7, pc}
 80097ae:	bf00      	nop

080097b0 <RTC_BypassShadowCmd>:
  * @param  NewState: new state of the Bypass Shadow feature.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
*/
void RTC_BypassShadowCmd(FunctionalState NewState)
{
 80097b0:	b480      	push	{r7}
 80097b2:	b083      	sub	sp, #12
 80097b4:	af00      	add	r7, sp, #0
 80097b6:	4603      	mov	r3, r0
 80097b8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80097ba:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80097be:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80097c2:	f04f 02ca 	mov.w	r2, #202	; 0xca
 80097c6:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80097c8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80097cc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80097d0:	f04f 0253 	mov.w	r2, #83	; 0x53
 80097d4:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
 80097d6:	79fb      	ldrb	r3, [r7, #7]
 80097d8:	2b00      	cmp	r3, #0
 80097da:	d00c      	beq.n	80097f6 <RTC_BypassShadowCmd+0x46>
  {
    /* Set the BYPSHAD bit */
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 80097dc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80097e0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80097e4:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 80097e8:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80097ec:	6892      	ldr	r2, [r2, #8]
 80097ee:	f042 0220 	orr.w	r2, r2, #32
 80097f2:	609a      	str	r2, [r3, #8]
 80097f4:	e00b      	b.n	800980e <RTC_BypassShadowCmd+0x5e>
  }
  else
  {
    /* Reset the BYPSHAD bit */
    RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
 80097f6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80097fa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80097fe:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8009802:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8009806:	6892      	ldr	r2, [r2, #8]
 8009808:	f002 02df 	and.w	r2, r2, #223	; 0xdf
 800980c:	609a      	str	r2, [r3, #8]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 800980e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009812:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009816:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800981a:	625a      	str	r2, [r3, #36]	; 0x24
}
 800981c:	f107 070c 	add.w	r7, r7, #12
 8009820:	46bd      	mov	sp, r7
 8009822:	bc80      	pop	{r7}
 8009824:	4770      	bx	lr
 8009826:	bf00      	nop

08009828 <RTC_SetTime>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Time register is configured
  *          - ERROR: RTC Time register is not configured
  */
ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8009828:	b590      	push	{r4, r7, lr}
 800982a:	b085      	sub	sp, #20
 800982c:	af00      	add	r7, sp, #0
 800982e:	6078      	str	r0, [r7, #4]
 8009830:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8009832:	f04f 0300 	mov.w	r3, #0
 8009836:	60fb      	str	r3, [r7, #12]
  ErrorStatus status = ERROR;
 8009838:	f04f 0300 	mov.w	r3, #0
 800983c:	72fb      	strb	r3, [r7, #11]
    
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
 800983e:	687b      	ldr	r3, [r7, #4]
 8009840:	2b00      	cmp	r3, #0
 8009842:	d10d      	bne.n	8009860 <RTC_SetTime+0x38>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8009844:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009848:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800984c:	689b      	ldr	r3, [r3, #8]
 800984e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009852:	2b00      	cmp	r3, #0
 8009854:	d119      	bne.n	800988a <RTC_SetTime+0x62>
      assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8009856:	683b      	ldr	r3, [r7, #0]
 8009858:	f04f 0200 	mov.w	r2, #0
 800985c:	70da      	strb	r2, [r3, #3]
 800985e:	e014      	b.n	800988a <RTC_SetTime+0x62>
    assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8009860:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009864:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009868:	689b      	ldr	r3, [r3, #8]
 800986a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800986e:	2b00      	cmp	r3, #0
 8009870:	d007      	beq.n	8009882 <RTC_SetTime+0x5a>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8009872:	683b      	ldr	r3, [r7, #0]
 8009874:	781b      	ldrb	r3, [r3, #0]
 8009876:	4618      	mov	r0, r3
 8009878:	f001 fb32 	bl	800aee0 <RTC_Bcd2ToByte>
 800987c:	4603      	mov	r3, r0
 800987e:	60fb      	str	r3, [r7, #12]
 8009880:	e003      	b.n	800988a <RTC_SetTime+0x62>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8009882:	683b      	ldr	r3, [r7, #0]
 8009884:	f04f 0200 	mov.w	r2, #0
 8009888:	70da      	strb	r2, [r3, #3]
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 800988a:	687b      	ldr	r3, [r7, #4]
 800988c:	2b00      	cmp	r3, #0
 800988e:	d012      	beq.n	80098b6 <RTC_SetTime+0x8e>
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8009890:	683b      	ldr	r3, [r7, #0]
 8009892:	781b      	ldrb	r3, [r3, #0]
 8009894:	ea4f 4203 	mov.w	r2, r3, lsl #16
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8009898:	683b      	ldr	r3, [r7, #0]
 800989a:	785b      	ldrb	r3, [r3, #1]
 800989c:	ea4f 2303 	mov.w	r3, r3, lsl #8
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 80098a0:	431a      	orrs	r2, r3
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 80098a2:	683b      	ldr	r3, [r7, #0]
 80098a4:	789b      	ldrb	r3, [r3, #2]
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 80098a6:	431a      	orrs	r2, r3
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 80098a8:	683b      	ldr	r3, [r7, #0]
 80098aa:	78db      	ldrb	r3, [r3, #3]
 80098ac:	ea4f 4303 	mov.w	r3, r3, lsl #16
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 80098b0:	4313      	orrs	r3, r2
 80098b2:	60fb      	str	r3, [r7, #12]
 80098b4:	e01e      	b.n	80098f4 <RTC_SetTime+0xcc>
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 80098b6:	683b      	ldr	r3, [r7, #0]
 80098b8:	781b      	ldrb	r3, [r3, #0]
 80098ba:	4618      	mov	r0, r3
 80098bc:	f001 faee 	bl	800ae9c <RTC_ByteToBcd2>
 80098c0:	4603      	mov	r3, r0
 80098c2:	ea4f 4403 	mov.w	r4, r3, lsl #16
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 80098c6:	683b      	ldr	r3, [r7, #0]
 80098c8:	785b      	ldrb	r3, [r3, #1]
 80098ca:	4618      	mov	r0, r3
 80098cc:	f001 fae6 	bl	800ae9c <RTC_ByteToBcd2>
 80098d0:	4603      	mov	r3, r0
 80098d2:	ea4f 2303 	mov.w	r3, r3, lsl #8
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 80098d6:	431c      	orrs	r4, r3
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 80098d8:	683b      	ldr	r3, [r7, #0]
 80098da:	789b      	ldrb	r3, [r3, #2]
 80098dc:	4618      	mov	r0, r3
 80098de:	f001 fadd 	bl	800ae9c <RTC_ByteToBcd2>
 80098e2:	4603      	mov	r3, r0
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 80098e4:	ea44 0203 	orr.w	r2, r4, r3
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 80098e8:	683b      	ldr	r3, [r7, #0]
 80098ea:	78db      	ldrb	r3, [r3, #3]
 80098ec:	ea4f 4303 	mov.w	r3, r3, lsl #16
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 80098f0:	4313      	orrs	r3, r2
 80098f2:	60fb      	str	r3, [r7, #12]
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
  }  

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80098f4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80098f8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80098fc:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009900:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009902:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009906:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800990a:	f04f 0253 	mov.w	r2, #83	; 0x53
 800990e:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8009910:	f7ff fe4c 	bl	80095ac <RTC_EnterInitMode>
 8009914:	4603      	mov	r3, r0
 8009916:	2b00      	cmp	r3, #0
 8009918:	d103      	bne.n	8009922 <RTC_SetTime+0xfa>
  {
    status = ERROR;
 800991a:	f04f 0300 	mov.w	r3, #0
 800991e:	72fb      	strb	r3, [r7, #11]
 8009920:	e018      	b.n	8009954 <RTC_SetTime+0x12c>
  } 
  else
  {
    /* Set the RTC_TR register */
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8009922:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8009926:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800992a:	68f9      	ldr	r1, [r7, #12]
 800992c:	f647 737f 	movw	r3, #32639	; 0x7f7f
 8009930:	f2c0 037f 	movt	r3, #127	; 0x7f
 8009934:	400b      	ands	r3, r1
 8009936:	6013      	str	r3, [r2, #0]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 8009938:	f7ff fe82 	bl	8009640 <RTC_ExitInitMode>

    if(RTC_WaitForSynchro() == ERROR)
 800993c:	f7ff fe92 	bl	8009664 <RTC_WaitForSynchro>
 8009940:	4603      	mov	r3, r0
 8009942:	2b00      	cmp	r3, #0
 8009944:	d103      	bne.n	800994e <RTC_SetTime+0x126>
    {
      status = ERROR;
 8009946:	f04f 0300 	mov.w	r3, #0
 800994a:	72fb      	strb	r3, [r7, #11]
 800994c:	e002      	b.n	8009954 <RTC_SetTime+0x12c>
    }
    else
    {
      status = SUCCESS;
 800994e:	f04f 0301 	mov.w	r3, #1
 8009952:	72fb      	strb	r3, [r7, #11]
    }
  
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8009954:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009958:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800995c:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009960:	625a      	str	r2, [r3, #36]	; 0x24
    
  return status;
 8009962:	7afb      	ldrb	r3, [r7, #11]
}
 8009964:	4618      	mov	r0, r3
 8009966:	f107 0714 	add.w	r7, r7, #20
 800996a:	46bd      	mov	sp, r7
 800996c:	bd90      	pop	{r4, r7, pc}
 800996e:	bf00      	nop

08009970 <RTC_TimeStructInit>:
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
{
 8009970:	b480      	push	{r7}
 8009972:	b083      	sub	sp, #12
 8009974:	af00      	add	r7, sp, #0
 8009976:	6078      	str	r0, [r7, #4]
  /* Time = 00h:00min:00sec */
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 8009978:	687b      	ldr	r3, [r7, #4]
 800997a:	f04f 0200 	mov.w	r2, #0
 800997e:	70da      	strb	r2, [r3, #3]
  RTC_TimeStruct->RTC_Hours = 0;
 8009980:	687b      	ldr	r3, [r7, #4]
 8009982:	f04f 0200 	mov.w	r2, #0
 8009986:	701a      	strb	r2, [r3, #0]
  RTC_TimeStruct->RTC_Minutes = 0;
 8009988:	687b      	ldr	r3, [r7, #4]
 800998a:	f04f 0200 	mov.w	r2, #0
 800998e:	705a      	strb	r2, [r3, #1]
  RTC_TimeStruct->RTC_Seconds = 0; 
 8009990:	687b      	ldr	r3, [r7, #4]
 8009992:	f04f 0200 	mov.w	r2, #0
 8009996:	709a      	strb	r2, [r3, #2]
}
 8009998:	f107 070c 	add.w	r7, r7, #12
 800999c:	46bd      	mov	sp, r7
 800999e:	bc80      	pop	{r7}
 80099a0:	4770      	bx	lr
 80099a2:	bf00      	nop

080099a4 <RTC_GetTime>:
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                        contain the returned current time configuration.     
  * @retval None
  */
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 80099a4:	b580      	push	{r7, lr}
 80099a6:	b084      	sub	sp, #16
 80099a8:	af00      	add	r7, sp, #0
 80099aa:	6078      	str	r0, [r7, #4]
 80099ac:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 80099ae:	f04f 0300 	mov.w	r3, #0
 80099b2:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 80099b4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 80099b8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80099bc:	681b      	ldr	r3, [r3, #0]
 80099be:	461a      	mov	r2, r3
 80099c0:	f647 737f 	movw	r3, #32639	; 0x7f7f
 80099c4:	f2c0 037f 	movt	r3, #127	; 0x7f
 80099c8:	4013      	ands	r3, r2
 80099ca:	60fb      	str	r3, [r7, #12]
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 80099cc:	68fb      	ldr	r3, [r7, #12]
 80099ce:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 80099d2:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80099d6:	b2da      	uxtb	r2, r3
 80099d8:	683b      	ldr	r3, [r7, #0]
 80099da:	701a      	strb	r2, [r3, #0]
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 80099dc:	68fb      	ldr	r3, [r7, #12]
 80099de:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 80099e2:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80099e6:	b2da      	uxtb	r2, r3
 80099e8:	683b      	ldr	r3, [r7, #0]
 80099ea:	705a      	strb	r2, [r3, #1]
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 80099ec:	68fb      	ldr	r3, [r7, #12]
 80099ee:	b2db      	uxtb	r3, r3
 80099f0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80099f4:	b2da      	uxtb	r2, r3
 80099f6:	683b      	ldr	r3, [r7, #0]
 80099f8:	709a      	strb	r2, [r3, #2]
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 80099fa:	68fb      	ldr	r3, [r7, #12]
 80099fc:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8009a00:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009a04:	b2da      	uxtb	r2, r3
 8009a06:	683b      	ldr	r3, [r7, #0]
 8009a08:	70da      	strb	r2, [r3, #3]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8009a0a:	687b      	ldr	r3, [r7, #4]
 8009a0c:	2b00      	cmp	r3, #0
 8009a0e:	d11a      	bne.n	8009a46 <RTC_GetTime+0xa2>
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8009a10:	683b      	ldr	r3, [r7, #0]
 8009a12:	781b      	ldrb	r3, [r3, #0]
 8009a14:	4618      	mov	r0, r3
 8009a16:	f001 fa63 	bl	800aee0 <RTC_Bcd2ToByte>
 8009a1a:	4603      	mov	r3, r0
 8009a1c:	461a      	mov	r2, r3
 8009a1e:	683b      	ldr	r3, [r7, #0]
 8009a20:	701a      	strb	r2, [r3, #0]
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 8009a22:	683b      	ldr	r3, [r7, #0]
 8009a24:	785b      	ldrb	r3, [r3, #1]
 8009a26:	4618      	mov	r0, r3
 8009a28:	f001 fa5a 	bl	800aee0 <RTC_Bcd2ToByte>
 8009a2c:	4603      	mov	r3, r0
 8009a2e:	461a      	mov	r2, r3
 8009a30:	683b      	ldr	r3, [r7, #0]
 8009a32:	705a      	strb	r2, [r3, #1]
    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
 8009a34:	683b      	ldr	r3, [r7, #0]
 8009a36:	789b      	ldrb	r3, [r3, #2]
 8009a38:	4618      	mov	r0, r3
 8009a3a:	f001 fa51 	bl	800aee0 <RTC_Bcd2ToByte>
 8009a3e:	4603      	mov	r3, r0
 8009a40:	461a      	mov	r2, r3
 8009a42:	683b      	ldr	r3, [r7, #0]
 8009a44:	709a      	strb	r2, [r3, #2]
  }
}
 8009a46:	f107 0710 	add.w	r7, r7, #16
 8009a4a:	46bd      	mov	sp, r7
 8009a4c:	bd80      	pop	{r7, pc}
 8009a4e:	bf00      	nop

08009a50 <RTC_GetSubSecond>:
  *         SSR register.
  * @param  None
  * @retval RTC current Calendar Subseconds value.
  */
uint32_t RTC_GetSubSecond(void)
{
 8009a50:	b480      	push	{r7}
 8009a52:	b083      	sub	sp, #12
 8009a54:	af00      	add	r7, sp, #0
  uint32_t tmpreg = 0;
 8009a56:	f04f 0300 	mov.w	r3, #0
 8009a5a:	607b      	str	r3, [r7, #4]
  
  /* Get subseconds values from the correspondent registers*/
  tmpreg = (uint32_t)(RTC->SSR);
 8009a5c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009a60:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009a64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009a66:	607b      	str	r3, [r7, #4]
  
  /* Read DR register to unfroze calendar registers */
  (void) (RTC->DR);
 8009a68:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009a6c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009a70:	685b      	ldr	r3, [r3, #4]
  
  return (tmpreg);
 8009a72:	687b      	ldr	r3, [r7, #4]
}
 8009a74:	4618      	mov	r0, r3
 8009a76:	f107 070c 	add.w	r7, r7, #12
 8009a7a:	46bd      	mov	sp, r7
 8009a7c:	bc80      	pop	{r7}
 8009a7e:	4770      	bx	lr

08009a80 <RTC_SetDate>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Date register is configured
  *          - ERROR: RTC Date register is not configured
  */
ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8009a80:	b590      	push	{r4, r7, lr}
 8009a82:	b085      	sub	sp, #20
 8009a84:	af00      	add	r7, sp, #0
 8009a86:	6078      	str	r0, [r7, #4]
 8009a88:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8009a8a:	f04f 0300 	mov.w	r3, #0
 8009a8e:	60fb      	str	r3, [r7, #12]
  ErrorStatus status = ERROR;
 8009a90:	f04f 0300 	mov.w	r3, #0
 8009a94:	72fb      	strb	r3, [r7, #11]
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 8009a96:	687b      	ldr	r3, [r7, #4]
 8009a98:	2b00      	cmp	r3, #0
 8009a9a:	d10f      	bne.n	8009abc <RTC_SetDate+0x3c>
 8009a9c:	683b      	ldr	r3, [r7, #0]
 8009a9e:	785b      	ldrb	r3, [r3, #1]
 8009aa0:	f003 0310 	and.w	r3, r3, #16
 8009aa4:	2b00      	cmp	r3, #0
 8009aa6:	d009      	beq.n	8009abc <RTC_SetDate+0x3c>
  {
    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 8009aa8:	683b      	ldr	r3, [r7, #0]
 8009aaa:	785b      	ldrb	r3, [r3, #1]
 8009aac:	f023 0310 	bic.w	r3, r3, #16
 8009ab0:	b2db      	uxtb	r3, r3
 8009ab2:	f103 030a 	add.w	r3, r3, #10
 8009ab6:	b2da      	uxtb	r2, r3
 8009ab8:	683b      	ldr	r3, [r7, #0]
 8009aba:	705a      	strb	r2, [r3, #1]
  }  
  if (RTC_Format == RTC_Format_BIN)
 8009abc:	687b      	ldr	r3, [r7, #4]
 8009abe:	2b00      	cmp	r3, #0
 8009ac0:	d00d      	beq.n	8009ade <RTC_SetDate+0x5e>
    assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
  }
  else
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 8009ac2:	683b      	ldr	r3, [r7, #0]
 8009ac4:	785b      	ldrb	r3, [r3, #1]
 8009ac6:	4618      	mov	r0, r3
 8009ac8:	f001 fa0a 	bl	800aee0 <RTC_Bcd2ToByte>
 8009acc:	4603      	mov	r3, r0
 8009ace:	60fb      	str	r3, [r7, #12]
    assert_param(IS_RTC_MONTH(tmpreg));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 8009ad0:	683b      	ldr	r3, [r7, #0]
 8009ad2:	789b      	ldrb	r3, [r3, #2]
 8009ad4:	4618      	mov	r0, r3
 8009ad6:	f001 fa03 	bl	800aee0 <RTC_Bcd2ToByte>
 8009ada:	4603      	mov	r3, r0
 8009adc:	60fb      	str	r3, [r7, #12]
    assert_param(IS_RTC_DATE(tmpreg));
  }
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 8009ade:	687b      	ldr	r3, [r7, #4]
 8009ae0:	2b00      	cmp	r3, #0
 8009ae2:	d012      	beq.n	8009b0a <RTC_SetDate+0x8a>
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8009ae4:	683b      	ldr	r3, [r7, #0]
 8009ae6:	78db      	ldrb	r3, [r3, #3]
 8009ae8:	ea4f 4203 	mov.w	r2, r3, lsl #16
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8009aec:	683b      	ldr	r3, [r7, #0]
 8009aee:	785b      	ldrb	r3, [r3, #1]
 8009af0:	ea4f 2303 	mov.w	r3, r3, lsl #8
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8009af4:	431a      	orrs	r2, r3
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
 8009af6:	683b      	ldr	r3, [r7, #0]
 8009af8:	789b      	ldrb	r3, [r3, #2]

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8009afa:	431a      	orrs	r2, r3
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 8009afc:	683b      	ldr	r3, [r7, #0]
 8009afe:	781b      	ldrb	r3, [r3, #0]
 8009b00:	ea4f 3343 	mov.w	r3, r3, lsl #13
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8009b04:	4313      	orrs	r3, r2
 8009b06:	60fb      	str	r3, [r7, #12]
 8009b08:	e01e      	b.n	8009b48 <RTC_SetDate+0xc8>
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8009b0a:	683b      	ldr	r3, [r7, #0]
 8009b0c:	78db      	ldrb	r3, [r3, #3]
 8009b0e:	4618      	mov	r0, r3
 8009b10:	f001 f9c4 	bl	800ae9c <RTC_ByteToBcd2>
 8009b14:	4603      	mov	r3, r0
 8009b16:	ea4f 4403 	mov.w	r4, r3, lsl #16
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8009b1a:	683b      	ldr	r3, [r7, #0]
 8009b1c:	785b      	ldrb	r3, [r3, #1]
 8009b1e:	4618      	mov	r0, r3
 8009b20:	f001 f9bc 	bl	800ae9c <RTC_ByteToBcd2>
 8009b24:	4603      	mov	r3, r0
 8009b26:	ea4f 2303 	mov.w	r3, r3, lsl #8
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8009b2a:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 8009b2c:	683b      	ldr	r3, [r7, #0]
 8009b2e:	789b      	ldrb	r3, [r3, #2]
 8009b30:	4618      	mov	r0, r3
 8009b32:	f001 f9b3 	bl	800ae9c <RTC_ByteToBcd2>
 8009b36:	4603      	mov	r3, r0
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8009b38:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 8009b3c:	683b      	ldr	r3, [r7, #0]
 8009b3e:	781b      	ldrb	r3, [r3, #0]
 8009b40:	ea4f 3343 	mov.w	r3, r3, lsl #13
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8009b44:	4313      	orrs	r3, r2
 8009b46:	60fb      	str	r3, [r7, #12]
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009b48:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009b4c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009b50:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009b54:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009b56:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009b5a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009b5e:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009b62:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8009b64:	f7ff fd22 	bl	80095ac <RTC_EnterInitMode>
 8009b68:	4603      	mov	r3, r0
 8009b6a:	2b00      	cmp	r3, #0
 8009b6c:	d103      	bne.n	8009b76 <RTC_SetDate+0xf6>
  {
    status = ERROR;
 8009b6e:	f04f 0300 	mov.w	r3, #0
 8009b72:	72fb      	strb	r3, [r7, #11]
 8009b74:	e017      	b.n	8009ba6 <RTC_SetDate+0x126>
  } 
  else
  {
    /* Set the RTC_DR register */
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 8009b76:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009b7a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009b7e:	68fa      	ldr	r2, [r7, #12]
 8009b80:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8009b84:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8009b88:	605a      	str	r2, [r3, #4]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 8009b8a:	f7ff fd59 	bl	8009640 <RTC_ExitInitMode>

    if(RTC_WaitForSynchro() == ERROR)
 8009b8e:	f7ff fd69 	bl	8009664 <RTC_WaitForSynchro>
 8009b92:	4603      	mov	r3, r0
 8009b94:	2b00      	cmp	r3, #0
 8009b96:	d103      	bne.n	8009ba0 <RTC_SetDate+0x120>
    {
      status = ERROR;
 8009b98:	f04f 0300 	mov.w	r3, #0
 8009b9c:	72fb      	strb	r3, [r7, #11]
 8009b9e:	e002      	b.n	8009ba6 <RTC_SetDate+0x126>
    }
    else
    {
      status = SUCCESS;
 8009ba0:	f04f 0301 	mov.w	r3, #1
 8009ba4:	72fb      	strb	r3, [r7, #11]
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 8009ba6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009baa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009bae:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009bb2:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8009bb4:	7afb      	ldrb	r3, [r7, #11]
}
 8009bb6:	4618      	mov	r0, r3
 8009bb8:	f107 0714 	add.w	r7, r7, #20
 8009bbc:	46bd      	mov	sp, r7
 8009bbe:	bd90      	pop	{r4, r7, pc}

08009bc0 <RTC_DateStructInit>:
  * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
{
 8009bc0:	b480      	push	{r7}
 8009bc2:	b083      	sub	sp, #12
 8009bc4:	af00      	add	r7, sp, #0
 8009bc6:	6078      	str	r0, [r7, #4]
  /* Monday, January 01 xx00 */
  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 8009bc8:	687b      	ldr	r3, [r7, #4]
 8009bca:	f04f 0201 	mov.w	r2, #1
 8009bce:	701a      	strb	r2, [r3, #0]
  RTC_DateStruct->RTC_Date = 1;
 8009bd0:	687b      	ldr	r3, [r7, #4]
 8009bd2:	f04f 0201 	mov.w	r2, #1
 8009bd6:	709a      	strb	r2, [r3, #2]
  RTC_DateStruct->RTC_Month = RTC_Month_January;
 8009bd8:	687b      	ldr	r3, [r7, #4]
 8009bda:	f04f 0201 	mov.w	r2, #1
 8009bde:	705a      	strb	r2, [r3, #1]
  RTC_DateStruct->RTC_Year = 0;
 8009be0:	687b      	ldr	r3, [r7, #4]
 8009be2:	f04f 0200 	mov.w	r2, #0
 8009be6:	70da      	strb	r2, [r3, #3]
}
 8009be8:	f107 070c 	add.w	r7, r7, #12
 8009bec:	46bd      	mov	sp, r7
 8009bee:	bc80      	pop	{r7}
 8009bf0:	4770      	bx	lr
 8009bf2:	bf00      	nop

08009bf4 <RTC_GetDate>:
  * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
  *                        contain the returned current date configuration.     
  * @retval None
  */
void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8009bf4:	b580      	push	{r7, lr}
 8009bf6:	b084      	sub	sp, #16
 8009bf8:	af00      	add	r7, sp, #0
 8009bfa:	6078      	str	r0, [r7, #4]
 8009bfc:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8009bfe:	f04f 0300 	mov.w	r3, #0
 8009c02:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
 8009c04:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009c08:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009c0c:	685b      	ldr	r3, [r3, #4]
 8009c0e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8009c12:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8009c16:	60fb      	str	r3, [r7, #12]

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8009c18:	68fb      	ldr	r3, [r7, #12]
 8009c1a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8009c1e:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009c22:	b2da      	uxtb	r2, r3
 8009c24:	683b      	ldr	r3, [r7, #0]
 8009c26:	70da      	strb	r2, [r3, #3]
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8009c28:	68fb      	ldr	r3, [r7, #12]
 8009c2a:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
 8009c2e:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8009c32:	b2da      	uxtb	r2, r3
 8009c34:	683b      	ldr	r3, [r7, #0]
 8009c36:	705a      	strb	r2, [r3, #1]
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 8009c38:	68fb      	ldr	r3, [r7, #12]
 8009c3a:	b2db      	uxtb	r3, r3
 8009c3c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009c40:	b2da      	uxtb	r2, r3
 8009c42:	683b      	ldr	r3, [r7, #0]
 8009c44:	709a      	strb	r2, [r3, #2]
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
 8009c46:	68fb      	ldr	r3, [r7, #12]
 8009c48:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8009c4c:	ea4f 3353 	mov.w	r3, r3, lsr #13
 8009c50:	b2da      	uxtb	r2, r3
 8009c52:	683b      	ldr	r3, [r7, #0]
 8009c54:	701a      	strb	r2, [r3, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8009c56:	687b      	ldr	r3, [r7, #4]
 8009c58:	2b00      	cmp	r3, #0
 8009c5a:	d11a      	bne.n	8009c92 <RTC_GetDate+0x9e>
  {
    /* Convert the structure parameters to Binary format */
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
 8009c5c:	683b      	ldr	r3, [r7, #0]
 8009c5e:	78db      	ldrb	r3, [r3, #3]
 8009c60:	4618      	mov	r0, r3
 8009c62:	f001 f93d 	bl	800aee0 <RTC_Bcd2ToByte>
 8009c66:	4603      	mov	r3, r0
 8009c68:	461a      	mov	r2, r3
 8009c6a:	683b      	ldr	r3, [r7, #0]
 8009c6c:	70da      	strb	r2, [r3, #3]
    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 8009c6e:	683b      	ldr	r3, [r7, #0]
 8009c70:	785b      	ldrb	r3, [r3, #1]
 8009c72:	4618      	mov	r0, r3
 8009c74:	f001 f934 	bl	800aee0 <RTC_Bcd2ToByte>
 8009c78:	4603      	mov	r3, r0
 8009c7a:	461a      	mov	r2, r3
 8009c7c:	683b      	ldr	r3, [r7, #0]
 8009c7e:	705a      	strb	r2, [r3, #1]
    RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 8009c80:	683b      	ldr	r3, [r7, #0]
 8009c82:	789b      	ldrb	r3, [r3, #2]
 8009c84:	4618      	mov	r0, r3
 8009c86:	f001 f92b 	bl	800aee0 <RTC_Bcd2ToByte>
 8009c8a:	4603      	mov	r3, r0
 8009c8c:	461a      	mov	r2, r3
 8009c8e:	683b      	ldr	r3, [r7, #0]
 8009c90:	709a      	strb	r2, [r3, #2]
  }
}
 8009c92:	f107 0710 	add.w	r7, r7, #16
 8009c96:	46bd      	mov	sp, r7
 8009c98:	bd80      	pop	{r7, pc}
 8009c9a:	bf00      	nop

08009c9c <RTC_SetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
  *                          contains the alarm configuration parameters.     
  * @retval None
  */
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8009c9c:	b590      	push	{r4, r7, lr}
 8009c9e:	b087      	sub	sp, #28
 8009ca0:	af00      	add	r7, sp, #0
 8009ca2:	60f8      	str	r0, [r7, #12]
 8009ca4:	60b9      	str	r1, [r7, #8]
 8009ca6:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 8009ca8:	f04f 0300 	mov.w	r3, #0
 8009cac:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
 8009cae:	68fb      	ldr	r3, [r7, #12]
 8009cb0:	2b00      	cmp	r3, #0
 8009cb2:	d10d      	bne.n	8009cd0 <RTC_SetAlarm+0x34>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8009cb4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009cb8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009cbc:	689b      	ldr	r3, [r3, #8]
 8009cbe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009cc2:	2b00      	cmp	r3, #0
 8009cc4:	d12c      	bne.n	8009d20 <RTC_SetAlarm+0x84>
      assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8009cc6:	687b      	ldr	r3, [r7, #4]
 8009cc8:	f04f 0200 	mov.w	r2, #0
 8009ccc:	70da      	strb	r2, [r3, #3]
 8009cce:	e027      	b.n	8009d20 <RTC_SetAlarm+0x84>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
    }
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8009cd0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009cd4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009cd8:	689b      	ldr	r3, [r3, #8]
 8009cda:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009cde:	2b00      	cmp	r3, #0
 8009ce0:	d007      	beq.n	8009cf2 <RTC_SetAlarm+0x56>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
 8009ce2:	687b      	ldr	r3, [r7, #4]
 8009ce4:	781b      	ldrb	r3, [r3, #0]
 8009ce6:	4618      	mov	r0, r3
 8009ce8:	f001 f8fa 	bl	800aee0 <RTC_Bcd2ToByte>
 8009cec:	4603      	mov	r3, r0
 8009cee:	617b      	str	r3, [r7, #20]
 8009cf0:	e003      	b.n	8009cfa <RTC_SetAlarm+0x5e>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8009cf2:	687b      	ldr	r3, [r7, #4]
 8009cf4:	f04f 0200 	mov.w	r2, #0
 8009cf8:	70da      	strb	r2, [r3, #3]
    }
    
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
    
    if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
 8009cfa:	687b      	ldr	r3, [r7, #4]
 8009cfc:	689b      	ldr	r3, [r3, #8]
 8009cfe:	2b00      	cmp	r3, #0
 8009d00:	d107      	bne.n	8009d12 <RTC_SetAlarm+0x76>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8009d02:	687b      	ldr	r3, [r7, #4]
 8009d04:	7b1b      	ldrb	r3, [r3, #12]
 8009d06:	4618      	mov	r0, r3
 8009d08:	f001 f8ea 	bl	800aee0 <RTC_Bcd2ToByte>
 8009d0c:	4603      	mov	r3, r0
 8009d0e:	617b      	str	r3, [r7, #20]
 8009d10:	e006      	b.n	8009d20 <RTC_SetAlarm+0x84>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
    }
    else
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8009d12:	687b      	ldr	r3, [r7, #4]
 8009d14:	7b1b      	ldrb	r3, [r3, #12]
 8009d16:	4618      	mov	r0, r3
 8009d18:	f001 f8e2 	bl	800aee0 <RTC_Bcd2ToByte>
 8009d1c:	4603      	mov	r3, r0
 8009d1e:	617b      	str	r3, [r7, #20]
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
    }    
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 8009d20:	68fb      	ldr	r3, [r7, #12]
 8009d22:	2b00      	cmp	r3, #0
 8009d24:	d01d      	beq.n	8009d62 <RTC_SetAlarm+0xc6>
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8009d26:	687b      	ldr	r3, [r7, #4]
 8009d28:	781b      	ldrb	r3, [r3, #0]
 8009d2a:	ea4f 4203 	mov.w	r2, r3, lsl #16
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8009d2e:	687b      	ldr	r3, [r7, #4]
 8009d30:	785b      	ldrb	r3, [r3, #1]
 8009d32:	ea4f 2303 	mov.w	r3, r3, lsl #8
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8009d36:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8009d38:	687b      	ldr	r3, [r7, #4]
 8009d3a:	789b      	ldrb	r3, [r3, #2]

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8009d3c:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8009d3e:	687b      	ldr	r3, [r7, #4]
 8009d40:	78db      	ldrb	r3, [r3, #3]
 8009d42:	ea4f 4303 	mov.w	r3, r3, lsl #16
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8009d46:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8009d48:	687b      	ldr	r3, [r7, #4]
 8009d4a:	7b1b      	ldrb	r3, [r3, #12]
 8009d4c:	ea4f 6303 	mov.w	r3, r3, lsl #24
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8009d50:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 8009d52:	687b      	ldr	r3, [r7, #4]
 8009d54:	689b      	ldr	r3, [r3, #8]
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8009d56:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 8009d58:	687b      	ldr	r3, [r7, #4]
 8009d5a:	685b      	ldr	r3, [r3, #4]
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8009d5c:	4313      	orrs	r3, r2
 8009d5e:	617b      	str	r3, [r7, #20]
 8009d60:	e02f      	b.n	8009dc2 <RTC_SetAlarm+0x126>
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8009d62:	687b      	ldr	r3, [r7, #4]
 8009d64:	781b      	ldrb	r3, [r3, #0]
 8009d66:	4618      	mov	r0, r3
 8009d68:	f001 f898 	bl	800ae9c <RTC_ByteToBcd2>
 8009d6c:	4603      	mov	r3, r0
 8009d6e:	ea4f 4403 	mov.w	r4, r3, lsl #16
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8009d72:	687b      	ldr	r3, [r7, #4]
 8009d74:	785b      	ldrb	r3, [r3, #1]
 8009d76:	4618      	mov	r0, r3
 8009d78:	f001 f890 	bl	800ae9c <RTC_ByteToBcd2>
 8009d7c:	4603      	mov	r3, r0
 8009d7e:	ea4f 2303 	mov.w	r3, r3, lsl #8
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8009d82:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 8009d84:	687b      	ldr	r3, [r7, #4]
 8009d86:	789b      	ldrb	r3, [r3, #2]
 8009d88:	4618      	mov	r0, r3
 8009d8a:	f001 f887 	bl	800ae9c <RTC_ByteToBcd2>
 8009d8e:	4603      	mov	r3, r0
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8009d90:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8009d94:	687b      	ldr	r3, [r7, #4]
 8009d96:	78db      	ldrb	r3, [r3, #3]
 8009d98:	ea4f 4303 	mov.w	r3, r3, lsl #16
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 8009d9c:	ea42 0403 	orr.w	r4, r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8009da0:	687b      	ldr	r3, [r7, #4]
 8009da2:	7b1b      	ldrb	r3, [r3, #12]
 8009da4:	4618      	mov	r0, r3
 8009da6:	f001 f879 	bl	800ae9c <RTC_ByteToBcd2>
 8009daa:	4603      	mov	r3, r0
 8009dac:	ea4f 6303 	mov.w	r3, r3, lsl #24
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8009db0:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 8009db4:	687b      	ldr	r3, [r7, #4]
 8009db6:	689b      	ldr	r3, [r3, #8]
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8009db8:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 8009dba:	687b      	ldr	r3, [r7, #4]
 8009dbc:	685b      	ldr	r3, [r3, #4]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8009dbe:	4313      	orrs	r3, r2
 8009dc0:	617b      	str	r3, [r7, #20]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  } 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009dc2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009dc6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009dca:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009dce:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009dd0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009dd4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009dd8:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009ddc:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if (RTC_Alarm == RTC_Alarm_A)
 8009dde:	68bb      	ldr	r3, [r7, #8]
 8009de0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009de4:	d106      	bne.n	8009df4 <RTC_SetAlarm+0x158>
  {
    RTC->ALRMAR = (uint32_t)tmpreg;
 8009de6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009dea:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009dee:	697a      	ldr	r2, [r7, #20]
 8009df0:	61da      	str	r2, [r3, #28]
 8009df2:	e005      	b.n	8009e00 <RTC_SetAlarm+0x164>
  }
  else
  {
    RTC->ALRMBR = (uint32_t)tmpreg;
 8009df4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009df8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009dfc:	697a      	ldr	r2, [r7, #20]
 8009dfe:	621a      	str	r2, [r3, #32]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 8009e00:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009e04:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009e08:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009e0c:	625a      	str	r2, [r3, #36]	; 0x24
}
 8009e0e:	f107 071c 	add.w	r7, r7, #28
 8009e12:	46bd      	mov	sp, r7
 8009e14:	bd90      	pop	{r4, r7, pc}
 8009e16:	bf00      	nop

08009e18 <RTC_AlarmStructInit>:
  * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8009e18:	b480      	push	{r7}
 8009e1a:	b083      	sub	sp, #12
 8009e1c:	af00      	add	r7, sp, #0
 8009e1e:	6078      	str	r0, [r7, #4]
  /* Alarm Time Settings : Time = 00h:00mn:00sec */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 8009e20:	687b      	ldr	r3, [r7, #4]
 8009e22:	f04f 0200 	mov.w	r2, #0
 8009e26:	70da      	strb	r2, [r3, #3]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
 8009e28:	687b      	ldr	r3, [r7, #4]
 8009e2a:	f04f 0200 	mov.w	r2, #0
 8009e2e:	701a      	strb	r2, [r3, #0]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
 8009e30:	687b      	ldr	r3, [r7, #4]
 8009e32:	f04f 0200 	mov.w	r2, #0
 8009e36:	705a      	strb	r2, [r3, #1]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
 8009e38:	687b      	ldr	r3, [r7, #4]
 8009e3a:	f04f 0200 	mov.w	r2, #0
 8009e3e:	709a      	strb	r2, [r3, #2]

  /* Alarm Date Settings : Date = 1st day of the month */
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 8009e40:	687b      	ldr	r3, [r7, #4]
 8009e42:	f04f 0200 	mov.w	r2, #0
 8009e46:	609a      	str	r2, [r3, #8]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 8009e48:	687b      	ldr	r3, [r7, #4]
 8009e4a:	f04f 0201 	mov.w	r2, #1
 8009e4e:	731a      	strb	r2, [r3, #12]

  /* Alarm Masks Settings : Mask =  all fields are not masked */
  RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
 8009e50:	687b      	ldr	r3, [r7, #4]
 8009e52:	f04f 0200 	mov.w	r2, #0
 8009e56:	605a      	str	r2, [r3, #4]
}
 8009e58:	f107 070c 	add.w	r7, r7, #12
 8009e5c:	46bd      	mov	sp, r7
 8009e5e:	bc80      	pop	{r7}
 8009e60:	4770      	bx	lr
 8009e62:	bf00      	nop

08009e64 <RTC_GetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
  *                          contains the output alarm configuration values.     
  * @retval None
  */
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8009e64:	b580      	push	{r7, lr}
 8009e66:	b086      	sub	sp, #24
 8009e68:	af00      	add	r7, sp, #0
 8009e6a:	60f8      	str	r0, [r7, #12]
 8009e6c:	60b9      	str	r1, [r7, #8]
 8009e6e:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 8009e70:	f04f 0300 	mov.w	r3, #0
 8009e74:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm)); 

  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
 8009e76:	68bb      	ldr	r3, [r7, #8]
 8009e78:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009e7c:	d106      	bne.n	8009e8c <RTC_GetAlarm+0x28>
  {
    tmpreg = (uint32_t)(RTC->ALRMAR);
 8009e7e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009e82:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009e86:	69db      	ldr	r3, [r3, #28]
 8009e88:	617b      	str	r3, [r7, #20]
 8009e8a:	e005      	b.n	8009e98 <RTC_GetAlarm+0x34>
  }
  else
  {
    tmpreg = (uint32_t)(RTC->ALRMBR);
 8009e8c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009e90:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009e94:	6a1b      	ldr	r3, [r3, #32]
 8009e96:	617b      	str	r3, [r7, #20]
  }

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 8009e98:	697b      	ldr	r3, [r7, #20]
 8009e9a:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 8009e9e:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009ea2:	b2da      	uxtb	r2, r3
 8009ea4:	687b      	ldr	r3, [r7, #4]
 8009ea6:	701a      	strb	r2, [r3, #0]
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 8009ea8:	697b      	ldr	r3, [r7, #20]
 8009eaa:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 8009eae:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8009eb2:	b2da      	uxtb	r2, r3
 8009eb4:	687b      	ldr	r3, [r7, #4]
 8009eb6:	705a      	strb	r2, [r3, #1]
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 8009eb8:	697b      	ldr	r3, [r7, #20]
 8009eba:	b2db      	uxtb	r3, r3
 8009ebc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8009ec0:	b2da      	uxtb	r2, r3
 8009ec2:	687b      	ldr	r3, [r7, #4]
 8009ec4:	709a      	strb	r2, [r3, #2]
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8009ec6:	697b      	ldr	r3, [r7, #20]
 8009ec8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8009ecc:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009ed0:	b2da      	uxtb	r2, r3
 8009ed2:	687b      	ldr	r3, [r7, #4]
 8009ed4:	70da      	strb	r2, [r3, #3]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 8009ed6:	697b      	ldr	r3, [r7, #20]
 8009ed8:	f003 537c 	and.w	r3, r3, #1056964608	; 0x3f000000
 8009edc:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8009ee0:	b2da      	uxtb	r2, r3
 8009ee2:	687b      	ldr	r3, [r7, #4]
 8009ee4:	731a      	strb	r2, [r3, #12]
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 8009ee6:	697b      	ldr	r3, [r7, #20]
 8009ee8:	f003 4280 	and.w	r2, r3, #1073741824	; 0x40000000
 8009eec:	687b      	ldr	r3, [r7, #4]
 8009eee:	609a      	str	r2, [r3, #8]
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 8009ef0:	697b      	ldr	r3, [r7, #20]
 8009ef2:	f003 3280 	and.w	r2, r3, #2155905152	; 0x80808080
 8009ef6:	687b      	ldr	r3, [r7, #4]
 8009ef8:	605a      	str	r2, [r3, #4]

  if (RTC_Format == RTC_Format_BIN)
 8009efa:	68fb      	ldr	r3, [r7, #12]
 8009efc:	2b00      	cmp	r3, #0
 8009efe:	d123      	bne.n	8009f48 <RTC_GetAlarm+0xe4>
  {
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8009f00:	687b      	ldr	r3, [r7, #4]
 8009f02:	781b      	ldrb	r3, [r3, #0]
 8009f04:	4618      	mov	r0, r3
 8009f06:	f000 ffeb 	bl	800aee0 <RTC_Bcd2ToByte>
 8009f0a:	4603      	mov	r3, r0
 8009f0c:	461a      	mov	r2, r3
 8009f0e:	687b      	ldr	r3, [r7, #4]
 8009f10:	701a      	strb	r2, [r3, #0]
                                                        RTC_AlarmTime.RTC_Hours);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8009f12:	687b      	ldr	r3, [r7, #4]
 8009f14:	785b      	ldrb	r3, [r3, #1]
 8009f16:	4618      	mov	r0, r3
 8009f18:	f000 ffe2 	bl	800aee0 <RTC_Bcd2ToByte>
 8009f1c:	4603      	mov	r3, r0
 8009f1e:	461a      	mov	r2, r3
 8009f20:	687b      	ldr	r3, [r7, #4]
 8009f22:	705a      	strb	r2, [r3, #1]
                                                        RTC_AlarmTime.RTC_Minutes);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8009f24:	687b      	ldr	r3, [r7, #4]
 8009f26:	789b      	ldrb	r3, [r3, #2]
 8009f28:	4618      	mov	r0, r3
 8009f2a:	f000 ffd9 	bl	800aee0 <RTC_Bcd2ToByte>
 8009f2e:	4603      	mov	r3, r0
 8009f30:	461a      	mov	r2, r3
 8009f32:	687b      	ldr	r3, [r7, #4]
 8009f34:	709a      	strb	r2, [r3, #2]
                                                        RTC_AlarmTime.RTC_Seconds);
    RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8009f36:	687b      	ldr	r3, [r7, #4]
 8009f38:	7b1b      	ldrb	r3, [r3, #12]
 8009f3a:	4618      	mov	r0, r3
 8009f3c:	f000 ffd0 	bl	800aee0 <RTC_Bcd2ToByte>
 8009f40:	4603      	mov	r3, r0
 8009f42:	461a      	mov	r2, r3
 8009f44:	687b      	ldr	r3, [r7, #4]
 8009f46:	731a      	strb	r2, [r3, #12]
  }  
}
 8009f48:	f107 0718 	add.w	r7, r7, #24
 8009f4c:	46bd      	mov	sp, r7
 8009f4e:	bd80      	pop	{r7, pc}

08009f50 <RTC_AlarmCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Alarm is enabled/disabled
  *          - ERROR: RTC Alarm is not enabled/disabled  
  */
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
{
 8009f50:	b480      	push	{r7}
 8009f52:	b087      	sub	sp, #28
 8009f54:	af00      	add	r7, sp, #0
 8009f56:	6078      	str	r0, [r7, #4]
 8009f58:	460b      	mov	r3, r1
 8009f5a:	70fb      	strb	r3, [r7, #3]
  __IO uint32_t alarmcounter = 0x00;
 8009f5c:	f04f 0300 	mov.w	r3, #0
 8009f60:	60fb      	str	r3, [r7, #12]
  uint32_t alarmstatus = 0x00;
 8009f62:	f04f 0300 	mov.w	r3, #0
 8009f66:	613b      	str	r3, [r7, #16]
  ErrorStatus status = ERROR;
 8009f68:	f04f 0300 	mov.w	r3, #0
 8009f6c:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009f6e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009f72:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009f76:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009f7a:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009f7c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009f80:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009f84:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009f88:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm state */
  if (NewState != DISABLE)
 8009f8a:	78fb      	ldrb	r3, [r7, #3]
 8009f8c:	2b00      	cmp	r3, #0
 8009f8e:	d010      	beq.n	8009fb2 <RTC_AlarmCmd+0x62>
  {
    RTC->CR |= (uint32_t)RTC_Alarm;
 8009f90:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009f94:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009f98:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8009f9c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8009fa0:	6892      	ldr	r2, [r2, #8]
 8009fa2:	4611      	mov	r1, r2
 8009fa4:	687a      	ldr	r2, [r7, #4]
 8009fa6:	430a      	orrs	r2, r1
 8009fa8:	609a      	str	r2, [r3, #8]

    status = SUCCESS;    
 8009faa:	f04f 0301 	mov.w	r3, #1
 8009fae:	75fb      	strb	r3, [r7, #23]
 8009fb0:	e037      	b.n	800a022 <RTC_AlarmCmd+0xd2>
  }
  else
  { 
    /* Disable the Alarm in RTC_CR register */
    RTC->CR &= (uint32_t)~RTC_Alarm;
 8009fb2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009fb6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009fba:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8009fbe:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8009fc2:	6892      	ldr	r2, [r2, #8]
 8009fc4:	4611      	mov	r1, r2
 8009fc6:	687a      	ldr	r2, [r7, #4]
 8009fc8:	ea6f 0202 	mvn.w	r2, r2
 8009fcc:	400a      	ands	r2, r1
 8009fce:	609a      	str	r2, [r3, #8]
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 8009fd0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8009fd4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8009fd8:	68db      	ldr	r3, [r3, #12]
 8009fda:	461a      	mov	r2, r3
 8009fdc:	687b      	ldr	r3, [r7, #4]
 8009fde:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8009fe2:	4013      	ands	r3, r2
 8009fe4:	613b      	str	r3, [r7, #16]
      alarmcounter++;  
 8009fe6:	68fb      	ldr	r3, [r7, #12]
 8009fe8:	f103 0301 	add.w	r3, r3, #1
 8009fec:	60fb      	str	r3, [r7, #12]
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 8009fee:	68fb      	ldr	r3, [r7, #12]
 8009ff0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8009ff4:	d002      	beq.n	8009ffc <RTC_AlarmCmd+0xac>
 8009ff6:	693b      	ldr	r3, [r7, #16]
 8009ff8:	2b00      	cmp	r3, #0
 8009ffa:	d0e9      	beq.n	8009fd0 <RTC_AlarmCmd+0x80>
    
    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
 8009ffc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a000:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a004:	68db      	ldr	r3, [r3, #12]
 800a006:	461a      	mov	r2, r3
 800a008:	687b      	ldr	r3, [r7, #4]
 800a00a:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800a00e:	4013      	ands	r3, r2
 800a010:	2b00      	cmp	r3, #0
 800a012:	d103      	bne.n	800a01c <RTC_AlarmCmd+0xcc>
    {
      status = ERROR;
 800a014:	f04f 0300 	mov.w	r3, #0
 800a018:	75fb      	strb	r3, [r7, #23]
 800a01a:	e002      	b.n	800a022 <RTC_AlarmCmd+0xd2>
    } 
    else
    {
      status = SUCCESS;
 800a01c:	f04f 0301 	mov.w	r3, #1
 800a020:	75fb      	strb	r3, [r7, #23]
    }        
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a022:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a026:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a02a:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a02e:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 800a030:	7dfb      	ldrb	r3, [r7, #23]
}
 800a032:	4618      	mov	r0, r3
 800a034:	f107 071c 	add.w	r7, r7, #28
 800a038:	46bd      	mov	sp, r7
 800a03a:	bc80      	pop	{r7}
 800a03c:	4770      	bx	lr
 800a03e:	bf00      	nop

0800a040 <RTC_AlarmSubSecondConfig>:
  *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
  *                                          to activate alarm
  * @retval None
  */
void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
{
 800a040:	b480      	push	{r7}
 800a042:	b087      	sub	sp, #28
 800a044:	af00      	add	r7, sp, #0
 800a046:	60f8      	str	r0, [r7, #12]
 800a048:	60b9      	str	r1, [r7, #8]
 800a04a:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 800a04c:	f04f 0300 	mov.w	r3, #0
 800a050:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a052:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a056:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a05a:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a05e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a060:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a064:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a068:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a06c:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Configure the Alarm A or Alarm B SubSecond registers */
  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
 800a06e:	68ba      	ldr	r2, [r7, #8]
 800a070:	687b      	ldr	r3, [r7, #4]
 800a072:	4313      	orrs	r3, r2
 800a074:	617b      	str	r3, [r7, #20]
  
  if (RTC_Alarm == RTC_Alarm_A)
 800a076:	68fb      	ldr	r3, [r7, #12]
 800a078:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a07c:	d106      	bne.n	800a08c <RTC_AlarmSubSecondConfig+0x4c>
  {
    /* Configure the AlarmA SubSecond register */
    RTC->ALRMASSR = tmpreg;
 800a07e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a082:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a086:	697a      	ldr	r2, [r7, #20]
 800a088:	645a      	str	r2, [r3, #68]	; 0x44
 800a08a:	e005      	b.n	800a098 <RTC_AlarmSubSecondConfig+0x58>
  }
  else
  {
    /* Configure the Alarm B SubSecond register */
    RTC->ALRMBSSR = tmpreg;
 800a08c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a090:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a094:	697a      	ldr	r2, [r7, #20]
 800a096:	649a      	str	r2, [r3, #72]	; 0x48
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 800a098:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a09c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a0a0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a0a4:	625a      	str	r2, [r3, #36]	; 0x24

}
 800a0a6:	f107 071c 	add.w	r7, r7, #28
 800a0aa:	46bd      	mov	sp, r7
 800a0ac:	bc80      	pop	{r7}
 800a0ae:	4770      	bx	lr

0800a0b0 <RTC_GetAlarmSubSecond>:
  *     @arg RTC_Alarm_B: to select Alarm B
  * @param  None
  * @retval RTC Alarm Subseconds value.
  */
uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
{
 800a0b0:	b480      	push	{r7}
 800a0b2:	b085      	sub	sp, #20
 800a0b4:	af00      	add	r7, sp, #0
 800a0b6:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800a0b8:	f04f 0300 	mov.w	r3, #0
 800a0bc:	60fb      	str	r3, [r7, #12]
  
  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
 800a0be:	687b      	ldr	r3, [r7, #4]
 800a0c0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a0c4:	d10a      	bne.n	800a0dc <RTC_GetAlarmSubSecond+0x2c>
  {
    tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
 800a0c6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a0ca:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a0ce:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a0d0:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800a0d4:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800a0d8:	60fb      	str	r3, [r7, #12]
 800a0da:	e009      	b.n	800a0f0 <RTC_GetAlarmSubSecond+0x40>
  }
  else
  {
    tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
 800a0dc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a0e0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a0e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a0e6:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800a0ea:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800a0ee:	60fb      	str	r3, [r7, #12]
  } 
  
  return (tmpreg);
 800a0f0:	68fb      	ldr	r3, [r7, #12]
}
 800a0f2:	4618      	mov	r0, r3
 800a0f4:	f107 0714 	add.w	r7, r7, #20
 800a0f8:	46bd      	mov	sp, r7
 800a0fa:	bc80      	pop	{r7}
 800a0fc:	4770      	bx	lr
 800a0fe:	bf00      	nop

0800a100 <RTC_WakeUpClockConfig>:
  *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
  *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
  * @retval None
  */
void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
{
 800a100:	b480      	push	{r7}
 800a102:	b083      	sub	sp, #12
 800a104:	af00      	add	r7, sp, #0
 800a106:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a108:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a10c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a110:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a114:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a116:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a11a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a11e:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a122:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 800a124:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a128:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a12c:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a130:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a134:	6892      	ldr	r2, [r2, #8]
 800a136:	f022 0207 	bic.w	r2, r2, #7
 800a13a:	609a      	str	r2, [r3, #8]

  /* Configure the clock source */
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
 800a13c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a140:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a144:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a148:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a14c:	6892      	ldr	r2, [r2, #8]
 800a14e:	4611      	mov	r1, r2
 800a150:	687a      	ldr	r2, [r7, #4]
 800a152:	430a      	orrs	r2, r1
 800a154:	609a      	str	r2, [r3, #8]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a156:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a15a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a15e:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a162:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a164:	f107 070c 	add.w	r7, r7, #12
 800a168:	46bd      	mov	sp, r7
 800a16a:	bc80      	pop	{r7}
 800a16c:	4770      	bx	lr
 800a16e:	bf00      	nop

0800a170 <RTC_SetWakeUpCounter>:
  * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
  *          This parameter can be a value from 0x0000 to 0xFFFF. 
  * @retval None
  */
void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
{
 800a170:	b480      	push	{r7}
 800a172:	b083      	sub	sp, #12
 800a174:	af00      	add	r7, sp, #0
 800a176:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a178:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a17c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a180:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a184:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a186:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a18a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a18e:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a192:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Configure the Wakeup Timer counter */
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
 800a194:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a198:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a19c:	687a      	ldr	r2, [r7, #4]
 800a19e:	615a      	str	r2, [r3, #20]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a1a0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a1a4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a1a8:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a1ac:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a1ae:	f107 070c 	add.w	r7, r7, #12
 800a1b2:	46bd      	mov	sp, r7
 800a1b4:	bc80      	pop	{r7}
 800a1b6:	4770      	bx	lr

0800a1b8 <RTC_GetWakeUpCounter>:
  * @brief  Returns the RTC WakeUp timer counter value.
  * @param  None
  * @retval The RTC WakeUp Counter value.
  */
uint32_t RTC_GetWakeUpCounter(void)
{
 800a1b8:	b480      	push	{r7}
 800a1ba:	af00      	add	r7, sp, #0
  /* Get the counter value */
  return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
 800a1bc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a1c0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a1c4:	695b      	ldr	r3, [r3, #20]
 800a1c6:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800a1ca:	ea4f 4313 	mov.w	r3, r3, lsr #16
}
 800a1ce:	4618      	mov	r0, r3
 800a1d0:	46bd      	mov	sp, r7
 800a1d2:	bc80      	pop	{r7}
 800a1d4:	4770      	bx	lr
 800a1d6:	bf00      	nop

0800a1d8 <RTC_WakeUpCmd>:
  * @param  NewState: new state of the WakeUp timer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
{
 800a1d8:	b480      	push	{r7}
 800a1da:	b087      	sub	sp, #28
 800a1dc:	af00      	add	r7, sp, #0
 800a1de:	4603      	mov	r3, r0
 800a1e0:	71fb      	strb	r3, [r7, #7]
  __IO uint32_t wutcounter = 0x00;
 800a1e2:	f04f 0300 	mov.w	r3, #0
 800a1e6:	60fb      	str	r3, [r7, #12]
  uint32_t wutwfstatus = 0x00;
 800a1e8:	f04f 0300 	mov.w	r3, #0
 800a1ec:	613b      	str	r3, [r7, #16]
  ErrorStatus status = ERROR;
 800a1ee:	f04f 0300 	mov.w	r3, #0
 800a1f2:	75fb      	strb	r3, [r7, #23]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a1f4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a1f8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a1fc:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a200:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a202:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a206:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a20a:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a20e:	625a      	str	r2, [r3, #36]	; 0x24

  if (NewState != DISABLE)
 800a210:	79fb      	ldrb	r3, [r7, #7]
 800a212:	2b00      	cmp	r3, #0
 800a214:	d00f      	beq.n	800a236 <RTC_WakeUpCmd+0x5e>
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
 800a216:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a21a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a21e:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a222:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a226:	6892      	ldr	r2, [r2, #8]
 800a228:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a22c:	609a      	str	r2, [r3, #8]
    status = SUCCESS;    
 800a22e:	f04f 0301 	mov.w	r3, #1
 800a232:	75fb      	strb	r3, [r7, #23]
 800a234:	e02e      	b.n	800a294 <RTC_WakeUpCmd+0xbc>
  }
  else
  {
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
 800a236:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a23a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a23e:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a242:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a246:	6892      	ldr	r2, [r2, #8]
 800a248:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a24c:	609a      	str	r2, [r3, #8]
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 800a24e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a252:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a256:	68db      	ldr	r3, [r3, #12]
 800a258:	f003 0304 	and.w	r3, r3, #4
 800a25c:	613b      	str	r3, [r7, #16]
      wutcounter++;  
 800a25e:	68fb      	ldr	r3, [r7, #12]
 800a260:	f103 0301 	add.w	r3, r3, #1
 800a264:	60fb      	str	r3, [r7, #12]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 800a266:	68fb      	ldr	r3, [r7, #12]
 800a268:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a26c:	d002      	beq.n	800a274 <RTC_WakeUpCmd+0x9c>
 800a26e:	693b      	ldr	r3, [r7, #16]
 800a270:	2b00      	cmp	r3, #0
 800a272:	d0ec      	beq.n	800a24e <RTC_WakeUpCmd+0x76>
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 800a274:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a278:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a27c:	68db      	ldr	r3, [r3, #12]
 800a27e:	f003 0304 	and.w	r3, r3, #4
 800a282:	2b00      	cmp	r3, #0
 800a284:	d103      	bne.n	800a28e <RTC_WakeUpCmd+0xb6>
    {
      status = ERROR;
 800a286:	f04f 0300 	mov.w	r3, #0
 800a28a:	75fb      	strb	r3, [r7, #23]
 800a28c:	e002      	b.n	800a294 <RTC_WakeUpCmd+0xbc>
    }
    else
    {
      status = SUCCESS;
 800a28e:	f04f 0301 	mov.w	r3, #1
 800a292:	75fb      	strb	r3, [r7, #23]
    }    
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a294:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a298:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a29c:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a2a0:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 800a2a2:	7dfb      	ldrb	r3, [r7, #23]
}
 800a2a4:	4618      	mov	r0, r3
 800a2a6:	f107 071c 	add.w	r7, r7, #28
 800a2aa:	46bd      	mov	sp, r7
 800a2ac:	bc80      	pop	{r7}
 800a2ae:	4770      	bx	lr

0800a2b0 <RTC_DayLightSavingConfig>:
  *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
  *            @arg RTC_StoreOperation_Set: BCK Bit Set
  * @retval None
  */
void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
{
 800a2b0:	b480      	push	{r7}
 800a2b2:	b083      	sub	sp, #12
 800a2b4:	af00      	add	r7, sp, #0
 800a2b6:	6078      	str	r0, [r7, #4]
 800a2b8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a2ba:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a2be:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a2c2:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a2c6:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a2c8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a2cc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a2d0:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a2d4:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);
 800a2d6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a2da:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a2de:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a2e2:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a2e6:	6892      	ldr	r2, [r2, #8]
 800a2e8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800a2ec:	609a      	str	r2, [r3, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 800a2ee:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a2f2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a2f6:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a2fa:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a2fe:	6892      	ldr	r2, [r2, #8]
 800a300:	4611      	mov	r1, r2
 800a302:	6878      	ldr	r0, [r7, #4]
 800a304:	683a      	ldr	r2, [r7, #0]
 800a306:	4302      	orrs	r2, r0
 800a308:	430a      	orrs	r2, r1
 800a30a:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a30c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a310:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a314:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a318:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a31a:	f107 070c 	add.w	r7, r7, #12
 800a31e:	46bd      	mov	sp, r7
 800a320:	bc80      	pop	{r7}
 800a322:	4770      	bx	lr

0800a324 <RTC_GetStoreOperation>:
  * @retval RTC Day Light Saving stored operation.
  *          - RTC_StoreOperation_Reset
  *          - RTC_StoreOperation_Set       
  */
uint32_t RTC_GetStoreOperation(void)
{
 800a324:	b480      	push	{r7}
 800a326:	af00      	add	r7, sp, #0
  return (RTC->CR & RTC_CR_BCK);
 800a328:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a32c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a330:	689b      	ldr	r3, [r3, #8]
 800a332:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
}
 800a336:	4618      	mov	r0, r3
 800a338:	46bd      	mov	sp, r7
 800a33a:	bc80      	pop	{r7}
 800a33c:	4770      	bx	lr
 800a33e:	bf00      	nop

0800a340 <RTC_OutputConfig>:
  *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
  *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
  * @retval None
  */
void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
{
 800a340:	b480      	push	{r7}
 800a342:	b083      	sub	sp, #12
 800a344:	af00      	add	r7, sp, #0
 800a346:	6078      	str	r0, [r7, #4]
 800a348:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT(RTC_Output));
  assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a34a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a34e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a352:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a356:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a358:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a35c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a360:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a364:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
 800a366:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a36a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a36e:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a372:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a376:	6892      	ldr	r2, [r2, #8]
 800a378:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
 800a37c:	609a      	str	r2, [r3, #8]

  /* Configure the output selection and polarity */
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 800a37e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a382:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a386:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a38a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a38e:	6892      	ldr	r2, [r2, #8]
 800a390:	4611      	mov	r1, r2
 800a392:	6878      	ldr	r0, [r7, #4]
 800a394:	683a      	ldr	r2, [r7, #0]
 800a396:	4302      	orrs	r2, r0
 800a398:	430a      	orrs	r2, r1
 800a39a:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a39c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a3a0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a3a4:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a3a8:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a3aa:	f107 070c 	add.w	r7, r7, #12
 800a3ae:	46bd      	mov	sp, r7
 800a3b0:	bc80      	pop	{r7}
 800a3b2:	4770      	bx	lr

0800a3b4 <RTC_CoarseCalibConfig>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are initialized
  *          - ERROR: RTC Coarse calibration are not initialized     
  */
ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
{
 800a3b4:	b580      	push	{r7, lr}
 800a3b6:	b084      	sub	sp, #16
 800a3b8:	af00      	add	r7, sp, #0
 800a3ba:	6078      	str	r0, [r7, #4]
 800a3bc:	6039      	str	r1, [r7, #0]
  ErrorStatus status = ERROR;
 800a3be:	f04f 0300 	mov.w	r3, #0
 800a3c2:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
  assert_param(IS_RTC_CALIB_VALUE(Value)); 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a3c4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a3c8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a3cc:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a3d0:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a3d2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a3d6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a3da:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a3de:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 800a3e0:	f7ff f8e4 	bl	80095ac <RTC_EnterInitMode>
 800a3e4:	4603      	mov	r3, r0
 800a3e6:	2b00      	cmp	r3, #0
 800a3e8:	d103      	bne.n	800a3f2 <RTC_CoarseCalibConfig+0x3e>
  {
    status = ERROR;
 800a3ea:	f04f 0300 	mov.w	r3, #0
 800a3ee:	73fb      	strb	r3, [r7, #15]
 800a3f0:	e00c      	b.n	800a40c <RTC_CoarseCalibConfig+0x58>
  } 
  else
  {
    /* Set the coarse calibration value */
    RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
 800a3f2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a3f6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a3fa:	6879      	ldr	r1, [r7, #4]
 800a3fc:	683a      	ldr	r2, [r7, #0]
 800a3fe:	430a      	orrs	r2, r1
 800a400:	619a      	str	r2, [r3, #24]
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 800a402:	f7ff f91d 	bl	8009640 <RTC_ExitInitMode>
    
    status = SUCCESS;
 800a406:	f04f 0301 	mov.w	r3, #1
 800a40a:	73fb      	strb	r3, [r7, #15]
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a40c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a410:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a414:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a418:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 800a41a:	7bfb      	ldrb	r3, [r7, #15]
}
 800a41c:	4618      	mov	r0, r3
 800a41e:	f107 0710 	add.w	r7, r7, #16
 800a422:	46bd      	mov	sp, r7
 800a424:	bd80      	pop	{r7, pc}
 800a426:	bf00      	nop

0800a428 <RTC_CoarseCalibCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are enabled/disabled
  *          - ERROR: RTC Coarse calibration are not enabled/disabled    
  */
ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
{
 800a428:	b580      	push	{r7, lr}
 800a42a:	b084      	sub	sp, #16
 800a42c:	af00      	add	r7, sp, #0
 800a42e:	4603      	mov	r3, r0
 800a430:	71fb      	strb	r3, [r7, #7]
  ErrorStatus status = ERROR;
 800a432:	f04f 0300 	mov.w	r3, #0
 800a436:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a438:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a43c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a440:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a444:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a446:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a44a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a44e:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a452:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 800a454:	f7ff f8aa 	bl	80095ac <RTC_EnterInitMode>
 800a458:	4603      	mov	r3, r0
 800a45a:	2b00      	cmp	r3, #0
 800a45c:	d103      	bne.n	800a466 <RTC_CoarseCalibCmd+0x3e>
  {
    status =  ERROR;
 800a45e:	f04f 0300 	mov.w	r3, #0
 800a462:	73fb      	strb	r3, [r7, #15]
 800a464:	e020      	b.n	800a4a8 <RTC_CoarseCalibCmd+0x80>
  }
  else
  {
    if (NewState != DISABLE)
 800a466:	79fb      	ldrb	r3, [r7, #7]
 800a468:	2b00      	cmp	r3, #0
 800a46a:	d00c      	beq.n	800a486 <RTC_CoarseCalibCmd+0x5e>
    {
      /* Enable the Coarse Calibration */
      RTC->CR |= (uint32_t)RTC_CR_DCE;
 800a46c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a470:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a474:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a478:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a47c:	6892      	ldr	r2, [r2, #8]
 800a47e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a482:	609a      	str	r2, [r3, #8]
 800a484:	e00b      	b.n	800a49e <RTC_CoarseCalibCmd+0x76>
    }
    else
    { 
      /* Disable the Coarse Calibration */
      RTC->CR &= (uint32_t)~RTC_CR_DCE;
 800a486:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a48a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a48e:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a492:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a496:	6892      	ldr	r2, [r2, #8]
 800a498:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a49c:	609a      	str	r2, [r3, #8]
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 800a49e:	f7ff f8cf 	bl	8009640 <RTC_ExitInitMode>
    
    status = SUCCESS;
 800a4a2:	f04f 0301 	mov.w	r3, #1
 800a4a6:	73fb      	strb	r3, [r7, #15]
  } 
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a4a8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a4ac:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a4b0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a4b4:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 800a4b6:	7bfb      	ldrb	r3, [r7, #15]
}
 800a4b8:	4618      	mov	r0, r3
 800a4ba:	f107 0710 	add.w	r7, r7, #16
 800a4be:	46bd      	mov	sp, r7
 800a4c0:	bd80      	pop	{r7, pc}
 800a4c2:	bf00      	nop

0800a4c4 <RTC_CalibOutputCmd>:
  * @param  NewState: new state of the digital calibration Output.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_CalibOutputCmd(FunctionalState NewState)
{
 800a4c4:	b480      	push	{r7}
 800a4c6:	b083      	sub	sp, #12
 800a4c8:	af00      	add	r7, sp, #0
 800a4ca:	4603      	mov	r3, r0
 800a4cc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a4ce:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a4d2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a4d6:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a4da:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a4dc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a4e0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a4e4:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a4e8:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
 800a4ea:	79fb      	ldrb	r3, [r7, #7]
 800a4ec:	2b00      	cmp	r3, #0
 800a4ee:	d00c      	beq.n	800a50a <RTC_CalibOutputCmd+0x46>
  {
    /* Enable the RTC clock output */
    RTC->CR |= (uint32_t)RTC_CR_COE;
 800a4f0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a4f4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a4f8:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a4fc:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a500:	6892      	ldr	r2, [r2, #8]
 800a502:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 800a506:	609a      	str	r2, [r3, #8]
 800a508:	e00b      	b.n	800a522 <RTC_CalibOutputCmd+0x5e>
  }
  else
  { 
    /* Disable the RTC clock output */
    RTC->CR &= (uint32_t)~RTC_CR_COE;
 800a50a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a50e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a512:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a516:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a51a:	6892      	ldr	r2, [r2, #8]
 800a51c:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 800a520:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a522:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a526:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a52a:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a52e:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a530:	f107 070c 	add.w	r7, r7, #12
 800a534:	46bd      	mov	sp, r7
 800a536:	bc80      	pop	{r7}
 800a538:	4770      	bx	lr
 800a53a:	bf00      	nop

0800a53c <RTC_CalibOutputConfig>:
  *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
  *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
  * @retval None
*/
void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
{
 800a53c:	b480      	push	{r7}
 800a53e:	b083      	sub	sp, #12
 800a540:	af00      	add	r7, sp, #0
 800a542:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a544:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a548:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a54c:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a550:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a552:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a556:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a55a:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a55e:	625a      	str	r2, [r3, #36]	; 0x24
  
  /*clear flags before config*/
  RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
 800a560:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a564:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a568:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a56c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a570:	6892      	ldr	r2, [r2, #8]
 800a572:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 800a576:	609a      	str	r2, [r3, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)RTC_CalibOutput;
 800a578:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a57c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a580:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a584:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a588:	6892      	ldr	r2, [r2, #8]
 800a58a:	4611      	mov	r1, r2
 800a58c:	687a      	ldr	r2, [r7, #4]
 800a58e:	430a      	orrs	r2, r1
 800a590:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 800a592:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a596:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a59a:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a59e:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a5a0:	f107 070c 	add.w	r7, r7, #12
 800a5a4:	46bd      	mov	sp, r7
 800a5a6:	bc80      	pop	{r7}
 800a5a8:	4770      	bx	lr
 800a5aa:	bf00      	nop

0800a5ac <RTC_SmoothCalibConfig>:
  *          - ERROR: RTC Calib registers are not configured
*/
ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
                                  uint32_t RTC_SmoothCalibPlusPulses,
                                  uint32_t RTC_SmouthCalibMinusPulsesValue)
{
 800a5ac:	b480      	push	{r7}
 800a5ae:	b087      	sub	sp, #28
 800a5b0:	af00      	add	r7, sp, #0
 800a5b2:	60f8      	str	r0, [r7, #12]
 800a5b4:	60b9      	str	r1, [r7, #8]
 800a5b6:	607a      	str	r2, [r7, #4]
  ErrorStatus status = ERROR;
 800a5b8:	f04f 0300 	mov.w	r3, #0
 800a5bc:	75fb      	strb	r3, [r7, #23]
  uint32_t recalpfcount = 0;
 800a5be:	f04f 0300 	mov.w	r3, #0
 800a5c2:	613b      	str	r3, [r7, #16]
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a5c4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a5c8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a5cc:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a5d0:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a5d2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a5d6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a5da:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a5de:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 800a5e0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a5e4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a5e8:	68db      	ldr	r3, [r3, #12]
 800a5ea:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800a5ee:	2b00      	cmp	r3, #0
 800a5f0:	d011      	beq.n	800a616 <RTC_SmoothCalibConfig+0x6a>
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 800a5f2:	e003      	b.n	800a5fc <RTC_SmoothCalibConfig+0x50>
    {
      recalpfcount++;
 800a5f4:	693b      	ldr	r3, [r7, #16]
 800a5f6:	f103 0301 	add.w	r3, r3, #1
 800a5fa:	613b      	str	r3, [r7, #16]
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 800a5fc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a600:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a604:	68db      	ldr	r3, [r3, #12]
 800a606:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800a60a:	2b00      	cmp	r3, #0
 800a60c:	d003      	beq.n	800a616 <RTC_SmoothCalibConfig+0x6a>
 800a60e:	693b      	ldr	r3, [r7, #16]
 800a610:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800a614:	d1ee      	bne.n	800a5f4 <RTC_SmoothCalibConfig+0x48>
      recalpfcount++;
    }
  }

  /* check if the calibration pending is completed or if there is no calibration operation at all*/
  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
 800a616:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a61a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a61e:	68db      	ldr	r3, [r3, #12]
 800a620:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800a624:	2b00      	cmp	r3, #0
 800a626:	d10d      	bne.n	800a644 <RTC_SmoothCalibConfig+0x98>
  {
    /* Configure the Smooth calibration settings */
    RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
 800a628:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a62c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a630:	68f9      	ldr	r1, [r7, #12]
 800a632:	68ba      	ldr	r2, [r7, #8]
 800a634:	4311      	orrs	r1, r2
 800a636:	687a      	ldr	r2, [r7, #4]
 800a638:	430a      	orrs	r2, r1
 800a63a:	63da      	str	r2, [r3, #60]	; 0x3c

    status = SUCCESS;
 800a63c:	f04f 0301 	mov.w	r3, #1
 800a640:	75fb      	strb	r3, [r7, #23]
 800a642:	e002      	b.n	800a64a <RTC_SmoothCalibConfig+0x9e>
  }
  else
  {
    status = ERROR;
 800a644:	f04f 0300 	mov.w	r3, #0
 800a648:	75fb      	strb	r3, [r7, #23]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 800a64a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a64e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a652:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a656:	625a      	str	r2, [r3, #36]	; 0x24
  
  return (ErrorStatus)(status);
 800a658:	7dfb      	ldrb	r3, [r7, #23]
}
 800a65a:	4618      	mov	r0, r3
 800a65c:	f107 071c 	add.w	r7, r7, #28
 800a660:	46bd      	mov	sp, r7
 800a662:	bc80      	pop	{r7}
 800a664:	4770      	bx	lr
 800a666:	bf00      	nop

0800a668 <RTC_TimeStampCmd>:
  * @param  NewState: new state of the TimeStamp.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
{
 800a668:	b480      	push	{r7}
 800a66a:	b085      	sub	sp, #20
 800a66c:	af00      	add	r7, sp, #0
 800a66e:	6078      	str	r0, [r7, #4]
 800a670:	460b      	mov	r3, r1
 800a672:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg = 0;
 800a674:	f04f 0300 	mov.w	r3, #0
 800a678:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 800a67a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a67e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a682:	689b      	ldr	r3, [r3, #8]
 800a684:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800a688:	f023 0308 	bic.w	r3, r3, #8
 800a68c:	60fb      	str	r3, [r7, #12]

  /* Get the new configuration */
  if (NewState != DISABLE)
 800a68e:	78fb      	ldrb	r3, [r7, #3]
 800a690:	2b00      	cmp	r3, #0
 800a692:	d006      	beq.n	800a6a2 <RTC_TimeStampCmd+0x3a>
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
 800a694:	687a      	ldr	r2, [r7, #4]
 800a696:	68fb      	ldr	r3, [r7, #12]
 800a698:	4313      	orrs	r3, r2
 800a69a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800a69e:	60fb      	str	r3, [r7, #12]
 800a6a0:	e003      	b.n	800a6aa <RTC_TimeStampCmd+0x42>
  }
  else
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge);
 800a6a2:	68fa      	ldr	r2, [r7, #12]
 800a6a4:	687b      	ldr	r3, [r7, #4]
 800a6a6:	4313      	orrs	r3, r2
 800a6a8:	60fb      	str	r3, [r7, #12]
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800a6aa:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a6ae:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a6b2:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800a6b6:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800a6b8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a6bc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a6c0:	f04f 0253 	mov.w	r2, #83	; 0x53
 800a6c4:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Time Stamp TSEDGE and Enable bits */
  RTC->CR = (uint32_t)tmpreg;
 800a6c6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a6ca:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a6ce:	68fa      	ldr	r2, [r7, #12]
 800a6d0:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800a6d2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a6d6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a6da:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800a6de:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a6e0:	f107 0714 	add.w	r7, r7, #20
 800a6e4:	46bd      	mov	sp, r7
 800a6e6:	bc80      	pop	{r7}
 800a6e8:	4770      	bx	lr
 800a6ea:	bf00      	nop

0800a6ec <RTC_GetTimeStamp>:
  *                             contains the TimeStamp date values.     
  * @retval None
  */
void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
                                      RTC_DateTypeDef* RTC_StampDateStruct)
{
 800a6ec:	b580      	push	{r7, lr}
 800a6ee:	b086      	sub	sp, #24
 800a6f0:	af00      	add	r7, sp, #0
 800a6f2:	60f8      	str	r0, [r7, #12]
 800a6f4:	60b9      	str	r1, [r7, #8]
 800a6f6:	607a      	str	r2, [r7, #4]
  uint32_t tmptime = 0, tmpdate = 0;
 800a6f8:	f04f 0300 	mov.w	r3, #0
 800a6fc:	617b      	str	r3, [r7, #20]
 800a6fe:	f04f 0300 	mov.w	r3, #0
 800a702:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
 800a704:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a708:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a70c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a70e:	461a      	mov	r2, r3
 800a710:	f647 737f 	movw	r3, #32639	; 0x7f7f
 800a714:	f2c0 037f 	movt	r3, #127	; 0x7f
 800a718:	4013      	ands	r3, r2
 800a71a:	617b      	str	r3, [r7, #20]
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
 800a71c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a720:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a724:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a726:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800a72a:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800a72e:	613b      	str	r3, [r7, #16]

  /* Fill the Time structure fields with the read parameters */
  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 800a730:	697b      	ldr	r3, [r7, #20]
 800a732:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 800a736:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800a73a:	b2da      	uxtb	r2, r3
 800a73c:	68bb      	ldr	r3, [r7, #8]
 800a73e:	701a      	strb	r2, [r3, #0]
  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 800a740:	697b      	ldr	r3, [r7, #20]
 800a742:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 800a746:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800a74a:	b2da      	uxtb	r2, r3
 800a74c:	68bb      	ldr	r3, [r7, #8]
 800a74e:	705a      	strb	r2, [r3, #1]
  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 800a750:	697b      	ldr	r3, [r7, #20]
 800a752:	b2db      	uxtb	r3, r3
 800a754:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800a758:	b2da      	uxtb	r2, r3
 800a75a:	68bb      	ldr	r3, [r7, #8]
 800a75c:	709a      	strb	r2, [r3, #2]
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
 800a75e:	697b      	ldr	r3, [r7, #20]
 800a760:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800a764:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800a768:	b2da      	uxtb	r2, r3
 800a76a:	68bb      	ldr	r3, [r7, #8]
 800a76c:	70da      	strb	r2, [r3, #3]

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
 800a76e:	687b      	ldr	r3, [r7, #4]
 800a770:	f04f 0200 	mov.w	r2, #0
 800a774:	70da      	strb	r2, [r3, #3]
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 800a776:	693b      	ldr	r3, [r7, #16]
 800a778:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
 800a77c:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800a780:	b2da      	uxtb	r2, r3
 800a782:	687b      	ldr	r3, [r7, #4]
 800a784:	705a      	strb	r2, [r3, #1]
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 800a786:	693b      	ldr	r3, [r7, #16]
 800a788:	b2db      	uxtb	r3, r3
 800a78a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a78e:	b2da      	uxtb	r2, r3
 800a790:	687b      	ldr	r3, [r7, #4]
 800a792:	709a      	strb	r2, [r3, #2]
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 800a794:	693b      	ldr	r3, [r7, #16]
 800a796:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 800a79a:	ea4f 3353 	mov.w	r3, r3, lsr #13
 800a79e:	b2da      	uxtb	r2, r3
 800a7a0:	687b      	ldr	r3, [r7, #4]
 800a7a2:	701a      	strb	r2, [r3, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 800a7a4:	68fb      	ldr	r3, [r7, #12]
 800a7a6:	2b00      	cmp	r3, #0
 800a7a8:	d135      	bne.n	800a816 <RTC_GetTimeStamp+0x12a>
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
 800a7aa:	68bb      	ldr	r3, [r7, #8]
 800a7ac:	781b      	ldrb	r3, [r3, #0]
 800a7ae:	4618      	mov	r0, r3
 800a7b0:	f000 fb96 	bl	800aee0 <RTC_Bcd2ToByte>
 800a7b4:	4603      	mov	r3, r0
 800a7b6:	461a      	mov	r2, r3
 800a7b8:	68bb      	ldr	r3, [r7, #8]
 800a7ba:	701a      	strb	r2, [r3, #0]
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 800a7bc:	68bb      	ldr	r3, [r7, #8]
 800a7be:	785b      	ldrb	r3, [r3, #1]
 800a7c0:	4618      	mov	r0, r3
 800a7c2:	f000 fb8d 	bl	800aee0 <RTC_Bcd2ToByte>
 800a7c6:	4603      	mov	r3, r0
 800a7c8:	461a      	mov	r2, r3
 800a7ca:	68bb      	ldr	r3, [r7, #8]
 800a7cc:	705a      	strb	r2, [r3, #1]
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 800a7ce:	68bb      	ldr	r3, [r7, #8]
 800a7d0:	789b      	ldrb	r3, [r3, #2]
 800a7d2:	4618      	mov	r0, r3
 800a7d4:	f000 fb84 	bl	800aee0 <RTC_Bcd2ToByte>
 800a7d8:	4603      	mov	r3, r0
 800a7da:	461a      	mov	r2, r3
 800a7dc:	68bb      	ldr	r3, [r7, #8]
 800a7de:	709a      	strb	r2, [r3, #2]

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
 800a7e0:	687b      	ldr	r3, [r7, #4]
 800a7e2:	785b      	ldrb	r3, [r3, #1]
 800a7e4:	4618      	mov	r0, r3
 800a7e6:	f000 fb7b 	bl	800aee0 <RTC_Bcd2ToByte>
 800a7ea:	4603      	mov	r3, r0
 800a7ec:	461a      	mov	r2, r3
 800a7ee:	687b      	ldr	r3, [r7, #4]
 800a7f0:	705a      	strb	r2, [r3, #1]
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 800a7f2:	687b      	ldr	r3, [r7, #4]
 800a7f4:	789b      	ldrb	r3, [r3, #2]
 800a7f6:	4618      	mov	r0, r3
 800a7f8:	f000 fb72 	bl	800aee0 <RTC_Bcd2ToByte>
 800a7fc:	4603      	mov	r3, r0
 800a7fe:	461a      	mov	r2, r3
 800a800:	687b      	ldr	r3, [r7, #4]
 800a802:	709a      	strb	r2, [r3, #2]
    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 800a804:	687b      	ldr	r3, [r7, #4]
 800a806:	781b      	ldrb	r3, [r3, #0]
 800a808:	4618      	mov	r0, r3
 800a80a:	f000 fb69 	bl	800aee0 <RTC_Bcd2ToByte>
 800a80e:	4603      	mov	r3, r0
 800a810:	461a      	mov	r2, r3
 800a812:	687b      	ldr	r3, [r7, #4]
 800a814:	701a      	strb	r2, [r3, #0]
  }
}
 800a816:	f107 0718 	add.w	r7, r7, #24
 800a81a:	46bd      	mov	sp, r7
 800a81c:	bd80      	pop	{r7, pc}
 800a81e:	bf00      	nop

0800a820 <RTC_GetTimeStampSubSecond>:
  * @brief  Get the RTC timestamp Subseconds value.
  * @param  None
  * @retval RTC current timestamp Subseconds value.
  */
uint32_t RTC_GetTimeStampSubSecond(void)
{
 800a820:	b480      	push	{r7}
 800a822:	af00      	add	r7, sp, #0
  /* Get timestamp subseconds values from the correspondent registers */
  return (uint32_t)(RTC->TSSSR);
 800a824:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a828:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a82c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 800a82e:	4618      	mov	r0, r3
 800a830:	46bd      	mov	sp, r7
 800a832:	bc80      	pop	{r7}
 800a834:	4770      	bx	lr
 800a836:	bf00      	nop

0800a838 <RTC_TamperTriggerConfig>:
  *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
  *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
  * @retval None
  */
void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
{
 800a838:	b480      	push	{r7}
 800a83a:	b083      	sub	sp, #12
 800a83c:	af00      	add	r7, sp, #0
 800a83e:	6078      	str	r0, [r7, #4]
 800a840:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
 800a842:	683b      	ldr	r3, [r7, #0]
 800a844:	2b00      	cmp	r3, #0
 800a846:	d111      	bne.n	800a86c <RTC_TamperTriggerConfig+0x34>
  {  
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 800a848:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a84c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a850:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a854:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a858:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a85a:	4611      	mov	r1, r2
 800a85c:	687a      	ldr	r2, [r7, #4]
 800a85e:	ea4f 0242 	mov.w	r2, r2, lsl #1
 800a862:	ea6f 0202 	mvn.w	r2, r2
 800a866:	400a      	ands	r2, r1
 800a868:	641a      	str	r2, [r3, #64]	; 0x40
 800a86a:	e00e      	b.n	800a88a <RTC_TamperTriggerConfig+0x52>
  }
  else
  { 
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
 800a86c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a870:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a874:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a878:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a87c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a87e:	4611      	mov	r1, r2
 800a880:	687a      	ldr	r2, [r7, #4]
 800a882:	ea4f 0242 	mov.w	r2, r2, lsl #1
 800a886:	430a      	orrs	r2, r1
 800a888:	641a      	str	r2, [r3, #64]	; 0x40
  }  
}
 800a88a:	f107 070c 	add.w	r7, r7, #12
 800a88e:	46bd      	mov	sp, r7
 800a890:	bc80      	pop	{r7}
 800a892:	4770      	bx	lr

0800a894 <RTC_TamperCmd>:
  * @param  NewState: new state of the tamper pin.
  *          This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
{
 800a894:	b480      	push	{r7}
 800a896:	b083      	sub	sp, #12
 800a898:	af00      	add	r7, sp, #0
 800a89a:	6078      	str	r0, [r7, #4]
 800a89c:	460b      	mov	r3, r1
 800a89e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800a8a0:	78fb      	ldrb	r3, [r7, #3]
 800a8a2:	2b00      	cmp	r3, #0
 800a8a4:	d00d      	beq.n	800a8c2 <RTC_TamperCmd+0x2e>
  {
    /* Enable the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
 800a8a6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a8aa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a8ae:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a8b2:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a8b6:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a8b8:	4611      	mov	r1, r2
 800a8ba:	687a      	ldr	r2, [r7, #4]
 800a8bc:	430a      	orrs	r2, r1
 800a8be:	641a      	str	r2, [r3, #64]	; 0x40
 800a8c0:	e00e      	b.n	800a8e0 <RTC_TamperCmd+0x4c>
  }
  else
  {
    /* Disable the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
 800a8c2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a8c6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a8ca:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a8ce:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a8d2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a8d4:	4611      	mov	r1, r2
 800a8d6:	687a      	ldr	r2, [r7, #4]
 800a8d8:	ea6f 0202 	mvn.w	r2, r2
 800a8dc:	400a      	ands	r2, r1
 800a8de:	641a      	str	r2, [r3, #64]	; 0x40
  }  
}
 800a8e0:	f107 070c 	add.w	r7, r7, #12
 800a8e4:	46bd      	mov	sp, r7
 800a8e6:	bc80      	pop	{r7}
 800a8e8:	4770      	bx	lr
 800a8ea:	bf00      	nop

0800a8ec <RTC_TamperFilterConfig>:
  *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
  *                                    samples at the active level 
  * @retval None
  */
void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
{
 800a8ec:	b480      	push	{r7}
 800a8ee:	b083      	sub	sp, #12
 800a8f0:	af00      	add	r7, sp, #0
 800a8f2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   
  /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
 800a8f4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a8f8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a8fc:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a900:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a904:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a906:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
 800a90a:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
 800a90c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a910:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a914:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a918:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a91c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a91e:	4611      	mov	r1, r2
 800a920:	687a      	ldr	r2, [r7, #4]
 800a922:	430a      	orrs	r2, r1
 800a924:	641a      	str	r2, [r3, #64]	; 0x40
}
 800a926:	f107 070c 	add.w	r7, r7, #12
 800a92a:	46bd      	mov	sp, r7
 800a92c:	bc80      	pop	{r7}
 800a92e:	4770      	bx	lr

0800a930 <RTC_TamperSamplingFreqConfig>:
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 256  
  * @retval None
  */
void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
{
 800a930:	b480      	push	{r7}
 800a932:	b083      	sub	sp, #12
 800a934:	af00      	add	r7, sp, #0
 800a936:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
 
  /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
 800a938:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a93c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a940:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a944:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a948:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a94a:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 800a94e:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
 800a950:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a954:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a958:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a95c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a960:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a962:	4611      	mov	r1, r2
 800a964:	687a      	ldr	r2, [r7, #4]
 800a966:	430a      	orrs	r2, r1
 800a968:	641a      	str	r2, [r3, #64]	; 0x40
}
 800a96a:	f107 070c 	add.w	r7, r7, #12
 800a96e:	46bd      	mov	sp, r7
 800a970:	bc80      	pop	{r7}
 800a972:	4770      	bx	lr

0800a974 <RTC_TamperPinsPrechargeDuration>:
  *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are pre-charged before sampling during 4 RTCCLK cycle    
  *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are pre-charged before sampling during 8 RTCCLK cycle
  * @retval None
  */
void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
{
 800a974:	b480      	push	{r7}
 800a976:	b083      	sub	sp, #12
 800a978:	af00      	add	r7, sp, #0
 800a97a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   
  /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
 800a97c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a980:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a984:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a988:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a98c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a98e:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
 800a992:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
 800a994:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a998:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a99c:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a9a0:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a9a4:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a9a6:	4611      	mov	r1, r2
 800a9a8:	687a      	ldr	r2, [r7, #4]
 800a9aa:	430a      	orrs	r2, r1
 800a9ac:	641a      	str	r2, [r3, #64]	; 0x40
}
 800a9ae:	f107 070c 	add.w	r7, r7, #12
 800a9b2:	46bd      	mov	sp, r7
 800a9b4:	bc80      	pop	{r7}
 800a9b6:	4770      	bx	lr

0800a9b8 <RTC_TimeStampOnTamperDetectionCmd>:
  * @param  NewState: new state of the timestamp on tamper event.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
{
 800a9b8:	b480      	push	{r7}
 800a9ba:	b083      	sub	sp, #12
 800a9bc:	af00      	add	r7, sp, #0
 800a9be:	4603      	mov	r3, r0
 800a9c0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
 800a9c2:	79fb      	ldrb	r3, [r7, #7]
 800a9c4:	2b00      	cmp	r3, #0
 800a9c6:	d00c      	beq.n	800a9e2 <RTC_TimeStampOnTamperDetectionCmd+0x2a>
  {
    /* Save timestamp on tamper detection event */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 800a9c8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a9cc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a9d0:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a9d4:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a9d8:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a9da:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a9de:	641a      	str	r2, [r3, #64]	; 0x40
 800a9e0:	e00b      	b.n	800a9fa <RTC_TimeStampOnTamperDetectionCmd+0x42>
  }
  else
  {
    /* Tamper detection does not cause a timestamp to be saved */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
 800a9e2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800a9e6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800a9ea:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800a9ee:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800a9f2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a9f4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a9f8:	641a      	str	r2, [r3, #64]	; 0x40
  }
}
 800a9fa:	f107 070c 	add.w	r7, r7, #12
 800a9fe:	46bd      	mov	sp, r7
 800aa00:	bc80      	pop	{r7}
 800aa02:	4770      	bx	lr

0800aa04 <RTC_TamperPullUpCmd>:
  * @param  NewState: new state of tamper pull up.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperPullUpCmd(FunctionalState NewState)
{
 800aa04:	b480      	push	{r7}
 800aa06:	b083      	sub	sp, #12
 800aa08:	af00      	add	r7, sp, #0
 800aa0a:	4603      	mov	r3, r0
 800aa0c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
 800aa0e:	79fb      	ldrb	r3, [r7, #7]
 800aa10:	2b00      	cmp	r3, #0
 800aa12:	d00c      	beq.n	800aa2e <RTC_TamperPullUpCmd+0x2a>
  {
    /* Enable precharge of the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 800aa14:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800aa18:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800aa1c:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800aa20:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800aa24:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800aa26:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800aa2a:	641a      	str	r2, [r3, #64]	; 0x40
 800aa2c:	e00b      	b.n	800aa46 <RTC_TamperPullUpCmd+0x42>
  }
  else
  {
    /* Disable precharge of the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
 800aa2e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800aa32:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800aa36:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800aa3a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800aa3e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800aa40:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800aa44:	641a      	str	r2, [r3, #64]	; 0x40
  } 
}
 800aa46:	f107 070c 	add.w	r7, r7, #12
 800aa4a:	46bd      	mov	sp, r7
 800aa4c:	bc80      	pop	{r7}
 800aa4e:	4770      	bx	lr

0800aa50 <RTC_WriteBackupRegister>:
  *                          specify the register.
  * @param  Data: Data to be written in the specified RTC Backup data register.                     
  * @retval None
  */
void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
{
 800aa50:	b480      	push	{r7}
 800aa52:	b085      	sub	sp, #20
 800aa54:	af00      	add	r7, sp, #0
 800aa56:	6078      	str	r0, [r7, #4]
 800aa58:	6039      	str	r1, [r7, #0]
  __IO uint32_t tmp = 0;
 800aa5a:	f04f 0300 	mov.w	r3, #0
 800aa5e:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 800aa60:	f642 0350 	movw	r3, #10320	; 0x2850
 800aa64:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800aa68:	60fb      	str	r3, [r7, #12]
  tmp += (RTC_BKP_DR * 4);
 800aa6a:	687b      	ldr	r3, [r7, #4]
 800aa6c:	ea4f 0283 	mov.w	r2, r3, lsl #2
 800aa70:	68fb      	ldr	r3, [r7, #12]
 800aa72:	18d3      	adds	r3, r2, r3
 800aa74:	60fb      	str	r3, [r7, #12]

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 800aa76:	68fb      	ldr	r3, [r7, #12]
 800aa78:	683a      	ldr	r2, [r7, #0]
 800aa7a:	601a      	str	r2, [r3, #0]
}
 800aa7c:	f107 0714 	add.w	r7, r7, #20
 800aa80:	46bd      	mov	sp, r7
 800aa82:	bc80      	pop	{r7}
 800aa84:	4770      	bx	lr
 800aa86:	bf00      	nop

0800aa88 <RTC_ReadBackupRegister>:
  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
  *                          specify the register.                   
  * @retval None
  */
uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
{
 800aa88:	b480      	push	{r7}
 800aa8a:	b085      	sub	sp, #20
 800aa8c:	af00      	add	r7, sp, #0
 800aa8e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmp = 0;
 800aa90:	f04f 0300 	mov.w	r3, #0
 800aa94:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 800aa96:	f642 0350 	movw	r3, #10320	; 0x2850
 800aa9a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800aa9e:	60fb      	str	r3, [r7, #12]
  tmp += (RTC_BKP_DR * 4);
 800aaa0:	687b      	ldr	r3, [r7, #4]
 800aaa2:	ea4f 0283 	mov.w	r2, r3, lsl #2
 800aaa6:	68fb      	ldr	r3, [r7, #12]
 800aaa8:	18d3      	adds	r3, r2, r3
 800aaaa:	60fb      	str	r3, [r7, #12]
  
  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 800aaac:	68fb      	ldr	r3, [r7, #12]
 800aaae:	681b      	ldr	r3, [r3, #0]
}
 800aab0:	4618      	mov	r0, r3
 800aab2:	f107 0714 	add.w	r7, r7, #20
 800aab6:	46bd      	mov	sp, r7
 800aab8:	bc80      	pop	{r7}
 800aaba:	4770      	bx	lr

0800aabc <RTC_TamperPinSelection>:
  *            @arg RTC_TamperPin_PC13: PC13 is selected as RTC Tamper Pin.
  *            @arg RTC_TamperPin_PI8: PI8 is selected as RTC Tamper Pin.    
  * @retval None
  */
void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
{
 800aabc:	b480      	push	{r7}
 800aabe:	b083      	sub	sp, #12
 800aac0:	af00      	add	r7, sp, #0
 800aac2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
 800aac4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800aac8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800aacc:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800aad0:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800aad4:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800aad6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800aada:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
 800aadc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800aae0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800aae4:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800aae8:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800aaec:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800aaee:	4611      	mov	r1, r2
 800aaf0:	687a      	ldr	r2, [r7, #4]
 800aaf2:	430a      	orrs	r2, r1
 800aaf4:	641a      	str	r2, [r3, #64]	; 0x40
}
 800aaf6:	f107 070c 	add.w	r7, r7, #12
 800aafa:	46bd      	mov	sp, r7
 800aafc:	bc80      	pop	{r7}
 800aafe:	4770      	bx	lr

0800ab00 <RTC_TimeStampPinSelection>:
  *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
  *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
  * @retval None
  */
void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
{
 800ab00:	b480      	push	{r7}
 800ab02:	b083      	sub	sp, #12
 800ab04:	af00      	add	r7, sp, #0
 800ab06:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
 800ab08:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ab0c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ab10:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800ab14:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ab18:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ab1a:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800ab1e:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
 800ab20:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ab24:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ab28:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800ab2c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ab30:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ab32:	4611      	mov	r1, r2
 800ab34:	687a      	ldr	r2, [r7, #4]
 800ab36:	430a      	orrs	r2, r1
 800ab38:	641a      	str	r2, [r3, #64]	; 0x40
}
 800ab3a:	f107 070c 	add.w	r7, r7, #12
 800ab3e:	46bd      	mov	sp, r7
 800ab40:	bc80      	pop	{r7}
 800ab42:	4770      	bx	lr

0800ab44 <RTC_OutputTypeConfig>:
  *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
  *                                    Push Pull mode.    
  * @retval None
  */
void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
{
 800ab44:	b480      	push	{r7}
 800ab46:	b083      	sub	sp, #12
 800ab48:	af00      	add	r7, sp, #0
 800ab4a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
 800ab4c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ab50:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ab54:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800ab58:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ab5c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ab5e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800ab62:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
 800ab64:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ab68:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ab6c:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800ab70:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ab74:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ab76:	4611      	mov	r1, r2
 800ab78:	687a      	ldr	r2, [r7, #4]
 800ab7a:	430a      	orrs	r2, r1
 800ab7c:	641a      	str	r2, [r3, #64]	; 0x40
}
 800ab7e:	f107 070c 	add.w	r7, r7, #12
 800ab82:	46bd      	mov	sp, r7
 800ab84:	bc80      	pop	{r7}
 800ab86:	4770      	bx	lr

0800ab88 <RTC_SynchroShiftConfig>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Shift registers are configured
  *          - ERROR: RTC Shift registers are not configured
*/
ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
{
 800ab88:	b580      	push	{r7, lr}
 800ab8a:	b084      	sub	sp, #16
 800ab8c:	af00      	add	r7, sp, #0
 800ab8e:	6078      	str	r0, [r7, #4]
 800ab90:	6039      	str	r1, [r7, #0]
  ErrorStatus status = ERROR;
 800ab92:	f04f 0300 	mov.w	r3, #0
 800ab96:	73fb      	strb	r3, [r7, #15]
  uint32_t shpfcount = 0;
 800ab98:	f04f 0300 	mov.w	r3, #0
 800ab9c:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800ab9e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800aba2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800aba6:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800abaa:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800abac:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800abb0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800abb4:	f04f 0253 	mov.w	r2, #83	; 0x53
 800abb8:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
 800abba:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800abbe:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800abc2:	68db      	ldr	r3, [r3, #12]
 800abc4:	f003 0308 	and.w	r3, r3, #8
 800abc8:	2b00      	cmp	r3, #0
 800abca:	d011      	beq.n	800abf0 <RTC_SynchroShiftConfig+0x68>
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 800abcc:	e003      	b.n	800abd6 <RTC_SynchroShiftConfig+0x4e>
    {
      shpfcount++;
 800abce:	68bb      	ldr	r3, [r7, #8]
 800abd0:	f103 0301 	add.w	r3, r3, #1
 800abd4:	60bb      	str	r3, [r7, #8]
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 800abd6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800abda:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800abde:	68db      	ldr	r3, [r3, #12]
 800abe0:	f003 0308 	and.w	r3, r3, #8
 800abe4:	2b00      	cmp	r3, #0
 800abe6:	d003      	beq.n	800abf0 <RTC_SynchroShiftConfig+0x68>
 800abe8:	68bb      	ldr	r3, [r7, #8]
 800abea:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800abee:	d1ee      	bne.n	800abce <RTC_SynchroShiftConfig+0x46>
      shpfcount++;
    }
  }

  /* Check if the Shift pending is completed or if there is no Shift operation at all*/
  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
 800abf0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800abf4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800abf8:	68db      	ldr	r3, [r3, #12]
 800abfa:	f003 0308 	and.w	r3, r3, #8
 800abfe:	2b00      	cmp	r3, #0
 800ac00:	d121      	bne.n	800ac46 <RTC_SynchroShiftConfig+0xbe>
  {
    /* check if the reference clock detection is disabled */
    if((RTC->CR & RTC_CR_REFCKON) == RESET)
 800ac02:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ac06:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ac0a:	689b      	ldr	r3, [r3, #8]
 800ac0c:	f003 0310 	and.w	r3, r3, #16
 800ac10:	2b00      	cmp	r3, #0
 800ac12:	d114      	bne.n	800ac3e <RTC_SynchroShiftConfig+0xb6>
    {
      /* Configure the Shift settings */
      RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
 800ac14:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ac18:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ac1c:	6839      	ldr	r1, [r7, #0]
 800ac1e:	687a      	ldr	r2, [r7, #4]
 800ac20:	430a      	orrs	r2, r1
 800ac22:	62da      	str	r2, [r3, #44]	; 0x2c
    
      if(RTC_WaitForSynchro() == ERROR)
 800ac24:	f7fe fd1e 	bl	8009664 <RTC_WaitForSynchro>
 800ac28:	4603      	mov	r3, r0
 800ac2a:	2b00      	cmp	r3, #0
 800ac2c:	d103      	bne.n	800ac36 <RTC_SynchroShiftConfig+0xae>
      {
        status = ERROR;
 800ac2e:	f04f 0300 	mov.w	r3, #0
 800ac32:	73fb      	strb	r3, [r7, #15]
 800ac34:	e00a      	b.n	800ac4c <RTC_SynchroShiftConfig+0xc4>
      }
      else
      {
        status = SUCCESS;
 800ac36:	f04f 0301 	mov.w	r3, #1
 800ac3a:	73fb      	strb	r3, [r7, #15]
 800ac3c:	e006      	b.n	800ac4c <RTC_SynchroShiftConfig+0xc4>
      }
    }
    else
    {
      status = ERROR;
 800ac3e:	f04f 0300 	mov.w	r3, #0
 800ac42:	73fb      	strb	r3, [r7, #15]
 800ac44:	e002      	b.n	800ac4c <RTC_SynchroShiftConfig+0xc4>
    }
  }
  else
  {
    status = ERROR;
 800ac46:	f04f 0300 	mov.w	r3, #0
 800ac4a:	73fb      	strb	r3, [r7, #15]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 800ac4c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ac50:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ac54:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800ac58:	625a      	str	r2, [r3, #36]	; 0x24
  
  return (ErrorStatus)(status);
 800ac5a:	7bfb      	ldrb	r3, [r7, #15]
}
 800ac5c:	4618      	mov	r0, r3
 800ac5e:	f107 0710 	add.w	r7, r7, #16
 800ac62:	46bd      	mov	sp, r7
 800ac64:	bd80      	pop	{r7, pc}
 800ac66:	bf00      	nop

0800ac68 <RTC_ITConfig>:
  * @param  NewState: new state of the specified RTC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
{
 800ac68:	b480      	push	{r7}
 800ac6a:	b083      	sub	sp, #12
 800ac6c:	af00      	add	r7, sp, #0
 800ac6e:	6078      	str	r0, [r7, #4]
 800ac70:	460b      	mov	r3, r1
 800ac72:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800ac74:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ac78:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ac7c:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800ac80:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800ac82:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ac86:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ac8a:	f04f 0253 	mov.w	r2, #83	; 0x53
 800ac8e:	625a      	str	r2, [r3, #36]	; 0x24

  if (NewState != DISABLE)
 800ac90:	78fb      	ldrb	r3, [r7, #3]
 800ac92:	2b00      	cmp	r3, #0
 800ac94:	d01e      	beq.n	800acd4 <RTC_ITConfig+0x6c>
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
 800ac96:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ac9a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ac9e:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800aca2:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800aca6:	6892      	ldr	r2, [r2, #8]
 800aca8:	4611      	mov	r1, r2
 800acaa:	687a      	ldr	r2, [r7, #4]
 800acac:	f022 0204 	bic.w	r2, r2, #4
 800acb0:	430a      	orrs	r2, r1
 800acb2:	609a      	str	r2, [r3, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
 800acb4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800acb8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800acbc:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800acc0:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800acc4:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800acc6:	4611      	mov	r1, r2
 800acc8:	687a      	ldr	r2, [r7, #4]
 800acca:	f002 0204 	and.w	r2, r2, #4
 800acce:	430a      	orrs	r2, r1
 800acd0:	641a      	str	r2, [r3, #64]	; 0x40
 800acd2:	e021      	b.n	800ad18 <RTC_ITConfig+0xb0>
  }
  else
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
 800acd4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800acd8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800acdc:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800ace0:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ace4:	6892      	ldr	r2, [r2, #8]
 800ace6:	4611      	mov	r1, r2
 800ace8:	687a      	ldr	r2, [r7, #4]
 800acea:	f022 0204 	bic.w	r2, r2, #4
 800acee:	ea6f 0202 	mvn.w	r2, r2
 800acf2:	400a      	ands	r2, r1
 800acf4:	609a      	str	r2, [r3, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
 800acf6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800acfa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800acfe:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800ad02:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ad06:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ad08:	4611      	mov	r1, r2
 800ad0a:	687a      	ldr	r2, [r7, #4]
 800ad0c:	f002 0204 	and.w	r2, r2, #4
 800ad10:	ea6f 0202 	mvn.w	r2, r2
 800ad14:	400a      	ands	r2, r1
 800ad16:	641a      	str	r2, [r3, #64]	; 0x40
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800ad18:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ad1c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ad20:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800ad24:	625a      	str	r2, [r3, #36]	; 0x24
}
 800ad26:	f107 070c 	add.w	r7, r7, #12
 800ad2a:	46bd      	mov	sp, r7
 800ad2c:	bc80      	pop	{r7}
 800ad2e:	4770      	bx	lr

0800ad30 <RTC_GetFlagStatus>:
  *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
  *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
  * @retval The new state of RTC_FLAG (SET or RESET).
  */
FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
{
 800ad30:	b480      	push	{r7}
 800ad32:	b085      	sub	sp, #20
 800ad34:	af00      	add	r7, sp, #0
 800ad36:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 800ad38:	f04f 0300 	mov.w	r3, #0
 800ad3c:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpreg = 0;
 800ad3e:	f04f 0300 	mov.w	r3, #0
 800ad42:	60bb      	str	r3, [r7, #8]
  
  /* Check the parameters */
  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
  
  /* Get all the flags */
  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
 800ad44:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ad48:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ad4c:	68db      	ldr	r3, [r3, #12]
 800ad4e:	461a      	mov	r2, r3
 800ad50:	f643 7377 	movw	r3, #16247	; 0x3f77
 800ad54:	4013      	ands	r3, r2
 800ad56:	60bb      	str	r3, [r7, #8]
  
  /* Return the status of the flag */
  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
 800ad58:	68ba      	ldr	r2, [r7, #8]
 800ad5a:	687b      	ldr	r3, [r7, #4]
 800ad5c:	4013      	ands	r3, r2
 800ad5e:	2b00      	cmp	r3, #0
 800ad60:	d003      	beq.n	800ad6a <RTC_GetFlagStatus+0x3a>
  {
    bitstatus = SET;
 800ad62:	f04f 0301 	mov.w	r3, #1
 800ad66:	73fb      	strb	r3, [r7, #15]
 800ad68:	e002      	b.n	800ad70 <RTC_GetFlagStatus+0x40>
  }
  else
  {
    bitstatus = RESET;
 800ad6a:	f04f 0300 	mov.w	r3, #0
 800ad6e:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800ad70:	7bfb      	ldrb	r3, [r7, #15]
}
 800ad72:	4618      	mov	r0, r3
 800ad74:	f107 0714 	add.w	r7, r7, #20
 800ad78:	46bd      	mov	sp, r7
 800ad7a:	bc80      	pop	{r7}
 800ad7c:	4770      	bx	lr
 800ad7e:	bf00      	nop

0800ad80 <RTC_ClearFlag>:
  *            @arg RTC_FLAG_ALRAF: Alarm A flag
  *            @arg RTC_FLAG_RSF: Registers Synchronized flag
  * @retval None
  */
void RTC_ClearFlag(uint32_t RTC_FLAG)
{
 800ad80:	b480      	push	{r7}
 800ad82:	b083      	sub	sp, #12
 800ad84:	af00      	add	r7, sp, #0
 800ad86:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));

  /* Clear the Flags in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
 800ad88:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ad8c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ad90:	687a      	ldr	r2, [r7, #4]
 800ad92:	ea4f 4202 	mov.w	r2, r2, lsl #16
 800ad96:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800ad9a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800ad9e:	ea6f 0102 	mvn.w	r1, r2
 800ada2:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800ada6:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800adaa:	68d2      	ldr	r2, [r2, #12]
 800adac:	f002 0280 	and.w	r2, r2, #128	; 0x80
 800adb0:	430a      	orrs	r2, r1
 800adb2:	60da      	str	r2, [r3, #12]
}
 800adb4:	f107 070c 	add.w	r7, r7, #12
 800adb8:	46bd      	mov	sp, r7
 800adba:	bc80      	pop	{r7}
 800adbc:	4770      	bx	lr
 800adbe:	bf00      	nop

0800adc0 <RTC_GetITStatus>:
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval The new state of RTC_IT (SET or RESET).
  */
ITStatus RTC_GetITStatus(uint32_t RTC_IT)
{
 800adc0:	b480      	push	{r7}
 800adc2:	b087      	sub	sp, #28
 800adc4:	af00      	add	r7, sp, #0
 800adc6:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 800adc8:	f04f 0300 	mov.w	r3, #0
 800adcc:	75fb      	strb	r3, [r7, #23]
  uint32_t tmpreg = 0, enablestatus = 0;
 800adce:	f04f 0300 	mov.w	r3, #0
 800add2:	613b      	str	r3, [r7, #16]
 800add4:	f04f 0300 	mov.w	r3, #0
 800add8:	60fb      	str	r3, [r7, #12]
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 800adda:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800adde:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ade2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ade4:	f003 0304 	and.w	r3, r3, #4
 800ade8:	613b      	str	r3, [r7, #16]
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
 800adea:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800adee:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800adf2:	689b      	ldr	r3, [r3, #8]
 800adf4:	461a      	mov	r2, r3
 800adf6:	687b      	ldr	r3, [r7, #4]
 800adf8:	401a      	ands	r2, r3
 800adfa:	687b      	ldr	r3, [r7, #4]
 800adfc:	ea4f 31d3 	mov.w	r1, r3, lsr #15
 800ae00:	693b      	ldr	r3, [r7, #16]
 800ae02:	400b      	ands	r3, r1
 800ae04:	4313      	orrs	r3, r2
 800ae06:	60fb      	str	r3, [r7, #12]
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 800ae08:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ae0c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ae10:	68db      	ldr	r3, [r3, #12]
 800ae12:	461a      	mov	r2, r3
 800ae14:	687b      	ldr	r3, [r7, #4]
 800ae16:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800ae1a:	4013      	ands	r3, r2
 800ae1c:	613b      	str	r3, [r7, #16]
  
  /* Get the status of the Interrupt */
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 800ae1e:	68fb      	ldr	r3, [r7, #12]
 800ae20:	2b00      	cmp	r3, #0
 800ae22:	d00a      	beq.n	800ae3a <RTC_GetITStatus+0x7a>
 800ae24:	693b      	ldr	r3, [r7, #16]
 800ae26:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800ae2a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800ae2e:	2b00      	cmp	r3, #0
 800ae30:	d003      	beq.n	800ae3a <RTC_GetITStatus+0x7a>
  {
    bitstatus = SET;
 800ae32:	f04f 0301 	mov.w	r3, #1
 800ae36:	75fb      	strb	r3, [r7, #23]
 800ae38:	e002      	b.n	800ae40 <RTC_GetITStatus+0x80>
  }
  else
  {
    bitstatus = RESET;
 800ae3a:	f04f 0300 	mov.w	r3, #0
 800ae3e:	75fb      	strb	r3, [r7, #23]
  }
  return bitstatus;
 800ae40:	7dfb      	ldrb	r3, [r7, #23]
}
 800ae42:	4618      	mov	r0, r3
 800ae44:	f107 071c 	add.w	r7, r7, #28
 800ae48:	46bd      	mov	sp, r7
 800ae4a:	bc80      	pop	{r7}
 800ae4c:	4770      	bx	lr
 800ae4e:	bf00      	nop

0800ae50 <RTC_ClearITPendingBit>:
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval None
  */
void RTC_ClearITPendingBit(uint32_t RTC_IT)
{
 800ae50:	b480      	push	{r7}
 800ae52:	b085      	sub	sp, #20
 800ae54:	af00      	add	r7, sp, #0
 800ae56:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 800ae58:	f04f 0300 	mov.w	r3, #0
 800ae5c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_IT(RTC_IT));

  /* Get the RTC_ISR Interrupt pending bits mask */
  tmpreg = (uint32_t)(RTC_IT >> 4);
 800ae5e:	687b      	ldr	r3, [r7, #4]
 800ae60:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800ae64:	60fb      	str	r3, [r7, #12]

  /* Clear the interrupt pending bits in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
 800ae66:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 800ae6a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ae6e:	68fa      	ldr	r2, [r7, #12]
 800ae70:	ea4f 4202 	mov.w	r2, r2, lsl #16
 800ae74:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800ae78:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800ae7c:	ea6f 0102 	mvn.w	r1, r2
 800ae80:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 800ae84:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ae88:	68d2      	ldr	r2, [r2, #12]
 800ae8a:	f002 0280 	and.w	r2, r2, #128	; 0x80
 800ae8e:	430a      	orrs	r2, r1
 800ae90:	60da      	str	r2, [r3, #12]
}
 800ae92:	f107 0714 	add.w	r7, r7, #20
 800ae96:	46bd      	mov	sp, r7
 800ae98:	bc80      	pop	{r7}
 800ae9a:	4770      	bx	lr

0800ae9c <RTC_ByteToBcd2>:
  * @brief  Converts a 2 digit decimal to BCD format.
  * @param  Value: Byte to be converted.
  * @retval Converted byte
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
 800ae9c:	b480      	push	{r7}
 800ae9e:	b085      	sub	sp, #20
 800aea0:	af00      	add	r7, sp, #0
 800aea2:	4603      	mov	r3, r0
 800aea4:	71fb      	strb	r3, [r7, #7]
  uint8_t bcdhigh = 0;
 800aea6:	f04f 0300 	mov.w	r3, #0
 800aeaa:	73fb      	strb	r3, [r7, #15]
  
  while (Value >= 10)
 800aeac:	e007      	b.n	800aebe <RTC_ByteToBcd2+0x22>
  {
    bcdhigh++;
 800aeae:	7bfb      	ldrb	r3, [r7, #15]
 800aeb0:	f103 0301 	add.w	r3, r3, #1
 800aeb4:	73fb      	strb	r3, [r7, #15]
    Value -= 10;
 800aeb6:	79fb      	ldrb	r3, [r7, #7]
 800aeb8:	f1a3 030a 	sub.w	r3, r3, #10
 800aebc:	71fb      	strb	r3, [r7, #7]
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 800aebe:	79fb      	ldrb	r3, [r7, #7]
 800aec0:	2b09      	cmp	r3, #9
 800aec2:	d8f4      	bhi.n	800aeae <RTC_ByteToBcd2+0x12>
  {
    bcdhigh++;
    Value -= 10;
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
 800aec4:	7bfb      	ldrb	r3, [r7, #15]
 800aec6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800aeca:	b2da      	uxtb	r2, r3
 800aecc:	79fb      	ldrb	r3, [r7, #7]
 800aece:	4313      	orrs	r3, r2
 800aed0:	b2db      	uxtb	r3, r3
}
 800aed2:	4618      	mov	r0, r3
 800aed4:	f107 0714 	add.w	r7, r7, #20
 800aed8:	46bd      	mov	sp, r7
 800aeda:	bc80      	pop	{r7}
 800aedc:	4770      	bx	lr
 800aede:	bf00      	nop

0800aee0 <RTC_Bcd2ToByte>:
  * @brief  Convert from 2 digit BCD to Binary.
  * @param  Value: BCD value to be converted.
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
 800aee0:	b480      	push	{r7}
 800aee2:	b085      	sub	sp, #20
 800aee4:	af00      	add	r7, sp, #0
 800aee6:	4603      	mov	r3, r0
 800aee8:	71fb      	strb	r3, [r7, #7]
  uint8_t tmp = 0;
 800aeea:	f04f 0300 	mov.w	r3, #0
 800aeee:	73fb      	strb	r3, [r7, #15]
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 800aef0:	79fb      	ldrb	r3, [r7, #7]
 800aef2:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800aef6:	b2db      	uxtb	r3, r3
 800aef8:	461a      	mov	r2, r3
 800aefa:	ea4f 0282 	mov.w	r2, r2, lsl #2
 800aefe:	18d3      	adds	r3, r2, r3
 800af00:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800af04:	73fb      	strb	r3, [r7, #15]
  return (tmp + (Value & (uint8_t)0x0F));
 800af06:	79fb      	ldrb	r3, [r7, #7]
 800af08:	f003 030f 	and.w	r3, r3, #15
 800af0c:	b2da      	uxtb	r2, r3
 800af0e:	7bfb      	ldrb	r3, [r7, #15]
 800af10:	18d3      	adds	r3, r2, r3
 800af12:	b2db      	uxtb	r3, r3
}
 800af14:	4618      	mov	r0, r3
 800af16:	f107 0714 	add.w	r7, r7, #20
 800af1a:	46bd      	mov	sp, r7
 800af1c:	bc80      	pop	{r7}
 800af1e:	4770      	bx	lr

0800af20 <SPI_I2S_DeInit>:
  *         is managed by the I2S peripheral clock).
  *             
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 800af20:	b580      	push	{r7, lr}
 800af22:	b082      	sub	sp, #8
 800af24:	af00      	add	r7, sp, #0
 800af26:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 800af28:	687a      	ldr	r2, [r7, #4]
 800af2a:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 800af2e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800af32:	429a      	cmp	r2, r3
 800af34:	d10c      	bne.n	800af50 <SPI_I2S_DeInit+0x30>
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 800af36:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800af3a:	f04f 0101 	mov.w	r1, #1
 800af3e:	f7fe f821 	bl	8008f84 <RCC_APB2PeriphResetCmd>
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 800af42:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800af46:	f04f 0100 	mov.w	r1, #0
 800af4a:	f7fe f81b 	bl	8008f84 <RCC_APB2PeriphResetCmd>
 800af4e:	e026      	b.n	800af9e <SPI_I2S_DeInit+0x7e>
  }
  else if (SPIx == SPI2)
 800af50:	687a      	ldr	r2, [r7, #4]
 800af52:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800af56:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800af5a:	429a      	cmp	r2, r3
 800af5c:	d10c      	bne.n	800af78 <SPI_I2S_DeInit+0x58>
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 800af5e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800af62:	f04f 0101 	mov.w	r1, #1
 800af66:	f7fd ffe1 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 800af6a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800af6e:	f04f 0100 	mov.w	r1, #0
 800af72:	f7fd ffdb 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 800af76:	e012      	b.n	800af9e <SPI_I2S_DeInit+0x7e>
    }
  else
  {
    if (SPIx == SPI3)
 800af78:	687a      	ldr	r2, [r7, #4]
 800af7a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800af7e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800af82:	429a      	cmp	r2, r3
 800af84:	d10b      	bne.n	800af9e <SPI_I2S_DeInit+0x7e>
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 800af86:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800af8a:	f04f 0101 	mov.w	r1, #1
 800af8e:	f7fd ffcd 	bl	8008f2c <RCC_APB1PeriphResetCmd>
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 800af92:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800af96:	f04f 0100 	mov.w	r1, #0
 800af9a:	f7fd ffc7 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    }
  }
}
 800af9e:	f107 0708 	add.w	r7, r7, #8
 800afa2:	46bd      	mov	sp, r7
 800afa4:	bd80      	pop	{r7, pc}
 800afa6:	bf00      	nop

0800afa8 <SPI_Init>:
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 800afa8:	b480      	push	{r7}
 800afaa:	b085      	sub	sp, #20
 800afac:	af00      	add	r7, sp, #0
 800afae:	6078      	str	r0, [r7, #4]
 800afb0:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0;
 800afb2:	f04f 0300 	mov.w	r3, #0
 800afb6:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 800afb8:	687b      	ldr	r3, [r7, #4]
 800afba:	881b      	ldrh	r3, [r3, #0]
 800afbc:	81fb      	strh	r3, [r7, #14]
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
 800afbe:	89fb      	ldrh	r3, [r7, #14]
 800afc0:	f403 5341 	and.w	r3, r3, #12352	; 0x3040
 800afc4:	81fb      	strh	r3, [r7, #14]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800afc6:	683b      	ldr	r3, [r7, #0]
 800afc8:	881a      	ldrh	r2, [r3, #0]
 800afca:	683b      	ldr	r3, [r7, #0]
 800afcc:	885b      	ldrh	r3, [r3, #2]
 800afce:	4313      	orrs	r3, r2
 800afd0:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
 800afd2:	683b      	ldr	r3, [r7, #0]
 800afd4:	889b      	ldrh	r3, [r3, #4]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800afd6:	4313      	orrs	r3, r2
 800afd8:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
 800afda:	683b      	ldr	r3, [r7, #0]
 800afdc:	88db      	ldrh	r3, [r3, #6]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800afde:	4313      	orrs	r3, r2
 800afe0:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
 800afe2:	683b      	ldr	r3, [r7, #0]
 800afe4:	891b      	ldrh	r3, [r3, #8]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800afe6:	4313      	orrs	r3, r2
 800afe8:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
 800afea:	683b      	ldr	r3, [r7, #0]
 800afec:	895b      	ldrh	r3, [r3, #10]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800afee:	4313      	orrs	r3, r2
 800aff0:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
 800aff2:	683b      	ldr	r3, [r7, #0]
 800aff4:	899b      	ldrh	r3, [r3, #12]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800aff6:	4313      	orrs	r3, r2
 800aff8:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
 800affa:	683b      	ldr	r3, [r7, #0]
 800affc:	89db      	ldrh	r3, [r3, #14]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800affe:	4313      	orrs	r3, r2
 800b000:	b29a      	uxth	r2, r3
 800b002:	89fb      	ldrh	r3, [r7, #14]
 800b004:	4313      	orrs	r3, r2
 800b006:	81fb      	strh	r3, [r7, #14]
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 800b008:	687b      	ldr	r3, [r7, #4]
 800b00a:	89fa      	ldrh	r2, [r7, #14]
 800b00c:	801a      	strh	r2, [r3, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 800b00e:	687b      	ldr	r3, [r7, #4]
 800b010:	8b9b      	ldrh	r3, [r3, #28]
 800b012:	b29b      	uxth	r3, r3
 800b014:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800b018:	b29a      	uxth	r2, r3
 800b01a:	687b      	ldr	r3, [r7, #4]
 800b01c:	839a      	strh	r2, [r3, #28]
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 800b01e:	683b      	ldr	r3, [r7, #0]
 800b020:	8a1a      	ldrh	r2, [r3, #16]
 800b022:	687b      	ldr	r3, [r7, #4]
 800b024:	821a      	strh	r2, [r3, #16]
}
 800b026:	f107 0714 	add.w	r7, r7, #20
 800b02a:	46bd      	mov	sp, r7
 800b02c:	bc80      	pop	{r7}
 800b02e:	4770      	bx	lr

0800b030 <I2S_Init>:
  *         to the value of the the source clock frequency (in Hz).
  *  
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 800b030:	b480      	push	{r7}
 800b032:	b08b      	sub	sp, #44	; 0x2c
 800b034:	af00      	add	r7, sp, #0
 800b036:	6078      	str	r0, [r7, #4]
 800b038:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
 800b03a:	f04f 0300 	mov.w	r3, #0
 800b03e:	837b      	strh	r3, [r7, #26]
 800b040:	f04f 0302 	mov.w	r3, #2
 800b044:	84fb      	strh	r3, [r7, #38]	; 0x26
 800b046:	f04f 0300 	mov.w	r3, #0
 800b04a:	84bb      	strh	r3, [r7, #36]	; 0x24
 800b04c:	f04f 0301 	mov.w	r3, #1
 800b050:	847b      	strh	r3, [r7, #34]	; 0x22
  uint32_t tmp = 0, i2sclk = 0;
 800b052:	f04f 0300 	mov.w	r3, #0
 800b056:	61fb      	str	r3, [r7, #28]
 800b058:	f04f 0300 	mov.w	r3, #0
 800b05c:	617b      	str	r3, [r7, #20]
#ifndef I2S_EXTERNAL_CLOCK_VAL
  uint32_t pllm = 0, plln = 0, pllr = 0;
 800b05e:	f04f 0300 	mov.w	r3, #0
 800b062:	613b      	str	r3, [r7, #16]
 800b064:	f04f 0300 	mov.w	r3, #0
 800b068:	60fb      	str	r3, [r7, #12]
 800b06a:	f04f 0300 	mov.w	r3, #0
 800b06e:	60bb      	str	r3, [r7, #8]
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 800b070:	687b      	ldr	r3, [r7, #4]
 800b072:	8b9b      	ldrh	r3, [r3, #28]
 800b074:	b29b      	uxth	r3, r3
 800b076:	f423 637a 	bic.w	r3, r3, #4000	; 0xfa0
 800b07a:	f023 031f 	bic.w	r3, r3, #31
 800b07e:	b29a      	uxth	r2, r3
 800b080:	687b      	ldr	r3, [r7, #4]
 800b082:	839a      	strh	r2, [r3, #28]
  SPIx->I2SPR = 0x0002;
 800b084:	687b      	ldr	r3, [r7, #4]
 800b086:	f04f 0202 	mov.w	r2, #2
 800b08a:	841a      	strh	r2, [r3, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 800b08c:	687b      	ldr	r3, [r7, #4]
 800b08e:	8b9b      	ldrh	r3, [r3, #28]
 800b090:	837b      	strh	r3, [r7, #26]
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 800b092:	683b      	ldr	r3, [r7, #0]
 800b094:	689a      	ldr	r2, [r3, #8]
 800b096:	f64a 4344 	movw	r3, #44100	; 0xac44
 800b09a:	429a      	cmp	r2, r3
 800b09c:	d106      	bne.n	800b0ac <I2S_Init+0x7c>
  {
    i2sodd = (uint16_t)1;//0;  //changed due to calc issues
 800b09e:	f04f 0301 	mov.w	r3, #1
 800b0a2:	84bb      	strh	r3, [r7, #36]	; 0x24
    i2sdiv = (uint16_t)53;//2;
 800b0a4:	f04f 0335 	mov.w	r3, #53	; 0x35
 800b0a8:	84fb      	strh	r3, [r7, #38]	; 0x26
 800b0aa:	e0a8      	b.n	800b1fe <I2S_Init+0x1ce>
  }else if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_48k) {
 800b0ac:	683b      	ldr	r3, [r7, #0]
 800b0ae:	689a      	ldr	r2, [r3, #8]
 800b0b0:	f64b 3380 	movw	r3, #48000	; 0xbb80
 800b0b4:	429a      	cmp	r2, r3
 800b0b6:	d106      	bne.n	800b0c6 <I2S_Init+0x96>
	i2sodd = (uint16_t)1;
 800b0b8:	f04f 0301 	mov.w	r3, #1
 800b0bc:	84bb      	strh	r3, [r7, #36]	; 0x24
	i2sdiv = (uint16_t)12;
 800b0be:	f04f 030c 	mov.w	r3, #12
 800b0c2:	84fb      	strh	r3, [r7, #38]	; 0x26
 800b0c4:	e09b      	b.n	800b1fe <I2S_Init+0x1ce>
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) *******************/
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 800b0c6:	683b      	ldr	r3, [r7, #0]
 800b0c8:	889b      	ldrh	r3, [r3, #4]
 800b0ca:	2b00      	cmp	r3, #0
 800b0cc:	d103      	bne.n	800b0d6 <I2S_Init+0xa6>
    {
      /* Packet length is 16 bits */
      packetlength = 1;
 800b0ce:	f04f 0301 	mov.w	r3, #1
 800b0d2:	847b      	strh	r3, [r7, #34]	; 0x22
 800b0d4:	e002      	b.n	800b0dc <I2S_Init+0xac>
    }
    else
    {
      /* Packet length is 32 bits */
      packetlength = 2;
 800b0d6:	f04f 0302 	mov.w	r3, #2
 800b0da:	847b      	strh	r3, [r7, #34]	; 0x22
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 800b0dc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800b0e0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800b0e4:	689b      	ldr	r3, [r3, #8]
 800b0e6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800b0ea:	2b00      	cmp	r3, #0
 800b0ec:	d00b      	beq.n	800b106 <I2S_Init+0xd6>
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
 800b0ee:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800b0f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800b0f6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800b0fa:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800b0fe:	6892      	ldr	r2, [r2, #8]
 800b100:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 800b104:	609a      	str	r2, [r3, #8]
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 800b106:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800b10a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800b10e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800b112:	461a      	mov	r2, r3
 800b114:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800b118:	4013      	ands	r3, r2
 800b11a:	ea4f 1393 	mov.w	r3, r3, lsr #6
 800b11e:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800b122:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800b126:	60fb      	str	r3, [r7, #12]
                      (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
 800b128:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800b12c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800b130:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800b134:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
 800b138:	ea4f 7313 	mov.w	r3, r3, lsr #28
 800b13c:	f003 0307 	and.w	r3, r3, #7
 800b140:	60bb      	str	r3, [r7, #8]
                      (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
 800b142:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800b146:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800b14a:	685b      	ldr	r3, [r3, #4]
 800b14c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800b150:	613b      	str	r3, [r7, #16]
    
    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 800b152:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 800b156:	f2c0 037a 	movt	r3, #122	; 0x7a
 800b15a:	693a      	ldr	r2, [r7, #16]
 800b15c:	fbb3 f3f2 	udiv	r3, r3, r2
 800b160:	68fa      	ldr	r2, [r7, #12]
 800b162:	fb02 f203 	mul.w	r2, r2, r3
 800b166:	68bb      	ldr	r3, [r7, #8]
 800b168:	fbb2 f3f3 	udiv	r3, r2, r3
 800b16c:	617b      	str	r3, [r7, #20]
  #endif /* I2S_EXTERNAL_CLOCK_VAL */
    
    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 800b16e:	683b      	ldr	r3, [r7, #0]
 800b170:	88db      	ldrh	r3, [r3, #6]
 800b172:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800b176:	d113      	bne.n	800b1a0 <I2S_Init+0x170>
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 800b178:	697b      	ldr	r3, [r7, #20]
 800b17a:	ea4f 2213 	mov.w	r2, r3, lsr #8
 800b17e:	4613      	mov	r3, r2
 800b180:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b184:	189b      	adds	r3, r3, r2
 800b186:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800b18a:	461a      	mov	r2, r3
 800b18c:	683b      	ldr	r3, [r7, #0]
 800b18e:	689b      	ldr	r3, [r3, #8]
 800b190:	fbb2 f3f3 	udiv	r3, r2, r3
 800b194:	b29b      	uxth	r3, r3
 800b196:	f103 0305 	add.w	r3, r3, #5
 800b19a:	b29b      	uxth	r3, r3
 800b19c:	61fb      	str	r3, [r7, #28]
 800b19e:	e015      	b.n	800b1cc <I2S_Init+0x19c>
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 800b1a0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800b1a2:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800b1a6:	697a      	ldr	r2, [r7, #20]
 800b1a8:	fbb2 f2f3 	udiv	r2, r2, r3
 800b1ac:	4613      	mov	r3, r2
 800b1ae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b1b2:	189b      	adds	r3, r3, r2
 800b1b4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800b1b8:	461a      	mov	r2, r3
 800b1ba:	683b      	ldr	r3, [r7, #0]
 800b1bc:	689b      	ldr	r3, [r3, #8]
 800b1be:	fbb2 f3f3 	udiv	r3, r2, r3
 800b1c2:	b29b      	uxth	r3, r3
 800b1c4:	f103 0305 	add.w	r3, r3, #5
 800b1c8:	b29b      	uxth	r3, r3
 800b1ca:	61fb      	str	r3, [r7, #28]
    }
    
    /* Remove the flatting point */
    tmp = tmp / 10;  
 800b1cc:	69fa      	ldr	r2, [r7, #28]
 800b1ce:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 800b1d2:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
 800b1d6:	fba3 1302 	umull	r1, r3, r3, r2
 800b1da:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800b1de:	61fb      	str	r3, [r7, #28]
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
 800b1e0:	69fb      	ldr	r3, [r7, #28]
 800b1e2:	b29b      	uxth	r3, r3
 800b1e4:	f003 0301 	and.w	r3, r3, #1
 800b1e8:	84bb      	strh	r3, [r7, #36]	; 0x24
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 800b1ea:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b1ec:	69fa      	ldr	r2, [r7, #28]
 800b1ee:	1ad3      	subs	r3, r2, r3
 800b1f0:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800b1f4:	84fb      	strh	r3, [r7, #38]	; 0x26
   
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 800b1f6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b1f8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800b1fc:	84bb      	strh	r3, [r7, #36]	; 0x24
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 800b1fe:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800b200:	2b01      	cmp	r3, #1
 800b202:	d902      	bls.n	800b20a <I2S_Init+0x1da>
 800b204:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800b206:	2bff      	cmp	r3, #255	; 0xff
 800b208:	d905      	bls.n	800b216 <I2S_Init+0x1e6>
  {
    /* Set the default values */
    i2sdiv = 2;
 800b20a:	f04f 0302 	mov.w	r3, #2
 800b20e:	84fb      	strh	r3, [r7, #38]	; 0x26
    i2sodd = 0;
 800b210:	f04f 0300 	mov.w	r3, #0
 800b214:	84bb      	strh	r3, [r7, #36]	; 0x24
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 800b216:	683b      	ldr	r3, [r7, #0]
 800b218:	88da      	ldrh	r2, [r3, #6]
 800b21a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800b21c:	4313      	orrs	r3, r2
 800b21e:	b29a      	uxth	r2, r3
 800b220:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800b222:	4313      	orrs	r3, r2
 800b224:	b29a      	uxth	r2, r3
 800b226:	687b      	ldr	r3, [r7, #4]
 800b228:	841a      	strh	r2, [r3, #32]
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 800b22a:	683b      	ldr	r3, [r7, #0]
 800b22c:	881a      	ldrh	r2, [r3, #0]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 800b22e:	683b      	ldr	r3, [r7, #0]
 800b230:	8859      	ldrh	r1, [r3, #2]
 800b232:	683b      	ldr	r3, [r7, #0]
 800b234:	8898      	ldrh	r0, [r3, #4]
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 800b236:	683b      	ldr	r3, [r7, #0]
 800b238:	899b      	ldrh	r3, [r3, #12]
  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 800b23a:	4303      	orrs	r3, r0
 800b23c:	b29b      	uxth	r3, r3
 800b23e:	430b      	orrs	r3, r1
 800b240:	b29b      	uxth	r3, r3

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 800b242:	4313      	orrs	r3, r2
 800b244:	b29a      	uxth	r2, r3
 800b246:	8b7b      	ldrh	r3, [r7, #26]
 800b248:	4313      	orrs	r3, r2
 800b24a:	b29b      	uxth	r3, r3
 800b24c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800b250:	837b      	strh	r3, [r7, #26]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  SPIx->I2SCFGR = tmpreg;
 800b252:	687b      	ldr	r3, [r7, #4]
 800b254:	8b7a      	ldrh	r2, [r7, #26]
 800b256:	839a      	strh	r2, [r3, #28]
}
 800b258:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 800b25c:	46bd      	mov	sp, r7
 800b25e:	bc80      	pop	{r7}
 800b260:	4770      	bx	lr
 800b262:	bf00      	nop

0800b264 <SPI_StructInit>:
  * @brief  Fills each SPI_InitStruct member with its default value.
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
  * @retval None
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
 800b264:	b480      	push	{r7}
 800b266:	b083      	sub	sp, #12
 800b268:	af00      	add	r7, sp, #0
 800b26a:	6078      	str	r0, [r7, #4]
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 800b26c:	687b      	ldr	r3, [r7, #4]
 800b26e:	f04f 0200 	mov.w	r2, #0
 800b272:	801a      	strh	r2, [r3, #0]
  /* initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 800b274:	687b      	ldr	r3, [r7, #4]
 800b276:	f04f 0200 	mov.w	r2, #0
 800b27a:	805a      	strh	r2, [r3, #2]
  /* initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 800b27c:	687b      	ldr	r3, [r7, #4]
 800b27e:	f04f 0200 	mov.w	r2, #0
 800b282:	809a      	strh	r2, [r3, #4]
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 800b284:	687b      	ldr	r3, [r7, #4]
 800b286:	f04f 0200 	mov.w	r2, #0
 800b28a:	80da      	strh	r2, [r3, #6]
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 800b28c:	687b      	ldr	r3, [r7, #4]
 800b28e:	f04f 0200 	mov.w	r2, #0
 800b292:	811a      	strh	r2, [r3, #8]
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 800b294:	687b      	ldr	r3, [r7, #4]
 800b296:	f04f 0200 	mov.w	r2, #0
 800b29a:	815a      	strh	r2, [r3, #10]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 800b29c:	687b      	ldr	r3, [r7, #4]
 800b29e:	f04f 0200 	mov.w	r2, #0
 800b2a2:	819a      	strh	r2, [r3, #12]
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 800b2a4:	687b      	ldr	r3, [r7, #4]
 800b2a6:	f04f 0200 	mov.w	r2, #0
 800b2aa:	81da      	strh	r2, [r3, #14]
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 800b2ac:	687b      	ldr	r3, [r7, #4]
 800b2ae:	f04f 0207 	mov.w	r2, #7
 800b2b2:	821a      	strh	r2, [r3, #16]
}
 800b2b4:	f107 070c 	add.w	r7, r7, #12
 800b2b8:	46bd      	mov	sp, r7
 800b2ba:	bc80      	pop	{r7}
 800b2bc:	4770      	bx	lr
 800b2be:	bf00      	nop

0800b2c0 <I2S_StructInit>:
  * @brief  Fills each I2S_InitStruct member with its default value.
  * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
  * @retval None
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
 800b2c0:	b480      	push	{r7}
 800b2c2:	b083      	sub	sp, #12
 800b2c4:	af00      	add	r7, sp, #0
 800b2c6:	6078      	str	r0, [r7, #4]
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 800b2c8:	687b      	ldr	r3, [r7, #4]
 800b2ca:	f04f 0200 	mov.w	r2, #0
 800b2ce:	801a      	strh	r2, [r3, #0]
  
  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 800b2d0:	687b      	ldr	r3, [r7, #4]
 800b2d2:	f04f 0200 	mov.w	r2, #0
 800b2d6:	805a      	strh	r2, [r3, #2]
  
  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 800b2d8:	687b      	ldr	r3, [r7, #4]
 800b2da:	f04f 0200 	mov.w	r2, #0
 800b2de:	809a      	strh	r2, [r3, #4]
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 800b2e0:	687b      	ldr	r3, [r7, #4]
 800b2e2:	f04f 0200 	mov.w	r2, #0
 800b2e6:	80da      	strh	r2, [r3, #6]
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 800b2e8:	687b      	ldr	r3, [r7, #4]
 800b2ea:	f64a 4244 	movw	r2, #44100	; 0xac44
 800b2ee:	609a      	str	r2, [r3, #8]
  
  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 800b2f0:	687b      	ldr	r3, [r7, #4]
 800b2f2:	f04f 0200 	mov.w	r2, #0
 800b2f6:	819a      	strh	r2, [r3, #12]
}
 800b2f8:	f107 070c 	add.w	r7, r7, #12
 800b2fc:	46bd      	mov	sp, r7
 800b2fe:	bc80      	pop	{r7}
 800b300:	4770      	bx	lr
 800b302:	bf00      	nop

0800b304 <SPI_Cmd>:
  * @param  NewState: new state of the SPIx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 800b304:	b480      	push	{r7}
 800b306:	b083      	sub	sp, #12
 800b308:	af00      	add	r7, sp, #0
 800b30a:	6078      	str	r0, [r7, #4]
 800b30c:	460b      	mov	r3, r1
 800b30e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800b310:	78fb      	ldrb	r3, [r7, #3]
 800b312:	2b00      	cmp	r3, #0
 800b314:	d008      	beq.n	800b328 <SPI_Cmd+0x24>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 800b316:	687b      	ldr	r3, [r7, #4]
 800b318:	881b      	ldrh	r3, [r3, #0]
 800b31a:	b29b      	uxth	r3, r3
 800b31c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b320:	b29a      	uxth	r2, r3
 800b322:	687b      	ldr	r3, [r7, #4]
 800b324:	801a      	strh	r2, [r3, #0]
 800b326:	e007      	b.n	800b338 <SPI_Cmd+0x34>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 800b328:	687b      	ldr	r3, [r7, #4]
 800b32a:	881b      	ldrh	r3, [r3, #0]
 800b32c:	b29b      	uxth	r3, r3
 800b32e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800b332:	b29a      	uxth	r2, r3
 800b334:	687b      	ldr	r3, [r7, #4]
 800b336:	801a      	strh	r2, [r3, #0]
  }
}
 800b338:	f107 070c 	add.w	r7, r7, #12
 800b33c:	46bd      	mov	sp, r7
 800b33e:	bc80      	pop	{r7}
 800b340:	4770      	bx	lr
 800b342:	bf00      	nop

0800b344 <I2S_Cmd>:
  * @param  NewState: new state of the SPIx peripheral. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 800b344:	b480      	push	{r7}
 800b346:	b083      	sub	sp, #12
 800b348:	af00      	add	r7, sp, #0
 800b34a:	6078      	str	r0, [r7, #4]
 800b34c:	460b      	mov	r3, r1
 800b34e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800b350:	78fb      	ldrb	r3, [r7, #3]
 800b352:	2b00      	cmp	r3, #0
 800b354:	d008      	beq.n	800b368 <I2S_Cmd+0x24>
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 800b356:	687b      	ldr	r3, [r7, #4]
 800b358:	8b9b      	ldrh	r3, [r3, #28]
 800b35a:	b29b      	uxth	r3, r3
 800b35c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800b360:	b29a      	uxth	r2, r3
 800b362:	687b      	ldr	r3, [r7, #4]
 800b364:	839a      	strh	r2, [r3, #28]
 800b366:	e007      	b.n	800b378 <I2S_Cmd+0x34>
  }
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 800b368:	687b      	ldr	r3, [r7, #4]
 800b36a:	8b9b      	ldrh	r3, [r3, #28]
 800b36c:	b29b      	uxth	r3, r3
 800b36e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800b372:	b29a      	uxth	r2, r3
 800b374:	687b      	ldr	r3, [r7, #4]
 800b376:	839a      	strh	r2, [r3, #28]
  }
}
 800b378:	f107 070c 	add.w	r7, r7, #12
 800b37c:	46bd      	mov	sp, r7
 800b37e:	bc80      	pop	{r7}
 800b380:	4770      	bx	lr
 800b382:	bf00      	nop

0800b384 <SPI_DataSizeConfig>:
  *            @arg SPI_DataSize_16b: Set data frame format to 16bit
  *            @arg SPI_DataSize_8b: Set data frame format to 8bit
  * @retval None
  */
void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
{
 800b384:	b480      	push	{r7}
 800b386:	b083      	sub	sp, #12
 800b388:	af00      	add	r7, sp, #0
 800b38a:	6078      	str	r0, [r7, #4]
 800b38c:	460b      	mov	r3, r1
 800b38e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
  /* Clear DFF bit */
  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
 800b390:	687b      	ldr	r3, [r7, #4]
 800b392:	881b      	ldrh	r3, [r3, #0]
 800b394:	b29b      	uxth	r3, r3
 800b396:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800b39a:	b29a      	uxth	r2, r3
 800b39c:	687b      	ldr	r3, [r7, #4]
 800b39e:	801a      	strh	r2, [r3, #0]
  /* Set new DFF bit value */
  SPIx->CR1 |= SPI_DataSize;
 800b3a0:	687b      	ldr	r3, [r7, #4]
 800b3a2:	881b      	ldrh	r3, [r3, #0]
 800b3a4:	b29a      	uxth	r2, r3
 800b3a6:	887b      	ldrh	r3, [r7, #2]
 800b3a8:	4313      	orrs	r3, r2
 800b3aa:	b29a      	uxth	r2, r3
 800b3ac:	687b      	ldr	r3, [r7, #4]
 800b3ae:	801a      	strh	r2, [r3, #0]
}
 800b3b0:	f107 070c 	add.w	r7, r7, #12
 800b3b4:	46bd      	mov	sp, r7
 800b3b6:	bc80      	pop	{r7}
 800b3b8:	4770      	bx	lr
 800b3ba:	bf00      	nop

0800b3bc <SPI_BiDirectionalLineConfig>:
  *            @arg SPI_Direction_Tx: Selects Tx transmission direction
  *            @arg SPI_Direction_Rx: Selects Rx receive direction
  * @retval None
  */
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
 800b3bc:	b480      	push	{r7}
 800b3be:	b083      	sub	sp, #12
 800b3c0:	af00      	add	r7, sp, #0
 800b3c2:	6078      	str	r0, [r7, #4]
 800b3c4:	460b      	mov	r3, r1
 800b3c6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 800b3c8:	887b      	ldrh	r3, [r7, #2]
 800b3ca:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800b3ce:	d108      	bne.n	800b3e2 <SPI_BiDirectionalLineConfig+0x26>
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 800b3d0:	687b      	ldr	r3, [r7, #4]
 800b3d2:	881b      	ldrh	r3, [r3, #0]
 800b3d4:	b29b      	uxth	r3, r3
 800b3d6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800b3da:	b29a      	uxth	r2, r3
 800b3dc:	687b      	ldr	r3, [r7, #4]
 800b3de:	801a      	strh	r2, [r3, #0]
 800b3e0:	e007      	b.n	800b3f2 <SPI_BiDirectionalLineConfig+0x36>
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
 800b3e2:	687b      	ldr	r3, [r7, #4]
 800b3e4:	881b      	ldrh	r3, [r3, #0]
 800b3e6:	b29b      	uxth	r3, r3
 800b3e8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800b3ec:	b29a      	uxth	r2, r3
 800b3ee:	687b      	ldr	r3, [r7, #4]
 800b3f0:	801a      	strh	r2, [r3, #0]
  }
}
 800b3f2:	f107 070c 	add.w	r7, r7, #12
 800b3f6:	46bd      	mov	sp, r7
 800b3f8:	bc80      	pop	{r7}
 800b3fa:	4770      	bx	lr

0800b3fc <SPI_NSSInternalSoftwareConfig>:
  *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
  *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
  * @retval None
  */
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
 800b3fc:	b480      	push	{r7}
 800b3fe:	b083      	sub	sp, #12
 800b400:	af00      	add	r7, sp, #0
 800b402:	6078      	str	r0, [r7, #4]
 800b404:	460b      	mov	r3, r1
 800b406:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 800b408:	887a      	ldrh	r2, [r7, #2]
 800b40a:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 800b40e:	429a      	cmp	r2, r3
 800b410:	d008      	beq.n	800b424 <SPI_NSSInternalSoftwareConfig+0x28>
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 800b412:	687b      	ldr	r3, [r7, #4]
 800b414:	881b      	ldrh	r3, [r3, #0]
 800b416:	b29b      	uxth	r3, r3
 800b418:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b41c:	b29a      	uxth	r2, r3
 800b41e:	687b      	ldr	r3, [r7, #4]
 800b420:	801a      	strh	r2, [r3, #0]
 800b422:	e007      	b.n	800b434 <SPI_NSSInternalSoftwareConfig+0x38>
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 800b424:	687b      	ldr	r3, [r7, #4]
 800b426:	881b      	ldrh	r3, [r3, #0]
 800b428:	b29b      	uxth	r3, r3
 800b42a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800b42e:	b29a      	uxth	r2, r3
 800b430:	687b      	ldr	r3, [r7, #4]
 800b432:	801a      	strh	r2, [r3, #0]
  }
}
 800b434:	f107 070c 	add.w	r7, r7, #12
 800b438:	46bd      	mov	sp, r7
 800b43a:	bc80      	pop	{r7}
 800b43c:	4770      	bx	lr
 800b43e:	bf00      	nop

0800b440 <SPI_SSOutputCmd>:
  * @param  NewState: new state of the SPIx SS output. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 800b440:	b480      	push	{r7}
 800b442:	b083      	sub	sp, #12
 800b444:	af00      	add	r7, sp, #0
 800b446:	6078      	str	r0, [r7, #4]
 800b448:	460b      	mov	r3, r1
 800b44a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800b44c:	78fb      	ldrb	r3, [r7, #3]
 800b44e:	2b00      	cmp	r3, #0
 800b450:	d008      	beq.n	800b464 <SPI_SSOutputCmd+0x24>
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 800b452:	687b      	ldr	r3, [r7, #4]
 800b454:	889b      	ldrh	r3, [r3, #4]
 800b456:	b29b      	uxth	r3, r3
 800b458:	f043 0304 	orr.w	r3, r3, #4
 800b45c:	b29a      	uxth	r2, r3
 800b45e:	687b      	ldr	r3, [r7, #4]
 800b460:	809a      	strh	r2, [r3, #4]
 800b462:	e007      	b.n	800b474 <SPI_SSOutputCmd+0x34>
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 800b464:	687b      	ldr	r3, [r7, #4]
 800b466:	889b      	ldrh	r3, [r3, #4]
 800b468:	b29b      	uxth	r3, r3
 800b46a:	f023 0304 	bic.w	r3, r3, #4
 800b46e:	b29a      	uxth	r2, r3
 800b470:	687b      	ldr	r3, [r7, #4]
 800b472:	809a      	strh	r2, [r3, #4]
  }
}
 800b474:	f107 070c 	add.w	r7, r7, #12
 800b478:	46bd      	mov	sp, r7
 800b47a:	bc80      	pop	{r7}
 800b47c:	4770      	bx	lr
 800b47e:	bf00      	nop

0800b480 <SPI_TIModeCmd>:
  * @param  NewState: new state of the selected SPI TI communication mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 800b480:	b480      	push	{r7}
 800b482:	b083      	sub	sp, #12
 800b484:	af00      	add	r7, sp, #0
 800b486:	6078      	str	r0, [r7, #4]
 800b488:	460b      	mov	r3, r1
 800b48a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b48c:	78fb      	ldrb	r3, [r7, #3]
 800b48e:	2b00      	cmp	r3, #0
 800b490:	d008      	beq.n	800b4a4 <SPI_TIModeCmd+0x24>
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 800b492:	687b      	ldr	r3, [r7, #4]
 800b494:	889b      	ldrh	r3, [r3, #4]
 800b496:	b29b      	uxth	r3, r3
 800b498:	f043 0310 	orr.w	r3, r3, #16
 800b49c:	b29a      	uxth	r2, r3
 800b49e:	687b      	ldr	r3, [r7, #4]
 800b4a0:	809a      	strh	r2, [r3, #4]
 800b4a2:	e007      	b.n	800b4b4 <SPI_TIModeCmd+0x34>
  }
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
 800b4a4:	687b      	ldr	r3, [r7, #4]
 800b4a6:	889b      	ldrh	r3, [r3, #4]
 800b4a8:	b29b      	uxth	r3, r3
 800b4aa:	f023 0310 	bic.w	r3, r3, #16
 800b4ae:	b29a      	uxth	r2, r3
 800b4b0:	687b      	ldr	r3, [r7, #4]
 800b4b2:	809a      	strh	r2, [r3, #4]
  }
}
 800b4b4:	f107 070c 	add.w	r7, r7, #12
 800b4b8:	46bd      	mov	sp, r7
 800b4ba:	bc80      	pop	{r7}
 800b4bc:	4770      	bx	lr
 800b4be:	bf00      	nop

0800b4c0 <I2S_FullDuplexConfig>:
  * @note   The I2S full duplex extension can be configured in slave mode only.    
  *  
  * @retval None
  */
void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
{
 800b4c0:	b480      	push	{r7}
 800b4c2:	b085      	sub	sp, #20
 800b4c4:	af00      	add	r7, sp, #0
 800b4c6:	6078      	str	r0, [r7, #4]
 800b4c8:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0, tmp = 0;
 800b4ca:	f04f 0300 	mov.w	r3, #0
 800b4ce:	81bb      	strh	r3, [r7, #12]
 800b4d0:	f04f 0300 	mov.w	r3, #0
 800b4d4:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 800b4d6:	687b      	ldr	r3, [r7, #4]
 800b4d8:	8b9b      	ldrh	r3, [r3, #28]
 800b4da:	b29b      	uxth	r3, r3
 800b4dc:	f423 637a 	bic.w	r3, r3, #4000	; 0xfa0
 800b4e0:	f023 031f 	bic.w	r3, r3, #31
 800b4e4:	b29a      	uxth	r2, r3
 800b4e6:	687b      	ldr	r3, [r7, #4]
 800b4e8:	839a      	strh	r2, [r3, #28]
  I2Sxext->I2SPR = 0x0002;
 800b4ea:	687b      	ldr	r3, [r7, #4]
 800b4ec:	f04f 0202 	mov.w	r2, #2
 800b4f0:	841a      	strh	r2, [r3, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 800b4f2:	687b      	ldr	r3, [r7, #4]
 800b4f4:	8b9b      	ldrh	r3, [r3, #28]
 800b4f6:	81bb      	strh	r3, [r7, #12]
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 800b4f8:	683b      	ldr	r3, [r7, #0]
 800b4fa:	881b      	ldrh	r3, [r3, #0]
 800b4fc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800b500:	d003      	beq.n	800b50a <I2S_FullDuplexConfig+0x4a>
 800b502:	683b      	ldr	r3, [r7, #0]
 800b504:	881b      	ldrh	r3, [r3, #0]
 800b506:	2b00      	cmp	r3, #0
 800b508:	d103      	bne.n	800b512 <I2S_FullDuplexConfig+0x52>
  {
    tmp = I2S_Mode_SlaveRx;
 800b50a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b50e:	81fb      	strh	r3, [r7, #14]
 800b510:	e00c      	b.n	800b52c <I2S_FullDuplexConfig+0x6c>
  }
  else
  {
    if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
 800b512:	683b      	ldr	r3, [r7, #0]
 800b514:	881b      	ldrh	r3, [r3, #0]
 800b516:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800b51a:	d004      	beq.n	800b526 <I2S_FullDuplexConfig+0x66>
 800b51c:	683b      	ldr	r3, [r7, #0]
 800b51e:	881b      	ldrh	r3, [r3, #0]
 800b520:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800b524:	d102      	bne.n	800b52c <I2S_FullDuplexConfig+0x6c>
    {
      tmp = I2S_Mode_SlaveTx;
 800b526:	f04f 0300 	mov.w	r3, #0
 800b52a:	81fb      	strh	r3, [r7, #14]
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 800b52c:	683b      	ldr	r3, [r7, #0]
 800b52e:	885a      	ldrh	r2, [r3, #2]
 800b530:	683b      	ldr	r3, [r7, #0]
 800b532:	8899      	ldrh	r1, [r3, #4]
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 800b534:	683b      	ldr	r3, [r7, #0]
 800b536:	899b      	ldrh	r3, [r3, #12]
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 800b538:	430b      	orrs	r3, r1
 800b53a:	b29b      	uxth	r3, r3
 800b53c:	4313      	orrs	r3, r2
 800b53e:	b29a      	uxth	r2, r3
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 800b540:	89fb      	ldrh	r3, [r7, #14]
 800b542:	4313      	orrs	r3, r2
 800b544:	b29a      	uxth	r2, r3
 800b546:	89bb      	ldrh	r3, [r7, #12]
 800b548:	4313      	orrs	r3, r2
 800b54a:	b29b      	uxth	r3, r3
 800b54c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800b550:	81bb      	strh	r3, [r7, #12]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
 800b552:	687b      	ldr	r3, [r7, #4]
 800b554:	89ba      	ldrh	r2, [r7, #12]
 800b556:	839a      	strh	r2, [r3, #28]
}
 800b558:	f107 0714 	add.w	r7, r7, #20
 800b55c:	46bd      	mov	sp, r7
 800b55e:	bc80      	pop	{r7}
 800b560:	4770      	bx	lr
 800b562:	bf00      	nop

0800b564 <SPI_I2S_ReceiveData>:
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
  * @retval The value of the received data.
  */
uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
{
 800b564:	b480      	push	{r7}
 800b566:	b083      	sub	sp, #12
 800b568:	af00      	add	r7, sp, #0
 800b56a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Return the data in the DR register */
  return SPIx->DR;
 800b56c:	687b      	ldr	r3, [r7, #4]
 800b56e:	899b      	ldrh	r3, [r3, #12]
 800b570:	b29b      	uxth	r3, r3
}
 800b572:	4618      	mov	r0, r3
 800b574:	f107 070c 	add.w	r7, r7, #12
 800b578:	46bd      	mov	sp, r7
 800b57a:	bc80      	pop	{r7}
 800b57c:	4770      	bx	lr
 800b57e:	bf00      	nop

0800b580 <SPI_I2S_SendData>:
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.     
  * @param  Data: Data to be transmitted.
  * @retval None
  */
void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
{
 800b580:	b480      	push	{r7}
 800b582:	b083      	sub	sp, #12
 800b584:	af00      	add	r7, sp, #0
 800b586:	6078      	str	r0, [r7, #4]
 800b588:	460b      	mov	r3, r1
 800b58a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
 800b58c:	687b      	ldr	r3, [r7, #4]
 800b58e:	887a      	ldrh	r2, [r7, #2]
 800b590:	819a      	strh	r2, [r3, #12]
}
 800b592:	f107 070c 	add.w	r7, r7, #12
 800b596:	46bd      	mov	sp, r7
 800b598:	bc80      	pop	{r7}
 800b59a:	4770      	bx	lr

0800b59c <SPI_CalculateCRC>:
  * @param  NewState: new state of the SPIx CRC value calculation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 800b59c:	b480      	push	{r7}
 800b59e:	b083      	sub	sp, #12
 800b5a0:	af00      	add	r7, sp, #0
 800b5a2:	6078      	str	r0, [r7, #4]
 800b5a4:	460b      	mov	r3, r1
 800b5a6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800b5a8:	78fb      	ldrb	r3, [r7, #3]
 800b5aa:	2b00      	cmp	r3, #0
 800b5ac:	d008      	beq.n	800b5c0 <SPI_CalculateCRC+0x24>
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 800b5ae:	687b      	ldr	r3, [r7, #4]
 800b5b0:	881b      	ldrh	r3, [r3, #0]
 800b5b2:	b29b      	uxth	r3, r3
 800b5b4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800b5b8:	b29a      	uxth	r2, r3
 800b5ba:	687b      	ldr	r3, [r7, #4]
 800b5bc:	801a      	strh	r2, [r3, #0]
 800b5be:	e007      	b.n	800b5d0 <SPI_CalculateCRC+0x34>
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 800b5c0:	687b      	ldr	r3, [r7, #4]
 800b5c2:	881b      	ldrh	r3, [r3, #0]
 800b5c4:	b29b      	uxth	r3, r3
 800b5c6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800b5ca:	b29a      	uxth	r2, r3
 800b5cc:	687b      	ldr	r3, [r7, #4]
 800b5ce:	801a      	strh	r2, [r3, #0]
  }
}
 800b5d0:	f107 070c 	add.w	r7, r7, #12
 800b5d4:	46bd      	mov	sp, r7
 800b5d6:	bc80      	pop	{r7}
 800b5d8:	4770      	bx	lr
 800b5da:	bf00      	nop

0800b5dc <SPI_TransmitCRC>:
  * @brief  Transmit the SPIx CRC value.
  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
  * @retval None
  */
void SPI_TransmitCRC(SPI_TypeDef* SPIx)
{
 800b5dc:	b480      	push	{r7}
 800b5de:	b083      	sub	sp, #12
 800b5e0:	af00      	add	r7, sp, #0
 800b5e2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
 800b5e4:	687b      	ldr	r3, [r7, #4]
 800b5e6:	881b      	ldrh	r3, [r3, #0]
 800b5e8:	b29b      	uxth	r3, r3
 800b5ea:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800b5ee:	b29a      	uxth	r2, r3
 800b5f0:	687b      	ldr	r3, [r7, #4]
 800b5f2:	801a      	strh	r2, [r3, #0]
}
 800b5f4:	f107 070c 	add.w	r7, r7, #12
 800b5f8:	46bd      	mov	sp, r7
 800b5fa:	bc80      	pop	{r7}
 800b5fc:	4770      	bx	lr
 800b5fe:	bf00      	nop

0800b600 <SPI_GetCRC>:
  *            @arg SPI_CRC_Tx: Selects Tx CRC register
  *            @arg SPI_CRC_Rx: Selects Rx CRC register
  * @retval The selected CRC register value..
  */
uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
{
 800b600:	b480      	push	{r7}
 800b602:	b085      	sub	sp, #20
 800b604:	af00      	add	r7, sp, #0
 800b606:	6078      	str	r0, [r7, #4]
 800b608:	460b      	mov	r3, r1
 800b60a:	70fb      	strb	r3, [r7, #3]
  uint16_t crcreg = 0;
 800b60c:	f04f 0300 	mov.w	r3, #0
 800b610:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));
  if (SPI_CRC != SPI_CRC_Rx)
 800b612:	78fb      	ldrb	r3, [r7, #3]
 800b614:	2b01      	cmp	r3, #1
 800b616:	d003      	beq.n	800b620 <SPI_GetCRC+0x20>
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 800b618:	687b      	ldr	r3, [r7, #4]
 800b61a:	8b1b      	ldrh	r3, [r3, #24]
 800b61c:	81fb      	strh	r3, [r7, #14]
 800b61e:	e002      	b.n	800b626 <SPI_GetCRC+0x26>
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 800b620:	687b      	ldr	r3, [r7, #4]
 800b622:	8a9b      	ldrh	r3, [r3, #20]
 800b624:	81fb      	strh	r3, [r7, #14]
  }
  /* Return the selected CRC register */
  return crcreg;
 800b626:	89fb      	ldrh	r3, [r7, #14]
}
 800b628:	4618      	mov	r0, r3
 800b62a:	f107 0714 	add.w	r7, r7, #20
 800b62e:	46bd      	mov	sp, r7
 800b630:	bc80      	pop	{r7}
 800b632:	4770      	bx	lr

0800b634 <SPI_GetCRCPolynomial>:
  * @brief  Returns the CRC Polynomial register value for the specified SPI.
  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
  * @retval The CRC Polynomial register value.
  */
uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
{
 800b634:	b480      	push	{r7}
 800b636:	b083      	sub	sp, #12
 800b638:	af00      	add	r7, sp, #0
 800b63a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 800b63c:	687b      	ldr	r3, [r7, #4]
 800b63e:	8a1b      	ldrh	r3, [r3, #16]
 800b640:	b29b      	uxth	r3, r3
}
 800b642:	4618      	mov	r0, r3
 800b644:	f107 070c 	add.w	r7, r7, #12
 800b648:	46bd      	mov	sp, r7
 800b64a:	bc80      	pop	{r7}
 800b64c:	4770      	bx	lr
 800b64e:	bf00      	nop

0800b650 <SPI_I2S_DMACmd>:
  * @param  NewState: new state of the selected SPI DMA transfer request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
{
 800b650:	b480      	push	{r7}
 800b652:	b083      	sub	sp, #12
 800b654:	af00      	add	r7, sp, #0
 800b656:	6078      	str	r0, [r7, #4]
 800b658:	4613      	mov	r3, r2
 800b65a:	460a      	mov	r2, r1
 800b65c:	807a      	strh	r2, [r7, #2]
 800b65e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
 800b660:	787b      	ldrb	r3, [r7, #1]
 800b662:	2b00      	cmp	r3, #0
 800b664:	d008      	beq.n	800b678 <SPI_I2S_DMACmd+0x28>
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 800b666:	687b      	ldr	r3, [r7, #4]
 800b668:	889b      	ldrh	r3, [r3, #4]
 800b66a:	b29a      	uxth	r2, r3
 800b66c:	887b      	ldrh	r3, [r7, #2]
 800b66e:	4313      	orrs	r3, r2
 800b670:	b29a      	uxth	r2, r3
 800b672:	687b      	ldr	r3, [r7, #4]
 800b674:	809a      	strh	r2, [r3, #4]
 800b676:	e00a      	b.n	800b68e <SPI_I2S_DMACmd+0x3e>
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 800b678:	687b      	ldr	r3, [r7, #4]
 800b67a:	889b      	ldrh	r3, [r3, #4]
 800b67c:	b29a      	uxth	r2, r3
 800b67e:	887b      	ldrh	r3, [r7, #2]
 800b680:	ea6f 0303 	mvn.w	r3, r3
 800b684:	b29b      	uxth	r3, r3
 800b686:	4013      	ands	r3, r2
 800b688:	b29a      	uxth	r2, r3
 800b68a:	687b      	ldr	r3, [r7, #4]
 800b68c:	809a      	strh	r2, [r3, #4]
  }
}
 800b68e:	f107 070c 	add.w	r7, r7, #12
 800b692:	46bd      	mov	sp, r7
 800b694:	bc80      	pop	{r7}
 800b696:	4770      	bx	lr

0800b698 <SPI_I2S_ITConfig>:
  * @param  NewState: new state of the specified SPI interrupt.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
{
 800b698:	b480      	push	{r7}
 800b69a:	b085      	sub	sp, #20
 800b69c:	af00      	add	r7, sp, #0
 800b69e:	6078      	str	r0, [r7, #4]
 800b6a0:	4613      	mov	r3, r2
 800b6a2:	460a      	mov	r2, r1
 800b6a4:	70fa      	strb	r2, [r7, #3]
 800b6a6:	70bb      	strb	r3, [r7, #2]
  uint16_t itpos = 0, itmask = 0 ;
 800b6a8:	f04f 0300 	mov.w	r3, #0
 800b6ac:	81fb      	strh	r3, [r7, #14]
 800b6ae:	f04f 0300 	mov.w	r3, #0
 800b6b2:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;
 800b6b4:	78fb      	ldrb	r3, [r7, #3]
 800b6b6:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800b6ba:	b2db      	uxtb	r3, r3
 800b6bc:	81fb      	strh	r3, [r7, #14]

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 800b6be:	89fb      	ldrh	r3, [r7, #14]
 800b6c0:	f04f 0201 	mov.w	r2, #1
 800b6c4:	fa02 f303 	lsl.w	r3, r2, r3
 800b6c8:	81bb      	strh	r3, [r7, #12]

  if (NewState != DISABLE)
 800b6ca:	78bb      	ldrb	r3, [r7, #2]
 800b6cc:	2b00      	cmp	r3, #0
 800b6ce:	d008      	beq.n	800b6e2 <SPI_I2S_ITConfig+0x4a>
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 800b6d0:	687b      	ldr	r3, [r7, #4]
 800b6d2:	889b      	ldrh	r3, [r3, #4]
 800b6d4:	b29a      	uxth	r2, r3
 800b6d6:	89bb      	ldrh	r3, [r7, #12]
 800b6d8:	4313      	orrs	r3, r2
 800b6da:	b29a      	uxth	r2, r3
 800b6dc:	687b      	ldr	r3, [r7, #4]
 800b6de:	809a      	strh	r2, [r3, #4]
 800b6e0:	e00a      	b.n	800b6f8 <SPI_I2S_ITConfig+0x60>
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 800b6e2:	687b      	ldr	r3, [r7, #4]
 800b6e4:	889b      	ldrh	r3, [r3, #4]
 800b6e6:	b29a      	uxth	r2, r3
 800b6e8:	89bb      	ldrh	r3, [r7, #12]
 800b6ea:	ea6f 0303 	mvn.w	r3, r3
 800b6ee:	b29b      	uxth	r3, r3
 800b6f0:	4013      	ands	r3, r2
 800b6f2:	b29a      	uxth	r2, r3
 800b6f4:	687b      	ldr	r3, [r7, #4]
 800b6f6:	809a      	strh	r2, [r3, #4]
  }
}
 800b6f8:	f107 0714 	add.w	r7, r7, #20
 800b6fc:	46bd      	mov	sp, r7
 800b6fe:	bc80      	pop	{r7}
 800b700:	4770      	bx	lr
 800b702:	bf00      	nop

0800b704 <SPI_I2S_GetFlagStatus>:
  *            @arg I2S_FLAG_UDR: Underrun Error flag.
  *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
  */
FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
 800b704:	b480      	push	{r7}
 800b706:	b085      	sub	sp, #20
 800b708:	af00      	add	r7, sp, #0
 800b70a:	6078      	str	r0, [r7, #4]
 800b70c:	460b      	mov	r3, r1
 800b70e:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 800b710:	f04f 0300 	mov.w	r3, #0
 800b714:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 800b716:	687b      	ldr	r3, [r7, #4]
 800b718:	891b      	ldrh	r3, [r3, #8]
 800b71a:	b29a      	uxth	r2, r3
 800b71c:	887b      	ldrh	r3, [r7, #2]
 800b71e:	4013      	ands	r3, r2
 800b720:	b29b      	uxth	r3, r3
 800b722:	2b00      	cmp	r3, #0
 800b724:	d003      	beq.n	800b72e <SPI_I2S_GetFlagStatus+0x2a>
  {
    /* SPI_I2S_FLAG is set */
    bitstatus = SET;
 800b726:	f04f 0301 	mov.w	r3, #1
 800b72a:	73fb      	strb	r3, [r7, #15]
 800b72c:	e002      	b.n	800b734 <SPI_I2S_GetFlagStatus+0x30>
  }
  else
  {
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
 800b72e:	f04f 0300 	mov.w	r3, #0
 800b732:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
 800b734:	7bfb      	ldrb	r3, [r7, #15]
}
 800b736:	4618      	mov	r0, r3
 800b738:	f107 0714 	add.w	r7, r7, #20
 800b73c:	46bd      	mov	sp, r7
 800b73e:	bc80      	pop	{r7}
 800b740:	4770      	bx	lr
 800b742:	bf00      	nop

0800b744 <SPI_I2S_ClearFlag>:
  *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
  *  
  * @retval None
  */
void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
 800b744:	b480      	push	{r7}
 800b746:	b083      	sub	sp, #12
 800b748:	af00      	add	r7, sp, #0
 800b74a:	6078      	str	r0, [r7, #4]
 800b74c:	460b      	mov	r3, r1
 800b74e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    
  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 800b750:	887b      	ldrh	r3, [r7, #2]
 800b752:	ea6f 0303 	mvn.w	r3, r3
 800b756:	b29a      	uxth	r2, r3
 800b758:	687b      	ldr	r3, [r7, #4]
 800b75a:	811a      	strh	r2, [r3, #8]
}
 800b75c:	f107 070c 	add.w	r7, r7, #12
 800b760:	46bd      	mov	sp, r7
 800b762:	bc80      	pop	{r7}
 800b764:	4770      	bx	lr
 800b766:	bf00      	nop

0800b768 <SPI_I2S_GetITStatus>:
  *            @arg I2S_IT_UDR: Underrun interrupt.  
  *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 800b768:	b480      	push	{r7}
 800b76a:	b085      	sub	sp, #20
 800b76c:	af00      	add	r7, sp, #0
 800b76e:	6078      	str	r0, [r7, #4]
 800b770:	460b      	mov	r3, r1
 800b772:	70fb      	strb	r3, [r7, #3]
  ITStatus bitstatus = RESET;
 800b774:	f04f 0300 	mov.w	r3, #0
 800b778:	73fb      	strb	r3, [r7, #15]
  uint16_t itpos = 0, itmask = 0, enablestatus = 0;
 800b77a:	f04f 0300 	mov.w	r3, #0
 800b77e:	81bb      	strh	r3, [r7, #12]
 800b780:	f04f 0300 	mov.w	r3, #0
 800b784:	817b      	strh	r3, [r7, #10]
 800b786:	f04f 0300 	mov.w	r3, #0
 800b78a:	813b      	strh	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 800b78c:	78fb      	ldrb	r3, [r7, #3]
 800b78e:	f003 030f 	and.w	r3, r3, #15
 800b792:	f04f 0201 	mov.w	r2, #1
 800b796:	fa02 f303 	lsl.w	r3, r2, r3
 800b79a:	81bb      	strh	r3, [r7, #12]

  /* Get the SPI_I2S_IT IT mask */
  itmask = SPI_I2S_IT >> 4;
 800b79c:	78fb      	ldrb	r3, [r7, #3]
 800b79e:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800b7a2:	b2db      	uxtb	r3, r3
 800b7a4:	817b      	strh	r3, [r7, #10]

  /* Set the IT mask */
  itmask = 0x01 << itmask;
 800b7a6:	897b      	ldrh	r3, [r7, #10]
 800b7a8:	f04f 0201 	mov.w	r2, #1
 800b7ac:	fa02 f303 	lsl.w	r3, r2, r3
 800b7b0:	817b      	strh	r3, [r7, #10]

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 800b7b2:	687b      	ldr	r3, [r7, #4]
 800b7b4:	889b      	ldrh	r3, [r3, #4]
 800b7b6:	b29a      	uxth	r2, r3
 800b7b8:	897b      	ldrh	r3, [r7, #10]
 800b7ba:	4013      	ands	r3, r2
 800b7bc:	813b      	strh	r3, [r7, #8]

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 800b7be:	687b      	ldr	r3, [r7, #4]
 800b7c0:	891b      	ldrh	r3, [r3, #8]
 800b7c2:	b29a      	uxth	r2, r3
 800b7c4:	89bb      	ldrh	r3, [r7, #12]
 800b7c6:	4013      	ands	r3, r2
 800b7c8:	b29b      	uxth	r3, r3
 800b7ca:	2b00      	cmp	r3, #0
 800b7cc:	d006      	beq.n	800b7dc <SPI_I2S_GetITStatus+0x74>
 800b7ce:	893b      	ldrh	r3, [r7, #8]
 800b7d0:	2b00      	cmp	r3, #0
 800b7d2:	d003      	beq.n	800b7dc <SPI_I2S_GetITStatus+0x74>
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
 800b7d4:	f04f 0301 	mov.w	r3, #1
 800b7d8:	73fb      	strb	r3, [r7, #15]
 800b7da:	e002      	b.n	800b7e2 <SPI_I2S_GetITStatus+0x7a>
  }
  else
  {
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
 800b7dc:	f04f 0300 	mov.w	r3, #0
 800b7e0:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
 800b7e2:	7bfb      	ldrb	r3, [r7, #15]
}
 800b7e4:	4618      	mov	r0, r3
 800b7e6:	f107 0714 	add.w	r7, r7, #20
 800b7ea:	46bd      	mov	sp, r7
 800b7ec:	bc80      	pop	{r7}
 800b7ee:	4770      	bx	lr

0800b7f0 <SPI_I2S_ClearITPendingBit>:
  *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
  *          the SPI).
  * @retval None
  */
void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 800b7f0:	b480      	push	{r7}
 800b7f2:	b085      	sub	sp, #20
 800b7f4:	af00      	add	r7, sp, #0
 800b7f6:	6078      	str	r0, [r7, #4]
 800b7f8:	460b      	mov	r3, r1
 800b7fa:	70fb      	strb	r3, [r7, #3]
  uint16_t itpos = 0;
 800b7fc:	f04f 0300 	mov.w	r3, #0
 800b800:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));

  /* Get the SPI_I2S IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 800b802:	78fb      	ldrb	r3, [r7, #3]
 800b804:	f003 030f 	and.w	r3, r3, #15
 800b808:	f04f 0201 	mov.w	r2, #1
 800b80c:	fa02 f303 	lsl.w	r3, r2, r3
 800b810:	81fb      	strh	r3, [r7, #14]

  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
  SPIx->SR = (uint16_t)~itpos;
 800b812:	89fb      	ldrh	r3, [r7, #14]
 800b814:	ea6f 0303 	mvn.w	r3, r3
 800b818:	b29a      	uxth	r2, r3
 800b81a:	687b      	ldr	r3, [r7, #4]
 800b81c:	811a      	strh	r2, [r3, #8]
}
 800b81e:	f107 0714 	add.w	r7, r7, #20
 800b822:	46bd      	mov	sp, r7
 800b824:	bc80      	pop	{r7}
 800b826:	4770      	bx	lr

0800b828 <SYSCFG_DeInit>:
  *   registers to their default reset values.
  * @param  None
  * @retval None
  */
void SYSCFG_DeInit(void)
{
 800b828:	b580      	push	{r7, lr}
 800b82a:	af00      	add	r7, sp, #0
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800b82c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800b830:	f04f 0101 	mov.w	r1, #1
 800b834:	f7fd fba6 	bl	8008f84 <RCC_APB2PeriphResetCmd>
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
 800b838:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800b83c:	f04f 0100 	mov.w	r1, #0
 800b840:	f7fd fba0 	bl	8008f84 <RCC_APB2PeriphResetCmd>
}
 800b844:	bd80      	pop	{r7, pc}
 800b846:	bf00      	nop

0800b848 <SYSCFG_MemoryRemapConfig>:
  *            @arg SYSCFG_MemoryRemap_FSMC:        FSMC (Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
  *            @arg SYSCFG_MemoryRemap_SRAM:        Embedded SRAM (112kB) mapped at 0x00000000
  * @retval None
  */
void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
{
 800b848:	b480      	push	{r7}
 800b84a:	b083      	sub	sp, #12
 800b84c:	af00      	add	r7, sp, #0
 800b84e:	4603      	mov	r3, r0
 800b850:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));

  SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
 800b852:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800b856:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800b85a:	79fa      	ldrb	r2, [r7, #7]
 800b85c:	601a      	str	r2, [r3, #0]
}
 800b85e:	f107 070c 	add.w	r7, r7, #12
 800b862:	46bd      	mov	sp, r7
 800b864:	bc80      	pop	{r7}
 800b866:	4770      	bx	lr

0800b868 <SYSCFG_EXTILineConfig>:
  *           This parameter can be EXTI_PinSourcex where x can be (0..15, except
  *           for EXTI_PortSourceGPIOI x can be (0..11).
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 800b868:	b490      	push	{r4, r7}
 800b86a:	b084      	sub	sp, #16
 800b86c:	af00      	add	r7, sp, #0
 800b86e:	4602      	mov	r2, r0
 800b870:	460b      	mov	r3, r1
 800b872:	71fa      	strb	r2, [r7, #7]
 800b874:	71bb      	strb	r3, [r7, #6]
  uint32_t tmp = 0x00;
 800b876:	f04f 0300 	mov.w	r3, #0
 800b87a:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 800b87c:	79bb      	ldrb	r3, [r7, #6]
 800b87e:	f003 0303 	and.w	r3, r3, #3
 800b882:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b886:	f04f 020f 	mov.w	r2, #15
 800b88a:	fa02 f303 	lsl.w	r3, r2, r3
 800b88e:	60fb      	str	r3, [r7, #12]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 800b890:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800b894:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800b898:	79ba      	ldrb	r2, [r7, #6]
 800b89a:	ea4f 0292 	mov.w	r2, r2, lsr #2
 800b89e:	b2d2      	uxtb	r2, r2
 800b8a0:	4610      	mov	r0, r2
 800b8a2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800b8a6:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800b8aa:	79b9      	ldrb	r1, [r7, #6]
 800b8ac:	ea4f 0191 	mov.w	r1, r1, lsr #2
 800b8b0:	b2c9      	uxtb	r1, r1
 800b8b2:	f101 0102 	add.w	r1, r1, #2
 800b8b6:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 800b8ba:	4611      	mov	r1, r2
 800b8bc:	68fa      	ldr	r2, [r7, #12]
 800b8be:	ea6f 0202 	mvn.w	r2, r2
 800b8c2:	4011      	ands	r1, r2
 800b8c4:	f100 0202 	add.w	r2, r0, #2
 800b8c8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 800b8cc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800b8d0:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800b8d4:	79ba      	ldrb	r2, [r7, #6]
 800b8d6:	ea4f 0292 	mov.w	r2, r2, lsr #2
 800b8da:	b2d2      	uxtb	r2, r2
 800b8dc:	4610      	mov	r0, r2
 800b8de:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800b8e2:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800b8e6:	79b9      	ldrb	r1, [r7, #6]
 800b8e8:	ea4f 0191 	mov.w	r1, r1, lsr #2
 800b8ec:	b2c9      	uxtb	r1, r1
 800b8ee:	f101 0102 	add.w	r1, r1, #2
 800b8f2:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 800b8f6:	4611      	mov	r1, r2
 800b8f8:	79fc      	ldrb	r4, [r7, #7]
 800b8fa:	79ba      	ldrb	r2, [r7, #6]
 800b8fc:	f002 0203 	and.w	r2, r2, #3
 800b900:	ea4f 0282 	mov.w	r2, r2, lsl #2
 800b904:	fa04 f202 	lsl.w	r2, r4, r2
 800b908:	4311      	orrs	r1, r2
 800b90a:	f100 0202 	add.w	r2, r0, #2
 800b90e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 800b912:	f107 0710 	add.w	r7, r7, #16
 800b916:	46bd      	mov	sp, r7
 800b918:	bc90      	pop	{r4, r7}
 800b91a:	4770      	bx	lr

0800b91c <SYSCFG_ETH_MediaInterfaceConfig>:
  *            @arg SYSCFG_ETH_MediaInterface_MII: MII mode selected
  *            @arg SYSCFG_ETH_MediaInterface_RMII: RMII mode selected 
  * @retval None 
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
 800b91c:	b480      	push	{r7}
 800b91e:	b083      	sub	sp, #12
 800b920:	af00      	add	r7, sp, #0
 800b922:	6078      	str	r0, [r7, #4]
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
 800b924:	f04f 03dc 	mov.w	r3, #220	; 0xdc
 800b928:	f2c4 2327 	movt	r3, #16935	; 0x4227
 800b92c:	687a      	ldr	r2, [r7, #4]
 800b92e:	601a      	str	r2, [r3, #0]
}
 800b930:	f107 070c 	add.w	r7, r7, #12
 800b934:	46bd      	mov	sp, r7
 800b936:	bc80      	pop	{r7}
 800b938:	4770      	bx	lr
 800b93a:	bf00      	nop

0800b93c <SYSCFG_CompensationCellCmd>:
  *            @arg ENABLE: I/O compensation cell enabled  
  *            @arg DISABLE: I/O compensation cell power-down mode  
  * @retval None
  */
void SYSCFG_CompensationCellCmd(FunctionalState NewState)
{
 800b93c:	b480      	push	{r7}
 800b93e:	b083      	sub	sp, #12
 800b940:	af00      	add	r7, sp, #0
 800b942:	4603      	mov	r3, r0
 800b944:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CMPCR_CMP_PD_BB = (uint32_t)NewState;
 800b946:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b94a:	f2c4 2327 	movt	r3, #16935	; 0x4227
 800b94e:	79fa      	ldrb	r2, [r7, #7]
 800b950:	601a      	str	r2, [r3, #0]
}
 800b952:	f107 070c 	add.w	r7, r7, #12
 800b956:	46bd      	mov	sp, r7
 800b958:	bc80      	pop	{r7}
 800b95a:	4770      	bx	lr

0800b95c <SYSCFG_GetCompensationCellStatus>:
  * @brief  Checks whether the I/O Compensation Cell ready flag is set or not.
  * @param  None
  * @retval The new state of the I/O Compensation Cell ready flag (SET or RESET)
  */
FlagStatus SYSCFG_GetCompensationCellStatus(void)
{
 800b95c:	b480      	push	{r7}
 800b95e:	b083      	sub	sp, #12
 800b960:	af00      	add	r7, sp, #0
  FlagStatus bitstatus = RESET;
 800b962:	f04f 0300 	mov.w	r3, #0
 800b966:	71fb      	strb	r3, [r7, #7]
    
  if ((SYSCFG->CMPCR & SYSCFG_CMPCR_READY ) != (uint32_t)RESET)
 800b968:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800b96c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800b970:	6a1b      	ldr	r3, [r3, #32]
 800b972:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800b976:	2b00      	cmp	r3, #0
 800b978:	d003      	beq.n	800b982 <SYSCFG_GetCompensationCellStatus+0x26>
  {
    bitstatus = SET;
 800b97a:	f04f 0301 	mov.w	r3, #1
 800b97e:	71fb      	strb	r3, [r7, #7]
 800b980:	e002      	b.n	800b988 <SYSCFG_GetCompensationCellStatus+0x2c>
  }
  else
  {
    bitstatus = RESET;
 800b982:	f04f 0300 	mov.w	r3, #0
 800b986:	71fb      	strb	r3, [r7, #7]
  }
  return bitstatus;
 800b988:	79fb      	ldrb	r3, [r7, #7]
}
 800b98a:	4618      	mov	r0, r3
 800b98c:	f107 070c 	add.w	r7, r7, #12
 800b990:	46bd      	mov	sp, r7
 800b992:	bc80      	pop	{r7}
 800b994:	4770      	bx	lr
 800b996:	bf00      	nop

0800b998 <TIM_DeInit>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval None

  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 800b998:	b580      	push	{r7, lr}
 800b99a:	b082      	sub	sp, #8
 800b99c:	af00      	add	r7, sp, #0
 800b99e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
 800b9a0:	687a      	ldr	r2, [r7, #4]
 800b9a2:	f04f 0300 	mov.w	r3, #0
 800b9a6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800b9aa:	429a      	cmp	r2, r3
 800b9ac:	d10c      	bne.n	800b9c8 <TIM_DeInit+0x30>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 800b9ae:	f04f 0001 	mov.w	r0, #1
 800b9b2:	f04f 0101 	mov.w	r1, #1
 800b9b6:	f7fd fae5 	bl	8008f84 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 800b9ba:	f04f 0001 	mov.w	r0, #1
 800b9be:	f04f 0100 	mov.w	r1, #0
 800b9c2:	f7fd fadf 	bl	8008f84 <RCC_APB2PeriphResetCmd>
 800b9c6:	e0ff      	b.n	800bbc8 <TIM_DeInit+0x230>
  } 
  else if (TIMx == TIM2) 
 800b9c8:	687b      	ldr	r3, [r7, #4]
 800b9ca:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800b9ce:	d10c      	bne.n	800b9ea <TIM_DeInit+0x52>
  {     
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 800b9d0:	f04f 0001 	mov.w	r0, #1
 800b9d4:	f04f 0101 	mov.w	r1, #1
 800b9d8:	f7fd faa8 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 800b9dc:	f04f 0001 	mov.w	r0, #1
 800b9e0:	f04f 0100 	mov.w	r1, #0
 800b9e4:	f7fd faa2 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 800b9e8:	e0ee      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM3)
 800b9ea:	687a      	ldr	r2, [r7, #4]
 800b9ec:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b9f0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800b9f4:	429a      	cmp	r2, r3
 800b9f6:	d10c      	bne.n	800ba12 <TIM_DeInit+0x7a>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 800b9f8:	f04f 0002 	mov.w	r0, #2
 800b9fc:	f04f 0101 	mov.w	r1, #1
 800ba00:	f7fd fa94 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 800ba04:	f04f 0002 	mov.w	r0, #2
 800ba08:	f04f 0100 	mov.w	r1, #0
 800ba0c:	f7fd fa8e 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 800ba10:	e0da      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM4)
 800ba12:	687a      	ldr	r2, [r7, #4]
 800ba14:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ba18:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ba1c:	429a      	cmp	r2, r3
 800ba1e:	d10c      	bne.n	800ba3a <TIM_DeInit+0xa2>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 800ba20:	f04f 0004 	mov.w	r0, #4
 800ba24:	f04f 0101 	mov.w	r1, #1
 800ba28:	f7fd fa80 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 800ba2c:	f04f 0004 	mov.w	r0, #4
 800ba30:	f04f 0100 	mov.w	r1, #0
 800ba34:	f7fd fa7a 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 800ba38:	e0c6      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM5)
 800ba3a:	687a      	ldr	r2, [r7, #4]
 800ba3c:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 800ba40:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ba44:	429a      	cmp	r2, r3
 800ba46:	d10c      	bne.n	800ba62 <TIM_DeInit+0xca>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
 800ba48:	f04f 0008 	mov.w	r0, #8
 800ba4c:	f04f 0101 	mov.w	r1, #1
 800ba50:	f7fd fa6c 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
 800ba54:	f04f 0008 	mov.w	r0, #8
 800ba58:	f04f 0100 	mov.w	r1, #0
 800ba5c:	f7fd fa66 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 800ba60:	e0b2      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM6)  
 800ba62:	687a      	ldr	r2, [r7, #4]
 800ba64:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ba68:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ba6c:	429a      	cmp	r2, r3
 800ba6e:	d10c      	bne.n	800ba8a <TIM_DeInit+0xf2>
  {    
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 800ba70:	f04f 0010 	mov.w	r0, #16
 800ba74:	f04f 0101 	mov.w	r1, #1
 800ba78:	f7fd fa58 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 800ba7c:	f04f 0010 	mov.w	r0, #16
 800ba80:	f04f 0100 	mov.w	r1, #0
 800ba84:	f7fd fa52 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 800ba88:	e09e      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM7)
 800ba8a:	687a      	ldr	r2, [r7, #4]
 800ba8c:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800ba90:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ba94:	429a      	cmp	r2, r3
 800ba96:	d10c      	bne.n	800bab2 <TIM_DeInit+0x11a>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 800ba98:	f04f 0020 	mov.w	r0, #32
 800ba9c:	f04f 0101 	mov.w	r1, #1
 800baa0:	f7fd fa44 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 800baa4:	f04f 0020 	mov.w	r0, #32
 800baa8:	f04f 0100 	mov.w	r1, #0
 800baac:	f7fd fa3e 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 800bab0:	e08a      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM8)
 800bab2:	687a      	ldr	r2, [r7, #4]
 800bab4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bab8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800babc:	429a      	cmp	r2, r3
 800babe:	d10c      	bne.n	800bada <TIM_DeInit+0x142>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 800bac0:	f04f 0002 	mov.w	r0, #2
 800bac4:	f04f 0101 	mov.w	r1, #1
 800bac8:	f7fd fa5c 	bl	8008f84 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 800bacc:	f04f 0002 	mov.w	r0, #2
 800bad0:	f04f 0100 	mov.w	r1, #0
 800bad4:	f7fd fa56 	bl	8008f84 <RCC_APB2PeriphResetCmd>
 800bad8:	e076      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM9)
 800bada:	687a      	ldr	r2, [r7, #4]
 800badc:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800bae0:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800bae4:	429a      	cmp	r2, r3
 800bae6:	d10c      	bne.n	800bb02 <TIM_DeInit+0x16a>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
 800bae8:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800baec:	f04f 0101 	mov.w	r1, #1
 800baf0:	f7fd fa48 	bl	8008f84 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
 800baf4:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800baf8:	f04f 0100 	mov.w	r1, #0
 800bafc:	f7fd fa42 	bl	8008f84 <RCC_APB2PeriphResetCmd>
 800bb00:	e062      	b.n	800bbc8 <TIM_DeInit+0x230>
   }  
  else if (TIMx == TIM10)
 800bb02:	687a      	ldr	r2, [r7, #4]
 800bb04:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800bb08:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800bb0c:	429a      	cmp	r2, r3
 800bb0e:	d10c      	bne.n	800bb2a <TIM_DeInit+0x192>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
 800bb10:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800bb14:	f04f 0101 	mov.w	r1, #1
 800bb18:	f7fd fa34 	bl	8008f84 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
 800bb1c:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800bb20:	f04f 0100 	mov.w	r1, #0
 800bb24:	f7fd fa2e 	bl	8008f84 <RCC_APB2PeriphResetCmd>
 800bb28:	e04e      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM11) 
 800bb2a:	687a      	ldr	r2, [r7, #4]
 800bb2c:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800bb30:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800bb34:	429a      	cmp	r2, r3
 800bb36:	d10c      	bne.n	800bb52 <TIM_DeInit+0x1ba>
  {     
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
 800bb38:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800bb3c:	f04f 0101 	mov.w	r1, #1
 800bb40:	f7fd fa20 	bl	8008f84 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
 800bb44:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800bb48:	f04f 0100 	mov.w	r1, #0
 800bb4c:	f7fd fa1a 	bl	8008f84 <RCC_APB2PeriphResetCmd>
 800bb50:	e03a      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM12)
 800bb52:	687a      	ldr	r2, [r7, #4]
 800bb54:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 800bb58:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800bb5c:	429a      	cmp	r2, r3
 800bb5e:	d10c      	bne.n	800bb7a <TIM_DeInit+0x1e2>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
 800bb60:	f04f 0040 	mov.w	r0, #64	; 0x40
 800bb64:	f04f 0101 	mov.w	r1, #1
 800bb68:	f7fd f9e0 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
 800bb6c:	f04f 0040 	mov.w	r0, #64	; 0x40
 800bb70:	f04f 0100 	mov.w	r1, #0
 800bb74:	f7fd f9da 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 800bb78:	e026      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else if (TIMx == TIM13) 
 800bb7a:	687a      	ldr	r2, [r7, #4]
 800bb7c:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800bb80:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800bb84:	429a      	cmp	r2, r3
 800bb86:	d10c      	bne.n	800bba2 <TIM_DeInit+0x20a>
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
 800bb88:	f04f 0080 	mov.w	r0, #128	; 0x80
 800bb8c:	f04f 0101 	mov.w	r1, #1
 800bb90:	f7fd f9cc 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
 800bb94:	f04f 0080 	mov.w	r0, #128	; 0x80
 800bb98:	f04f 0100 	mov.w	r1, #0
 800bb9c:	f7fd f9c6 	bl	8008f2c <RCC_APB1PeriphResetCmd>
 800bba0:	e012      	b.n	800bbc8 <TIM_DeInit+0x230>
  }  
  else
  { 
    if (TIMx == TIM14) 
 800bba2:	687a      	ldr	r2, [r7, #4]
 800bba4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800bba8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800bbac:	429a      	cmp	r2, r3
 800bbae:	d10b      	bne.n	800bbc8 <TIM_DeInit+0x230>
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
 800bbb0:	f44f 7080 	mov.w	r0, #256	; 0x100
 800bbb4:	f04f 0101 	mov.w	r1, #1
 800bbb8:	f7fd f9b8 	bl	8008f2c <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
 800bbbc:	f44f 7080 	mov.w	r0, #256	; 0x100
 800bbc0:	f04f 0100 	mov.w	r1, #0
 800bbc4:	f7fd f9b2 	bl	8008f2c <RCC_APB1PeriphResetCmd>
    }   
  }
}
 800bbc8:	f107 0708 	add.w	r7, r7, #8
 800bbcc:	46bd      	mov	sp, r7
 800bbce:	bd80      	pop	{r7, pc}

0800bbd0 <TIM_TimeBaseInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 800bbd0:	b480      	push	{r7}
 800bbd2:	b085      	sub	sp, #20
 800bbd4:	af00      	add	r7, sp, #0
 800bbd6:	6078      	str	r0, [r7, #4]
 800bbd8:	6039      	str	r1, [r7, #0]
  uint16_t tmpcr1 = 0;
 800bbda:	f04f 0300 	mov.w	r3, #0
 800bbde:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 800bbe0:	687b      	ldr	r3, [r7, #4]
 800bbe2:	881b      	ldrh	r3, [r3, #0]
 800bbe4:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8)||
 800bbe6:	687a      	ldr	r2, [r7, #4]
 800bbe8:	f04f 0300 	mov.w	r3, #0
 800bbec:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800bbf0:	429a      	cmp	r2, r3
 800bbf2:	d01f      	beq.n	800bc34 <TIM_TimeBaseInit+0x64>
 800bbf4:	687a      	ldr	r2, [r7, #4]
 800bbf6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bbfa:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800bbfe:	429a      	cmp	r2, r3
 800bc00:	d018      	beq.n	800bc34 <TIM_TimeBaseInit+0x64>
 800bc02:	687b      	ldr	r3, [r7, #4]
 800bc04:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800bc08:	d014      	beq.n	800bc34 <TIM_TimeBaseInit+0x64>
     (TIMx == TIM2) || (TIMx == TIM3)||
 800bc0a:	687a      	ldr	r2, [r7, #4]
 800bc0c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc10:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800bc14:	429a      	cmp	r2, r3
 800bc16:	d00d      	beq.n	800bc34 <TIM_TimeBaseInit+0x64>
 800bc18:	687a      	ldr	r2, [r7, #4]
 800bc1a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800bc1e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800bc22:	429a      	cmp	r2, r3
 800bc24:	d006      	beq.n	800bc34 <TIM_TimeBaseInit+0x64>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 800bc26:	687a      	ldr	r2, [r7, #4]
 800bc28:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 800bc2c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800bc30:	429a      	cmp	r2, r3
 800bc32:	d108      	bne.n	800bc46 <TIM_TimeBaseInit+0x76>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 800bc34:	89fb      	ldrh	r3, [r7, #14]
 800bc36:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800bc3a:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 800bc3c:	683b      	ldr	r3, [r7, #0]
 800bc3e:	885a      	ldrh	r2, [r3, #2]
 800bc40:	89fb      	ldrh	r3, [r7, #14]
 800bc42:	4313      	orrs	r3, r2
 800bc44:	81fb      	strh	r3, [r7, #14]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 800bc46:	687a      	ldr	r2, [r7, #4]
 800bc48:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800bc4c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800bc50:	429a      	cmp	r2, r3
 800bc52:	d00f      	beq.n	800bc74 <TIM_TimeBaseInit+0xa4>
 800bc54:	687a      	ldr	r2, [r7, #4]
 800bc56:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800bc5a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800bc5e:	429a      	cmp	r2, r3
 800bc60:	d008      	beq.n	800bc74 <TIM_TimeBaseInit+0xa4>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 800bc62:	89fb      	ldrh	r3, [r7, #14]
 800bc64:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800bc68:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 800bc6a:	683b      	ldr	r3, [r7, #0]
 800bc6c:	891a      	ldrh	r2, [r3, #8]
 800bc6e:	89fb      	ldrh	r3, [r7, #14]
 800bc70:	4313      	orrs	r3, r2
 800bc72:	81fb      	strh	r3, [r7, #14]
  }

  TIMx->CR1 = tmpcr1;
 800bc74:	687b      	ldr	r3, [r7, #4]
 800bc76:	89fa      	ldrh	r2, [r7, #14]
 800bc78:	801a      	strh	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 800bc7a:	683b      	ldr	r3, [r7, #0]
 800bc7c:	685a      	ldr	r2, [r3, #4]
 800bc7e:	687b      	ldr	r3, [r7, #4]
 800bc80:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 800bc82:	683b      	ldr	r3, [r7, #0]
 800bc84:	881a      	ldrh	r2, [r3, #0]
 800bc86:	687b      	ldr	r3, [r7, #4]
 800bc88:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 800bc8a:	687a      	ldr	r2, [r7, #4]
 800bc8c:	f04f 0300 	mov.w	r3, #0
 800bc90:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800bc94:	429a      	cmp	r2, r3
 800bc96:	d006      	beq.n	800bca6 <TIM_TimeBaseInit+0xd6>
 800bc98:	687a      	ldr	r2, [r7, #4]
 800bc9a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bc9e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800bca2:	429a      	cmp	r2, r3
 800bca4:	d104      	bne.n	800bcb0 <TIM_TimeBaseInit+0xe0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 800bca6:	683b      	ldr	r3, [r7, #0]
 800bca8:	7a9b      	ldrb	r3, [r3, #10]
 800bcaa:	461a      	mov	r2, r3
 800bcac:	687b      	ldr	r3, [r7, #4]
 800bcae:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 800bcb0:	687b      	ldr	r3, [r7, #4]
 800bcb2:	f04f 0201 	mov.w	r2, #1
 800bcb6:	829a      	strh	r2, [r3, #20]
}
 800bcb8:	f107 0714 	add.w	r7, r7, #20
 800bcbc:	46bd      	mov	sp, r7
 800bcbe:	bc80      	pop	{r7}
 800bcc0:	4770      	bx	lr
 800bcc2:	bf00      	nop

0800bcc4 <TIM_TimeBaseStructInit>:
  * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
  *         structure which will be initialized.
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 800bcc4:	b480      	push	{r7}
 800bcc6:	b083      	sub	sp, #12
 800bcc8:	af00      	add	r7, sp, #0
 800bcca:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 800bccc:	687b      	ldr	r3, [r7, #4]
 800bcce:	f04f 32ff 	mov.w	r2, #4294967295
 800bcd2:	605a      	str	r2, [r3, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 800bcd4:	687b      	ldr	r3, [r7, #4]
 800bcd6:	f04f 0200 	mov.w	r2, #0
 800bcda:	801a      	strh	r2, [r3, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 800bcdc:	687b      	ldr	r3, [r7, #4]
 800bcde:	f04f 0200 	mov.w	r2, #0
 800bce2:	811a      	strh	r2, [r3, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 800bce4:	687b      	ldr	r3, [r7, #4]
 800bce6:	f04f 0200 	mov.w	r2, #0
 800bcea:	805a      	strh	r2, [r3, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 800bcec:	687b      	ldr	r3, [r7, #4]
 800bcee:	f04f 0200 	mov.w	r2, #0
 800bcf2:	729a      	strb	r2, [r3, #10]
}
 800bcf4:	f107 070c 	add.w	r7, r7, #12
 800bcf8:	46bd      	mov	sp, r7
 800bcfa:	bc80      	pop	{r7}
 800bcfc:	4770      	bx	lr
 800bcfe:	bf00      	nop

0800bd00 <TIM_PrescalerConfig>:
  *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
  *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
  * @retval None
  */
void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
{
 800bd00:	b480      	push	{r7}
 800bd02:	b083      	sub	sp, #12
 800bd04:	af00      	add	r7, sp, #0
 800bd06:	6078      	str	r0, [r7, #4]
 800bd08:	4613      	mov	r3, r2
 800bd0a:	460a      	mov	r2, r1
 800bd0c:	807a      	strh	r2, [r7, #2]
 800bd0e:	803b      	strh	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 800bd10:	687b      	ldr	r3, [r7, #4]
 800bd12:	887a      	ldrh	r2, [r7, #2]
 800bd14:	851a      	strh	r2, [r3, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 800bd16:	687b      	ldr	r3, [r7, #4]
 800bd18:	883a      	ldrh	r2, [r7, #0]
 800bd1a:	829a      	strh	r2, [r3, #20]
}
 800bd1c:	f107 070c 	add.w	r7, r7, #12
 800bd20:	46bd      	mov	sp, r7
 800bd22:	bc80      	pop	{r7}
 800bd24:	4770      	bx	lr
 800bd26:	bf00      	nop

0800bd28 <TIM_CounterModeConfig>:
  *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
  *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
  * @retval None
  */
void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
{
 800bd28:	b480      	push	{r7}
 800bd2a:	b085      	sub	sp, #20
 800bd2c:	af00      	add	r7, sp, #0
 800bd2e:	6078      	str	r0, [r7, #4]
 800bd30:	460b      	mov	r3, r1
 800bd32:	807b      	strh	r3, [r7, #2]
  uint16_t tmpcr1 = 0;
 800bd34:	f04f 0300 	mov.w	r3, #0
 800bd38:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));

  tmpcr1 = TIMx->CR1;
 800bd3a:	687b      	ldr	r3, [r7, #4]
 800bd3c:	881b      	ldrh	r3, [r3, #0]
 800bd3e:	81fb      	strh	r3, [r7, #14]

  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
 800bd40:	89fb      	ldrh	r3, [r7, #14]
 800bd42:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800bd46:	81fb      	strh	r3, [r7, #14]

  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 800bd48:	89fa      	ldrh	r2, [r7, #14]
 800bd4a:	887b      	ldrh	r3, [r7, #2]
 800bd4c:	4313      	orrs	r3, r2
 800bd4e:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 800bd50:	687b      	ldr	r3, [r7, #4]
 800bd52:	89fa      	ldrh	r2, [r7, #14]
 800bd54:	801a      	strh	r2, [r3, #0]
}
 800bd56:	f107 0714 	add.w	r7, r7, #20
 800bd5a:	46bd      	mov	sp, r7
 800bd5c:	bc80      	pop	{r7}
 800bd5e:	4770      	bx	lr

0800bd60 <TIM_SetCounter>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @param  Counter: specifies the Counter register new value.
  * @retval None
  */
void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
{
 800bd60:	b480      	push	{r7}
 800bd62:	b083      	sub	sp, #12
 800bd64:	af00      	add	r7, sp, #0
 800bd66:	6078      	str	r0, [r7, #4]
 800bd68:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
   assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 800bd6a:	687b      	ldr	r3, [r7, #4]
 800bd6c:	683a      	ldr	r2, [r7, #0]
 800bd6e:	625a      	str	r2, [r3, #36]	; 0x24
}
 800bd70:	f107 070c 	add.w	r7, r7, #12
 800bd74:	46bd      	mov	sp, r7
 800bd76:	bc80      	pop	{r7}
 800bd78:	4770      	bx	lr
 800bd7a:	bf00      	nop

0800bd7c <TIM_SetAutoreload>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @param  Autoreload: specifies the Autoreload register new value.
  * @retval None
  */
void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
{
 800bd7c:	b480      	push	{r7}
 800bd7e:	b083      	sub	sp, #12
 800bd80:	af00      	add	r7, sp, #0
 800bd82:	6078      	str	r0, [r7, #4]
 800bd84:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 800bd86:	687b      	ldr	r3, [r7, #4]
 800bd88:	683a      	ldr	r2, [r7, #0]
 800bd8a:	62da      	str	r2, [r3, #44]	; 0x2c
}
 800bd8c:	f107 070c 	add.w	r7, r7, #12
 800bd90:	46bd      	mov	sp, r7
 800bd92:	bc80      	pop	{r7}
 800bd94:	4770      	bx	lr
 800bd96:	bf00      	nop

0800bd98 <TIM_GetCounter>:
  * @brief  Gets the TIMx Counter value.
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval Counter Register value
  */
uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
{
 800bd98:	b480      	push	{r7}
 800bd9a:	b083      	sub	sp, #12
 800bd9c:	af00      	add	r7, sp, #0
 800bd9e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Counter Register value */
  return TIMx->CNT;
 800bda0:	687b      	ldr	r3, [r7, #4]
 800bda2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800bda4:	4618      	mov	r0, r3
 800bda6:	f107 070c 	add.w	r7, r7, #12
 800bdaa:	46bd      	mov	sp, r7
 800bdac:	bc80      	pop	{r7}
 800bdae:	4770      	bx	lr

0800bdb0 <TIM_GetPrescaler>:
  * @brief  Gets the TIMx Prescaler value.
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval Prescaler Register value.
  */
uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
{
 800bdb0:	b480      	push	{r7}
 800bdb2:	b083      	sub	sp, #12
 800bdb4:	af00      	add	r7, sp, #0
 800bdb6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Prescaler Register value */
  return TIMx->PSC;
 800bdb8:	687b      	ldr	r3, [r7, #4]
 800bdba:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800bdbc:	b29b      	uxth	r3, r3
}
 800bdbe:	4618      	mov	r0, r3
 800bdc0:	f107 070c 	add.w	r7, r7, #12
 800bdc4:	46bd      	mov	sp, r7
 800bdc6:	bc80      	pop	{r7}
 800bdc8:	4770      	bx	lr
 800bdca:	bf00      	nop

0800bdcc <TIM_UpdateDisableConfig>:
  * @param  NewState: new state of the TIMx UDIS bit
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800bdcc:	b480      	push	{r7}
 800bdce:	b083      	sub	sp, #12
 800bdd0:	af00      	add	r7, sp, #0
 800bdd2:	6078      	str	r0, [r7, #4]
 800bdd4:	460b      	mov	r3, r1
 800bdd6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800bdd8:	78fb      	ldrb	r3, [r7, #3]
 800bdda:	2b00      	cmp	r3, #0
 800bddc:	d008      	beq.n	800bdf0 <TIM_UpdateDisableConfig+0x24>
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 800bdde:	687b      	ldr	r3, [r7, #4]
 800bde0:	881b      	ldrh	r3, [r3, #0]
 800bde2:	b29b      	uxth	r3, r3
 800bde4:	f043 0302 	orr.w	r3, r3, #2
 800bde8:	b29a      	uxth	r2, r3
 800bdea:	687b      	ldr	r3, [r7, #4]
 800bdec:	801a      	strh	r2, [r3, #0]
 800bdee:	e007      	b.n	800be00 <TIM_UpdateDisableConfig+0x34>
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
 800bdf0:	687b      	ldr	r3, [r7, #4]
 800bdf2:	881b      	ldrh	r3, [r3, #0]
 800bdf4:	b29b      	uxth	r3, r3
 800bdf6:	f023 0302 	bic.w	r3, r3, #2
 800bdfa:	b29a      	uxth	r2, r3
 800bdfc:	687b      	ldr	r3, [r7, #4]
 800bdfe:	801a      	strh	r2, [r3, #0]
  }
}
 800be00:	f107 070c 	add.w	r7, r7, #12
 800be04:	46bd      	mov	sp, r7
 800be06:	bc80      	pop	{r7}
 800be08:	4770      	bx	lr
 800be0a:	bf00      	nop

0800be0c <TIM_UpdateRequestConfig>:
  *                 generation through the slave mode controller.
  *            @arg TIM_UpdateSource_Regular: Source of update is counter overflow/underflow.
  * @retval None
  */
void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
{
 800be0c:	b480      	push	{r7}
 800be0e:	b083      	sub	sp, #12
 800be10:	af00      	add	r7, sp, #0
 800be12:	6078      	str	r0, [r7, #4]
 800be14:	460b      	mov	r3, r1
 800be16:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 800be18:	887b      	ldrh	r3, [r7, #2]
 800be1a:	2b00      	cmp	r3, #0
 800be1c:	d008      	beq.n	800be30 <TIM_UpdateRequestConfig+0x24>
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 800be1e:	687b      	ldr	r3, [r7, #4]
 800be20:	881b      	ldrh	r3, [r3, #0]
 800be22:	b29b      	uxth	r3, r3
 800be24:	f043 0304 	orr.w	r3, r3, #4
 800be28:	b29a      	uxth	r2, r3
 800be2a:	687b      	ldr	r3, [r7, #4]
 800be2c:	801a      	strh	r2, [r3, #0]
 800be2e:	e007      	b.n	800be40 <TIM_UpdateRequestConfig+0x34>
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
 800be30:	687b      	ldr	r3, [r7, #4]
 800be32:	881b      	ldrh	r3, [r3, #0]
 800be34:	b29b      	uxth	r3, r3
 800be36:	f023 0304 	bic.w	r3, r3, #4
 800be3a:	b29a      	uxth	r2, r3
 800be3c:	687b      	ldr	r3, [r7, #4]
 800be3e:	801a      	strh	r2, [r3, #0]
  }
}
 800be40:	f107 070c 	add.w	r7, r7, #12
 800be44:	46bd      	mov	sp, r7
 800be46:	bc80      	pop	{r7}
 800be48:	4770      	bx	lr
 800be4a:	bf00      	nop

0800be4c <TIM_ARRPreloadConfig>:
  * @param  NewState: new state of the TIMx peripheral Preload register
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800be4c:	b480      	push	{r7}
 800be4e:	b083      	sub	sp, #12
 800be50:	af00      	add	r7, sp, #0
 800be52:	6078      	str	r0, [r7, #4]
 800be54:	460b      	mov	r3, r1
 800be56:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800be58:	78fb      	ldrb	r3, [r7, #3]
 800be5a:	2b00      	cmp	r3, #0
 800be5c:	d008      	beq.n	800be70 <TIM_ARRPreloadConfig+0x24>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 800be5e:	687b      	ldr	r3, [r7, #4]
 800be60:	881b      	ldrh	r3, [r3, #0]
 800be62:	b29b      	uxth	r3, r3
 800be64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800be68:	b29a      	uxth	r2, r3
 800be6a:	687b      	ldr	r3, [r7, #4]
 800be6c:	801a      	strh	r2, [r3, #0]
 800be6e:	e007      	b.n	800be80 <TIM_ARRPreloadConfig+0x34>
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 800be70:	687b      	ldr	r3, [r7, #4]
 800be72:	881b      	ldrh	r3, [r3, #0]
 800be74:	b29b      	uxth	r3, r3
 800be76:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800be7a:	b29a      	uxth	r2, r3
 800be7c:	687b      	ldr	r3, [r7, #4]
 800be7e:	801a      	strh	r2, [r3, #0]
  }
}
 800be80:	f107 070c 	add.w	r7, r7, #12
 800be84:	46bd      	mov	sp, r7
 800be86:	bc80      	pop	{r7}
 800be88:	4770      	bx	lr
 800be8a:	bf00      	nop

0800be8c <TIM_SelectOnePulseMode>:
  *            @arg TIM_OPMode_Single
  *            @arg TIM_OPMode_Repetitive
  * @retval None
  */
void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
{
 800be8c:	b480      	push	{r7}
 800be8e:	b083      	sub	sp, #12
 800be90:	af00      	add	r7, sp, #0
 800be92:	6078      	str	r0, [r7, #4]
 800be94:	460b      	mov	r3, r1
 800be96:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));

  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
 800be98:	687b      	ldr	r3, [r7, #4]
 800be9a:	881b      	ldrh	r3, [r3, #0]
 800be9c:	b29b      	uxth	r3, r3
 800be9e:	f023 0308 	bic.w	r3, r3, #8
 800bea2:	b29a      	uxth	r2, r3
 800bea4:	687b      	ldr	r3, [r7, #4]
 800bea6:	801a      	strh	r2, [r3, #0]

  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 800bea8:	687b      	ldr	r3, [r7, #4]
 800beaa:	881b      	ldrh	r3, [r3, #0]
 800beac:	b29a      	uxth	r2, r3
 800beae:	887b      	ldrh	r3, [r7, #2]
 800beb0:	4313      	orrs	r3, r2
 800beb2:	b29a      	uxth	r2, r3
 800beb4:	687b      	ldr	r3, [r7, #4]
 800beb6:	801a      	strh	r2, [r3, #0]
}
 800beb8:	f107 070c 	add.w	r7, r7, #12
 800bebc:	46bd      	mov	sp, r7
 800bebe:	bc80      	pop	{r7}
 800bec0:	4770      	bx	lr
 800bec2:	bf00      	nop

0800bec4 <TIM_SetClockDivision>:
  *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
  *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
  * @retval None
  */
void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
{
 800bec4:	b480      	push	{r7}
 800bec6:	b083      	sub	sp, #12
 800bec8:	af00      	add	r7, sp, #0
 800beca:	6078      	str	r0, [r7, #4]
 800becc:	460b      	mov	r3, r1
 800bece:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));

  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
 800bed0:	687b      	ldr	r3, [r7, #4]
 800bed2:	881b      	ldrh	r3, [r3, #0]
 800bed4:	b29b      	uxth	r3, r3
 800bed6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800beda:	b29a      	uxth	r2, r3
 800bedc:	687b      	ldr	r3, [r7, #4]
 800bede:	801a      	strh	r2, [r3, #0]

  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 800bee0:	687b      	ldr	r3, [r7, #4]
 800bee2:	881b      	ldrh	r3, [r3, #0]
 800bee4:	b29a      	uxth	r2, r3
 800bee6:	887b      	ldrh	r3, [r7, #2]
 800bee8:	4313      	orrs	r3, r2
 800beea:	b29a      	uxth	r2, r3
 800beec:	687b      	ldr	r3, [r7, #4]
 800beee:	801a      	strh	r2, [r3, #0]
}
 800bef0:	f107 070c 	add.w	r7, r7, #12
 800bef4:	46bd      	mov	sp, r7
 800bef6:	bc80      	pop	{r7}
 800bef8:	4770      	bx	lr
 800befa:	bf00      	nop

0800befc <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800befc:	b480      	push	{r7}
 800befe:	b083      	sub	sp, #12
 800bf00:	af00      	add	r7, sp, #0
 800bf02:	6078      	str	r0, [r7, #4]
 800bf04:	460b      	mov	r3, r1
 800bf06:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800bf08:	78fb      	ldrb	r3, [r7, #3]
 800bf0a:	2b00      	cmp	r3, #0
 800bf0c:	d008      	beq.n	800bf20 <TIM_Cmd+0x24>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 800bf0e:	687b      	ldr	r3, [r7, #4]
 800bf10:	881b      	ldrh	r3, [r3, #0]
 800bf12:	b29b      	uxth	r3, r3
 800bf14:	f043 0301 	orr.w	r3, r3, #1
 800bf18:	b29a      	uxth	r2, r3
 800bf1a:	687b      	ldr	r3, [r7, #4]
 800bf1c:	801a      	strh	r2, [r3, #0]
 800bf1e:	e007      	b.n	800bf30 <TIM_Cmd+0x34>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 800bf20:	687b      	ldr	r3, [r7, #4]
 800bf22:	881b      	ldrh	r3, [r3, #0]
 800bf24:	b29b      	uxth	r3, r3
 800bf26:	f023 0301 	bic.w	r3, r3, #1
 800bf2a:	b29a      	uxth	r2, r3
 800bf2c:	687b      	ldr	r3, [r7, #4]
 800bf2e:	801a      	strh	r2, [r3, #0]
  }
}
 800bf30:	f107 070c 	add.w	r7, r7, #12
 800bf34:	46bd      	mov	sp, r7
 800bf36:	bc80      	pop	{r7}
 800bf38:	4770      	bx	lr
 800bf3a:	bf00      	nop

0800bf3c <TIM_OC1Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800bf3c:	b480      	push	{r7}
 800bf3e:	b085      	sub	sp, #20
 800bf40:	af00      	add	r7, sp, #0
 800bf42:	6078      	str	r0, [r7, #4]
 800bf44:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 800bf46:	f04f 0300 	mov.w	r3, #0
 800bf4a:	817b      	strh	r3, [r7, #10]
 800bf4c:	f04f 0300 	mov.w	r3, #0
 800bf50:	81fb      	strh	r3, [r7, #14]
 800bf52:	f04f 0300 	mov.w	r3, #0
 800bf56:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 800bf58:	687b      	ldr	r3, [r7, #4]
 800bf5a:	8c1b      	ldrh	r3, [r3, #32]
 800bf5c:	b29b      	uxth	r3, r3
 800bf5e:	f023 0301 	bic.w	r3, r3, #1
 800bf62:	b29a      	uxth	r2, r3
 800bf64:	687b      	ldr	r3, [r7, #4]
 800bf66:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800bf68:	687b      	ldr	r3, [r7, #4]
 800bf6a:	8c1b      	ldrh	r3, [r3, #32]
 800bf6c:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800bf6e:	687b      	ldr	r3, [r7, #4]
 800bf70:	889b      	ldrh	r3, [r3, #4]
 800bf72:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800bf74:	687b      	ldr	r3, [r7, #4]
 800bf76:	8b1b      	ldrh	r3, [r3, #24]
 800bf78:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
 800bf7a:	897b      	ldrh	r3, [r7, #10]
 800bf7c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800bf80:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 800bf82:	897b      	ldrh	r3, [r7, #10]
 800bf84:	f023 0303 	bic.w	r3, r3, #3
 800bf88:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 800bf8a:	683b      	ldr	r3, [r7, #0]
 800bf8c:	881a      	ldrh	r2, [r3, #0]
 800bf8e:	897b      	ldrh	r3, [r7, #10]
 800bf90:	4313      	orrs	r3, r2
 800bf92:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 800bf94:	89fb      	ldrh	r3, [r7, #14]
 800bf96:	f023 0302 	bic.w	r3, r3, #2
 800bf9a:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 800bf9c:	683b      	ldr	r3, [r7, #0]
 800bf9e:	899a      	ldrh	r2, [r3, #12]
 800bfa0:	89fb      	ldrh	r3, [r7, #14]
 800bfa2:	4313      	orrs	r3, r2
 800bfa4:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 800bfa6:	683b      	ldr	r3, [r7, #0]
 800bfa8:	885a      	ldrh	r2, [r3, #2]
 800bfaa:	89fb      	ldrh	r3, [r7, #14]
 800bfac:	4313      	orrs	r3, r2
 800bfae:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800bfb0:	687a      	ldr	r2, [r7, #4]
 800bfb2:	f04f 0300 	mov.w	r3, #0
 800bfb6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800bfba:	429a      	cmp	r2, r3
 800bfbc:	d006      	beq.n	800bfcc <TIM_OC1Init+0x90>
 800bfbe:	687a      	ldr	r2, [r7, #4]
 800bfc0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bfc4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800bfc8:	429a      	cmp	r2, r3
 800bfca:	d123      	bne.n	800c014 <TIM_OC1Init+0xd8>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 800bfcc:	89fb      	ldrh	r3, [r7, #14]
 800bfce:	f023 0308 	bic.w	r3, r3, #8
 800bfd2:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 800bfd4:	683b      	ldr	r3, [r7, #0]
 800bfd6:	89da      	ldrh	r2, [r3, #14]
 800bfd8:	89fb      	ldrh	r3, [r7, #14]
 800bfda:	4313      	orrs	r3, r2
 800bfdc:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
 800bfde:	89fb      	ldrh	r3, [r7, #14]
 800bfe0:	f023 0304 	bic.w	r3, r3, #4
 800bfe4:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 800bfe6:	683b      	ldr	r3, [r7, #0]
 800bfe8:	889a      	ldrh	r2, [r3, #4]
 800bfea:	89fb      	ldrh	r3, [r7, #14]
 800bfec:	4313      	orrs	r3, r2
 800bfee:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
 800bff0:	89bb      	ldrh	r3, [r7, #12]
 800bff2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800bff6:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
 800bff8:	89bb      	ldrh	r3, [r7, #12]
 800bffa:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800bffe:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 800c000:	683b      	ldr	r3, [r7, #0]
 800c002:	8a1a      	ldrh	r2, [r3, #16]
 800c004:	89bb      	ldrh	r3, [r7, #12]
 800c006:	4313      	orrs	r3, r2
 800c008:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 800c00a:	683b      	ldr	r3, [r7, #0]
 800c00c:	8a5a      	ldrh	r2, [r3, #18]
 800c00e:	89bb      	ldrh	r3, [r7, #12]
 800c010:	4313      	orrs	r3, r2
 800c012:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c014:	687b      	ldr	r3, [r7, #4]
 800c016:	89ba      	ldrh	r2, [r7, #12]
 800c018:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800c01a:	687b      	ldr	r3, [r7, #4]
 800c01c:	897a      	ldrh	r2, [r7, #10]
 800c01e:	831a      	strh	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 800c020:	683b      	ldr	r3, [r7, #0]
 800c022:	689a      	ldr	r2, [r3, #8]
 800c024:	687b      	ldr	r3, [r7, #4]
 800c026:	635a      	str	r2, [r3, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c028:	687b      	ldr	r3, [r7, #4]
 800c02a:	89fa      	ldrh	r2, [r7, #14]
 800c02c:	841a      	strh	r2, [r3, #32]
}
 800c02e:	f107 0714 	add.w	r7, r7, #20
 800c032:	46bd      	mov	sp, r7
 800c034:	bc80      	pop	{r7}
 800c036:	4770      	bx	lr

0800c038 <TIM_OC2Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800c038:	b480      	push	{r7}
 800c03a:	b085      	sub	sp, #20
 800c03c:	af00      	add	r7, sp, #0
 800c03e:	6078      	str	r0, [r7, #4]
 800c040:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 800c042:	f04f 0300 	mov.w	r3, #0
 800c046:	817b      	strh	r3, [r7, #10]
 800c048:	f04f 0300 	mov.w	r3, #0
 800c04c:	81fb      	strh	r3, [r7, #14]
 800c04e:	f04f 0300 	mov.w	r3, #0
 800c052:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 800c054:	687b      	ldr	r3, [r7, #4]
 800c056:	8c1b      	ldrh	r3, [r3, #32]
 800c058:	b29b      	uxth	r3, r3
 800c05a:	f023 0310 	bic.w	r3, r3, #16
 800c05e:	b29a      	uxth	r2, r3
 800c060:	687b      	ldr	r3, [r7, #4]
 800c062:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 800c064:	687b      	ldr	r3, [r7, #4]
 800c066:	8c1b      	ldrh	r3, [r3, #32]
 800c068:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c06a:	687b      	ldr	r3, [r7, #4]
 800c06c:	889b      	ldrh	r3, [r3, #4]
 800c06e:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800c070:	687b      	ldr	r3, [r7, #4]
 800c072:	8b1b      	ldrh	r3, [r3, #24]
 800c074:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
 800c076:	897b      	ldrh	r3, [r7, #10]
 800c078:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800c07c:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 800c07e:	897b      	ldrh	r3, [r7, #10]
 800c080:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c084:	817b      	strh	r3, [r7, #10]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800c086:	683b      	ldr	r3, [r7, #0]
 800c088:	881b      	ldrh	r3, [r3, #0]
 800c08a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c08e:	b29a      	uxth	r2, r3
 800c090:	897b      	ldrh	r3, [r7, #10]
 800c092:	4313      	orrs	r3, r2
 800c094:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 800c096:	89fb      	ldrh	r3, [r7, #14]
 800c098:	f023 0320 	bic.w	r3, r3, #32
 800c09c:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 800c09e:	683b      	ldr	r3, [r7, #0]
 800c0a0:	899b      	ldrh	r3, [r3, #12]
 800c0a2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800c0a6:	b29a      	uxth	r2, r3
 800c0a8:	89fb      	ldrh	r3, [r7, #14]
 800c0aa:	4313      	orrs	r3, r2
 800c0ac:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 800c0ae:	683b      	ldr	r3, [r7, #0]
 800c0b0:	885b      	ldrh	r3, [r3, #2]
 800c0b2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800c0b6:	b29a      	uxth	r2, r3
 800c0b8:	89fb      	ldrh	r3, [r7, #14]
 800c0ba:	4313      	orrs	r3, r2
 800c0bc:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800c0be:	687a      	ldr	r2, [r7, #4]
 800c0c0:	f04f 0300 	mov.w	r3, #0
 800c0c4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800c0c8:	429a      	cmp	r2, r3
 800c0ca:	d006      	beq.n	800c0da <TIM_OC2Init+0xa2>
 800c0cc:	687a      	ldr	r2, [r7, #4]
 800c0ce:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c0d2:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800c0d6:	429a      	cmp	r2, r3
 800c0d8:	d12f      	bne.n	800c13a <TIM_OC2Init+0x102>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 800c0da:	89fb      	ldrh	r3, [r7, #14]
 800c0dc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800c0e0:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 800c0e2:	683b      	ldr	r3, [r7, #0]
 800c0e4:	89db      	ldrh	r3, [r3, #14]
 800c0e6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800c0ea:	b29a      	uxth	r2, r3
 800c0ec:	89fb      	ldrh	r3, [r7, #14]
 800c0ee:	4313      	orrs	r3, r2
 800c0f0:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
 800c0f2:	89fb      	ldrh	r3, [r7, #14]
 800c0f4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800c0f8:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 800c0fa:	683b      	ldr	r3, [r7, #0]
 800c0fc:	889b      	ldrh	r3, [r3, #4]
 800c0fe:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800c102:	b29a      	uxth	r2, r3
 800c104:	89fb      	ldrh	r3, [r7, #14]
 800c106:	4313      	orrs	r3, r2
 800c108:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
 800c10a:	89bb      	ldrh	r3, [r7, #12]
 800c10c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800c110:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
 800c112:	89bb      	ldrh	r3, [r7, #12]
 800c114:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800c118:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 800c11a:	683b      	ldr	r3, [r7, #0]
 800c11c:	8a1b      	ldrh	r3, [r3, #16]
 800c11e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c122:	b29a      	uxth	r2, r3
 800c124:	89bb      	ldrh	r3, [r7, #12]
 800c126:	4313      	orrs	r3, r2
 800c128:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 800c12a:	683b      	ldr	r3, [r7, #0]
 800c12c:	8a5b      	ldrh	r3, [r3, #18]
 800c12e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c132:	b29a      	uxth	r2, r3
 800c134:	89bb      	ldrh	r3, [r7, #12]
 800c136:	4313      	orrs	r3, r2
 800c138:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c13a:	687b      	ldr	r3, [r7, #4]
 800c13c:	89ba      	ldrh	r2, [r7, #12]
 800c13e:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800c140:	687b      	ldr	r3, [r7, #4]
 800c142:	897a      	ldrh	r2, [r7, #10]
 800c144:	831a      	strh	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 800c146:	683b      	ldr	r3, [r7, #0]
 800c148:	689a      	ldr	r2, [r3, #8]
 800c14a:	687b      	ldr	r3, [r7, #4]
 800c14c:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c14e:	687b      	ldr	r3, [r7, #4]
 800c150:	89fa      	ldrh	r2, [r7, #14]
 800c152:	841a      	strh	r2, [r3, #32]
}
 800c154:	f107 0714 	add.w	r7, r7, #20
 800c158:	46bd      	mov	sp, r7
 800c15a:	bc80      	pop	{r7}
 800c15c:	4770      	bx	lr
 800c15e:	bf00      	nop

0800c160 <TIM_OC3Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800c160:	b480      	push	{r7}
 800c162:	b085      	sub	sp, #20
 800c164:	af00      	add	r7, sp, #0
 800c166:	6078      	str	r0, [r7, #4]
 800c168:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 800c16a:	f04f 0300 	mov.w	r3, #0
 800c16e:	817b      	strh	r3, [r7, #10]
 800c170:	f04f 0300 	mov.w	r3, #0
 800c174:	81fb      	strh	r3, [r7, #14]
 800c176:	f04f 0300 	mov.w	r3, #0
 800c17a:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 800c17c:	687b      	ldr	r3, [r7, #4]
 800c17e:	8c1b      	ldrh	r3, [r3, #32]
 800c180:	b29b      	uxth	r3, r3
 800c182:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800c186:	b29a      	uxth	r2, r3
 800c188:	687b      	ldr	r3, [r7, #4]
 800c18a:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c18c:	687b      	ldr	r3, [r7, #4]
 800c18e:	8c1b      	ldrh	r3, [r3, #32]
 800c190:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c192:	687b      	ldr	r3, [r7, #4]
 800c194:	889b      	ldrh	r3, [r3, #4]
 800c196:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800c198:	687b      	ldr	r3, [r7, #4]
 800c19a:	8b9b      	ldrh	r3, [r3, #28]
 800c19c:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
 800c19e:	897b      	ldrh	r3, [r7, #10]
 800c1a0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c1a4:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
 800c1a6:	897b      	ldrh	r3, [r7, #10]
 800c1a8:	f023 0303 	bic.w	r3, r3, #3
 800c1ac:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 800c1ae:	683b      	ldr	r3, [r7, #0]
 800c1b0:	881a      	ldrh	r2, [r3, #0]
 800c1b2:	897b      	ldrh	r3, [r7, #10]
 800c1b4:	4313      	orrs	r3, r2
 800c1b6:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 800c1b8:	89fb      	ldrh	r3, [r7, #14]
 800c1ba:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800c1be:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 800c1c0:	683b      	ldr	r3, [r7, #0]
 800c1c2:	899b      	ldrh	r3, [r3, #12]
 800c1c4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c1c8:	b29a      	uxth	r2, r3
 800c1ca:	89fb      	ldrh	r3, [r7, #14]
 800c1cc:	4313      	orrs	r3, r2
 800c1ce:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 800c1d0:	683b      	ldr	r3, [r7, #0]
 800c1d2:	885b      	ldrh	r3, [r3, #2]
 800c1d4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c1d8:	b29a      	uxth	r2, r3
 800c1da:	89fb      	ldrh	r3, [r7, #14]
 800c1dc:	4313      	orrs	r3, r2
 800c1de:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800c1e0:	687a      	ldr	r2, [r7, #4]
 800c1e2:	f04f 0300 	mov.w	r3, #0
 800c1e6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800c1ea:	429a      	cmp	r2, r3
 800c1ec:	d006      	beq.n	800c1fc <TIM_OC3Init+0x9c>
 800c1ee:	687a      	ldr	r2, [r7, #4]
 800c1f0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c1f4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800c1f8:	429a      	cmp	r2, r3
 800c1fa:	d12f      	bne.n	800c25c <TIM_OC3Init+0xfc>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 800c1fc:	89fb      	ldrh	r3, [r7, #14]
 800c1fe:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800c202:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 800c204:	683b      	ldr	r3, [r7, #0]
 800c206:	89db      	ldrh	r3, [r3, #14]
 800c208:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c20c:	b29a      	uxth	r2, r3
 800c20e:	89fb      	ldrh	r3, [r7, #14]
 800c210:	4313      	orrs	r3, r2
 800c212:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
 800c214:	89fb      	ldrh	r3, [r7, #14]
 800c216:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800c21a:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 800c21c:	683b      	ldr	r3, [r7, #0]
 800c21e:	889b      	ldrh	r3, [r3, #4]
 800c220:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c224:	b29a      	uxth	r2, r3
 800c226:	89fb      	ldrh	r3, [r7, #14]
 800c228:	4313      	orrs	r3, r2
 800c22a:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
 800c22c:	89bb      	ldrh	r3, [r7, #12]
 800c22e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800c232:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
 800c234:	89bb      	ldrh	r3, [r7, #12]
 800c236:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800c23a:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 800c23c:	683b      	ldr	r3, [r7, #0]
 800c23e:	8a1b      	ldrh	r3, [r3, #16]
 800c240:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800c244:	b29a      	uxth	r2, r3
 800c246:	89bb      	ldrh	r3, [r7, #12]
 800c248:	4313      	orrs	r3, r2
 800c24a:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 800c24c:	683b      	ldr	r3, [r7, #0]
 800c24e:	8a5b      	ldrh	r3, [r3, #18]
 800c250:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800c254:	b29a      	uxth	r2, r3
 800c256:	89bb      	ldrh	r3, [r7, #12]
 800c258:	4313      	orrs	r3, r2
 800c25a:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c25c:	687b      	ldr	r3, [r7, #4]
 800c25e:	89ba      	ldrh	r2, [r7, #12]
 800c260:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800c262:	687b      	ldr	r3, [r7, #4]
 800c264:	897a      	ldrh	r2, [r7, #10]
 800c266:	839a      	strh	r2, [r3, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 800c268:	683b      	ldr	r3, [r7, #0]
 800c26a:	689a      	ldr	r2, [r3, #8]
 800c26c:	687b      	ldr	r3, [r7, #4]
 800c26e:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c270:	687b      	ldr	r3, [r7, #4]
 800c272:	89fa      	ldrh	r2, [r7, #14]
 800c274:	841a      	strh	r2, [r3, #32]
}
 800c276:	f107 0714 	add.w	r7, r7, #20
 800c27a:	46bd      	mov	sp, r7
 800c27c:	bc80      	pop	{r7}
 800c27e:	4770      	bx	lr

0800c280 <TIM_OC4Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800c280:	b480      	push	{r7}
 800c282:	b085      	sub	sp, #20
 800c284:	af00      	add	r7, sp, #0
 800c286:	6078      	str	r0, [r7, #4]
 800c288:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 800c28a:	f04f 0300 	mov.w	r3, #0
 800c28e:	81bb      	strh	r3, [r7, #12]
 800c290:	f04f 0300 	mov.w	r3, #0
 800c294:	817b      	strh	r3, [r7, #10]
 800c296:	f04f 0300 	mov.w	r3, #0
 800c29a:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 800c29c:	687b      	ldr	r3, [r7, #4]
 800c29e:	8c1b      	ldrh	r3, [r3, #32]
 800c2a0:	b29b      	uxth	r3, r3
 800c2a2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800c2a6:	b29a      	uxth	r2, r3
 800c2a8:	687b      	ldr	r3, [r7, #4]
 800c2aa:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800c2ac:	687b      	ldr	r3, [r7, #4]
 800c2ae:	8c1b      	ldrh	r3, [r3, #32]
 800c2b0:	817b      	strh	r3, [r7, #10]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800c2b2:	687b      	ldr	r3, [r7, #4]
 800c2b4:	889b      	ldrh	r3, [r3, #4]
 800c2b6:	81fb      	strh	r3, [r7, #14]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800c2b8:	687b      	ldr	r3, [r7, #4]
 800c2ba:	8b9b      	ldrh	r3, [r3, #28]
 800c2bc:	81bb      	strh	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
 800c2be:	89bb      	ldrh	r3, [r7, #12]
 800c2c0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800c2c4:	81bb      	strh	r3, [r7, #12]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
 800c2c6:	89bb      	ldrh	r3, [r7, #12]
 800c2c8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c2cc:	81bb      	strh	r3, [r7, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800c2ce:	683b      	ldr	r3, [r7, #0]
 800c2d0:	881b      	ldrh	r3, [r3, #0]
 800c2d2:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c2d6:	b29a      	uxth	r2, r3
 800c2d8:	89bb      	ldrh	r3, [r7, #12]
 800c2da:	4313      	orrs	r3, r2
 800c2dc:	81bb      	strh	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 800c2de:	897b      	ldrh	r3, [r7, #10]
 800c2e0:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800c2e4:	817b      	strh	r3, [r7, #10]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 800c2e6:	683b      	ldr	r3, [r7, #0]
 800c2e8:	899b      	ldrh	r3, [r3, #12]
 800c2ea:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800c2ee:	b29a      	uxth	r2, r3
 800c2f0:	897b      	ldrh	r3, [r7, #10]
 800c2f2:	4313      	orrs	r3, r2
 800c2f4:	817b      	strh	r3, [r7, #10]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 800c2f6:	683b      	ldr	r3, [r7, #0]
 800c2f8:	885b      	ldrh	r3, [r3, #2]
 800c2fa:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800c2fe:	b29a      	uxth	r2, r3
 800c300:	897b      	ldrh	r3, [r7, #10]
 800c302:	4313      	orrs	r3, r2
 800c304:	817b      	strh	r3, [r7, #10]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 800c306:	687a      	ldr	r2, [r7, #4]
 800c308:	f04f 0300 	mov.w	r3, #0
 800c30c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800c310:	429a      	cmp	r2, r3
 800c312:	d006      	beq.n	800c322 <TIM_OC4Init+0xa2>
 800c314:	687a      	ldr	r2, [r7, #4]
 800c316:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c31a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800c31e:	429a      	cmp	r2, r3
 800c320:	d10b      	bne.n	800c33a <TIM_OC4Init+0xba>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
 800c322:	89fb      	ldrh	r3, [r7, #14]
 800c324:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800c328:	81fb      	strh	r3, [r7, #14]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 800c32a:	683b      	ldr	r3, [r7, #0]
 800c32c:	8a1b      	ldrh	r3, [r3, #16]
 800c32e:	ea4f 1383 	mov.w	r3, r3, lsl #6
 800c332:	b29a      	uxth	r2, r3
 800c334:	89fb      	ldrh	r3, [r7, #14]
 800c336:	4313      	orrs	r3, r2
 800c338:	81fb      	strh	r3, [r7, #14]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800c33a:	687b      	ldr	r3, [r7, #4]
 800c33c:	89fa      	ldrh	r2, [r7, #14]
 800c33e:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 800c340:	687b      	ldr	r3, [r7, #4]
 800c342:	89ba      	ldrh	r2, [r7, #12]
 800c344:	839a      	strh	r2, [r3, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 800c346:	683b      	ldr	r3, [r7, #0]
 800c348:	689a      	ldr	r2, [r3, #8]
 800c34a:	687b      	ldr	r3, [r7, #4]
 800c34c:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800c34e:	687b      	ldr	r3, [r7, #4]
 800c350:	897a      	ldrh	r2, [r7, #10]
 800c352:	841a      	strh	r2, [r3, #32]
}
 800c354:	f107 0714 	add.w	r7, r7, #20
 800c358:	46bd      	mov	sp, r7
 800c35a:	bc80      	pop	{r7}
 800c35c:	4770      	bx	lr
 800c35e:	bf00      	nop

0800c360 <TIM_OCStructInit>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800c360:	b480      	push	{r7}
 800c362:	b083      	sub	sp, #12
 800c364:	af00      	add	r7, sp, #0
 800c366:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 800c368:	687b      	ldr	r3, [r7, #4]
 800c36a:	f04f 0200 	mov.w	r2, #0
 800c36e:	801a      	strh	r2, [r3, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 800c370:	687b      	ldr	r3, [r7, #4]
 800c372:	f04f 0200 	mov.w	r2, #0
 800c376:	805a      	strh	r2, [r3, #2]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 800c378:	687b      	ldr	r3, [r7, #4]
 800c37a:	f04f 0200 	mov.w	r2, #0
 800c37e:	809a      	strh	r2, [r3, #4]
  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
 800c380:	687b      	ldr	r3, [r7, #4]
 800c382:	f04f 0200 	mov.w	r2, #0
 800c386:	609a      	str	r2, [r3, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 800c388:	687b      	ldr	r3, [r7, #4]
 800c38a:	f04f 0200 	mov.w	r2, #0
 800c38e:	819a      	strh	r2, [r3, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 800c390:	687b      	ldr	r3, [r7, #4]
 800c392:	f04f 0200 	mov.w	r2, #0
 800c396:	81da      	strh	r2, [r3, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 800c398:	687b      	ldr	r3, [r7, #4]
 800c39a:	f04f 0200 	mov.w	r2, #0
 800c39e:	821a      	strh	r2, [r3, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 800c3a0:	687b      	ldr	r3, [r7, #4]
 800c3a2:	f04f 0200 	mov.w	r2, #0
 800c3a6:	825a      	strh	r2, [r3, #18]
}
 800c3a8:	f107 070c 	add.w	r7, r7, #12
 800c3ac:	46bd      	mov	sp, r7
 800c3ae:	bc80      	pop	{r7}
 800c3b0:	4770      	bx	lr
 800c3b2:	bf00      	nop

0800c3b4 <TIM_SelectOCxM>:
  *            @arg TIM_ForcedAction_Active
  *            @arg TIM_ForcedAction_InActive
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
{
 800c3b4:	b480      	push	{r7}
 800c3b6:	b085      	sub	sp, #20
 800c3b8:	af00      	add	r7, sp, #0
 800c3ba:	6078      	str	r0, [r7, #4]
 800c3bc:	4613      	mov	r3, r2
 800c3be:	460a      	mov	r2, r1
 800c3c0:	807a      	strh	r2, [r7, #2]
 800c3c2:	803b      	strh	r3, [r7, #0]
  uint32_t tmp = 0;
 800c3c4:	f04f 0300 	mov.w	r3, #0
 800c3c8:	60fb      	str	r3, [r7, #12]
  uint16_t tmp1 = 0;
 800c3ca:	f04f 0300 	mov.w	r3, #0
 800c3ce:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
 800c3d0:	687b      	ldr	r3, [r7, #4]
 800c3d2:	60fb      	str	r3, [r7, #12]
  tmp += CCMR_OFFSET;
 800c3d4:	68fb      	ldr	r3, [r7, #12]
 800c3d6:	f103 0318 	add.w	r3, r3, #24
 800c3da:	60fb      	str	r3, [r7, #12]

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 800c3dc:	887b      	ldrh	r3, [r7, #2]
 800c3de:	f04f 0201 	mov.w	r2, #1
 800c3e2:	fa02 f303 	lsl.w	r3, r2, r3
 800c3e6:	817b      	strh	r3, [r7, #10]

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 800c3e8:	687b      	ldr	r3, [r7, #4]
 800c3ea:	8c1b      	ldrh	r3, [r3, #32]
 800c3ec:	b29a      	uxth	r2, r3
 800c3ee:	897b      	ldrh	r3, [r7, #10]
 800c3f0:	ea6f 0303 	mvn.w	r3, r3
 800c3f4:	b29b      	uxth	r3, r3
 800c3f6:	4013      	ands	r3, r2
 800c3f8:	b29a      	uxth	r2, r3
 800c3fa:	687b      	ldr	r3, [r7, #4]
 800c3fc:	841a      	strh	r2, [r3, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 800c3fe:	887b      	ldrh	r3, [r7, #2]
 800c400:	2b00      	cmp	r3, #0
 800c402:	d002      	beq.n	800c40a <TIM_SelectOCxM+0x56>
 800c404:	887b      	ldrh	r3, [r7, #2]
 800c406:	2b08      	cmp	r3, #8
 800c408:	d114      	bne.n	800c434 <TIM_SelectOCxM+0x80>
  {
    tmp += (TIM_Channel>>1);
 800c40a:	887b      	ldrh	r3, [r7, #2]
 800c40c:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800c410:	b29b      	uxth	r3, r3
 800c412:	68fa      	ldr	r2, [r7, #12]
 800c414:	18d3      	adds	r3, r2, r3
 800c416:	60fb      	str	r3, [r7, #12]

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
 800c418:	68fa      	ldr	r2, [r7, #12]
 800c41a:	68fb      	ldr	r3, [r7, #12]
 800c41c:	6819      	ldr	r1, [r3, #0]
 800c41e:	f64f 738f 	movw	r3, #65423	; 0xff8f
 800c422:	400b      	ands	r3, r1
 800c424:	6013      	str	r3, [r2, #0]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 800c426:	68fb      	ldr	r3, [r7, #12]
 800c428:	68fa      	ldr	r2, [r7, #12]
 800c42a:	6811      	ldr	r1, [r2, #0]
 800c42c:	883a      	ldrh	r2, [r7, #0]
 800c42e:	430a      	orrs	r2, r1
 800c430:	601a      	str	r2, [r3, #0]
 800c432:	e019      	b.n	800c468 <TIM_SelectOCxM+0xb4>
  }
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
 800c434:	887b      	ldrh	r3, [r7, #2]
 800c436:	f1a3 0304 	sub.w	r3, r3, #4
 800c43a:	b29b      	uxth	r3, r3
 800c43c:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800c440:	b29b      	uxth	r3, r3
 800c442:	68fa      	ldr	r2, [r7, #12]
 800c444:	18d3      	adds	r3, r2, r3
 800c446:	60fb      	str	r3, [r7, #12]

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 800c448:	68fa      	ldr	r2, [r7, #12]
 800c44a:	68fb      	ldr	r3, [r7, #12]
 800c44c:	6819      	ldr	r1, [r3, #0]
 800c44e:	f648 73ff 	movw	r3, #36863	; 0x8fff
 800c452:	400b      	ands	r3, r1
 800c454:	6013      	str	r3, [r2, #0]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 800c456:	68fb      	ldr	r3, [r7, #12]
 800c458:	68fa      	ldr	r2, [r7, #12]
 800c45a:	6811      	ldr	r1, [r2, #0]
 800c45c:	883a      	ldrh	r2, [r7, #0]
 800c45e:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800c462:	b292      	uxth	r2, r2
 800c464:	430a      	orrs	r2, r1
 800c466:	601a      	str	r2, [r3, #0]
  }
}
 800c468:	f107 0714 	add.w	r7, r7, #20
 800c46c:	46bd      	mov	sp, r7
 800c46e:	bc80      	pop	{r7}
 800c470:	4770      	bx	lr
 800c472:	bf00      	nop

0800c474 <TIM_SetCompare1>:
  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
  * @param  Compare1: specifies the Capture Compare1 register new value.
  * @retval None
  */
void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
{
 800c474:	b480      	push	{r7}
 800c476:	b083      	sub	sp, #12
 800c478:	af00      	add	r7, sp, #0
 800c47a:	6078      	str	r0, [r7, #4]
 800c47c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 800c47e:	687b      	ldr	r3, [r7, #4]
 800c480:	683a      	ldr	r2, [r7, #0]
 800c482:	635a      	str	r2, [r3, #52]	; 0x34
}
 800c484:	f107 070c 	add.w	r7, r7, #12
 800c488:	46bd      	mov	sp, r7
 800c48a:	bc80      	pop	{r7}
 800c48c:	4770      	bx	lr
 800c48e:	bf00      	nop

0800c490 <TIM_SetCompare2>:
  *         peripheral.
  * @param  Compare2: specifies the Capture Compare2 register new value.
  * @retval None
  */
void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
{
 800c490:	b480      	push	{r7}
 800c492:	b083      	sub	sp, #12
 800c494:	af00      	add	r7, sp, #0
 800c496:	6078      	str	r0, [r7, #4]
 800c498:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 800c49a:	687b      	ldr	r3, [r7, #4]
 800c49c:	683a      	ldr	r2, [r7, #0]
 800c49e:	639a      	str	r2, [r3, #56]	; 0x38
}
 800c4a0:	f107 070c 	add.w	r7, r7, #12
 800c4a4:	46bd      	mov	sp, r7
 800c4a6:	bc80      	pop	{r7}
 800c4a8:	4770      	bx	lr
 800c4aa:	bf00      	nop

0800c4ac <TIM_SetCompare3>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare3: specifies the Capture Compare3 register new value.
  * @retval None
  */
void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
{
 800c4ac:	b480      	push	{r7}
 800c4ae:	b083      	sub	sp, #12
 800c4b0:	af00      	add	r7, sp, #0
 800c4b2:	6078      	str	r0, [r7, #4]
 800c4b4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 800c4b6:	687b      	ldr	r3, [r7, #4]
 800c4b8:	683a      	ldr	r2, [r7, #0]
 800c4ba:	63da      	str	r2, [r3, #60]	; 0x3c
}
 800c4bc:	f107 070c 	add.w	r7, r7, #12
 800c4c0:	46bd      	mov	sp, r7
 800c4c2:	bc80      	pop	{r7}
 800c4c4:	4770      	bx	lr
 800c4c6:	bf00      	nop

0800c4c8 <TIM_SetCompare4>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare4: specifies the Capture Compare4 register new value.
  * @retval None
  */
void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
{
 800c4c8:	b480      	push	{r7}
 800c4ca:	b083      	sub	sp, #12
 800c4cc:	af00      	add	r7, sp, #0
 800c4ce:	6078      	str	r0, [r7, #4]
 800c4d0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 800c4d2:	687b      	ldr	r3, [r7, #4]
 800c4d4:	683a      	ldr	r2, [r7, #0]
 800c4d6:	641a      	str	r2, [r3, #64]	; 0x40
}
 800c4d8:	f107 070c 	add.w	r7, r7, #12
 800c4dc:	46bd      	mov	sp, r7
 800c4de:	bc80      	pop	{r7}
 800c4e0:	4770      	bx	lr
 800c4e2:	bf00      	nop

0800c4e4 <TIM_ForcedOC1Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
  * @retval None
  */
void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 800c4e4:	b480      	push	{r7}
 800c4e6:	b085      	sub	sp, #20
 800c4e8:	af00      	add	r7, sp, #0
 800c4ea:	6078      	str	r0, [r7, #4]
 800c4ec:	460b      	mov	r3, r1
 800c4ee:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800c4f0:	f04f 0300 	mov.w	r3, #0
 800c4f4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 800c4f6:	687b      	ldr	r3, [r7, #4]
 800c4f8:	8b1b      	ldrh	r3, [r3, #24]
 800c4fa:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
 800c4fc:	89fb      	ldrh	r3, [r7, #14]
 800c4fe:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c502:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 800c504:	89fa      	ldrh	r2, [r7, #14]
 800c506:	887b      	ldrh	r3, [r7, #2]
 800c508:	4313      	orrs	r3, r2
 800c50a:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800c50c:	687b      	ldr	r3, [r7, #4]
 800c50e:	89fa      	ldrh	r2, [r7, #14]
 800c510:	831a      	strh	r2, [r3, #24]
}
 800c512:	f107 0714 	add.w	r7, r7, #20
 800c516:	46bd      	mov	sp, r7
 800c518:	bc80      	pop	{r7}
 800c51a:	4770      	bx	lr

0800c51c <TIM_ForcedOC2Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
  * @retval None
  */
void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 800c51c:	b480      	push	{r7}
 800c51e:	b085      	sub	sp, #20
 800c520:	af00      	add	r7, sp, #0
 800c522:	6078      	str	r0, [r7, #4]
 800c524:	460b      	mov	r3, r1
 800c526:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800c528:	f04f 0300 	mov.w	r3, #0
 800c52c:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 800c52e:	687b      	ldr	r3, [r7, #4]
 800c530:	8b1b      	ldrh	r3, [r3, #24]
 800c532:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
 800c534:	89fb      	ldrh	r3, [r7, #14]
 800c536:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800c53a:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
 800c53c:	887b      	ldrh	r3, [r7, #2]
 800c53e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c542:	b29a      	uxth	r2, r3
 800c544:	89fb      	ldrh	r3, [r7, #14]
 800c546:	4313      	orrs	r3, r2
 800c548:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800c54a:	687b      	ldr	r3, [r7, #4]
 800c54c:	89fa      	ldrh	r2, [r7, #14]
 800c54e:	831a      	strh	r2, [r3, #24]
}
 800c550:	f107 0714 	add.w	r7, r7, #20
 800c554:	46bd      	mov	sp, r7
 800c556:	bc80      	pop	{r7}
 800c558:	4770      	bx	lr
 800c55a:	bf00      	nop

0800c55c <TIM_ForcedOC3Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
  * @retval None
  */
void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 800c55c:	b480      	push	{r7}
 800c55e:	b085      	sub	sp, #20
 800c560:	af00      	add	r7, sp, #0
 800c562:	6078      	str	r0, [r7, #4]
 800c564:	460b      	mov	r3, r1
 800c566:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800c568:	f04f 0300 	mov.w	r3, #0
 800c56c:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));

  tmpccmr2 = TIMx->CCMR2;
 800c56e:	687b      	ldr	r3, [r7, #4]
 800c570:	8b9b      	ldrh	r3, [r3, #28]
 800c572:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
 800c574:	89fb      	ldrh	r3, [r7, #14]
 800c576:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c57a:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 800c57c:	89fa      	ldrh	r2, [r7, #14]
 800c57e:	887b      	ldrh	r3, [r7, #2]
 800c580:	4313      	orrs	r3, r2
 800c582:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800c584:	687b      	ldr	r3, [r7, #4]
 800c586:	89fa      	ldrh	r2, [r7, #14]
 800c588:	839a      	strh	r2, [r3, #28]
}
 800c58a:	f107 0714 	add.w	r7, r7, #20
 800c58e:	46bd      	mov	sp, r7
 800c590:	bc80      	pop	{r7}
 800c592:	4770      	bx	lr

0800c594 <TIM_ForcedOC4Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
  * @retval None
  */
void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 800c594:	b480      	push	{r7}
 800c596:	b085      	sub	sp, #20
 800c598:	af00      	add	r7, sp, #0
 800c59a:	6078      	str	r0, [r7, #4]
 800c59c:	460b      	mov	r3, r1
 800c59e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800c5a0:	f04f 0300 	mov.w	r3, #0
 800c5a4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 800c5a6:	687b      	ldr	r3, [r7, #4]
 800c5a8:	8b9b      	ldrh	r3, [r3, #28]
 800c5aa:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
 800c5ac:	89fb      	ldrh	r3, [r7, #14]
 800c5ae:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800c5b2:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
 800c5b4:	887b      	ldrh	r3, [r7, #2]
 800c5b6:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c5ba:	b29a      	uxth	r2, r3
 800c5bc:	89fb      	ldrh	r3, [r7, #14]
 800c5be:	4313      	orrs	r3, r2
 800c5c0:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800c5c2:	687b      	ldr	r3, [r7, #4]
 800c5c4:	89fa      	ldrh	r2, [r7, #14]
 800c5c6:	839a      	strh	r2, [r3, #28]
}
 800c5c8:	f107 0714 	add.w	r7, r7, #20
 800c5cc:	46bd      	mov	sp, r7
 800c5ce:	bc80      	pop	{r7}
 800c5d0:	4770      	bx	lr
 800c5d2:	bf00      	nop

0800c5d4 <TIM_OC1PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800c5d4:	b480      	push	{r7}
 800c5d6:	b085      	sub	sp, #20
 800c5d8:	af00      	add	r7, sp, #0
 800c5da:	6078      	str	r0, [r7, #4]
 800c5dc:	460b      	mov	r3, r1
 800c5de:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800c5e0:	f04f 0300 	mov.w	r3, #0
 800c5e4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 800c5e6:	687b      	ldr	r3, [r7, #4]
 800c5e8:	8b1b      	ldrh	r3, [r3, #24]
 800c5ea:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
 800c5ec:	89fb      	ldrh	r3, [r7, #14]
 800c5ee:	f023 0308 	bic.w	r3, r3, #8
 800c5f2:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 800c5f4:	89fa      	ldrh	r2, [r7, #14]
 800c5f6:	887b      	ldrh	r3, [r7, #2]
 800c5f8:	4313      	orrs	r3, r2
 800c5fa:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800c5fc:	687b      	ldr	r3, [r7, #4]
 800c5fe:	89fa      	ldrh	r2, [r7, #14]
 800c600:	831a      	strh	r2, [r3, #24]
}
 800c602:	f107 0714 	add.w	r7, r7, #20
 800c606:	46bd      	mov	sp, r7
 800c608:	bc80      	pop	{r7}
 800c60a:	4770      	bx	lr

0800c60c <TIM_OC2PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800c60c:	b480      	push	{r7}
 800c60e:	b085      	sub	sp, #20
 800c610:	af00      	add	r7, sp, #0
 800c612:	6078      	str	r0, [r7, #4]
 800c614:	460b      	mov	r3, r1
 800c616:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800c618:	f04f 0300 	mov.w	r3, #0
 800c61c:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 800c61e:	687b      	ldr	r3, [r7, #4]
 800c620:	8b1b      	ldrh	r3, [r3, #24]
 800c622:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
 800c624:	89fb      	ldrh	r3, [r7, #14]
 800c626:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800c62a:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 800c62c:	887b      	ldrh	r3, [r7, #2]
 800c62e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c632:	b29a      	uxth	r2, r3
 800c634:	89fb      	ldrh	r3, [r7, #14]
 800c636:	4313      	orrs	r3, r2
 800c638:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800c63a:	687b      	ldr	r3, [r7, #4]
 800c63c:	89fa      	ldrh	r2, [r7, #14]
 800c63e:	831a      	strh	r2, [r3, #24]
}
 800c640:	f107 0714 	add.w	r7, r7, #20
 800c644:	46bd      	mov	sp, r7
 800c646:	bc80      	pop	{r7}
 800c648:	4770      	bx	lr
 800c64a:	bf00      	nop

0800c64c <TIM_OC3PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800c64c:	b480      	push	{r7}
 800c64e:	b085      	sub	sp, #20
 800c650:	af00      	add	r7, sp, #0
 800c652:	6078      	str	r0, [r7, #4]
 800c654:	460b      	mov	r3, r1
 800c656:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800c658:	f04f 0300 	mov.w	r3, #0
 800c65c:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 800c65e:	687b      	ldr	r3, [r7, #4]
 800c660:	8b9b      	ldrh	r3, [r3, #28]
 800c662:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
 800c664:	89fb      	ldrh	r3, [r7, #14]
 800c666:	f023 0308 	bic.w	r3, r3, #8
 800c66a:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 800c66c:	89fa      	ldrh	r2, [r7, #14]
 800c66e:	887b      	ldrh	r3, [r7, #2]
 800c670:	4313      	orrs	r3, r2
 800c672:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800c674:	687b      	ldr	r3, [r7, #4]
 800c676:	89fa      	ldrh	r2, [r7, #14]
 800c678:	839a      	strh	r2, [r3, #28]
}
 800c67a:	f107 0714 	add.w	r7, r7, #20
 800c67e:	46bd      	mov	sp, r7
 800c680:	bc80      	pop	{r7}
 800c682:	4770      	bx	lr

0800c684 <TIM_OC4PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800c684:	b480      	push	{r7}
 800c686:	b085      	sub	sp, #20
 800c688:	af00      	add	r7, sp, #0
 800c68a:	6078      	str	r0, [r7, #4]
 800c68c:	460b      	mov	r3, r1
 800c68e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800c690:	f04f 0300 	mov.w	r3, #0
 800c694:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 800c696:	687b      	ldr	r3, [r7, #4]
 800c698:	8b9b      	ldrh	r3, [r3, #28]
 800c69a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
 800c69c:	89fb      	ldrh	r3, [r7, #14]
 800c69e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800c6a2:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
 800c6a4:	887b      	ldrh	r3, [r7, #2]
 800c6a6:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c6aa:	b29a      	uxth	r2, r3
 800c6ac:	89fb      	ldrh	r3, [r7, #14]
 800c6ae:	4313      	orrs	r3, r2
 800c6b0:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800c6b2:	687b      	ldr	r3, [r7, #4]
 800c6b4:	89fa      	ldrh	r2, [r7, #14]
 800c6b6:	839a      	strh	r2, [r3, #28]
}
 800c6b8:	f107 0714 	add.w	r7, r7, #20
 800c6bc:	46bd      	mov	sp, r7
 800c6be:	bc80      	pop	{r7}
 800c6c0:	4770      	bx	lr
 800c6c2:	bf00      	nop

0800c6c4 <TIM_OC1FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 800c6c4:	b480      	push	{r7}
 800c6c6:	b085      	sub	sp, #20
 800c6c8:	af00      	add	r7, sp, #0
 800c6ca:	6078      	str	r0, [r7, #4]
 800c6cc:	460b      	mov	r3, r1
 800c6ce:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800c6d0:	f04f 0300 	mov.w	r3, #0
 800c6d4:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 800c6d6:	687b      	ldr	r3, [r7, #4]
 800c6d8:	8b1b      	ldrh	r3, [r3, #24]
 800c6da:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
 800c6dc:	89fb      	ldrh	r3, [r7, #14]
 800c6de:	f023 0304 	bic.w	r3, r3, #4
 800c6e2:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 800c6e4:	89fa      	ldrh	r2, [r7, #14]
 800c6e6:	887b      	ldrh	r3, [r7, #2]
 800c6e8:	4313      	orrs	r3, r2
 800c6ea:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 800c6ec:	687b      	ldr	r3, [r7, #4]
 800c6ee:	89fa      	ldrh	r2, [r7, #14]
 800c6f0:	831a      	strh	r2, [r3, #24]
}
 800c6f2:	f107 0714 	add.w	r7, r7, #20
 800c6f6:	46bd      	mov	sp, r7
 800c6f8:	bc80      	pop	{r7}
 800c6fa:	4770      	bx	lr

0800c6fc <TIM_OC2FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 800c6fc:	b480      	push	{r7}
 800c6fe:	b085      	sub	sp, #20
 800c700:	af00      	add	r7, sp, #0
 800c702:	6078      	str	r0, [r7, #4]
 800c704:	460b      	mov	r3, r1
 800c706:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800c708:	f04f 0300 	mov.w	r3, #0
 800c70c:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 800c70e:	687b      	ldr	r3, [r7, #4]
 800c710:	8b1b      	ldrh	r3, [r3, #24]
 800c712:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
 800c714:	89fb      	ldrh	r3, [r7, #14]
 800c716:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800c71a:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
 800c71c:	887b      	ldrh	r3, [r7, #2]
 800c71e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c722:	b29a      	uxth	r2, r3
 800c724:	89fb      	ldrh	r3, [r7, #14]
 800c726:	4313      	orrs	r3, r2
 800c728:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 800c72a:	687b      	ldr	r3, [r7, #4]
 800c72c:	89fa      	ldrh	r2, [r7, #14]
 800c72e:	831a      	strh	r2, [r3, #24]
}
 800c730:	f107 0714 	add.w	r7, r7, #20
 800c734:	46bd      	mov	sp, r7
 800c736:	bc80      	pop	{r7}
 800c738:	4770      	bx	lr
 800c73a:	bf00      	nop

0800c73c <TIM_OC3FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 800c73c:	b480      	push	{r7}
 800c73e:	b085      	sub	sp, #20
 800c740:	af00      	add	r7, sp, #0
 800c742:	6078      	str	r0, [r7, #4]
 800c744:	460b      	mov	r3, r1
 800c746:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800c748:	f04f 0300 	mov.w	r3, #0
 800c74c:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 800c74e:	687b      	ldr	r3, [r7, #4]
 800c750:	8b9b      	ldrh	r3, [r3, #28]
 800c752:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
 800c754:	89fb      	ldrh	r3, [r7, #14]
 800c756:	f023 0304 	bic.w	r3, r3, #4
 800c75a:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 800c75c:	89fa      	ldrh	r2, [r7, #14]
 800c75e:	887b      	ldrh	r3, [r7, #2]
 800c760:	4313      	orrs	r3, r2
 800c762:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 800c764:	687b      	ldr	r3, [r7, #4]
 800c766:	89fa      	ldrh	r2, [r7, #14]
 800c768:	839a      	strh	r2, [r3, #28]
}
 800c76a:	f107 0714 	add.w	r7, r7, #20
 800c76e:	46bd      	mov	sp, r7
 800c770:	bc80      	pop	{r7}
 800c772:	4770      	bx	lr

0800c774 <TIM_OC4FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 800c774:	b480      	push	{r7}
 800c776:	b085      	sub	sp, #20
 800c778:	af00      	add	r7, sp, #0
 800c77a:	6078      	str	r0, [r7, #4]
 800c77c:	460b      	mov	r3, r1
 800c77e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800c780:	f04f 0300 	mov.w	r3, #0
 800c784:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 800c786:	687b      	ldr	r3, [r7, #4]
 800c788:	8b9b      	ldrh	r3, [r3, #28]
 800c78a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
 800c78c:	89fb      	ldrh	r3, [r7, #14]
 800c78e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800c792:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
 800c794:	887b      	ldrh	r3, [r7, #2]
 800c796:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c79a:	b29a      	uxth	r2, r3
 800c79c:	89fb      	ldrh	r3, [r7, #14]
 800c79e:	4313      	orrs	r3, r2
 800c7a0:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 800c7a2:	687b      	ldr	r3, [r7, #4]
 800c7a4:	89fa      	ldrh	r2, [r7, #14]
 800c7a6:	839a      	strh	r2, [r3, #28]
}
 800c7a8:	f107 0714 	add.w	r7, r7, #20
 800c7ac:	46bd      	mov	sp, r7
 800c7ae:	bc80      	pop	{r7}
 800c7b0:	4770      	bx	lr
 800c7b2:	bf00      	nop

0800c7b4 <TIM_ClearOC1Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 800c7b4:	b480      	push	{r7}
 800c7b6:	b085      	sub	sp, #20
 800c7b8:	af00      	add	r7, sp, #0
 800c7ba:	6078      	str	r0, [r7, #4]
 800c7bc:	460b      	mov	r3, r1
 800c7be:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800c7c0:	f04f 0300 	mov.w	r3, #0
 800c7c4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 800c7c6:	687b      	ldr	r3, [r7, #4]
 800c7c8:	8b1b      	ldrh	r3, [r3, #24]
 800c7ca:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
 800c7cc:	89fb      	ldrh	r3, [r7, #14]
 800c7ce:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800c7d2:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 800c7d4:	89fa      	ldrh	r2, [r7, #14]
 800c7d6:	887b      	ldrh	r3, [r7, #2]
 800c7d8:	4313      	orrs	r3, r2
 800c7da:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800c7dc:	687b      	ldr	r3, [r7, #4]
 800c7de:	89fa      	ldrh	r2, [r7, #14]
 800c7e0:	831a      	strh	r2, [r3, #24]
}
 800c7e2:	f107 0714 	add.w	r7, r7, #20
 800c7e6:	46bd      	mov	sp, r7
 800c7e8:	bc80      	pop	{r7}
 800c7ea:	4770      	bx	lr

0800c7ec <TIM_ClearOC2Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 800c7ec:	b480      	push	{r7}
 800c7ee:	b085      	sub	sp, #20
 800c7f0:	af00      	add	r7, sp, #0
 800c7f2:	6078      	str	r0, [r7, #4]
 800c7f4:	460b      	mov	r3, r1
 800c7f6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800c7f8:	f04f 0300 	mov.w	r3, #0
 800c7fc:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 800c7fe:	687b      	ldr	r3, [r7, #4]
 800c800:	8b1b      	ldrh	r3, [r3, #24]
 800c802:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
 800c804:	89fb      	ldrh	r3, [r7, #14]
 800c806:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800c80a:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800c80e:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 800c810:	887b      	ldrh	r3, [r7, #2]
 800c812:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c816:	b29a      	uxth	r2, r3
 800c818:	89fb      	ldrh	r3, [r7, #14]
 800c81a:	4313      	orrs	r3, r2
 800c81c:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800c81e:	687b      	ldr	r3, [r7, #4]
 800c820:	89fa      	ldrh	r2, [r7, #14]
 800c822:	831a      	strh	r2, [r3, #24]
}
 800c824:	f107 0714 	add.w	r7, r7, #20
 800c828:	46bd      	mov	sp, r7
 800c82a:	bc80      	pop	{r7}
 800c82c:	4770      	bx	lr
 800c82e:	bf00      	nop

0800c830 <TIM_ClearOC3Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 800c830:	b480      	push	{r7}
 800c832:	b085      	sub	sp, #20
 800c834:	af00      	add	r7, sp, #0
 800c836:	6078      	str	r0, [r7, #4]
 800c838:	460b      	mov	r3, r1
 800c83a:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800c83c:	f04f 0300 	mov.w	r3, #0
 800c840:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 800c842:	687b      	ldr	r3, [r7, #4]
 800c844:	8b9b      	ldrh	r3, [r3, #28]
 800c846:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
 800c848:	89fb      	ldrh	r3, [r7, #14]
 800c84a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800c84e:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 800c850:	89fa      	ldrh	r2, [r7, #14]
 800c852:	887b      	ldrh	r3, [r7, #2]
 800c854:	4313      	orrs	r3, r2
 800c856:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800c858:	687b      	ldr	r3, [r7, #4]
 800c85a:	89fa      	ldrh	r2, [r7, #14]
 800c85c:	839a      	strh	r2, [r3, #28]
}
 800c85e:	f107 0714 	add.w	r7, r7, #20
 800c862:	46bd      	mov	sp, r7
 800c864:	bc80      	pop	{r7}
 800c866:	4770      	bx	lr

0800c868 <TIM_ClearOC4Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 800c868:	b480      	push	{r7}
 800c86a:	b085      	sub	sp, #20
 800c86c:	af00      	add	r7, sp, #0
 800c86e:	6078      	str	r0, [r7, #4]
 800c870:	460b      	mov	r3, r1
 800c872:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800c874:	f04f 0300 	mov.w	r3, #0
 800c878:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 800c87a:	687b      	ldr	r3, [r7, #4]
 800c87c:	8b9b      	ldrh	r3, [r3, #28]
 800c87e:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
 800c880:	89fb      	ldrh	r3, [r7, #14]
 800c882:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800c886:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800c88a:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 800c88c:	887b      	ldrh	r3, [r7, #2]
 800c88e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c892:	b29a      	uxth	r2, r3
 800c894:	89fb      	ldrh	r3, [r7, #14]
 800c896:	4313      	orrs	r3, r2
 800c898:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800c89a:	687b      	ldr	r3, [r7, #4]
 800c89c:	89fa      	ldrh	r2, [r7, #14]
 800c89e:	839a      	strh	r2, [r3, #28]
}
 800c8a0:	f107 0714 	add.w	r7, r7, #20
 800c8a4:	46bd      	mov	sp, r7
 800c8a6:	bc80      	pop	{r7}
 800c8a8:	4770      	bx	lr
 800c8aa:	bf00      	nop

0800c8ac <TIM_OC1PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 800c8ac:	b480      	push	{r7}
 800c8ae:	b085      	sub	sp, #20
 800c8b0:	af00      	add	r7, sp, #0
 800c8b2:	6078      	str	r0, [r7, #4]
 800c8b4:	460b      	mov	r3, r1
 800c8b6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800c8b8:	f04f 0300 	mov.w	r3, #0
 800c8bc:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800c8be:	687b      	ldr	r3, [r7, #4]
 800c8c0:	8c1b      	ldrh	r3, [r3, #32]
 800c8c2:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
 800c8c4:	89fb      	ldrh	r3, [r7, #14]
 800c8c6:	f023 0302 	bic.w	r3, r3, #2
 800c8ca:	81fb      	strh	r3, [r7, #14]
  tmpccer |= TIM_OCPolarity;
 800c8cc:	89fa      	ldrh	r2, [r7, #14]
 800c8ce:	887b      	ldrh	r3, [r7, #2]
 800c8d0:	4313      	orrs	r3, r2
 800c8d2:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800c8d4:	687b      	ldr	r3, [r7, #4]
 800c8d6:	89fa      	ldrh	r2, [r7, #14]
 800c8d8:	841a      	strh	r2, [r3, #32]
}
 800c8da:	f107 0714 	add.w	r7, r7, #20
 800c8de:	46bd      	mov	sp, r7
 800c8e0:	bc80      	pop	{r7}
 800c8e2:	4770      	bx	lr

0800c8e4 <TIM_OC1NPolarityConfig>:
  *            @arg TIM_OCNPolarity_High: Output Compare active high
  *            @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
 800c8e4:	b480      	push	{r7}
 800c8e6:	b085      	sub	sp, #20
 800c8e8:	af00      	add	r7, sp, #0
 800c8ea:	6078      	str	r0, [r7, #4]
 800c8ec:	460b      	mov	r3, r1
 800c8ee:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800c8f0:	f04f 0300 	mov.w	r3, #0
 800c8f4:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 800c8f6:	687b      	ldr	r3, [r7, #4]
 800c8f8:	8c1b      	ldrh	r3, [r3, #32]
 800c8fa:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 800c8fc:	89fb      	ldrh	r3, [r7, #14]
 800c8fe:	f023 0308 	bic.w	r3, r3, #8
 800c902:	81fb      	strh	r3, [r7, #14]
  tmpccer |= TIM_OCNPolarity;
 800c904:	89fa      	ldrh	r2, [r7, #14]
 800c906:	887b      	ldrh	r3, [r7, #2]
 800c908:	4313      	orrs	r3, r2
 800c90a:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800c90c:	687b      	ldr	r3, [r7, #4]
 800c90e:	89fa      	ldrh	r2, [r7, #14]
 800c910:	841a      	strh	r2, [r3, #32]
}
 800c912:	f107 0714 	add.w	r7, r7, #20
 800c916:	46bd      	mov	sp, r7
 800c918:	bc80      	pop	{r7}
 800c91a:	4770      	bx	lr

0800c91c <TIM_OC2PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 800c91c:	b480      	push	{r7}
 800c91e:	b085      	sub	sp, #20
 800c920:	af00      	add	r7, sp, #0
 800c922:	6078      	str	r0, [r7, #4]
 800c924:	460b      	mov	r3, r1
 800c926:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800c928:	f04f 0300 	mov.w	r3, #0
 800c92c:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800c92e:	687b      	ldr	r3, [r7, #4]
 800c930:	8c1b      	ldrh	r3, [r3, #32]
 800c932:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
 800c934:	89fb      	ldrh	r3, [r7, #14]
 800c936:	f023 0320 	bic.w	r3, r3, #32
 800c93a:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
 800c93c:	887b      	ldrh	r3, [r7, #2]
 800c93e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800c942:	b29a      	uxth	r2, r3
 800c944:	89fb      	ldrh	r3, [r7, #14]
 800c946:	4313      	orrs	r3, r2
 800c948:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800c94a:	687b      	ldr	r3, [r7, #4]
 800c94c:	89fa      	ldrh	r2, [r7, #14]
 800c94e:	841a      	strh	r2, [r3, #32]
}
 800c950:	f107 0714 	add.w	r7, r7, #20
 800c954:	46bd      	mov	sp, r7
 800c956:	bc80      	pop	{r7}
 800c958:	4770      	bx	lr
 800c95a:	bf00      	nop

0800c95c <TIM_OC2NPolarityConfig>:
  *            @arg TIM_OCNPolarity_High: Output Compare active high
  *            @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
 800c95c:	b480      	push	{r7}
 800c95e:	b085      	sub	sp, #20
 800c960:	af00      	add	r7, sp, #0
 800c962:	6078      	str	r0, [r7, #4]
 800c964:	460b      	mov	r3, r1
 800c966:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800c968:	f04f 0300 	mov.w	r3, #0
 800c96c:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 800c96e:	687b      	ldr	r3, [r7, #4]
 800c970:	8c1b      	ldrh	r3, [r3, #32]
 800c972:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 800c974:	89fb      	ldrh	r3, [r7, #14]
 800c976:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800c97a:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
 800c97c:	887b      	ldrh	r3, [r7, #2]
 800c97e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800c982:	b29a      	uxth	r2, r3
 800c984:	89fb      	ldrh	r3, [r7, #14]
 800c986:	4313      	orrs	r3, r2
 800c988:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800c98a:	687b      	ldr	r3, [r7, #4]
 800c98c:	89fa      	ldrh	r2, [r7, #14]
 800c98e:	841a      	strh	r2, [r3, #32]
}
 800c990:	f107 0714 	add.w	r7, r7, #20
 800c994:	46bd      	mov	sp, r7
 800c996:	bc80      	pop	{r7}
 800c998:	4770      	bx	lr
 800c99a:	bf00      	nop

0800c99c <TIM_OC3PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 800c99c:	b480      	push	{r7}
 800c99e:	b085      	sub	sp, #20
 800c9a0:	af00      	add	r7, sp, #0
 800c9a2:	6078      	str	r0, [r7, #4]
 800c9a4:	460b      	mov	r3, r1
 800c9a6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800c9a8:	f04f 0300 	mov.w	r3, #0
 800c9ac:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800c9ae:	687b      	ldr	r3, [r7, #4]
 800c9b0:	8c1b      	ldrh	r3, [r3, #32]
 800c9b2:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 800c9b4:	89fb      	ldrh	r3, [r7, #14]
 800c9b6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800c9ba:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
 800c9bc:	887b      	ldrh	r3, [r7, #2]
 800c9be:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c9c2:	b29a      	uxth	r2, r3
 800c9c4:	89fb      	ldrh	r3, [r7, #14]
 800c9c6:	4313      	orrs	r3, r2
 800c9c8:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800c9ca:	687b      	ldr	r3, [r7, #4]
 800c9cc:	89fa      	ldrh	r2, [r7, #14]
 800c9ce:	841a      	strh	r2, [r3, #32]
}
 800c9d0:	f107 0714 	add.w	r7, r7, #20
 800c9d4:	46bd      	mov	sp, r7
 800c9d6:	bc80      	pop	{r7}
 800c9d8:	4770      	bx	lr
 800c9da:	bf00      	nop

0800c9dc <TIM_OC3NPolarityConfig>:
  *            @arg TIM_OCNPolarity_High: Output Compare active high
  *            @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
 800c9dc:	b480      	push	{r7}
 800c9de:	b085      	sub	sp, #20
 800c9e0:	af00      	add	r7, sp, #0
 800c9e2:	6078      	str	r0, [r7, #4]
 800c9e4:	460b      	mov	r3, r1
 800c9e6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800c9e8:	f04f 0300 	mov.w	r3, #0
 800c9ec:	81fb      	strh	r3, [r7, #14]
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 800c9ee:	687b      	ldr	r3, [r7, #4]
 800c9f0:	8c1b      	ldrh	r3, [r3, #32]
 800c9f2:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 800c9f4:	89fb      	ldrh	r3, [r7, #14]
 800c9f6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800c9fa:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
 800c9fc:	887b      	ldrh	r3, [r7, #2]
 800c9fe:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800ca02:	b29a      	uxth	r2, r3
 800ca04:	89fb      	ldrh	r3, [r7, #14]
 800ca06:	4313      	orrs	r3, r2
 800ca08:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800ca0a:	687b      	ldr	r3, [r7, #4]
 800ca0c:	89fa      	ldrh	r2, [r7, #14]
 800ca0e:	841a      	strh	r2, [r3, #32]
}
 800ca10:	f107 0714 	add.w	r7, r7, #20
 800ca14:	46bd      	mov	sp, r7
 800ca16:	bc80      	pop	{r7}
 800ca18:	4770      	bx	lr
 800ca1a:	bf00      	nop

0800ca1c <TIM_OC4PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 800ca1c:	b480      	push	{r7}
 800ca1e:	b085      	sub	sp, #20
 800ca20:	af00      	add	r7, sp, #0
 800ca22:	6078      	str	r0, [r7, #4]
 800ca24:	460b      	mov	r3, r1
 800ca26:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800ca28:	f04f 0300 	mov.w	r3, #0
 800ca2c:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800ca2e:	687b      	ldr	r3, [r7, #4]
 800ca30:	8c1b      	ldrh	r3, [r3, #32]
 800ca32:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 800ca34:	89fb      	ldrh	r3, [r7, #14]
 800ca36:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800ca3a:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
 800ca3c:	887b      	ldrh	r3, [r7, #2]
 800ca3e:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800ca42:	b29a      	uxth	r2, r3
 800ca44:	89fb      	ldrh	r3, [r7, #14]
 800ca46:	4313      	orrs	r3, r2
 800ca48:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800ca4a:	687b      	ldr	r3, [r7, #4]
 800ca4c:	89fa      	ldrh	r2, [r7, #14]
 800ca4e:	841a      	strh	r2, [r3, #32]
}
 800ca50:	f107 0714 	add.w	r7, r7, #20
 800ca54:	46bd      	mov	sp, r7
 800ca56:	bc80      	pop	{r7}
 800ca58:	4770      	bx	lr
 800ca5a:	bf00      	nop

0800ca5c <TIM_CCxCmd>:
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 800ca5c:	b480      	push	{r7}
 800ca5e:	b085      	sub	sp, #20
 800ca60:	af00      	add	r7, sp, #0
 800ca62:	6078      	str	r0, [r7, #4]
 800ca64:	4613      	mov	r3, r2
 800ca66:	460a      	mov	r2, r1
 800ca68:	807a      	strh	r2, [r7, #2]
 800ca6a:	803b      	strh	r3, [r7, #0]
  uint16_t tmp = 0;
 800ca6c:	f04f 0300 	mov.w	r3, #0
 800ca70:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;
 800ca72:	887b      	ldrh	r3, [r7, #2]
 800ca74:	f04f 0201 	mov.w	r2, #1
 800ca78:	fa02 f303 	lsl.w	r3, r2, r3
 800ca7c:	81fb      	strh	r3, [r7, #14]

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 800ca7e:	687b      	ldr	r3, [r7, #4]
 800ca80:	8c1b      	ldrh	r3, [r3, #32]
 800ca82:	b29a      	uxth	r2, r3
 800ca84:	89fb      	ldrh	r3, [r7, #14]
 800ca86:	ea6f 0303 	mvn.w	r3, r3
 800ca8a:	b29b      	uxth	r3, r3
 800ca8c:	4013      	ands	r3, r2
 800ca8e:	b29a      	uxth	r2, r3
 800ca90:	687b      	ldr	r3, [r7, #4]
 800ca92:	841a      	strh	r2, [r3, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 800ca94:	687b      	ldr	r3, [r7, #4]
 800ca96:	8c1b      	ldrh	r3, [r3, #32]
 800ca98:	b29a      	uxth	r2, r3
 800ca9a:	8839      	ldrh	r1, [r7, #0]
 800ca9c:	887b      	ldrh	r3, [r7, #2]
 800ca9e:	fa01 f303 	lsl.w	r3, r1, r3
 800caa2:	b29b      	uxth	r3, r3
 800caa4:	4313      	orrs	r3, r2
 800caa6:	b29a      	uxth	r2, r3
 800caa8:	687b      	ldr	r3, [r7, #4]
 800caaa:	841a      	strh	r2, [r3, #32]
}
 800caac:	f107 0714 	add.w	r7, r7, #20
 800cab0:	46bd      	mov	sp, r7
 800cab2:	bc80      	pop	{r7}
 800cab4:	4770      	bx	lr
 800cab6:	bf00      	nop

0800cab8 <TIM_CCxNCmd>:
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 800cab8:	b480      	push	{r7}
 800caba:	b085      	sub	sp, #20
 800cabc:	af00      	add	r7, sp, #0
 800cabe:	6078      	str	r0, [r7, #4]
 800cac0:	4613      	mov	r3, r2
 800cac2:	460a      	mov	r2, r1
 800cac4:	807a      	strh	r2, [r7, #2]
 800cac6:	803b      	strh	r3, [r7, #0]
  uint16_t tmp = 0;
 800cac8:	f04f 0300 	mov.w	r3, #0
 800cacc:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;
 800cace:	887b      	ldrh	r3, [r7, #2]
 800cad0:	f04f 0204 	mov.w	r2, #4
 800cad4:	fa02 f303 	lsl.w	r3, r2, r3
 800cad8:	81fb      	strh	r3, [r7, #14]

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 800cada:	687b      	ldr	r3, [r7, #4]
 800cadc:	8c1b      	ldrh	r3, [r3, #32]
 800cade:	b29a      	uxth	r2, r3
 800cae0:	89fb      	ldrh	r3, [r7, #14]
 800cae2:	ea6f 0303 	mvn.w	r3, r3
 800cae6:	b29b      	uxth	r3, r3
 800cae8:	4013      	ands	r3, r2
 800caea:	b29a      	uxth	r2, r3
 800caec:	687b      	ldr	r3, [r7, #4]
 800caee:	841a      	strh	r2, [r3, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 800caf0:	687b      	ldr	r3, [r7, #4]
 800caf2:	8c1b      	ldrh	r3, [r3, #32]
 800caf4:	b29a      	uxth	r2, r3
 800caf6:	8839      	ldrh	r1, [r7, #0]
 800caf8:	887b      	ldrh	r3, [r7, #2]
 800cafa:	fa01 f303 	lsl.w	r3, r1, r3
 800cafe:	b29b      	uxth	r3, r3
 800cb00:	4313      	orrs	r3, r2
 800cb02:	b29a      	uxth	r2, r3
 800cb04:	687b      	ldr	r3, [r7, #4]
 800cb06:	841a      	strh	r2, [r3, #32]
}
 800cb08:	f107 0714 	add.w	r7, r7, #20
 800cb0c:	46bd      	mov	sp, r7
 800cb0e:	bc80      	pop	{r7}
 800cb10:	4770      	bx	lr
 800cb12:	bf00      	nop

0800cb14 <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 800cb14:	b580      	push	{r7, lr}
 800cb16:	b082      	sub	sp, #8
 800cb18:	af00      	add	r7, sp, #0
 800cb1a:	6078      	str	r0, [r7, #4]
 800cb1c:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 800cb1e:	683b      	ldr	r3, [r7, #0]
 800cb20:	881b      	ldrh	r3, [r3, #0]
 800cb22:	2b00      	cmp	r3, #0
 800cb24:	d10f      	bne.n	800cb46 <TIM_ICInit+0x32>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800cb26:	683b      	ldr	r3, [r7, #0]
 800cb28:	8859      	ldrh	r1, [r3, #2]
               TIM_ICInitStruct->TIM_ICSelection,
 800cb2a:	683b      	ldr	r3, [r7, #0]
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800cb2c:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
 800cb2e:	683b      	ldr	r3, [r7, #0]
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800cb30:	891b      	ldrh	r3, [r3, #8]
 800cb32:	6878      	ldr	r0, [r7, #4]
 800cb34:	f000 fcc4 	bl	800d4c0 <TI1_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800cb38:	683b      	ldr	r3, [r7, #0]
 800cb3a:	88db      	ldrh	r3, [r3, #6]
 800cb3c:	6878      	ldr	r0, [r7, #4]
 800cb3e:	4619      	mov	r1, r3
 800cb40:	f000 f8ec 	bl	800cd1c <TIM_SetIC1Prescaler>
 800cb44:	e036      	b.n	800cbb4 <TIM_ICInit+0xa0>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 800cb46:	683b      	ldr	r3, [r7, #0]
 800cb48:	881b      	ldrh	r3, [r3, #0]
 800cb4a:	2b04      	cmp	r3, #4
 800cb4c:	d10f      	bne.n	800cb6e <TIM_ICInit+0x5a>
  {
    /* TI2 Configuration */
    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800cb4e:	683b      	ldr	r3, [r7, #0]
 800cb50:	8859      	ldrh	r1, [r3, #2]
               TIM_ICInitStruct->TIM_ICSelection,
 800cb52:	683b      	ldr	r3, [r7, #0]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
  {
    /* TI2 Configuration */
    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800cb54:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
 800cb56:	683b      	ldr	r3, [r7, #0]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
  {
    /* TI2 Configuration */
    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800cb58:	891b      	ldrh	r3, [r3, #8]
 800cb5a:	6878      	ldr	r0, [r7, #4]
 800cb5c:	f000 fcf0 	bl	800d540 <TI2_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800cb60:	683b      	ldr	r3, [r7, #0]
 800cb62:	88db      	ldrh	r3, [r3, #6]
 800cb64:	6878      	ldr	r0, [r7, #4]
 800cb66:	4619      	mov	r1, r3
 800cb68:	f000 f8f4 	bl	800cd54 <TIM_SetIC2Prescaler>
 800cb6c:	e022      	b.n	800cbb4 <TIM_ICInit+0xa0>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 800cb6e:	683b      	ldr	r3, [r7, #0]
 800cb70:	881b      	ldrh	r3, [r3, #0]
 800cb72:	2b08      	cmp	r3, #8
 800cb74:	d10f      	bne.n	800cb96 <TIM_ICInit+0x82>
  {
    /* TI3 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 800cb76:	683b      	ldr	r3, [r7, #0]
 800cb78:	8859      	ldrh	r1, [r3, #2]
               TIM_ICInitStruct->TIM_ICSelection,
 800cb7a:	683b      	ldr	r3, [r7, #0]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
  {
    /* TI3 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 800cb7c:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
 800cb7e:	683b      	ldr	r3, [r7, #0]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
  {
    /* TI3 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 800cb80:	891b      	ldrh	r3, [r3, #8]
 800cb82:	6878      	ldr	r0, [r7, #4]
 800cb84:	f000 fd2a 	bl	800d5dc <TI3_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800cb88:	683b      	ldr	r3, [r7, #0]
 800cb8a:	88db      	ldrh	r3, [r3, #6]
 800cb8c:	6878      	ldr	r0, [r7, #4]
 800cb8e:	4619      	mov	r1, r3
 800cb90:	f000 f8fe 	bl	800cd90 <TIM_SetIC3Prescaler>
 800cb94:	e00e      	b.n	800cbb4 <TIM_ICInit+0xa0>
  }
  else
  {
    /* TI4 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800cb96:	683b      	ldr	r3, [r7, #0]
 800cb98:	8859      	ldrh	r1, [r3, #2]
               TIM_ICInitStruct->TIM_ICSelection,
 800cb9a:	683b      	ldr	r3, [r7, #0]
  }
  else
  {
    /* TI4 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800cb9c:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
 800cb9e:	683b      	ldr	r3, [r7, #0]
  }
  else
  {
    /* TI4 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800cba0:	891b      	ldrh	r3, [r3, #8]
 800cba2:	6878      	ldr	r0, [r7, #4]
 800cba4:	f000 fd60 	bl	800d668 <TI4_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800cba8:	683b      	ldr	r3, [r7, #0]
 800cbaa:	88db      	ldrh	r3, [r3, #6]
 800cbac:	6878      	ldr	r0, [r7, #4]
 800cbae:	4619      	mov	r1, r3
 800cbb0:	f000 f90a 	bl	800cdc8 <TIM_SetIC4Prescaler>
  }
}
 800cbb4:	f107 0708 	add.w	r7, r7, #8
 800cbb8:	46bd      	mov	sp, r7
 800cbba:	bd80      	pop	{r7, pc}

0800cbbc <TIM_ICStructInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 800cbbc:	b480      	push	{r7}
 800cbbe:	b083      	sub	sp, #12
 800cbc0:	af00      	add	r7, sp, #0
 800cbc2:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 800cbc4:	687b      	ldr	r3, [r7, #4]
 800cbc6:	f04f 0200 	mov.w	r2, #0
 800cbca:	801a      	strh	r2, [r3, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 800cbcc:	687b      	ldr	r3, [r7, #4]
 800cbce:	f04f 0200 	mov.w	r2, #0
 800cbd2:	805a      	strh	r2, [r3, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 800cbd4:	687b      	ldr	r3, [r7, #4]
 800cbd6:	f04f 0201 	mov.w	r2, #1
 800cbda:	809a      	strh	r2, [r3, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 800cbdc:	687b      	ldr	r3, [r7, #4]
 800cbde:	f04f 0200 	mov.w	r2, #0
 800cbe2:	80da      	strh	r2, [r3, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 800cbe4:	687b      	ldr	r3, [r7, #4]
 800cbe6:	f04f 0200 	mov.w	r2, #0
 800cbea:	811a      	strh	r2, [r3, #8]
}
 800cbec:	f107 070c 	add.w	r7, r7, #12
 800cbf0:	46bd      	mov	sp, r7
 800cbf2:	bc80      	pop	{r7}
 800cbf4:	4770      	bx	lr
 800cbf6:	bf00      	nop

0800cbf8 <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 800cbf8:	b580      	push	{r7, lr}
 800cbfa:	b084      	sub	sp, #16
 800cbfc:	af00      	add	r7, sp, #0
 800cbfe:	6078      	str	r0, [r7, #4]
 800cc00:	6039      	str	r1, [r7, #0]
  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
 800cc02:	f04f 0300 	mov.w	r3, #0
 800cc06:	81fb      	strh	r3, [r7, #14]
  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
 800cc08:	f04f 0301 	mov.w	r3, #1
 800cc0c:	81bb      	strh	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 800cc0e:	683b      	ldr	r3, [r7, #0]
 800cc10:	885b      	ldrh	r3, [r3, #2]
 800cc12:	2b00      	cmp	r3, #0
 800cc14:	d103      	bne.n	800cc1e <TIM_PWMIConfig+0x26>
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
 800cc16:	f04f 0302 	mov.w	r3, #2
 800cc1a:	81fb      	strh	r3, [r7, #14]
 800cc1c:	e002      	b.n	800cc24 <TIM_PWMIConfig+0x2c>
  }
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
 800cc1e:	f04f 0300 	mov.w	r3, #0
 800cc22:	81fb      	strh	r3, [r7, #14]
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 800cc24:	683b      	ldr	r3, [r7, #0]
 800cc26:	889b      	ldrh	r3, [r3, #4]
 800cc28:	2b01      	cmp	r3, #1
 800cc2a:	d103      	bne.n	800cc34 <TIM_PWMIConfig+0x3c>
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
 800cc2c:	f04f 0302 	mov.w	r3, #2
 800cc30:	81bb      	strh	r3, [r7, #12]
 800cc32:	e002      	b.n	800cc3a <TIM_PWMIConfig+0x42>
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
 800cc34:	f04f 0301 	mov.w	r3, #1
 800cc38:	81bb      	strh	r3, [r7, #12]
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 800cc3a:	683b      	ldr	r3, [r7, #0]
 800cc3c:	881b      	ldrh	r3, [r3, #0]
 800cc3e:	2b00      	cmp	r3, #0
 800cc40:	d11c      	bne.n	800cc7c <TIM_PWMIConfig+0x84>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800cc42:	683b      	ldr	r3, [r7, #0]
 800cc44:	8859      	ldrh	r1, [r3, #2]
 800cc46:	683b      	ldr	r3, [r7, #0]
 800cc48:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICFilter);
 800cc4a:	683b      	ldr	r3, [r7, #0]
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800cc4c:	891b      	ldrh	r3, [r3, #8]
 800cc4e:	6878      	ldr	r0, [r7, #4]
 800cc50:	f000 fc36 	bl	800d4c0 <TI1_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800cc54:	683b      	ldr	r3, [r7, #0]
 800cc56:	88db      	ldrh	r3, [r3, #6]
 800cc58:	6878      	ldr	r0, [r7, #4]
 800cc5a:	4619      	mov	r1, r3
 800cc5c:	f000 f85e 	bl	800cd1c <TIM_SetIC1Prescaler>
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 800cc60:	683b      	ldr	r3, [r7, #0]
 800cc62:	891b      	ldrh	r3, [r3, #8]
 800cc64:	89f9      	ldrh	r1, [r7, #14]
 800cc66:	89ba      	ldrh	r2, [r7, #12]
 800cc68:	6878      	ldr	r0, [r7, #4]
 800cc6a:	f000 fc69 	bl	800d540 <TI2_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800cc6e:	683b      	ldr	r3, [r7, #0]
 800cc70:	88db      	ldrh	r3, [r3, #6]
 800cc72:	6878      	ldr	r0, [r7, #4]
 800cc74:	4619      	mov	r1, r3
 800cc76:	f000 f86d 	bl	800cd54 <TIM_SetIC2Prescaler>
 800cc7a:	e01b      	b.n	800ccb4 <TIM_PWMIConfig+0xbc>
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800cc7c:	683b      	ldr	r3, [r7, #0]
 800cc7e:	8859      	ldrh	r1, [r3, #2]
 800cc80:	683b      	ldr	r3, [r7, #0]
 800cc82:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICFilter);
 800cc84:	683b      	ldr	r3, [r7, #0]
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800cc86:	891b      	ldrh	r3, [r3, #8]
 800cc88:	6878      	ldr	r0, [r7, #4]
 800cc8a:	f000 fc59 	bl	800d540 <TI2_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800cc8e:	683b      	ldr	r3, [r7, #0]
 800cc90:	88db      	ldrh	r3, [r3, #6]
 800cc92:	6878      	ldr	r0, [r7, #4]
 800cc94:	4619      	mov	r1, r3
 800cc96:	f000 f85d 	bl	800cd54 <TIM_SetIC2Prescaler>
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 800cc9a:	683b      	ldr	r3, [r7, #0]
 800cc9c:	891b      	ldrh	r3, [r3, #8]
 800cc9e:	89f9      	ldrh	r1, [r7, #14]
 800cca0:	89ba      	ldrh	r2, [r7, #12]
 800cca2:	6878      	ldr	r0, [r7, #4]
 800cca4:	f000 fc0c 	bl	800d4c0 <TI1_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800cca8:	683b      	ldr	r3, [r7, #0]
 800ccaa:	88db      	ldrh	r3, [r3, #6]
 800ccac:	6878      	ldr	r0, [r7, #4]
 800ccae:	4619      	mov	r1, r3
 800ccb0:	f000 f834 	bl	800cd1c <TIM_SetIC1Prescaler>
  }
}
 800ccb4:	f107 0710 	add.w	r7, r7, #16
 800ccb8:	46bd      	mov	sp, r7
 800ccba:	bd80      	pop	{r7, pc}

0800ccbc <TIM_GetCapture1>:
  * @brief  Gets the TIMx Input Capture 1 value.
  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
  * @retval Capture Compare 1 Register value.
  */
uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
{
 800ccbc:	b480      	push	{r7}
 800ccbe:	b083      	sub	sp, #12
 800ccc0:	af00      	add	r7, sp, #0
 800ccc2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 800ccc4:	687b      	ldr	r3, [r7, #4]
 800ccc6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 800ccc8:	4618      	mov	r0, r3
 800ccca:	f107 070c 	add.w	r7, r7, #12
 800ccce:	46bd      	mov	sp, r7
 800ccd0:	bc80      	pop	{r7}
 800ccd2:	4770      	bx	lr

0800ccd4 <TIM_GetCapture2>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
  *         peripheral.
  * @retval Capture Compare 2 Register value.
  */
uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
{
 800ccd4:	b480      	push	{r7}
 800ccd6:	b083      	sub	sp, #12
 800ccd8:	af00      	add	r7, sp, #0
 800ccda:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 800ccdc:	687b      	ldr	r3, [r7, #4]
 800ccde:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 800cce0:	4618      	mov	r0, r3
 800cce2:	f107 070c 	add.w	r7, r7, #12
 800cce6:	46bd      	mov	sp, r7
 800cce8:	bc80      	pop	{r7}
 800ccea:	4770      	bx	lr

0800ccec <TIM_GetCapture3>:
  * @brief  Gets the TIMx Input Capture 3 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 3 Register value.
  */
uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
{
 800ccec:	b480      	push	{r7}
 800ccee:	b083      	sub	sp, #12
 800ccf0:	af00      	add	r7, sp, #0
 800ccf2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 

  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 800ccf4:	687b      	ldr	r3, [r7, #4]
 800ccf6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}
 800ccf8:	4618      	mov	r0, r3
 800ccfa:	f107 070c 	add.w	r7, r7, #12
 800ccfe:	46bd      	mov	sp, r7
 800cd00:	bc80      	pop	{r7}
 800cd02:	4770      	bx	lr

0800cd04 <TIM_GetCapture4>:
  * @brief  Gets the TIMx Input Capture 4 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 4 Register value.
  */
uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
{
 800cd04:	b480      	push	{r7}
 800cd06:	b083      	sub	sp, #12
 800cd08:	af00      	add	r7, sp, #0
 800cd0a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 800cd0c:	687b      	ldr	r3, [r7, #4]
 800cd0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 800cd10:	4618      	mov	r0, r3
 800cd12:	f107 070c 	add.w	r7, r7, #12
 800cd16:	46bd      	mov	sp, r7
 800cd18:	bc80      	pop	{r7}
 800cd1a:	4770      	bx	lr

0800cd1c <TIM_SetIC1Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 800cd1c:	b480      	push	{r7}
 800cd1e:	b083      	sub	sp, #12
 800cd20:	af00      	add	r7, sp, #0
 800cd22:	6078      	str	r0, [r7, #4]
 800cd24:	460b      	mov	r3, r1
 800cd26:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
 800cd28:	687b      	ldr	r3, [r7, #4]
 800cd2a:	8b1b      	ldrh	r3, [r3, #24]
 800cd2c:	b29b      	uxth	r3, r3
 800cd2e:	f023 030c 	bic.w	r3, r3, #12
 800cd32:	b29a      	uxth	r2, r3
 800cd34:	687b      	ldr	r3, [r7, #4]
 800cd36:	831a      	strh	r2, [r3, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 800cd38:	687b      	ldr	r3, [r7, #4]
 800cd3a:	8b1b      	ldrh	r3, [r3, #24]
 800cd3c:	b29a      	uxth	r2, r3
 800cd3e:	887b      	ldrh	r3, [r7, #2]
 800cd40:	4313      	orrs	r3, r2
 800cd42:	b29a      	uxth	r2, r3
 800cd44:	687b      	ldr	r3, [r7, #4]
 800cd46:	831a      	strh	r2, [r3, #24]
}
 800cd48:	f107 070c 	add.w	r7, r7, #12
 800cd4c:	46bd      	mov	sp, r7
 800cd4e:	bc80      	pop	{r7}
 800cd50:	4770      	bx	lr
 800cd52:	bf00      	nop

0800cd54 <TIM_SetIC2Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 800cd54:	b480      	push	{r7}
 800cd56:	b083      	sub	sp, #12
 800cd58:	af00      	add	r7, sp, #0
 800cd5a:	6078      	str	r0, [r7, #4]
 800cd5c:	460b      	mov	r3, r1
 800cd5e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
 800cd60:	687b      	ldr	r3, [r7, #4]
 800cd62:	8b1b      	ldrh	r3, [r3, #24]
 800cd64:	b29b      	uxth	r3, r3
 800cd66:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800cd6a:	b29a      	uxth	r2, r3
 800cd6c:	687b      	ldr	r3, [r7, #4]
 800cd6e:	831a      	strh	r2, [r3, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 800cd70:	687b      	ldr	r3, [r7, #4]
 800cd72:	8b1b      	ldrh	r3, [r3, #24]
 800cd74:	b29a      	uxth	r2, r3
 800cd76:	887b      	ldrh	r3, [r7, #2]
 800cd78:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cd7c:	b29b      	uxth	r3, r3
 800cd7e:	4313      	orrs	r3, r2
 800cd80:	b29a      	uxth	r2, r3
 800cd82:	687b      	ldr	r3, [r7, #4]
 800cd84:	831a      	strh	r2, [r3, #24]
}
 800cd86:	f107 070c 	add.w	r7, r7, #12
 800cd8a:	46bd      	mov	sp, r7
 800cd8c:	bc80      	pop	{r7}
 800cd8e:	4770      	bx	lr

0800cd90 <TIM_SetIC3Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 800cd90:	b480      	push	{r7}
 800cd92:	b083      	sub	sp, #12
 800cd94:	af00      	add	r7, sp, #0
 800cd96:	6078      	str	r0, [r7, #4]
 800cd98:	460b      	mov	r3, r1
 800cd9a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 800cd9c:	687b      	ldr	r3, [r7, #4]
 800cd9e:	8b9b      	ldrh	r3, [r3, #28]
 800cda0:	b29b      	uxth	r3, r3
 800cda2:	f023 030c 	bic.w	r3, r3, #12
 800cda6:	b29a      	uxth	r2, r3
 800cda8:	687b      	ldr	r3, [r7, #4]
 800cdaa:	839a      	strh	r2, [r3, #28]

  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 800cdac:	687b      	ldr	r3, [r7, #4]
 800cdae:	8b9b      	ldrh	r3, [r3, #28]
 800cdb0:	b29a      	uxth	r2, r3
 800cdb2:	887b      	ldrh	r3, [r7, #2]
 800cdb4:	4313      	orrs	r3, r2
 800cdb6:	b29a      	uxth	r2, r3
 800cdb8:	687b      	ldr	r3, [r7, #4]
 800cdba:	839a      	strh	r2, [r3, #28]
}
 800cdbc:	f107 070c 	add.w	r7, r7, #12
 800cdc0:	46bd      	mov	sp, r7
 800cdc2:	bc80      	pop	{r7}
 800cdc4:	4770      	bx	lr
 800cdc6:	bf00      	nop

0800cdc8 <TIM_SetIC4Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{  
 800cdc8:	b480      	push	{r7}
 800cdca:	b083      	sub	sp, #12
 800cdcc:	af00      	add	r7, sp, #0
 800cdce:	6078      	str	r0, [r7, #4]
 800cdd0:	460b      	mov	r3, r1
 800cdd2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 800cdd4:	687b      	ldr	r3, [r7, #4]
 800cdd6:	8b9b      	ldrh	r3, [r3, #28]
 800cdd8:	b29b      	uxth	r3, r3
 800cdda:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800cdde:	b29a      	uxth	r2, r3
 800cde0:	687b      	ldr	r3, [r7, #4]
 800cde2:	839a      	strh	r2, [r3, #28]

  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 800cde4:	687b      	ldr	r3, [r7, #4]
 800cde6:	8b9b      	ldrh	r3, [r3, #28]
 800cde8:	b29a      	uxth	r2, r3
 800cdea:	887b      	ldrh	r3, [r7, #2]
 800cdec:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cdf0:	b29b      	uxth	r3, r3
 800cdf2:	4313      	orrs	r3, r2
 800cdf4:	b29a      	uxth	r2, r3
 800cdf6:	687b      	ldr	r3, [r7, #4]
 800cdf8:	839a      	strh	r2, [r3, #28]
}
 800cdfa:	f107 070c 	add.w	r7, r7, #12
 800cdfe:	46bd      	mov	sp, r7
 800ce00:	bc80      	pop	{r7}
 800ce02:	4770      	bx	lr

0800ce04 <TIM_BDTRConfig>:
  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval None
  */
void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
{
 800ce04:	b480      	push	{r7}
 800ce06:	b083      	sub	sp, #12
 800ce08:	af00      	add	r7, sp, #0
 800ce0a:	6078      	str	r0, [r7, #4]
 800ce0c:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800ce0e:	683b      	ldr	r3, [r7, #0]
 800ce10:	881a      	ldrh	r2, [r3, #0]
 800ce12:	683b      	ldr	r3, [r7, #0]
 800ce14:	885b      	ldrh	r3, [r3, #2]
 800ce16:	4313      	orrs	r3, r2
 800ce18:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
 800ce1a:	683b      	ldr	r3, [r7, #0]
 800ce1c:	889b      	ldrh	r3, [r3, #4]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800ce1e:	4313      	orrs	r3, r2
 800ce20:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
 800ce22:	683b      	ldr	r3, [r7, #0]
 800ce24:	88db      	ldrh	r3, [r3, #6]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800ce26:	4313      	orrs	r3, r2
 800ce28:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 800ce2a:	683b      	ldr	r3, [r7, #0]
 800ce2c:	891b      	ldrh	r3, [r3, #8]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800ce2e:	4313      	orrs	r3, r2
 800ce30:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 800ce32:	683b      	ldr	r3, [r7, #0]
 800ce34:	895b      	ldrh	r3, [r3, #10]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800ce36:	4313      	orrs	r3, r2
 800ce38:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
 800ce3a:	683b      	ldr	r3, [r7, #0]
 800ce3c:	899b      	ldrh	r3, [r3, #12]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800ce3e:	4313      	orrs	r3, r2
 800ce40:	b29a      	uxth	r2, r3
 800ce42:	687b      	ldr	r3, [r7, #4]
 800ce44:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
}
 800ce48:	f107 070c 	add.w	r7, r7, #12
 800ce4c:	46bd      	mov	sp, r7
 800ce4e:	bc80      	pop	{r7}
 800ce50:	4770      	bx	lr
 800ce52:	bf00      	nop

0800ce54 <TIM_BDTRStructInit>:
  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
 800ce54:	b480      	push	{r7}
 800ce56:	b083      	sub	sp, #12
 800ce58:	af00      	add	r7, sp, #0
 800ce5a:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 800ce5c:	687b      	ldr	r3, [r7, #4]
 800ce5e:	f04f 0200 	mov.w	r2, #0
 800ce62:	801a      	strh	r2, [r3, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 800ce64:	687b      	ldr	r3, [r7, #4]
 800ce66:	f04f 0200 	mov.w	r2, #0
 800ce6a:	805a      	strh	r2, [r3, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 800ce6c:	687b      	ldr	r3, [r7, #4]
 800ce6e:	f04f 0200 	mov.w	r2, #0
 800ce72:	809a      	strh	r2, [r3, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 800ce74:	687b      	ldr	r3, [r7, #4]
 800ce76:	f04f 0200 	mov.w	r2, #0
 800ce7a:	80da      	strh	r2, [r3, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 800ce7c:	687b      	ldr	r3, [r7, #4]
 800ce7e:	f04f 0200 	mov.w	r2, #0
 800ce82:	811a      	strh	r2, [r3, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 800ce84:	687b      	ldr	r3, [r7, #4]
 800ce86:	f04f 0200 	mov.w	r2, #0
 800ce8a:	815a      	strh	r2, [r3, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 800ce8c:	687b      	ldr	r3, [r7, #4]
 800ce8e:	f04f 0200 	mov.w	r2, #0
 800ce92:	819a      	strh	r2, [r3, #12]
}
 800ce94:	f107 070c 	add.w	r7, r7, #12
 800ce98:	46bd      	mov	sp, r7
 800ce9a:	bc80      	pop	{r7}
 800ce9c:	4770      	bx	lr
 800ce9e:	bf00      	nop

0800cea0 <TIM_CtrlPWMOutputs>:
  * @param  NewState: new state of the TIM peripheral Main Outputs.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800cea0:	b480      	push	{r7}
 800cea2:	b083      	sub	sp, #12
 800cea4:	af00      	add	r7, sp, #0
 800cea6:	6078      	str	r0, [r7, #4]
 800cea8:	460b      	mov	r3, r1
 800ceaa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800ceac:	78fb      	ldrb	r3, [r7, #3]
 800ceae:	2b00      	cmp	r3, #0
 800ceb0:	d00c      	beq.n	800cecc <TIM_CtrlPWMOutputs+0x2c>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 800ceb2:	687b      	ldr	r3, [r7, #4]
 800ceb4:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800ceb8:	b29b      	uxth	r3, r3
 800ceba:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800cebe:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800cec2:	b29a      	uxth	r2, r3
 800cec4:	687b      	ldr	r3, [r7, #4]
 800cec6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
 800ceca:	e00b      	b.n	800cee4 <TIM_CtrlPWMOutputs+0x44>
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 800cecc:	687b      	ldr	r3, [r7, #4]
 800cece:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800ced2:	b29b      	uxth	r3, r3
 800ced4:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800ced8:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800cedc:	b29a      	uxth	r2, r3
 800cede:	687b      	ldr	r3, [r7, #4]
 800cee0:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  }  
}
 800cee4:	f107 070c 	add.w	r7, r7, #12
 800cee8:	46bd      	mov	sp, r7
 800ceea:	bc80      	pop	{r7}
 800ceec:	4770      	bx	lr
 800ceee:	bf00      	nop

0800cef0 <TIM_SelectCOM>:
  * @param  NewState: new state of the Commutation event.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800cef0:	b480      	push	{r7}
 800cef2:	b083      	sub	sp, #12
 800cef4:	af00      	add	r7, sp, #0
 800cef6:	6078      	str	r0, [r7, #4]
 800cef8:	460b      	mov	r3, r1
 800cefa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800cefc:	78fb      	ldrb	r3, [r7, #3]
 800cefe:	2b00      	cmp	r3, #0
 800cf00:	d008      	beq.n	800cf14 <TIM_SelectCOM+0x24>
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 800cf02:	687b      	ldr	r3, [r7, #4]
 800cf04:	889b      	ldrh	r3, [r3, #4]
 800cf06:	b29b      	uxth	r3, r3
 800cf08:	f043 0304 	orr.w	r3, r3, #4
 800cf0c:	b29a      	uxth	r2, r3
 800cf0e:	687b      	ldr	r3, [r7, #4]
 800cf10:	809a      	strh	r2, [r3, #4]
 800cf12:	e007      	b.n	800cf24 <TIM_SelectCOM+0x34>
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
 800cf14:	687b      	ldr	r3, [r7, #4]
 800cf16:	889b      	ldrh	r3, [r3, #4]
 800cf18:	b29b      	uxth	r3, r3
 800cf1a:	f023 0304 	bic.w	r3, r3, #4
 800cf1e:	b29a      	uxth	r2, r3
 800cf20:	687b      	ldr	r3, [r7, #4]
 800cf22:	809a      	strh	r2, [r3, #4]
  }
}
 800cf24:	f107 070c 	add.w	r7, r7, #12
 800cf28:	46bd      	mov	sp, r7
 800cf2a:	bc80      	pop	{r7}
 800cf2c:	4770      	bx	lr
 800cf2e:	bf00      	nop

0800cf30 <TIM_CCPreloadControl>:
  * @param  NewState: new state of the Capture Compare Preload Control bit
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
 800cf30:	b480      	push	{r7}
 800cf32:	b083      	sub	sp, #12
 800cf34:	af00      	add	r7, sp, #0
 800cf36:	6078      	str	r0, [r7, #4]
 800cf38:	460b      	mov	r3, r1
 800cf3a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800cf3c:	78fb      	ldrb	r3, [r7, #3]
 800cf3e:	2b00      	cmp	r3, #0
 800cf40:	d008      	beq.n	800cf54 <TIM_CCPreloadControl+0x24>
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 800cf42:	687b      	ldr	r3, [r7, #4]
 800cf44:	889b      	ldrh	r3, [r3, #4]
 800cf46:	b29b      	uxth	r3, r3
 800cf48:	f043 0301 	orr.w	r3, r3, #1
 800cf4c:	b29a      	uxth	r2, r3
 800cf4e:	687b      	ldr	r3, [r7, #4]
 800cf50:	809a      	strh	r2, [r3, #4]
 800cf52:	e007      	b.n	800cf64 <TIM_CCPreloadControl+0x34>
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
 800cf54:	687b      	ldr	r3, [r7, #4]
 800cf56:	889b      	ldrh	r3, [r3, #4]
 800cf58:	b29b      	uxth	r3, r3
 800cf5a:	f023 0301 	bic.w	r3, r3, #1
 800cf5e:	b29a      	uxth	r2, r3
 800cf60:	687b      	ldr	r3, [r7, #4]
 800cf62:	809a      	strh	r2, [r3, #4]
  }
}
 800cf64:	f107 070c 	add.w	r7, r7, #12
 800cf68:	46bd      	mov	sp, r7
 800cf6a:	bc80      	pop	{r7}
 800cf6c:	4770      	bx	lr
 800cf6e:	bf00      	nop

0800cf70 <TIM_ITConfig>:
  * @param  NewState: new state of the TIM interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
 800cf70:	b480      	push	{r7}
 800cf72:	b083      	sub	sp, #12
 800cf74:	af00      	add	r7, sp, #0
 800cf76:	6078      	str	r0, [r7, #4]
 800cf78:	4613      	mov	r3, r2
 800cf7a:	460a      	mov	r2, r1
 800cf7c:	807a      	strh	r2, [r7, #2]
 800cf7e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800cf80:	787b      	ldrb	r3, [r7, #1]
 800cf82:	2b00      	cmp	r3, #0
 800cf84:	d008      	beq.n	800cf98 <TIM_ITConfig+0x28>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 800cf86:	687b      	ldr	r3, [r7, #4]
 800cf88:	899b      	ldrh	r3, [r3, #12]
 800cf8a:	b29a      	uxth	r2, r3
 800cf8c:	887b      	ldrh	r3, [r7, #2]
 800cf8e:	4313      	orrs	r3, r2
 800cf90:	b29a      	uxth	r2, r3
 800cf92:	687b      	ldr	r3, [r7, #4]
 800cf94:	819a      	strh	r2, [r3, #12]
 800cf96:	e00a      	b.n	800cfae <TIM_ITConfig+0x3e>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 800cf98:	687b      	ldr	r3, [r7, #4]
 800cf9a:	899b      	ldrh	r3, [r3, #12]
 800cf9c:	b29a      	uxth	r2, r3
 800cf9e:	887b      	ldrh	r3, [r7, #2]
 800cfa0:	ea6f 0303 	mvn.w	r3, r3
 800cfa4:	b29b      	uxth	r3, r3
 800cfa6:	4013      	ands	r3, r2
 800cfa8:	b29a      	uxth	r2, r3
 800cfaa:	687b      	ldr	r3, [r7, #4]
 800cfac:	819a      	strh	r2, [r3, #12]
  }
}
 800cfae:	f107 070c 	add.w	r7, r7, #12
 800cfb2:	46bd      	mov	sp, r7
 800cfb4:	bc80      	pop	{r7}
 800cfb6:	4770      	bx	lr

0800cfb8 <TIM_GenerateEvent>:
  * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
  *        
  * @retval None
  */
void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
{ 
 800cfb8:	b480      	push	{r7}
 800cfba:	b083      	sub	sp, #12
 800cfbc:	af00      	add	r7, sp, #0
 800cfbe:	6078      	str	r0, [r7, #4]
 800cfc0:	460b      	mov	r3, r1
 800cfc2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
 
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 800cfc4:	687b      	ldr	r3, [r7, #4]
 800cfc6:	887a      	ldrh	r2, [r7, #2]
 800cfc8:	829a      	strh	r2, [r3, #20]
}
 800cfca:	f107 070c 	add.w	r7, r7, #12
 800cfce:	46bd      	mov	sp, r7
 800cfd0:	bc80      	pop	{r7}
 800cfd2:	4770      	bx	lr

0800cfd4 <TIM_GetFlagStatus>:
  * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
  *
  * @retval The new state of TIM_FLAG (SET or RESET).
  */
FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{ 
 800cfd4:	b480      	push	{r7}
 800cfd6:	b085      	sub	sp, #20
 800cfd8:	af00      	add	r7, sp, #0
 800cfda:	6078      	str	r0, [r7, #4]
 800cfdc:	460b      	mov	r3, r1
 800cfde:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 800cfe0:	f04f 0300 	mov.w	r3, #0
 800cfe4:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));

  
  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
 800cfe6:	687b      	ldr	r3, [r7, #4]
 800cfe8:	8a1b      	ldrh	r3, [r3, #16]
 800cfea:	b29a      	uxth	r2, r3
 800cfec:	887b      	ldrh	r3, [r7, #2]
 800cfee:	4013      	ands	r3, r2
 800cff0:	b29b      	uxth	r3, r3
 800cff2:	2b00      	cmp	r3, #0
 800cff4:	d003      	beq.n	800cffe <TIM_GetFlagStatus+0x2a>
  {
    bitstatus = SET;
 800cff6:	f04f 0301 	mov.w	r3, #1
 800cffa:	73fb      	strb	r3, [r7, #15]
 800cffc:	e002      	b.n	800d004 <TIM_GetFlagStatus+0x30>
  }
  else
  {
    bitstatus = RESET;
 800cffe:	f04f 0300 	mov.w	r3, #0
 800d002:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800d004:	7bfb      	ldrb	r3, [r7, #15]
}
 800d006:	4618      	mov	r0, r3
 800d008:	f107 0714 	add.w	r7, r7, #20
 800d00c:	46bd      	mov	sp, r7
 800d00e:	bc80      	pop	{r7}
 800d010:	4770      	bx	lr
 800d012:	bf00      	nop

0800d014 <TIM_ClearFlag>:
  * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.
  *    
  * @retval None
  */
void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{  
 800d014:	b480      	push	{r7}
 800d016:	b083      	sub	sp, #12
 800d018:	af00      	add	r7, sp, #0
 800d01a:	6078      	str	r0, [r7, #4]
 800d01c:	460b      	mov	r3, r1
 800d01e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 800d020:	887b      	ldrh	r3, [r7, #2]
 800d022:	ea6f 0303 	mvn.w	r3, r3
 800d026:	b29a      	uxth	r2, r3
 800d028:	687b      	ldr	r3, [r7, #4]
 800d02a:	821a      	strh	r2, [r3, #16]
}
 800d02c:	f107 070c 	add.w	r7, r7, #12
 800d030:	46bd      	mov	sp, r7
 800d032:	bc80      	pop	{r7}
 800d034:	4770      	bx	lr
 800d036:	bf00      	nop

0800d038 <TIM_GetITStatus>:
  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
  *     
  * @retval The new state of the TIM_IT(SET or RESET).
  */
ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 800d038:	b480      	push	{r7}
 800d03a:	b085      	sub	sp, #20
 800d03c:	af00      	add	r7, sp, #0
 800d03e:	6078      	str	r0, [r7, #4]
 800d040:	460b      	mov	r3, r1
 800d042:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 800d044:	f04f 0300 	mov.w	r3, #0
 800d048:	73fb      	strb	r3, [r7, #15]
  uint16_t itstatus = 0x0, itenable = 0x0;
 800d04a:	f04f 0300 	mov.w	r3, #0
 800d04e:	81bb      	strh	r3, [r7, #12]
 800d050:	f04f 0300 	mov.w	r3, #0
 800d054:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 800d056:	687b      	ldr	r3, [r7, #4]
 800d058:	8a1b      	ldrh	r3, [r3, #16]
 800d05a:	b29a      	uxth	r2, r3
 800d05c:	887b      	ldrh	r3, [r7, #2]
 800d05e:	4013      	ands	r3, r2
 800d060:	81bb      	strh	r3, [r7, #12]
  
  itenable = TIMx->DIER & TIM_IT;
 800d062:	687b      	ldr	r3, [r7, #4]
 800d064:	899b      	ldrh	r3, [r3, #12]
 800d066:	b29a      	uxth	r2, r3
 800d068:	887b      	ldrh	r3, [r7, #2]
 800d06a:	4013      	ands	r3, r2
 800d06c:	817b      	strh	r3, [r7, #10]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 800d06e:	89bb      	ldrh	r3, [r7, #12]
 800d070:	2b00      	cmp	r3, #0
 800d072:	d006      	beq.n	800d082 <TIM_GetITStatus+0x4a>
 800d074:	897b      	ldrh	r3, [r7, #10]
 800d076:	2b00      	cmp	r3, #0
 800d078:	d003      	beq.n	800d082 <TIM_GetITStatus+0x4a>
  {
    bitstatus = SET;
 800d07a:	f04f 0301 	mov.w	r3, #1
 800d07e:	73fb      	strb	r3, [r7, #15]
 800d080:	e002      	b.n	800d088 <TIM_GetITStatus+0x50>
  }
  else
  {
    bitstatus = RESET;
 800d082:	f04f 0300 	mov.w	r3, #0
 800d086:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800d088:	7bfb      	ldrb	r3, [r7, #15]
}
 800d08a:	4618      	mov	r0, r3
 800d08c:	f107 0714 	add.w	r7, r7, #20
 800d090:	46bd      	mov	sp, r7
 800d092:	bc80      	pop	{r7}
 800d094:	4770      	bx	lr
 800d096:	bf00      	nop

0800d098 <TIM_ClearITPendingBit>:
  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
  *      
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 800d098:	b480      	push	{r7}
 800d09a:	b083      	sub	sp, #12
 800d09c:	af00      	add	r7, sp, #0
 800d09e:	6078      	str	r0, [r7, #4]
 800d0a0:	460b      	mov	r3, r1
 800d0a2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 800d0a4:	887b      	ldrh	r3, [r7, #2]
 800d0a6:	ea6f 0303 	mvn.w	r3, r3
 800d0aa:	b29a      	uxth	r2, r3
 800d0ac:	687b      	ldr	r3, [r7, #4]
 800d0ae:	821a      	strh	r2, [r3, #16]
}
 800d0b0:	f107 070c 	add.w	r7, r7, #12
 800d0b4:	46bd      	mov	sp, r7
 800d0b6:	bc80      	pop	{r7}
 800d0b8:	4770      	bx	lr
 800d0ba:	bf00      	nop

0800d0bc <TIM_DMAConfig>:
  * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
  *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
  * @retval None
  */
void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
{
 800d0bc:	b480      	push	{r7}
 800d0be:	b083      	sub	sp, #12
 800d0c0:	af00      	add	r7, sp, #0
 800d0c2:	6078      	str	r0, [r7, #4]
 800d0c4:	4613      	mov	r3, r2
 800d0c6:	460a      	mov	r2, r1
 800d0c8:	807a      	strh	r2, [r7, #2]
 800d0ca:	803b      	strh	r3, [r7, #0]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));

  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 800d0cc:	887a      	ldrh	r2, [r7, #2]
 800d0ce:	883b      	ldrh	r3, [r7, #0]
 800d0d0:	4313      	orrs	r3, r2
 800d0d2:	b29a      	uxth	r2, r3
 800d0d4:	687b      	ldr	r3, [r7, #4]
 800d0d6:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
}
 800d0da:	f107 070c 	add.w	r7, r7, #12
 800d0de:	46bd      	mov	sp, r7
 800d0e0:	bc80      	pop	{r7}
 800d0e2:	4770      	bx	lr

0800d0e4 <TIM_DMACmd>:
  * @param  NewState: new state of the DMA Request sources.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
{ 
 800d0e4:	b480      	push	{r7}
 800d0e6:	b083      	sub	sp, #12
 800d0e8:	af00      	add	r7, sp, #0
 800d0ea:	6078      	str	r0, [r7, #4]
 800d0ec:	4613      	mov	r3, r2
 800d0ee:	460a      	mov	r2, r1
 800d0f0:	807a      	strh	r2, [r7, #2]
 800d0f2:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800d0f4:	787b      	ldrb	r3, [r7, #1]
 800d0f6:	2b00      	cmp	r3, #0
 800d0f8:	d008      	beq.n	800d10c <TIM_DMACmd+0x28>
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 800d0fa:	687b      	ldr	r3, [r7, #4]
 800d0fc:	899b      	ldrh	r3, [r3, #12]
 800d0fe:	b29a      	uxth	r2, r3
 800d100:	887b      	ldrh	r3, [r7, #2]
 800d102:	4313      	orrs	r3, r2
 800d104:	b29a      	uxth	r2, r3
 800d106:	687b      	ldr	r3, [r7, #4]
 800d108:	819a      	strh	r2, [r3, #12]
 800d10a:	e00a      	b.n	800d122 <TIM_DMACmd+0x3e>
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 800d10c:	687b      	ldr	r3, [r7, #4]
 800d10e:	899b      	ldrh	r3, [r3, #12]
 800d110:	b29a      	uxth	r2, r3
 800d112:	887b      	ldrh	r3, [r7, #2]
 800d114:	ea6f 0303 	mvn.w	r3, r3
 800d118:	b29b      	uxth	r3, r3
 800d11a:	4013      	ands	r3, r2
 800d11c:	b29a      	uxth	r2, r3
 800d11e:	687b      	ldr	r3, [r7, #4]
 800d120:	819a      	strh	r2, [r3, #12]
  }
}
 800d122:	f107 070c 	add.w	r7, r7, #12
 800d126:	46bd      	mov	sp, r7
 800d128:	bc80      	pop	{r7}
 800d12a:	4770      	bx	lr

0800d12c <TIM_SelectCCDMA>:
  * @param  NewState: new state of the Capture Compare DMA source
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800d12c:	b480      	push	{r7}
 800d12e:	b083      	sub	sp, #12
 800d130:	af00      	add	r7, sp, #0
 800d132:	6078      	str	r0, [r7, #4]
 800d134:	460b      	mov	r3, r1
 800d136:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800d138:	78fb      	ldrb	r3, [r7, #3]
 800d13a:	2b00      	cmp	r3, #0
 800d13c:	d008      	beq.n	800d150 <TIM_SelectCCDMA+0x24>
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 800d13e:	687b      	ldr	r3, [r7, #4]
 800d140:	889b      	ldrh	r3, [r3, #4]
 800d142:	b29b      	uxth	r3, r3
 800d144:	f043 0308 	orr.w	r3, r3, #8
 800d148:	b29a      	uxth	r2, r3
 800d14a:	687b      	ldr	r3, [r7, #4]
 800d14c:	809a      	strh	r2, [r3, #4]
 800d14e:	e007      	b.n	800d160 <TIM_SelectCCDMA+0x34>
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
 800d150:	687b      	ldr	r3, [r7, #4]
 800d152:	889b      	ldrh	r3, [r3, #4]
 800d154:	b29b      	uxth	r3, r3
 800d156:	f023 0308 	bic.w	r3, r3, #8
 800d15a:	b29a      	uxth	r2, r3
 800d15c:	687b      	ldr	r3, [r7, #4]
 800d15e:	809a      	strh	r2, [r3, #4]
  }
}
 800d160:	f107 070c 	add.w	r7, r7, #12
 800d164:	46bd      	mov	sp, r7
 800d166:	bc80      	pop	{r7}
 800d168:	4770      	bx	lr
 800d16a:	bf00      	nop

0800d16c <TIM_InternalClockConfig>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
  *         peripheral.
  * @retval None
  */
void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
{
 800d16c:	b480      	push	{r7}
 800d16e:	b083      	sub	sp, #12
 800d170:	af00      	add	r7, sp, #0
 800d172:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
 800d174:	687b      	ldr	r3, [r7, #4]
 800d176:	891b      	ldrh	r3, [r3, #8]
 800d178:	b29b      	uxth	r3, r3
 800d17a:	f023 0307 	bic.w	r3, r3, #7
 800d17e:	b29a      	uxth	r2, r3
 800d180:	687b      	ldr	r3, [r7, #4]
 800d182:	811a      	strh	r2, [r3, #8]
}
 800d184:	f107 070c 	add.w	r7, r7, #12
 800d188:	46bd      	mov	sp, r7
 800d18a:	bc80      	pop	{r7}
 800d18c:	4770      	bx	lr
 800d18e:	bf00      	nop

0800d190 <TIM_ITRxExternalClockConfig>:
  *            @arg TIM_TS_ITR2: Internal Trigger 2
  *            @arg TIM_TS_ITR3: Internal Trigger 3
  * @retval None
  */
void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
{
 800d190:	b580      	push	{r7, lr}
 800d192:	b082      	sub	sp, #8
 800d194:	af00      	add	r7, sp, #0
 800d196:	6078      	str	r0, [r7, #4]
 800d198:	460b      	mov	r3, r1
 800d19a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
 800d19c:	887b      	ldrh	r3, [r7, #2]
 800d19e:	6878      	ldr	r0, [r7, #4]
 800d1a0:	4619      	mov	r1, r3
 800d1a2:	f000 f87d 	bl	800d2a0 <TIM_SelectInputTrigger>

  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 800d1a6:	687b      	ldr	r3, [r7, #4]
 800d1a8:	891b      	ldrh	r3, [r3, #8]
 800d1aa:	b29b      	uxth	r3, r3
 800d1ac:	f043 0307 	orr.w	r3, r3, #7
 800d1b0:	b29a      	uxth	r2, r3
 800d1b2:	687b      	ldr	r3, [r7, #4]
 800d1b4:	811a      	strh	r2, [r3, #8]
}
 800d1b6:	f107 0708 	add.w	r7, r7, #8
 800d1ba:	46bd      	mov	sp, r7
 800d1bc:	bd80      	pop	{r7, pc}
 800d1be:	bf00      	nop

0800d1c0 <TIM_TIxExternalClockConfig>:
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 800d1c0:	b580      	push	{r7, lr}
 800d1c2:	b084      	sub	sp, #16
 800d1c4:	af00      	add	r7, sp, #0
 800d1c6:	60f8      	str	r0, [r7, #12]
 800d1c8:	8179      	strh	r1, [r7, #10]
 800d1ca:	813a      	strh	r2, [r7, #8]
 800d1cc:	80fb      	strh	r3, [r7, #6]
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 800d1ce:	897b      	ldrh	r3, [r7, #10]
 800d1d0:	2b60      	cmp	r3, #96	; 0x60
 800d1d2:	d108      	bne.n	800d1e6 <TIM_TIxExternalClockConfig+0x26>
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 800d1d4:	893a      	ldrh	r2, [r7, #8]
 800d1d6:	88fb      	ldrh	r3, [r7, #6]
 800d1d8:	68f8      	ldr	r0, [r7, #12]
 800d1da:	4611      	mov	r1, r2
 800d1dc:	f04f 0201 	mov.w	r2, #1
 800d1e0:	f000 f9ae 	bl	800d540 <TI2_Config>
 800d1e4:	e007      	b.n	800d1f6 <TIM_TIxExternalClockConfig+0x36>
  }
  else
  {
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 800d1e6:	893a      	ldrh	r2, [r7, #8]
 800d1e8:	88fb      	ldrh	r3, [r7, #6]
 800d1ea:	68f8      	ldr	r0, [r7, #12]
 800d1ec:	4611      	mov	r1, r2
 800d1ee:	f04f 0201 	mov.w	r2, #1
 800d1f2:	f000 f965 	bl	800d4c0 <TI1_Config>
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
 800d1f6:	897b      	ldrh	r3, [r7, #10]
 800d1f8:	68f8      	ldr	r0, [r7, #12]
 800d1fa:	4619      	mov	r1, r3
 800d1fc:	f000 f850 	bl	800d2a0 <TIM_SelectInputTrigger>
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 800d200:	68fb      	ldr	r3, [r7, #12]
 800d202:	891b      	ldrh	r3, [r3, #8]
 800d204:	b29b      	uxth	r3, r3
 800d206:	f043 0307 	orr.w	r3, r3, #7
 800d20a:	b29a      	uxth	r2, r3
 800d20c:	68fb      	ldr	r3, [r7, #12]
 800d20e:	811a      	strh	r2, [r3, #8]
}
 800d210:	f107 0710 	add.w	r7, r7, #16
 800d214:	46bd      	mov	sp, r7
 800d216:	bd80      	pop	{r7, pc}

0800d218 <TIM_ETRClockMode1Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 800d218:	b580      	push	{r7, lr}
 800d21a:	b086      	sub	sp, #24
 800d21c:	af00      	add	r7, sp, #0
 800d21e:	60f8      	str	r0, [r7, #12]
 800d220:	8179      	strh	r1, [r7, #10]
 800d222:	813a      	strh	r2, [r7, #8]
 800d224:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
 800d226:	f04f 0300 	mov.w	r3, #0
 800d22a:	82fb      	strh	r3, [r7, #22]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 800d22c:	8979      	ldrh	r1, [r7, #10]
 800d22e:	893a      	ldrh	r2, [r7, #8]
 800d230:	88fb      	ldrh	r3, [r7, #6]
 800d232:	68f8      	ldr	r0, [r7, #12]
 800d234:	f000 f8a4 	bl	800d380 <TIM_ETRConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800d238:	68fb      	ldr	r3, [r7, #12]
 800d23a:	891b      	ldrh	r3, [r3, #8]
 800d23c:	82fb      	strh	r3, [r7, #22]

  /* Reset the SMS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 800d23e:	8afb      	ldrh	r3, [r7, #22]
 800d240:	f023 0307 	bic.w	r3, r3, #7
 800d244:	82fb      	strh	r3, [r7, #22]

  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;
 800d246:	8afb      	ldrh	r3, [r7, #22]
 800d248:	f043 0307 	orr.w	r3, r3, #7
 800d24c:	82fb      	strh	r3, [r7, #22]

  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 800d24e:	8afb      	ldrh	r3, [r7, #22]
 800d250:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800d254:	82fb      	strh	r3, [r7, #22]
  tmpsmcr |= TIM_TS_ETRF;
 800d256:	8afb      	ldrh	r3, [r7, #22]
 800d258:	f043 0370 	orr.w	r3, r3, #112	; 0x70
 800d25c:	82fb      	strh	r3, [r7, #22]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800d25e:	68fb      	ldr	r3, [r7, #12]
 800d260:	8afa      	ldrh	r2, [r7, #22]
 800d262:	811a      	strh	r2, [r3, #8]
}
 800d264:	f107 0718 	add.w	r7, r7, #24
 800d268:	46bd      	mov	sp, r7
 800d26a:	bd80      	pop	{r7, pc}

0800d26c <TIM_ETRClockMode2Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 800d26c:	b580      	push	{r7, lr}
 800d26e:	b084      	sub	sp, #16
 800d270:	af00      	add	r7, sp, #0
 800d272:	60f8      	str	r0, [r7, #12]
 800d274:	8179      	strh	r1, [r7, #10]
 800d276:	813a      	strh	r2, [r7, #8]
 800d278:	80fb      	strh	r3, [r7, #6]
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 800d27a:	8979      	ldrh	r1, [r7, #10]
 800d27c:	893a      	ldrh	r2, [r7, #8]
 800d27e:	88fb      	ldrh	r3, [r7, #6]
 800d280:	68f8      	ldr	r0, [r7, #12]
 800d282:	f000 f87d 	bl	800d380 <TIM_ETRConfig>

  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 800d286:	68fb      	ldr	r3, [r7, #12]
 800d288:	891b      	ldrh	r3, [r3, #8]
 800d28a:	b29b      	uxth	r3, r3
 800d28c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800d290:	b29a      	uxth	r2, r3
 800d292:	68fb      	ldr	r3, [r7, #12]
 800d294:	811a      	strh	r2, [r3, #8]
}
 800d296:	f107 0710 	add.w	r7, r7, #16
 800d29a:	46bd      	mov	sp, r7
 800d29c:	bd80      	pop	{r7, pc}
 800d29e:	bf00      	nop

0800d2a0 <TIM_SelectInputTrigger>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
{
 800d2a0:	b480      	push	{r7}
 800d2a2:	b085      	sub	sp, #20
 800d2a4:	af00      	add	r7, sp, #0
 800d2a6:	6078      	str	r0, [r7, #4]
 800d2a8:	460b      	mov	r3, r1
 800d2aa:	807b      	strh	r3, [r7, #2]
  uint16_t tmpsmcr = 0;
 800d2ac:	f04f 0300 	mov.w	r3, #0
 800d2b0:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800d2b2:	687b      	ldr	r3, [r7, #4]
 800d2b4:	891b      	ldrh	r3, [r3, #8]
 800d2b6:	81fb      	strh	r3, [r7, #14]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 800d2b8:	89fb      	ldrh	r3, [r7, #14]
 800d2ba:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800d2be:	81fb      	strh	r3, [r7, #14]

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 800d2c0:	89fa      	ldrh	r2, [r7, #14]
 800d2c2:	887b      	ldrh	r3, [r7, #2]
 800d2c4:	4313      	orrs	r3, r2
 800d2c6:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800d2c8:	687b      	ldr	r3, [r7, #4]
 800d2ca:	89fa      	ldrh	r2, [r7, #14]
 800d2cc:	811a      	strh	r2, [r3, #8]
}
 800d2ce:	f107 0714 	add.w	r7, r7, #20
 800d2d2:	46bd      	mov	sp, r7
 800d2d4:	bc80      	pop	{r7}
 800d2d6:	4770      	bx	lr

0800d2d8 <TIM_SelectOutputTrigger>:
  *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output(TRGO)
  *
  * @retval None
  */
void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
{
 800d2d8:	b480      	push	{r7}
 800d2da:	b083      	sub	sp, #12
 800d2dc:	af00      	add	r7, sp, #0
 800d2de:	6078      	str	r0, [r7, #4]
 800d2e0:	460b      	mov	r3, r1
 800d2e2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
 800d2e4:	687b      	ldr	r3, [r7, #4]
 800d2e6:	889b      	ldrh	r3, [r3, #4]
 800d2e8:	b29b      	uxth	r3, r3
 800d2ea:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800d2ee:	b29a      	uxth	r2, r3
 800d2f0:	687b      	ldr	r3, [r7, #4]
 800d2f2:	809a      	strh	r2, [r3, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 800d2f4:	687b      	ldr	r3, [r7, #4]
 800d2f6:	889b      	ldrh	r3, [r3, #4]
 800d2f8:	b29a      	uxth	r2, r3
 800d2fa:	887b      	ldrh	r3, [r7, #2]
 800d2fc:	4313      	orrs	r3, r2
 800d2fe:	b29a      	uxth	r2, r3
 800d300:	687b      	ldr	r3, [r7, #4]
 800d302:	809a      	strh	r2, [r3, #4]
}
 800d304:	f107 070c 	add.w	r7, r7, #12
 800d308:	46bd      	mov	sp, r7
 800d30a:	bc80      	pop	{r7}
 800d30c:	4770      	bx	lr
 800d30e:	bf00      	nop

0800d310 <TIM_SelectSlaveMode>:
  *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI
  *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter
  * @retval None
  */
void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
{
 800d310:	b480      	push	{r7}
 800d312:	b083      	sub	sp, #12
 800d314:	af00      	add	r7, sp, #0
 800d316:	6078      	str	r0, [r7, #4]
 800d318:	460b      	mov	r3, r1
 800d31a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));

  /* Reset the SMS Bits */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
 800d31c:	687b      	ldr	r3, [r7, #4]
 800d31e:	891b      	ldrh	r3, [r3, #8]
 800d320:	b29b      	uxth	r3, r3
 800d322:	f023 0307 	bic.w	r3, r3, #7
 800d326:	b29a      	uxth	r2, r3
 800d328:	687b      	ldr	r3, [r7, #4]
 800d32a:	811a      	strh	r2, [r3, #8]

  /* Select the Slave Mode */
  TIMx->SMCR |= TIM_SlaveMode;
 800d32c:	687b      	ldr	r3, [r7, #4]
 800d32e:	891b      	ldrh	r3, [r3, #8]
 800d330:	b29a      	uxth	r2, r3
 800d332:	887b      	ldrh	r3, [r7, #2]
 800d334:	4313      	orrs	r3, r2
 800d336:	b29a      	uxth	r2, r3
 800d338:	687b      	ldr	r3, [r7, #4]
 800d33a:	811a      	strh	r2, [r3, #8]
}
 800d33c:	f107 070c 	add.w	r7, r7, #12
 800d340:	46bd      	mov	sp, r7
 800d342:	bc80      	pop	{r7}
 800d344:	4770      	bx	lr
 800d346:	bf00      	nop

0800d348 <TIM_SelectMasterSlaveMode>:
  *                                             and its slaves (through TRGO)
  *            @arg TIM_MasterSlaveMode_Disable: No action
  * @retval None
  */
void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
{
 800d348:	b480      	push	{r7}
 800d34a:	b083      	sub	sp, #12
 800d34c:	af00      	add	r7, sp, #0
 800d34e:	6078      	str	r0, [r7, #4]
 800d350:	460b      	mov	r3, r1
 800d352:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));

  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
 800d354:	687b      	ldr	r3, [r7, #4]
 800d356:	891b      	ldrh	r3, [r3, #8]
 800d358:	b29b      	uxth	r3, r3
 800d35a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800d35e:	b29a      	uxth	r2, r3
 800d360:	687b      	ldr	r3, [r7, #4]
 800d362:	811a      	strh	r2, [r3, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 800d364:	687b      	ldr	r3, [r7, #4]
 800d366:	891b      	ldrh	r3, [r3, #8]
 800d368:	b29a      	uxth	r2, r3
 800d36a:	887b      	ldrh	r3, [r7, #2]
 800d36c:	4313      	orrs	r3, r2
 800d36e:	b29a      	uxth	r2, r3
 800d370:	687b      	ldr	r3, [r7, #4]
 800d372:	811a      	strh	r2, [r3, #8]
}
 800d374:	f107 070c 	add.w	r7, r7, #12
 800d378:	46bd      	mov	sp, r7
 800d37a:	bc80      	pop	{r7}
 800d37c:	4770      	bx	lr
 800d37e:	bf00      	nop

0800d380 <TIM_ETRConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                   uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 800d380:	b480      	push	{r7}
 800d382:	b087      	sub	sp, #28
 800d384:	af00      	add	r7, sp, #0
 800d386:	60f8      	str	r0, [r7, #12]
 800d388:	8179      	strh	r1, [r7, #10]
 800d38a:	813a      	strh	r2, [r7, #8]
 800d38c:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
 800d38e:	f04f 0300 	mov.w	r3, #0
 800d392:	82fb      	strh	r3, [r7, #22]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 800d394:	68fb      	ldr	r3, [r7, #12]
 800d396:	891b      	ldrh	r3, [r3, #8]
 800d398:	82fb      	strh	r3, [r7, #22]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 800d39a:	8afb      	ldrh	r3, [r7, #22]
 800d39c:	b2db      	uxtb	r3, r3
 800d39e:	82fb      	strh	r3, [r7, #22]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 800d3a0:	88fb      	ldrh	r3, [r7, #6]
 800d3a2:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d3a6:	b29a      	uxth	r2, r3
 800d3a8:	893b      	ldrh	r3, [r7, #8]
 800d3aa:	4313      	orrs	r3, r2
 800d3ac:	b29a      	uxth	r2, r3
 800d3ae:	897b      	ldrh	r3, [r7, #10]
 800d3b0:	4313      	orrs	r3, r2
 800d3b2:	b29a      	uxth	r2, r3
 800d3b4:	8afb      	ldrh	r3, [r7, #22]
 800d3b6:	4313      	orrs	r3, r2
 800d3b8:	82fb      	strh	r3, [r7, #22]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800d3ba:	68fb      	ldr	r3, [r7, #12]
 800d3bc:	8afa      	ldrh	r2, [r7, #22]
 800d3be:	811a      	strh	r2, [r3, #8]
}
 800d3c0:	f107 071c 	add.w	r7, r7, #28
 800d3c4:	46bd      	mov	sp, r7
 800d3c6:	bc80      	pop	{r7}
 800d3c8:	4770      	bx	lr
 800d3ca:	bf00      	nop

0800d3cc <TIM_EncoderInterfaceConfig>:
  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 800d3cc:	b480      	push	{r7}
 800d3ce:	b087      	sub	sp, #28
 800d3d0:	af00      	add	r7, sp, #0
 800d3d2:	60f8      	str	r0, [r7, #12]
 800d3d4:	8179      	strh	r1, [r7, #10]
 800d3d6:	813a      	strh	r2, [r7, #8]
 800d3d8:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
 800d3da:	f04f 0300 	mov.w	r3, #0
 800d3de:	82fb      	strh	r3, [r7, #22]
  uint16_t tmpccmr1 = 0;
 800d3e0:	f04f 0300 	mov.w	r3, #0
 800d3e4:	82bb      	strh	r3, [r7, #20]
  uint16_t tmpccer = 0;
 800d3e6:	f04f 0300 	mov.w	r3, #0
 800d3ea:	827b      	strh	r3, [r7, #18]
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800d3ec:	68fb      	ldr	r3, [r7, #12]
 800d3ee:	891b      	ldrh	r3, [r3, #8]
 800d3f0:	82fb      	strh	r3, [r7, #22]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 800d3f2:	68fb      	ldr	r3, [r7, #12]
 800d3f4:	8b1b      	ldrh	r3, [r3, #24]
 800d3f6:	82bb      	strh	r3, [r7, #20]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800d3f8:	68fb      	ldr	r3, [r7, #12]
 800d3fa:	8c1b      	ldrh	r3, [r3, #32]
 800d3fc:	827b      	strh	r3, [r7, #18]

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 800d3fe:	8afb      	ldrh	r3, [r7, #22]
 800d400:	f023 0307 	bic.w	r3, r3, #7
 800d404:	82fb      	strh	r3, [r7, #22]
  tmpsmcr |= TIM_EncoderMode;
 800d406:	8afa      	ldrh	r2, [r7, #22]
 800d408:	897b      	ldrh	r3, [r7, #10]
 800d40a:	4313      	orrs	r3, r2
 800d40c:	82fb      	strh	r3, [r7, #22]

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 800d40e:	8abb      	ldrh	r3, [r7, #20]
 800d410:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800d414:	f023 0303 	bic.w	r3, r3, #3
 800d418:	82bb      	strh	r3, [r7, #20]
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 800d41a:	8abb      	ldrh	r3, [r7, #20]
 800d41c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800d420:	f043 0301 	orr.w	r3, r3, #1
 800d424:	82bb      	strh	r3, [r7, #20]

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
 800d426:	8a7b      	ldrh	r3, [r7, #18]
 800d428:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 800d42c:	827b      	strh	r3, [r7, #18]
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 800d42e:	88fb      	ldrh	r3, [r7, #6]
 800d430:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800d434:	b29a      	uxth	r2, r3
 800d436:	893b      	ldrh	r3, [r7, #8]
 800d438:	4313      	orrs	r3, r2
 800d43a:	b29a      	uxth	r2, r3
 800d43c:	8a7b      	ldrh	r3, [r7, #18]
 800d43e:	4313      	orrs	r3, r2
 800d440:	827b      	strh	r3, [r7, #18]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800d442:	68fb      	ldr	r3, [r7, #12]
 800d444:	8afa      	ldrh	r2, [r7, #22]
 800d446:	811a      	strh	r2, [r3, #8]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 800d448:	68fb      	ldr	r3, [r7, #12]
 800d44a:	8aba      	ldrh	r2, [r7, #20]
 800d44c:	831a      	strh	r2, [r3, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800d44e:	68fb      	ldr	r3, [r7, #12]
 800d450:	8a7a      	ldrh	r2, [r7, #18]
 800d452:	841a      	strh	r2, [r3, #32]
}
 800d454:	f107 071c 	add.w	r7, r7, #28
 800d458:	46bd      	mov	sp, r7
 800d45a:	bc80      	pop	{r7}
 800d45c:	4770      	bx	lr
 800d45e:	bf00      	nop

0800d460 <TIM_SelectHallSensor>:
  * @param  NewState: new state of the TIMx Hall sensor interface.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800d460:	b480      	push	{r7}
 800d462:	b083      	sub	sp, #12
 800d464:	af00      	add	r7, sp, #0
 800d466:	6078      	str	r0, [r7, #4]
 800d468:	460b      	mov	r3, r1
 800d46a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800d46c:	78fb      	ldrb	r3, [r7, #3]
 800d46e:	2b00      	cmp	r3, #0
 800d470:	d008      	beq.n	800d484 <TIM_SelectHallSensor+0x24>
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 800d472:	687b      	ldr	r3, [r7, #4]
 800d474:	889b      	ldrh	r3, [r3, #4]
 800d476:	b29b      	uxth	r3, r3
 800d478:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800d47c:	b29a      	uxth	r2, r3
 800d47e:	687b      	ldr	r3, [r7, #4]
 800d480:	809a      	strh	r2, [r3, #4]
 800d482:	e007      	b.n	800d494 <TIM_SelectHallSensor+0x34>
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
 800d484:	687b      	ldr	r3, [r7, #4]
 800d486:	889b      	ldrh	r3, [r3, #4]
 800d488:	b29b      	uxth	r3, r3
 800d48a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800d48e:	b29a      	uxth	r2, r3
 800d490:	687b      	ldr	r3, [r7, #4]
 800d492:	809a      	strh	r2, [r3, #4]
  }
}
 800d494:	f107 070c 	add.w	r7, r7, #12
 800d498:	46bd      	mov	sp, r7
 800d49a:	bc80      	pop	{r7}
 800d49c:	4770      	bx	lr
 800d49e:	bf00      	nop

0800d4a0 <TIM_RemapConfig>:
  *            @arg TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
  *                                 (HSE divided by a programmable prescaler)  
  * @retval None
  */
void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
{
 800d4a0:	b480      	push	{r7}
 800d4a2:	b083      	sub	sp, #12
 800d4a4:	af00      	add	r7, sp, #0
 800d4a6:	6078      	str	r0, [r7, #4]
 800d4a8:	460b      	mov	r3, r1
 800d4aa:	807b      	strh	r3, [r7, #2]
 /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_REMAP(TIM_Remap));

  /* Set the Timer remapping configuration */
  TIMx->OR =  TIM_Remap;
 800d4ac:	687b      	ldr	r3, [r7, #4]
 800d4ae:	887a      	ldrh	r2, [r7, #2]
 800d4b0:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
}
 800d4b4:	f107 070c 	add.w	r7, r7, #12
 800d4b8:	46bd      	mov	sp, r7
 800d4ba:	bc80      	pop	{r7}
 800d4bc:	4770      	bx	lr
 800d4be:	bf00      	nop

0800d4c0 <TI1_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 800d4c0:	b480      	push	{r7}
 800d4c2:	b087      	sub	sp, #28
 800d4c4:	af00      	add	r7, sp, #0
 800d4c6:	60f8      	str	r0, [r7, #12]
 800d4c8:	8179      	strh	r1, [r7, #10]
 800d4ca:	813a      	strh	r2, [r7, #8]
 800d4cc:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0;
 800d4ce:	f04f 0300 	mov.w	r3, #0
 800d4d2:	82fb      	strh	r3, [r7, #22]
 800d4d4:	f04f 0300 	mov.w	r3, #0
 800d4d8:	82bb      	strh	r3, [r7, #20]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 800d4da:	68fb      	ldr	r3, [r7, #12]
 800d4dc:	8c1b      	ldrh	r3, [r3, #32]
 800d4de:	b29b      	uxth	r3, r3
 800d4e0:	f023 0301 	bic.w	r3, r3, #1
 800d4e4:	b29a      	uxth	r2, r3
 800d4e6:	68fb      	ldr	r3, [r7, #12]
 800d4e8:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800d4ea:	68fb      	ldr	r3, [r7, #12]
 800d4ec:	8b1b      	ldrh	r3, [r3, #24]
 800d4ee:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 800d4f0:	68fb      	ldr	r3, [r7, #12]
 800d4f2:	8c1b      	ldrh	r3, [r3, #32]
 800d4f4:	82bb      	strh	r3, [r7, #20]

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
 800d4f6:	8afb      	ldrh	r3, [r7, #22]
 800d4f8:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
 800d4fc:	82fb      	strh	r3, [r7, #22]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 800d4fe:	88fb      	ldrh	r3, [r7, #6]
 800d500:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800d504:	b29a      	uxth	r2, r3
 800d506:	893b      	ldrh	r3, [r7, #8]
 800d508:	4313      	orrs	r3, r2
 800d50a:	b29a      	uxth	r2, r3
 800d50c:	8afb      	ldrh	r3, [r7, #22]
 800d50e:	4313      	orrs	r3, r2
 800d510:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800d512:	8abb      	ldrh	r3, [r7, #20]
 800d514:	f023 030a 	bic.w	r3, r3, #10
 800d518:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 800d51a:	897a      	ldrh	r2, [r7, #10]
 800d51c:	8abb      	ldrh	r3, [r7, #20]
 800d51e:	4313      	orrs	r3, r2
 800d520:	b29b      	uxth	r3, r3
 800d522:	f043 0301 	orr.w	r3, r3, #1
 800d526:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800d528:	68fb      	ldr	r3, [r7, #12]
 800d52a:	8afa      	ldrh	r2, [r7, #22]
 800d52c:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800d52e:	68fb      	ldr	r3, [r7, #12]
 800d530:	8aba      	ldrh	r2, [r7, #20]
 800d532:	841a      	strh	r2, [r3, #32]
}
 800d534:	f107 071c 	add.w	r7, r7, #28
 800d538:	46bd      	mov	sp, r7
 800d53a:	bc80      	pop	{r7}
 800d53c:	4770      	bx	lr
 800d53e:	bf00      	nop

0800d540 <TI2_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 800d540:	b480      	push	{r7}
 800d542:	b087      	sub	sp, #28
 800d544:	af00      	add	r7, sp, #0
 800d546:	60f8      	str	r0, [r7, #12]
 800d548:	8179      	strh	r1, [r7, #10]
 800d54a:	813a      	strh	r2, [r7, #8]
 800d54c:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
 800d54e:	f04f 0300 	mov.w	r3, #0
 800d552:	82fb      	strh	r3, [r7, #22]
 800d554:	f04f 0300 	mov.w	r3, #0
 800d558:	82bb      	strh	r3, [r7, #20]
 800d55a:	f04f 0300 	mov.w	r3, #0
 800d55e:	827b      	strh	r3, [r7, #18]

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 800d560:	68fb      	ldr	r3, [r7, #12]
 800d562:	8c1b      	ldrh	r3, [r3, #32]
 800d564:	b29b      	uxth	r3, r3
 800d566:	f023 0310 	bic.w	r3, r3, #16
 800d56a:	b29a      	uxth	r2, r3
 800d56c:	68fb      	ldr	r3, [r7, #12]
 800d56e:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800d570:	68fb      	ldr	r3, [r7, #12]
 800d572:	8b1b      	ldrh	r3, [r3, #24]
 800d574:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 800d576:	68fb      	ldr	r3, [r7, #12]
 800d578:	8c1b      	ldrh	r3, [r3, #32]
 800d57a:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 800d57c:	897b      	ldrh	r3, [r7, #10]
 800d57e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800d582:	827b      	strh	r3, [r7, #18]

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 800d584:	8afb      	ldrh	r3, [r7, #22]
 800d586:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800d58a:	ea4f 5303 	mov.w	r3, r3, lsl #20
 800d58e:	ea4f 5313 	mov.w	r3, r3, lsr #20
 800d592:	82fb      	strh	r3, [r7, #22]
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 800d594:	88fb      	ldrh	r3, [r7, #6]
 800d596:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800d59a:	b29a      	uxth	r2, r3
 800d59c:	8afb      	ldrh	r3, [r7, #22]
 800d59e:	4313      	orrs	r3, r2
 800d5a0:	82fb      	strh	r3, [r7, #22]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 800d5a2:	893b      	ldrh	r3, [r7, #8]
 800d5a4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d5a8:	b29a      	uxth	r2, r3
 800d5aa:	8afb      	ldrh	r3, [r7, #22]
 800d5ac:	4313      	orrs	r3, r2
 800d5ae:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800d5b0:	8abb      	ldrh	r3, [r7, #20]
 800d5b2:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800d5b6:	82bb      	strh	r3, [r7, #20]
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 800d5b8:	8a7a      	ldrh	r2, [r7, #18]
 800d5ba:	8abb      	ldrh	r3, [r7, #20]
 800d5bc:	4313      	orrs	r3, r2
 800d5be:	b29b      	uxth	r3, r3
 800d5c0:	f043 0310 	orr.w	r3, r3, #16
 800d5c4:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800d5c6:	68fb      	ldr	r3, [r7, #12]
 800d5c8:	8afa      	ldrh	r2, [r7, #22]
 800d5ca:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800d5cc:	68fb      	ldr	r3, [r7, #12]
 800d5ce:	8aba      	ldrh	r2, [r7, #20]
 800d5d0:	841a      	strh	r2, [r3, #32]
}
 800d5d2:	f107 071c 	add.w	r7, r7, #28
 800d5d6:	46bd      	mov	sp, r7
 800d5d8:	bc80      	pop	{r7}
 800d5da:	4770      	bx	lr

0800d5dc <TI3_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 800d5dc:	b480      	push	{r7}
 800d5de:	b087      	sub	sp, #28
 800d5e0:	af00      	add	r7, sp, #0
 800d5e2:	60f8      	str	r0, [r7, #12]
 800d5e4:	8179      	strh	r1, [r7, #10]
 800d5e6:	813a      	strh	r2, [r7, #8]
 800d5e8:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
 800d5ea:	f04f 0300 	mov.w	r3, #0
 800d5ee:	82fb      	strh	r3, [r7, #22]
 800d5f0:	f04f 0300 	mov.w	r3, #0
 800d5f4:	82bb      	strh	r3, [r7, #20]
 800d5f6:	f04f 0300 	mov.w	r3, #0
 800d5fa:	827b      	strh	r3, [r7, #18]

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 800d5fc:	68fb      	ldr	r3, [r7, #12]
 800d5fe:	8c1b      	ldrh	r3, [r3, #32]
 800d600:	b29b      	uxth	r3, r3
 800d602:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800d606:	b29a      	uxth	r2, r3
 800d608:	68fb      	ldr	r3, [r7, #12]
 800d60a:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 800d60c:	68fb      	ldr	r3, [r7, #12]
 800d60e:	8b9b      	ldrh	r3, [r3, #28]
 800d610:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 800d612:	68fb      	ldr	r3, [r7, #12]
 800d614:	8c1b      	ldrh	r3, [r3, #32]
 800d616:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 8);
 800d618:	897b      	ldrh	r3, [r7, #10]
 800d61a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d61e:	827b      	strh	r3, [r7, #18]

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 800d620:	8afb      	ldrh	r3, [r7, #22]
 800d622:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
 800d626:	82fb      	strh	r3, [r7, #22]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 800d628:	88fb      	ldrh	r3, [r7, #6]
 800d62a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800d62e:	b29a      	uxth	r2, r3
 800d630:	893b      	ldrh	r3, [r7, #8]
 800d632:	4313      	orrs	r3, r2
 800d634:	b29a      	uxth	r2, r3
 800d636:	8afb      	ldrh	r3, [r7, #22]
 800d638:	4313      	orrs	r3, r2
 800d63a:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 800d63c:	8abb      	ldrh	r3, [r7, #20]
 800d63e:	f423 6320 	bic.w	r3, r3, #2560	; 0xa00
 800d642:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 800d644:	8a7a      	ldrh	r2, [r7, #18]
 800d646:	8abb      	ldrh	r3, [r7, #20]
 800d648:	4313      	orrs	r3, r2
 800d64a:	b29b      	uxth	r3, r3
 800d64c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800d650:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 800d652:	68fb      	ldr	r3, [r7, #12]
 800d654:	8afa      	ldrh	r2, [r7, #22]
 800d656:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer;
 800d658:	68fb      	ldr	r3, [r7, #12]
 800d65a:	8aba      	ldrh	r2, [r7, #20]
 800d65c:	841a      	strh	r2, [r3, #32]
}
 800d65e:	f107 071c 	add.w	r7, r7, #28
 800d662:	46bd      	mov	sp, r7
 800d664:	bc80      	pop	{r7}
 800d666:	4770      	bx	lr

0800d668 <TI4_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 800d668:	b480      	push	{r7}
 800d66a:	b087      	sub	sp, #28
 800d66c:	af00      	add	r7, sp, #0
 800d66e:	60f8      	str	r0, [r7, #12]
 800d670:	8179      	strh	r1, [r7, #10]
 800d672:	813a      	strh	r2, [r7, #8]
 800d674:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
 800d676:	f04f 0300 	mov.w	r3, #0
 800d67a:	82fb      	strh	r3, [r7, #22]
 800d67c:	f04f 0300 	mov.w	r3, #0
 800d680:	82bb      	strh	r3, [r7, #20]
 800d682:	f04f 0300 	mov.w	r3, #0
 800d686:	827b      	strh	r3, [r7, #18]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 800d688:	68fb      	ldr	r3, [r7, #12]
 800d68a:	8c1b      	ldrh	r3, [r3, #32]
 800d68c:	b29b      	uxth	r3, r3
 800d68e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800d692:	b29a      	uxth	r2, r3
 800d694:	68fb      	ldr	r3, [r7, #12]
 800d696:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 800d698:	68fb      	ldr	r3, [r7, #12]
 800d69a:	8b9b      	ldrh	r3, [r3, #28]
 800d69c:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 800d69e:	68fb      	ldr	r3, [r7, #12]
 800d6a0:	8c1b      	ldrh	r3, [r3, #32]
 800d6a2:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 12);
 800d6a4:	897b      	ldrh	r3, [r7, #10]
 800d6a6:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800d6aa:	827b      	strh	r3, [r7, #18]

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 800d6ac:	8afb      	ldrh	r3, [r7, #22]
 800d6ae:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800d6b2:	ea4f 5303 	mov.w	r3, r3, lsl #20
 800d6b6:	ea4f 5313 	mov.w	r3, r3, lsr #20
 800d6ba:	82fb      	strh	r3, [r7, #22]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 800d6bc:	893b      	ldrh	r3, [r7, #8]
 800d6be:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d6c2:	b29a      	uxth	r2, r3
 800d6c4:	8afb      	ldrh	r3, [r7, #22]
 800d6c6:	4313      	orrs	r3, r2
 800d6c8:	82fb      	strh	r3, [r7, #22]
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 800d6ca:	88fb      	ldrh	r3, [r7, #6]
 800d6cc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800d6d0:	b29a      	uxth	r2, r3
 800d6d2:	8afb      	ldrh	r3, [r7, #22]
 800d6d4:	4313      	orrs	r3, r2
 800d6d6:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 800d6d8:	8abb      	ldrh	r3, [r7, #20]
 800d6da:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800d6de:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800d6e2:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800d6e6:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 800d6e8:	8a7a      	ldrh	r2, [r7, #18]
 800d6ea:	8abb      	ldrh	r3, [r7, #20]
 800d6ec:	4313      	orrs	r3, r2
 800d6ee:	b29b      	uxth	r3, r3
 800d6f0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800d6f4:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 800d6f6:	68fb      	ldr	r3, [r7, #12]
 800d6f8:	8afa      	ldrh	r2, [r7, #22]
 800d6fa:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer ;
 800d6fc:	68fb      	ldr	r3, [r7, #12]
 800d6fe:	8aba      	ldrh	r2, [r7, #20]
 800d700:	841a      	strh	r2, [r3, #32]
}
 800d702:	f107 071c 	add.w	r7, r7, #28
 800d706:	46bd      	mov	sp, r7
 800d708:	bc80      	pop	{r7}
 800d70a:	4770      	bx	lr

0800d70c <STM_EVAL_LEDInit>:
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
 800d70c:	b580      	push	{r7, lr}
 800d70e:	b084      	sub	sp, #16
 800d710:	af00      	add	r7, sp, #0
 800d712:	4603      	mov	r3, r0
 800d714:	71fb      	strb	r3, [r7, #7]
  GPIO_InitTypeDef  GPIO_InitStructure;
  
  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 800d716:	79fa      	ldrb	r2, [r7, #7]
 800d718:	f64b 4304 	movw	r3, #48132	; 0xbc04
 800d71c:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d720:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d724:	4618      	mov	r0, r3
 800d726:	f04f 0101 	mov.w	r1, #1
 800d72a:	f7fb fa9f 	bl	8008c6c <RCC_AHB1PeriphClockCmd>

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 800d72e:	79fa      	ldrb	r2, [r7, #7]
 800d730:	f64b 33fc 	movw	r3, #48124	; 0xbbfc
 800d734:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d738:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800d73c:	60bb      	str	r3, [r7, #8]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800d73e:	f04f 0301 	mov.w	r3, #1
 800d742:	733b      	strb	r3, [r7, #12]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800d744:	f04f 0300 	mov.w	r3, #0
 800d748:	73bb      	strb	r3, [r7, #14]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800d74a:	f04f 0301 	mov.w	r3, #1
 800d74e:	73fb      	strb	r3, [r7, #15]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800d750:	f04f 0302 	mov.w	r3, #2
 800d754:	737b      	strb	r3, [r7, #13]
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 800d756:	79fa      	ldrb	r2, [r7, #7]
 800d758:	f240 0334 	movw	r3, #52	; 0x34
 800d75c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d760:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d764:	f107 0308 	add.w	r3, r7, #8
 800d768:	4610      	mov	r0, r2
 800d76a:	4619      	mov	r1, r3
 800d76c:	f7f9 fea8 	bl	80074c0 <GPIO_Init>
}
 800d770:	f107 0710 	add.w	r7, r7, #16
 800d774:	46bd      	mov	sp, r7
 800d776:	bd80      	pop	{r7, pc}

0800d778 <STM_EVAL_LEDOn>:
  *     @arg LED5
  *     @arg LED6  
  * @retval None
  */
void STM_EVAL_LEDOn(Led_TypeDef Led)
{
 800d778:	b480      	push	{r7}
 800d77a:	b083      	sub	sp, #12
 800d77c:	af00      	add	r7, sp, #0
 800d77e:	4603      	mov	r3, r0
 800d780:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->BSRRL = GPIO_PIN[Led];
 800d782:	79fa      	ldrb	r2, [r7, #7]
 800d784:	f240 0334 	movw	r3, #52	; 0x34
 800d788:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d78c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d790:	79f9      	ldrb	r1, [r7, #7]
 800d792:	f64b 33fc 	movw	r3, #48124	; 0xbbfc
 800d796:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d79a:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 800d79e:	8313      	strh	r3, [r2, #24]
}
 800d7a0:	f107 070c 	add.w	r7, r7, #12
 800d7a4:	46bd      	mov	sp, r7
 800d7a6:	bc80      	pop	{r7}
 800d7a8:	4770      	bx	lr
 800d7aa:	bf00      	nop

0800d7ac <STM_EVAL_LEDOff>:
  *     @arg LED5
  *     @arg LED6 
  * @retval None
  */
void STM_EVAL_LEDOff(Led_TypeDef Led)
{
 800d7ac:	b480      	push	{r7}
 800d7ae:	b083      	sub	sp, #12
 800d7b0:	af00      	add	r7, sp, #0
 800d7b2:	4603      	mov	r3, r0
 800d7b4:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->BSRRH = GPIO_PIN[Led];  
 800d7b6:	79fa      	ldrb	r2, [r7, #7]
 800d7b8:	f240 0334 	movw	r3, #52	; 0x34
 800d7bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d7c0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d7c4:	79f9      	ldrb	r1, [r7, #7]
 800d7c6:	f64b 33fc 	movw	r3, #48124	; 0xbbfc
 800d7ca:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d7ce:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 800d7d2:	8353      	strh	r3, [r2, #26]
}
 800d7d4:	f107 070c 	add.w	r7, r7, #12
 800d7d8:	46bd      	mov	sp, r7
 800d7da:	bc80      	pop	{r7}
 800d7dc:	4770      	bx	lr
 800d7de:	bf00      	nop

0800d7e0 <STM_EVAL_LEDToggle>:
  *     @arg LED5
  *     @arg LED6  
  * @retval None
  */
void STM_EVAL_LEDToggle(Led_TypeDef Led)
{
 800d7e0:	b480      	push	{r7}
 800d7e2:	b083      	sub	sp, #12
 800d7e4:	af00      	add	r7, sp, #0
 800d7e6:	4603      	mov	r3, r0
 800d7e8:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->ODR ^= GPIO_PIN[Led];
 800d7ea:	79fa      	ldrb	r2, [r7, #7]
 800d7ec:	f240 0334 	movw	r3, #52	; 0x34
 800d7f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d7f4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d7f8:	79f9      	ldrb	r1, [r7, #7]
 800d7fa:	f240 0334 	movw	r3, #52	; 0x34
 800d7fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d802:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800d806:	695b      	ldr	r3, [r3, #20]
 800d808:	4619      	mov	r1, r3
 800d80a:	79f8      	ldrb	r0, [r7, #7]
 800d80c:	f64b 33fc 	movw	r3, #48124	; 0xbbfc
 800d810:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d814:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
 800d818:	404b      	eors	r3, r1
 800d81a:	6153      	str	r3, [r2, #20]
}
 800d81c:	f107 070c 	add.w	r7, r7, #12
 800d820:	46bd      	mov	sp, r7
 800d822:	bc80      	pop	{r7}
 800d824:	4770      	bx	lr
 800d826:	bf00      	nop

0800d828 <STM_EVAL_PBInit>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval None
  */
void STM_EVAL_PBInit(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
{
 800d828:	b580      	push	{r7, lr}
 800d82a:	b088      	sub	sp, #32
 800d82c:	af00      	add	r7, sp, #0
 800d82e:	4602      	mov	r2, r0
 800d830:	460b      	mov	r3, r1
 800d832:	71fa      	strb	r2, [r7, #7]
 800d834:	71bb      	strb	r3, [r7, #6]
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the BUTTON Clock */
  RCC_AHB1PeriphClockCmd(BUTTON_CLK[Button], ENABLE);
 800d836:	79fa      	ldrb	r2, [r7, #7]
 800d838:	f64b 4318 	movw	r3, #48152	; 0xbc18
 800d83c:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d840:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d844:	4618      	mov	r0, r3
 800d846:	f04f 0101 	mov.w	r1, #1
 800d84a:	f7fb fa0f 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800d84e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800d852:	f04f 0101 	mov.w	r1, #1
 800d856:	f7fb fab9 	bl	8008dcc <RCC_APB2PeriphClockCmd>

  /* Configure Button pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800d85a:	f04f 0300 	mov.w	r3, #0
 800d85e:	773b      	strb	r3, [r7, #28]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800d860:	f04f 0300 	mov.w	r3, #0
 800d864:	77fb      	strb	r3, [r7, #31]
  GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
 800d866:	79fa      	ldrb	r2, [r7, #7]
 800d868:	f64b 4314 	movw	r3, #48148	; 0xbc14
 800d86c:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d870:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800d874:	61bb      	str	r3, [r7, #24]
  GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);
 800d876:	79fa      	ldrb	r2, [r7, #7]
 800d878:	f240 0344 	movw	r3, #68	; 0x44
 800d87c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d880:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d884:	f107 0318 	add.w	r3, r7, #24
 800d888:	4610      	mov	r0, r2
 800d88a:	4619      	mov	r1, r3
 800d88c:	f7f9 fe18 	bl	80074c0 <GPIO_Init>

  if (Button_Mode == BUTTON_MODE_EXTI)
 800d890:	79bb      	ldrb	r3, [r7, #6]
 800d892:	2b01      	cmp	r3, #1
 800d894:	d13a      	bne.n	800d90c <STM_EVAL_PBInit+0xe4>
  {
    /* Connect Button EXTI Line to Button GPIO Pin */
    SYSCFG_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);
 800d896:	79fa      	ldrb	r2, [r7, #7]
 800d898:	f64b 4320 	movw	r3, #48160	; 0xbc20
 800d89c:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d8a0:	5c9a      	ldrb	r2, [r3, r2]
 800d8a2:	79f9      	ldrb	r1, [r7, #7]
 800d8a4:	f64b 4324 	movw	r3, #48164	; 0xbc24
 800d8a8:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d8ac:	5c5b      	ldrb	r3, [r3, r1]
 800d8ae:	4610      	mov	r0, r2
 800d8b0:	4619      	mov	r1, r3
 800d8b2:	f7fd ffd9 	bl	800b868 <SYSCFG_EXTILineConfig>

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
 800d8b6:	79fa      	ldrb	r2, [r7, #7]
 800d8b8:	f64b 431c 	movw	r3, #48156	; 0xbc1c
 800d8bc:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d8c0:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800d8c4:	613b      	str	r3, [r7, #16]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 800d8c6:	f04f 0300 	mov.w	r3, #0
 800d8ca:	753b      	strb	r3, [r7, #20]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  
 800d8cc:	f04f 0308 	mov.w	r3, #8
 800d8d0:	757b      	strb	r3, [r7, #21]
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800d8d2:	f04f 0301 	mov.w	r3, #1
 800d8d6:	75bb      	strb	r3, [r7, #22]
    EXTI_Init(&EXTI_InitStructure);
 800d8d8:	f107 0310 	add.w	r3, r7, #16
 800d8dc:	4618      	mov	r0, r3
 800d8de:	f7f9 fbf3 	bl	80070c8 <EXTI_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
 800d8e2:	79fa      	ldrb	r2, [r7, #7]
 800d8e4:	f64b 4328 	movw	r3, #48168	; 0xbc28
 800d8e8:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d8ec:	5c9b      	ldrb	r3, [r3, r2]
 800d8ee:	733b      	strb	r3, [r7, #12]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
 800d8f0:	f04f 030f 	mov.w	r3, #15
 800d8f4:	737b      	strb	r3, [r7, #13]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
 800d8f6:	f04f 030f 	mov.w	r3, #15
 800d8fa:	73bb      	strb	r3, [r7, #14]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800d8fc:	f04f 0301 	mov.w	r3, #1
 800d900:	73fb      	strb	r3, [r7, #15]

    NVIC_Init(&NVIC_InitStructure); 
 800d902:	f107 030c 	add.w	r3, r7, #12
 800d906:	4618      	mov	r0, r3
 800d908:	f7f8 fc32 	bl	8006170 <NVIC_Init>
  }
}
 800d90c:	f107 0720 	add.w	r7, r7, #32
 800d910:	46bd      	mov	sp, r7
 800d912:	bd80      	pop	{r7, pc}

0800d914 <STM_EVAL_PBGetState>:
  * @param  Button: Specifies the Button to be checked.
  *   This parameter should be: BUTTON_USER  
  * @retval The Button GPIO pin value.
  */
uint32_t STM_EVAL_PBGetState(Button_TypeDef Button)
{
 800d914:	b580      	push	{r7, lr}
 800d916:	b082      	sub	sp, #8
 800d918:	af00      	add	r7, sp, #0
 800d91a:	4603      	mov	r3, r0
 800d91c:	71fb      	strb	r3, [r7, #7]
  return GPIO_ReadInputDataBit(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 800d91e:	79fa      	ldrb	r2, [r7, #7]
 800d920:	f240 0344 	movw	r3, #68	; 0x44
 800d924:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d928:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d92c:	79f9      	ldrb	r1, [r7, #7]
 800d92e:	f64b 4314 	movw	r3, #48148	; 0xbc14
 800d932:	f6c0 0302 	movt	r3, #2050	; 0x802
 800d936:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 800d93a:	4610      	mov	r0, r2
 800d93c:	4619      	mov	r1, r3
 800d93e:	f7f9 fea9 	bl	8007694 <GPIO_ReadInputDataBit>
 800d942:	4603      	mov	r3, r0
}
 800d944:	4618      	mov	r0, r3
 800d946:	f107 0708 	add.w	r7, r7, #8
 800d94a:	46bd      	mov	sp, r7
 800d94c:	bd80      	pop	{r7, pc}
 800d94e:	bf00      	nop

0800d950 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field
 */
static __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800d950:	b480      	push	{r7}
 800d952:	b085      	sub	sp, #20
 800d954:	af00      	add	r7, sp, #0
 800d956:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
 800d958:	687b      	ldr	r3, [r7, #4]
 800d95a:	f003 0307 	and.w	r3, r3, #7
 800d95e:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800d960:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800d964:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800d968:	68db      	ldr	r3, [r3, #12]
 800d96a:	60bb      	str	r3, [r7, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 800d96c:	68ba      	ldr	r2, [r7, #8]
 800d96e:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800d972:	4013      	ands	r3, r2
 800d974:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
 800d976:	68fb      	ldr	r3, [r7, #12]
 800d978:	ea4f 2203 	mov.w	r2, r3, lsl #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
 800d97c:	68bb      	ldr	r3, [r7, #8]
 800d97e:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 800d980:	f043 63be 	orr.w	r3, r3, #99614720	; 0x5f00000
 800d984:	f443 2320 	orr.w	r3, r3, #655360	; 0xa0000
 800d988:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800d98a:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800d98e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800d992:	68ba      	ldr	r2, [r7, #8]
 800d994:	60da      	str	r2, [r3, #12]
}
 800d996:	f107 0714 	add.w	r7, r7, #20
 800d99a:	46bd      	mov	sp, r7
 800d99c:	bc80      	pop	{r7}
 800d99e:	4770      	bx	lr

0800d9a0 <EVAL_AUDIO_SetAudioInterface>:
  * @brief  Set the current audio interface (I2S or DAC).
  * @param  Interface: AUDIO_INTERFACE_I2S or AUDIO_INTERFACE_DAC
  * @retval None
  */
void EVAL_AUDIO_SetAudioInterface(uint32_t Interface)
{    
 800d9a0:	b480      	push	{r7}
 800d9a2:	b083      	sub	sp, #12
 800d9a4:	af00      	add	r7, sp, #0
 800d9a6:	6078      	str	r0, [r7, #4]
  CurrAudioInterface = Interface;
 800d9a8:	f240 0354 	movw	r3, #84	; 0x54
 800d9ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9b0:	687a      	ldr	r2, [r7, #4]
 800d9b2:	601a      	str	r2, [r3, #0]
  
  if (CurrAudioInterface == AUDIO_INTERFACE_I2S)
 800d9b4:	f240 0354 	movw	r3, #84	; 0x54
 800d9b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9bc:	681b      	ldr	r3, [r3, #0]
 800d9be:	2b01      	cmp	r3, #1
 800d9c0:	d14a      	bne.n	800da58 <EVAL_AUDIO_SetAudioInterface+0xb8>
  {
    /* DMA Stream definitions */
    AUDIO_MAL_DMA_CLOCK    = AUDIO_I2S_DMA_CLOCK;
 800d9c2:	f240 0358 	movw	r3, #88	; 0x58
 800d9c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9ca:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 800d9ce:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_STREAM   = AUDIO_I2S_DMA_STREAM;        
 800d9d0:	f240 035c 	movw	r3, #92	; 0x5c
 800d9d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9d8:	f246 02b8 	movw	r2, #24760	; 0x60b8
 800d9dc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800d9e0:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_DREG     = AUDIO_I2S_DMA_DREG;
 800d9e2:	f240 0360 	movw	r3, #96	; 0x60
 800d9e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9ea:	f643 420c 	movw	r2, #15372	; 0x3c0c
 800d9ee:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800d9f2:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_CHANNEL  = AUDIO_I2S_DMA_CHANNEL;
 800d9f4:	f640 2300 	movw	r3, #2560	; 0xa00
 800d9f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9fc:	f04f 0200 	mov.w	r2, #0
 800da00:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_IRQ      = AUDIO_I2S_DMA_IRQ  ;
 800da02:	f240 0364 	movw	r3, #100	; 0x64
 800da06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da0a:	f04f 022f 	mov.w	r2, #47	; 0x2f
 800da0e:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_TC  = AUDIO_I2S_DMA_FLAG_TC;
 800da10:	f240 0368 	movw	r3, #104	; 0x68
 800da14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da18:	f04f 5220 	mov.w	r2, #671088640	; 0x28000000
 800da1c:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_HT  = AUDIO_I2S_DMA_FLAG_HT;
 800da1e:	f240 036c 	movw	r3, #108	; 0x6c
 800da22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da26:	f04f 5210 	mov.w	r2, #603979776	; 0x24000000
 800da2a:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_FE  = AUDIO_I2S_DMA_FLAG_FE;
 800da2c:	f240 0370 	movw	r3, #112	; 0x70
 800da30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da34:	f04f 5201 	mov.w	r2, #541065216	; 0x20400000
 800da38:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_TE  = AUDIO_I2S_DMA_FLAG_TE;
 800da3a:	f240 0374 	movw	r3, #116	; 0x74
 800da3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da42:	f04f 5208 	mov.w	r2, #570425344	; 0x22000000
 800da46:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_DME = AUDIO_I2S_DMA_FLAG_DME;
 800da48:	f240 0378 	movw	r3, #120	; 0x78
 800da4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da50:	f04f 5204 	mov.w	r2, #553648128	; 0x21000000
 800da54:	601a      	str	r2, [r3, #0]
 800da56:	e056      	b.n	800db06 <EVAL_AUDIO_SetAudioInterface+0x166>
  }
  else if (Interface == AUDIO_INTERFACE_DAC)
 800da58:	687b      	ldr	r3, [r7, #4]
 800da5a:	2b02      	cmp	r3, #2
 800da5c:	d153      	bne.n	800db06 <EVAL_AUDIO_SetAudioInterface+0x166>
  {
    /* DMA Stream definitions */
    AUDIO_MAL_DMA_CLOCK    = AUDIO_DAC_DMA_CLOCK;
 800da5e:	f240 0358 	movw	r3, #88	; 0x58
 800da62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da66:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 800da6a:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_STREAM   = AUDIO_DAC_DMA_STREAM;        
 800da6c:	f240 035c 	movw	r3, #92	; 0x5c
 800da70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da74:	f246 0210 	movw	r2, #24592	; 0x6010
 800da78:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800da7c:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_DREG     = AUDIO_DAC_DMA_DREG;
 800da7e:	f240 0360 	movw	r3, #96	; 0x60
 800da82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da86:	f247 420c 	movw	r2, #29708	; 0x740c
 800da8a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800da8e:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_CHANNEL  = AUDIO_DAC_DMA_CHANNEL;
 800da90:	f640 2300 	movw	r3, #2560	; 0xa00
 800da94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800da98:	f04f 0200 	mov.w	r2, #0
 800da9c:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_IRQ      = AUDIO_DAC_DMA_IRQ  ;
 800da9e:	f240 0364 	movw	r3, #100	; 0x64
 800daa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800daa6:	f04f 020b 	mov.w	r2, #11
 800daaa:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_TC  = AUDIO_DAC_DMA_FLAG_TC;
 800daac:	f240 0368 	movw	r3, #104	; 0x68
 800dab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dab4:	f04f 0220 	mov.w	r2, #32
 800dab8:	f2c1 0200 	movt	r2, #4096	; 0x1000
 800dabc:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_HT  = AUDIO_DAC_DMA_FLAG_HT;
 800dabe:	f240 036c 	movw	r3, #108	; 0x6c
 800dac2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dac6:	f04f 0210 	mov.w	r2, #16
 800daca:	f2c1 0200 	movt	r2, #4096	; 0x1000
 800dace:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_FE  = AUDIO_DAC_DMA_FLAG_FE;
 800dad0:	f240 0370 	movw	r3, #112	; 0x70
 800dad4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dad8:	f04f 0201 	mov.w	r2, #1
 800dadc:	f2c1 0280 	movt	r2, #4224	; 0x1080
 800dae0:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_TE  = AUDIO_DAC_DMA_FLAG_TE;
 800dae2:	f240 0374 	movw	r3, #116	; 0x74
 800dae6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800daea:	f04f 0208 	mov.w	r2, #8
 800daee:	f2c1 0200 	movt	r2, #4096	; 0x1000
 800daf2:	601a      	str	r2, [r3, #0]
    AUDIO_MAL_DMA_FLAG_DME = AUDIO_DAC_DMA_FLAG_DME;    
 800daf4:	f240 0378 	movw	r3, #120	; 0x78
 800daf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dafc:	f04f 0204 	mov.w	r2, #4
 800db00:	f2c1 0280 	movt	r2, #4224	; 0x1080
 800db04:	601a      	str	r2, [r3, #0]
  }
}
 800db06:	f107 070c 	add.w	r7, r7, #12
 800db0a:	46bd      	mov	sp, r7
 800db0c:	bc80      	pop	{r7}
 800db0e:	4770      	bx	lr

0800db10 <EVAL_AUDIO_Init>:
  * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
  * @param  AudioFreq: Audio frequency used to play the audio stream.
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
{    
 800db10:	b580      	push	{r7, lr}
 800db12:	b082      	sub	sp, #8
 800db14:	af00      	add	r7, sp, #0
 800db16:	460b      	mov	r3, r1
 800db18:	603a      	str	r2, [r7, #0]
 800db1a:	4602      	mov	r2, r0
 800db1c:	80fa      	strh	r2, [r7, #6]
 800db1e:	717b      	strb	r3, [r7, #5]
  /* Perform low layer Codec initialization */
  if (Codec_Init(OutputDevice, VOLUME_CONVERT(Volume), AudioFreq) != 0)
 800db20:	797b      	ldrb	r3, [r7, #5]
 800db22:	2b64      	cmp	r3, #100	; 0x64
 800db24:	d811      	bhi.n	800db4a <EVAL_AUDIO_Init+0x3a>
 800db26:	797a      	ldrb	r2, [r7, #5]
 800db28:	4613      	mov	r3, r2
 800db2a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800db2e:	1a9a      	subs	r2, r3, r2
 800db30:	f248 531f 	movw	r3, #34079	; 0x851f
 800db34:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 800db38:	fb83 1302 	smull	r1, r3, r3, r2
 800db3c:	ea4f 1163 	mov.w	r1, r3, asr #5
 800db40:	ea4f 73e2 	mov.w	r3, r2, asr #31
 800db44:	1acb      	subs	r3, r1, r3
 800db46:	b2db      	uxtb	r3, r3
 800db48:	e001      	b.n	800db4e <EVAL_AUDIO_Init+0x3e>
 800db4a:	f04f 0364 	mov.w	r3, #100	; 0x64
 800db4e:	88fa      	ldrh	r2, [r7, #6]
 800db50:	4610      	mov	r0, r2
 800db52:	4619      	mov	r1, r3
 800db54:	683a      	ldr	r2, [r7, #0]
 800db56:	f000 f9b9 	bl	800decc <Codec_Init>
 800db5a:	4603      	mov	r3, r0
 800db5c:	2b00      	cmp	r3, #0
 800db5e:	d002      	beq.n	800db66 <EVAL_AUDIO_Init+0x56>
  {
    return 1;                
 800db60:	f04f 0301 	mov.w	r3, #1
 800db64:	e003      	b.n	800db6e <EVAL_AUDIO_Init+0x5e>
  }
  else
  {    
    /* I2S data transfer preparation:
    Prepare the Media to be used for the audio transfer from memory to I2S peripheral */
    Audio_MAL_Init();
 800db66:	f000 feb5 	bl	800e8d4 <Audio_MAL_Init>
    
    /* Return 0 when all operations are OK */
    return 0;
 800db6a:	f04f 0300 	mov.w	r3, #0
  }
}
 800db6e:	4618      	mov	r0, r3
 800db70:	f107 0708 	add.w	r7, r7, #8
 800db74:	46bd      	mov	sp, r7
 800db76:	bd80      	pop	{r7, pc}

0800db78 <EVAL_AUDIO_DeInit>:
  *         by EVAL_AUDIO_Init() function). 
  * @param  None
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_DeInit(void)
{ 
 800db78:	b580      	push	{r7, lr}
 800db7a:	af00      	add	r7, sp, #0
  /* DeInitialize the Media layer */
  Audio_MAL_DeInit();
 800db7c:	f000 ffa4 	bl	800eac8 <Audio_MAL_DeInit>
  
  /* DeInitialize Codec */  
  Codec_DeInit();  
 800db80:	f000 fa78 	bl	800e074 <Codec_DeInit>
  
  return 0;
 800db84:	f04f 0300 	mov.w	r3, #0
}
 800db88:	4618      	mov	r0, r3
 800db8a:	bd80      	pop	{r7, pc}

0800db8c <EVAL_AUDIO_Play>:
  * @param  pBuffer: Pointer to the buffer 
  * @param  Size: Number of audio data BYTES.
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_Play(int16_t* pBuffer, uint32_t Size)
{
 800db8c:	b580      	push	{r7, lr}
 800db8e:	b082      	sub	sp, #8
 800db90:	af00      	add	r7, sp, #0
 800db92:	6078      	str	r0, [r7, #4]
 800db94:	6039      	str	r1, [r7, #0]
  /* Set the total number of data to be played (count in half-word) */
  AudioTotalSize = Size;
 800db96:	f240 0348 	movw	r3, #72	; 0x48
 800db9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800db9e:	683a      	ldr	r2, [r7, #0]
 800dba0:	601a      	str	r2, [r3, #0]

  /* Call the audio Codec Play function */
  Codec_Play();
 800dba2:	f000 fa85 	bl	800e0b0 <Codec_Play>
  
  /* Update the Media layer and enable it for play */  
  Audio_MAL_Play((uint32_t)pBuffer, Size);
 800dba6:	687b      	ldr	r3, [r7, #4]
 800dba8:	4618      	mov	r0, r3
 800dbaa:	6839      	ldr	r1, [r7, #0]
 800dbac:	f000 ffba 	bl	800eb24 <Audio_MAL_Play>
  
  /* Update the remaining number of data to be played */
  // Size/2 was bull shit caused overflow
  AudioRemSize = (Size) - DMA_MAX(AudioTotalSize);
 800dbb0:	f240 0348 	movw	r3, #72	; 0x48
 800dbb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dbb8:	681a      	ldr	r2, [r3, #0]
 800dbba:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800dbbe:	429a      	cmp	r2, r3
 800dbc0:	bf38      	it	cc
 800dbc2:	4613      	movcc	r3, r2
 800dbc4:	683a      	ldr	r2, [r7, #0]
 800dbc6:	1ad2      	subs	r2, r2, r3
 800dbc8:	f240 034c 	movw	r3, #76	; 0x4c
 800dbcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dbd0:	601a      	str	r2, [r3, #0]
  
  /* Update the current audio pointer position */
  CurrentPos = (uint16_t*)pBuffer + DMA_MAX(AudioTotalSize);
 800dbd2:	f240 0348 	movw	r3, #72	; 0x48
 800dbd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dbda:	681a      	ldr	r2, [r3, #0]
 800dbdc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800dbe0:	429a      	cmp	r2, r3
 800dbe2:	bf38      	it	cc
 800dbe4:	4613      	movcc	r3, r2
 800dbe6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800dbea:	687a      	ldr	r2, [r7, #4]
 800dbec:	18d2      	adds	r2, r2, r3
 800dbee:	f244 5384 	movw	r3, #17796	; 0x4584
 800dbf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dbf6:	601a      	str	r2, [r3, #0]
  
  return 0;
 800dbf8:	f04f 0300 	mov.w	r3, #0
}
 800dbfc:	4618      	mov	r0, r3
 800dbfe:	f107 0708 	add.w	r7, r7, #8
 800dc02:	46bd      	mov	sp, r7
 800dc04:	bd80      	pop	{r7, pc}
 800dc06:	bf00      	nop

0800dc08 <EVAL_AUDIO_PauseResume>:
  * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
  *         from 0) to resume. 
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_PauseResume(uint32_t Cmd)
{    
 800dc08:	b580      	push	{r7, lr}
 800dc0a:	b082      	sub	sp, #8
 800dc0c:	af00      	add	r7, sp, #0
 800dc0e:	6078      	str	r0, [r7, #4]
  /* Call the Audio Codec Pause/Resume function */
  if (Codec_PauseResume(Cmd) != 0)
 800dc10:	6878      	ldr	r0, [r7, #4]
 800dc12:	f000 fa55 	bl	800e0c0 <Codec_PauseResume>
 800dc16:	4603      	mov	r3, r0
 800dc18:	2b00      	cmp	r3, #0
 800dc1a:	d002      	beq.n	800dc22 <EVAL_AUDIO_PauseResume+0x1a>
  {
    return 1;
 800dc1c:	f04f 0301 	mov.w	r3, #1
 800dc20:	e006      	b.n	800dc30 <EVAL_AUDIO_PauseResume+0x28>
  }
  else
  {
    /* Call the Media layer pause/resume function */
    Audio_MAL_PauseResume(Cmd, 0);
 800dc22:	6878      	ldr	r0, [r7, #4]
 800dc24:	f04f 0100 	mov.w	r1, #0
 800dc28:	f000 ffe6 	bl	800ebf8 <Audio_MAL_PauseResume>
    
    /* Return 0 if all operations are OK */
    return 0;
 800dc2c:	f04f 0300 	mov.w	r3, #0
  }
}
 800dc30:	4618      	mov	r0, r3
 800dc32:	f107 0708 	add.w	r7, r7, #8
 800dc36:	46bd      	mov	sp, r7
 800dc38:	bd80      	pop	{r7, pc}
 800dc3a:	bf00      	nop

0800dc3c <EVAL_AUDIO_Stop>:
  *           - CODEC_PDWN_HW: completely shut down the codec (physically). 
  *                            Then need to reconfigure the Codec after power on.  
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_Stop(uint32_t Option)
{
 800dc3c:	b580      	push	{r7, lr}
 800dc3e:	b082      	sub	sp, #8
 800dc40:	af00      	add	r7, sp, #0
 800dc42:	6078      	str	r0, [r7, #4]
  /* Call Audio Codec Stop function */
  if (Codec_Stop(Option) != 0)
 800dc44:	6878      	ldr	r0, [r7, #4]
 800dc46:	f000 fa7f 	bl	800e148 <Codec_Stop>
 800dc4a:	4603      	mov	r3, r0
 800dc4c:	2b00      	cmp	r3, #0
 800dc4e:	d002      	beq.n	800dc56 <EVAL_AUDIO_Stop+0x1a>
  {
    return 1;
 800dc50:	f04f 0301 	mov.w	r3, #1
 800dc54:	e00d      	b.n	800dc72 <EVAL_AUDIO_Stop+0x36>
  }
  else
  {
    /* Call Media layer Stop function */
    Audio_MAL_Stop();
 800dc56:	f001 f817 	bl	800ec88 <Audio_MAL_Stop>
    
    /* Update the remaining data number */
    AudioRemSize = AudioTotalSize;    
 800dc5a:	f240 0348 	movw	r3, #72	; 0x48
 800dc5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dc62:	681a      	ldr	r2, [r3, #0]
 800dc64:	f240 034c 	movw	r3, #76	; 0x4c
 800dc68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dc6c:	601a      	str	r2, [r3, #0]
    
    /* Return 0 when all operations are correctly done */
    return 0;
 800dc6e:	f04f 0300 	mov.w	r3, #0
  }
}
 800dc72:	4618      	mov	r0, r3
 800dc74:	f107 0708 	add.w	r7, r7, #8
 800dc78:	46bd      	mov	sp, r7
 800dc7a:	bd80      	pop	{r7, pc}

0800dc7c <EVAL_AUDIO_VolumeCtl>:
  * @param  Volume: Volume level to be set in percentage from 0% to 100% (0 for 
  *         Mute and 100 for Max volume level).
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_VolumeCtl(uint8_t Volume)
{
 800dc7c:	b580      	push	{r7, lr}
 800dc7e:	b082      	sub	sp, #8
 800dc80:	af00      	add	r7, sp, #0
 800dc82:	4603      	mov	r3, r0
 800dc84:	71fb      	strb	r3, [r7, #7]
  /* Call the codec volume control function with converted volume value */
  return (Codec_VolumeCtrl(VOLUME_CONVERT(Volume)));
 800dc86:	79fb      	ldrb	r3, [r7, #7]
 800dc88:	2b64      	cmp	r3, #100	; 0x64
 800dc8a:	d811      	bhi.n	800dcb0 <EVAL_AUDIO_VolumeCtl+0x34>
 800dc8c:	79fa      	ldrb	r2, [r7, #7]
 800dc8e:	4613      	mov	r3, r2
 800dc90:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800dc94:	1a9a      	subs	r2, r3, r2
 800dc96:	f248 531f 	movw	r3, #34079	; 0x851f
 800dc9a:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 800dc9e:	fb83 1302 	smull	r1, r3, r3, r2
 800dca2:	ea4f 1163 	mov.w	r1, r3, asr #5
 800dca6:	ea4f 73e2 	mov.w	r3, r2, asr #31
 800dcaa:	1acb      	subs	r3, r1, r3
 800dcac:	b2db      	uxtb	r3, r3
 800dcae:	e001      	b.n	800dcb4 <EVAL_AUDIO_VolumeCtl+0x38>
 800dcb0:	f04f 0364 	mov.w	r3, #100	; 0x64
 800dcb4:	4618      	mov	r0, r3
 800dcb6:	f000 fa7f 	bl	800e1b8 <Codec_VolumeCtrl>
 800dcba:	4603      	mov	r3, r0
}
 800dcbc:	4618      	mov	r0, r3
 800dcbe:	f107 0708 	add.w	r7, r7, #8
 800dcc2:	46bd      	mov	sp, r7
 800dcc4:	bd80      	pop	{r7, pc}
 800dcc6:	bf00      	nop

0800dcc8 <EVAL_AUDIO_Mute>:
  * @param  Command: could be AUDIO_MUTE_ON to mute sound or AUDIO_MUTE_OFF to 
  *         unmute the codec and restore previous volume level.
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t EVAL_AUDIO_Mute(uint32_t Cmd)
{ 
 800dcc8:	b580      	push	{r7, lr}
 800dcca:	b082      	sub	sp, #8
 800dccc:	af00      	add	r7, sp, #0
 800dcce:	6078      	str	r0, [r7, #4]
  /* Call the Codec Mute function */
  return (Codec_Mute(Cmd));
 800dcd0:	6878      	ldr	r0, [r7, #4]
 800dcd2:	f000 fab7 	bl	800e244 <Codec_Mute>
 800dcd6:	4603      	mov	r3, r0
}
 800dcd8:	4618      	mov	r0, r3
 800dcda:	f107 0708 	add.w	r7, r7, #8
 800dcde:	46bd      	mov	sp, r7
 800dce0:	bd80      	pop	{r7, pc}
 800dce2:	bf00      	nop

0800dce4 <Audio_MAL_IRQHandler>:
  * @brief  This function handles main Media layer interrupt. 
  * @param  None
  * @retval 0 if correct communication, else wrong communication
  */
static void Audio_MAL_IRQHandler(void)
{    
 800dce4:	b580      	push	{r7, lr}
 800dce6:	af00      	add	r7, sp, #0
  uint32_t Size = AudioRemSize;
#endif /* AUDIO_MAL_MODE_NORMAL */
  
#ifdef AUDIO_MAL_DMA_IT_TC_EN
  /* Transfer complete interrupt */
  if (DMA_GetFlagStatus(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC) != RESET)
 800dce8:	f240 035c 	movw	r3, #92	; 0x5c
 800dcec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dcf0:	681a      	ldr	r2, [r3, #0]
 800dcf2:	f240 0368 	movw	r3, #104	; 0x68
 800dcf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dcfa:	681b      	ldr	r3, [r3, #0]
 800dcfc:	4610      	mov	r0, r2
 800dcfe:	4619      	mov	r1, r3
 800dd00:	f7f9 f870 	bl	8006de4 <DMA_GetFlagStatus>
 800dd04:	4603      	mov	r3, r0
 800dd06:	2b00      	cmp	r3, #0
 800dd08:	f000 80ab 	beq.w	800de62 <Audio_MAL_IRQHandler+0x17e>
  {         
 #ifdef AUDIO_MAL_MODE_NORMAL
    /* Check if the end of file has been reached */
    if (AudioRemSize > 0)
 800dd0c:	f240 034c 	movw	r3, #76	; 0x4c
 800dd10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dd14:	681b      	ldr	r3, [r3, #0]
 800dd16:	2b00      	cmp	r3, #0
 800dd18:	f000 8081 	beq.w	800de1e <Audio_MAL_IRQHandler+0x13a>
    {      
      /* Wait the DMA Stream to be effectively disabled */
      while (DMA_GetCmdStatus(AUDIO_MAL_DMA_STREAM) != DISABLE)
 800dd1c:	bf00      	nop
 800dd1e:	f240 035c 	movw	r3, #92	; 0x5c
 800dd22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dd26:	681b      	ldr	r3, [r3, #0]
 800dd28:	4618      	mov	r0, r3
 800dd2a:	f7f9 f82b 	bl	8006d84 <DMA_GetCmdStatus>
 800dd2e:	4603      	mov	r3, r0
 800dd30:	2b00      	cmp	r3, #0
 800dd32:	d1f4      	bne.n	800dd1e <Audio_MAL_IRQHandler+0x3a>
      {}
      
      /* Clear the Interrupt flag */
      DMA_ClearFlag(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC); 
 800dd34:	f240 035c 	movw	r3, #92	; 0x5c
 800dd38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dd3c:	681a      	ldr	r2, [r3, #0]
 800dd3e:	f240 0368 	movw	r3, #104	; 0x68
 800dd42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dd46:	681b      	ldr	r3, [r3, #0]
 800dd48:	4610      	mov	r0, r2
 800dd4a:	4619      	mov	r1, r3
 800dd4c:	f7f9 f88e 	bl	8006e6c <DMA_ClearFlag>
           
      /* Re-Configure the buffer address and size */
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t) CurrentPos;
 800dd50:	f244 5384 	movw	r3, #17796	; 0x4584
 800dd54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dd58:	681b      	ldr	r3, [r3, #0]
 800dd5a:	461a      	mov	r2, r3
 800dd5c:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800dd60:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dd64:	609a      	str	r2, [r3, #8]
      DMA_InitStructure.DMA_BufferSize = (uint32_t) (DMA_MAX(AudioRemSize));
 800dd66:	f240 034c 	movw	r3, #76	; 0x4c
 800dd6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dd6e:	681a      	ldr	r2, [r3, #0]
 800dd70:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800dd74:	429a      	cmp	r2, r3
 800dd76:	bf28      	it	cs
 800dd78:	461a      	movcs	r2, r3
 800dd7a:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800dd7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dd82:	611a      	str	r2, [r3, #16]
            
      /* Configure the DMA Stream with the new parameters */
      DMA_Init(AUDIO_MAL_DMA_STREAM, &DMA_InitStructure);
 800dd84:	f240 035c 	movw	r3, #92	; 0x5c
 800dd88:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dd8c:	681b      	ldr	r3, [r3, #0]
 800dd8e:	4618      	mov	r0, r3
 800dd90:	f244 51c4 	movw	r1, #17860	; 0x45c4
 800dd94:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800dd98:	f7f8 fe7e 	bl	8006a98 <DMA_Init>
      
      /* Enable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE);    
 800dd9c:	f240 035c 	movw	r3, #92	; 0x5c
 800dda0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dda4:	681b      	ldr	r3, [r3, #0]
 800dda6:	4618      	mov	r0, r3
 800dda8:	f04f 0101 	mov.w	r1, #1
 800ddac:	f7f8 ff12 	bl	8006bd4 <DMA_Cmd>
      
      /* Update the current pointer position */
      CurrentPos += DMA_MAX(AudioRemSize);        
 800ddb0:	f244 5384 	movw	r3, #17796	; 0x4584
 800ddb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ddb8:	681a      	ldr	r2, [r3, #0]
 800ddba:	f240 034c 	movw	r3, #76	; 0x4c
 800ddbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ddc2:	6819      	ldr	r1, [r3, #0]
 800ddc4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800ddc8:	4299      	cmp	r1, r3
 800ddca:	bf38      	it	cc
 800ddcc:	460b      	movcc	r3, r1
 800ddce:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800ddd2:	18d2      	adds	r2, r2, r3
 800ddd4:	f244 5384 	movw	r3, #17796	; 0x4584
 800ddd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dddc:	601a      	str	r2, [r3, #0]
      
      /* Update the remaining number of data to be played */
      AudioRemSize -= DMA_MAX(AudioRemSize);   
 800ddde:	f240 034c 	movw	r3, #76	; 0x4c
 800dde2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dde6:	681a      	ldr	r2, [r3, #0]
 800dde8:	f240 034c 	movw	r3, #76	; 0x4c
 800ddec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ddf0:	6819      	ldr	r1, [r3, #0]
 800ddf2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800ddf6:	4299      	cmp	r1, r3
 800ddf8:	bf38      	it	cc
 800ddfa:	460b      	movcc	r3, r1
 800ddfc:	1ad2      	subs	r2, r2, r3
 800ddfe:	f240 034c 	movw	r3, #76	; 0x4c
 800de02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800de06:	601a      	str	r2, [r3, #0]
        /* Enable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE); 
 800de08:	f240 035c 	movw	r3, #92	; 0x5c
 800de0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800de10:	681b      	ldr	r3, [r3, #0]
 800de12:	4618      	mov	r0, r3
 800de14:	f04f 0101 	mov.w	r1, #1
 800de18:	f7f8 fedc 	bl	8006bd4 <DMA_Cmd>
 800de1c:	e021      	b.n	800de62 <Audio_MAL_IRQHandler+0x17e>
    }
    else
    {
      /* Disable the I2S DMA Stream*/
      DMA_Cmd(AUDIO_MAL_DMA_STREAM, DISABLE);   
 800de1e:	f240 035c 	movw	r3, #92	; 0x5c
 800de22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800de26:	681b      	ldr	r3, [r3, #0]
 800de28:	4618      	mov	r0, r3
 800de2a:	f04f 0100 	mov.w	r1, #0
 800de2e:	f7f8 fed1 	bl	8006bd4 <DMA_Cmd>
      
      /* Clear the Interrupt flag */
      DMA_ClearFlag(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC);       
 800de32:	f240 035c 	movw	r3, #92	; 0x5c
 800de36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800de3a:	681a      	ldr	r2, [r3, #0]
 800de3c:	f240 0368 	movw	r3, #104	; 0x68
 800de40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800de44:	681b      	ldr	r3, [r3, #0]
 800de46:	4610      	mov	r0, r2
 800de48:	4619      	mov	r1, r3
 800de4a:	f7f9 f80f 	bl	8006e6c <DMA_ClearFlag>
      
      /* Manage the remaining file size and new address offset: This function 
      should be coded by user (its prototype is already declared in stm32f4_discovery_audio_codec.h) */  
      EVAL_AUDIO_TransferComplete_CallBack((uint32_t)CurrentPos, 0);       
 800de4e:	f244 5384 	movw	r3, #17796	; 0x4584
 800de52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800de56:	681b      	ldr	r3, [r3, #0]
 800de58:	4618      	mov	r0, r3
 800de5a:	f04f 0100 	mov.w	r1, #0
 800de5e:	f014 f88d 	bl	8021f7c <EVAL_AUDIO_TransferComplete_CallBack>
    /* Clear the Interrupt flag */
    DMA_ClearFlag(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TE | AUDIO_MAL_DMA_FLAG_FE | \
                                        AUDIO_MAL_DMA_FLAG_DME);
  }  
#endif /* AUDIO_MAL_DMA_IT_TE_EN */
}
 800de62:	bd80      	pop	{r7, pc}

0800de64 <DMA1_Stream7_IRQHandler>:
  * @brief  This function handles main I2S interrupt. 
  * @param  None
  * @retval 0 if correct communication, else wrong communication
  */
void Audio_MAL_I2S_IRQHandler(void)
{ 
 800de64:	b580      	push	{r7, lr}
 800de66:	af00      	add	r7, sp, #0
  Audio_MAL_IRQHandler();
 800de68:	f7ff ff3c 	bl	800dce4 <Audio_MAL_IRQHandler>
}
 800de6c:	bd80      	pop	{r7, pc}
 800de6e:	bf00      	nop

0800de70 <DMA1_Stream0_IRQHandler>:
  * @brief  This function handles main DAC interrupt. 
  * @param  None
  * @retval 0 if correct communication, else wrong communication
  */
void Audio_MAL_DAC_IRQHandler(void)
{ 
 800de70:	b580      	push	{r7, lr}
 800de72:	af00      	add	r7, sp, #0
  Audio_MAL_IRQHandler();
 800de74:	f7ff ff36 	bl	800dce4 <Audio_MAL_IRQHandler>
}
 800de78:	bd80      	pop	{r7, pc}
 800de7a:	bf00      	nop

0800de7c <SPI3_IRQHandler>:
  * @brief  I2S interrupt management
  * @param  None
  * @retval None
  */
void Audio_I2S_IRQHandler(void)
{
 800de7c:	b580      	push	{r7, lr}
 800de7e:	af00      	add	r7, sp, #0
  /* Check on the I2S TXE flag */  
  if (SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_TXE) != RESET)
 800de80:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800de84:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800de88:	f04f 0102 	mov.w	r1, #2
 800de8c:	f7fd fc3a 	bl	800b704 <SPI_I2S_GetFlagStatus>
 800de90:	4603      	mov	r3, r0
 800de92:	2b00      	cmp	r3, #0
 800de94:	d018      	beq.n	800dec8 <SPI3_IRQHandler+0x4c>
  { 
    if (CurrAudioInterface == AUDIO_INTERFACE_DAC)
 800de96:	f240 0354 	movw	r3, #84	; 0x54
 800de9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800de9e:	681b      	ldr	r3, [r3, #0]
 800dea0:	2b02      	cmp	r3, #2
 800dea2:	d107      	bne.n	800deb4 <SPI3_IRQHandler+0x38>
    {
      /* Wirte data to the DAC interface */
      DAC_SetChannel1Data(DAC_Align_12b_L, EVAL_AUDIO_GetSampleCallBack()); 
 800dea4:	f014 f88a 	bl	8021fbc <EVAL_AUDIO_GetSampleCallBack>
 800dea8:	4603      	mov	r3, r0
 800deaa:	f04f 0004 	mov.w	r0, #4
 800deae:	4619      	mov	r1, r3
 800deb0:	f7f8 fb60 	bl	8006574 <DAC_SetChannel1Data>
    }
    
    /* Send dummy data on I2S to avoid the underrun condition */
    SPI_I2S_SendData(CODEC_I2S, EVAL_AUDIO_GetSampleCallBack()); 
 800deb4:	f014 f882 	bl	8021fbc <EVAL_AUDIO_GetSampleCallBack>
 800deb8:	4603      	mov	r3, r0
 800deba:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800debe:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800dec2:	4619      	mov	r1, r3
 800dec4:	f7fd fb5c 	bl	800b580 <SPI_I2S_SendData>
  }
}
 800dec8:	bd80      	pop	{r7, pc}
 800deca:	bf00      	nop

0800decc <Codec_Init>:
  * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
  * @param  AudioFreq: Audio frequency used to play the audio stream.
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
{
 800decc:	b580      	push	{r7, lr}
 800dece:	b084      	sub	sp, #16
 800ded0:	af00      	add	r7, sp, #0
 800ded2:	460b      	mov	r3, r1
 800ded4:	603a      	str	r2, [r7, #0]
 800ded6:	4602      	mov	r2, r0
 800ded8:	80fa      	strh	r2, [r7, #6]
 800deda:	717b      	strb	r3, [r7, #5]
  uint32_t counter = 0; 
 800dedc:	f04f 0300 	mov.w	r3, #0
 800dee0:	60fb      	str	r3, [r7, #12]

  /* Configure the Codec related IOs */
  Codec_GPIO_Init();   
 800dee2:	f000 fbaf 	bl	800e644 <Codec_GPIO_Init>
  
  /* Reset the Codec Registers */
  Codec_Reset();
 800dee6:	f000 f9d7 	bl	800e298 <Codec_Reset>

  /* Initialize the Control interface of the Audio Codec */
  Codec_CtrlInterface_Init();     
 800deea:	f000 fb03 	bl	800e4f4 <Codec_CtrlInterface_Init>
  
  /* Keep Codec powered OFF */
  counter += Codec_WriteRegister(0x02, 0x01);  
 800deee:	f04f 0002 	mov.w	r0, #2
 800def2:	f04f 0101 	mov.w	r1, #1
 800def6:	f000 f9eb 	bl	800e2d0 <Codec_WriteRegister>
 800defa:	4603      	mov	r3, r0
 800defc:	68fa      	ldr	r2, [r7, #12]
 800defe:	18d3      	adds	r3, r2, r3
 800df00:	60fb      	str	r3, [r7, #12]
      
  counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
 800df02:	f04f 0004 	mov.w	r0, #4
 800df06:	f04f 01af 	mov.w	r1, #175	; 0xaf
 800df0a:	f000 f9e1 	bl	800e2d0 <Codec_WriteRegister>
 800df0e:	4603      	mov	r3, r0
 800df10:	68fa      	ldr	r2, [r7, #12]
 800df12:	18d3      	adds	r3, r2, r3
 800df14:	60fb      	str	r3, [r7, #12]
  OutputDev = 0xAF;
 800df16:	f640 13ff 	movw	r3, #2559	; 0x9ff
 800df1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800df1e:	f04f 02af 	mov.w	r2, #175	; 0xaf
 800df22:	701a      	strb	r2, [r3, #0]
  
  /* Clock configuration: Auto detection */  
  counter += Codec_WriteRegister(0x05, 0x81);
 800df24:	f04f 0005 	mov.w	r0, #5
 800df28:	f04f 0181 	mov.w	r1, #129	; 0x81
 800df2c:	f000 f9d0 	bl	800e2d0 <Codec_WriteRegister>
 800df30:	4603      	mov	r3, r0
 800df32:	68fa      	ldr	r2, [r7, #12]
 800df34:	18d3      	adds	r3, r2, r3
 800df36:	60fb      	str	r3, [r7, #12]
  
  /* Set the Slave Mode and the audio Standard */  
  counter += Codec_WriteRegister(0x06, CODEC_STANDARD);
 800df38:	f04f 0006 	mov.w	r0, #6
 800df3c:	f04f 0104 	mov.w	r1, #4
 800df40:	f000 f9c6 	bl	800e2d0 <Codec_WriteRegister>
 800df44:	4603      	mov	r3, r0
 800df46:	68fa      	ldr	r2, [r7, #12]
 800df48:	18d3      	adds	r3, r2, r3
 800df4a:	60fb      	str	r3, [r7, #12]
      
  /* Set the Master volume */
  Codec_VolumeCtrl(Volume);
 800df4c:	797b      	ldrb	r3, [r7, #5]
 800df4e:	4618      	mov	r0, r3
 800df50:	f000 f932 	bl	800e1b8 <Codec_VolumeCtrl>
  
  if (CurrAudioInterface == AUDIO_INTERFACE_DAC)
 800df54:	f240 0354 	movw	r3, #84	; 0x54
 800df58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800df5c:	681b      	ldr	r3, [r3, #0]
 800df5e:	2b02      	cmp	r3, #2
 800df60:	d131      	bne.n	800dfc6 <Codec_Init+0xfa>
  {
    /* Enable the PassThrough on AIN1A and AIN1B */
    counter += Codec_WriteRegister(0x08, 0x01);
 800df62:	f04f 0008 	mov.w	r0, #8
 800df66:	f04f 0101 	mov.w	r1, #1
 800df6a:	f000 f9b1 	bl	800e2d0 <Codec_WriteRegister>
 800df6e:	4603      	mov	r3, r0
 800df70:	68fa      	ldr	r2, [r7, #12]
 800df72:	18d3      	adds	r3, r2, r3
 800df74:	60fb      	str	r3, [r7, #12]
    counter += Codec_WriteRegister(0x09, 0x01);
 800df76:	f04f 0009 	mov.w	r0, #9
 800df7a:	f04f 0101 	mov.w	r1, #1
 800df7e:	f000 f9a7 	bl	800e2d0 <Codec_WriteRegister>
 800df82:	4603      	mov	r3, r0
 800df84:	68fa      	ldr	r2, [r7, #12]
 800df86:	18d3      	adds	r3, r2, r3
 800df88:	60fb      	str	r3, [r7, #12]
    
    /* Route the analog input to the HP line */
    counter += Codec_WriteRegister(0x0E, 0xC0);
 800df8a:	f04f 000e 	mov.w	r0, #14
 800df8e:	f04f 01c0 	mov.w	r1, #192	; 0xc0
 800df92:	f000 f99d 	bl	800e2d0 <Codec_WriteRegister>
 800df96:	4603      	mov	r3, r0
 800df98:	68fa      	ldr	r2, [r7, #12]
 800df9a:	18d3      	adds	r3, r2, r3
 800df9c:	60fb      	str	r3, [r7, #12]
    
    /* Set the Passthough volume */
    counter += Codec_WriteRegister(0x14, 0x00);
 800df9e:	f04f 0014 	mov.w	r0, #20
 800dfa2:	f04f 0100 	mov.w	r1, #0
 800dfa6:	f000 f993 	bl	800e2d0 <Codec_WriteRegister>
 800dfaa:	4603      	mov	r3, r0
 800dfac:	68fa      	ldr	r2, [r7, #12]
 800dfae:	18d3      	adds	r3, r2, r3
 800dfb0:	60fb      	str	r3, [r7, #12]
    counter += Codec_WriteRegister(0x15, 0x00);
 800dfb2:	f04f 0015 	mov.w	r0, #21
 800dfb6:	f04f 0100 	mov.w	r1, #0
 800dfba:	f000 f989 	bl	800e2d0 <Codec_WriteRegister>
 800dfbe:	4603      	mov	r3, r0
 800dfc0:	68fa      	ldr	r2, [r7, #12]
 800dfc2:	18d3      	adds	r3, r2, r3
 800dfc4:	60fb      	str	r3, [r7, #12]
  }

  /* Power on the Codec */
  counter += Codec_WriteRegister(0x02, 0x9E);  
 800dfc6:	f04f 0002 	mov.w	r0, #2
 800dfca:	f04f 019e 	mov.w	r1, #158	; 0x9e
 800dfce:	f000 f97f 	bl	800e2d0 <Codec_WriteRegister>
 800dfd2:	4603      	mov	r3, r0
 800dfd4:	68fa      	ldr	r2, [r7, #12]
 800dfd6:	18d3      	adds	r3, r2, r3
 800dfd8:	60fb      	str	r3, [r7, #12]
      off the I2S peripheral MCLK clock (which is the operating clock for Codec).
      If this delay is not inserted, then the codec will not shut down properly and
      it results in high noise after shut down. */
  
  /* Disable the analog soft ramp */
  counter += Codec_WriteRegister(0x0A, 0x00);
 800dfda:	f04f 000a 	mov.w	r0, #10
 800dfde:	f04f 0100 	mov.w	r1, #0
 800dfe2:	f000 f975 	bl	800e2d0 <Codec_WriteRegister>
 800dfe6:	4603      	mov	r3, r0
 800dfe8:	68fa      	ldr	r2, [r7, #12]
 800dfea:	18d3      	adds	r3, r2, r3
 800dfec:	60fb      	str	r3, [r7, #12]
  if (CurrAudioInterface != AUDIO_INTERFACE_DAC)
 800dfee:	f240 0354 	movw	r3, #84	; 0x54
 800dff2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dff6:	681b      	ldr	r3, [r3, #0]
 800dff8:	2b02      	cmp	r3, #2
 800dffa:	d009      	beq.n	800e010 <Codec_Init+0x144>
  {  
    /* Disable the digital soft ramp */
    counter += Codec_WriteRegister(0x0E, 0x04);
 800dffc:	f04f 000e 	mov.w	r0, #14
 800e000:	f04f 0104 	mov.w	r1, #4
 800e004:	f000 f964 	bl	800e2d0 <Codec_WriteRegister>
 800e008:	4603      	mov	r3, r0
 800e00a:	68fa      	ldr	r2, [r7, #12]
 800e00c:	18d3      	adds	r3, r2, r3
 800e00e:	60fb      	str	r3, [r7, #12]
  }
  /* Disable the limiter attack level */
  counter += Codec_WriteRegister(0x27, 0x00);
 800e010:	f04f 0027 	mov.w	r0, #39	; 0x27
 800e014:	f04f 0100 	mov.w	r1, #0
 800e018:	f000 f95a 	bl	800e2d0 <Codec_WriteRegister>
 800e01c:	4603      	mov	r3, r0
 800e01e:	68fa      	ldr	r2, [r7, #12]
 800e020:	18d3      	adds	r3, r2, r3
 800e022:	60fb      	str	r3, [r7, #12]
  /* Adjust Bass and Treble levels */
  counter += Codec_WriteRegister(0x1F, 0x0F);
 800e024:	f04f 001f 	mov.w	r0, #31
 800e028:	f04f 010f 	mov.w	r1, #15
 800e02c:	f000 f950 	bl	800e2d0 <Codec_WriteRegister>
 800e030:	4603      	mov	r3, r0
 800e032:	68fa      	ldr	r2, [r7, #12]
 800e034:	18d3      	adds	r3, r2, r3
 800e036:	60fb      	str	r3, [r7, #12]
  /* Adjust PCM volume level */
  counter += Codec_WriteRegister(0x1A, 0x0A);
 800e038:	f04f 001a 	mov.w	r0, #26
 800e03c:	f04f 010a 	mov.w	r1, #10
 800e040:	f000 f946 	bl	800e2d0 <Codec_WriteRegister>
 800e044:	4603      	mov	r3, r0
 800e046:	68fa      	ldr	r2, [r7, #12]
 800e048:	18d3      	adds	r3, r2, r3
 800e04a:	60fb      	str	r3, [r7, #12]
  counter += Codec_WriteRegister(0x1B, 0x0A);
 800e04c:	f04f 001b 	mov.w	r0, #27
 800e050:	f04f 010a 	mov.w	r1, #10
 800e054:	f000 f93c 	bl	800e2d0 <Codec_WriteRegister>
 800e058:	4603      	mov	r3, r0
 800e05a:	68fa      	ldr	r2, [r7, #12]
 800e05c:	18d3      	adds	r3, r2, r3
 800e05e:	60fb      	str	r3, [r7, #12]

  /* Configure the I2S peripheral */
  Codec_AudioInterface_Init(AudioFreq);  
 800e060:	6838      	ldr	r0, [r7, #0]
 800e062:	f000 fa85 	bl	800e570 <Codec_AudioInterface_Init>
  
  /* Return communication control value */
  return counter;  
 800e066:	68fb      	ldr	r3, [r7, #12]
}
 800e068:	4618      	mov	r0, r3
 800e06a:	f107 0710 	add.w	r7, r7, #16
 800e06e:	46bd      	mov	sp, r7
 800e070:	bd80      	pop	{r7, pc}
 800e072:	bf00      	nop

0800e074 <Codec_DeInit>:
  *         resources.
  * @param  None
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_DeInit(void)
{
 800e074:	b580      	push	{r7, lr}
 800e076:	b082      	sub	sp, #8
 800e078:	af00      	add	r7, sp, #0
  uint32_t counter = 0; 
 800e07a:	f04f 0300 	mov.w	r3, #0
 800e07e:	607b      	str	r3, [r7, #4]

  /* Reset the Codec Registers */
  Codec_Reset();  
 800e080:	f000 f90a 	bl	800e298 <Codec_Reset>
  
  /* Keep Codec powered OFF */
  counter += Codec_WriteRegister(0x02, 0x01);    
 800e084:	f04f 0002 	mov.w	r0, #2
 800e088:	f04f 0101 	mov.w	r1, #1
 800e08c:	f000 f920 	bl	800e2d0 <Codec_WriteRegister>
 800e090:	4603      	mov	r3, r0
 800e092:	687a      	ldr	r2, [r7, #4]
 800e094:	18d3      	adds	r3, r2, r3
 800e096:	607b      	str	r3, [r7, #4]
  
  /* Deinitialize all use GPIOs */
  Codec_GPIO_DeInit();
 800e098:	f000 fbaa 	bl	800e7f0 <Codec_GPIO_DeInit>

  /* Disable the Codec control interface */
  Codec_CtrlInterface_DeInit();
 800e09c:	f000 fa62 	bl	800e564 <Codec_CtrlInterface_DeInit>
  
  /* Deinitialize the Codec audio interface (I2S) */
  Codec_AudioInterface_DeInit(); 
 800e0a0:	f000 fab8 	bl	800e614 <Codec_AudioInterface_DeInit>
  
  /* Return communication control value */
  return counter;  
 800e0a4:	687b      	ldr	r3, [r7, #4]
}
 800e0a6:	4618      	mov	r0, r3
 800e0a8:	f107 0708 	add.w	r7, r7, #8
 800e0ac:	46bd      	mov	sp, r7
 800e0ae:	bd80      	pop	{r7, pc}

0800e0b0 <Codec_Play>:
  * @note   For this codec no Play options are required.
  * @param  None
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_Play(void)
{
 800e0b0:	b480      	push	{r7}
 800e0b2:	af00      	add	r7, sp, #0
  /* 
     No actions required on Codec level for play command
     */  

  /* Return communication control value */
  return 0;  
 800e0b4:	f04f 0300 	mov.w	r3, #0
}
 800e0b8:	4618      	mov	r0, r3
 800e0ba:	46bd      	mov	sp, r7
 800e0bc:	bc80      	pop	{r7}
 800e0be:	4770      	bx	lr

0800e0c0 <Codec_PauseResume>:
  * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
  *         from 0) to resume. 
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_PauseResume(uint32_t Cmd)
{
 800e0c0:	b580      	push	{r7, lr}
 800e0c2:	b084      	sub	sp, #16
 800e0c4:	af00      	add	r7, sp, #0
 800e0c6:	6078      	str	r0, [r7, #4]
  uint32_t counter = 0;   
 800e0c8:	f04f 0300 	mov.w	r3, #0
 800e0cc:	60fb      	str	r3, [r7, #12]
  
  /* Pause the audio file playing */
  if (Cmd == AUDIO_PAUSE)
 800e0ce:	687b      	ldr	r3, [r7, #4]
 800e0d0:	2b00      	cmp	r3, #0
 800e0d2:	d112      	bne.n	800e0fa <Codec_PauseResume+0x3a>
  { 
    /* Mute the output first */
    counter += Codec_Mute(AUDIO_MUTE_ON);
 800e0d4:	f04f 0001 	mov.w	r0, #1
 800e0d8:	f000 f8b4 	bl	800e244 <Codec_Mute>
 800e0dc:	4603      	mov	r3, r0
 800e0de:	68fa      	ldr	r2, [r7, #12]
 800e0e0:	18d3      	adds	r3, r2, r3
 800e0e2:	60fb      	str	r3, [r7, #12]

    /* Put the Codec in Power save mode */    
    counter += Codec_WriteRegister(0x02, 0x01);    
 800e0e4:	f04f 0002 	mov.w	r0, #2
 800e0e8:	f04f 0101 	mov.w	r1, #1
 800e0ec:	f000 f8f0 	bl	800e2d0 <Codec_WriteRegister>
 800e0f0:	4603      	mov	r3, r0
 800e0f2:	68fa      	ldr	r2, [r7, #12]
 800e0f4:	18d3      	adds	r3, r2, r3
 800e0f6:	60fb      	str	r3, [r7, #12]
 800e0f8:	e020      	b.n	800e13c <Codec_PauseResume+0x7c>
  }
  else /* AUDIO_RESUME */
  {
    /* Unmute the output first */
    counter += Codec_Mute(AUDIO_MUTE_OFF);
 800e0fa:	f04f 0000 	mov.w	r0, #0
 800e0fe:	f000 f8a1 	bl	800e244 <Codec_Mute>
 800e102:	4603      	mov	r3, r0
 800e104:	68fa      	ldr	r2, [r7, #12]
 800e106:	18d3      	adds	r3, r2, r3
 800e108:	60fb      	str	r3, [r7, #12]
    
    counter += Codec_WriteRegister(0x04, OutputDev);
 800e10a:	f640 13ff 	movw	r3, #2559	; 0x9ff
 800e10e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e112:	781b      	ldrb	r3, [r3, #0]
 800e114:	b2db      	uxtb	r3, r3
 800e116:	f04f 0004 	mov.w	r0, #4
 800e11a:	4619      	mov	r1, r3
 800e11c:	f000 f8d8 	bl	800e2d0 <Codec_WriteRegister>
 800e120:	4603      	mov	r3, r0
 800e122:	68fa      	ldr	r2, [r7, #12]
 800e124:	18d3      	adds	r3, r2, r3
 800e126:	60fb      	str	r3, [r7, #12]
    
    /* Exit the Power save mode */
    counter += Codec_WriteRegister(0x02, 0x9E); 
 800e128:	f04f 0002 	mov.w	r0, #2
 800e12c:	f04f 019e 	mov.w	r1, #158	; 0x9e
 800e130:	f000 f8ce 	bl	800e2d0 <Codec_WriteRegister>
 800e134:	4603      	mov	r3, r0
 800e136:	68fa      	ldr	r2, [r7, #12]
 800e138:	18d3      	adds	r3, r2, r3
 800e13a:	60fb      	str	r3, [r7, #12]
  }

  return counter;
 800e13c:	68fb      	ldr	r3, [r7, #12]
}
 800e13e:	4618      	mov	r0, r3
 800e140:	f107 0710 	add.w	r7, r7, #16
 800e144:	46bd      	mov	sp, r7
 800e146:	bd80      	pop	{r7, pc}

0800e148 <Codec_Stop>:
  *                           (user should re-Initialize the codec in order to 
  *                            play again the audio stream).
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_Stop(uint32_t CodecPdwnMode)
{
 800e148:	b580      	push	{r7, lr}
 800e14a:	b084      	sub	sp, #16
 800e14c:	af00      	add	r7, sp, #0
 800e14e:	6078      	str	r0, [r7, #4]
  uint32_t counter = 0;   
 800e150:	f04f 0300 	mov.w	r3, #0
 800e154:	60fb      	str	r3, [r7, #12]

  /* Mute the output first */
  Codec_Mute(AUDIO_MUTE_ON);
 800e156:	f04f 0001 	mov.w	r0, #1
 800e15a:	f000 f873 	bl	800e244 <Codec_Mute>
  
  if (CodecPdwnMode == CODEC_PDWN_SW)
 800e15e:	687b      	ldr	r3, [r7, #4]
 800e160:	2b02      	cmp	r3, #2
 800e162:	d10a      	bne.n	800e17a <Codec_Stop+0x32>
  {    
    /* Power down the DAC and the speaker (PMDAC and PMSPK bits)*/
    counter += Codec_WriteRegister(0x02, 0x9F);
 800e164:	f04f 0002 	mov.w	r0, #2
 800e168:	f04f 019f 	mov.w	r1, #159	; 0x9f
 800e16c:	f000 f8b0 	bl	800e2d0 <Codec_WriteRegister>
 800e170:	4603      	mov	r3, r0
 800e172:	68fa      	ldr	r2, [r7, #12]
 800e174:	18d3      	adds	r3, r2, r3
 800e176:	60fb      	str	r3, [r7, #12]
 800e178:	e017      	b.n	800e1aa <Codec_Stop+0x62>
  }
  else /* CODEC_PDWN_HW */
  { 
    /* Power down the DAC components */
    counter += Codec_WriteRegister(0x02, 0x9F);
 800e17a:	f04f 0002 	mov.w	r0, #2
 800e17e:	f04f 019f 	mov.w	r1, #159	; 0x9f
 800e182:	f000 f8a5 	bl	800e2d0 <Codec_WriteRegister>
 800e186:	4603      	mov	r3, r0
 800e188:	68fa      	ldr	r2, [r7, #12]
 800e18a:	18d3      	adds	r3, r2, r3
 800e18c:	60fb      	str	r3, [r7, #12]
    
    /* Wait at least 100us */
    Delay(0xFFF);
 800e18e:	f640 70ff 	movw	r0, #4095	; 0xfff
 800e192:	f000 fb89 	bl	800e8a8 <Delay>
    
    /* Reset The pin */
    GPIO_WriteBit(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, Bit_RESET);
 800e196:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800e19a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e19e:	f04f 0110 	mov.w	r1, #16
 800e1a2:	f04f 0200 	mov.w	r2, #0
 800e1a6:	f7f9 fae9 	bl	800777c <GPIO_WriteBit>
  }
  
  return counter;    
 800e1aa:	68fb      	ldr	r3, [r7, #12]
}
 800e1ac:	4618      	mov	r0, r3
 800e1ae:	f107 0710 	add.w	r7, r7, #16
 800e1b2:	46bd      	mov	sp, r7
 800e1b4:	bd80      	pop	{r7, pc}
 800e1b6:	bf00      	nop

0800e1b8 <Codec_VolumeCtrl>:
  * @param  Volume: a byte value from 0 to 255 (refer to codec registers 
  *         description for more details).
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_VolumeCtrl(uint8_t Volume)
{
 800e1b8:	b580      	push	{r7, lr}
 800e1ba:	b084      	sub	sp, #16
 800e1bc:	af00      	add	r7, sp, #0
 800e1be:	4603      	mov	r3, r0
 800e1c0:	71fb      	strb	r3, [r7, #7]
  uint32_t counter = 0;
 800e1c2:	f04f 0300 	mov.w	r3, #0
 800e1c6:	60fb      	str	r3, [r7, #12]
  
  if (Volume > 0xE6)
 800e1c8:	79fb      	ldrb	r3, [r7, #7]
 800e1ca:	2be6      	cmp	r3, #230	; 0xe6
 800e1cc:	d91a      	bls.n	800e204 <Codec_VolumeCtrl+0x4c>
  {
    /* Set the Master volume */
    counter += Codec_WriteRegister(0x20, Volume - 0xE7); 
 800e1ce:	79fb      	ldrb	r3, [r7, #7]
 800e1d0:	f103 0319 	add.w	r3, r3, #25
 800e1d4:	b2db      	uxtb	r3, r3
 800e1d6:	f04f 0020 	mov.w	r0, #32
 800e1da:	4619      	mov	r1, r3
 800e1dc:	f000 f878 	bl	800e2d0 <Codec_WriteRegister>
 800e1e0:	4603      	mov	r3, r0
 800e1e2:	68fa      	ldr	r2, [r7, #12]
 800e1e4:	18d3      	adds	r3, r2, r3
 800e1e6:	60fb      	str	r3, [r7, #12]
    counter += Codec_WriteRegister(0x21, Volume - 0xE7);     
 800e1e8:	79fb      	ldrb	r3, [r7, #7]
 800e1ea:	f103 0319 	add.w	r3, r3, #25
 800e1ee:	b2db      	uxtb	r3, r3
 800e1f0:	f04f 0021 	mov.w	r0, #33	; 0x21
 800e1f4:	4619      	mov	r1, r3
 800e1f6:	f000 f86b 	bl	800e2d0 <Codec_WriteRegister>
 800e1fa:	4603      	mov	r3, r0
 800e1fc:	68fa      	ldr	r2, [r7, #12]
 800e1fe:	18d3      	adds	r3, r2, r3
 800e200:	60fb      	str	r3, [r7, #12]
 800e202:	e019      	b.n	800e238 <Codec_VolumeCtrl+0x80>
  }
  else
  {
    /* Set the Master volume */
    counter += Codec_WriteRegister(0x20, Volume + 0x19); 
 800e204:	79fb      	ldrb	r3, [r7, #7]
 800e206:	f103 0319 	add.w	r3, r3, #25
 800e20a:	b2db      	uxtb	r3, r3
 800e20c:	f04f 0020 	mov.w	r0, #32
 800e210:	4619      	mov	r1, r3
 800e212:	f000 f85d 	bl	800e2d0 <Codec_WriteRegister>
 800e216:	4603      	mov	r3, r0
 800e218:	68fa      	ldr	r2, [r7, #12]
 800e21a:	18d3      	adds	r3, r2, r3
 800e21c:	60fb      	str	r3, [r7, #12]
    counter += Codec_WriteRegister(0x21, Volume + 0x19); 
 800e21e:	79fb      	ldrb	r3, [r7, #7]
 800e220:	f103 0319 	add.w	r3, r3, #25
 800e224:	b2db      	uxtb	r3, r3
 800e226:	f04f 0021 	mov.w	r0, #33	; 0x21
 800e22a:	4619      	mov	r1, r3
 800e22c:	f000 f850 	bl	800e2d0 <Codec_WriteRegister>
 800e230:	4603      	mov	r3, r0
 800e232:	68fa      	ldr	r2, [r7, #12]
 800e234:	18d3      	adds	r3, r2, r3
 800e236:	60fb      	str	r3, [r7, #12]
  }

  return counter;  
 800e238:	68fb      	ldr	r3, [r7, #12]
}
 800e23a:	4618      	mov	r0, r3
 800e23c:	f107 0710 	add.w	r7, r7, #16
 800e240:	46bd      	mov	sp, r7
 800e242:	bd80      	pop	{r7, pc}

0800e244 <Codec_Mute>:
  * @param  Cmd: AUDIO_MUTE_ON to enable the mute or AUDIO_MUTE_OFF to disable the
  *             mute mode.
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_Mute(uint32_t Cmd)
{
 800e244:	b580      	push	{r7, lr}
 800e246:	b084      	sub	sp, #16
 800e248:	af00      	add	r7, sp, #0
 800e24a:	6078      	str	r0, [r7, #4]
  uint32_t counter = 0;  
 800e24c:	f04f 0300 	mov.w	r3, #0
 800e250:	60fb      	str	r3, [r7, #12]
  
  /* Set the Mute mode */
  if (Cmd == AUDIO_MUTE_ON)
 800e252:	687b      	ldr	r3, [r7, #4]
 800e254:	2b01      	cmp	r3, #1
 800e256:	d10a      	bne.n	800e26e <Codec_Mute+0x2a>
  {
    counter += Codec_WriteRegister(0x04, 0xFF);
 800e258:	f04f 0004 	mov.w	r0, #4
 800e25c:	f04f 01ff 	mov.w	r1, #255	; 0xff
 800e260:	f000 f836 	bl	800e2d0 <Codec_WriteRegister>
 800e264:	4603      	mov	r3, r0
 800e266:	68fa      	ldr	r2, [r7, #12]
 800e268:	18d3      	adds	r3, r2, r3
 800e26a:	60fb      	str	r3, [r7, #12]
 800e26c:	e00e      	b.n	800e28c <Codec_Mute+0x48>
  }
  else /* AUDIO_MUTE_OFF Disable the Mute */
  {
    counter += Codec_WriteRegister(0x04, OutputDev);
 800e26e:	f640 13ff 	movw	r3, #2559	; 0x9ff
 800e272:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e276:	781b      	ldrb	r3, [r3, #0]
 800e278:	b2db      	uxtb	r3, r3
 800e27a:	f04f 0004 	mov.w	r0, #4
 800e27e:	4619      	mov	r1, r3
 800e280:	f000 f826 	bl	800e2d0 <Codec_WriteRegister>
 800e284:	4603      	mov	r3, r0
 800e286:	68fa      	ldr	r2, [r7, #12]
 800e288:	18d3      	adds	r3, r2, r3
 800e28a:	60fb      	str	r3, [r7, #12]
  }
  
  return counter; 
 800e28c:	68fb      	ldr	r3, [r7, #12]
}
 800e28e:	4618      	mov	r0, r3
 800e290:	f107 0710 	add.w	r7, r7, #16
 800e294:	46bd      	mov	sp, r7
 800e296:	bd80      	pop	{r7, pc}

0800e298 <Codec_Reset>:
  * @note   This function calls an external driver function: The IO Expander driver.
  * @param  None
  * @retval None
  */
static void Codec_Reset(void)
{
 800e298:	b580      	push	{r7, lr}
 800e29a:	af00      	add	r7, sp, #0
  /* Power Down the codec */
  GPIO_WriteBit(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, Bit_RESET);
 800e29c:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800e2a0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e2a4:	f04f 0110 	mov.w	r1, #16
 800e2a8:	f04f 0200 	mov.w	r2, #0
 800e2ac:	f7f9 fa66 	bl	800777c <GPIO_WriteBit>

  /* wait for a delay to insure registers erasing */
  Delay(CODEC_RESET_DELAY); 
 800e2b0:	f644 70ff 	movw	r0, #20479	; 0x4fff
 800e2b4:	f000 faf8 	bl	800e8a8 <Delay>
  
  /* Power on the codec */
  GPIO_WriteBit(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, Bit_SET);
 800e2b8:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800e2bc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e2c0:	f04f 0110 	mov.w	r1, #16
 800e2c4:	f04f 0201 	mov.w	r2, #1
 800e2c8:	f7f9 fa58 	bl	800777c <GPIO_WriteBit>
}
 800e2cc:	bd80      	pop	{r7, pc}
 800e2ce:	bf00      	nop

0800e2d0 <Codec_WriteRegister>:
  * @param  RegisterAddr: The address (location) of the register to be written.
  * @param  RegisterValue: the Byte value to be written into destination register.
  * @retval 0 if correct communication, else wrong communication
  */
static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue)
{
 800e2d0:	b580      	push	{r7, lr}
 800e2d2:	b084      	sub	sp, #16
 800e2d4:	af00      	add	r7, sp, #0
 800e2d6:	4602      	mov	r2, r0
 800e2d8:	460b      	mov	r3, r1
 800e2da:	71fa      	strb	r2, [r7, #7]
 800e2dc:	71bb      	strb	r3, [r7, #6]
  uint32_t result = 0;
 800e2de:	f04f 0300 	mov.w	r3, #0
 800e2e2:	60fb      	str	r3, [r7, #12]

  /*!< While the bus is busy */
  CODECTimeout = CODEC_LONG_TIMEOUT;
 800e2e4:	f240 0350 	movw	r3, #80	; 0x50
 800e2e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e2ec:	f44f 1296 	mov.w	r2, #1228800	; 0x12c000
 800e2f0:	601a      	str	r2, [r3, #0]
  while(I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_BUSY))
 800e2f2:	e016      	b.n	800e322 <Codec_WriteRegister+0x52>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 800e2f4:	f240 0350 	movw	r3, #80	; 0x50
 800e2f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e2fc:	681b      	ldr	r3, [r3, #0]
 800e2fe:	2b00      	cmp	r3, #0
 800e300:	bf14      	ite	ne
 800e302:	2200      	movne	r2, #0
 800e304:	2201      	moveq	r2, #1
 800e306:	b2d2      	uxtb	r2, r2
 800e308:	f103 31ff 	add.w	r1, r3, #4294967295
 800e30c:	f240 0350 	movw	r3, #80	; 0x50
 800e310:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e314:	6019      	str	r1, [r3, #0]
 800e316:	2a00      	cmp	r2, #0
 800e318:	d003      	beq.n	800e322 <Codec_WriteRegister+0x52>
 800e31a:	f000 fad7 	bl	800e8cc <Codec_TIMEOUT_UserCallback>
 800e31e:	4603      	mov	r3, r0
 800e320:	e0e3      	b.n	800e4ea <Codec_WriteRegister+0x21a>
{
  uint32_t result = 0;

  /*!< While the bus is busy */
  CODECTimeout = CODEC_LONG_TIMEOUT;
  while(I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_BUSY))
 800e322:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e326:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e32a:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 800e32e:	f7f9 ff1d 	bl	800816c <I2C_GetFlagStatus>
 800e332:	4603      	mov	r3, r0
 800e334:	2b00      	cmp	r3, #0
 800e336:	d1dd      	bne.n	800e2f4 <Codec_WriteRegister+0x24>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
  }
  
  /* Start the config sequence */
  I2C_GenerateSTART(CODEC_I2C, ENABLE);
 800e338:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e33c:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e340:	f04f 0101 	mov.w	r1, #1
 800e344:	f7f9 fc04 	bl	8007b50 <I2C_GenerateSTART>

  /* Test on EV5 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 800e348:	f240 0350 	movw	r3, #80	; 0x50
 800e34c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e350:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800e354:	601a      	str	r2, [r3, #0]
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 800e356:	e016      	b.n	800e386 <Codec_WriteRegister+0xb6>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 800e358:	f240 0350 	movw	r3, #80	; 0x50
 800e35c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e360:	681b      	ldr	r3, [r3, #0]
 800e362:	2b00      	cmp	r3, #0
 800e364:	bf14      	ite	ne
 800e366:	2200      	movne	r2, #0
 800e368:	2201      	moveq	r2, #1
 800e36a:	b2d2      	uxtb	r2, r2
 800e36c:	f103 31ff 	add.w	r1, r3, #4294967295
 800e370:	f240 0350 	movw	r3, #80	; 0x50
 800e374:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e378:	6019      	str	r1, [r3, #0]
 800e37a:	2a00      	cmp	r2, #0
 800e37c:	d003      	beq.n	800e386 <Codec_WriteRegister+0xb6>
 800e37e:	f000 faa5 	bl	800e8cc <Codec_TIMEOUT_UserCallback>
 800e382:	4603      	mov	r3, r0
 800e384:	e0b1      	b.n	800e4ea <Codec_WriteRegister+0x21a>
  /* Start the config sequence */
  I2C_GenerateSTART(CODEC_I2C, ENABLE);

  /* Test on EV5 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_MODE_SELECT))
 800e386:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e38a:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e38e:	f04f 0101 	mov.w	r1, #1
 800e392:	f2c0 0103 	movt	r1, #3
 800e396:	f7f9 fe8b 	bl	80080b0 <I2C_CheckEvent>
 800e39a:	4603      	mov	r3, r0
 800e39c:	2b00      	cmp	r3, #0
 800e39e:	d0db      	beq.n	800e358 <Codec_WriteRegister+0x88>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
  }
  
  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(CODEC_I2C, CODEC_ADDRESS, I2C_Direction_Transmitter);
 800e3a0:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e3a4:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e3a8:	f04f 0194 	mov.w	r1, #148	; 0x94
 800e3ac:	f04f 0200 	mov.w	r2, #0
 800e3b0:	f7f9 fc0e 	bl	8007bd0 <I2C_Send7bitAddress>

  /* Test on EV6 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 800e3b4:	f240 0350 	movw	r3, #80	; 0x50
 800e3b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e3bc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800e3c0:	601a      	str	r2, [r3, #0]
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 800e3c2:	e016      	b.n	800e3f2 <Codec_WriteRegister+0x122>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 800e3c4:	f240 0350 	movw	r3, #80	; 0x50
 800e3c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e3cc:	681b      	ldr	r3, [r3, #0]
 800e3ce:	2b00      	cmp	r3, #0
 800e3d0:	bf14      	ite	ne
 800e3d2:	2200      	movne	r2, #0
 800e3d4:	2201      	moveq	r2, #1
 800e3d6:	b2d2      	uxtb	r2, r2
 800e3d8:	f103 31ff 	add.w	r1, r3, #4294967295
 800e3dc:	f240 0350 	movw	r3, #80	; 0x50
 800e3e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e3e4:	6019      	str	r1, [r3, #0]
 800e3e6:	2a00      	cmp	r2, #0
 800e3e8:	d003      	beq.n	800e3f2 <Codec_WriteRegister+0x122>
 800e3ea:	f000 fa6f 	bl	800e8cc <Codec_TIMEOUT_UserCallback>
 800e3ee:	4603      	mov	r3, r0
 800e3f0:	e07b      	b.n	800e4ea <Codec_WriteRegister+0x21a>
  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(CODEC_I2C, CODEC_ADDRESS, I2C_Direction_Transmitter);

  /* Test on EV6 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 800e3f2:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e3f6:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e3fa:	f04f 0182 	mov.w	r1, #130	; 0x82
 800e3fe:	f2c0 0107 	movt	r1, #7
 800e402:	f7f9 fe55 	bl	80080b0 <I2C_CheckEvent>
 800e406:	4603      	mov	r3, r0
 800e408:	2b00      	cmp	r3, #0
 800e40a:	d0db      	beq.n	800e3c4 <Codec_WriteRegister+0xf4>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
  }

  /* Transmit the first address for write operation */
  I2C_SendData(CODEC_I2C, RegisterAddr);
 800e40c:	79fb      	ldrb	r3, [r7, #7]
 800e40e:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e412:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e416:	4619      	mov	r1, r3
 800e418:	f7f9 fd3e 	bl	8007e98 <I2C_SendData>

  /* Test on EV8 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
 800e41c:	f240 0350 	movw	r3, #80	; 0x50
 800e420:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e424:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800e428:	601a      	str	r2, [r3, #0]
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
 800e42a:	e016      	b.n	800e45a <Codec_WriteRegister+0x18a>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
 800e42c:	f240 0350 	movw	r3, #80	; 0x50
 800e430:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e434:	681b      	ldr	r3, [r3, #0]
 800e436:	2b00      	cmp	r3, #0
 800e438:	bf14      	ite	ne
 800e43a:	2200      	movne	r2, #0
 800e43c:	2201      	moveq	r2, #1
 800e43e:	b2d2      	uxtb	r2, r2
 800e440:	f103 31ff 	add.w	r1, r3, #4294967295
 800e444:	f240 0350 	movw	r3, #80	; 0x50
 800e448:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e44c:	6019      	str	r1, [r3, #0]
 800e44e:	2a00      	cmp	r2, #0
 800e450:	d003      	beq.n	800e45a <Codec_WriteRegister+0x18a>
 800e452:	f000 fa3b 	bl	800e8cc <Codec_TIMEOUT_UserCallback>
 800e456:	4603      	mov	r3, r0
 800e458:	e047      	b.n	800e4ea <Codec_WriteRegister+0x21a>
  /* Transmit the first address for write operation */
  I2C_SendData(CODEC_I2C, RegisterAddr);

  /* Test on EV8 and clear it */
  CODECTimeout = CODEC_FLAG_TIMEOUT;
  while (!I2C_CheckEvent(CODEC_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
 800e45a:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e45e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e462:	f04f 0180 	mov.w	r1, #128	; 0x80
 800e466:	f2c0 0107 	movt	r1, #7
 800e46a:	f7f9 fe21 	bl	80080b0 <I2C_CheckEvent>
 800e46e:	4603      	mov	r3, r0
 800e470:	2b00      	cmp	r3, #0
 800e472:	d0db      	beq.n	800e42c <Codec_WriteRegister+0x15c>
  {
    if((CODECTimeout--) == 0) return Codec_TIMEOUT_UserCallback();
  }
  
  /* Prepare the register value to be sent */
  I2C_SendData(CODEC_I2C, RegisterValue);
 800e474:	79bb      	ldrb	r3, [r7, #6]
 800e476:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e47a:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e47e:	4619      	mov	r1, r3
 800e480:	f7f9 fd0a 	bl	8007e98 <I2C_SendData>
  
  /*!< Wait till all data have been physically transferred on the bus */
  CODECTimeout = CODEC_LONG_TIMEOUT;
 800e484:	f240 0350 	movw	r3, #80	; 0x50
 800e488:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e48c:	f44f 1296 	mov.w	r2, #1228800	; 0x12c000
 800e490:	601a      	str	r2, [r3, #0]
  while(!I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_BTF))
 800e492:	e014      	b.n	800e4be <Codec_WriteRegister+0x1ee>
  {
    if((CODECTimeout--) == 0) Codec_TIMEOUT_UserCallback();
 800e494:	f240 0350 	movw	r3, #80	; 0x50
 800e498:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e49c:	681b      	ldr	r3, [r3, #0]
 800e49e:	2b00      	cmp	r3, #0
 800e4a0:	bf14      	ite	ne
 800e4a2:	2200      	movne	r2, #0
 800e4a4:	2201      	moveq	r2, #1
 800e4a6:	b2d2      	uxtb	r2, r2
 800e4a8:	f103 31ff 	add.w	r1, r3, #4294967295
 800e4ac:	f240 0350 	movw	r3, #80	; 0x50
 800e4b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e4b4:	6019      	str	r1, [r3, #0]
 800e4b6:	2a00      	cmp	r2, #0
 800e4b8:	d001      	beq.n	800e4be <Codec_WriteRegister+0x1ee>
 800e4ba:	f000 fa07 	bl	800e8cc <Codec_TIMEOUT_UserCallback>
  /* Prepare the register value to be sent */
  I2C_SendData(CODEC_I2C, RegisterValue);
  
  /*!< Wait till all data have been physically transferred on the bus */
  CODECTimeout = CODEC_LONG_TIMEOUT;
  while(!I2C_GetFlagStatus(CODEC_I2C, I2C_FLAG_BTF))
 800e4be:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e4c2:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e4c6:	f04f 0104 	mov.w	r1, #4
 800e4ca:	f2c1 0100 	movt	r1, #4096	; 0x1000
 800e4ce:	f7f9 fe4d 	bl	800816c <I2C_GetFlagStatus>
 800e4d2:	4603      	mov	r3, r0
 800e4d4:	2b00      	cmp	r3, #0
 800e4d6:	d0dd      	beq.n	800e494 <Codec_WriteRegister+0x1c4>
  {
    if((CODECTimeout--) == 0) Codec_TIMEOUT_UserCallback();
  }
  
  /* End the configuration sequence */
  I2C_GenerateSTOP(CODEC_I2C, ENABLE);  
 800e4d8:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e4dc:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e4e0:	f04f 0101 	mov.w	r1, #1
 800e4e4:	f7f9 fb54 	bl	8007b90 <I2C_GenerateSTOP>
  /* Verify that the data has been correctly written */  
  result = (Codec_ReadRegister(RegisterAddr) == RegisterValue)? 0:1;
#endif /* VERIFY_WRITTENDATA */

  /* Return the verifying value: 0 (Passed) or 1 (Failed) */
  return result;  
 800e4e8:	68fb      	ldr	r3, [r7, #12]
}
 800e4ea:	4618      	mov	r0, r3
 800e4ec:	f107 0710 	add.w	r7, r7, #16
 800e4f0:	46bd      	mov	sp, r7
 800e4f2:	bd80      	pop	{r7, pc}

0800e4f4 <Codec_CtrlInterface_Init>:
  * @brief  Initializes the Audio Codec control interface (I2C).
  * @param  None
  * @retval None
  */
static void Codec_CtrlInterface_Init(void)
{
 800e4f4:	b580      	push	{r7, lr}
 800e4f6:	b084      	sub	sp, #16
 800e4f8:	af00      	add	r7, sp, #0
  I2C_InitTypeDef I2C_InitStructure;
  
  /* Enable the CODEC_I2C peripheral clock */
  RCC_APB1PeriphClockCmd(CODEC_I2C_CLK, ENABLE);
 800e4fa:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800e4fe:	f04f 0101 	mov.w	r1, #1
 800e502:	f7fa fc37 	bl	8008d74 <RCC_APB1PeriphClockCmd>
  
  /* CODEC_I2C peripheral configuration */
  I2C_DeInit(CODEC_I2C);
 800e506:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e50a:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e50e:	f7f9 f9c3 	bl	8007898 <I2C_DeInit>
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 800e512:	f04f 0300 	mov.w	r3, #0
 800e516:	80bb      	strh	r3, [r7, #4]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 800e518:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 800e51c:	80fb      	strh	r3, [r7, #6]
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
 800e51e:	f04f 0333 	mov.w	r3, #51	; 0x33
 800e522:	813b      	strh	r3, [r7, #8]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 800e524:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800e528:	817b      	strh	r3, [r7, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 800e52a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800e52e:	81bb      	strh	r3, [r7, #12]
  I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
 800e530:	f248 63a0 	movw	r3, #34464	; 0x86a0
 800e534:	f2c0 0301 	movt	r3, #1
 800e538:	603b      	str	r3, [r7, #0]
  /* Enable the I2C peripheral */
  I2C_Cmd(CODEC_I2C, ENABLE);  
 800e53a:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e53e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e542:	f04f 0101 	mov.w	r1, #1
 800e546:	f7f9 fae3 	bl	8007b10 <I2C_Cmd>
  I2C_Init(CODEC_I2C, &I2C_InitStructure);
 800e54a:	463b      	mov	r3, r7
 800e54c:	f44f 40a8 	mov.w	r0, #21504	; 0x5400
 800e550:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e554:	4619      	mov	r1, r3
 800e556:	f7f9 f9e3 	bl	8007920 <I2C_Init>
}
 800e55a:	f107 0710 	add.w	r7, r7, #16
 800e55e:	46bd      	mov	sp, r7
 800e560:	bd80      	pop	{r7, pc}
 800e562:	bf00      	nop

0800e564 <Codec_CtrlInterface_DeInit>:
  *         may be used by other modules.
  * @param  None
  * @retval None
  */
static void Codec_CtrlInterface_DeInit(void)
{
 800e564:	b480      	push	{r7}
 800e566:	af00      	add	r7, sp, #0
  /* Disable the I2C peripheral */ /* This step is not done here because 
     the I2C interface can be used by other modules */
  /* I2C_DeInit(CODEC_I2C); */
}
 800e568:	46bd      	mov	sp, r7
 800e56a:	bc80      	pop	{r7}
 800e56c:	4770      	bx	lr
 800e56e:	bf00      	nop

0800e570 <Codec_AudioInterface_Init>:
  *         is already configured and ready to be used.    
  * @param  AudioFreq: Audio frequency to be configured for the I2S peripheral. 
  * @retval None
  */
static void Codec_AudioInterface_Init(uint32_t AudioFreq)
{
 800e570:	b580      	push	{r7, lr}
 800e572:	b08a      	sub	sp, #40	; 0x28
 800e574:	af00      	add	r7, sp, #0
 800e576:	6078      	str	r0, [r7, #4]
  I2S_InitTypeDef I2S_InitStructure;
  DAC_InitTypeDef  DAC_InitStructure;

  /* Enable the CODEC_I2S peripheral clock */
  RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, ENABLE);
 800e578:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800e57c:	f04f 0101 	mov.w	r1, #1
 800e580:	f7fa fbf8 	bl	8008d74 <RCC_APB1PeriphClockCmd>
  
  /* CODEC_I2S peripheral configuration */
  SPI_I2S_DeInit(CODEC_I2S);
 800e584:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800e588:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e58c:	f7fc fcc8 	bl	800af20 <SPI_I2S_DeInit>
  I2S_InitStructure.I2S_AudioFreq = AudioFreq;
 800e590:	687b      	ldr	r3, [r7, #4]
 800e592:	623b      	str	r3, [r7, #32]
  I2S_InitStructure.I2S_Standard = I2S_STANDARD;
 800e594:	f04f 0300 	mov.w	r3, #0
 800e598:	837b      	strh	r3, [r7, #26]
  I2S_InitStructure.I2S_DataFormat = I2S_DataFormat_16b;
 800e59a:	f04f 0300 	mov.w	r3, #0
 800e59e:	83bb      	strh	r3, [r7, #28]
  I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
 800e5a0:	f04f 0300 	mov.w	r3, #0
 800e5a4:	84bb      	strh	r3, [r7, #36]	; 0x24
    I2S_InitStructure.I2S_Mode = I2S_Mode_MasterRx;
  }
  else
  {
#else
   I2S_InitStructure.I2S_Mode = I2S_Mode_MasterTx;
 800e5a6:	f44f 7300 	mov.w	r3, #512	; 0x200
 800e5aa:	833b      	strh	r3, [r7, #24]
#endif
#ifdef DAC_USE_I2S_DMA
  }
#endif /* DAC_USE_I2S_DMA */
#ifdef CODEC_MCLK_ENABLED
  I2S_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Enable;
 800e5ac:	f44f 7300 	mov.w	r3, #512	; 0x200
 800e5b0:	83fb      	strh	r3, [r7, #30]
#else
#error "No selection for the MCLK output has been defined !"
#endif /* CODEC_MCLK_ENABLED */
  
  /* Initialize the I2S peripheral with the structure above */
  I2S_Init(CODEC_I2S, &I2S_InitStructure);
 800e5b2:	f107 0318 	add.w	r3, r7, #24
 800e5b6:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800e5ba:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e5be:	4619      	mov	r1, r3
 800e5c0:	f7fc fd36 	bl	800b030 <I2S_Init>


  /* Configure the DAC interface */
  if (CurrAudioInterface == AUDIO_INTERFACE_DAC)
 800e5c4:	f240 0354 	movw	r3, #84	; 0x54
 800e5c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e5cc:	681b      	ldr	r3, [r3, #0]
 800e5ce:	2b02      	cmp	r3, #2
 800e5d0:	d11b      	bne.n	800e60a <Codec_AudioInterface_Init+0x9a>
  {    
    /* DAC Periph clock enable */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
 800e5d2:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 800e5d6:	f04f 0101 	mov.w	r1, #1
 800e5da:	f7fa fbcb 	bl	8008d74 <RCC_APB1PeriphClockCmd>
    
    /* DAC channel1 Configuration */
    DAC_InitStructure.DAC_Trigger = DAC_Trigger_None;
 800e5de:	f04f 0300 	mov.w	r3, #0
 800e5e2:	60bb      	str	r3, [r7, #8]
    DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
 800e5e4:	f04f 0300 	mov.w	r3, #0
 800e5e8:	60fb      	str	r3, [r7, #12]
    DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
 800e5ea:	f04f 0300 	mov.w	r3, #0
 800e5ee:	617b      	str	r3, [r7, #20]
    DAC_Init(AUDIO_DAC_CHANNEL, &DAC_InitStructure);
 800e5f0:	f107 0308 	add.w	r3, r7, #8
 800e5f4:	f04f 0000 	mov.w	r0, #0
 800e5f8:	4619      	mov	r1, r3
 800e5fa:	f7f7 fea3 	bl	8006344 <DAC_Init>
    
    /* Enable DAC Channel1 */
    DAC_Cmd(AUDIO_DAC_CHANNEL, ENABLE);  
 800e5fe:	f04f 0000 	mov.w	r0, #0
 800e602:	f04f 0101 	mov.w	r1, #1
 800e606:	f7f7 fef1 	bl	80063ec <DAC_Cmd>
  }
  
  /* The I2S peripheral will be enabled only in the EVAL_AUDIO_Play() function 
       or by user functions if DMA mode not enabled */  
}
 800e60a:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800e60e:	46bd      	mov	sp, r7
 800e610:	bd80      	pop	{r7, pc}
 800e612:	bf00      	nop

0800e614 <Codec_AudioInterface_DeInit>:
  * @brief  Restores the Audio Codec audio interface to its default state.
  * @param  None
  * @retval None
  */
static void Codec_AudioInterface_DeInit(void)
{
 800e614:	b580      	push	{r7, lr}
 800e616:	af00      	add	r7, sp, #0
  /* Disable the CODEC_I2S peripheral (in case it hasn't already been disabled) */
  I2S_Cmd(CODEC_I2S, DISABLE);
 800e618:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800e61c:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e620:	f04f 0100 	mov.w	r1, #0
 800e624:	f7fc fe8e 	bl	800b344 <I2S_Cmd>
  
  /* Deinitialize the CODEC_I2S peripheral */
  SPI_I2S_DeInit(CODEC_I2S);
 800e628:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800e62c:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e630:	f7fc fc76 	bl	800af20 <SPI_I2S_DeInit>
  
  /* Disable the CODEC_I2S peripheral clock */
  RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, DISABLE); 
 800e634:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800e638:	f04f 0100 	mov.w	r1, #0
 800e63c:	f7fa fb9a 	bl	8008d74 <RCC_APB1PeriphClockCmd>
}
 800e640:	bd80      	pop	{r7, pc}
 800e642:	bf00      	nop

0800e644 <Codec_GPIO_Init>:
  *        interfaces).
  * @param  None
  * @retval None
  */
static void Codec_GPIO_Init(void)
{
 800e644:	b580      	push	{r7, lr}
 800e646:	b082      	sub	sp, #8
 800e648:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStructure;
  
  /* Enable Reset GPIO Clock */
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
 800e64a:	f04f 0008 	mov.w	r0, #8
 800e64e:	f04f 0101 	mov.w	r1, #1
 800e652:	f7fa fb0b 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
  
  /* Audio reset pin configuration -------------------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN; 
 800e656:	f04f 0310 	mov.w	r3, #16
 800e65a:	603b      	str	r3, [r7, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800e65c:	f04f 0301 	mov.w	r3, #1
 800e660:	713b      	strb	r3, [r7, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800e662:	f04f 0302 	mov.w	r3, #2
 800e666:	717b      	strb	r3, [r7, #5]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800e668:	f04f 0300 	mov.w	r3, #0
 800e66c:	71bb      	strb	r3, [r7, #6]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 800e66e:	f04f 0300 	mov.w	r3, #0
 800e672:	71fb      	strb	r3, [r7, #7]
  GPIO_Init(AUDIO_RESET_GPIO, &GPIO_InitStructure);    
 800e674:	463b      	mov	r3, r7
 800e676:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800e67a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e67e:	4619      	mov	r1, r3
 800e680:	f7f8 ff1e 	bl	80074c0 <GPIO_Init>
  
  /* Enable I2S and I2C GPIO clocks */
  RCC_AHB1PeriphClockCmd(CODEC_I2C_GPIO_CLOCK | CODEC_I2S_GPIO_CLOCK, ENABLE);
 800e684:	f04f 0007 	mov.w	r0, #7
 800e688:	f04f 0101 	mov.w	r1, #1
 800e68c:	f7fa faee 	bl	8008c6c <RCC_AHB1PeriphClockCmd>

  /* CODEC_I2C SCL and SDA pins configuration -------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2C_SCL_PIN | CODEC_I2C_SDA_PIN; 
 800e690:	f44f 7310 	mov.w	r3, #576	; 0x240
 800e694:	603b      	str	r3, [r7, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800e696:	f04f 0302 	mov.w	r3, #2
 800e69a:	713b      	strb	r3, [r7, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800e69c:	f04f 0302 	mov.w	r3, #2
 800e6a0:	717b      	strb	r3, [r7, #5]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 800e6a2:	f04f 0301 	mov.w	r3, #1
 800e6a6:	71bb      	strb	r3, [r7, #6]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 800e6a8:	f04f 0300 	mov.w	r3, #0
 800e6ac:	71fb      	strb	r3, [r7, #7]
  GPIO_Init(CODEC_I2C_GPIO, &GPIO_InitStructure);     
 800e6ae:	463b      	mov	r3, r7
 800e6b0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800e6b4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e6b8:	4619      	mov	r1, r3
 800e6ba:	f7f8 ff01 	bl	80074c0 <GPIO_Init>
  /* Connect pins to I2C peripheral */
  GPIO_PinAFConfig(CODEC_I2C_GPIO, CODEC_I2S_SCL_PINSRC, CODEC_I2C_GPIO_AF);  
 800e6be:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800e6c2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e6c6:	f04f 0106 	mov.w	r1, #6
 800e6ca:	f04f 0204 	mov.w	r2, #4
 800e6ce:	f7f9 f88d 	bl	80077ec <GPIO_PinAFConfig>
  GPIO_PinAFConfig(CODEC_I2C_GPIO, CODEC_I2S_SDA_PINSRC, CODEC_I2C_GPIO_AF);  
 800e6d2:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800e6d6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e6da:	f04f 0109 	mov.w	r1, #9
 800e6de:	f04f 0204 	mov.w	r2, #4
 800e6e2:	f7f9 f883 	bl	80077ec <GPIO_PinAFConfig>

  /* CODEC_I2S pins configuration: WS, SCK and SD pins -----------------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN; 
 800e6e6:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800e6ea:	603b      	str	r3, [r7, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800e6ec:	f04f 0302 	mov.w	r3, #2
 800e6f0:	713b      	strb	r3, [r7, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800e6f2:	f04f 0302 	mov.w	r3, #2
 800e6f6:	717b      	strb	r3, [r7, #5]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800e6f8:	f04f 0300 	mov.w	r3, #0
 800e6fc:	71bb      	strb	r3, [r7, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800e6fe:	f04f 0300 	mov.w	r3, #0
 800e702:	71fb      	strb	r3, [r7, #7]
  GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);
 800e704:	463b      	mov	r3, r7
 800e706:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e70a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e70e:	4619      	mov	r1, r3
 800e710:	f7f8 fed6 	bl	80074c0 <GPIO_Init>
  
  /* Connect pins to I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_WS_GPIO, CODEC_I2S_WS_PINSRC, CODEC_I2S_GPIO_AF);  
 800e714:	f04f 0000 	mov.w	r0, #0
 800e718:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e71c:	f04f 0104 	mov.w	r1, #4
 800e720:	f04f 0206 	mov.w	r2, #6
 800e724:	f7f9 f862 	bl	80077ec <GPIO_PinAFConfig>
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SCK_PINSRC, CODEC_I2S_GPIO_AF);
 800e728:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e72c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e730:	f04f 010a 	mov.w	r1, #10
 800e734:	f04f 0206 	mov.w	r2, #6
 800e738:	f7f9 f858 	bl	80077ec <GPIO_PinAFConfig>

  if (CurrAudioInterface != AUDIO_INTERFACE_DAC) 
 800e73c:	f240 0354 	movw	r3, #84	; 0x54
 800e740:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e744:	681b      	ldr	r3, [r3, #0]
 800e746:	2b02      	cmp	r3, #2
 800e748:	d015      	beq.n	800e776 <Codec_GPIO_Init+0x132>
  {
    GPIO_InitStructure.GPIO_Pin = CODEC_I2S_WS_PIN ;
 800e74a:	f04f 0310 	mov.w	r3, #16
 800e74e:	603b      	str	r3, [r7, #0]
    GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure); 
 800e750:	463b      	mov	r3, r7
 800e752:	f04f 0000 	mov.w	r0, #0
 800e756:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e75a:	4619      	mov	r1, r3
 800e75c:	f7f8 feb0 	bl	80074c0 <GPIO_Init>
    GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SD_PINSRC, CODEC_I2S_GPIO_AF);
 800e760:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e764:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e768:	f04f 010c 	mov.w	r1, #12
 800e76c:	f04f 0206 	mov.w	r2, #6
 800e770:	f7f9 f83c 	bl	80077ec <GPIO_PinAFConfig>
 800e774:	e016      	b.n	800e7a4 <Codec_GPIO_Init+0x160>
  }
  else
  {
    /* GPIOA clock enable (to be used with DAC) */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 800e776:	f04f 0001 	mov.w	r0, #1
 800e77a:	f04f 0101 	mov.w	r1, #1
 800e77e:	f7fa fa75 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
   
    /* DAC channel 1 & 2 (DAC_OUT1 = PA.4) configuration */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
 800e782:	f04f 0310 	mov.w	r3, #16
 800e786:	603b      	str	r3, [r7, #0]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 800e788:	f04f 0303 	mov.w	r3, #3
 800e78c:	713b      	strb	r3, [r7, #4]
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800e78e:	f04f 0300 	mov.w	r3, #0
 800e792:	71fb      	strb	r3, [r7, #7]
    GPIO_Init(GPIOA, &GPIO_InitStructure);
 800e794:	463b      	mov	r3, r7
 800e796:	f04f 0000 	mov.w	r0, #0
 800e79a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e79e:	4619      	mov	r1, r3
 800e7a0:	f7f8 fe8e 	bl	80074c0 <GPIO_Init>
  }

#ifdef CODEC_MCLK_ENABLED
  /* CODEC_I2S pins configuration: MCK pin */
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_MCK_PIN; 
 800e7a4:	f04f 0380 	mov.w	r3, #128	; 0x80
 800e7a8:	603b      	str	r3, [r7, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800e7aa:	f04f 0302 	mov.w	r3, #2
 800e7ae:	713b      	strb	r3, [r7, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800e7b0:	f04f 0302 	mov.w	r3, #2
 800e7b4:	717b      	strb	r3, [r7, #5]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800e7b6:	f04f 0300 	mov.w	r3, #0
 800e7ba:	71bb      	strb	r3, [r7, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800e7bc:	f04f 0300 	mov.w	r3, #0
 800e7c0:	71fb      	strb	r3, [r7, #7]
  GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure);   
 800e7c2:	463b      	mov	r3, r7
 800e7c4:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e7c8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e7cc:	4619      	mov	r1, r3
 800e7ce:	f7f8 fe77 	bl	80074c0 <GPIO_Init>
  /* Connect pins to I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_MCK_GPIO, CODEC_I2S_MCK_PINSRC, CODEC_I2S_GPIO_AF); 
 800e7d2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e7d6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e7da:	f04f 0107 	mov.w	r1, #7
 800e7de:	f04f 0206 	mov.w	r2, #6
 800e7e2:	f7f9 f803 	bl	80077ec <GPIO_PinAFConfig>
#endif /* CODEC_MCLK_ENABLED */ 
}
 800e7e6:	f107 0708 	add.w	r7, r7, #8
 800e7ea:	46bd      	mov	sp, r7
 800e7ec:	bd80      	pop	{r7, pc}
 800e7ee:	bf00      	nop

0800e7f0 <Codec_GPIO_DeInit>:
  * @brief  Restores the IOs used by the Audio Codec interface to their default state.
  * @param  None
  * @retval None
  */
static void Codec_GPIO_DeInit(void)
{
 800e7f0:	b580      	push	{r7, lr}
 800e7f2:	b082      	sub	sp, #8
 800e7f4:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStructure;
  
  /* Deinitialize all the GPIOs used by the driver */
  GPIO_InitStructure.GPIO_Pin =  CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN;
 800e7f6:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800e7fa:	603b      	str	r3, [r7, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800e7fc:	f04f 0300 	mov.w	r3, #0
 800e800:	713b      	strb	r3, [r7, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 800e802:	f04f 0300 	mov.w	r3, #0
 800e806:	717b      	strb	r3, [r7, #5]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800e808:	f04f 0300 	mov.w	r3, #0
 800e80c:	71bb      	strb	r3, [r7, #6]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 800e80e:	f04f 0300 	mov.w	r3, #0
 800e812:	71fb      	strb	r3, [r7, #7]
  GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);  
 800e814:	463b      	mov	r3, r7
 800e816:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e81a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e81e:	4619      	mov	r1, r3
 800e820:	f7f8 fe4e 	bl	80074c0 <GPIO_Init>
  
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_WS_PIN ;
 800e824:	f04f 0310 	mov.w	r3, #16
 800e828:	603b      	str	r3, [r7, #0]
  GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure); 
 800e82a:	463b      	mov	r3, r7
 800e82c:	f04f 0000 	mov.w	r0, #0
 800e830:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e834:	4619      	mov	r1, r3
 800e836:	f7f8 fe43 	bl	80074c0 <GPIO_Init>
     
  /* Disconnect pins from I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_WS_GPIO, CODEC_I2S_WS_PINSRC, 0x00);  
 800e83a:	f04f 0000 	mov.w	r0, #0
 800e83e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e842:	f04f 0104 	mov.w	r1, #4
 800e846:	f04f 0200 	mov.w	r2, #0
 800e84a:	f7f8 ffcf 	bl	80077ec <GPIO_PinAFConfig>
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SCK_PINSRC, 0x00);
 800e84e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e852:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e856:	f04f 010a 	mov.w	r1, #10
 800e85a:	f04f 0200 	mov.w	r2, #0
 800e85e:	f7f8 ffc5 	bl	80077ec <GPIO_PinAFConfig>
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SD_PINSRC, 0x00);  
 800e862:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e866:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e86a:	f04f 010c 	mov.w	r1, #12
 800e86e:	f04f 0200 	mov.w	r2, #0
 800e872:	f7f8 ffbb 	bl	80077ec <GPIO_PinAFConfig>
  
#ifdef CODEC_MCLK_ENABLED
  /* CODEC_I2S pins deinitialization: MCK pin */
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_MCK_PIN; 
 800e876:	f04f 0380 	mov.w	r3, #128	; 0x80
 800e87a:	603b      	str	r3, [r7, #0]
  GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure);   
 800e87c:	463b      	mov	r3, r7
 800e87e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e882:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e886:	4619      	mov	r1, r3
 800e888:	f7f8 fe1a 	bl	80074c0 <GPIO_Init>
  /* Disconnect pins from I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_MCK_GPIO, CODEC_I2S_MCK_PINSRC, CODEC_I2S_GPIO_AF); 
 800e88c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e890:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800e894:	f04f 0107 	mov.w	r1, #7
 800e898:	f04f 0206 	mov.w	r2, #6
 800e89c:	f7f8 ffa6 	bl	80077ec <GPIO_PinAFConfig>
#endif /* CODEC_MCLK_ENABLED */    
}
 800e8a0:	f107 0708 	add.w	r7, r7, #8
 800e8a4:	46bd      	mov	sp, r7
 800e8a6:	bd80      	pop	{r7, pc}

0800e8a8 <Delay>:
  * @brief  Inserts a delay time (not accurate timing).
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void Delay( __IO uint32_t nCount)
{
 800e8a8:	b480      	push	{r7}
 800e8aa:	b083      	sub	sp, #12
 800e8ac:	af00      	add	r7, sp, #0
 800e8ae:	6078      	str	r0, [r7, #4]
  for (; nCount != 0; nCount--);
 800e8b0:	e003      	b.n	800e8ba <Delay+0x12>
 800e8b2:	687b      	ldr	r3, [r7, #4]
 800e8b4:	f103 33ff 	add.w	r3, r3, #4294967295
 800e8b8:	607b      	str	r3, [r7, #4]
 800e8ba:	687b      	ldr	r3, [r7, #4]
 800e8bc:	2b00      	cmp	r3, #0
 800e8be:	d1f8      	bne.n	800e8b2 <Delay+0xa>
}
 800e8c0:	f107 070c 	add.w	r7, r7, #12
 800e8c4:	46bd      	mov	sp, r7
 800e8c6:	bc80      	pop	{r7}
 800e8c8:	4770      	bx	lr
 800e8ca:	bf00      	nop

0800e8cc <Codec_TIMEOUT_UserCallback>:
  * @brief  Basic management of the timeout situation.
  * @param  None
  * @retval None
  */
uint32_t Codec_TIMEOUT_UserCallback(void)
{
 800e8cc:	b480      	push	{r7}
 800e8ce:	af00      	add	r7, sp, #0
  /* Block communication and all processes */
  while (1)
  {   
  }
 800e8d0:	e7fe      	b.n	800e8d0 <Codec_TIMEOUT_UserCallback+0x4>
 800e8d2:	bf00      	nop

0800e8d4 <Audio_MAL_Init>:
  *         from Media to the I2S peripheral.
  * @param  None
  * @retval None
  */
static void Audio_MAL_Init(void)  
{ 
 800e8d4:	b580      	push	{r7, lr}
 800e8d6:	b082      	sub	sp, #8
 800e8d8:	af00      	add	r7, sp, #0
#else  
#if defined(AUDIO_MAL_DMA_IT_TC_EN) || defined(AUDIO_MAL_DMA_IT_HT_EN) || defined(AUDIO_MAL_DMA_IT_TE_EN)
  NVIC_InitTypeDef NVIC_InitStructure;
#endif

  if (CurrAudioInterface == AUDIO_INTERFACE_I2S)
 800e8da:	f240 0354 	movw	r3, #84	; 0x54
 800e8de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e8e2:	681b      	ldr	r3, [r3, #0]
 800e8e4:	2b01      	cmp	r3, #1
 800e8e6:	f040 80bc 	bne.w	800ea62 <Audio_MAL_Init+0x18e>
  {
    /* Enable the DMA clock */
    RCC_AHB1PeriphClockCmd(AUDIO_MAL_DMA_CLOCK, ENABLE); 
 800e8ea:	f240 0358 	movw	r3, #88	; 0x58
 800e8ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e8f2:	681b      	ldr	r3, [r3, #0]
 800e8f4:	4618      	mov	r0, r3
 800e8f6:	f04f 0101 	mov.w	r1, #1
 800e8fa:	f7fa f9b7 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
    
    /* Configure the DMA Stream */
    DMA_Cmd(AUDIO_MAL_DMA_STREAM, DISABLE);
 800e8fe:	f240 035c 	movw	r3, #92	; 0x5c
 800e902:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e906:	681b      	ldr	r3, [r3, #0]
 800e908:	4618      	mov	r0, r3
 800e90a:	f04f 0100 	mov.w	r1, #0
 800e90e:	f7f8 f961 	bl	8006bd4 <DMA_Cmd>
    DMA_DeInit(AUDIO_MAL_DMA_STREAM);
 800e912:	f240 035c 	movw	r3, #92	; 0x5c
 800e916:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e91a:	681b      	ldr	r3, [r3, #0]
 800e91c:	4618      	mov	r0, r3
 800e91e:	f7f7 ff99 	bl	8006854 <DMA_DeInit>
    /* Set the parameters to be configured */
    DMA_InitStructure.DMA_Channel = AUDIO_MAL_DMA_CHANNEL;  
 800e922:	f640 2300 	movw	r3, #2560	; 0xa00
 800e926:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e92a:	681a      	ldr	r2, [r3, #0]
 800e92c:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e930:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e934:	601a      	str	r2, [r3, #0]
    DMA_InitStructure.DMA_PeripheralBaseAddr = AUDIO_MAL_DMA_DREG;
 800e936:	f240 0360 	movw	r3, #96	; 0x60
 800e93a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e93e:	681a      	ldr	r2, [r3, #0]
 800e940:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e944:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e948:	605a      	str	r2, [r3, #4]
    DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)0;      /* This field will be configured in play function */
 800e94a:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e94e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e952:	f04f 0200 	mov.w	r2, #0
 800e956:	609a      	str	r2, [r3, #8]
    DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 800e958:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e95c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e960:	f04f 0240 	mov.w	r2, #64	; 0x40
 800e964:	60da      	str	r2, [r3, #12]
    DMA_InitStructure.DMA_BufferSize = (uint32_t)0xFFFE;      /* This field will be configured in play function */
 800e966:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e96a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e96e:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 800e972:	611a      	str	r2, [r3, #16]
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800e974:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e978:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e97c:	f04f 0200 	mov.w	r2, #0
 800e980:	615a      	str	r2, [r3, #20]
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800e982:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e986:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e98a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800e98e:	619a      	str	r2, [r3, #24]
    DMA_InitStructure.DMA_PeripheralDataSize = AUDIO_MAL_DMA_PERIPH_DATA_SIZE;
 800e990:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e994:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e998:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800e99c:	61da      	str	r2, [r3, #28]
    DMA_InitStructure.DMA_MemoryDataSize = AUDIO_MAL_DMA_MEM_DATA_SIZE; 
 800e99e:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e9a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e9a6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800e9aa:	621a      	str	r2, [r3, #32]
#ifdef AUDIO_MAL_MODE_NORMAL
    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 800e9ac:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e9b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e9b4:	f04f 0200 	mov.w	r2, #0
 800e9b8:	625a      	str	r2, [r3, #36]	; 0x24
#elif defined(AUDIO_MAL_MODE_CIRCULAR)
    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
#else
#error "AUDIO_MAL_MODE_NORMAL or AUDIO_MAL_MODE_CIRCULAR should be selected !!"
#endif /* AUDIO_MAL_MODE_NORMAL */  
    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 800e9ba:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e9be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e9c2:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800e9c6:	629a      	str	r2, [r3, #40]	; 0x28
    DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
 800e9c8:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e9cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e9d0:	f04f 0200 	mov.w	r2, #0
 800e9d4:	62da      	str	r2, [r3, #44]	; 0x2c
    DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 800e9d6:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e9da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e9de:	f04f 0200 	mov.w	r2, #0
 800e9e2:	631a      	str	r2, [r3, #48]	; 0x30
    DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
 800e9e4:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e9e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e9ec:	f04f 0200 	mov.w	r2, #0
 800e9f0:	635a      	str	r2, [r3, #52]	; 0x34
    DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;  
 800e9f2:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800e9f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e9fa:	f04f 0200 	mov.w	r2, #0
 800e9fe:	639a      	str	r2, [r3, #56]	; 0x38
    DMA_Init(AUDIO_MAL_DMA_STREAM, &DMA_InitStructure);  
 800ea00:	f240 035c 	movw	r3, #92	; 0x5c
 800ea04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ea08:	681b      	ldr	r3, [r3, #0]
 800ea0a:	4618      	mov	r0, r3
 800ea0c:	f244 51c4 	movw	r1, #17860	; 0x45c4
 800ea10:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800ea14:	f7f8 f840 	bl	8006a98 <DMA_Init>
    
    /* Enable the selected DMA interrupts (selected in "stm32f4_discovery_eval_audio_codec.h" defines) */
#ifdef AUDIO_MAL_DMA_IT_TC_EN
    DMA_ITConfig(AUDIO_MAL_DMA_STREAM, DMA_IT_TC, ENABLE);
 800ea18:	f240 035c 	movw	r3, #92	; 0x5c
 800ea1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ea20:	681b      	ldr	r3, [r3, #0]
 800ea22:	4618      	mov	r0, r3
 800ea24:	f04f 0110 	mov.w	r1, #16
 800ea28:	f04f 0201 	mov.w	r2, #1
 800ea2c:	f7f8 fa50 	bl	8006ed0 <DMA_ITConfig>
    DMA_ITConfig(AUDIO_MAL_DMA_STREAM, DMA_IT_TE | DMA_IT_FE | DMA_IT_DME, ENABLE);
#endif /* AUDIO_MAL_DMA_IT_TE_EN */
    
#if defined(AUDIO_MAL_DMA_IT_TC_EN) || defined(AUDIO_MAL_DMA_IT_HT_EN) || defined(AUDIO_MAL_DMA_IT_TE_EN)
    /* I2S DMA IRQ Channel configuration */
    NVIC_SetPriorityGrouping(NVIC_PriorityGroup_4);		//added for FreeRTOS support in Tansfercomplete callback
 800ea30:	f44f 7040 	mov.w	r0, #768	; 0x300
 800ea34:	f7fe ff8c 	bl	800d950 <NVIC_SetPriorityGrouping>

    NVIC_InitStructure.NVIC_IRQChannel = AUDIO_MAL_DMA_IRQ;
 800ea38:	f240 0364 	movw	r3, #100	; 0x64
 800ea3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ea40:	681b      	ldr	r3, [r3, #0]
 800ea42:	b2db      	uxtb	r3, r3
 800ea44:	713b      	strb	r3, [r7, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = EVAL_AUDIO_IRQ_PREPRIO;
 800ea46:	f04f 030d 	mov.w	r3, #13
 800ea4a:	717b      	strb	r3, [r7, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = EVAL_AUDIO_IRQ_SUBRIO;
 800ea4c:	f04f 0300 	mov.w	r3, #0
 800ea50:	71bb      	strb	r3, [r7, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800ea52:	f04f 0301 	mov.w	r3, #1
 800ea56:	71fb      	strb	r3, [r7, #7]
    NVIC_Init(&NVIC_InitStructure);
 800ea58:	f107 0304 	add.w	r3, r7, #4
 800ea5c:	4618      	mov	r0, r3
 800ea5e:	f7f7 fb87 	bl	8006170 <NVIC_Init>
    NVIC_Init(&NVIC_InitStructure);
#endif 
  }
#endif /* DAC_USE_I2S_DMA */
  
  if (CurrAudioInterface == AUDIO_INTERFACE_I2S)
 800ea62:	f240 0354 	movw	r3, #84	; 0x54
 800ea66:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ea6a:	681b      	ldr	r3, [r3, #0]
 800ea6c:	2b01      	cmp	r3, #1
 800ea6e:	d10a      	bne.n	800ea86 <Audio_MAL_Init+0x1b2>
  {
    /* Enable the I2S DMA request */
    SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, ENABLE);  
 800ea70:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800ea74:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800ea78:	f04f 0102 	mov.w	r1, #2
 800ea7c:	f04f 0201 	mov.w	r2, #1
 800ea80:	f7fc fde6 	bl	800b650 <SPI_I2S_DMACmd>
 800ea84:	e01c      	b.n	800eac0 <Audio_MAL_Init+0x1ec>
  }
  else
  {
    /* Configure the STM32 DAC to geenrate audio analog signal */
    DAC_Config();
 800ea86:	f000 f935 	bl	800ecf4 <DAC_Config>
    
#ifndef DAC_USE_I2S_DMA
    /* Enable the I2S interrupt used to write into the DAC register */
    SPI_I2S_ITConfig(SPI3, SPI_I2S_IT_TXE, ENABLE);
 800ea8a:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800ea8e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800ea92:	f04f 0171 	mov.w	r1, #113	; 0x71
 800ea96:	f04f 0201 	mov.w	r2, #1
 800ea9a:	f7fc fdfd 	bl	800b698 <SPI_I2S_ITConfig>
    
    /* I2S DMA IRQ Channel configuration */
    NVIC_InitStructure.NVIC_IRQChannel = CODEC_I2S_IRQ;
 800ea9e:	f04f 0333 	mov.w	r3, #51	; 0x33
 800eaa2:	713b      	strb	r3, [r7, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = EVAL_AUDIO_IRQ_PREPRIO;
 800eaa4:	f04f 030d 	mov.w	r3, #13
 800eaa8:	717b      	strb	r3, [r7, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = EVAL_AUDIO_IRQ_SUBRIO;
 800eaaa:	f04f 0300 	mov.w	r3, #0
 800eaae:	71bb      	strb	r3, [r7, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800eab0:	f04f 0301 	mov.w	r3, #1
 800eab4:	71fb      	strb	r3, [r7, #7]
    NVIC_Init(&NVIC_InitStructure); 
 800eab6:	f107 0304 	add.w	r3, r7, #4
 800eaba:	4618      	mov	r0, r3
 800eabc:	f7f7 fb58 	bl	8006170 <NVIC_Init>
    /* Enable the I2S DMA request */
    SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Rx, ENABLE);   
#endif /* DAC_USE_I2S_DMA */
  }
#endif
}
 800eac0:	f107 0708 	add.w	r7, r7, #8
 800eac4:	46bd      	mov	sp, r7
 800eac6:	bd80      	pop	{r7, pc}

0800eac8 <Audio_MAL_DeInit>:
  * @brief  Restore default state of the used Media.
  * @param  None
  * @retval None
  */
static void Audio_MAL_DeInit(void)  
{   
 800eac8:	b580      	push	{r7, lr}
 800eaca:	b082      	sub	sp, #8
 800eacc:	af00      	add	r7, sp, #0
#if defined(AUDIO_MAL_DMA_IT_TC_EN) || defined(AUDIO_MAL_DMA_IT_HT_EN) || defined(AUDIO_MAL_DMA_IT_TE_EN)
  NVIC_InitTypeDef NVIC_InitStructure;  
  
  /* Deinitialize the NVIC interrupt for the I2S DMA Stream */
  NVIC_InitStructure.NVIC_IRQChannel = AUDIO_MAL_DMA_IRQ;
 800eace:	f240 0364 	movw	r3, #100	; 0x64
 800ead2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ead6:	681b      	ldr	r3, [r3, #0]
 800ead8:	b2db      	uxtb	r3, r3
 800eada:	713b      	strb	r3, [r7, #4]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = EVAL_AUDIO_IRQ_PREPRIO;
 800eadc:	f04f 030d 	mov.w	r3, #13
 800eae0:	717b      	strb	r3, [r7, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = EVAL_AUDIO_IRQ_SUBRIO;
 800eae2:	f04f 0300 	mov.w	r3, #0
 800eae6:	71bb      	strb	r3, [r7, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
 800eae8:	f04f 0300 	mov.w	r3, #0
 800eaec:	71fb      	strb	r3, [r7, #7]
  NVIC_Init(&NVIC_InitStructure);  
 800eaee:	f107 0304 	add.w	r3, r7, #4
 800eaf2:	4618      	mov	r0, r3
 800eaf4:	f7f7 fb3c 	bl	8006170 <NVIC_Init>
#endif 
  
  /* Disable the DMA stream before the deinit */
  DMA_Cmd(AUDIO_MAL_DMA_STREAM, DISABLE);
 800eaf8:	f240 035c 	movw	r3, #92	; 0x5c
 800eafc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eb00:	681b      	ldr	r3, [r3, #0]
 800eb02:	4618      	mov	r0, r3
 800eb04:	f04f 0100 	mov.w	r1, #0
 800eb08:	f7f8 f864 	bl	8006bd4 <DMA_Cmd>
  
  /* Dinitialize the DMA Stream */
  DMA_DeInit(AUDIO_MAL_DMA_STREAM);
 800eb0c:	f240 035c 	movw	r3, #92	; 0x5c
 800eb10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eb14:	681b      	ldr	r3, [r3, #0]
 800eb16:	4618      	mov	r0, r3
 800eb18:	f7f7 fe9c 	bl	8006854 <DMA_DeInit>
  
  /* 
     The DMA clock is not disabled, since it can be used by other streams 
                                                                          */ 
}
 800eb1c:	f107 0708 	add.w	r7, r7, #8
 800eb20:	46bd      	mov	sp, r7
 800eb22:	bd80      	pop	{r7, pc}

0800eb24 <Audio_MAL_Play>:
  * @brief  Starts playing audio stream from the audio Media.
  * @param  None
  * @retval None
  */
void Audio_MAL_Play(uint32_t Addr, uint32_t Size)
{         
 800eb24:	b580      	push	{r7, lr}
 800eb26:	b082      	sub	sp, #8
 800eb28:	af00      	add	r7, sp, #0
 800eb2a:	6078      	str	r0, [r7, #4]
 800eb2c:	6039      	str	r1, [r7, #0]
  if (CurrAudioInterface == AUDIO_INTERFACE_I2S)
 800eb2e:	f240 0354 	movw	r3, #84	; 0x54
 800eb32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eb36:	681b      	ldr	r3, [r3, #0]
 800eb38:	2b01      	cmp	r3, #1
 800eb3a:	d124      	bne.n	800eb86 <Audio_MAL_Play+0x62>
  {
    /* Configure the buffer address and size */
    DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)Addr;
 800eb3c:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800eb40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eb44:	687a      	ldr	r2, [r7, #4]
 800eb46:	609a      	str	r2, [r3, #8]
    DMA_InitStructure.DMA_BufferSize = (uint32_t)Size/2;
 800eb48:	683b      	ldr	r3, [r7, #0]
 800eb4a:	ea4f 0253 	mov.w	r2, r3, lsr #1
 800eb4e:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800eb52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eb56:	611a      	str	r2, [r3, #16]
    
    /* Configure the DMA Stream with the new parameters */
    DMA_Init(AUDIO_MAL_DMA_STREAM, &DMA_InitStructure);
 800eb58:	f240 035c 	movw	r3, #92	; 0x5c
 800eb5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eb60:	681b      	ldr	r3, [r3, #0]
 800eb62:	4618      	mov	r0, r3
 800eb64:	f244 51c4 	movw	r1, #17860	; 0x45c4
 800eb68:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800eb6c:	f7f7 ff94 	bl	8006a98 <DMA_Init>
    
    /* Enable the I2S DMA Stream*/
    DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE);   
 800eb70:	f240 035c 	movw	r3, #92	; 0x5c
 800eb74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eb78:	681b      	ldr	r3, [r3, #0]
 800eb7a:	4618      	mov	r0, r3
 800eb7c:	f04f 0101 	mov.w	r1, #1
 800eb80:	f7f8 f828 	bl	8006bd4 <DMA_Cmd>
 800eb84:	e021      	b.n	800ebca <Audio_MAL_Play+0xa6>
  }
#ifndef DAC_USE_I2S_DMA
  else
  {
    /* Configure the buffer address and size */
    DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)Addr;
 800eb86:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800eb8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eb8e:	687a      	ldr	r2, [r7, #4]
 800eb90:	609a      	str	r2, [r3, #8]
    DMA_InitStructure.DMA_BufferSize = (uint32_t)Size;
 800eb92:	f244 53c4 	movw	r3, #17860	; 0x45c4
 800eb96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eb9a:	683a      	ldr	r2, [r7, #0]
 800eb9c:	611a      	str	r2, [r3, #16]
    
    /* Configure the DMA Stream with the new parameters */
    DMA_Init(AUDIO_MAL_DMA_STREAM, &DMA_InitStructure);
 800eb9e:	f240 035c 	movw	r3, #92	; 0x5c
 800eba2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eba6:	681b      	ldr	r3, [r3, #0]
 800eba8:	4618      	mov	r0, r3
 800ebaa:	f244 51c4 	movw	r1, #17860	; 0x45c4
 800ebae:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800ebb2:	f7f7 ff71 	bl	8006a98 <DMA_Init>
    
    /* Enable the I2S DMA Stream*/
    DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE);
 800ebb6:	f240 035c 	movw	r3, #92	; 0x5c
 800ebba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ebbe:	681b      	ldr	r3, [r3, #0]
 800ebc0:	4618      	mov	r0, r3
 800ebc2:	f04f 0101 	mov.w	r1, #1
 800ebc6:	f7f8 f805 	bl	8006bd4 <DMA_Cmd>
  }
#endif /* DAC_USE_I2S_DMA */
  
  /* If the I2S peripheral is still not enabled, enable it */
  if ((CODEC_I2S->I2SCFGR & I2S_ENABLE_MASK) == 0)
 800ebca:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800ebce:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ebd2:	8b9b      	ldrh	r3, [r3, #28]
 800ebd4:	b29b      	uxth	r3, r3
 800ebd6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800ebda:	2b00      	cmp	r3, #0
 800ebdc:	d107      	bne.n	800ebee <Audio_MAL_Play+0xca>
  {
    I2S_Cmd(CODEC_I2S, ENABLE);
 800ebde:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800ebe2:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800ebe6:	f04f 0101 	mov.w	r1, #1
 800ebea:	f7fc fbab 	bl	800b344 <I2S_Cmd>
  }
}
 800ebee:	f107 0708 	add.w	r7, r7, #8
 800ebf2:	46bd      	mov	sp, r7
 800ebf4:	bd80      	pop	{r7, pc}
 800ebf6:	bf00      	nop

0800ebf8 <Audio_MAL_PauseResume>:
  *              from 0) to resume. 
  * @param  Addr: Address from/at which the audio stream should resume/pause.
  * @retval None
  */
static void Audio_MAL_PauseResume(uint32_t Cmd, uint32_t Addr)
{
 800ebf8:	b580      	push	{r7, lr}
 800ebfa:	b082      	sub	sp, #8
 800ebfc:	af00      	add	r7, sp, #0
 800ebfe:	6078      	str	r0, [r7, #4]
 800ec00:	6039      	str	r1, [r7, #0]
  /* Pause the audio file playing */
  if (Cmd == AUDIO_PAUSE)
 800ec02:	687b      	ldr	r3, [r7, #4]
 800ec04:	2b00      	cmp	r3, #0
 800ec06:	d114      	bne.n	800ec32 <Audio_MAL_PauseResume+0x3a>
  {   
    /* Disable the I2S DMA request */
    SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, DISABLE);
 800ec08:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800ec0c:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800ec10:	f04f 0102 	mov.w	r1, #2
 800ec14:	f04f 0200 	mov.w	r2, #0
 800ec18:	f7fc fd1a 	bl	800b650 <SPI_I2S_DMACmd>
    /* Pause the I2S DMA Stream 
        Note. For the STM32F40x devices, the DMA implements a pause feature, 
              by disabling the stream, all configuration is preserved and data 
              transfer is paused till the next enable of the stream.
              This feature is not available on STM32F40x devices. */
    DMA_Cmd(AUDIO_MAL_DMA_STREAM, DISABLE);
 800ec1c:	f240 035c 	movw	r3, #92	; 0x5c
 800ec20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ec24:	681b      	ldr	r3, [r3, #0]
 800ec26:	4618      	mov	r0, r3
 800ec28:	f04f 0100 	mov.w	r1, #0
 800ec2c:	f7f7 ffd2 	bl	8006bd4 <DMA_Cmd>
 800ec30:	e025      	b.n	800ec7e <Audio_MAL_PauseResume+0x86>
  }
  else /* AUDIO_RESUME */
  {
    /* Enable the I2S DMA request */
    SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, ENABLE);
 800ec32:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800ec36:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800ec3a:	f04f 0102 	mov.w	r1, #2
 800ec3e:	f04f 0201 	mov.w	r2, #1
 800ec42:	f7fc fd05 	bl	800b650 <SPI_I2S_DMACmd>
    /* Resume the I2S DMA Stream 
        Note. For the STM32F40x devices, the DMA implements a pause feature, 
              by disabling the stream, all configuration is preserved and data 
              transfer is paused till the next enable of the stream.
              This feature is not available on STM32F40x devices. */
    DMA_Cmd(AUDIO_MAL_DMA_STREAM, ENABLE);
 800ec46:	f240 035c 	movw	r3, #92	; 0x5c
 800ec4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ec4e:	681b      	ldr	r3, [r3, #0]
 800ec50:	4618      	mov	r0, r3
 800ec52:	f04f 0101 	mov.w	r1, #1
 800ec56:	f7f7 ffbd 	bl	8006bd4 <DMA_Cmd>
    
    /* If the I2S peripheral is still not enabled, enable it */
    if ((CODEC_I2S->I2SCFGR & I2S_ENABLE_MASK) == 0)
 800ec5a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800ec5e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800ec62:	8b9b      	ldrh	r3, [r3, #28]
 800ec64:	b29b      	uxth	r3, r3
 800ec66:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800ec6a:	2b00      	cmp	r3, #0
 800ec6c:	d107      	bne.n	800ec7e <Audio_MAL_PauseResume+0x86>
    {
      I2S_Cmd(CODEC_I2S, ENABLE);
 800ec6e:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800ec72:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800ec76:	f04f 0101 	mov.w	r1, #1
 800ec7a:	f7fc fb63 	bl	800b344 <I2S_Cmd>
    }    
  } 
}
 800ec7e:	f107 0708 	add.w	r7, r7, #8
 800ec82:	46bd      	mov	sp, r7
 800ec84:	bd80      	pop	{r7, pc}
 800ec86:	bf00      	nop

0800ec88 <Audio_MAL_Stop>:
  * @brief  Stops audio stream playing on the used Media.
  * @param  None
  * @retval None
  */
static void Audio_MAL_Stop(void)
{   
 800ec88:	b580      	push	{r7, lr}
 800ec8a:	af00      	add	r7, sp, #0
  /* Stop the Transfer on the I2S side: Stop and disable the DMA stream */
  DMA_Cmd(AUDIO_MAL_DMA_STREAM, DISABLE);
 800ec8c:	f240 035c 	movw	r3, #92	; 0x5c
 800ec90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ec94:	681b      	ldr	r3, [r3, #0]
 800ec96:	4618      	mov	r0, r3
 800ec98:	f04f 0100 	mov.w	r1, #0
 800ec9c:	f7f7 ff9a 	bl	8006bd4 <DMA_Cmd>

  /* Clear all the DMA flags for the next transfer */
  DMA_ClearFlag(AUDIO_MAL_DMA_STREAM, AUDIO_MAL_DMA_FLAG_TC |AUDIO_MAL_DMA_FLAG_HT | \
 800eca0:	f240 035c 	movw	r3, #92	; 0x5c
 800eca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800eca8:	681a      	ldr	r2, [r3, #0]
 800ecaa:	f240 0368 	movw	r3, #104	; 0x68
 800ecae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ecb2:	6819      	ldr	r1, [r3, #0]
 800ecb4:	f240 036c 	movw	r3, #108	; 0x6c
 800ecb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ecbc:	681b      	ldr	r3, [r3, #0]
 800ecbe:	4319      	orrs	r1, r3
 800ecc0:	f240 0370 	movw	r3, #112	; 0x70
 800ecc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ecc8:	681b      	ldr	r3, [r3, #0]
 800ecca:	4319      	orrs	r1, r3
 800eccc:	f240 0374 	movw	r3, #116	; 0x74
 800ecd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ecd4:	681b      	ldr	r3, [r3, #0]
 800ecd6:	430b      	orrs	r3, r1
 800ecd8:	4610      	mov	r0, r2
 800ecda:	4619      	mov	r1, r3
 800ecdc:	f7f8 f8c6 	bl	8006e6c <DMA_ClearFlag>
  /*  
           The I2S DMA requests are not disabled here.
                                                            */
  
  /* In all modes, disable the I2S peripheral */
  I2S_Cmd(CODEC_I2S, DISABLE);
 800ece0:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
 800ece4:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800ece8:	f04f 0100 	mov.w	r1, #0
 800ecec:	f7fc fb2a 	bl	800b344 <I2S_Cmd>
}
 800ecf0:	bd80      	pop	{r7, pc}
 800ecf2:	bf00      	nop

0800ecf4 <DAC_Config>:
  * @brief  DAC  Channel1 Configuration
  * @param  None
  * @retval None
  */
void DAC_Config(void)
{
 800ecf4:	b580      	push	{r7, lr}
 800ecf6:	b086      	sub	sp, #24
 800ecf8:	af00      	add	r7, sp, #0
  DAC_InitTypeDef  DAC_InitStructure;
  GPIO_InitTypeDef GPIO_InitStructure;

  /* DMA1 clock and GPIOA clock enable (to be used with DAC) */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1 | RCC_AHB1Periph_GPIOA, ENABLE);
 800ecfa:	f04f 0001 	mov.w	r0, #1
 800ecfe:	f2c0 0020 	movt	r0, #32
 800ed02:	f04f 0101 	mov.w	r1, #1
 800ed06:	f7f9 ffb1 	bl	8008c6c <RCC_AHB1PeriphClockCmd>

  /* DAC Periph clock enable */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
 800ed0a:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 800ed0e:	f04f 0101 	mov.w	r1, #1
 800ed12:	f7fa f82f 	bl	8008d74 <RCC_APB1PeriphClockCmd>

  /* DAC channel 1 & 2 (DAC_OUT1 = PA.4) configuration */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
 800ed16:	f04f 0310 	mov.w	r3, #16
 800ed1a:	603b      	str	r3, [r7, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 800ed1c:	f04f 0303 	mov.w	r3, #3
 800ed20:	713b      	strb	r3, [r7, #4]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800ed22:	f04f 0300 	mov.w	r3, #0
 800ed26:	71fb      	strb	r3, [r7, #7]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800ed28:	463b      	mov	r3, r7
 800ed2a:	f04f 0000 	mov.w	r0, #0
 800ed2e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800ed32:	4619      	mov	r1, r3
 800ed34:	f7f8 fbc4 	bl	80074c0 <GPIO_Init>

  /* DAC channel1 Configuration */
  DAC_InitStructure.DAC_Trigger = DAC_Trigger_None;
 800ed38:	f04f 0300 	mov.w	r3, #0
 800ed3c:	60bb      	str	r3, [r7, #8]
  DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
 800ed3e:	f04f 0300 	mov.w	r3, #0
 800ed42:	60fb      	str	r3, [r7, #12]
  DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
 800ed44:	f04f 0300 	mov.w	r3, #0
 800ed48:	617b      	str	r3, [r7, #20]
  DAC_Init(AUDIO_DAC_CHANNEL, &DAC_InitStructure);
 800ed4a:	f107 0308 	add.w	r3, r7, #8
 800ed4e:	f04f 0000 	mov.w	r0, #0
 800ed52:	4619      	mov	r1, r3
 800ed54:	f7f7 faf6 	bl	8006344 <DAC_Init>

  /* Enable DAC Channel1 */
  DAC_Cmd(AUDIO_DAC_CHANNEL, ENABLE);
 800ed58:	f04f 0000 	mov.w	r0, #0
 800ed5c:	f04f 0101 	mov.w	r1, #1
 800ed60:	f7f7 fb44 	bl	80063ec <DAC_Cmd>
}
 800ed64:	f107 0718 	add.w	r7, r7, #24
 800ed68:	46bd      	mov	sp, r7
 800ed6a:	bd80      	pop	{r7, pc}

0800ed6c <LIS302DL_Init>:
  * @param  LIS302DL_Config_Struct: pointer to a LIS302DL_Config_TypeDef structure 
  *         that contains the configuration setting for the LIS302DL.
  * @retval None
  */
void LIS302DL_Init(LIS302DL_InitTypeDef *LIS302DL_InitStruct)
{
 800ed6c:	b580      	push	{r7, lr}
 800ed6e:	b084      	sub	sp, #16
 800ed70:	af00      	add	r7, sp, #0
 800ed72:	6078      	str	r0, [r7, #4]
  uint8_t ctrl = 0x00;
 800ed74:	f04f 0300 	mov.w	r3, #0
 800ed78:	73fb      	strb	r3, [r7, #15]
  
  /* Configure the low level interface ---------------------------------------*/
  LIS302DL_LowLevel_Init();
 800ed7a:	f000 f9ed 	bl	800f158 <LIS302DL_LowLevel_Init>
  
  /* Configure MEMS: data rate, power mode, full scale, self test and axes */
  ctrl = (uint8_t) (LIS302DL_InitStruct->Output_DataRate | LIS302DL_InitStruct->Power_Mode | \
 800ed7e:	687b      	ldr	r3, [r7, #4]
 800ed80:	785a      	ldrb	r2, [r3, #1]
 800ed82:	687b      	ldr	r3, [r7, #4]
 800ed84:	781b      	ldrb	r3, [r3, #0]
 800ed86:	4313      	orrs	r3, r2
 800ed88:	b2da      	uxtb	r2, r3
                    LIS302DL_InitStruct->Full_Scale | LIS302DL_InitStruct->Self_Test | \
 800ed8a:	687b      	ldr	r3, [r7, #4]
 800ed8c:	78db      	ldrb	r3, [r3, #3]
  
  /* Configure the low level interface ---------------------------------------*/
  LIS302DL_LowLevel_Init();
  
  /* Configure MEMS: data rate, power mode, full scale, self test and axes */
  ctrl = (uint8_t) (LIS302DL_InitStruct->Output_DataRate | LIS302DL_InitStruct->Power_Mode | \
 800ed8e:	4313      	orrs	r3, r2
 800ed90:	b2da      	uxtb	r2, r3
                    LIS302DL_InitStruct->Full_Scale | LIS302DL_InitStruct->Self_Test | \
 800ed92:	687b      	ldr	r3, [r7, #4]
 800ed94:	791b      	ldrb	r3, [r3, #4]
  
  /* Configure the low level interface ---------------------------------------*/
  LIS302DL_LowLevel_Init();
  
  /* Configure MEMS: data rate, power mode, full scale, self test and axes */
  ctrl = (uint8_t) (LIS302DL_InitStruct->Output_DataRate | LIS302DL_InitStruct->Power_Mode | \
 800ed96:	4313      	orrs	r3, r2
 800ed98:	b2da      	uxtb	r2, r3
                    LIS302DL_InitStruct->Full_Scale | LIS302DL_InitStruct->Self_Test | \
                    LIS302DL_InitStruct->Axes_Enable);
 800ed9a:	687b      	ldr	r3, [r7, #4]
 800ed9c:	789b      	ldrb	r3, [r3, #2]
  
  /* Configure the low level interface ---------------------------------------*/
  LIS302DL_LowLevel_Init();
  
  /* Configure MEMS: data rate, power mode, full scale, self test and axes */
  ctrl = (uint8_t) (LIS302DL_InitStruct->Output_DataRate | LIS302DL_InitStruct->Power_Mode | \
 800ed9e:	4313      	orrs	r3, r2
 800eda0:	b2db      	uxtb	r3, r3
 800eda2:	73fb      	strb	r3, [r7, #15]
                    LIS302DL_InitStruct->Full_Scale | LIS302DL_InitStruct->Self_Test | \
                    LIS302DL_InitStruct->Axes_Enable);
  
  /* Write value to MEMS CTRL_REG1 regsister */
  LIS302DL_Write(&ctrl, LIS302DL_CTRL_REG1_ADDR, 1);
 800eda4:	f107 030f 	add.w	r3, r7, #15
 800eda8:	4618      	mov	r0, r3
 800edaa:	f04f 0120 	mov.w	r1, #32
 800edae:	f04f 0201 	mov.w	r2, #1
 800edb2:	f000 f8ed 	bl	800ef90 <LIS302DL_Write>
}
 800edb6:	f107 0710 	add.w	r7, r7, #16
 800edba:	46bd      	mov	sp, r7
 800edbc:	bd80      	pop	{r7, pc}
 800edbe:	bf00      	nop

0800edc0 <LIS302DL_FilterConfig>:
  * @param  LIS302DL_Filter_ConfigTypeDef: pointer to a LIS302DL_FilterConfig_TypeDef 
  *         structure that contains the configuration setting for the LIS302DL Filter.
  * @retval None
  */
void LIS302DL_FilterConfig(LIS302DL_FilterConfigTypeDef *LIS302DL_FilterConfigStruct)
{
 800edc0:	b580      	push	{r7, lr}
 800edc2:	b084      	sub	sp, #16
 800edc4:	af00      	add	r7, sp, #0
 800edc6:	6078      	str	r0, [r7, #4]
  uint8_t ctrl = 0x00;
 800edc8:	f04f 0300 	mov.w	r3, #0
 800edcc:	73fb      	strb	r3, [r7, #15]
  
  /* Read CTRL_REG2 register */
  LIS302DL_Read(&ctrl, LIS302DL_CTRL_REG2_ADDR, 1);
 800edce:	f107 030f 	add.w	r3, r7, #15
 800edd2:	4618      	mov	r0, r3
 800edd4:	f04f 0121 	mov.w	r1, #33	; 0x21
 800edd8:	f04f 0201 	mov.w	r2, #1
 800eddc:	f000 f910 	bl	800f000 <LIS302DL_Read>
  
  /* Clear high pass filter cut-off level, interrupt and data selection bits*/
  ctrl &= (uint8_t)~(LIS302DL_FILTEREDDATASELECTION_OUTPUTREGISTER | \
 800ede0:	7bfb      	ldrb	r3, [r7, #15]
 800ede2:	f023 032f 	bic.w	r3, r3, #47	; 0x2f
 800ede6:	b2db      	uxtb	r3, r3
 800ede8:	73fb      	strb	r3, [r7, #15]
                     LIS302DL_HIGHPASSFILTER_LEVEL_3 | \
                     LIS302DL_HIGHPASSFILTERINTERRUPT_1_2);
  /* Configure MEMS high pass filter cut-off level, interrupt and data selection bits */                     
  ctrl |= (uint8_t)(LIS302DL_FilterConfigStruct->HighPassFilter_Data_Selection | \
 800edea:	687b      	ldr	r3, [r7, #4]
 800edec:	781a      	ldrb	r2, [r3, #0]
                    LIS302DL_FilterConfigStruct->HighPassFilter_CutOff_Frequency | \
 800edee:	687b      	ldr	r3, [r7, #4]
 800edf0:	785b      	ldrb	r3, [r3, #1]
  /* Clear high pass filter cut-off level, interrupt and data selection bits*/
  ctrl &= (uint8_t)~(LIS302DL_FILTEREDDATASELECTION_OUTPUTREGISTER | \
                     LIS302DL_HIGHPASSFILTER_LEVEL_3 | \
                     LIS302DL_HIGHPASSFILTERINTERRUPT_1_2);
  /* Configure MEMS high pass filter cut-off level, interrupt and data selection bits */                     
  ctrl |= (uint8_t)(LIS302DL_FilterConfigStruct->HighPassFilter_Data_Selection | \
 800edf2:	4313      	orrs	r3, r2
 800edf4:	b2da      	uxtb	r2, r3
                    LIS302DL_FilterConfigStruct->HighPassFilter_CutOff_Frequency | \
                    LIS302DL_FilterConfigStruct->HighPassFilter_Interrupt);
 800edf6:	687b      	ldr	r3, [r7, #4]
 800edf8:	789b      	ldrb	r3, [r3, #2]
  /* Clear high pass filter cut-off level, interrupt and data selection bits*/
  ctrl &= (uint8_t)~(LIS302DL_FILTEREDDATASELECTION_OUTPUTREGISTER | \
                     LIS302DL_HIGHPASSFILTER_LEVEL_3 | \
                     LIS302DL_HIGHPASSFILTERINTERRUPT_1_2);
  /* Configure MEMS high pass filter cut-off level, interrupt and data selection bits */                     
  ctrl |= (uint8_t)(LIS302DL_FilterConfigStruct->HighPassFilter_Data_Selection | \
 800edfa:	4313      	orrs	r3, r2
 800edfc:	b2da      	uxtb	r2, r3
 800edfe:	7bfb      	ldrb	r3, [r7, #15]
 800ee00:	4313      	orrs	r3, r2
 800ee02:	b2db      	uxtb	r3, r3
 800ee04:	73fb      	strb	r3, [r7, #15]
                    LIS302DL_FilterConfigStruct->HighPassFilter_CutOff_Frequency | \
                    LIS302DL_FilterConfigStruct->HighPassFilter_Interrupt);
  
  /* Write value to MEMS CTRL_REG2 register */
  LIS302DL_Write(&ctrl, LIS302DL_CTRL_REG2_ADDR, 1);
 800ee06:	f107 030f 	add.w	r3, r7, #15
 800ee0a:	4618      	mov	r0, r3
 800ee0c:	f04f 0121 	mov.w	r1, #33	; 0x21
 800ee10:	f04f 0201 	mov.w	r2, #1
 800ee14:	f000 f8bc 	bl	800ef90 <LIS302DL_Write>
}
 800ee18:	f107 0710 	add.w	r7, r7, #16
 800ee1c:	46bd      	mov	sp, r7
 800ee1e:	bd80      	pop	{r7, pc}

0800ee20 <LIS302DL_InterruptConfig>:
  * @param  LIS302DL_InterruptConfig_TypeDef: pointer to a LIS302DL_InterruptConfig_TypeDef 
  *         structure that contains the configuration setting for the LIS302DL Interrupt.
  * @retval None
  */
void LIS302DL_InterruptConfig(LIS302DL_InterruptConfigTypeDef *LIS302DL_IntConfigStruct)
{
 800ee20:	b580      	push	{r7, lr}
 800ee22:	b084      	sub	sp, #16
 800ee24:	af00      	add	r7, sp, #0
 800ee26:	6078      	str	r0, [r7, #4]
  uint8_t ctrl = 0x00;
 800ee28:	f04f 0300 	mov.w	r3, #0
 800ee2c:	73fb      	strb	r3, [r7, #15]
  
  /* Read CLICK_CFG register */
  LIS302DL_Read(&ctrl, LIS302DL_CLICK_CFG_REG_ADDR, 1);
 800ee2e:	f107 030f 	add.w	r3, r7, #15
 800ee32:	4618      	mov	r0, r3
 800ee34:	f04f 0138 	mov.w	r1, #56	; 0x38
 800ee38:	f04f 0201 	mov.w	r2, #1
 800ee3c:	f000 f8e0 	bl	800f000 <LIS302DL_Read>
  
  /* Configure latch Interrupt request, click interrupts and double click interrupts */                   
  ctrl = (uint8_t)(LIS302DL_IntConfigStruct->Latch_Request| \
 800ee40:	687b      	ldr	r3, [r7, #4]
 800ee42:	781a      	ldrb	r2, [r3, #0]
                   LIS302DL_IntConfigStruct->SingleClick_Axes | \
 800ee44:	687b      	ldr	r3, [r7, #4]
 800ee46:	785b      	ldrb	r3, [r3, #1]
  
  /* Read CLICK_CFG register */
  LIS302DL_Read(&ctrl, LIS302DL_CLICK_CFG_REG_ADDR, 1);
  
  /* Configure latch Interrupt request, click interrupts and double click interrupts */                   
  ctrl = (uint8_t)(LIS302DL_IntConfigStruct->Latch_Request| \
 800ee48:	4313      	orrs	r3, r2
 800ee4a:	b2da      	uxtb	r2, r3
                   LIS302DL_IntConfigStruct->SingleClick_Axes | \
                   LIS302DL_IntConfigStruct->DoubleClick_Axes);
 800ee4c:	687b      	ldr	r3, [r7, #4]
 800ee4e:	789b      	ldrb	r3, [r3, #2]
  
  /* Read CLICK_CFG register */
  LIS302DL_Read(&ctrl, LIS302DL_CLICK_CFG_REG_ADDR, 1);
  
  /* Configure latch Interrupt request, click interrupts and double click interrupts */                   
  ctrl = (uint8_t)(LIS302DL_IntConfigStruct->Latch_Request| \
 800ee50:	4313      	orrs	r3, r2
 800ee52:	b2db      	uxtb	r3, r3
 800ee54:	73fb      	strb	r3, [r7, #15]
                   LIS302DL_IntConfigStruct->SingleClick_Axes | \
                   LIS302DL_IntConfigStruct->DoubleClick_Axes);
  
  /* Write value to MEMS CLICK_CFG register */
  LIS302DL_Write(&ctrl, LIS302DL_CLICK_CFG_REG_ADDR, 1);
 800ee56:	f107 030f 	add.w	r3, r7, #15
 800ee5a:	4618      	mov	r0, r3
 800ee5c:	f04f 0138 	mov.w	r1, #56	; 0x38
 800ee60:	f04f 0201 	mov.w	r2, #1
 800ee64:	f000 f894 	bl	800ef90 <LIS302DL_Write>
}
 800ee68:	f107 0710 	add.w	r7, r7, #16
 800ee6c:	46bd      	mov	sp, r7
 800ee6e:	bd80      	pop	{r7, pc}

0800ee70 <LIS302DL_LowpowerCmd>:
  *     @arg LIS302DL_LOWPOWERMODE_POWERDOWN: Power down mode
  *     @arg LIS302DL_LOWPOWERMODE_ACTIVE: Active mode  
  * @retval None
  */
void LIS302DL_LowpowerCmd(uint8_t LowPowerMode)
{
 800ee70:	b580      	push	{r7, lr}
 800ee72:	b084      	sub	sp, #16
 800ee74:	af00      	add	r7, sp, #0
 800ee76:	4603      	mov	r3, r0
 800ee78:	71fb      	strb	r3, [r7, #7]
  uint8_t tmpreg;
  
  /* Read CTRL_REG1 register */
  LIS302DL_Read(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
 800ee7a:	f107 030f 	add.w	r3, r7, #15
 800ee7e:	4618      	mov	r0, r3
 800ee80:	f04f 0120 	mov.w	r1, #32
 800ee84:	f04f 0201 	mov.w	r2, #1
 800ee88:	f000 f8ba 	bl	800f000 <LIS302DL_Read>
  
  /* Set new low power mode configuration */
  tmpreg &= (uint8_t)~LIS302DL_LOWPOWERMODE_ACTIVE;
 800ee8c:	7bfb      	ldrb	r3, [r7, #15]
 800ee8e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800ee92:	b2db      	uxtb	r3, r3
 800ee94:	73fb      	strb	r3, [r7, #15]
  tmpreg |= LowPowerMode;
 800ee96:	7bfa      	ldrb	r2, [r7, #15]
 800ee98:	79fb      	ldrb	r3, [r7, #7]
 800ee9a:	4313      	orrs	r3, r2
 800ee9c:	b2db      	uxtb	r3, r3
 800ee9e:	73fb      	strb	r3, [r7, #15]
  
  /* Write value to MEMS CTRL_REG1 regsister */
  LIS302DL_Write(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
 800eea0:	f107 030f 	add.w	r3, r7, #15
 800eea4:	4618      	mov	r0, r3
 800eea6:	f04f 0120 	mov.w	r1, #32
 800eeaa:	f04f 0201 	mov.w	r2, #1
 800eeae:	f000 f86f 	bl	800ef90 <LIS302DL_Write>
}
 800eeb2:	f107 0710 	add.w	r7, r7, #16
 800eeb6:	46bd      	mov	sp, r7
 800eeb8:	bd80      	pop	{r7, pc}
 800eeba:	bf00      	nop

0800eebc <LIS302DL_DataRateCmd>:
  *     @arg LIS302DL_DATARATE_100: 100 Hz output data rate 
  *     @arg LIS302DL_DATARATE_400: 400 Hz output data rate    
  * @retval None
  */
void LIS302DL_DataRateCmd(uint8_t DataRateValue)
{
 800eebc:	b580      	push	{r7, lr}
 800eebe:	b084      	sub	sp, #16
 800eec0:	af00      	add	r7, sp, #0
 800eec2:	4603      	mov	r3, r0
 800eec4:	71fb      	strb	r3, [r7, #7]
  uint8_t tmpreg;
  
  /* Read CTRL_REG1 register */
  LIS302DL_Read(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
 800eec6:	f107 030f 	add.w	r3, r7, #15
 800eeca:	4618      	mov	r0, r3
 800eecc:	f04f 0120 	mov.w	r1, #32
 800eed0:	f04f 0201 	mov.w	r2, #1
 800eed4:	f000 f894 	bl	800f000 <LIS302DL_Read>
  
  /* Set new Data rate configuration */
  tmpreg &= (uint8_t)~LIS302DL_DATARATE_400;
 800eed8:	7bfb      	ldrb	r3, [r7, #15]
 800eeda:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800eede:	b2db      	uxtb	r3, r3
 800eee0:	73fb      	strb	r3, [r7, #15]
  tmpreg |= DataRateValue;
 800eee2:	7bfa      	ldrb	r2, [r7, #15]
 800eee4:	79fb      	ldrb	r3, [r7, #7]
 800eee6:	4313      	orrs	r3, r2
 800eee8:	b2db      	uxtb	r3, r3
 800eeea:	73fb      	strb	r3, [r7, #15]
  
  /* Write value to MEMS CTRL_REG1 regsister */
  LIS302DL_Write(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
 800eeec:	f107 030f 	add.w	r3, r7, #15
 800eef0:	4618      	mov	r0, r3
 800eef2:	f04f 0120 	mov.w	r1, #32
 800eef6:	f04f 0201 	mov.w	r2, #1
 800eefa:	f000 f849 	bl	800ef90 <LIS302DL_Write>
}
 800eefe:	f107 0710 	add.w	r7, r7, #16
 800ef02:	46bd      	mov	sp, r7
 800ef04:	bd80      	pop	{r7, pc}
 800ef06:	bf00      	nop

0800ef08 <LIS302DL_FullScaleCmd>:
  *     @arg LIS302DL_FULLSCALE_2_3: +-2.3g
  *     @arg LIS302DL_FULLSCALE_9_2: +-9.2g   
  * @retval None
  */
void LIS302DL_FullScaleCmd(uint8_t FS_value)
{
 800ef08:	b580      	push	{r7, lr}
 800ef0a:	b084      	sub	sp, #16
 800ef0c:	af00      	add	r7, sp, #0
 800ef0e:	4603      	mov	r3, r0
 800ef10:	71fb      	strb	r3, [r7, #7]
  uint8_t tmpreg;
  
  /* Read CTRL_REG1 register */
  LIS302DL_Read(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
 800ef12:	f107 030f 	add.w	r3, r7, #15
 800ef16:	4618      	mov	r0, r3
 800ef18:	f04f 0120 	mov.w	r1, #32
 800ef1c:	f04f 0201 	mov.w	r2, #1
 800ef20:	f000 f86e 	bl	800f000 <LIS302DL_Read>
  
  /* Set new full scale configuration */
  tmpreg &= (uint8_t)~LIS302DL_FULLSCALE_9_2;
 800ef24:	7bfb      	ldrb	r3, [r7, #15]
 800ef26:	f023 0320 	bic.w	r3, r3, #32
 800ef2a:	b2db      	uxtb	r3, r3
 800ef2c:	73fb      	strb	r3, [r7, #15]
  tmpreg |= FS_value;
 800ef2e:	7bfa      	ldrb	r2, [r7, #15]
 800ef30:	79fb      	ldrb	r3, [r7, #7]
 800ef32:	4313      	orrs	r3, r2
 800ef34:	b2db      	uxtb	r3, r3
 800ef36:	73fb      	strb	r3, [r7, #15]
  
  /* Write value to MEMS CTRL_REG1 regsister */
  LIS302DL_Write(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
 800ef38:	f107 030f 	add.w	r3, r7, #15
 800ef3c:	4618      	mov	r0, r3
 800ef3e:	f04f 0120 	mov.w	r1, #32
 800ef42:	f04f 0201 	mov.w	r2, #1
 800ef46:	f000 f823 	bl	800ef90 <LIS302DL_Write>
}
 800ef4a:	f107 0710 	add.w	r7, r7, #16
 800ef4e:	46bd      	mov	sp, r7
 800ef50:	bd80      	pop	{r7, pc}
 800ef52:	bf00      	nop

0800ef54 <LIS302DL_RebootCmd>:
  * @brief  Reboot memory content of LIS302DL
  * @param  None
  * @retval None
  */
void LIS302DL_RebootCmd(void)
{
 800ef54:	b580      	push	{r7, lr}
 800ef56:	b082      	sub	sp, #8
 800ef58:	af00      	add	r7, sp, #0
  uint8_t tmpreg;
  /* Read CTRL_REG2 register */
  LIS302DL_Read(&tmpreg, LIS302DL_CTRL_REG2_ADDR, 1);
 800ef5a:	f107 0307 	add.w	r3, r7, #7
 800ef5e:	4618      	mov	r0, r3
 800ef60:	f04f 0121 	mov.w	r1, #33	; 0x21
 800ef64:	f04f 0201 	mov.w	r2, #1
 800ef68:	f000 f84a 	bl	800f000 <LIS302DL_Read>
  
  /* Enable or Disable the reboot memory */
  tmpreg |= LIS302DL_BOOT_REBOOTMEMORY;
 800ef6c:	79fb      	ldrb	r3, [r7, #7]
 800ef6e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ef72:	b2db      	uxtb	r3, r3
 800ef74:	71fb      	strb	r3, [r7, #7]
  
  /* Write value to MEMS CTRL_REG2 regsister */
  LIS302DL_Write(&tmpreg, LIS302DL_CTRL_REG2_ADDR, 1);
 800ef76:	f107 0307 	add.w	r3, r7, #7
 800ef7a:	4618      	mov	r0, r3
 800ef7c:	f04f 0121 	mov.w	r1, #33	; 0x21
 800ef80:	f04f 0201 	mov.w	r2, #1
 800ef84:	f000 f804 	bl	800ef90 <LIS302DL_Write>
}
 800ef88:	f107 0708 	add.w	r7, r7, #8
 800ef8c:	46bd      	mov	sp, r7
 800ef8e:	bd80      	pop	{r7, pc}

0800ef90 <LIS302DL_Write>:
  * @param  WriteAddr : LIS302DL's internal address to write to.
  * @param  NumByteToWrite: Number of bytes to write.
  * @retval None
  */
void LIS302DL_Write(uint8_t* pBuffer, uint8_t WriteAddr, uint16_t NumByteToWrite)
{
 800ef90:	b580      	push	{r7, lr}
 800ef92:	b082      	sub	sp, #8
 800ef94:	af00      	add	r7, sp, #0
 800ef96:	6078      	str	r0, [r7, #4]
 800ef98:	4613      	mov	r3, r2
 800ef9a:	460a      	mov	r2, r1
 800ef9c:	70fa      	strb	r2, [r7, #3]
 800ef9e:	803b      	strh	r3, [r7, #0]
  /* Configure the MS bit: 
       - When 0, the address will remain unchanged in multiple read/write commands.
       - When 1, the address will be auto incremented in multiple read/write commands.
  */
  if(NumByteToWrite > 0x01)
 800efa0:	883b      	ldrh	r3, [r7, #0]
 800efa2:	2b01      	cmp	r3, #1
 800efa4:	d903      	bls.n	800efae <LIS302DL_Write+0x1e>
  {
    WriteAddr |= (uint8_t)MULTIPLEBYTE_CMD;
 800efa6:	78fb      	ldrb	r3, [r7, #3]
 800efa8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800efac:	70fb      	strb	r3, [r7, #3]
  }
  /* Set chip select Low at the start of the transmission */
  LIS302DL_CS_LOW();
 800efae:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800efb2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800efb6:	f04f 0108 	mov.w	r1, #8
 800efba:	f7f8 fbd1 	bl	8007760 <GPIO_ResetBits>
  
  /* Send the Address of the indexed register */
  LIS302DL_SendByte(WriteAddr);
 800efbe:	78fb      	ldrb	r3, [r7, #3]
 800efc0:	4618      	mov	r0, r3
 800efc2:	f000 f9af 	bl	800f324 <LIS302DL_SendByte>
  /* Send the data that will be written into the device (MSB First) */
  while(NumByteToWrite >= 0x01)
 800efc6:	e00c      	b.n	800efe2 <LIS302DL_Write+0x52>
  {
    LIS302DL_SendByte(*pBuffer);
 800efc8:	687b      	ldr	r3, [r7, #4]
 800efca:	781b      	ldrb	r3, [r3, #0]
 800efcc:	4618      	mov	r0, r3
 800efce:	f000 f9a9 	bl	800f324 <LIS302DL_SendByte>
    NumByteToWrite--;
 800efd2:	883b      	ldrh	r3, [r7, #0]
 800efd4:	f103 33ff 	add.w	r3, r3, #4294967295
 800efd8:	803b      	strh	r3, [r7, #0]
    pBuffer++;
 800efda:	687b      	ldr	r3, [r7, #4]
 800efdc:	f103 0301 	add.w	r3, r3, #1
 800efe0:	607b      	str	r3, [r7, #4]
  LIS302DL_CS_LOW();
  
  /* Send the Address of the indexed register */
  LIS302DL_SendByte(WriteAddr);
  /* Send the data that will be written into the device (MSB First) */
  while(NumByteToWrite >= 0x01)
 800efe2:	883b      	ldrh	r3, [r7, #0]
 800efe4:	2b00      	cmp	r3, #0
 800efe6:	d1ef      	bne.n	800efc8 <LIS302DL_Write+0x38>
    NumByteToWrite--;
    pBuffer++;
  }
  
  /* Set chip select High at the end of the transmission */ 
  LIS302DL_CS_HIGH();
 800efe8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800efec:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800eff0:	f04f 0108 	mov.w	r1, #8
 800eff4:	f7f8 fba6 	bl	8007744 <GPIO_SetBits>
}
 800eff8:	f107 0708 	add.w	r7, r7, #8
 800effc:	46bd      	mov	sp, r7
 800effe:	bd80      	pop	{r7, pc}

0800f000 <LIS302DL_Read>:
  * @param  ReadAddr : LIS302DL's internal address to read from.
  * @param  NumByteToRead : number of bytes to read from the LIS302DL.
  * @retval None
  */
void LIS302DL_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{  
 800f000:	b580      	push	{r7, lr}
 800f002:	b082      	sub	sp, #8
 800f004:	af00      	add	r7, sp, #0
 800f006:	6078      	str	r0, [r7, #4]
 800f008:	4613      	mov	r3, r2
 800f00a:	460a      	mov	r2, r1
 800f00c:	70fa      	strb	r2, [r7, #3]
 800f00e:	803b      	strh	r3, [r7, #0]
  if(NumByteToRead > 0x01)
 800f010:	883b      	ldrh	r3, [r7, #0]
 800f012:	2b01      	cmp	r3, #1
 800f014:	d904      	bls.n	800f020 <LIS302DL_Read+0x20>
  {
    ReadAddr |= (uint8_t)(READWRITE_CMD | MULTIPLEBYTE_CMD);
 800f016:	78fb      	ldrb	r3, [r7, #3]
 800f018:	f063 033f 	orn	r3, r3, #63	; 0x3f
 800f01c:	70fb      	strb	r3, [r7, #3]
 800f01e:	e003      	b.n	800f028 <LIS302DL_Read+0x28>
  }
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
 800f020:	78fb      	ldrb	r3, [r7, #3]
 800f022:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800f026:	70fb      	strb	r3, [r7, #3]
  }
  /* Set chip select Low at the start of the transmission */
  LIS302DL_CS_LOW();
 800f028:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800f02c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f030:	f04f 0108 	mov.w	r1, #8
 800f034:	f7f8 fb94 	bl	8007760 <GPIO_ResetBits>
  
  /* Send the Address of the indexed register */
  LIS302DL_SendByte(ReadAddr);
 800f038:	78fb      	ldrb	r3, [r7, #3]
 800f03a:	4618      	mov	r0, r3
 800f03c:	f000 f972 	bl	800f324 <LIS302DL_SendByte>
  
  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
 800f040:	e00f      	b.n	800f062 <LIS302DL_Read+0x62>
  {
    /* Send dummy byte (0x00) to generate the SPI clock to LIS302DL (Slave device) */
    *pBuffer = LIS302DL_SendByte(DUMMY_BYTE);
 800f042:	f04f 0000 	mov.w	r0, #0
 800f046:	f000 f96d 	bl	800f324 <LIS302DL_SendByte>
 800f04a:	4603      	mov	r3, r0
 800f04c:	461a      	mov	r2, r3
 800f04e:	687b      	ldr	r3, [r7, #4]
 800f050:	701a      	strb	r2, [r3, #0]
    NumByteToRead--;
 800f052:	883b      	ldrh	r3, [r7, #0]
 800f054:	f103 33ff 	add.w	r3, r3, #4294967295
 800f058:	803b      	strh	r3, [r7, #0]
    pBuffer++;
 800f05a:	687b      	ldr	r3, [r7, #4]
 800f05c:	f103 0301 	add.w	r3, r3, #1
 800f060:	607b      	str	r3, [r7, #4]
  
  /* Send the Address of the indexed register */
  LIS302DL_SendByte(ReadAddr);
  
  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
 800f062:	883b      	ldrh	r3, [r7, #0]
 800f064:	2b00      	cmp	r3, #0
 800f066:	d1ec      	bne.n	800f042 <LIS302DL_Read+0x42>
    NumByteToRead--;
    pBuffer++;
  }
  
  /* Set chip select High at the end of the transmission */ 
  LIS302DL_CS_HIGH();
 800f068:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800f06c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f070:	f04f 0108 	mov.w	r1, #8
 800f074:	f7f8 fb66 	bl	8007744 <GPIO_SetBits>
}
 800f078:	f107 0708 	add.w	r7, r7, #8
 800f07c:	46bd      	mov	sp, r7
 800f07e:	bd80      	pop	{r7, pc}

0800f080 <LIS302DL_ReadACC>:
  *         ACC[mg]=SENSITIVITY* (out_h*256+out_l)/16 (12 bit rappresentation)
  * @param  s16 buffer to store data
  * @retval None
  */
void LIS302DL_ReadACC(int32_t* out)
{
 800f080:	b580      	push	{r7, lr}
 800f082:	b086      	sub	sp, #24
 800f084:	af00      	add	r7, sp, #0
 800f086:	6078      	str	r0, [r7, #4]
  uint8_t buffer[6];
  uint8_t crtl, i = 0x00;
 800f088:	f04f 0300 	mov.w	r3, #0
 800f08c:	75fb      	strb	r3, [r7, #23]
   
  LIS302DL_Read(&crtl, LIS302DL_CTRL_REG1_ADDR, 1);  
 800f08e:	f107 030f 	add.w	r3, r7, #15
 800f092:	4618      	mov	r0, r3
 800f094:	f04f 0120 	mov.w	r1, #32
 800f098:	f04f 0201 	mov.w	r2, #1
 800f09c:	f7ff ffb0 	bl	800f000 <LIS302DL_Read>
  LIS302DL_Read(buffer, LIS302DL_OUT_X_ADDR, 6);
 800f0a0:	f107 0310 	add.w	r3, r7, #16
 800f0a4:	4618      	mov	r0, r3
 800f0a6:	f04f 0129 	mov.w	r1, #41	; 0x29
 800f0aa:	f04f 0206 	mov.w	r2, #6
 800f0ae:	f7ff ffa7 	bl	800f000 <LIS302DL_Read>
  
  switch(crtl & 0x20) 
 800f0b2:	7bfb      	ldrb	r3, [r7, #15]
 800f0b4:	f003 0320 	and.w	r3, r3, #32
 800f0b8:	2b00      	cmp	r3, #0
 800f0ba:	d002      	beq.n	800f0c2 <LIS302DL_ReadACC+0x42>
 800f0bc:	2b20      	cmp	r3, #32
 800f0be:	d023      	beq.n	800f108 <LIS302DL_ReadACC+0x88>
 800f0c0:	e045      	b.n	800f14e <LIS302DL_ReadACC+0xce>
    {
    /* FS bit = 0 ==> Sensitivity typical value = 18milligals/digit*/ 
    case 0x00:
      for(i=0; i<0x03; i++)
 800f0c2:	f04f 0300 	mov.w	r3, #0
 800f0c6:	75fb      	strb	r3, [r7, #23]
 800f0c8:	e01a      	b.n	800f100 <LIS302DL_ReadACC+0x80>
      {
        *out =(int32_t)(LIS302DL_SENSITIVITY_2_3G *  (int8_t)buffer[2*i]);
 800f0ca:	7dfb      	ldrb	r3, [r7, #23]
 800f0cc:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800f0d0:	f107 0218 	add.w	r2, r7, #24
 800f0d4:	18d3      	adds	r3, r2, r3
 800f0d6:	f813 3c08 	ldrb.w	r3, [r3, #-8]
 800f0da:	b2db      	uxtb	r3, r3
 800f0dc:	b25a      	sxtb	r2, r3
 800f0de:	4613      	mov	r3, r2
 800f0e0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800f0e4:	189b      	adds	r3, r3, r2
 800f0e6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800f0ea:	461a      	mov	r2, r3
 800f0ec:	687b      	ldr	r3, [r7, #4]
 800f0ee:	601a      	str	r2, [r3, #0]
        out++;
 800f0f0:	687b      	ldr	r3, [r7, #4]
 800f0f2:	f103 0304 	add.w	r3, r3, #4
 800f0f6:	607b      	str	r3, [r7, #4]
  
  switch(crtl & 0x20) 
    {
    /* FS bit = 0 ==> Sensitivity typical value = 18milligals/digit*/ 
    case 0x00:
      for(i=0; i<0x03; i++)
 800f0f8:	7dfb      	ldrb	r3, [r7, #23]
 800f0fa:	f103 0301 	add.w	r3, r3, #1
 800f0fe:	75fb      	strb	r3, [r7, #23]
 800f100:	7dfb      	ldrb	r3, [r7, #23]
 800f102:	2b02      	cmp	r3, #2
 800f104:	d9e1      	bls.n	800f0ca <LIS302DL_ReadACC+0x4a>
      {
        *out =(int32_t)(LIS302DL_SENSITIVITY_2_3G *  (int8_t)buffer[2*i]);
        out++;
      }
      break;
 800f106:	e023      	b.n	800f150 <LIS302DL_ReadACC+0xd0>
    /* FS bit = 1 ==> Sensitivity typical value = 72milligals/digit*/ 
    case 0x20:
      for(i=0; i<0x03; i++)
 800f108:	f04f 0300 	mov.w	r3, #0
 800f10c:	75fb      	strb	r3, [r7, #23]
 800f10e:	e01a      	b.n	800f146 <LIS302DL_ReadACC+0xc6>
      {
        *out =(int32_t)(LIS302DL_SENSITIVITY_9_2G * (int8_t)buffer[2*i]);
 800f110:	7dfb      	ldrb	r3, [r7, #23]
 800f112:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800f116:	f107 0218 	add.w	r2, r7, #24
 800f11a:	18d3      	adds	r3, r2, r3
 800f11c:	f813 3c08 	ldrb.w	r3, [r3, #-8]
 800f120:	b2db      	uxtb	r3, r3
 800f122:	b25a      	sxtb	r2, r3
 800f124:	4613      	mov	r3, r2
 800f126:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800f12a:	189b      	adds	r3, r3, r2
 800f12c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800f130:	461a      	mov	r2, r3
 800f132:	687b      	ldr	r3, [r7, #4]
 800f134:	601a      	str	r2, [r3, #0]
        out++;
 800f136:	687b      	ldr	r3, [r7, #4]
 800f138:	f103 0304 	add.w	r3, r3, #4
 800f13c:	607b      	str	r3, [r7, #4]
        out++;
      }
      break;
    /* FS bit = 1 ==> Sensitivity typical value = 72milligals/digit*/ 
    case 0x20:
      for(i=0; i<0x03; i++)
 800f13e:	7dfb      	ldrb	r3, [r7, #23]
 800f140:	f103 0301 	add.w	r3, r3, #1
 800f144:	75fb      	strb	r3, [r7, #23]
 800f146:	7dfb      	ldrb	r3, [r7, #23]
 800f148:	2b02      	cmp	r3, #2
 800f14a:	d9e1      	bls.n	800f110 <LIS302DL_ReadACC+0x90>
      {
        *out =(int32_t)(LIS302DL_SENSITIVITY_9_2G * (int8_t)buffer[2*i]);
        out++;
      }         
      break;
 800f14c:	e000      	b.n	800f150 <LIS302DL_ReadACC+0xd0>
    default:
      break;
 800f14e:	bf00      	nop
    }
 }
 800f150:	f107 0718 	add.w	r7, r7, #24
 800f154:	46bd      	mov	sp, r7
 800f156:	bd80      	pop	{r7, pc}

0800f158 <LIS302DL_LowLevel_Init>:
  * @brief  Initializes the low level interface used to drive the LIS302DL
  * @param  None
  * @retval None
  */
static void LIS302DL_LowLevel_Init(void)
{
 800f158:	b580      	push	{r7, lr}
 800f15a:	b088      	sub	sp, #32
 800f15c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStructure;
  SPI_InitTypeDef  SPI_InitStructure;

  /* Enable the SPI periph */
  RCC_APB2PeriphClockCmd(LIS302DL_SPI_CLK, ENABLE);
 800f15e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800f162:	f04f 0101 	mov.w	r1, #1
 800f166:	f7f9 fe31 	bl	8008dcc <RCC_APB2PeriphClockCmd>

  /* Enable SCK, MOSI and MISO GPIO clocks */
  RCC_AHB1PeriphClockCmd(LIS302DL_SPI_SCK_GPIO_CLK | LIS302DL_SPI_MISO_GPIO_CLK | LIS302DL_SPI_MOSI_GPIO_CLK, ENABLE);
 800f16a:	f04f 0001 	mov.w	r0, #1
 800f16e:	f04f 0101 	mov.w	r1, #1
 800f172:	f7f9 fd7b 	bl	8008c6c <RCC_AHB1PeriphClockCmd>

  /* Enable CS  GPIO clock */
  RCC_AHB1PeriphClockCmd(LIS302DL_SPI_CS_GPIO_CLK, ENABLE);
 800f176:	f04f 0010 	mov.w	r0, #16
 800f17a:	f04f 0101 	mov.w	r1, #1
 800f17e:	f7f9 fd75 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
  
  /* Enable INT1 GPIO clock */
  RCC_AHB1PeriphClockCmd(LIS302DL_SPI_INT1_GPIO_CLK, ENABLE);
 800f182:	f04f 0010 	mov.w	r0, #16
 800f186:	f04f 0101 	mov.w	r1, #1
 800f18a:	f7f9 fd6f 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
  
  /* Enable INT2 GPIO clock */
  RCC_AHB1PeriphClockCmd(LIS302DL_SPI_INT2_GPIO_CLK, ENABLE);
 800f18e:	f04f 0010 	mov.w	r0, #16
 800f192:	f04f 0101 	mov.w	r1, #1
 800f196:	f7f9 fd69 	bl	8008c6c <RCC_AHB1PeriphClockCmd>

  GPIO_PinAFConfig(LIS302DL_SPI_SCK_GPIO_PORT, LIS302DL_SPI_SCK_SOURCE, LIS302DL_SPI_SCK_AF);
 800f19a:	f04f 0000 	mov.w	r0, #0
 800f19e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f1a2:	f04f 0105 	mov.w	r1, #5
 800f1a6:	f04f 0205 	mov.w	r2, #5
 800f1aa:	f7f8 fb1f 	bl	80077ec <GPIO_PinAFConfig>
  GPIO_PinAFConfig(LIS302DL_SPI_MISO_GPIO_PORT, LIS302DL_SPI_MISO_SOURCE, LIS302DL_SPI_MISO_AF);
 800f1ae:	f04f 0000 	mov.w	r0, #0
 800f1b2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f1b6:	f04f 0106 	mov.w	r1, #6
 800f1ba:	f04f 0205 	mov.w	r2, #5
 800f1be:	f7f8 fb15 	bl	80077ec <GPIO_PinAFConfig>
  GPIO_PinAFConfig(LIS302DL_SPI_MOSI_GPIO_PORT, LIS302DL_SPI_MOSI_SOURCE, LIS302DL_SPI_MOSI_AF);
 800f1c2:	f04f 0000 	mov.w	r0, #0
 800f1c6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f1ca:	f04f 0107 	mov.w	r1, #7
 800f1ce:	f04f 0205 	mov.w	r2, #5
 800f1d2:	f7f8 fb0b 	bl	80077ec <GPIO_PinAFConfig>

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800f1d6:	f04f 0302 	mov.w	r3, #2
 800f1da:	773b      	strb	r3, [r7, #28]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800f1dc:	f04f 0300 	mov.w	r3, #0
 800f1e0:	77bb      	strb	r3, [r7, #30]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
 800f1e2:	f04f 0302 	mov.w	r3, #2
 800f1e6:	77fb      	strb	r3, [r7, #31]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800f1e8:	f04f 0302 	mov.w	r3, #2
 800f1ec:	777b      	strb	r3, [r7, #29]

  /* SPI SCK pin configuration */
  GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_SCK_PIN;
 800f1ee:	f04f 0320 	mov.w	r3, #32
 800f1f2:	61bb      	str	r3, [r7, #24]
  GPIO_Init(LIS302DL_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
 800f1f4:	f107 0318 	add.w	r3, r7, #24
 800f1f8:	f04f 0000 	mov.w	r0, #0
 800f1fc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f200:	4619      	mov	r1, r3
 800f202:	f7f8 f95d 	bl	80074c0 <GPIO_Init>

  /* SPI  MOSI pin configuration */
  GPIO_InitStructure.GPIO_Pin =  LIS302DL_SPI_MOSI_PIN;
 800f206:	f04f 0380 	mov.w	r3, #128	; 0x80
 800f20a:	61bb      	str	r3, [r7, #24]
  GPIO_Init(LIS302DL_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
 800f20c:	f107 0318 	add.w	r3, r7, #24
 800f210:	f04f 0000 	mov.w	r0, #0
 800f214:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f218:	4619      	mov	r1, r3
 800f21a:	f7f8 f951 	bl	80074c0 <GPIO_Init>

  /* SPI MISO pin configuration */
  GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_MISO_PIN;
 800f21e:	f04f 0340 	mov.w	r3, #64	; 0x40
 800f222:	61bb      	str	r3, [r7, #24]
  GPIO_Init(LIS302DL_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
 800f224:	f107 0318 	add.w	r3, r7, #24
 800f228:	f04f 0000 	mov.w	r0, #0
 800f22c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f230:	4619      	mov	r1, r3
 800f232:	f7f8 f945 	bl	80074c0 <GPIO_Init>

  /* SPI configuration -------------------------------------------------------*/
  SPI_I2S_DeInit(LIS302DL_SPI);
 800f236:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 800f23a:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f23e:	f7fb fe6f 	bl	800af20 <SPI_I2S_DeInit>
  SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 800f242:	f04f 0300 	mov.w	r3, #0
 800f246:	80bb      	strh	r3, [r7, #4]
  SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 800f248:	f04f 0300 	mov.w	r3, #0
 800f24c:	813b      	strh	r3, [r7, #8]
  SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 800f24e:	f04f 0300 	mov.w	r3, #0
 800f252:	817b      	strh	r3, [r7, #10]
  SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 800f254:	f04f 0300 	mov.w	r3, #0
 800f258:	81bb      	strh	r3, [r7, #12]
  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 800f25a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800f25e:	81fb      	strh	r3, [r7, #14]
  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
 800f260:	f04f 0308 	mov.w	r3, #8
 800f264:	823b      	strh	r3, [r7, #16]
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 800f266:	f04f 0300 	mov.w	r3, #0
 800f26a:	827b      	strh	r3, [r7, #18]
  SPI_InitStructure.SPI_CRCPolynomial = 7;
 800f26c:	f04f 0307 	mov.w	r3, #7
 800f270:	82bb      	strh	r3, [r7, #20]
  SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 800f272:	f44f 7382 	mov.w	r3, #260	; 0x104
 800f276:	80fb      	strh	r3, [r7, #6]
  SPI_Init(LIS302DL_SPI, &SPI_InitStructure);
 800f278:	f107 0304 	add.w	r3, r7, #4
 800f27c:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 800f280:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f284:	4619      	mov	r1, r3
 800f286:	f7fb fe8f 	bl	800afa8 <SPI_Init>

  /* Enable SPI1  */
  SPI_Cmd(LIS302DL_SPI, ENABLE);
 800f28a:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 800f28e:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f292:	f04f 0101 	mov.w	r1, #1
 800f296:	f7fc f835 	bl	800b304 <SPI_Cmd>

  /* Configure GPIO PIN for Lis Chip select */
  GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_CS_PIN;
 800f29a:	f04f 0308 	mov.w	r3, #8
 800f29e:	61bb      	str	r3, [r7, #24]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800f2a0:	f04f 0301 	mov.w	r3, #1
 800f2a4:	773b      	strb	r3, [r7, #28]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800f2a6:	f04f 0300 	mov.w	r3, #0
 800f2aa:	77bb      	strb	r3, [r7, #30]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800f2ac:	f04f 0302 	mov.w	r3, #2
 800f2b0:	777b      	strb	r3, [r7, #29]
  GPIO_Init(LIS302DL_SPI_CS_GPIO_PORT, &GPIO_InitStructure);
 800f2b2:	f107 0318 	add.w	r3, r7, #24
 800f2b6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800f2ba:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f2be:	4619      	mov	r1, r3
 800f2c0:	f7f8 f8fe 	bl	80074c0 <GPIO_Init>

  /* Deselect : Chip Select high */
  GPIO_SetBits(LIS302DL_SPI_CS_GPIO_PORT, LIS302DL_SPI_CS_PIN);
 800f2c4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800f2c8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f2cc:	f04f 0108 	mov.w	r1, #8
 800f2d0:	f7f8 fa38 	bl	8007744 <GPIO_SetBits>
  
  /* Configure GPIO PINs to detect Interrupts */
  GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_INT1_PIN;
 800f2d4:	f04f 0301 	mov.w	r3, #1
 800f2d8:	61bb      	str	r3, [r7, #24]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800f2da:	f04f 0300 	mov.w	r3, #0
 800f2de:	773b      	strb	r3, [r7, #28]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800f2e0:	f04f 0300 	mov.w	r3, #0
 800f2e4:	77bb      	strb	r3, [r7, #30]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800f2e6:	f04f 0302 	mov.w	r3, #2
 800f2ea:	777b      	strb	r3, [r7, #29]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 800f2ec:	f04f 0300 	mov.w	r3, #0
 800f2f0:	77fb      	strb	r3, [r7, #31]
  GPIO_Init(LIS302DL_SPI_INT1_GPIO_PORT, &GPIO_InitStructure);
 800f2f2:	f107 0318 	add.w	r3, r7, #24
 800f2f6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800f2fa:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f2fe:	4619      	mov	r1, r3
 800f300:	f7f8 f8de 	bl	80074c0 <GPIO_Init>
  
  GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_INT2_PIN;
 800f304:	f04f 0302 	mov.w	r3, #2
 800f308:	61bb      	str	r3, [r7, #24]
  GPIO_Init(LIS302DL_SPI_INT2_GPIO_PORT, &GPIO_InitStructure);
 800f30a:	f107 0318 	add.w	r3, r7, #24
 800f30e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800f312:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800f316:	4619      	mov	r1, r3
 800f318:	f7f8 f8d2 	bl	80074c0 <GPIO_Init>
}
 800f31c:	f107 0720 	add.w	r7, r7, #32
 800f320:	46bd      	mov	sp, r7
 800f322:	bd80      	pop	{r7, pc}

0800f324 <LIS302DL_SendByte>:
  *         from the SPI bus.
  * @param  Byte : Byte send.
  * @retval The received byte value
  */
static uint8_t LIS302DL_SendByte(uint8_t byte)
{
 800f324:	b580      	push	{r7, lr}
 800f326:	b082      	sub	sp, #8
 800f328:	af00      	add	r7, sp, #0
 800f32a:	4603      	mov	r3, r0
 800f32c:	71fb      	strb	r3, [r7, #7]
  /* Loop while DR register in not emplty */
  LIS302DLTimeout = LIS302DL_FLAG_TIMEOUT;
 800f32e:	f240 037c 	movw	r3, #124	; 0x7c
 800f332:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f336:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800f33a:	601a      	str	r2, [r3, #0]
  while (SPI_I2S_GetFlagStatus(LIS302DL_SPI, SPI_I2S_FLAG_TXE) == RESET)
 800f33c:	e017      	b.n	800f36e <LIS302DL_SendByte+0x4a>
  {
    if((LIS302DLTimeout--) == 0) return LIS302DL_TIMEOUT_UserCallback();
 800f33e:	f240 037c 	movw	r3, #124	; 0x7c
 800f342:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f346:	681b      	ldr	r3, [r3, #0]
 800f348:	2b00      	cmp	r3, #0
 800f34a:	bf14      	ite	ne
 800f34c:	2200      	movne	r2, #0
 800f34e:	2201      	moveq	r2, #1
 800f350:	b2d2      	uxtb	r2, r2
 800f352:	f103 31ff 	add.w	r1, r3, #4294967295
 800f356:	f240 037c 	movw	r3, #124	; 0x7c
 800f35a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f35e:	6019      	str	r1, [r3, #0]
 800f360:	2a00      	cmp	r2, #0
 800f362:	d004      	beq.n	800f36e <LIS302DL_SendByte+0x4a>
 800f364:	f000 f850 	bl	800f408 <LIS302DL_TIMEOUT_UserCallback>
 800f368:	4603      	mov	r3, r0
 800f36a:	b2db      	uxtb	r3, r3
 800f36c:	e046      	b.n	800f3fc <LIS302DL_SendByte+0xd8>
  */
static uint8_t LIS302DL_SendByte(uint8_t byte)
{
  /* Loop while DR register in not emplty */
  LIS302DLTimeout = LIS302DL_FLAG_TIMEOUT;
  while (SPI_I2S_GetFlagStatus(LIS302DL_SPI, SPI_I2S_FLAG_TXE) == RESET)
 800f36e:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 800f372:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f376:	f04f 0102 	mov.w	r1, #2
 800f37a:	f7fc f9c3 	bl	800b704 <SPI_I2S_GetFlagStatus>
 800f37e:	4603      	mov	r3, r0
 800f380:	2b00      	cmp	r3, #0
 800f382:	d0dc      	beq.n	800f33e <LIS302DL_SendByte+0x1a>
  {
    if((LIS302DLTimeout--) == 0) return LIS302DL_TIMEOUT_UserCallback();
  }
  
  /* Send a Byte through the SPI peripheral */
  SPI_I2S_SendData(LIS302DL_SPI, byte);
 800f384:	79fb      	ldrb	r3, [r7, #7]
 800f386:	b29b      	uxth	r3, r3
 800f388:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 800f38c:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f390:	4619      	mov	r1, r3
 800f392:	f7fc f8f5 	bl	800b580 <SPI_I2S_SendData>
  
  /* Wait to receive a Byte */
  LIS302DLTimeout = LIS302DL_FLAG_TIMEOUT;
 800f396:	f240 037c 	movw	r3, #124	; 0x7c
 800f39a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f39e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800f3a2:	601a      	str	r2, [r3, #0]
  while (SPI_I2S_GetFlagStatus(LIS302DL_SPI, SPI_I2S_FLAG_RXNE) == RESET)
 800f3a4:	e017      	b.n	800f3d6 <LIS302DL_SendByte+0xb2>
  {
    if((LIS302DLTimeout--) == 0) return LIS302DL_TIMEOUT_UserCallback();
 800f3a6:	f240 037c 	movw	r3, #124	; 0x7c
 800f3aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f3ae:	681b      	ldr	r3, [r3, #0]
 800f3b0:	2b00      	cmp	r3, #0
 800f3b2:	bf14      	ite	ne
 800f3b4:	2200      	movne	r2, #0
 800f3b6:	2201      	moveq	r2, #1
 800f3b8:	b2d2      	uxtb	r2, r2
 800f3ba:	f103 31ff 	add.w	r1, r3, #4294967295
 800f3be:	f240 037c 	movw	r3, #124	; 0x7c
 800f3c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f3c6:	6019      	str	r1, [r3, #0]
 800f3c8:	2a00      	cmp	r2, #0
 800f3ca:	d004      	beq.n	800f3d6 <LIS302DL_SendByte+0xb2>
 800f3cc:	f000 f81c 	bl	800f408 <LIS302DL_TIMEOUT_UserCallback>
 800f3d0:	4603      	mov	r3, r0
 800f3d2:	b2db      	uxtb	r3, r3
 800f3d4:	e012      	b.n	800f3fc <LIS302DL_SendByte+0xd8>
  /* Send a Byte through the SPI peripheral */
  SPI_I2S_SendData(LIS302DL_SPI, byte);
  
  /* Wait to receive a Byte */
  LIS302DLTimeout = LIS302DL_FLAG_TIMEOUT;
  while (SPI_I2S_GetFlagStatus(LIS302DL_SPI, SPI_I2S_FLAG_RXNE) == RESET)
 800f3d6:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 800f3da:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f3de:	f04f 0101 	mov.w	r1, #1
 800f3e2:	f7fc f98f 	bl	800b704 <SPI_I2S_GetFlagStatus>
 800f3e6:	4603      	mov	r3, r0
 800f3e8:	2b00      	cmp	r3, #0
 800f3ea:	d0dc      	beq.n	800f3a6 <LIS302DL_SendByte+0x82>
  {
    if((LIS302DLTimeout--) == 0) return LIS302DL_TIMEOUT_UserCallback();
  }
  
  /* Return the Byte read from the SPI bus */
  return (uint8_t)SPI_I2S_ReceiveData(LIS302DL_SPI);
 800f3ec:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 800f3f0:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f3f4:	f7fc f8b6 	bl	800b564 <SPI_I2S_ReceiveData>
 800f3f8:	4603      	mov	r3, r0
 800f3fa:	b2db      	uxtb	r3, r3
}
 800f3fc:	4618      	mov	r0, r3
 800f3fe:	f107 0708 	add.w	r7, r7, #8
 800f402:	46bd      	mov	sp, r7
 800f404:	bd80      	pop	{r7, pc}
 800f406:	bf00      	nop

0800f408 <LIS302DL_TIMEOUT_UserCallback>:
  * @brief  Basic management of the timeout situation.
  * @param  None.
  * @retval None.
  */
uint32_t LIS302DL_TIMEOUT_UserCallback(void)
{
 800f408:	b480      	push	{r7}
 800f40a:	af00      	add	r7, sp, #0
  /* Block communication and all processes */
  while (1)
  {   
  }
 800f40c:	e7fe      	b.n	800f40c <LIS302DL_TIMEOUT_UserCallback+0x4>
 800f40e:	bf00      	nop

0800f410 <_ZN6CMenueC1EP11CGraphicLCD>:
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/


CMenue::CMenue(CGraphicLCD *display) : glcd(display){
 800f410:	b580      	push	{r7, lr}
 800f412:	b082      	sub	sp, #8
 800f414:	af00      	add	r7, sp, #0
 800f416:	6078      	str	r0, [r7, #4]
 800f418:	6039      	str	r1, [r7, #0]
 800f41a:	687b      	ldr	r3, [r7, #4]
 800f41c:	4618      	mov	r0, r3
 800f41e:	f00a f915 	bl	801964c <_ZN12AManagedTaskC1Ev>
 800f422:	687b      	ldr	r3, [r7, #4]
 800f424:	4a05      	ldr	r2, [pc, #20]	; (800f43c <_ZN6CMenueC1EP11CGraphicLCD+0x2c>)
 800f426:	601a      	str	r2, [r3, #0]
 800f428:	687b      	ldr	r3, [r7, #4]
 800f42a:	683a      	ldr	r2, [r7, #0]
 800f42c:	60da      	str	r2, [r3, #12]
}
 800f42e:	687b      	ldr	r3, [r7, #4]
 800f430:	4618      	mov	r0, r3
 800f432:	f107 0708 	add.w	r7, r7, #8
 800f436:	46bd      	mov	sp, r7
 800f438:	bd80      	pop	{r7, pc}
 800f43a:	bf00      	nop
 800f43c:	0802bc38 	.word	0x0802bc38

0800f440 <_ZN6CMenueD1Ev>:

CMenue::~CMenue() {
 800f440:	b580      	push	{r7, lr}
 800f442:	b082      	sub	sp, #8
 800f444:	af00      	add	r7, sp, #0
 800f446:	6078      	str	r0, [r7, #4]
 800f448:	687b      	ldr	r3, [r7, #4]
 800f44a:	4a0a      	ldr	r2, [pc, #40]	; (800f474 <_ZN6CMenueD1Ev+0x34>)
 800f44c:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated destructor stub
}
 800f44e:	6878      	ldr	r0, [r7, #4]
 800f450:	f00a f918 	bl	8019684 <_ZN12AManagedTaskD1Ev>
 800f454:	f04f 0300 	mov.w	r3, #0
 800f458:	f003 0301 	and.w	r3, r3, #1
 800f45c:	b2db      	uxtb	r3, r3
 800f45e:	2b00      	cmp	r3, #0
 800f460:	d002      	beq.n	800f468 <_ZN6CMenueD1Ev+0x28>
 800f462:	6878      	ldr	r0, [r7, #4]
 800f464:	f012 feb6 	bl	80221d4 <_ZdlPv>
 800f468:	687b      	ldr	r3, [r7, #4]
 800f46a:	4618      	mov	r0, r3
 800f46c:	f107 0708 	add.w	r7, r7, #8
 800f470:	46bd      	mov	sp, r7
 800f472:	bd80      	pop	{r7, pc}
 800f474:	0802bc38 	.word	0x0802bc38

0800f478 <_ZN6CMenueD0Ev>:


CMenue::CMenue(CGraphicLCD *display) : glcd(display){
}

CMenue::~CMenue() {
 800f478:	b580      	push	{r7, lr}
 800f47a:	b082      	sub	sp, #8
 800f47c:	af00      	add	r7, sp, #0
 800f47e:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated destructor stub
}
 800f480:	6878      	ldr	r0, [r7, #4]
 800f482:	f7ff ffdd 	bl	800f440 <_ZN6CMenueD1Ev>
 800f486:	6878      	ldr	r0, [r7, #4]
 800f488:	f012 fea4 	bl	80221d4 <_ZdlPv>
 800f48c:	687b      	ldr	r3, [r7, #4]
 800f48e:	4618      	mov	r0, r3
 800f490:	f107 0708 	add.w	r7, r7, #8
 800f494:	46bd      	mov	sp, r7
 800f496:	bd80      	pop	{r7, pc}

0800f498 <_ZN6CMenue12HardwareInitEv>:
/**
  * @brief  HardwareInit called before Scheduler starts
  * @param  None
  * @retval true on success
  */
bool CMenue::HardwareInit(void){
 800f498:	b480      	push	{r7}
 800f49a:	b083      	sub	sp, #12
 800f49c:	af00      	add	r7, sp, #0
 800f49e:	6078      	str	r0, [r7, #4]

	return true;
 800f4a0:	f04f 0301 	mov.w	r3, #1
}
 800f4a4:	4618      	mov	r0, r3
 800f4a6:	f107 070c 	add.w	r7, r7, #12
 800f4aa:	46bd      	mov	sp, r7
 800f4ac:	bc80      	pop	{r7}
 800f4ae:	4770      	bx	lr

0800f4b0 <_ZN6CMenue3RunEv>:
/**
  * @brief  task function for Menu
  * @param  None
  * @retval None
  */
void CMenue::Run(void){
 800f4b0:	b590      	push	{r4, r7, lr}
 800f4b2:	b087      	sub	sp, #28
 800f4b4:	af02      	add	r7, sp, #8
 800f4b6:	6078      	str	r0, [r7, #4]
	char buffer[4];
	int x = 0;
 800f4b8:	f04f 0300 	mov.w	r3, #0
 800f4bc:	60fb      	str	r3, [r7, #12]

	glcd->Init();
 800f4be:	687b      	ldr	r3, [r7, #4]
 800f4c0:	68db      	ldr	r3, [r3, #12]
 800f4c2:	681b      	ldr	r3, [r3, #0]
 800f4c4:	f103 0320 	add.w	r3, r3, #32
 800f4c8:	681b      	ldr	r3, [r3, #0]
 800f4ca:	687a      	ldr	r2, [r7, #4]
 800f4cc:	68d2      	ldr	r2, [r2, #12]
 800f4ce:	4610      	mov	r0, r2
 800f4d0:	4798      	blx	r3
	glcd->Inverse(true);
 800f4d2:	687b      	ldr	r3, [r7, #4]
 800f4d4:	68db      	ldr	r3, [r3, #12]
 800f4d6:	4618      	mov	r0, r3
 800f4d8:	f04f 0101 	mov.w	r1, #1
 800f4dc:	f008 ff32 	bl	8018344 <_ZN11CGraphicLCD7InverseEb>
	glcd->Clear();
 800f4e0:	687b      	ldr	r3, [r7, #4]
 800f4e2:	68db      	ldr	r3, [r3, #12]
 800f4e4:	681b      	ldr	r3, [r3, #0]
 800f4e6:	681b      	ldr	r3, [r3, #0]
 800f4e8:	687a      	ldr	r2, [r7, #4]
 800f4ea:	68d2      	ldr	r2, [r2, #12]
 800f4ec:	4610      	mov	r0, r2
 800f4ee:	4798      	blx	r3


	vTaskDelay(500/portTICK_RATE_MS);
 800f4f0:	f04f 0032 	mov.w	r0, #50	; 0x32
 800f4f4:	f00b fa42 	bl	801a97c <vTaskDelay>
	glcd->WriteString("Introducing Project:",c_FontSansSerif12,5,5);
 800f4f8:	687b      	ldr	r3, [r7, #4]
 800f4fa:	68db      	ldr	r3, [r3, #12]
 800f4fc:	681b      	ldr	r3, [r3, #0]
 800f4fe:	f103 0318 	add.w	r3, r3, #24
 800f502:	681c      	ldr	r4, [r3, #0]
 800f504:	687b      	ldr	r3, [r7, #4]
 800f506:	68db      	ldr	r3, [r3, #12]
 800f508:	f04f 0205 	mov.w	r2, #5
 800f50c:	9200      	str	r2, [sp, #0]
 800f50e:	4618      	mov	r0, r3
 800f510:	f64b 2170 	movw	r1, #47728	; 0xba70
 800f514:	f6c0 0102 	movt	r1, #2050	; 0x802
 800f518:	f24f 1230 	movw	r2, #61744	; 0xf130
 800f51c:	f6c0 0202 	movt	r2, #2050	; 0x802
 800f520:	f04f 0305 	mov.w	r3, #5
 800f524:	47a0      	blx	r4

	vTaskDelay(1000/portTICK_RATE_MS);
 800f526:	f04f 0064 	mov.w	r0, #100	; 0x64
 800f52a:	f00b fa27 	bl	801a97c <vTaskDelay>
	glcd->WriteString("ThunderCryer",c_FontSansSerif26,3,35);
 800f52e:	687b      	ldr	r3, [r7, #4]
 800f530:	68db      	ldr	r3, [r3, #12]
 800f532:	681b      	ldr	r3, [r3, #0]
 800f534:	f103 0318 	add.w	r3, r3, #24
 800f538:	681c      	ldr	r4, [r3, #0]
 800f53a:	687b      	ldr	r3, [r7, #4]
 800f53c:	68db      	ldr	r3, [r3, #12]
 800f53e:	f04f 0223 	mov.w	r2, #35	; 0x23
 800f542:	9200      	str	r2, [sp, #0]
 800f544:	4618      	mov	r0, r3
 800f546:	f64b 2188 	movw	r1, #47752	; 0xba88
 800f54a:	f6c0 0102 	movt	r1, #2050	; 0x802
 800f54e:	f64f 7254 	movw	r2, #65364	; 0xff54
 800f552:	f6c0 0202 	movt	r2, #2050	; 0x802
 800f556:	f04f 0303 	mov.w	r3, #3
 800f55a:	47a0      	blx	r4

	vTaskDelay(10000/portTICK_RATE_MS);
 800f55c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800f560:	f00b fa0c 	bl	801a97c <vTaskDelay>
	glcd->Clear();
 800f564:	687b      	ldr	r3, [r7, #4]
 800f566:	68db      	ldr	r3, [r3, #12]
 800f568:	681b      	ldr	r3, [r3, #0]
 800f56a:	681b      	ldr	r3, [r3, #0]
 800f56c:	687a      	ldr	r2, [r7, #4]
 800f56e:	68d2      	ldr	r2, [r2, #12]
 800f570:	4610      	mov	r0, r2
 800f572:	4798      	blx	r3
	glcd->Window(2,2,100,60);
 800f574:	687b      	ldr	r3, [r7, #4]
 800f576:	68db      	ldr	r3, [r3, #12]
 800f578:	681b      	ldr	r3, [r3, #0]
 800f57a:	f103 0308 	add.w	r3, r3, #8
 800f57e:	681c      	ldr	r4, [r3, #0]
 800f580:	687b      	ldr	r3, [r7, #4]
 800f582:	68db      	ldr	r3, [r3, #12]
 800f584:	f04f 023c 	mov.w	r2, #60	; 0x3c
 800f588:	9200      	str	r2, [sp, #0]
 800f58a:	4618      	mov	r0, r3
 800f58c:	f04f 0102 	mov.w	r1, #2
 800f590:	f04f 0202 	mov.w	r2, #2
 800f594:	f04f 0364 	mov.w	r3, #100	; 0x64
 800f598:	47a0      	blx	r4
	glcd->WriteString("21:14",c_FontSansSerif26,5,5);
 800f59a:	687b      	ldr	r3, [r7, #4]
 800f59c:	68db      	ldr	r3, [r3, #12]
 800f59e:	681b      	ldr	r3, [r3, #0]
 800f5a0:	f103 0318 	add.w	r3, r3, #24
 800f5a4:	681c      	ldr	r4, [r3, #0]
 800f5a6:	687b      	ldr	r3, [r7, #4]
 800f5a8:	68db      	ldr	r3, [r3, #12]
 800f5aa:	f04f 0205 	mov.w	r2, #5
 800f5ae:	9200      	str	r2, [sp, #0]
 800f5b0:	4618      	mov	r0, r3
 800f5b2:	f64b 2198 	movw	r1, #47768	; 0xba98
 800f5b6:	f6c0 0102 	movt	r1, #2050	; 0x802
 800f5ba:	f64f 7254 	movw	r2, #65364	; 0xff54
 800f5be:	f6c0 0202 	movt	r2, #2050	; 0x802
 800f5c2:	f04f 0305 	mov.w	r3, #5
 800f5c6:	47a0      	blx	r4
	glcd->WriteString("Fr. 24.02.12",c_FontNative,5,40);
 800f5c8:	687b      	ldr	r3, [r7, #4]
 800f5ca:	68db      	ldr	r3, [r3, #12]
 800f5cc:	681b      	ldr	r3, [r3, #0]
 800f5ce:	f103 0318 	add.w	r3, r3, #24
 800f5d2:	681c      	ldr	r4, [r3, #0]
 800f5d4:	687b      	ldr	r3, [r7, #4]
 800f5d6:	68db      	ldr	r3, [r3, #12]
 800f5d8:	f04f 0228 	mov.w	r2, #40	; 0x28
 800f5dc:	9200      	str	r2, [sp, #0]
 800f5de:	4618      	mov	r0, r3
 800f5e0:	f64b 21a0 	movw	r1, #47776	; 0xbaa0
 800f5e4:	f6c0 0102 	movt	r1, #2050	; 0x802
 800f5e8:	f64b 4258 	movw	r2, #48216	; 0xbc58
 800f5ec:	f6c0 0202 	movt	r2, #2050	; 0x802
 800f5f0:	f04f 0305 	mov.w	r3, #5
 800f5f4:	47a0      	blx	r4

	glcd->WriteString("Development in progress",c_FontNative,1,120);
 800f5f6:	687b      	ldr	r3, [r7, #4]
 800f5f8:	68db      	ldr	r3, [r3, #12]
 800f5fa:	681b      	ldr	r3, [r3, #0]
 800f5fc:	f103 0318 	add.w	r3, r3, #24
 800f600:	681c      	ldr	r4, [r3, #0]
 800f602:	687b      	ldr	r3, [r7, #4]
 800f604:	68db      	ldr	r3, [r3, #12]
 800f606:	f04f 0278 	mov.w	r2, #120	; 0x78
 800f60a:	9200      	str	r2, [sp, #0]
 800f60c:	4618      	mov	r0, r3
 800f60e:	f64b 21b0 	movw	r1, #47792	; 0xbab0
 800f612:	f6c0 0102 	movt	r1, #2050	; 0x802
 800f616:	f64b 4258 	movw	r2, #48216	; 0xbc58
 800f61a:	f6c0 0202 	movt	r2, #2050	; 0x802
 800f61e:	f04f 0301 	mov.w	r3, #1
 800f622:	47a0      	blx	r4

	while(1){
		if(x<60) {
 800f624:	68fb      	ldr	r3, [r7, #12]
 800f626:	2b3b      	cmp	r3, #59	; 0x3b
 800f628:	dc3b      	bgt.n	800f6a2 <_ZN6CMenue3RunEv+0x1f2>
			sprintf(buffer,"%02u",x);
 800f62a:	f107 0308 	add.w	r3, r7, #8
 800f62e:	4618      	mov	r0, r3
 800f630:	f64b 21c8 	movw	r1, #47816	; 0xbac8
 800f634:	f6c0 0102 	movt	r1, #2050	; 0x802
 800f638:	68fa      	ldr	r2, [r7, #12]
 800f63a:	f016 fc69 	bl	8025f10 <sprintf>
			glcd->SectorClear(75,7,20,20);
 800f63e:	687b      	ldr	r3, [r7, #4]
 800f640:	68db      	ldr	r3, [r3, #12]
 800f642:	681b      	ldr	r3, [r3, #0]
 800f644:	f103 0310 	add.w	r3, r3, #16
 800f648:	681c      	ldr	r4, [r3, #0]
 800f64a:	687b      	ldr	r3, [r7, #4]
 800f64c:	68db      	ldr	r3, [r3, #12]
 800f64e:	f04f 0214 	mov.w	r2, #20
 800f652:	9200      	str	r2, [sp, #0]
 800f654:	4618      	mov	r0, r3
 800f656:	f04f 014b 	mov.w	r1, #75	; 0x4b
 800f65a:	f04f 0207 	mov.w	r2, #7
 800f65e:	f04f 0314 	mov.w	r3, #20
 800f662:	47a0      	blx	r4
			glcd->WriteString(buffer,c_FontSansSerif12,75,7);
 800f664:	687b      	ldr	r3, [r7, #4]
 800f666:	68db      	ldr	r3, [r3, #12]
 800f668:	681b      	ldr	r3, [r3, #0]
 800f66a:	f103 0318 	add.w	r3, r3, #24
 800f66e:	681c      	ldr	r4, [r3, #0]
 800f670:	687b      	ldr	r3, [r7, #4]
 800f672:	68da      	ldr	r2, [r3, #12]
 800f674:	f107 0308 	add.w	r3, r7, #8
 800f678:	f04f 0107 	mov.w	r1, #7
 800f67c:	9100      	str	r1, [sp, #0]
 800f67e:	4610      	mov	r0, r2
 800f680:	4619      	mov	r1, r3
 800f682:	f24f 1230 	movw	r2, #61744	; 0xf130
 800f686:	f6c0 0202 	movt	r2, #2050	; 0x802
 800f68a:	f04f 034b 	mov.w	r3, #75	; 0x4b
 800f68e:	47a0      	blx	r4
			x++;
 800f690:	68fb      	ldr	r3, [r7, #12]
 800f692:	f103 0301 	add.w	r3, r3, #1
 800f696:	60fb      	str	r3, [r7, #12]
			vTaskDelay(1000/portTICK_RATE_MS);
 800f698:	f04f 0064 	mov.w	r0, #100	; 0x64
 800f69c:	f00b f96e 	bl	801a97c <vTaskDelay>
	glcd->WriteString("21:14",c_FontSansSerif26,5,5);
	glcd->WriteString("Fr. 24.02.12",c_FontNative,5,40);

	glcd->WriteString("Development in progress",c_FontNative,1,120);

	while(1){
 800f6a0:	e7c0      	b.n	800f624 <_ZN6CMenue3RunEv+0x174>
			glcd->SectorClear(75,7,20,20);
			glcd->WriteString(buffer,c_FontSansSerif12,75,7);
			x++;
			vTaskDelay(1000/portTICK_RATE_MS);
		} else
			x = 0;
 800f6a2:	f04f 0300 	mov.w	r3, #0
 800f6a6:	60fb      	str	r3, [r7, #12]
	glcd->WriteString("21:14",c_FontSansSerif26,5,5);
	glcd->WriteString("Fr. 24.02.12",c_FontNative,5,40);

	glcd->WriteString("Development in progress",c_FontNative,1,120);

	while(1){
 800f6a8:	e7bc      	b.n	800f624 <_ZN6CMenue3RunEv+0x174>
 800f6aa:	bf00      	nop

0800f6ac <xmp3_SetBitstreamPointer>:
 * Outputs:     filled bitstream info struct
 *
 * Return:      none
 **************************************************************************************/
void SetBitstreamPointer(BitStreamInfo *bsi, int nBytes, unsigned char *buf)
{
 800f6ac:	b480      	push	{r7}
 800f6ae:	b085      	sub	sp, #20
 800f6b0:	af00      	add	r7, sp, #0
 800f6b2:	60f8      	str	r0, [r7, #12]
 800f6b4:	60b9      	str	r1, [r7, #8]
 800f6b6:	607a      	str	r2, [r7, #4]
	/* init bitstream */
	bsi->bytePtr = buf;
 800f6b8:	68fb      	ldr	r3, [r7, #12]
 800f6ba:	687a      	ldr	r2, [r7, #4]
 800f6bc:	601a      	str	r2, [r3, #0]
	bsi->iCache = 0;		/* 4-byte unsigned int */
 800f6be:	68fb      	ldr	r3, [r7, #12]
 800f6c0:	f04f 0200 	mov.w	r2, #0
 800f6c4:	605a      	str	r2, [r3, #4]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 800f6c6:	68fb      	ldr	r3, [r7, #12]
 800f6c8:	f04f 0200 	mov.w	r2, #0
 800f6cc:	609a      	str	r2, [r3, #8]
	bsi->nBytes = nBytes;
 800f6ce:	68fb      	ldr	r3, [r7, #12]
 800f6d0:	68ba      	ldr	r2, [r7, #8]
 800f6d2:	60da      	str	r2, [r3, #12]
}
 800f6d4:	f107 0714 	add.w	r7, r7, #20
 800f6d8:	46bd      	mov	sp, r7
 800f6da:	bc80      	pop	{r7}
 800f6dc:	4770      	bx	lr
 800f6de:	bf00      	nop

0800f6e0 <RefillBitstreamCache>:
 *
 * TODO:        optimize for ARM
 *              possibly add little/big-endian modes for doing 32-bit loads
 **************************************************************************************/
static __inline void RefillBitstreamCache(BitStreamInfo *bsi)
{
 800f6e0:	b480      	push	{r7}
 800f6e2:	b085      	sub	sp, #20
 800f6e4:	af00      	add	r7, sp, #0
 800f6e6:	6078      	str	r0, [r7, #4]
	int nBytes = bsi->nBytes;
 800f6e8:	687b      	ldr	r3, [r7, #4]
 800f6ea:	68db      	ldr	r3, [r3, #12]
 800f6ec:	60fb      	str	r3, [r7, #12]

	/* optimize for common case, independent of machine endian-ness */
	if (nBytes >= 4) {
 800f6ee:	68fb      	ldr	r3, [r7, #12]
 800f6f0:	2b03      	cmp	r3, #3
 800f6f2:	dd3e      	ble.n	800f772 <RefillBitstreamCache+0x92>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800f6f4:	687b      	ldr	r3, [r7, #4]
 800f6f6:	681b      	ldr	r3, [r3, #0]
 800f6f8:	781a      	ldrb	r2, [r3, #0]
 800f6fa:	ea4f 6202 	mov.w	r2, r2, lsl #24
 800f6fe:	4611      	mov	r1, r2
 800f700:	687a      	ldr	r2, [r7, #4]
 800f702:	6051      	str	r1, [r2, #4]
 800f704:	f103 0201 	add.w	r2, r3, #1
 800f708:	687b      	ldr	r3, [r7, #4]
 800f70a:	601a      	str	r2, [r3, #0]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800f70c:	687b      	ldr	r3, [r7, #4]
 800f70e:	6859      	ldr	r1, [r3, #4]
 800f710:	687b      	ldr	r3, [r7, #4]
 800f712:	681b      	ldr	r3, [r3, #0]
 800f714:	781a      	ldrb	r2, [r3, #0]
 800f716:	ea4f 4202 	mov.w	r2, r2, lsl #16
 800f71a:	4311      	orrs	r1, r2
 800f71c:	687a      	ldr	r2, [r7, #4]
 800f71e:	6051      	str	r1, [r2, #4]
 800f720:	f103 0201 	add.w	r2, r3, #1
 800f724:	687b      	ldr	r3, [r7, #4]
 800f726:	601a      	str	r2, [r3, #0]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800f728:	687b      	ldr	r3, [r7, #4]
 800f72a:	6859      	ldr	r1, [r3, #4]
 800f72c:	687b      	ldr	r3, [r7, #4]
 800f72e:	681b      	ldr	r3, [r3, #0]
 800f730:	781a      	ldrb	r2, [r3, #0]
 800f732:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800f736:	4311      	orrs	r1, r2
 800f738:	687a      	ldr	r2, [r7, #4]
 800f73a:	6051      	str	r1, [r2, #4]
 800f73c:	f103 0201 	add.w	r2, r3, #1
 800f740:	687b      	ldr	r3, [r7, #4]
 800f742:	601a      	str	r2, [r3, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 800f744:	687b      	ldr	r3, [r7, #4]
 800f746:	6859      	ldr	r1, [r3, #4]
 800f748:	687b      	ldr	r3, [r7, #4]
 800f74a:	681b      	ldr	r3, [r3, #0]
 800f74c:	781a      	ldrb	r2, [r3, #0]
 800f74e:	4311      	orrs	r1, r2
 800f750:	687a      	ldr	r2, [r7, #4]
 800f752:	6051      	str	r1, [r2, #4]
 800f754:	f103 0201 	add.w	r2, r3, #1
 800f758:	687b      	ldr	r3, [r7, #4]
 800f75a:	601a      	str	r2, [r3, #0]
		bsi->cachedBits = 32;
 800f75c:	687b      	ldr	r3, [r7, #4]
 800f75e:	f04f 0220 	mov.w	r2, #32
 800f762:	609a      	str	r2, [r3, #8]
		bsi->nBytes -= 4;
 800f764:	687b      	ldr	r3, [r7, #4]
 800f766:	68db      	ldr	r3, [r3, #12]
 800f768:	f1a3 0204 	sub.w	r2, r3, #4
 800f76c:	687b      	ldr	r3, [r7, #4]
 800f76e:	60da      	str	r2, [r3, #12]
 800f770:	e038      	b.n	800f7e4 <RefillBitstreamCache+0x104>
	} else {
		bsi->iCache = 0;
 800f772:	687b      	ldr	r3, [r7, #4]
 800f774:	f04f 0200 	mov.w	r2, #0
 800f778:	605a      	str	r2, [r3, #4]
		while (nBytes--) {
 800f77a:	e011      	b.n	800f7a0 <RefillBitstreamCache+0xc0>
			bsi->iCache |= (*bsi->bytePtr++);
 800f77c:	687b      	ldr	r3, [r7, #4]
 800f77e:	6859      	ldr	r1, [r3, #4]
 800f780:	687b      	ldr	r3, [r7, #4]
 800f782:	681b      	ldr	r3, [r3, #0]
 800f784:	781a      	ldrb	r2, [r3, #0]
 800f786:	4311      	orrs	r1, r2
 800f788:	687a      	ldr	r2, [r7, #4]
 800f78a:	6051      	str	r1, [r2, #4]
 800f78c:	f103 0201 	add.w	r2, r3, #1
 800f790:	687b      	ldr	r3, [r7, #4]
 800f792:	601a      	str	r2, [r3, #0]
			bsi->iCache <<= 8;
 800f794:	687b      	ldr	r3, [r7, #4]
 800f796:	685b      	ldr	r3, [r3, #4]
 800f798:	ea4f 2203 	mov.w	r2, r3, lsl #8
 800f79c:	687b      	ldr	r3, [r7, #4]
 800f79e:	605a      	str	r2, [r3, #4]
		bsi->iCache |= (*bsi->bytePtr++);
		bsi->cachedBits = 32;
		bsi->nBytes -= 4;
	} else {
		bsi->iCache = 0;
		while (nBytes--) {
 800f7a0:	68fb      	ldr	r3, [r7, #12]
 800f7a2:	2b00      	cmp	r3, #0
 800f7a4:	bf0c      	ite	eq
 800f7a6:	2300      	moveq	r3, #0
 800f7a8:	2301      	movne	r3, #1
 800f7aa:	b2db      	uxtb	r3, r3
 800f7ac:	68fa      	ldr	r2, [r7, #12]
 800f7ae:	f102 32ff 	add.w	r2, r2, #4294967295
 800f7b2:	60fa      	str	r2, [r7, #12]
 800f7b4:	2b00      	cmp	r3, #0
 800f7b6:	d1e1      	bne.n	800f77c <RefillBitstreamCache+0x9c>
			bsi->iCache |= (*bsi->bytePtr++);
			bsi->iCache <<= 8;
		}
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800f7b8:	687b      	ldr	r3, [r7, #4]
 800f7ba:	685a      	ldr	r2, [r3, #4]
 800f7bc:	687b      	ldr	r3, [r7, #4]
 800f7be:	68db      	ldr	r3, [r3, #12]
 800f7c0:	f1c3 0303 	rsb	r3, r3, #3
 800f7c4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800f7c8:	fa02 f203 	lsl.w	r2, r2, r3
 800f7cc:	687b      	ldr	r3, [r7, #4]
 800f7ce:	605a      	str	r2, [r3, #4]
		bsi->cachedBits = 8*bsi->nBytes;
 800f7d0:	687b      	ldr	r3, [r7, #4]
 800f7d2:	68db      	ldr	r3, [r3, #12]
 800f7d4:	ea4f 02c3 	mov.w	r2, r3, lsl #3
 800f7d8:	687b      	ldr	r3, [r7, #4]
 800f7da:	609a      	str	r2, [r3, #8]
		bsi->nBytes = 0;
 800f7dc:	687b      	ldr	r3, [r7, #4]
 800f7de:	f04f 0200 	mov.w	r2, #0
 800f7e2:	60da      	str	r2, [r3, #12]
	}
}
 800f7e4:	f107 0714 	add.w	r7, r7, #20
 800f7e8:	46bd      	mov	sp, r7
 800f7ea:	bc80      	pop	{r7}
 800f7ec:	4770      	bx	lr
 800f7ee:	bf00      	nop

0800f7f0 <xmp3_GetBits>:
 *              if nBits = 0, returns 0 (useful for scalefactor unpacking)
 *
 * TODO:        optimize for ARM
 **************************************************************************************/
unsigned int GetBits(BitStreamInfo *bsi, int nBits)
{
 800f7f0:	b580      	push	{r7, lr}
 800f7f2:	b084      	sub	sp, #16
 800f7f4:	af00      	add	r7, sp, #0
 800f7f6:	6078      	str	r0, [r7, #4]
 800f7f8:	6039      	str	r1, [r7, #0]
	unsigned int data, lowBits;

	nBits &= 0x1f;							/* nBits mod 32 to avoid unpredictable results like >> by negative amount */
 800f7fa:	683b      	ldr	r3, [r7, #0]
 800f7fc:	f003 031f 	and.w	r3, r3, #31
 800f800:	603b      	str	r3, [r7, #0]
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 800f802:	687b      	ldr	r3, [r7, #4]
 800f804:	685a      	ldr	r2, [r3, #4]
 800f806:	683b      	ldr	r3, [r7, #0]
 800f808:	f1c3 031f 	rsb	r3, r3, #31
 800f80c:	fa22 f303 	lsr.w	r3, r2, r3
 800f810:	60fb      	str	r3, [r7, #12]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800f812:	68fb      	ldr	r3, [r7, #12]
 800f814:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800f818:	60fb      	str	r3, [r7, #12]
	bsi->iCache <<= nBits;					/* left-justify cache */
 800f81a:	687b      	ldr	r3, [r7, #4]
 800f81c:	685a      	ldr	r2, [r3, #4]
 800f81e:	683b      	ldr	r3, [r7, #0]
 800f820:	fa02 f203 	lsl.w	r2, r2, r3
 800f824:	687b      	ldr	r3, [r7, #4]
 800f826:	605a      	str	r2, [r3, #4]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800f828:	687b      	ldr	r3, [r7, #4]
 800f82a:	689a      	ldr	r2, [r3, #8]
 800f82c:	683b      	ldr	r3, [r7, #0]
 800f82e:	1ad2      	subs	r2, r2, r3
 800f830:	687b      	ldr	r3, [r7, #4]
 800f832:	609a      	str	r2, [r3, #8]

	/* if we cross an int boundary, refill the cache */
	if (bsi->cachedBits < 0) {
 800f834:	687b      	ldr	r3, [r7, #4]
 800f836:	689b      	ldr	r3, [r3, #8]
 800f838:	2b00      	cmp	r3, #0
 800f83a:	da20      	bge.n	800f87e <xmp3_GetBits+0x8e>
		lowBits = -bsi->cachedBits;
 800f83c:	687b      	ldr	r3, [r7, #4]
 800f83e:	689b      	ldr	r3, [r3, #8]
 800f840:	f1c3 0300 	rsb	r3, r3, #0
 800f844:	60bb      	str	r3, [r7, #8]
		RefillBitstreamCache(bsi);
 800f846:	6878      	ldr	r0, [r7, #4]
 800f848:	f7ff ff4a 	bl	800f6e0 <RefillBitstreamCache>
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800f84c:	687b      	ldr	r3, [r7, #4]
 800f84e:	685a      	ldr	r2, [r3, #4]
 800f850:	68bb      	ldr	r3, [r7, #8]
 800f852:	f1c3 0320 	rsb	r3, r3, #32
 800f856:	fa22 f303 	lsr.w	r3, r2, r3
 800f85a:	68fa      	ldr	r2, [r7, #12]
 800f85c:	4313      	orrs	r3, r2
 800f85e:	60fb      	str	r3, [r7, #12]
	
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800f860:	687b      	ldr	r3, [r7, #4]
 800f862:	689b      	ldr	r3, [r3, #8]
 800f864:	461a      	mov	r2, r3
 800f866:	68bb      	ldr	r3, [r7, #8]
 800f868:	1ad3      	subs	r3, r2, r3
 800f86a:	461a      	mov	r2, r3
 800f86c:	687b      	ldr	r3, [r7, #4]
 800f86e:	609a      	str	r2, [r3, #8]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800f870:	687b      	ldr	r3, [r7, #4]
 800f872:	685a      	ldr	r2, [r3, #4]
 800f874:	68bb      	ldr	r3, [r7, #8]
 800f876:	fa02 f203 	lsl.w	r2, r2, r3
 800f87a:	687b      	ldr	r3, [r7, #4]
 800f87c:	605a      	str	r2, [r3, #4]
	}

	return data;
 800f87e:	68fb      	ldr	r3, [r7, #12]
}
 800f880:	4618      	mov	r0, r3
 800f882:	f107 0710 	add.w	r7, r7, #16
 800f886:	46bd      	mov	sp, r7
 800f888:	bd80      	pop	{r7, pc}
 800f88a:	bf00      	nop

0800f88c <xmp3_CalcBitsUsed>:
 * Outputs:     none
 *
 * Return:      number of bits read from bitstream, as offset from startBuf:startOffset
 **************************************************************************************/
int CalcBitsUsed(BitStreamInfo *bsi, unsigned char *startBuf, int startOffset)
{
 800f88c:	b480      	push	{r7}
 800f88e:	b087      	sub	sp, #28
 800f890:	af00      	add	r7, sp, #0
 800f892:	60f8      	str	r0, [r7, #12]
 800f894:	60b9      	str	r1, [r7, #8]
 800f896:	607a      	str	r2, [r7, #4]
	int bitsUsed;

	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 800f898:	68fb      	ldr	r3, [r7, #12]
 800f89a:	681b      	ldr	r3, [r3, #0]
 800f89c:	461a      	mov	r2, r3
 800f89e:	68bb      	ldr	r3, [r7, #8]
 800f8a0:	1ad3      	subs	r3, r2, r3
 800f8a2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800f8a6:	617b      	str	r3, [r7, #20]
	bitsUsed -= bsi->cachedBits;
 800f8a8:	68fb      	ldr	r3, [r7, #12]
 800f8aa:	689b      	ldr	r3, [r3, #8]
 800f8ac:	697a      	ldr	r2, [r7, #20]
 800f8ae:	1ad3      	subs	r3, r2, r3
 800f8b0:	617b      	str	r3, [r7, #20]
	bitsUsed -= startOffset;
 800f8b2:	697a      	ldr	r2, [r7, #20]
 800f8b4:	687b      	ldr	r3, [r7, #4]
 800f8b6:	1ad3      	subs	r3, r2, r3
 800f8b8:	617b      	str	r3, [r7, #20]

	return bitsUsed;
 800f8ba:	697b      	ldr	r3, [r7, #20]
}
 800f8bc:	4618      	mov	r0, r3
 800f8be:	f107 071c 	add.w	r7, r7, #28
 800f8c2:	46bd      	mov	sp, r7
 800f8c4:	bc80      	pop	{r7}
 800f8c6:	4770      	bx	lr

0800f8c8 <xmp3_CheckPadBit>:
 * Outputs:     none
 *
 * Return:      1 if pad bit is set, 0 if not, -1 if null input pointer
 **************************************************************************************/
int CheckPadBit(MP3DecInfo *mp3DecInfo)
{
 800f8c8:	b480      	push	{r7}
 800f8ca:	b085      	sub	sp, #20
 800f8cc:	af00      	add	r7, sp, #0
 800f8ce:	6078      	str	r0, [r7, #4]
	FrameHeader *fh;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS)
 800f8d0:	687b      	ldr	r3, [r7, #4]
 800f8d2:	2b00      	cmp	r3, #0
 800f8d4:	d003      	beq.n	800f8de <xmp3_CheckPadBit+0x16>
 800f8d6:	687b      	ldr	r3, [r7, #4]
 800f8d8:	681b      	ldr	r3, [r3, #0]
 800f8da:	2b00      	cmp	r3, #0
 800f8dc:	d102      	bne.n	800f8e4 <xmp3_CheckPadBit+0x1c>
		return -1;
 800f8de:	f04f 33ff 	mov.w	r3, #4294967295
 800f8e2:	e008      	b.n	800f8f6 <xmp3_CheckPadBit+0x2e>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 800f8e4:	687b      	ldr	r3, [r7, #4]
 800f8e6:	681b      	ldr	r3, [r3, #0]
 800f8e8:	60fb      	str	r3, [r7, #12]

	return (fh->paddingBit ? 1 : 0);
 800f8ea:	68fb      	ldr	r3, [r7, #12]
 800f8ec:	695b      	ldr	r3, [r3, #20]
 800f8ee:	2b00      	cmp	r3, #0
 800f8f0:	bf0c      	ite	eq
 800f8f2:	2300      	moveq	r3, #0
 800f8f4:	2301      	movne	r3, #1
}
 800f8f6:	4618      	mov	r0, r3
 800f8f8:	f107 0714 	add.w	r7, r7, #20
 800f8fc:	46bd      	mov	sp, r7
 800f8fe:	bc80      	pop	{r7}
 800f900:	4770      	bx	lr
 800f902:	bf00      	nop

0800f904 <xmp3_UnpackFrameHeader>:
 *
 * TODO:        check for valid modes, depending on capabilities of decoder
 *              test CRC on actual stream (verify no endian problems)
 **************************************************************************************/
int UnpackFrameHeader(MP3DecInfo *mp3DecInfo, unsigned char *buf)
{
 800f904:	b490      	push	{r4, r7}
 800f906:	b084      	sub	sp, #16
 800f908:	af00      	add	r7, sp, #0
 800f90a:	6078      	str	r0, [r7, #4]
 800f90c:	6039      	str	r1, [r7, #0]

	int verIdx;
	FrameHeader *fh;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 800f90e:	687b      	ldr	r3, [r7, #4]
 800f910:	2b00      	cmp	r3, #0
 800f912:	d00f      	beq.n	800f934 <xmp3_UnpackFrameHeader+0x30>
 800f914:	687b      	ldr	r3, [r7, #4]
 800f916:	681b      	ldr	r3, [r3, #0]
 800f918:	2b00      	cmp	r3, #0
 800f91a:	d00b      	beq.n	800f934 <xmp3_UnpackFrameHeader+0x30>
 800f91c:	683b      	ldr	r3, [r7, #0]
 800f91e:	781b      	ldrb	r3, [r3, #0]
 800f920:	2bff      	cmp	r3, #255	; 0xff
 800f922:	d107      	bne.n	800f934 <xmp3_UnpackFrameHeader+0x30>
 800f924:	683b      	ldr	r3, [r7, #0]
 800f926:	f103 0301 	add.w	r3, r3, #1
 800f92a:	781b      	ldrb	r3, [r3, #0]
 800f92c:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 800f930:	2be0      	cmp	r3, #224	; 0xe0
 800f932:	d002      	beq.n	800f93a <xmp3_UnpackFrameHeader+0x36>
		return -1;
 800f934:	f04f 33ff 	mov.w	r3, #4294967295
 800f938:	e194      	b.n	800fc64 <xmp3_UnpackFrameHeader+0x360>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 800f93a:	687b      	ldr	r3, [r7, #4]
 800f93c:	681b      	ldr	r3, [r3, #0]
 800f93e:	60fb      	str	r3, [r7, #12]

	/* read header fields - use bitmasks instead of GetBits() for speed, since format never varies */
	verIdx =         (buf[1] >> 3) & 0x03;
 800f940:	683b      	ldr	r3, [r7, #0]
 800f942:	f103 0301 	add.w	r3, r3, #1
 800f946:	781b      	ldrb	r3, [r3, #0]
 800f948:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800f94c:	b2db      	uxtb	r3, r3
 800f94e:	f003 0303 	and.w	r3, r3, #3
 800f952:	60bb      	str	r3, [r7, #8]
	fh->ver =        (MPEGVersion)( verIdx == 0 ? MPEG25 : ((verIdx & 0x01) ? MPEG1 : MPEG2) );
 800f954:	68bb      	ldr	r3, [r7, #8]
 800f956:	2b00      	cmp	r3, #0
 800f958:	d00a      	beq.n	800f970 <xmp3_UnpackFrameHeader+0x6c>
 800f95a:	68bb      	ldr	r3, [r7, #8]
 800f95c:	f003 0301 	and.w	r3, r3, #1
 800f960:	2b00      	cmp	r3, #0
 800f962:	d102      	bne.n	800f96a <xmp3_UnpackFrameHeader+0x66>
 800f964:	f04f 0301 	mov.w	r3, #1
 800f968:	e001      	b.n	800f96e <xmp3_UnpackFrameHeader+0x6a>
 800f96a:	f04f 0300 	mov.w	r3, #0
 800f96e:	e001      	b.n	800f974 <xmp3_UnpackFrameHeader+0x70>
 800f970:	f04f 0302 	mov.w	r3, #2
 800f974:	68fa      	ldr	r2, [r7, #12]
 800f976:	7013      	strb	r3, [r2, #0]
	fh->layer = 4 - ((buf[1] >> 1) & 0x03);     /* easy mapping of index to layer number, 4 = error */
 800f978:	683b      	ldr	r3, [r7, #0]
 800f97a:	f103 0301 	add.w	r3, r3, #1
 800f97e:	781b      	ldrb	r3, [r3, #0]
 800f980:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800f984:	b2db      	uxtb	r3, r3
 800f986:	f003 0303 	and.w	r3, r3, #3
 800f98a:	f1c3 0204 	rsb	r2, r3, #4
 800f98e:	68fb      	ldr	r3, [r7, #12]
 800f990:	605a      	str	r2, [r3, #4]
	fh->crc =   1 - ((buf[1] >> 0) & 0x01);
 800f992:	683b      	ldr	r3, [r7, #0]
 800f994:	f103 0301 	add.w	r3, r3, #1
 800f998:	781b      	ldrb	r3, [r3, #0]
 800f99a:	f003 0301 	and.w	r3, r3, #1
 800f99e:	2b00      	cmp	r3, #0
 800f9a0:	bf14      	ite	ne
 800f9a2:	2200      	movne	r2, #0
 800f9a4:	2201      	moveq	r2, #1
 800f9a6:	68fb      	ldr	r3, [r7, #12]
 800f9a8:	609a      	str	r2, [r3, #8]
	fh->brIdx =      (buf[2] >> 4) & 0x0f;
 800f9aa:	683b      	ldr	r3, [r7, #0]
 800f9ac:	f103 0302 	add.w	r3, r3, #2
 800f9b0:	781b      	ldrb	r3, [r3, #0]
 800f9b2:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800f9b6:	b2db      	uxtb	r3, r3
 800f9b8:	f003 020f 	and.w	r2, r3, #15
 800f9bc:	68fb      	ldr	r3, [r7, #12]
 800f9be:	60da      	str	r2, [r3, #12]
	fh->srIdx =      (buf[2] >> 2) & 0x03;
 800f9c0:	683b      	ldr	r3, [r7, #0]
 800f9c2:	f103 0302 	add.w	r3, r3, #2
 800f9c6:	781b      	ldrb	r3, [r3, #0]
 800f9c8:	ea4f 0393 	mov.w	r3, r3, lsr #2
 800f9cc:	b2db      	uxtb	r3, r3
 800f9ce:	f003 0203 	and.w	r2, r3, #3
 800f9d2:	68fb      	ldr	r3, [r7, #12]
 800f9d4:	611a      	str	r2, [r3, #16]
	fh->paddingBit = (buf[2] >> 1) & 0x01;
 800f9d6:	683b      	ldr	r3, [r7, #0]
 800f9d8:	f103 0302 	add.w	r3, r3, #2
 800f9dc:	781b      	ldrb	r3, [r3, #0]
 800f9de:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800f9e2:	b2db      	uxtb	r3, r3
 800f9e4:	f003 0201 	and.w	r2, r3, #1
 800f9e8:	68fb      	ldr	r3, [r7, #12]
 800f9ea:	615a      	str	r2, [r3, #20]
	fh->privateBit = (buf[2] >> 0) & 0x01;
 800f9ec:	683b      	ldr	r3, [r7, #0]
 800f9ee:	f103 0302 	add.w	r3, r3, #2
 800f9f2:	781b      	ldrb	r3, [r3, #0]
 800f9f4:	f003 0201 	and.w	r2, r3, #1
 800f9f8:	68fb      	ldr	r3, [r7, #12]
 800f9fa:	619a      	str	r2, [r3, #24]
	fh->sMode =      (StereoMode)((buf[3] >> 6) & 0x03);      /* maps to correct enum (see definition) */    
 800f9fc:	683b      	ldr	r3, [r7, #0]
 800f9fe:	f103 0303 	add.w	r3, r3, #3
 800fa02:	781b      	ldrb	r3, [r3, #0]
 800fa04:	ea4f 1393 	mov.w	r3, r3, lsr #6
 800fa08:	b2da      	uxtb	r2, r3
 800fa0a:	68fb      	ldr	r3, [r7, #12]
 800fa0c:	771a      	strb	r2, [r3, #28]
	fh->modeExt =    (buf[3] >> 4) & 0x03;
 800fa0e:	683b      	ldr	r3, [r7, #0]
 800fa10:	f103 0303 	add.w	r3, r3, #3
 800fa14:	781b      	ldrb	r3, [r3, #0]
 800fa16:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800fa1a:	b2db      	uxtb	r3, r3
 800fa1c:	f003 0203 	and.w	r2, r3, #3
 800fa20:	68fb      	ldr	r3, [r7, #12]
 800fa22:	621a      	str	r2, [r3, #32]
	fh->copyFlag =   (buf[3] >> 3) & 0x01;
 800fa24:	683b      	ldr	r3, [r7, #0]
 800fa26:	f103 0303 	add.w	r3, r3, #3
 800fa2a:	781b      	ldrb	r3, [r3, #0]
 800fa2c:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800fa30:	b2db      	uxtb	r3, r3
 800fa32:	f003 0201 	and.w	r2, r3, #1
 800fa36:	68fb      	ldr	r3, [r7, #12]
 800fa38:	625a      	str	r2, [r3, #36]	; 0x24
	fh->origFlag =   (buf[3] >> 2) & 0x01;
 800fa3a:	683b      	ldr	r3, [r7, #0]
 800fa3c:	f103 0303 	add.w	r3, r3, #3
 800fa40:	781b      	ldrb	r3, [r3, #0]
 800fa42:	ea4f 0393 	mov.w	r3, r3, lsr #2
 800fa46:	b2db      	uxtb	r3, r3
 800fa48:	f003 0201 	and.w	r2, r3, #1
 800fa4c:	68fb      	ldr	r3, [r7, #12]
 800fa4e:	629a      	str	r2, [r3, #40]	; 0x28
	fh->emphasis =   (buf[3] >> 0) & 0x03;
 800fa50:	683b      	ldr	r3, [r7, #0]
 800fa52:	f103 0303 	add.w	r3, r3, #3
 800fa56:	781b      	ldrb	r3, [r3, #0]
 800fa58:	f003 0203 	and.w	r2, r3, #3
 800fa5c:	68fb      	ldr	r3, [r7, #12]
 800fa5e:	62da      	str	r2, [r3, #44]	; 0x2c

	/* check parameters to avoid indexing tables with bad values */
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 800fa60:	68fb      	ldr	r3, [r7, #12]
 800fa62:	691b      	ldr	r3, [r3, #16]
 800fa64:	2b03      	cmp	r3, #3
 800fa66:	d007      	beq.n	800fa78 <xmp3_UnpackFrameHeader+0x174>
 800fa68:	68fb      	ldr	r3, [r7, #12]
 800fa6a:	685b      	ldr	r3, [r3, #4]
 800fa6c:	2b04      	cmp	r3, #4
 800fa6e:	d003      	beq.n	800fa78 <xmp3_UnpackFrameHeader+0x174>
 800fa70:	68fb      	ldr	r3, [r7, #12]
 800fa72:	68db      	ldr	r3, [r3, #12]
 800fa74:	2b0f      	cmp	r3, #15
 800fa76:	d102      	bne.n	800fa7e <xmp3_UnpackFrameHeader+0x17a>
		return -1;
 800fa78:	f04f 33ff 	mov.w	r3, #4294967295
 800fa7c:	e0f2      	b.n	800fc64 <xmp3_UnpackFrameHeader+0x360>

	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 800fa7e:	68fb      	ldr	r3, [r7, #12]
 800fa80:	781b      	ldrb	r3, [r3, #0]
 800fa82:	f04f 02de 	mov.w	r2, #222	; 0xde
 800fa86:	fb02 f203 	mul.w	r2, r2, r3
 800fa8a:	68fb      	ldr	r3, [r7, #12]
 800fa8c:	691b      	ldr	r3, [r3, #16]
 800fa8e:	f04f 014a 	mov.w	r1, #74	; 0x4a
 800fa92:	fb01 f303 	mul.w	r3, r1, r3
 800fa96:	18d2      	adds	r2, r2, r3
 800fa98:	f64e 53c8 	movw	r3, #60872	; 0xedc8
 800fa9c:	f6c0 0302 	movt	r3, #2050	; 0x802
 800faa0:	18d2      	adds	r2, r2, r3
 800faa2:	68fb      	ldr	r3, [r7, #12]
 800faa4:	635a      	str	r2, [r3, #52]	; 0x34
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 800faa6:	68fb      	ldr	r3, [r7, #12]
 800faa8:	7f1b      	ldrb	r3, [r3, #28]
 800faaa:	2b01      	cmp	r3, #1
 800faac:	d003      	beq.n	800fab6 <xmp3_UnpackFrameHeader+0x1b2>
		fh->modeExt = 0;
 800faae:	68fb      	ldr	r3, [r7, #12]
 800fab0:	f04f 0200 	mov.w	r2, #0
 800fab4:	621a      	str	r2, [r3, #32]

	/* init user-accessible data */
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 800fab6:	68fb      	ldr	r3, [r7, #12]
 800fab8:	7f1b      	ldrb	r3, [r3, #28]
 800faba:	2b03      	cmp	r3, #3
 800fabc:	d102      	bne.n	800fac4 <xmp3_UnpackFrameHeader+0x1c0>
 800fabe:	f04f 0301 	mov.w	r3, #1
 800fac2:	e001      	b.n	800fac8 <xmp3_UnpackFrameHeader+0x1c4>
 800fac4:	f04f 0302 	mov.w	r3, #2
 800fac8:	687a      	ldr	r2, [r7, #4]
 800faca:	f8c2 37bc 	str.w	r3, [r2, #1980]	; 0x7bc
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 800face:	68fb      	ldr	r3, [r7, #12]
 800fad0:	781b      	ldrb	r3, [r3, #0]
 800fad2:	4619      	mov	r1, r3
 800fad4:	68fb      	ldr	r3, [r7, #12]
 800fad6:	6918      	ldr	r0, [r3, #16]
 800fad8:	f64e 3264 	movw	r2, #60260	; 0xeb64
 800fadc:	f6c0 0202 	movt	r2, #2050	; 0x802
 800fae0:	460b      	mov	r3, r1
 800fae2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800fae6:	185b      	adds	r3, r3, r1
 800fae8:	181b      	adds	r3, r3, r0
 800faea:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800faee:	687b      	ldr	r3, [r7, #4]
 800faf0:	f8c3 27c0 	str.w	r2, [r3, #1984]	; 0x7c0
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 800faf4:	68fb      	ldr	r3, [r7, #12]
 800faf6:	781b      	ldrb	r3, [r3, #0]
 800faf8:	2b00      	cmp	r3, #0
 800fafa:	d102      	bne.n	800fb02 <xmp3_UnpackFrameHeader+0x1fe>
 800fafc:	f04f 0302 	mov.w	r3, #2
 800fb00:	e001      	b.n	800fb06 <xmp3_UnpackFrameHeader+0x202>
 800fb02:	f04f 0301 	mov.w	r3, #1
 800fb06:	687a      	ldr	r2, [r7, #4]
 800fb08:	f8c2 37c4 	str.w	r3, [r2, #1988]	; 0x7c4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800fb0c:	68fb      	ldr	r3, [r7, #12]
 800fb0e:	781b      	ldrb	r3, [r3, #0]
 800fb10:	4619      	mov	r1, r3
 800fb12:	68fb      	ldr	r3, [r7, #12]
 800fb14:	685b      	ldr	r3, [r3, #4]
 800fb16:	f103 30ff 	add.w	r0, r3, #4294967295
 800fb1a:	f64e 4298 	movw	r2, #60568	; 0xec98
 800fb1e:	f6c0 0202 	movt	r2, #2050	; 0x802
 800fb22:	460b      	mov	r3, r1
 800fb24:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800fb28:	185b      	adds	r3, r3, r1
 800fb2a:	181b      	adds	r3, r3, r0
 800fb2c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800fb30:	b21a      	sxth	r2, r3
 800fb32:	687b      	ldr	r3, [r7, #4]
 800fb34:	f8d3 37c4 	ldr.w	r3, [r3, #1988]	; 0x7c4
 800fb38:	fb92 f2f3 	sdiv	r2, r2, r3
 800fb3c:	687b      	ldr	r3, [r7, #4]
 800fb3e:	f8c3 27c8 	str.w	r2, [r3, #1992]	; 0x7c8
	mp3DecInfo->layer = fh->layer;
 800fb42:	68fb      	ldr	r3, [r7, #12]
 800fb44:	685a      	ldr	r2, [r3, #4]
 800fb46:	687b      	ldr	r3, [r7, #4]
 800fb48:	f8c3 27d0 	str.w	r2, [r3, #2000]	; 0x7d0
	mp3DecInfo->version = fh->ver;
 800fb4c:	68fb      	ldr	r3, [r7, #12]
 800fb4e:	781a      	ldrb	r2, [r3, #0]
 800fb50:	687b      	ldr	r3, [r7, #4]
 800fb52:	f883 27d4 	strb.w	r2, [r3, #2004]	; 0x7d4
	/* get bitrate and nSlots from table, unless brIdx == 0 (free mode) in which case caller must figure it out himself
	 * question - do we want to overwrite mp3DecInfo->bitrate with 0 each time if it's free mode, and
	 *  copy the pre-calculated actual free bitrate into it in mp3dec.c (according to the spec, 
	 *  this shouldn't be necessary, since it should be either all frames free or none free)
	 */
	if (fh->brIdx) {
 800fb56:	68fb      	ldr	r3, [r7, #12]
 800fb58:	68db      	ldr	r3, [r3, #12]
 800fb5a:	2b00      	cmp	r3, #0
 800fb5c:	d068      	beq.n	800fc30 <xmp3_UnpackFrameHeader+0x32c>
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800fb5e:	68fb      	ldr	r3, [r7, #12]
 800fb60:	781b      	ldrb	r3, [r3, #0]
 800fb62:	4618      	mov	r0, r3
 800fb64:	68fb      	ldr	r3, [r7, #12]
 800fb66:	685b      	ldr	r3, [r3, #4]
 800fb68:	f103 33ff 	add.w	r3, r3, #4294967295
 800fb6c:	68fa      	ldr	r2, [r7, #12]
 800fb6e:	68d4      	ldr	r4, [r2, #12]
 800fb70:	f64e 3188 	movw	r1, #60296	; 0xeb88
 800fb74:	f6c0 0102 	movt	r1, #2050	; 0x802
 800fb78:	461a      	mov	r2, r3
 800fb7a:	ea4f 1202 	mov.w	r2, r2, lsl #4
 800fb7e:	1ad2      	subs	r2, r2, r3
 800fb80:	4603      	mov	r3, r0
 800fb82:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800fb86:	181b      	adds	r3, r3, r0
 800fb88:	ea4f 1003 	mov.w	r0, r3, lsl #4
 800fb8c:	1ac0      	subs	r0, r0, r3
 800fb8e:	1813      	adds	r3, r2, r0
 800fb90:	191b      	adds	r3, r3, r4
 800fb92:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800fb96:	b21b      	sxth	r3, r3
 800fb98:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800fb9c:	fb02 f203 	mul.w	r2, r2, r3
 800fba0:	687b      	ldr	r3, [r7, #4]
 800fba2:	f8c3 27b8 	str.w	r2, [r3, #1976]	; 0x7b8
	
		/* nSlots = total frame bytes (from table) - sideInfo bytes - header - CRC (if present) + pad (if present) */
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800fba6:	68fb      	ldr	r3, [r7, #12]
 800fba8:	781b      	ldrb	r3, [r3, #0]
 800fbaa:	4618      	mov	r0, r3
 800fbac:	68fb      	ldr	r3, [r7, #12]
 800fbae:	691b      	ldr	r3, [r3, #16]
 800fbb0:	68fa      	ldr	r2, [r7, #12]
 800fbb2:	68d4      	ldr	r4, [r2, #12]
 800fbb4:	f64e 41b8 	movw	r1, #60600	; 0xecb8
 800fbb8:	f6c0 0102 	movt	r1, #2050	; 0x802
 800fbbc:	461a      	mov	r2, r3
 800fbbe:	ea4f 1202 	mov.w	r2, r2, lsl #4
 800fbc2:	1ad2      	subs	r2, r2, r3
 800fbc4:	4603      	mov	r3, r0
 800fbc6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800fbca:	181b      	adds	r3, r3, r0
 800fbcc:	ea4f 1003 	mov.w	r0, r3, lsl #4
 800fbd0:	1ac0      	subs	r0, r0, r3
 800fbd2:	1813      	adds	r3, r2, r0
 800fbd4:	191b      	adds	r3, r3, r4
 800fbd6:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800fbda:	b21a      	sxth	r2, r3
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 800fbdc:	68fb      	ldr	r3, [r7, #12]
 800fbde:	781b      	ldrb	r3, [r3, #0]
 800fbe0:	4618      	mov	r0, r3
 800fbe2:	68fb      	ldr	r3, [r7, #12]
 800fbe4:	7f1b      	ldrb	r3, [r3, #28]
 800fbe6:	2b03      	cmp	r3, #3
 800fbe8:	bf0c      	ite	eq
 800fbea:	2100      	moveq	r1, #0
 800fbec:	2101      	movne	r1, #1
 800fbee:	f64e 43ac 	movw	r3, #60588	; 0xecac
 800fbf2:	f6c0 0302 	movt	r3, #2050	; 0x802
 800fbf6:	ea4f 0040 	mov.w	r0, r0, lsl #1
 800fbfa:	1841      	adds	r1, r0, r1
 800fbfc:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 800fc00:	b21b      	sxth	r3, r3
	 */
	if (fh->brIdx) {
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
	
		/* nSlots = total frame bytes (from table) - sideInfo bytes - header - CRC (if present) + pad (if present) */
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800fc02:	1ad3      	subs	r3, r2, r3
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 800fc04:	f1a3 0204 	sub.w	r2, r3, #4
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 800fc08:	68fb      	ldr	r3, [r7, #12]
 800fc0a:	689b      	ldr	r3, [r3, #8]
 800fc0c:	2b00      	cmp	r3, #0
 800fc0e:	d002      	beq.n	800fc16 <xmp3_UnpackFrameHeader+0x312>
 800fc10:	f04f 0302 	mov.w	r3, #2
 800fc14:	e001      	b.n	800fc1a <xmp3_UnpackFrameHeader+0x316>
 800fc16:	f04f 0300 	mov.w	r3, #0
 800fc1a:	1ad2      	subs	r2, r2, r3
 800fc1c:	68fb      	ldr	r3, [r7, #12]
 800fc1e:	695b      	ldr	r3, [r3, #20]
 800fc20:	2b00      	cmp	r3, #0
 800fc22:	bf0c      	ite	eq
 800fc24:	2300      	moveq	r3, #0
 800fc26:	2301      	movne	r3, #1
 800fc28:	18d2      	adds	r2, r2, r3
	 */
	if (fh->brIdx) {
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
	
		/* nSlots = total frame bytes (from table) - sideInfo bytes - header - CRC (if present) + pad (if present) */
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800fc2a:	687b      	ldr	r3, [r7, #4]
 800fc2c:	f8c3 27cc 	str.w	r2, [r3, #1996]	; 0x7cc
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
	}

	/* load crc word, if enabled, and return length of frame header (in bytes) */
	if (fh->crc) {
 800fc30:	68fb      	ldr	r3, [r7, #12]
 800fc32:	689b      	ldr	r3, [r3, #8]
 800fc34:	2b00      	cmp	r3, #0
 800fc36:	d00f      	beq.n	800fc58 <xmp3_UnpackFrameHeader+0x354>
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 800fc38:	683b      	ldr	r3, [r7, #0]
 800fc3a:	f103 0304 	add.w	r3, r3, #4
 800fc3e:	781b      	ldrb	r3, [r3, #0]
 800fc40:	ea4f 2203 	mov.w	r2, r3, lsl #8
 800fc44:	683b      	ldr	r3, [r7, #0]
 800fc46:	f103 0305 	add.w	r3, r3, #5
 800fc4a:	781b      	ldrb	r3, [r3, #0]
 800fc4c:	431a      	orrs	r2, r3
 800fc4e:	68fb      	ldr	r3, [r7, #12]
 800fc50:	631a      	str	r2, [r3, #48]	; 0x30
		return 6;
 800fc52:	f04f 0306 	mov.w	r3, #6
 800fc56:	e005      	b.n	800fc64 <xmp3_UnpackFrameHeader+0x360>
	} else {
		fh->CRCWord = 0;
 800fc58:	68fb      	ldr	r3, [r7, #12]
 800fc5a:	f04f 0200 	mov.w	r2, #0
 800fc5e:	631a      	str	r2, [r3, #48]	; 0x30
		return 4;
 800fc60:	f04f 0304 	mov.w	r3, #4
	}
}
 800fc64:	4618      	mov	r0, r3
 800fc66:	f107 0710 	add.w	r7, r7, #16
 800fc6a:	46bd      	mov	sp, r7
 800fc6c:	bc90      	pop	{r4, r7}
 800fc6e:	4770      	bx	lr

0800fc70 <xmp3_UnpackSideInfo>:
 *
 * Return:      length (in bytes) of side info data
 *              -1 if null input pointers
 **************************************************************************************/
int UnpackSideInfo(MP3DecInfo *mp3DecInfo, unsigned char *buf)
{
 800fc70:	b580      	push	{r7, lr}
 800fc72:	b08e      	sub	sp, #56	; 0x38
 800fc74:	af00      	add	r7, sp, #0
 800fc76:	6078      	str	r0, [r7, #4]
 800fc78:	6039      	str	r1, [r7, #0]
	FrameHeader *fh;
	SideInfo *si;
	SideInfoSub *sis;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS)
 800fc7a:	687b      	ldr	r3, [r7, #4]
 800fc7c:	2b00      	cmp	r3, #0
 800fc7e:	d007      	beq.n	800fc90 <xmp3_UnpackSideInfo+0x20>
 800fc80:	687b      	ldr	r3, [r7, #4]
 800fc82:	681b      	ldr	r3, [r3, #0]
 800fc84:	2b00      	cmp	r3, #0
 800fc86:	d003      	beq.n	800fc90 <xmp3_UnpackSideInfo+0x20>
 800fc88:	687b      	ldr	r3, [r7, #4]
 800fc8a:	685b      	ldr	r3, [r3, #4]
 800fc8c:	2b00      	cmp	r3, #0
 800fc8e:	d102      	bne.n	800fc96 <xmp3_UnpackSideInfo+0x26>
		return -1;
 800fc90:	f04f 33ff 	mov.w	r3, #4294967295
 800fc94:	e1bd      	b.n	8010012 <xmp3_UnpackSideInfo+0x3a2>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 800fc96:	687b      	ldr	r3, [r7, #4]
 800fc98:	681b      	ldr	r3, [r3, #0]
 800fc9a:	627b      	str	r3, [r7, #36]	; 0x24
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
 800fc9c:	687b      	ldr	r3, [r7, #4]
 800fc9e:	685b      	ldr	r3, [r3, #4]
 800fca0:	623b      	str	r3, [r7, #32]

	bsi = &bitStreamInfo;
 800fca2:	f107 0308 	add.w	r3, r7, #8
 800fca6:	61fb      	str	r3, [r7, #28]
	if (fh->ver == MPEG1) {
 800fca8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fcaa:	781b      	ldrb	r3, [r3, #0]
 800fcac:	2b00      	cmp	r3, #0
 800fcae:	d153      	bne.n	800fd58 <xmp3_UnpackSideInfo+0xe8>
		/* MPEG 1 */
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 800fcb0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fcb2:	7f1b      	ldrb	r3, [r3, #28]
 800fcb4:	2b03      	cmp	r3, #3
 800fcb6:	d102      	bne.n	800fcbe <xmp3_UnpackSideInfo+0x4e>
 800fcb8:	f04f 0311 	mov.w	r3, #17
 800fcbc:	e001      	b.n	800fcc2 <xmp3_UnpackSideInfo+0x52>
 800fcbe:	f04f 0320 	mov.w	r3, #32
 800fcc2:	62bb      	str	r3, [r7, #40]	; 0x28
		SetBitstreamPointer(bsi, nBytes, buf);
 800fcc4:	69f8      	ldr	r0, [r7, #28]
 800fcc6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800fcc8:	683a      	ldr	r2, [r7, #0]
 800fcca:	f7ff fcef 	bl	800f6ac <xmp3_SetBitstreamPointer>
		si->mainDataBegin = GetBits(bsi, 9);
 800fcce:	69f8      	ldr	r0, [r7, #28]
 800fcd0:	f04f 0109 	mov.w	r1, #9
 800fcd4:	f7ff fd8c 	bl	800f7f0 <xmp3_GetBits>
 800fcd8:	4603      	mov	r3, r0
 800fcda:	461a      	mov	r2, r3
 800fcdc:	6a3b      	ldr	r3, [r7, #32]
 800fcde:	601a      	str	r2, [r3, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 800fce0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fce2:	7f1b      	ldrb	r3, [r3, #28]
 800fce4:	2b03      	cmp	r3, #3
 800fce6:	d102      	bne.n	800fcee <xmp3_UnpackSideInfo+0x7e>
 800fce8:	f04f 0305 	mov.w	r3, #5
 800fcec:	e001      	b.n	800fcf2 <xmp3_UnpackSideInfo+0x82>
 800fcee:	f04f 0303 	mov.w	r3, #3
 800fcf2:	69f8      	ldr	r0, [r7, #28]
 800fcf4:	4619      	mov	r1, r3
 800fcf6:	f7ff fd7b 	bl	800f7f0 <xmp3_GetBits>
 800fcfa:	4603      	mov	r3, r0
 800fcfc:	461a      	mov	r2, r3
 800fcfe:	6a3b      	ldr	r3, [r7, #32]
 800fd00:	605a      	str	r2, [r3, #4]

		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800fd02:	f04f 0300 	mov.w	r3, #0
 800fd06:	633b      	str	r3, [r7, #48]	; 0x30
 800fd08:	e01f      	b.n	800fd4a <xmp3_UnpackSideInfo+0xda>
			for (bd = 0; bd < MAX_SCFBD; bd++)
 800fd0a:	f04f 0300 	mov.w	r3, #0
 800fd0e:	62fb      	str	r3, [r7, #44]	; 0x2c
 800fd10:	e014      	b.n	800fd3c <xmp3_UnpackSideInfo+0xcc>
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 800fd12:	69f8      	ldr	r0, [r7, #28]
 800fd14:	f04f 0101 	mov.w	r1, #1
 800fd18:	f7ff fd6a 	bl	800f7f0 <xmp3_GetBits>
 800fd1c:	4603      	mov	r3, r0
 800fd1e:	4619      	mov	r1, r3
 800fd20:	6a3b      	ldr	r3, [r7, #32]
 800fd22:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800fd24:	ea4f 0082 	mov.w	r0, r2, lsl #2
 800fd28:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800fd2a:	1882      	adds	r2, r0, r2
 800fd2c:	f102 0202 	add.w	r2, r2, #2
 800fd30:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		SetBitstreamPointer(bsi, nBytes, buf);
		si->mainDataBegin = GetBits(bsi, 9);
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));

		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
			for (bd = 0; bd < MAX_SCFBD; bd++)
 800fd34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd36:	f103 0301 	add.w	r3, r3, #1
 800fd3a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800fd3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd3e:	2b03      	cmp	r3, #3
 800fd40:	dde7      	ble.n	800fd12 <xmp3_UnpackSideInfo+0xa2>
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
		SetBitstreamPointer(bsi, nBytes, buf);
		si->mainDataBegin = GetBits(bsi, 9);
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));

		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800fd42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fd44:	f103 0301 	add.w	r3, r3, #1
 800fd48:	633b      	str	r3, [r7, #48]	; 0x30
 800fd4a:	687b      	ldr	r3, [r7, #4]
 800fd4c:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 800fd50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fd52:	429a      	cmp	r2, r3
 800fd54:	dcd9      	bgt.n	800fd0a <xmp3_UnpackSideInfo+0x9a>
 800fd56:	e028      	b.n	800fdaa <xmp3_UnpackSideInfo+0x13a>
			for (bd = 0; bd < MAX_SCFBD; bd++)
				si->scfsi[ch][bd] = GetBits(bsi, 1);
	} else {
		/* MPEG 2, MPEG 2.5 */
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 800fd58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fd5a:	7f1b      	ldrb	r3, [r3, #28]
 800fd5c:	2b03      	cmp	r3, #3
 800fd5e:	d102      	bne.n	800fd66 <xmp3_UnpackSideInfo+0xf6>
 800fd60:	f04f 0309 	mov.w	r3, #9
 800fd64:	e001      	b.n	800fd6a <xmp3_UnpackSideInfo+0xfa>
 800fd66:	f04f 0311 	mov.w	r3, #17
 800fd6a:	62bb      	str	r3, [r7, #40]	; 0x28
		SetBitstreamPointer(bsi, nBytes, buf);
 800fd6c:	69f8      	ldr	r0, [r7, #28]
 800fd6e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800fd70:	683a      	ldr	r2, [r7, #0]
 800fd72:	f7ff fc9b 	bl	800f6ac <xmp3_SetBitstreamPointer>
		si->mainDataBegin = GetBits(bsi, 8);
 800fd76:	69f8      	ldr	r0, [r7, #28]
 800fd78:	f04f 0108 	mov.w	r1, #8
 800fd7c:	f7ff fd38 	bl	800f7f0 <xmp3_GetBits>
 800fd80:	4603      	mov	r3, r0
 800fd82:	461a      	mov	r2, r3
 800fd84:	6a3b      	ldr	r3, [r7, #32]
 800fd86:	601a      	str	r2, [r3, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
 800fd88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fd8a:	7f1b      	ldrb	r3, [r3, #28]
 800fd8c:	2b03      	cmp	r3, #3
 800fd8e:	d102      	bne.n	800fd96 <xmp3_UnpackSideInfo+0x126>
 800fd90:	f04f 0301 	mov.w	r3, #1
 800fd94:	e001      	b.n	800fd9a <xmp3_UnpackSideInfo+0x12a>
 800fd96:	f04f 0302 	mov.w	r3, #2
 800fd9a:	69f8      	ldr	r0, [r7, #28]
 800fd9c:	4619      	mov	r1, r3
 800fd9e:	f7ff fd27 	bl	800f7f0 <xmp3_GetBits>
 800fda2:	4603      	mov	r3, r0
 800fda4:	461a      	mov	r2, r3
 800fda6:	6a3b      	ldr	r3, [r7, #32]
 800fda8:	605a      	str	r2, [r3, #4]
	}

	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800fdaa:	f04f 0300 	mov.w	r3, #0
 800fdae:	637b      	str	r3, [r7, #52]	; 0x34
 800fdb0:	e122      	b.n	800fff8 <xmp3_UnpackSideInfo+0x388>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800fdb2:	f04f 0300 	mov.w	r3, #0
 800fdb6:	633b      	str	r3, [r7, #48]	; 0x30
 800fdb8:	e113      	b.n	800ffe2 <xmp3_UnpackSideInfo+0x372>
			sis = &si->sis[gr][ch];						/* side info subblock for this granule, channel */
 800fdba:	6a3b      	ldr	r3, [r7, #32]
 800fdbc:	f103 0128 	add.w	r1, r3, #40	; 0x28
 800fdc0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800fdc2:	4613      	mov	r3, r2
 800fdc4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800fdc8:	189b      	adds	r3, r3, r2
 800fdca:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800fdce:	4618      	mov	r0, r3
 800fdd0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800fdd2:	4613      	mov	r3, r2
 800fdd4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800fdd8:	189b      	adds	r3, r3, r2
 800fdda:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800fdde:	18c3      	adds	r3, r0, r3
 800fde0:	18cb      	adds	r3, r1, r3
 800fde2:	61bb      	str	r3, [r7, #24]

			sis->part23Length =    GetBits(bsi, 12);
 800fde4:	69f8      	ldr	r0, [r7, #28]
 800fde6:	f04f 010c 	mov.w	r1, #12
 800fdea:	f7ff fd01 	bl	800f7f0 <xmp3_GetBits>
 800fdee:	4603      	mov	r3, r0
 800fdf0:	461a      	mov	r2, r3
 800fdf2:	69bb      	ldr	r3, [r7, #24]
 800fdf4:	601a      	str	r2, [r3, #0]
			sis->nBigvals =        GetBits(bsi, 9);
 800fdf6:	69f8      	ldr	r0, [r7, #28]
 800fdf8:	f04f 0109 	mov.w	r1, #9
 800fdfc:	f7ff fcf8 	bl	800f7f0 <xmp3_GetBits>
 800fe00:	4603      	mov	r3, r0
 800fe02:	461a      	mov	r2, r3
 800fe04:	69bb      	ldr	r3, [r7, #24]
 800fe06:	605a      	str	r2, [r3, #4]
			sis->globalGain =      GetBits(bsi, 8);
 800fe08:	69f8      	ldr	r0, [r7, #28]
 800fe0a:	f04f 0108 	mov.w	r1, #8
 800fe0e:	f7ff fcef 	bl	800f7f0 <xmp3_GetBits>
 800fe12:	4603      	mov	r3, r0
 800fe14:	461a      	mov	r2, r3
 800fe16:	69bb      	ldr	r3, [r7, #24]
 800fe18:	609a      	str	r2, [r3, #8]
			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
 800fe1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fe1c:	781b      	ldrb	r3, [r3, #0]
 800fe1e:	2b00      	cmp	r3, #0
 800fe20:	d102      	bne.n	800fe28 <xmp3_UnpackSideInfo+0x1b8>
 800fe22:	f04f 0304 	mov.w	r3, #4
 800fe26:	e001      	b.n	800fe2c <xmp3_UnpackSideInfo+0x1bc>
 800fe28:	f04f 0309 	mov.w	r3, #9
 800fe2c:	69f8      	ldr	r0, [r7, #28]
 800fe2e:	4619      	mov	r1, r3
 800fe30:	f7ff fcde 	bl	800f7f0 <xmp3_GetBits>
 800fe34:	4603      	mov	r3, r0
 800fe36:	461a      	mov	r2, r3
 800fe38:	69bb      	ldr	r3, [r7, #24]
 800fe3a:	60da      	str	r2, [r3, #12]
			sis->winSwitchFlag =   GetBits(bsi, 1);
 800fe3c:	69f8      	ldr	r0, [r7, #28]
 800fe3e:	f04f 0101 	mov.w	r1, #1
 800fe42:	f7ff fcd5 	bl	800f7f0 <xmp3_GetBits>
 800fe46:	4603      	mov	r3, r0
 800fe48:	461a      	mov	r2, r3
 800fe4a:	69bb      	ldr	r3, [r7, #24]
 800fe4c:	611a      	str	r2, [r3, #16]

			if(sis->winSwitchFlag) {
 800fe4e:	69bb      	ldr	r3, [r7, #24]
 800fe50:	691b      	ldr	r3, [r3, #16]
 800fe52:	2b00      	cmp	r3, #0
 800fe54:	d06b      	beq.n	800ff2e <xmp3_UnpackSideInfo+0x2be>
				/* this is a start, stop, short, or mixed block */
				sis->blockType =       GetBits(bsi, 2);		/* 0 = normal, 1 = start, 2 = short, 3 = stop */
 800fe56:	69f8      	ldr	r0, [r7, #28]
 800fe58:	f04f 0102 	mov.w	r1, #2
 800fe5c:	f7ff fcc8 	bl	800f7f0 <xmp3_GetBits>
 800fe60:	4603      	mov	r3, r0
 800fe62:	461a      	mov	r2, r3
 800fe64:	69bb      	ldr	r3, [r7, #24]
 800fe66:	615a      	str	r2, [r3, #20]
				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
 800fe68:	69f8      	ldr	r0, [r7, #28]
 800fe6a:	f04f 0101 	mov.w	r1, #1
 800fe6e:	f7ff fcbf 	bl	800f7f0 <xmp3_GetBits>
 800fe72:	4603      	mov	r3, r0
 800fe74:	461a      	mov	r2, r3
 800fe76:	69bb      	ldr	r3, [r7, #24]
 800fe78:	619a      	str	r2, [r3, #24]
				sis->tableSelect[0] =  GetBits(bsi, 5);
 800fe7a:	69f8      	ldr	r0, [r7, #28]
 800fe7c:	f04f 0105 	mov.w	r1, #5
 800fe80:	f7ff fcb6 	bl	800f7f0 <xmp3_GetBits>
 800fe84:	4603      	mov	r3, r0
 800fe86:	461a      	mov	r2, r3
 800fe88:	69bb      	ldr	r3, [r7, #24]
 800fe8a:	61da      	str	r2, [r3, #28]
				sis->tableSelect[1] =  GetBits(bsi, 5);
 800fe8c:	69f8      	ldr	r0, [r7, #28]
 800fe8e:	f04f 0105 	mov.w	r1, #5
 800fe92:	f7ff fcad 	bl	800f7f0 <xmp3_GetBits>
 800fe96:	4603      	mov	r3, r0
 800fe98:	461a      	mov	r2, r3
 800fe9a:	69bb      	ldr	r3, [r7, #24]
 800fe9c:	621a      	str	r2, [r3, #32]
				sis->tableSelect[2] =  0;					/* unused */
 800fe9e:	69bb      	ldr	r3, [r7, #24]
 800fea0:	f04f 0200 	mov.w	r2, #0
 800fea4:	625a      	str	r2, [r3, #36]	; 0x24
				sis->subBlockGain[0] = GetBits(bsi, 3);
 800fea6:	69f8      	ldr	r0, [r7, #28]
 800fea8:	f04f 0103 	mov.w	r1, #3
 800feac:	f7ff fca0 	bl	800f7f0 <xmp3_GetBits>
 800feb0:	4603      	mov	r3, r0
 800feb2:	461a      	mov	r2, r3
 800feb4:	69bb      	ldr	r3, [r7, #24]
 800feb6:	629a      	str	r2, [r3, #40]	; 0x28
				sis->subBlockGain[1] = GetBits(bsi, 3);
 800feb8:	69f8      	ldr	r0, [r7, #28]
 800feba:	f04f 0103 	mov.w	r1, #3
 800febe:	f7ff fc97 	bl	800f7f0 <xmp3_GetBits>
 800fec2:	4603      	mov	r3, r0
 800fec4:	461a      	mov	r2, r3
 800fec6:	69bb      	ldr	r3, [r7, #24]
 800fec8:	62da      	str	r2, [r3, #44]	; 0x2c
				sis->subBlockGain[2] = GetBits(bsi, 3);
 800feca:	69f8      	ldr	r0, [r7, #28]
 800fecc:	f04f 0103 	mov.w	r1, #3
 800fed0:	f7ff fc8e 	bl	800f7f0 <xmp3_GetBits>
 800fed4:	4603      	mov	r3, r0
 800fed6:	461a      	mov	r2, r3
 800fed8:	69bb      	ldr	r3, [r7, #24]
 800feda:	631a      	str	r2, [r3, #48]	; 0x30

				/* TODO - check logic */
				if (sis->blockType == 0) {
 800fedc:	69bb      	ldr	r3, [r7, #24]
 800fede:	695b      	ldr	r3, [r3, #20]
 800fee0:	2b00      	cmp	r3, #0
 800fee2:	d10c      	bne.n	800fefe <xmp3_UnpackSideInfo+0x28e>
					/* this should not be allowed, according to spec */
					sis->nBigvals = 0;
 800fee4:	69bb      	ldr	r3, [r7, #24]
 800fee6:	f04f 0200 	mov.w	r2, #0
 800feea:	605a      	str	r2, [r3, #4]
					sis->part23Length = 0;
 800feec:	69bb      	ldr	r3, [r7, #24]
 800feee:	f04f 0200 	mov.w	r2, #0
 800fef2:	601a      	str	r2, [r3, #0]
					sis->sfCompress = 0;
 800fef4:	69bb      	ldr	r3, [r7, #24]
 800fef6:	f04f 0200 	mov.w	r2, #0
 800fefa:	60da      	str	r2, [r3, #12]
 800fefc:	e010      	b.n	800ff20 <xmp3_UnpackSideInfo+0x2b0>
				} else if (sis->blockType == 2 && sis->mixedBlock == 0) {
 800fefe:	69bb      	ldr	r3, [r7, #24]
 800ff00:	695b      	ldr	r3, [r3, #20]
 800ff02:	2b02      	cmp	r3, #2
 800ff04:	d108      	bne.n	800ff18 <xmp3_UnpackSideInfo+0x2a8>
 800ff06:	69bb      	ldr	r3, [r7, #24]
 800ff08:	699b      	ldr	r3, [r3, #24]
 800ff0a:	2b00      	cmp	r3, #0
 800ff0c:	d104      	bne.n	800ff18 <xmp3_UnpackSideInfo+0x2a8>
					/* short block, not mixed */
					sis->region0Count = 8;
 800ff0e:	69bb      	ldr	r3, [r7, #24]
 800ff10:	f04f 0208 	mov.w	r2, #8
 800ff14:	635a      	str	r2, [r3, #52]	; 0x34
 800ff16:	e003      	b.n	800ff20 <xmp3_UnpackSideInfo+0x2b0>
				} else {
					/* start, stop, or short-mixed */
					sis->region0Count = 7;
 800ff18:	69bb      	ldr	r3, [r7, #24]
 800ff1a:	f04f 0207 	mov.w	r2, #7
 800ff1e:	635a      	str	r2, [r3, #52]	; 0x34
				}
				sis->region1Count = 20 - sis->region0Count;
 800ff20:	69bb      	ldr	r3, [r7, #24]
 800ff22:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ff24:	f1c3 0214 	rsb	r2, r3, #20
 800ff28:	69bb      	ldr	r3, [r7, #24]
 800ff2a:	639a      	str	r2, [r3, #56]	; 0x38
 800ff2c:	e034      	b.n	800ff98 <xmp3_UnpackSideInfo+0x328>
			} else {
				/* this is a normal block */
				sis->blockType = 0;
 800ff2e:	69bb      	ldr	r3, [r7, #24]
 800ff30:	f04f 0200 	mov.w	r2, #0
 800ff34:	615a      	str	r2, [r3, #20]
				sis->mixedBlock = 0;
 800ff36:	69bb      	ldr	r3, [r7, #24]
 800ff38:	f04f 0200 	mov.w	r2, #0
 800ff3c:	619a      	str	r2, [r3, #24]
				sis->tableSelect[0] =  GetBits(bsi, 5);
 800ff3e:	69f8      	ldr	r0, [r7, #28]
 800ff40:	f04f 0105 	mov.w	r1, #5
 800ff44:	f7ff fc54 	bl	800f7f0 <xmp3_GetBits>
 800ff48:	4603      	mov	r3, r0
 800ff4a:	461a      	mov	r2, r3
 800ff4c:	69bb      	ldr	r3, [r7, #24]
 800ff4e:	61da      	str	r2, [r3, #28]
				sis->tableSelect[1] =  GetBits(bsi, 5);
 800ff50:	69f8      	ldr	r0, [r7, #28]
 800ff52:	f04f 0105 	mov.w	r1, #5
 800ff56:	f7ff fc4b 	bl	800f7f0 <xmp3_GetBits>
 800ff5a:	4603      	mov	r3, r0
 800ff5c:	461a      	mov	r2, r3
 800ff5e:	69bb      	ldr	r3, [r7, #24]
 800ff60:	621a      	str	r2, [r3, #32]
				sis->tableSelect[2] =  GetBits(bsi, 5);
 800ff62:	69f8      	ldr	r0, [r7, #28]
 800ff64:	f04f 0105 	mov.w	r1, #5
 800ff68:	f7ff fc42 	bl	800f7f0 <xmp3_GetBits>
 800ff6c:	4603      	mov	r3, r0
 800ff6e:	461a      	mov	r2, r3
 800ff70:	69bb      	ldr	r3, [r7, #24]
 800ff72:	625a      	str	r2, [r3, #36]	; 0x24
				sis->region0Count =    GetBits(bsi, 4);
 800ff74:	69f8      	ldr	r0, [r7, #28]
 800ff76:	f04f 0104 	mov.w	r1, #4
 800ff7a:	f7ff fc39 	bl	800f7f0 <xmp3_GetBits>
 800ff7e:	4603      	mov	r3, r0
 800ff80:	461a      	mov	r2, r3
 800ff82:	69bb      	ldr	r3, [r7, #24]
 800ff84:	635a      	str	r2, [r3, #52]	; 0x34
				sis->region1Count =    GetBits(bsi, 3);
 800ff86:	69f8      	ldr	r0, [r7, #28]
 800ff88:	f04f 0103 	mov.w	r1, #3
 800ff8c:	f7ff fc30 	bl	800f7f0 <xmp3_GetBits>
 800ff90:	4603      	mov	r3, r0
 800ff92:	461a      	mov	r2, r3
 800ff94:	69bb      	ldr	r3, [r7, #24]
 800ff96:	639a      	str	r2, [r3, #56]	; 0x38
			}
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800ff98:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ff9a:	781b      	ldrb	r3, [r3, #0]
 800ff9c:	2b00      	cmp	r3, #0
 800ff9e:	d106      	bne.n	800ffae <xmp3_UnpackSideInfo+0x33e>
 800ffa0:	69f8      	ldr	r0, [r7, #28]
 800ffa2:	f04f 0101 	mov.w	r1, #1
 800ffa6:	f7ff fc23 	bl	800f7f0 <xmp3_GetBits>
 800ffaa:	4603      	mov	r3, r0
 800ffac:	e001      	b.n	800ffb2 <xmp3_UnpackSideInfo+0x342>
 800ffae:	f04f 0300 	mov.w	r3, #0
 800ffb2:	69ba      	ldr	r2, [r7, #24]
 800ffb4:	63d3      	str	r3, [r2, #60]	; 0x3c
			sis->sfactScale =        GetBits(bsi, 1);
 800ffb6:	69f8      	ldr	r0, [r7, #28]
 800ffb8:	f04f 0101 	mov.w	r1, #1
 800ffbc:	f7ff fc18 	bl	800f7f0 <xmp3_GetBits>
 800ffc0:	4603      	mov	r3, r0
 800ffc2:	461a      	mov	r2, r3
 800ffc4:	69bb      	ldr	r3, [r7, #24]
 800ffc6:	641a      	str	r2, [r3, #64]	; 0x40
			sis->count1TableSelect = GetBits(bsi, 1);
 800ffc8:	69f8      	ldr	r0, [r7, #28]
 800ffca:	f04f 0101 	mov.w	r1, #1
 800ffce:	f7ff fc0f 	bl	800f7f0 <xmp3_GetBits>
 800ffd2:	4603      	mov	r3, r0
 800ffd4:	461a      	mov	r2, r3
 800ffd6:	69bb      	ldr	r3, [r7, #24]
 800ffd8:	645a      	str	r2, [r3, #68]	; 0x44
		si->mainDataBegin = GetBits(bsi, 8);
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
	}

	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ffda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ffdc:	f103 0301 	add.w	r3, r3, #1
 800ffe0:	633b      	str	r3, [r7, #48]	; 0x30
 800ffe2:	687b      	ldr	r3, [r7, #4]
 800ffe4:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 800ffe8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ffea:	429a      	cmp	r2, r3
 800ffec:	f73f aee5 	bgt.w	800fdba <xmp3_UnpackSideInfo+0x14a>
		SetBitstreamPointer(bsi, nBytes, buf);
		si->mainDataBegin = GetBits(bsi, 8);
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
	}

	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800fff0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fff2:	f103 0301 	add.w	r3, r3, #1
 800fff6:	637b      	str	r3, [r7, #52]	; 0x34
 800fff8:	687b      	ldr	r3, [r7, #4]
 800fffa:	f8d3 27c4 	ldr.w	r2, [r3, #1988]	; 0x7c4
 800fffe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010000:	429a      	cmp	r2, r3
 8010002:	f73f aed6 	bgt.w	800fdb2 <xmp3_UnpackSideInfo+0x142>
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
			sis->sfactScale =        GetBits(bsi, 1);
			sis->count1TableSelect = GetBits(bsi, 1);
		}
	}
	mp3DecInfo->mainDataBegin = si->mainDataBegin;	/* needed by main decode loop */
 8010006:	6a3b      	ldr	r3, [r7, #32]
 8010008:	681a      	ldr	r2, [r3, #0]
 801000a:	687b      	ldr	r3, [r7, #4]
 801000c:	f8c3 27d8 	str.w	r2, [r3, #2008]	; 0x7d8

	ASSERT(nBytes == CalcBitsUsed(bsi, buf, 0) >> 3);

	return nBytes;	
 8010010:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 8010012:	4618      	mov	r0, r3
 8010014:	f107 0738 	add.w	r7, r7, #56	; 0x38
 8010018:	46bd      	mov	sp, r7
 801001a:	bd80      	pop	{r7, pc}

0801001c <ClearBuffer>:
 * Return:      none
 *
 * Notes:       slow, platform-independent equivalent to memset(buf, 0, nBytes)
 **************************************************************************************/
void ClearBuffer(void *buf, int nBytes)
{
 801001c:	b480      	push	{r7}
 801001e:	b085      	sub	sp, #20
 8010020:	af00      	add	r7, sp, #0
 8010022:	6078      	str	r0, [r7, #4]
 8010024:	6039      	str	r1, [r7, #0]
	int i;
	unsigned char *cbuf = (unsigned char *)buf;
 8010026:	687b      	ldr	r3, [r7, #4]
 8010028:	60bb      	str	r3, [r7, #8]

	for (i = 0; i < nBytes; i++)
 801002a:	f04f 0300 	mov.w	r3, #0
 801002e:	60fb      	str	r3, [r7, #12]
 8010030:	e009      	b.n	8010046 <ClearBuffer+0x2a>
		cbuf[i] = 0;
 8010032:	68fb      	ldr	r3, [r7, #12]
 8010034:	68ba      	ldr	r2, [r7, #8]
 8010036:	18d3      	adds	r3, r2, r3
 8010038:	f04f 0200 	mov.w	r2, #0
 801003c:	701a      	strb	r2, [r3, #0]
void ClearBuffer(void *buf, int nBytes)
{
	int i;
	unsigned char *cbuf = (unsigned char *)buf;

	for (i = 0; i < nBytes; i++)
 801003e:	68fb      	ldr	r3, [r7, #12]
 8010040:	f103 0301 	add.w	r3, r3, #1
 8010044:	60fb      	str	r3, [r7, #12]
 8010046:	68fa      	ldr	r2, [r7, #12]
 8010048:	683b      	ldr	r3, [r7, #0]
 801004a:	429a      	cmp	r2, r3
 801004c:	dbf1      	blt.n	8010032 <ClearBuffer+0x16>
		cbuf[i] = 0;

}
 801004e:	f107 0714 	add.w	r7, r7, #20
 8010052:	46bd      	mov	sp, r7
 8010054:	bc80      	pop	{r7}
 8010056:	4770      	bx	lr

08010058 <xmp3_AllocateBuffers>:
 *
 *              Changed by Kasper Jepsen to support static buffers as well.
 *
 **************************************************************************************/
MP3DecInfo *AllocateBuffers(void)
{
 8010058:	b580      	push	{r7, lr}
 801005a:	b082      	sub	sp, #8
 801005c:	af00      	add	r7, sp, #0
  MP3DecInfo *mp3DecInfo_pointer;
  #ifdef static_buffers
  mp3DecInfo_pointer = (MP3DecInfo*)&mp3DecInfo;
 801005e:	f244 6338 	movw	r3, #17976	; 0x4638
 8010062:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010066:	607b      	str	r3, [r7, #4]
  ClearBuffer((void*)&mp3DecInfo, sizeof(MP3DecInfo));
 8010068:	f244 6038 	movw	r0, #17976	; 0x4638
 801006c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8010070:	f44f 61fe 	mov.w	r1, #2032	; 0x7f0
 8010074:	f7ff ffd2 	bl	801001c <ClearBuffer>

  	mp3DecInfo.FrameHeaderPS =     (void*)&fh;
 8010078:	f244 6338 	movw	r3, #17976	; 0x4638
 801007c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010080:	f244 6200 	movw	r2, #17920	; 0x4600
 8010084:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010088:	601a      	str	r2, [r3, #0]
	mp3DecInfo.SideInfoPS =        (void*)&si;
 801008a:	f244 6338 	movw	r3, #17976	; 0x4638
 801008e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010092:	f644 7244 	movw	r2, #20292	; 0x4f44
 8010096:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801009a:	605a      	str	r2, [r3, #4]
	mp3DecInfo.ScaleFactorInfoPS = (void*)&sfi;
 801009c:	f244 6338 	movw	r3, #17976	; 0x4638
 80100a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100a4:	f644 6228 	movw	r2, #20008	; 0x4e28
 80100a8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80100ac:	609a      	str	r2, [r3, #8]
	mp3DecInfo.HuffmanInfoPS =     (void*)&hi;
 80100ae:	f244 6338 	movw	r3, #17976	; 0x4638
 80100b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100b6:	f247 2290 	movw	r2, #29328	; 0x7290
 80100ba:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80100be:	60da      	str	r2, [r3, #12]
	mp3DecInfo.DequantInfoPS =     (void*)&di;
 80100c0:	f244 6338 	movw	r3, #17976	; 0x4638
 80100c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100c8:	f248 42a0 	movw	r2, #33952	; 0x84a0
 80100cc:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80100d0:	611a      	str	r2, [r3, #16]
	mp3DecInfo.IMDCTInfoPS =       (void*)&mi;
 80100d2:	f244 6338 	movw	r3, #17976	; 0x4638
 80100d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100da:	f248 72e8 	movw	r2, #34792	; 0x87e8
 80100de:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80100e2:	615a      	str	r2, [r3, #20]
	mp3DecInfo.SubbandInfoPS =     (void*)&sbi;
 80100e4:	f244 6338 	movw	r3, #17976	; 0x4638
 80100e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100ec:	f245 028c 	movw	r2, #20620	; 0x508c
 80100f0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80100f4:	619a      	str	r2, [r3, #24]

	/* important to do this - DSP primitives assume a bunch of state variables are 0 on first use */
    ClearBuffer((void*)&fh,  sizeof(FrameHeader));
 80100f6:	f244 6000 	movw	r0, #17920	; 0x4600
 80100fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80100fe:	f04f 0138 	mov.w	r1, #56	; 0x38
 8010102:	f7ff ff8b 	bl	801001c <ClearBuffer>
	ClearBuffer((void*)&si,  sizeof(SideInfo));
 8010106:	f644 7044 	movw	r0, #20292	; 0x4f44
 801010a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801010e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010112:	f7ff ff83 	bl	801001c <ClearBuffer>
	ClearBuffer((void*)&sfi, sizeof(ScaleFactorInfo));
 8010116:	f644 6028 	movw	r0, #20008	; 0x4e28
 801011a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801011e:	f44f 718e 	mov.w	r1, #284	; 0x11c
 8010122:	f7ff ff7b 	bl	801001c <ClearBuffer>
	ClearBuffer((void*)&hi,  sizeof(HuffmanInfo));
 8010126:	f247 2090 	movw	r0, #29328	; 0x7290
 801012a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801012e:	f241 2110 	movw	r1, #4624	; 0x1210
 8010132:	f7ff ff73 	bl	801001c <ClearBuffer>
	ClearBuffer((void*)&di,  sizeof(DequantInfo));
 8010136:	f248 40a0 	movw	r0, #33952	; 0x84a0
 801013a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801013e:	f44f 7152 	mov.w	r1, #840	; 0x348
 8010142:	f7ff ff6b 	bl	801001c <ClearBuffer>
	ClearBuffer((void*)&mi,  sizeof(IMDCTInfo));
 8010146:	f248 70e8 	movw	r0, #34792	; 0x87e8
 801014a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801014e:	f44f 51d9 	mov.w	r1, #6944	; 0x1b20
 8010152:	f7ff ff63 	bl	801001c <ClearBuffer>
	ClearBuffer((void*)&sbi, sizeof(SubbandInfo));
 8010156:	f245 008c 	movw	r0, #20620	; 0x508c
 801015a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801015e:	f242 2104 	movw	r1, #8708	; 0x2204
 8010162:	f7ff ff5b 	bl	801001c <ClearBuffer>
	ClearBuffer(di,  sizeof(DequantInfo));
	ClearBuffer(mi,  sizeof(IMDCTInfo));
	ClearBuffer(sbi, sizeof(SubbandInfo));

#endif
	return mp3DecInfo_pointer;
 8010166:	687b      	ldr	r3, [r7, #4]

}
 8010168:	4618      	mov	r0, r3
 801016a:	f107 0708 	add.w	r7, r7, #8
 801016e:	46bd      	mov	sp, r7
 8010170:	bd80      	pop	{r7, pc}
 8010172:	bf00      	nop

08010174 <xmp3_FreeBuffers>:
 * Return:      none
 *
 * Notes:       safe to call even if some buffers were not allocated (uses SAFE_FREE)
 **************************************************************************************/
void FreeBuffers(MP3DecInfo *mp3DecInfo)
{
 8010174:	b480      	push	{r7}
 8010176:	b083      	sub	sp, #12
 8010178:	af00      	add	r7, sp, #0
 801017a:	6078      	str	r0, [r7, #4]
	SAFE_FREE(mp3DecInfo->IMDCTInfoPS);
	SAFE_FREE(mp3DecInfo->SubbandInfoPS);

	SAFE_FREE(mp3DecInfo);
#endif
}
 801017c:	f107 070c 	add.w	r7, r7, #12
 8010180:	46bd      	mov	sp, r7
 8010182:	bc80      	pop	{r7}
 8010184:	4770      	bx	lr
 8010186:	bf00      	nop

08010188 <MULSHIFT32>:


#if defined(__GNUC__) && defined(__arm__)

static __inline__ int MULSHIFT32(int x, int y)
{
 8010188:	b490      	push	{r4, r7}
 801018a:	b084      	sub	sp, #16
 801018c:	af00      	add	r7, sp, #0
 801018e:	6078      	str	r0, [r7, #4]
 8010190:	6039      	str	r1, [r7, #0]
int zlow;
__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 8010192:	687a      	ldr	r2, [r7, #4]
 8010194:	683b      	ldr	r3, [r7, #0]
 8010196:	fb82 4303 	smull	r4, r3, r2, r3
 801019a:	60fc      	str	r4, [r7, #12]
 801019c:	603b      	str	r3, [r7, #0]
return y;
 801019e:	683b      	ldr	r3, [r7, #0]
}
 80101a0:	4618      	mov	r0, r3
 80101a2:	f107 0710 	add.w	r7, r7, #16
 80101a6:	46bd      	mov	sp, r7
 80101a8:	bc90      	pop	{r4, r7}
 80101aa:	4770      	bx	lr

080101ac <xmp3_FDCT32>:
 * TODO:        code organization and optimization for ARM
 *              possibly interleave stereo (cut # of coef loads in half - may not have
 *                enough registers)
 **************************************************************************************/
void FDCT32(int *buf, int *dest, int offset, int oddBlock, int gb)
{
 80101ac:	b590      	push	{r4, r7, lr}
 80101ae:	b09f      	sub	sp, #124	; 0x7c
 80101b0:	af00      	add	r7, sp, #0
 80101b2:	60f8      	str	r0, [r7, #12]
 80101b4:	60b9      	str	r1, [r7, #8]
 80101b6:	607a      	str	r2, [r7, #4]
 80101b8:	603b      	str	r3, [r7, #0]
    int i, s, tmp, es;
    const int *cptr = dcttab;
 80101ba:	f64b 4370 	movw	r3, #48240	; 0xbc70
 80101be:	f6c0 0302 	movt	r3, #2050	; 0x802
 80101c2:	66bb      	str	r3, [r7, #104]	; 0x68

	/* scaling - ensure at least 6 guard bits for DCT 
	 * (in practice this is already true 99% of time, so this code is
	 *  almost never triggered)
	 */
	es = 0;
 80101c4:	f04f 0300 	mov.w	r3, #0
 80101c8:	66fb      	str	r3, [r7, #108]	; 0x6c
	if (gb < 6) {
 80101ca:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80101ce:	2b05      	cmp	r3, #5
 80101d0:	dc1e      	bgt.n	8010210 <xmp3_FDCT32+0x64>
		es = 6 - gb;
 80101d2:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80101d6:	f1c3 0306 	rsb	r3, r3, #6
 80101da:	66fb      	str	r3, [r7, #108]	; 0x6c
		for (i = 0; i < 32; i++)
 80101dc:	f04f 0300 	mov.w	r3, #0
 80101e0:	677b      	str	r3, [r7, #116]	; 0x74
 80101e2:	e012      	b.n	801020a <xmp3_FDCT32+0x5e>
			buf[i] >>= es;
 80101e4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80101e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80101ea:	68fa      	ldr	r2, [r7, #12]
 80101ec:	18d3      	adds	r3, r2, r3
 80101ee:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80101f0:	ea4f 0282 	mov.w	r2, r2, lsl #2
 80101f4:	68f9      	ldr	r1, [r7, #12]
 80101f6:	188a      	adds	r2, r1, r2
 80101f8:	6811      	ldr	r1, [r2, #0]
 80101fa:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80101fc:	fa41 f202 	asr.w	r2, r1, r2
 8010200:	601a      	str	r2, [r3, #0]
	 *  almost never triggered)
	 */
	es = 0;
	if (gb < 6) {
		es = 6 - gb;
		for (i = 0; i < 32; i++)
 8010202:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8010204:	f103 0301 	add.w	r3, r3, #1
 8010208:	677b      	str	r3, [r7, #116]	; 0x74
 801020a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801020c:	2b1f      	cmp	r3, #31
 801020e:	dde9      	ble.n	80101e4 <xmp3_FDCT32+0x38>
			buf[i] >>= es;
	}

	/* first pass */    
	D32FP(0, 1, 5, 1);
 8010210:	68fb      	ldr	r3, [r7, #12]
 8010212:	681b      	ldr	r3, [r3, #0]
 8010214:	663b      	str	r3, [r7, #96]	; 0x60
 8010216:	68fb      	ldr	r3, [r7, #12]
 8010218:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 801021a:	65fb      	str	r3, [r7, #92]	; 0x5c
 801021c:	68fb      	ldr	r3, [r7, #12]
 801021e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010220:	65bb      	str	r3, [r7, #88]	; 0x58
 8010222:	68fb      	ldr	r3, [r7, #12]
 8010224:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010226:	657b      	str	r3, [r7, #84]	; 0x54
 8010228:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801022a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801022c:	18d3      	adds	r3, r2, r3
 801022e:	653b      	str	r3, [r7, #80]	; 0x50
 8010230:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010232:	681a      	ldr	r2, [r3, #0]
 8010234:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010236:	f103 0304 	add.w	r3, r3, #4
 801023a:	66bb      	str	r3, [r7, #104]	; 0x68
 801023c:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801023e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010240:	1acb      	subs	r3, r1, r3
 8010242:	4610      	mov	r0, r2
 8010244:	4619      	mov	r1, r3
 8010246:	f7ff ff9f 	bl	8010188 <MULSHIFT32>
 801024a:	4603      	mov	r3, r0
 801024c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010250:	64fb      	str	r3, [r7, #76]	; 0x4c
 8010252:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010254:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010256:	18d3      	adds	r3, r2, r3
 8010258:	64bb      	str	r3, [r7, #72]	; 0x48
 801025a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801025c:	681a      	ldr	r2, [r3, #0]
 801025e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010260:	f103 0304 	add.w	r3, r3, #4
 8010264:	66bb      	str	r3, [r7, #104]	; 0x68
 8010266:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8010268:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801026a:	1acb      	subs	r3, r1, r3
 801026c:	4610      	mov	r0, r2
 801026e:	4619      	mov	r1, r3
 8010270:	f7ff ff8a 	bl	8010188 <MULSHIFT32>
 8010274:	4603      	mov	r3, r0
 8010276:	ea4f 1343 	mov.w	r3, r3, lsl #5
 801027a:	647b      	str	r3, [r7, #68]	; 0x44
 801027c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801027e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010280:	18d2      	adds	r2, r2, r3
 8010282:	68fb      	ldr	r3, [r7, #12]
 8010284:	601a      	str	r2, [r3, #0]
 8010286:	68fb      	ldr	r3, [r7, #12]
 8010288:	f103 043c 	add.w	r4, r3, #60	; 0x3c
 801028c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801028e:	681a      	ldr	r2, [r3, #0]
 8010290:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010292:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010294:	1acb      	subs	r3, r1, r3
 8010296:	4610      	mov	r0, r2
 8010298:	4619      	mov	r1, r3
 801029a:	f7ff ff75 	bl	8010188 <MULSHIFT32>
 801029e:	4603      	mov	r3, r0
 80102a0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80102a4:	6023      	str	r3, [r4, #0]
 80102a6:	68fb      	ldr	r3, [r7, #12]
 80102a8:	f103 0340 	add.w	r3, r3, #64	; 0x40
 80102ac:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80102ae:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80102b0:	188a      	adds	r2, r1, r2
 80102b2:	601a      	str	r2, [r3, #0]
 80102b4:	68fb      	ldr	r3, [r7, #12]
 80102b6:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 80102ba:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80102bc:	681a      	ldr	r2, [r3, #0]
 80102be:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80102c0:	f103 0304 	add.w	r3, r3, #4
 80102c4:	66bb      	str	r3, [r7, #104]	; 0x68
 80102c6:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80102c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80102ca:	1acb      	subs	r3, r1, r3
 80102cc:	4610      	mov	r0, r2
 80102ce:	4619      	mov	r1, r3
 80102d0:	f7ff ff5a 	bl	8010188 <MULSHIFT32>
 80102d4:	4603      	mov	r3, r0
 80102d6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80102da:	6023      	str	r3, [r4, #0]
	D32FP(1, 1, 3, 1);
 80102dc:	68fb      	ldr	r3, [r7, #12]
 80102de:	685b      	ldr	r3, [r3, #4]
 80102e0:	663b      	str	r3, [r7, #96]	; 0x60
 80102e2:	68fb      	ldr	r3, [r7, #12]
 80102e4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80102e6:	65fb      	str	r3, [r7, #92]	; 0x5c
 80102e8:	68fb      	ldr	r3, [r7, #12]
 80102ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80102ec:	65bb      	str	r3, [r7, #88]	; 0x58
 80102ee:	68fb      	ldr	r3, [r7, #12]
 80102f0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80102f2:	657b      	str	r3, [r7, #84]	; 0x54
 80102f4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80102f6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80102f8:	18d3      	adds	r3, r2, r3
 80102fa:	653b      	str	r3, [r7, #80]	; 0x50
 80102fc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80102fe:	681a      	ldr	r2, [r3, #0]
 8010300:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010302:	f103 0304 	add.w	r3, r3, #4
 8010306:	66bb      	str	r3, [r7, #104]	; 0x68
 8010308:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801030a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801030c:	1acb      	subs	r3, r1, r3
 801030e:	4610      	mov	r0, r2
 8010310:	4619      	mov	r1, r3
 8010312:	f7ff ff39 	bl	8010188 <MULSHIFT32>
 8010316:	4603      	mov	r3, r0
 8010318:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801031c:	64fb      	str	r3, [r7, #76]	; 0x4c
 801031e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010320:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010322:	18d3      	adds	r3, r2, r3
 8010324:	64bb      	str	r3, [r7, #72]	; 0x48
 8010326:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010328:	681a      	ldr	r2, [r3, #0]
 801032a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801032c:	f103 0304 	add.w	r3, r3, #4
 8010330:	66bb      	str	r3, [r7, #104]	; 0x68
 8010332:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8010334:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010336:	1acb      	subs	r3, r1, r3
 8010338:	4610      	mov	r0, r2
 801033a:	4619      	mov	r1, r3
 801033c:	f7ff ff24 	bl	8010188 <MULSHIFT32>
 8010340:	4603      	mov	r3, r0
 8010342:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8010346:	647b      	str	r3, [r7, #68]	; 0x44
 8010348:	68fb      	ldr	r3, [r7, #12]
 801034a:	f103 0304 	add.w	r3, r3, #4
 801034e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010350:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8010352:	188a      	adds	r2, r1, r2
 8010354:	601a      	str	r2, [r3, #0]
 8010356:	68fb      	ldr	r3, [r7, #12]
 8010358:	f103 0438 	add.w	r4, r3, #56	; 0x38
 801035c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801035e:	681a      	ldr	r2, [r3, #0]
 8010360:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010362:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010364:	1acb      	subs	r3, r1, r3
 8010366:	4610      	mov	r0, r2
 8010368:	4619      	mov	r1, r3
 801036a:	f7ff ff0d 	bl	8010188 <MULSHIFT32>
 801036e:	4603      	mov	r3, r0
 8010370:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010374:	6023      	str	r3, [r4, #0]
 8010376:	68fb      	ldr	r3, [r7, #12]
 8010378:	f103 0344 	add.w	r3, r3, #68	; 0x44
 801037c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801037e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010380:	188a      	adds	r2, r1, r2
 8010382:	601a      	str	r2, [r3, #0]
 8010384:	68fb      	ldr	r3, [r7, #12]
 8010386:	f103 0478 	add.w	r4, r3, #120	; 0x78
 801038a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801038c:	681a      	ldr	r2, [r3, #0]
 801038e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010390:	f103 0304 	add.w	r3, r3, #4
 8010394:	66bb      	str	r3, [r7, #104]	; 0x68
 8010396:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8010398:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801039a:	1acb      	subs	r3, r1, r3
 801039c:	4610      	mov	r0, r2
 801039e:	4619      	mov	r1, r3
 80103a0:	f7ff fef2 	bl	8010188 <MULSHIFT32>
 80103a4:	4603      	mov	r3, r0
 80103a6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80103aa:	6023      	str	r3, [r4, #0]
	D32FP(2, 1, 3, 1);
 80103ac:	68fb      	ldr	r3, [r7, #12]
 80103ae:	689b      	ldr	r3, [r3, #8]
 80103b0:	663b      	str	r3, [r7, #96]	; 0x60
 80103b2:	68fb      	ldr	r3, [r7, #12]
 80103b4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80103b6:	65fb      	str	r3, [r7, #92]	; 0x5c
 80103b8:	68fb      	ldr	r3, [r7, #12]
 80103ba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80103bc:	65bb      	str	r3, [r7, #88]	; 0x58
 80103be:	68fb      	ldr	r3, [r7, #12]
 80103c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80103c2:	657b      	str	r3, [r7, #84]	; 0x54
 80103c4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80103c6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80103c8:	18d3      	adds	r3, r2, r3
 80103ca:	653b      	str	r3, [r7, #80]	; 0x50
 80103cc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80103ce:	681a      	ldr	r2, [r3, #0]
 80103d0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80103d2:	f103 0304 	add.w	r3, r3, #4
 80103d6:	66bb      	str	r3, [r7, #104]	; 0x68
 80103d8:	6e39      	ldr	r1, [r7, #96]	; 0x60
 80103da:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80103dc:	1acb      	subs	r3, r1, r3
 80103de:	4610      	mov	r0, r2
 80103e0:	4619      	mov	r1, r3
 80103e2:	f7ff fed1 	bl	8010188 <MULSHIFT32>
 80103e6:	4603      	mov	r3, r0
 80103e8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80103ec:	64fb      	str	r3, [r7, #76]	; 0x4c
 80103ee:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80103f0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80103f2:	18d3      	adds	r3, r2, r3
 80103f4:	64bb      	str	r3, [r7, #72]	; 0x48
 80103f6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80103f8:	681a      	ldr	r2, [r3, #0]
 80103fa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80103fc:	f103 0304 	add.w	r3, r3, #4
 8010400:	66bb      	str	r3, [r7, #104]	; 0x68
 8010402:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8010404:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010406:	1acb      	subs	r3, r1, r3
 8010408:	4610      	mov	r0, r2
 801040a:	4619      	mov	r1, r3
 801040c:	f7ff febc 	bl	8010188 <MULSHIFT32>
 8010410:	4603      	mov	r3, r0
 8010412:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8010416:	647b      	str	r3, [r7, #68]	; 0x44
 8010418:	68fb      	ldr	r3, [r7, #12]
 801041a:	f103 0308 	add.w	r3, r3, #8
 801041e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010420:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8010422:	188a      	adds	r2, r1, r2
 8010424:	601a      	str	r2, [r3, #0]
 8010426:	68fb      	ldr	r3, [r7, #12]
 8010428:	f103 0434 	add.w	r4, r3, #52	; 0x34
 801042c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801042e:	681a      	ldr	r2, [r3, #0]
 8010430:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010432:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010434:	1acb      	subs	r3, r1, r3
 8010436:	4610      	mov	r0, r2
 8010438:	4619      	mov	r1, r3
 801043a:	f7ff fea5 	bl	8010188 <MULSHIFT32>
 801043e:	4603      	mov	r3, r0
 8010440:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010444:	6023      	str	r3, [r4, #0]
 8010446:	68fb      	ldr	r3, [r7, #12]
 8010448:	f103 0348 	add.w	r3, r3, #72	; 0x48
 801044c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801044e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010450:	188a      	adds	r2, r1, r2
 8010452:	601a      	str	r2, [r3, #0]
 8010454:	68fb      	ldr	r3, [r7, #12]
 8010456:	f103 0474 	add.w	r4, r3, #116	; 0x74
 801045a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801045c:	681a      	ldr	r2, [r3, #0]
 801045e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010460:	f103 0304 	add.w	r3, r3, #4
 8010464:	66bb      	str	r3, [r7, #104]	; 0x68
 8010466:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8010468:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801046a:	1acb      	subs	r3, r1, r3
 801046c:	4610      	mov	r0, r2
 801046e:	4619      	mov	r1, r3
 8010470:	f7ff fe8a 	bl	8010188 <MULSHIFT32>
 8010474:	4603      	mov	r3, r0
 8010476:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801047a:	6023      	str	r3, [r4, #0]
	D32FP(3, 1, 2, 1);
 801047c:	68fb      	ldr	r3, [r7, #12]
 801047e:	68db      	ldr	r3, [r3, #12]
 8010480:	663b      	str	r3, [r7, #96]	; 0x60
 8010482:	68fb      	ldr	r3, [r7, #12]
 8010484:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010486:	65fb      	str	r3, [r7, #92]	; 0x5c
 8010488:	68fb      	ldr	r3, [r7, #12]
 801048a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801048c:	65bb      	str	r3, [r7, #88]	; 0x58
 801048e:	68fb      	ldr	r3, [r7, #12]
 8010490:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010492:	657b      	str	r3, [r7, #84]	; 0x54
 8010494:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8010496:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010498:	18d3      	adds	r3, r2, r3
 801049a:	653b      	str	r3, [r7, #80]	; 0x50
 801049c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801049e:	681a      	ldr	r2, [r3, #0]
 80104a0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80104a2:	f103 0304 	add.w	r3, r3, #4
 80104a6:	66bb      	str	r3, [r7, #104]	; 0x68
 80104a8:	6e39      	ldr	r1, [r7, #96]	; 0x60
 80104aa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80104ac:	1acb      	subs	r3, r1, r3
 80104ae:	4610      	mov	r0, r2
 80104b0:	4619      	mov	r1, r3
 80104b2:	f7ff fe69 	bl	8010188 <MULSHIFT32>
 80104b6:	4603      	mov	r3, r0
 80104b8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80104bc:	64fb      	str	r3, [r7, #76]	; 0x4c
 80104be:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80104c0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80104c2:	18d3      	adds	r3, r2, r3
 80104c4:	64bb      	str	r3, [r7, #72]	; 0x48
 80104c6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80104c8:	681a      	ldr	r2, [r3, #0]
 80104ca:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80104cc:	f103 0304 	add.w	r3, r3, #4
 80104d0:	66bb      	str	r3, [r7, #104]	; 0x68
 80104d2:	6db9      	ldr	r1, [r7, #88]	; 0x58
 80104d4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80104d6:	1acb      	subs	r3, r1, r3
 80104d8:	4610      	mov	r0, r2
 80104da:	4619      	mov	r1, r3
 80104dc:	f7ff fe54 	bl	8010188 <MULSHIFT32>
 80104e0:	4603      	mov	r3, r0
 80104e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80104e6:	647b      	str	r3, [r7, #68]	; 0x44
 80104e8:	68fb      	ldr	r3, [r7, #12]
 80104ea:	f103 030c 	add.w	r3, r3, #12
 80104ee:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80104f0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80104f2:	188a      	adds	r2, r1, r2
 80104f4:	601a      	str	r2, [r3, #0]
 80104f6:	68fb      	ldr	r3, [r7, #12]
 80104f8:	f103 0430 	add.w	r4, r3, #48	; 0x30
 80104fc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80104fe:	681a      	ldr	r2, [r3, #0]
 8010500:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010502:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010504:	1acb      	subs	r3, r1, r3
 8010506:	4610      	mov	r0, r2
 8010508:	4619      	mov	r1, r3
 801050a:	f7ff fe3d 	bl	8010188 <MULSHIFT32>
 801050e:	4603      	mov	r3, r0
 8010510:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010514:	6023      	str	r3, [r4, #0]
 8010516:	68fb      	ldr	r3, [r7, #12]
 8010518:	f103 034c 	add.w	r3, r3, #76	; 0x4c
 801051c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801051e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010520:	188a      	adds	r2, r1, r2
 8010522:	601a      	str	r2, [r3, #0]
 8010524:	68fb      	ldr	r3, [r7, #12]
 8010526:	f103 0470 	add.w	r4, r3, #112	; 0x70
 801052a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801052c:	681a      	ldr	r2, [r3, #0]
 801052e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010530:	f103 0304 	add.w	r3, r3, #4
 8010534:	66bb      	str	r3, [r7, #104]	; 0x68
 8010536:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8010538:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801053a:	1acb      	subs	r3, r1, r3
 801053c:	4610      	mov	r0, r2
 801053e:	4619      	mov	r1, r3
 8010540:	f7ff fe22 	bl	8010188 <MULSHIFT32>
 8010544:	4603      	mov	r3, r0
 8010546:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801054a:	6023      	str	r3, [r4, #0]
	D32FP(4, 1, 2, 1);
 801054c:	68fb      	ldr	r3, [r7, #12]
 801054e:	691b      	ldr	r3, [r3, #16]
 8010550:	663b      	str	r3, [r7, #96]	; 0x60
 8010552:	68fb      	ldr	r3, [r7, #12]
 8010554:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8010556:	65fb      	str	r3, [r7, #92]	; 0x5c
 8010558:	68fb      	ldr	r3, [r7, #12]
 801055a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801055c:	65bb      	str	r3, [r7, #88]	; 0x58
 801055e:	68fb      	ldr	r3, [r7, #12]
 8010560:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8010562:	657b      	str	r3, [r7, #84]	; 0x54
 8010564:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8010566:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010568:	18d3      	adds	r3, r2, r3
 801056a:	653b      	str	r3, [r7, #80]	; 0x50
 801056c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801056e:	681a      	ldr	r2, [r3, #0]
 8010570:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010572:	f103 0304 	add.w	r3, r3, #4
 8010576:	66bb      	str	r3, [r7, #104]	; 0x68
 8010578:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801057a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801057c:	1acb      	subs	r3, r1, r3
 801057e:	4610      	mov	r0, r2
 8010580:	4619      	mov	r1, r3
 8010582:	f7ff fe01 	bl	8010188 <MULSHIFT32>
 8010586:	4603      	mov	r3, r0
 8010588:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801058c:	64fb      	str	r3, [r7, #76]	; 0x4c
 801058e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010590:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010592:	18d3      	adds	r3, r2, r3
 8010594:	64bb      	str	r3, [r7, #72]	; 0x48
 8010596:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010598:	681a      	ldr	r2, [r3, #0]
 801059a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801059c:	f103 0304 	add.w	r3, r3, #4
 80105a0:	66bb      	str	r3, [r7, #104]	; 0x68
 80105a2:	6db9      	ldr	r1, [r7, #88]	; 0x58
 80105a4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80105a6:	1acb      	subs	r3, r1, r3
 80105a8:	4610      	mov	r0, r2
 80105aa:	4619      	mov	r1, r3
 80105ac:	f7ff fdec 	bl	8010188 <MULSHIFT32>
 80105b0:	4603      	mov	r3, r0
 80105b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80105b6:	647b      	str	r3, [r7, #68]	; 0x44
 80105b8:	68fb      	ldr	r3, [r7, #12]
 80105ba:	f103 0310 	add.w	r3, r3, #16
 80105be:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80105c0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80105c2:	188a      	adds	r2, r1, r2
 80105c4:	601a      	str	r2, [r3, #0]
 80105c6:	68fb      	ldr	r3, [r7, #12]
 80105c8:	f103 042c 	add.w	r4, r3, #44	; 0x2c
 80105cc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80105ce:	681a      	ldr	r2, [r3, #0]
 80105d0:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80105d2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105d4:	1acb      	subs	r3, r1, r3
 80105d6:	4610      	mov	r0, r2
 80105d8:	4619      	mov	r1, r3
 80105da:	f7ff fdd5 	bl	8010188 <MULSHIFT32>
 80105de:	4603      	mov	r3, r0
 80105e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80105e4:	6023      	str	r3, [r4, #0]
 80105e6:	68fb      	ldr	r3, [r7, #12]
 80105e8:	f103 0350 	add.w	r3, r3, #80	; 0x50
 80105ec:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80105ee:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80105f0:	188a      	adds	r2, r1, r2
 80105f2:	601a      	str	r2, [r3, #0]
 80105f4:	68fb      	ldr	r3, [r7, #12]
 80105f6:	f103 046c 	add.w	r4, r3, #108	; 0x6c
 80105fa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80105fc:	681a      	ldr	r2, [r3, #0]
 80105fe:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010600:	f103 0304 	add.w	r3, r3, #4
 8010604:	66bb      	str	r3, [r7, #104]	; 0x68
 8010606:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8010608:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801060a:	1acb      	subs	r3, r1, r3
 801060c:	4610      	mov	r0, r2
 801060e:	4619      	mov	r1, r3
 8010610:	f7ff fdba 	bl	8010188 <MULSHIFT32>
 8010614:	4603      	mov	r3, r0
 8010616:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801061a:	6023      	str	r3, [r4, #0]
	D32FP(5, 1, 1, 2);
 801061c:	68fb      	ldr	r3, [r7, #12]
 801061e:	695b      	ldr	r3, [r3, #20]
 8010620:	663b      	str	r3, [r7, #96]	; 0x60
 8010622:	68fb      	ldr	r3, [r7, #12]
 8010624:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8010626:	65fb      	str	r3, [r7, #92]	; 0x5c
 8010628:	68fb      	ldr	r3, [r7, #12]
 801062a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801062c:	65bb      	str	r3, [r7, #88]	; 0x58
 801062e:	68fb      	ldr	r3, [r7, #12]
 8010630:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010632:	657b      	str	r3, [r7, #84]	; 0x54
 8010634:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8010636:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010638:	18d3      	adds	r3, r2, r3
 801063a:	653b      	str	r3, [r7, #80]	; 0x50
 801063c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801063e:	681a      	ldr	r2, [r3, #0]
 8010640:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010642:	f103 0304 	add.w	r3, r3, #4
 8010646:	66bb      	str	r3, [r7, #104]	; 0x68
 8010648:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801064a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801064c:	1acb      	subs	r3, r1, r3
 801064e:	4610      	mov	r0, r2
 8010650:	4619      	mov	r1, r3
 8010652:	f7ff fd99 	bl	8010188 <MULSHIFT32>
 8010656:	4603      	mov	r3, r0
 8010658:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801065c:	64fb      	str	r3, [r7, #76]	; 0x4c
 801065e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010660:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010662:	18d3      	adds	r3, r2, r3
 8010664:	64bb      	str	r3, [r7, #72]	; 0x48
 8010666:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010668:	681a      	ldr	r2, [r3, #0]
 801066a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801066c:	f103 0304 	add.w	r3, r3, #4
 8010670:	66bb      	str	r3, [r7, #104]	; 0x68
 8010672:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8010674:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010676:	1acb      	subs	r3, r1, r3
 8010678:	4610      	mov	r0, r2
 801067a:	4619      	mov	r1, r3
 801067c:	f7ff fd84 	bl	8010188 <MULSHIFT32>
 8010680:	4603      	mov	r3, r0
 8010682:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010686:	647b      	str	r3, [r7, #68]	; 0x44
 8010688:	68fb      	ldr	r3, [r7, #12]
 801068a:	f103 0314 	add.w	r3, r3, #20
 801068e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010690:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8010692:	188a      	adds	r2, r1, r2
 8010694:	601a      	str	r2, [r3, #0]
 8010696:	68fb      	ldr	r3, [r7, #12]
 8010698:	f103 0428 	add.w	r4, r3, #40	; 0x28
 801069c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801069e:	681a      	ldr	r2, [r3, #0]
 80106a0:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80106a2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80106a4:	1acb      	subs	r3, r1, r3
 80106a6:	4610      	mov	r0, r2
 80106a8:	4619      	mov	r1, r3
 80106aa:	f7ff fd6d 	bl	8010188 <MULSHIFT32>
 80106ae:	4603      	mov	r3, r0
 80106b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80106b4:	6023      	str	r3, [r4, #0]
 80106b6:	68fb      	ldr	r3, [r7, #12]
 80106b8:	f103 0354 	add.w	r3, r3, #84	; 0x54
 80106bc:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80106be:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80106c0:	188a      	adds	r2, r1, r2
 80106c2:	601a      	str	r2, [r3, #0]
 80106c4:	68fb      	ldr	r3, [r7, #12]
 80106c6:	f103 0468 	add.w	r4, r3, #104	; 0x68
 80106ca:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80106cc:	681a      	ldr	r2, [r3, #0]
 80106ce:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80106d0:	f103 0304 	add.w	r3, r3, #4
 80106d4:	66bb      	str	r3, [r7, #104]	; 0x68
 80106d6:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80106d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80106da:	1acb      	subs	r3, r1, r3
 80106dc:	4610      	mov	r0, r2
 80106de:	4619      	mov	r1, r3
 80106e0:	f7ff fd52 	bl	8010188 <MULSHIFT32>
 80106e4:	4603      	mov	r3, r0
 80106e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80106ea:	6023      	str	r3, [r4, #0]
	D32FP(6, 1, 1, 2);
 80106ec:	68fb      	ldr	r3, [r7, #12]
 80106ee:	699b      	ldr	r3, [r3, #24]
 80106f0:	663b      	str	r3, [r7, #96]	; 0x60
 80106f2:	68fb      	ldr	r3, [r7, #12]
 80106f4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80106f6:	65fb      	str	r3, [r7, #92]	; 0x5c
 80106f8:	68fb      	ldr	r3, [r7, #12]
 80106fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80106fc:	65bb      	str	r3, [r7, #88]	; 0x58
 80106fe:	68fb      	ldr	r3, [r7, #12]
 8010700:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010702:	657b      	str	r3, [r7, #84]	; 0x54
 8010704:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8010706:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010708:	18d3      	adds	r3, r2, r3
 801070a:	653b      	str	r3, [r7, #80]	; 0x50
 801070c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801070e:	681a      	ldr	r2, [r3, #0]
 8010710:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010712:	f103 0304 	add.w	r3, r3, #4
 8010716:	66bb      	str	r3, [r7, #104]	; 0x68
 8010718:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801071a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801071c:	1acb      	subs	r3, r1, r3
 801071e:	4610      	mov	r0, r2
 8010720:	4619      	mov	r1, r3
 8010722:	f7ff fd31 	bl	8010188 <MULSHIFT32>
 8010726:	4603      	mov	r3, r0
 8010728:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801072c:	64fb      	str	r3, [r7, #76]	; 0x4c
 801072e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010730:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010732:	18d3      	adds	r3, r2, r3
 8010734:	64bb      	str	r3, [r7, #72]	; 0x48
 8010736:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010738:	681a      	ldr	r2, [r3, #0]
 801073a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801073c:	f103 0304 	add.w	r3, r3, #4
 8010740:	66bb      	str	r3, [r7, #104]	; 0x68
 8010742:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8010744:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010746:	1acb      	subs	r3, r1, r3
 8010748:	4610      	mov	r0, r2
 801074a:	4619      	mov	r1, r3
 801074c:	f7ff fd1c 	bl	8010188 <MULSHIFT32>
 8010750:	4603      	mov	r3, r0
 8010752:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010756:	647b      	str	r3, [r7, #68]	; 0x44
 8010758:	68fb      	ldr	r3, [r7, #12]
 801075a:	f103 0318 	add.w	r3, r3, #24
 801075e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010760:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8010762:	188a      	adds	r2, r1, r2
 8010764:	601a      	str	r2, [r3, #0]
 8010766:	68fb      	ldr	r3, [r7, #12]
 8010768:	f103 0424 	add.w	r4, r3, #36	; 0x24
 801076c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801076e:	681a      	ldr	r2, [r3, #0]
 8010770:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010772:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010774:	1acb      	subs	r3, r1, r3
 8010776:	4610      	mov	r0, r2
 8010778:	4619      	mov	r1, r3
 801077a:	f7ff fd05 	bl	8010188 <MULSHIFT32>
 801077e:	4603      	mov	r3, r0
 8010780:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010784:	6023      	str	r3, [r4, #0]
 8010786:	68fb      	ldr	r3, [r7, #12]
 8010788:	f103 0358 	add.w	r3, r3, #88	; 0x58
 801078c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801078e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010790:	188a      	adds	r2, r1, r2
 8010792:	601a      	str	r2, [r3, #0]
 8010794:	68fb      	ldr	r3, [r7, #12]
 8010796:	f103 0464 	add.w	r4, r3, #100	; 0x64
 801079a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801079c:	681a      	ldr	r2, [r3, #0]
 801079e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80107a0:	f103 0304 	add.w	r3, r3, #4
 80107a4:	66bb      	str	r3, [r7, #104]	; 0x68
 80107a6:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80107a8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80107aa:	1acb      	subs	r3, r1, r3
 80107ac:	4610      	mov	r0, r2
 80107ae:	4619      	mov	r1, r3
 80107b0:	f7ff fcea 	bl	8010188 <MULSHIFT32>
 80107b4:	4603      	mov	r3, r0
 80107b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80107ba:	6023      	str	r3, [r4, #0]
	D32FP(7, 1, 1, 4);
 80107bc:	68fb      	ldr	r3, [r7, #12]
 80107be:	69db      	ldr	r3, [r3, #28]
 80107c0:	663b      	str	r3, [r7, #96]	; 0x60
 80107c2:	68fb      	ldr	r3, [r7, #12]
 80107c4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80107c6:	65fb      	str	r3, [r7, #92]	; 0x5c
 80107c8:	68fb      	ldr	r3, [r7, #12]
 80107ca:	6a1b      	ldr	r3, [r3, #32]
 80107cc:	65bb      	str	r3, [r7, #88]	; 0x58
 80107ce:	68fb      	ldr	r3, [r7, #12]
 80107d0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80107d2:	657b      	str	r3, [r7, #84]	; 0x54
 80107d4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80107d6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80107d8:	18d3      	adds	r3, r2, r3
 80107da:	653b      	str	r3, [r7, #80]	; 0x50
 80107dc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80107de:	681a      	ldr	r2, [r3, #0]
 80107e0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80107e2:	f103 0304 	add.w	r3, r3, #4
 80107e6:	66bb      	str	r3, [r7, #104]	; 0x68
 80107e8:	6e39      	ldr	r1, [r7, #96]	; 0x60
 80107ea:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80107ec:	1acb      	subs	r3, r1, r3
 80107ee:	4610      	mov	r0, r2
 80107f0:	4619      	mov	r1, r3
 80107f2:	f7ff fcc9 	bl	8010188 <MULSHIFT32>
 80107f6:	4603      	mov	r3, r0
 80107f8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80107fc:	64fb      	str	r3, [r7, #76]	; 0x4c
 80107fe:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010800:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010802:	18d3      	adds	r3, r2, r3
 8010804:	64bb      	str	r3, [r7, #72]	; 0x48
 8010806:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010808:	681a      	ldr	r2, [r3, #0]
 801080a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801080c:	f103 0304 	add.w	r3, r3, #4
 8010810:	66bb      	str	r3, [r7, #104]	; 0x68
 8010812:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8010814:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010816:	1acb      	subs	r3, r1, r3
 8010818:	4610      	mov	r0, r2
 801081a:	4619      	mov	r1, r3
 801081c:	f7ff fcb4 	bl	8010188 <MULSHIFT32>
 8010820:	4603      	mov	r3, r0
 8010822:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010826:	647b      	str	r3, [r7, #68]	; 0x44
 8010828:	68fb      	ldr	r3, [r7, #12]
 801082a:	f103 031c 	add.w	r3, r3, #28
 801082e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010830:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8010832:	188a      	adds	r2, r1, r2
 8010834:	601a      	str	r2, [r3, #0]
 8010836:	68fb      	ldr	r3, [r7, #12]
 8010838:	f103 0420 	add.w	r4, r3, #32
 801083c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801083e:	681a      	ldr	r2, [r3, #0]
 8010840:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8010842:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010844:	1acb      	subs	r3, r1, r3
 8010846:	4610      	mov	r0, r2
 8010848:	4619      	mov	r1, r3
 801084a:	f7ff fc9d 	bl	8010188 <MULSHIFT32>
 801084e:	4603      	mov	r3, r0
 8010850:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8010854:	6023      	str	r3, [r4, #0]
 8010856:	68fb      	ldr	r3, [r7, #12]
 8010858:	f103 035c 	add.w	r3, r3, #92	; 0x5c
 801085c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801085e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010860:	188a      	adds	r2, r1, r2
 8010862:	601a      	str	r2, [r3, #0]
 8010864:	68fb      	ldr	r3, [r7, #12]
 8010866:	f103 0460 	add.w	r4, r3, #96	; 0x60
 801086a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801086c:	681a      	ldr	r2, [r3, #0]
 801086e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010870:	f103 0304 	add.w	r3, r3, #4
 8010874:	66bb      	str	r3, [r7, #104]	; 0x68
 8010876:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8010878:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801087a:	1acb      	subs	r3, r1, r3
 801087c:	4610      	mov	r0, r2
 801087e:	4619      	mov	r1, r3
 8010880:	f7ff fc82 	bl	8010188 <MULSHIFT32>
 8010884:	4603      	mov	r3, r0
 8010886:	ea4f 1303 	mov.w	r3, r3, lsl #4
 801088a:	6023      	str	r3, [r4, #0]

	/* second pass */
	for (i = 4; i > 0; i--) {
 801088c:	f04f 0304 	mov.w	r3, #4
 8010890:	677b      	str	r3, [r7, #116]	; 0x74
 8010892:	e139      	b.n	8010b08 <xmp3_FDCT32+0x95c>
		a0 = buf[0]; 	    a7 = buf[7];		a3 = buf[3];	    a4 = buf[4];
 8010894:	68fb      	ldr	r3, [r7, #12]
 8010896:	681b      	ldr	r3, [r3, #0]
 8010898:	663b      	str	r3, [r7, #96]	; 0x60
 801089a:	68fb      	ldr	r3, [r7, #12]
 801089c:	69db      	ldr	r3, [r3, #28]
 801089e:	643b      	str	r3, [r7, #64]	; 0x40
 80108a0:	68fb      	ldr	r3, [r7, #12]
 80108a2:	68db      	ldr	r3, [r3, #12]
 80108a4:	65fb      	str	r3, [r7, #92]	; 0x5c
 80108a6:	68fb      	ldr	r3, [r7, #12]
 80108a8:	691b      	ldr	r3, [r3, #16]
 80108aa:	63fb      	str	r3, [r7, #60]	; 0x3c
		b0 = a0 + a7;	    b7 = MULSHIFT32(*cptr++, a0 - a7) << 1;
 80108ac:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80108ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80108b0:	18d3      	adds	r3, r2, r3
 80108b2:	653b      	str	r3, [r7, #80]	; 0x50
 80108b4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80108b6:	681a      	ldr	r2, [r3, #0]
 80108b8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80108ba:	f103 0304 	add.w	r3, r3, #4
 80108be:	66bb      	str	r3, [r7, #104]	; 0x68
 80108c0:	6e39      	ldr	r1, [r7, #96]	; 0x60
 80108c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80108c4:	1acb      	subs	r3, r1, r3
 80108c6:	4610      	mov	r0, r2
 80108c8:	4619      	mov	r1, r3
 80108ca:	f7ff fc5d 	bl	8010188 <MULSHIFT32>
 80108ce:	4603      	mov	r3, r0
 80108d0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80108d4:	63bb      	str	r3, [r7, #56]	; 0x38
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 80108d6:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80108d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80108da:	18d3      	adds	r3, r2, r3
 80108dc:	64fb      	str	r3, [r7, #76]	; 0x4c
 80108de:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80108e0:	681a      	ldr	r2, [r3, #0]
 80108e2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80108e4:	f103 0304 	add.w	r3, r3, #4
 80108e8:	66bb      	str	r3, [r7, #104]	; 0x68
 80108ea:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 80108ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80108ee:	1acb      	subs	r3, r1, r3
 80108f0:	4610      	mov	r0, r2
 80108f2:	4619      	mov	r1, r3
 80108f4:	f7ff fc48 	bl	8010188 <MULSHIFT32>
 80108f8:	4603      	mov	r3, r0
 80108fa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80108fe:	637b      	str	r3, [r7, #52]	; 0x34
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 8010900:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8010902:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010904:	18d3      	adds	r3, r2, r3
 8010906:	663b      	str	r3, [r7, #96]	; 0x60
 8010908:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801090a:	681a      	ldr	r2, [r3, #0]
 801090c:	6d39      	ldr	r1, [r7, #80]	; 0x50
 801090e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010910:	1acb      	subs	r3, r1, r3
 8010912:	4610      	mov	r0, r2
 8010914:	4619      	mov	r1, r3
 8010916:	f7ff fc37 	bl	8010188 <MULSHIFT32>
 801091a:	4603      	mov	r3, r0
 801091c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010920:	65fb      	str	r3, [r7, #92]	; 0x5c
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 8010922:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010924:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010926:	18d3      	adds	r3, r2, r3
 8010928:	63fb      	str	r3, [r7, #60]	; 0x3c
 801092a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801092c:	681a      	ldr	r2, [r3, #0]
 801092e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010930:	f103 0304 	add.w	r3, r3, #4
 8010934:	66bb      	str	r3, [r7, #104]	; 0x68
 8010936:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8010938:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801093a:	1acb      	subs	r3, r1, r3
 801093c:	4610      	mov	r0, r2
 801093e:	4619      	mov	r1, r3
 8010940:	f7ff fc22 	bl	8010188 <MULSHIFT32>
 8010944:	4603      	mov	r3, r0
 8010946:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801094a:	643b      	str	r3, [r7, #64]	; 0x40

		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 801094c:	68fb      	ldr	r3, [r7, #12]
 801094e:	685b      	ldr	r3, [r3, #4]
 8010950:	65bb      	str	r3, [r7, #88]	; 0x58
 8010952:	68fb      	ldr	r3, [r7, #12]
 8010954:	699b      	ldr	r3, [r3, #24]
 8010956:	633b      	str	r3, [r7, #48]	; 0x30
 8010958:	68fb      	ldr	r3, [r7, #12]
 801095a:	689b      	ldr	r3, [r3, #8]
 801095c:	657b      	str	r3, [r7, #84]	; 0x54
 801095e:	68fb      	ldr	r3, [r7, #12]
 8010960:	695b      	ldr	r3, [r3, #20]
 8010962:	62fb      	str	r3, [r7, #44]	; 0x2c
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 8010964:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010966:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010968:	18d3      	adds	r3, r2, r3
 801096a:	64bb      	str	r3, [r7, #72]	; 0x48
 801096c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801096e:	681a      	ldr	r2, [r3, #0]
 8010970:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010972:	f103 0304 	add.w	r3, r3, #4
 8010976:	66bb      	str	r3, [r7, #104]	; 0x68
 8010978:	6db9      	ldr	r1, [r7, #88]	; 0x58
 801097a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801097c:	1acb      	subs	r3, r1, r3
 801097e:	4610      	mov	r0, r2
 8010980:	4619      	mov	r1, r3
 8010982:	f7ff fc01 	bl	8010188 <MULSHIFT32>
 8010986:	4603      	mov	r3, r0
 8010988:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801098c:	62bb      	str	r3, [r7, #40]	; 0x28
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 801098e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8010990:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010992:	18d3      	adds	r3, r2, r3
 8010994:	647b      	str	r3, [r7, #68]	; 0x44
 8010996:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010998:	681a      	ldr	r2, [r3, #0]
 801099a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801099c:	f103 0304 	add.w	r3, r3, #4
 80109a0:	66bb      	str	r3, [r7, #104]	; 0x68
 80109a2:	6d79      	ldr	r1, [r7, #84]	; 0x54
 80109a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80109a6:	1acb      	subs	r3, r1, r3
 80109a8:	4610      	mov	r0, r2
 80109aa:	4619      	mov	r1, r3
 80109ac:	f7ff fbec 	bl	8010188 <MULSHIFT32>
 80109b0:	4603      	mov	r3, r0
 80109b2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80109b6:	627b      	str	r3, [r7, #36]	; 0x24
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 80109b8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80109ba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80109bc:	18d3      	adds	r3, r2, r3
 80109be:	65bb      	str	r3, [r7, #88]	; 0x58
 80109c0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80109c2:	681a      	ldr	r2, [r3, #0]
 80109c4:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 80109c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80109c8:	1acb      	subs	r3, r1, r3
 80109ca:	4610      	mov	r0, r2
 80109cc:	4619      	mov	r1, r3
 80109ce:	f7ff fbdb 	bl	8010188 <MULSHIFT32>
 80109d2:	4603      	mov	r3, r0
 80109d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80109d8:	657b      	str	r3, [r7, #84]	; 0x54
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 80109da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80109dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80109de:	18d3      	adds	r3, r2, r3
 80109e0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80109e2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80109e4:	681a      	ldr	r2, [r3, #0]
 80109e6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80109e8:	f103 0304 	add.w	r3, r3, #4
 80109ec:	66bb      	str	r3, [r7, #104]	; 0x68
 80109ee:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80109f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80109f2:	1acb      	subs	r3, r1, r3
 80109f4:	4610      	mov	r0, r2
 80109f6:	4619      	mov	r1, r3
 80109f8:	f7ff fbc6 	bl	8010188 <MULSHIFT32>
 80109fc:	4603      	mov	r3, r0
 80109fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010a02:	633b      	str	r3, [r7, #48]	; 0x30

		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 8010a04:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8010a06:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010a08:	18d3      	adds	r3, r2, r3
 8010a0a:	653b      	str	r3, [r7, #80]	; 0x50
 8010a0c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8010a0e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010a10:	1ad3      	subs	r3, r2, r3
 8010a12:	f647 109a 	movw	r0, #31130	; 0x799a
 8010a16:	f6c5 2082 	movt	r0, #23170	; 0x5a82
 8010a1a:	4619      	mov	r1, r3
 8010a1c:	f7ff fbb4 	bl	8010188 <MULSHIFT32>
 8010a20:	4603      	mov	r3, r0
 8010a22:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010a26:	64bb      	str	r3, [r7, #72]	; 0x48
		b2 = a2 + a3;	    b3 = MULSHIFT32(COS4_0, a3 - a2) << 1;
 8010a28:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8010a2a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010a2c:	18d3      	adds	r3, r2, r3
 8010a2e:	647b      	str	r3, [r7, #68]	; 0x44
 8010a30:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010a32:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010a34:	1ad3      	subs	r3, r2, r3
 8010a36:	f647 109a 	movw	r0, #31130	; 0x799a
 8010a3a:	f6c5 2082 	movt	r0, #23170	; 0x5a82
 8010a3e:	4619      	mov	r1, r3
 8010a40:	f7ff fba2 	bl	8010188 <MULSHIFT32>
 8010a44:	4603      	mov	r3, r0
 8010a46:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010a4a:	64fb      	str	r3, [r7, #76]	; 0x4c
		buf[0] = b0;	    buf[1] = b1;
 8010a4c:	68fb      	ldr	r3, [r7, #12]
 8010a4e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8010a50:	601a      	str	r2, [r3, #0]
 8010a52:	68fb      	ldr	r3, [r7, #12]
 8010a54:	f103 0304 	add.w	r3, r3, #4
 8010a58:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8010a5a:	601a      	str	r2, [r3, #0]
		buf[2] = b2 + b3;	buf[3] = b3;
 8010a5c:	68fb      	ldr	r3, [r7, #12]
 8010a5e:	f103 0308 	add.w	r3, r3, #8
 8010a62:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8010a64:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010a66:	188a      	adds	r2, r1, r2
 8010a68:	601a      	str	r2, [r3, #0]
 8010a6a:	68fb      	ldr	r3, [r7, #12]
 8010a6c:	f103 030c 	add.w	r3, r3, #12
 8010a70:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010a72:	601a      	str	r2, [r3, #0]

		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 8010a74:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010a76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010a78:	18d3      	adds	r3, r2, r3
 8010a7a:	637b      	str	r3, [r7, #52]	; 0x34
 8010a7c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010a7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010a80:	1ad3      	subs	r3, r2, r3
 8010a82:	f647 109a 	movw	r0, #31130	; 0x799a
 8010a86:	f6c5 2082 	movt	r0, #23170	; 0x5a82
 8010a8a:	4619      	mov	r1, r3
 8010a8c:	f7ff fb7c 	bl	8010188 <MULSHIFT32>
 8010a90:	4603      	mov	r3, r0
 8010a92:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010a96:	627b      	str	r3, [r7, #36]	; 0x24
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 8010a98:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010a9a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010a9c:	18d3      	adds	r3, r2, r3
 8010a9e:	62bb      	str	r3, [r7, #40]	; 0x28
 8010aa0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8010aa2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010aa4:	1ad3      	subs	r3, r2, r3
 8010aa6:	f647 109a 	movw	r0, #31130	; 0x799a
 8010aaa:	f6c5 2082 	movt	r0, #23170	; 0x5a82
 8010aae:	4619      	mov	r1, r3
 8010ab0:	f7ff fb6a 	bl	8010188 <MULSHIFT32>
 8010ab4:	4603      	mov	r3, r0
 8010ab6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010aba:	63bb      	str	r3, [r7, #56]	; 0x38
		b6 += b7;
 8010abc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010abe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010ac0:	18d3      	adds	r3, r2, r3
 8010ac2:	62bb      	str	r3, [r7, #40]	; 0x28
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 8010ac4:	68fb      	ldr	r3, [r7, #12]
 8010ac6:	f103 0310 	add.w	r3, r3, #16
 8010aca:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8010acc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010ace:	188a      	adds	r2, r1, r2
 8010ad0:	601a      	str	r2, [r3, #0]
 8010ad2:	68fb      	ldr	r3, [r7, #12]
 8010ad4:	f103 0314 	add.w	r3, r3, #20
 8010ad8:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8010ada:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8010adc:	188a      	adds	r2, r1, r2
 8010ade:	601a      	str	r2, [r3, #0]
		buf[6] = b5 + b6;	buf[7] = b7;
 8010ae0:	68fb      	ldr	r3, [r7, #12]
 8010ae2:	f103 0318 	add.w	r3, r3, #24
 8010ae6:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8010ae8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010aea:	188a      	adds	r2, r1, r2
 8010aec:	601a      	str	r2, [r3, #0]
 8010aee:	68fb      	ldr	r3, [r7, #12]
 8010af0:	f103 031c 	add.w	r3, r3, #28
 8010af4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8010af6:	601a      	str	r2, [r3, #0]

		buf += 8;
 8010af8:	68fb      	ldr	r3, [r7, #12]
 8010afa:	f103 0320 	add.w	r3, r3, #32
 8010afe:	60fb      	str	r3, [r7, #12]
	D32FP(5, 1, 1, 2);
	D32FP(6, 1, 1, 2);
	D32FP(7, 1, 1, 4);

	/* second pass */
	for (i = 4; i > 0; i--) {
 8010b00:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8010b02:	f103 33ff 	add.w	r3, r3, #4294967295
 8010b06:	677b      	str	r3, [r7, #116]	; 0x74
 8010b08:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8010b0a:	2b00      	cmp	r3, #0
 8010b0c:	f73f aec2 	bgt.w	8010894 <xmp3_FDCT32+0x6e8>
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
		buf[6] = b5 + b6;	buf[7] = b7;

		buf += 8;
	}
	buf -= 32;	/* reset */
 8010b10:	68fb      	ldr	r3, [r7, #12]
 8010b12:	f1a3 0380 	sub.w	r3, r3, #128	; 0x80
 8010b16:	60fb      	str	r3, [r7, #12]

	/* sample 0 - always delayed one block */
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 8010b18:	687a      	ldr	r2, [r7, #4]
 8010b1a:	683b      	ldr	r3, [r7, #0]
 8010b1c:	1ad3      	subs	r3, r2, r3
 8010b1e:	f003 0207 	and.w	r2, r3, #7
 8010b22:	683b      	ldr	r3, [r7, #0]
 8010b24:	2b00      	cmp	r3, #0
 8010b26:	d002      	beq.n	8010b2e <xmp3_FDCT32+0x982>
 8010b28:	f04f 0300 	mov.w	r3, #0
 8010b2c:	e001      	b.n	8010b32 <xmp3_FDCT32+0x986>
 8010b2e:	f44f 6388 	mov.w	r3, #1088	; 0x440
 8010b32:	18d3      	adds	r3, r2, r3
 8010b34:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010b38:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010b3c:	68ba      	ldr	r2, [r7, #8]
 8010b3e:	18d3      	adds	r3, r2, r3
 8010b40:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 0];				d[0] = d[8] = s;
 8010b42:	68fb      	ldr	r3, [r7, #12]
 8010b44:	681b      	ldr	r3, [r3, #0]
 8010b46:	673b      	str	r3, [r7, #112]	; 0x70
 8010b48:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010b4a:	f103 0320 	add.w	r3, r3, #32
 8010b4e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010b50:	601a      	str	r2, [r3, #0]
 8010b52:	681a      	ldr	r2, [r3, #0]
 8010b54:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010b56:	601a      	str	r2, [r3, #0]
    
	/* samples 16 to 31 */
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 8010b58:	683b      	ldr	r3, [r7, #0]
 8010b5a:	2b00      	cmp	r3, #0
 8010b5c:	d002      	beq.n	8010b64 <xmp3_FDCT32+0x9b8>
 8010b5e:	f44f 6388 	mov.w	r3, #1088	; 0x440
 8010b62:	e001      	b.n	8010b68 <xmp3_FDCT32+0x9bc>
 8010b64:	f04f 0300 	mov.w	r3, #0
 8010b68:	687a      	ldr	r2, [r7, #4]
 8010b6a:	189b      	adds	r3, r3, r2
 8010b6c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010b70:	68ba      	ldr	r2, [r7, #8]
 8010b72:	18d3      	adds	r3, r2, r3
 8010b74:	667b      	str	r3, [r7, #100]	; 0x64

	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 8010b76:	68fb      	ldr	r3, [r7, #12]
 8010b78:	685b      	ldr	r3, [r3, #4]
 8010b7a:	673b      	str	r3, [r7, #112]	; 0x70
 8010b7c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010b7e:	f103 0320 	add.w	r3, r3, #32
 8010b82:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010b84:	601a      	str	r2, [r3, #0]
 8010b86:	681a      	ldr	r2, [r3, #0]
 8010b88:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010b8a:	601a      	str	r2, [r3, #0]
 8010b8c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010b8e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010b92:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[25] + buf[29];
 8010b94:	68fb      	ldr	r3, [r7, #12]
 8010b96:	f103 0364 	add.w	r3, r3, #100	; 0x64
 8010b9a:	681a      	ldr	r2, [r3, #0]
 8010b9c:	68fb      	ldr	r3, [r7, #12]
 8010b9e:	f103 0374 	add.w	r3, r3, #116	; 0x74
 8010ba2:	681b      	ldr	r3, [r3, #0]
 8010ba4:	18d3      	adds	r3, r2, r3
 8010ba6:	623b      	str	r3, [r7, #32]
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 8010ba8:	68fb      	ldr	r3, [r7, #12]
 8010baa:	f103 0344 	add.w	r3, r3, #68	; 0x44
 8010bae:	681a      	ldr	r2, [r3, #0]
 8010bb0:	6a3b      	ldr	r3, [r7, #32]
 8010bb2:	18d3      	adds	r3, r2, r3
 8010bb4:	673b      	str	r3, [r7, #112]	; 0x70
 8010bb6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010bb8:	f103 0320 	add.w	r3, r3, #32
 8010bbc:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010bbe:	601a      	str	r2, [r3, #0]
 8010bc0:	681a      	ldr	r2, [r3, #0]
 8010bc2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010bc4:	601a      	str	r2, [r3, #0]
 8010bc6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010bc8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010bcc:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 9] + buf[13];		d[0] = d[8] = s;	d += 64;
 8010bce:	68fb      	ldr	r3, [r7, #12]
 8010bd0:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8010bd4:	681a      	ldr	r2, [r3, #0]
 8010bd6:	68fb      	ldr	r3, [r7, #12]
 8010bd8:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8010bdc:	681b      	ldr	r3, [r3, #0]
 8010bde:	18d3      	adds	r3, r2, r3
 8010be0:	673b      	str	r3, [r7, #112]	; 0x70
 8010be2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010be4:	f103 0320 	add.w	r3, r3, #32
 8010be8:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010bea:	601a      	str	r2, [r3, #0]
 8010bec:	681a      	ldr	r2, [r3, #0]
 8010bee:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010bf0:	601a      	str	r2, [r3, #0]
 8010bf2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010bf4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010bf8:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 8010bfa:	68fb      	ldr	r3, [r7, #12]
 8010bfc:	f103 0354 	add.w	r3, r3, #84	; 0x54
 8010c00:	681a      	ldr	r2, [r3, #0]
 8010c02:	6a3b      	ldr	r3, [r7, #32]
 8010c04:	18d3      	adds	r3, r2, r3
 8010c06:	673b      	str	r3, [r7, #112]	; 0x70
 8010c08:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c0a:	f103 0320 	add.w	r3, r3, #32
 8010c0e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010c10:	601a      	str	r2, [r3, #0]
 8010c12:	681a      	ldr	r2, [r3, #0]
 8010c14:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c16:	601a      	str	r2, [r3, #0]
 8010c18:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c1a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010c1e:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[29] + buf[27];
 8010c20:	68fb      	ldr	r3, [r7, #12]
 8010c22:	f103 0374 	add.w	r3, r3, #116	; 0x74
 8010c26:	681a      	ldr	r2, [r3, #0]
 8010c28:	68fb      	ldr	r3, [r7, #12]
 8010c2a:	f103 036c 	add.w	r3, r3, #108	; 0x6c
 8010c2e:	681b      	ldr	r3, [r3, #0]
 8010c30:	18d3      	adds	r3, r2, r3
 8010c32:	623b      	str	r3, [r7, #32]
	s = buf[ 5];				d[0] = d[8] = s;	d += 64;
 8010c34:	68fb      	ldr	r3, [r7, #12]
 8010c36:	695b      	ldr	r3, [r3, #20]
 8010c38:	673b      	str	r3, [r7, #112]	; 0x70
 8010c3a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c3c:	f103 0320 	add.w	r3, r3, #32
 8010c40:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010c42:	601a      	str	r2, [r3, #0]
 8010c44:	681a      	ldr	r2, [r3, #0]
 8010c46:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c48:	601a      	str	r2, [r3, #0]
 8010c4a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c4c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010c50:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 8010c52:	68fb      	ldr	r3, [r7, #12]
 8010c54:	f103 0354 	add.w	r3, r3, #84	; 0x54
 8010c58:	681a      	ldr	r2, [r3, #0]
 8010c5a:	6a3b      	ldr	r3, [r7, #32]
 8010c5c:	18d3      	adds	r3, r2, r3
 8010c5e:	673b      	str	r3, [r7, #112]	; 0x70
 8010c60:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c62:	f103 0320 	add.w	r3, r3, #32
 8010c66:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010c68:	601a      	str	r2, [r3, #0]
 8010c6a:	681a      	ldr	r2, [r3, #0]
 8010c6c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c6e:	601a      	str	r2, [r3, #0]
 8010c70:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c72:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010c76:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[13] + buf[11];		d[0] = d[8] = s;	d += 64;
 8010c78:	68fb      	ldr	r3, [r7, #12]
 8010c7a:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8010c7e:	681a      	ldr	r2, [r3, #0]
 8010c80:	68fb      	ldr	r3, [r7, #12]
 8010c82:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8010c86:	681b      	ldr	r3, [r3, #0]
 8010c88:	18d3      	adds	r3, r2, r3
 8010c8a:	673b      	str	r3, [r7, #112]	; 0x70
 8010c8c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c8e:	f103 0320 	add.w	r3, r3, #32
 8010c92:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010c94:	601a      	str	r2, [r3, #0]
 8010c96:	681a      	ldr	r2, [r3, #0]
 8010c98:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c9a:	601a      	str	r2, [r3, #0]
 8010c9c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010c9e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010ca2:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 8010ca4:	68fb      	ldr	r3, [r7, #12]
 8010ca6:	f103 034c 	add.w	r3, r3, #76	; 0x4c
 8010caa:	681a      	ldr	r2, [r3, #0]
 8010cac:	6a3b      	ldr	r3, [r7, #32]
 8010cae:	18d3      	adds	r3, r2, r3
 8010cb0:	673b      	str	r3, [r7, #112]	; 0x70
 8010cb2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010cb4:	f103 0320 	add.w	r3, r3, #32
 8010cb8:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010cba:	601a      	str	r2, [r3, #0]
 8010cbc:	681a      	ldr	r2, [r3, #0]
 8010cbe:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010cc0:	601a      	str	r2, [r3, #0]
 8010cc2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010cc4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010cc8:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[27] + buf[31];
 8010cca:	68fb      	ldr	r3, [r7, #12]
 8010ccc:	f103 036c 	add.w	r3, r3, #108	; 0x6c
 8010cd0:	681a      	ldr	r2, [r3, #0]
 8010cd2:	68fb      	ldr	r3, [r7, #12]
 8010cd4:	f103 037c 	add.w	r3, r3, #124	; 0x7c
 8010cd8:	681b      	ldr	r3, [r3, #0]
 8010cda:	18d3      	adds	r3, r2, r3
 8010cdc:	623b      	str	r3, [r7, #32]
	s = buf[ 3];				d[0] = d[8] = s;	d += 64;
 8010cde:	68fb      	ldr	r3, [r7, #12]
 8010ce0:	68db      	ldr	r3, [r3, #12]
 8010ce2:	673b      	str	r3, [r7, #112]	; 0x70
 8010ce4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010ce6:	f103 0320 	add.w	r3, r3, #32
 8010cea:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010cec:	601a      	str	r2, [r3, #0]
 8010cee:	681a      	ldr	r2, [r3, #0]
 8010cf0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010cf2:	601a      	str	r2, [r3, #0]
 8010cf4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010cf6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010cfa:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 8010cfc:	68fb      	ldr	r3, [r7, #12]
 8010cfe:	f103 034c 	add.w	r3, r3, #76	; 0x4c
 8010d02:	681a      	ldr	r2, [r3, #0]
 8010d04:	6a3b      	ldr	r3, [r7, #32]
 8010d06:	18d3      	adds	r3, r2, r3
 8010d08:	673b      	str	r3, [r7, #112]	; 0x70
 8010d0a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d0c:	f103 0320 	add.w	r3, r3, #32
 8010d10:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010d12:	601a      	str	r2, [r3, #0]
 8010d14:	681a      	ldr	r2, [r3, #0]
 8010d16:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d18:	601a      	str	r2, [r3, #0]
 8010d1a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d1c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010d20:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[11] + buf[15];		d[0] = d[8] = s;	d += 64;
 8010d22:	68fb      	ldr	r3, [r7, #12]
 8010d24:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8010d28:	681a      	ldr	r2, [r3, #0]
 8010d2a:	68fb      	ldr	r3, [r7, #12]
 8010d2c:	f103 033c 	add.w	r3, r3, #60	; 0x3c
 8010d30:	681b      	ldr	r3, [r3, #0]
 8010d32:	18d3      	adds	r3, r2, r3
 8010d34:	673b      	str	r3, [r7, #112]	; 0x70
 8010d36:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d38:	f103 0320 	add.w	r3, r3, #32
 8010d3c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010d3e:	601a      	str	r2, [r3, #0]
 8010d40:	681a      	ldr	r2, [r3, #0]
 8010d42:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d44:	601a      	str	r2, [r3, #0]
 8010d46:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d48:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010d4c:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 8010d4e:	68fb      	ldr	r3, [r7, #12]
 8010d50:	f103 035c 	add.w	r3, r3, #92	; 0x5c
 8010d54:	681a      	ldr	r2, [r3, #0]
 8010d56:	6a3b      	ldr	r3, [r7, #32]
 8010d58:	18d3      	adds	r3, r2, r3
 8010d5a:	673b      	str	r3, [r7, #112]	; 0x70
 8010d5c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d5e:	f103 0320 	add.w	r3, r3, #32
 8010d62:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010d64:	601a      	str	r2, [r3, #0]
 8010d66:	681a      	ldr	r2, [r3, #0]
 8010d68:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d6a:	601a      	str	r2, [r3, #0]
 8010d6c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d6e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010d72:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[31];
 8010d74:	68fb      	ldr	r3, [r7, #12]
 8010d76:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8010d78:	623b      	str	r3, [r7, #32]
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 8010d7a:	68fb      	ldr	r3, [r7, #12]
 8010d7c:	69db      	ldr	r3, [r3, #28]
 8010d7e:	673b      	str	r3, [r7, #112]	; 0x70
 8010d80:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d82:	f103 0320 	add.w	r3, r3, #32
 8010d86:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010d88:	601a      	str	r2, [r3, #0]
 8010d8a:	681a      	ldr	r2, [r3, #0]
 8010d8c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d8e:	601a      	str	r2, [r3, #0]
 8010d90:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010d92:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010d96:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 8010d98:	68fb      	ldr	r3, [r7, #12]
 8010d9a:	f103 035c 	add.w	r3, r3, #92	; 0x5c
 8010d9e:	681a      	ldr	r2, [r3, #0]
 8010da0:	6a3b      	ldr	r3, [r7, #32]
 8010da2:	18d3      	adds	r3, r2, r3
 8010da4:	673b      	str	r3, [r7, #112]	; 0x70
 8010da6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010da8:	f103 0320 	add.w	r3, r3, #32
 8010dac:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010dae:	601a      	str	r2, [r3, #0]
 8010db0:	681a      	ldr	r2, [r3, #0]
 8010db2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010db4:	601a      	str	r2, [r3, #0]
 8010db6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010db8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010dbc:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 8010dbe:	68fb      	ldr	r3, [r7, #12]
 8010dc0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010dc2:	673b      	str	r3, [r7, #112]	; 0x70
 8010dc4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010dc6:	f103 0320 	add.w	r3, r3, #32
 8010dca:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010dcc:	601a      	str	r2, [r3, #0]
 8010dce:	681a      	ldr	r2, [r3, #0]
 8010dd0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010dd2:	601a      	str	r2, [r3, #0]
 8010dd4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010dd6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010dda:	667b      	str	r3, [r7, #100]	; 0x64
	s = tmp;					d[0] = d[8] = s;
 8010ddc:	6a3b      	ldr	r3, [r7, #32]
 8010dde:	673b      	str	r3, [r7, #112]	; 0x70
 8010de0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010de2:	f103 0320 	add.w	r3, r3, #32
 8010de6:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010de8:	601a      	str	r2, [r3, #0]
 8010dea:	681a      	ldr	r2, [r3, #0]
 8010dec:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010dee:	601a      	str	r2, [r3, #0]

	/* samples 16 to 1 (sample 16 used again) */
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 8010df0:	687a      	ldr	r2, [r7, #4]
 8010df2:	683b      	ldr	r3, [r7, #0]
 8010df4:	1ad3      	subs	r3, r2, r3
 8010df6:	f003 0207 	and.w	r2, r3, #7
 8010dfa:	683b      	ldr	r3, [r7, #0]
 8010dfc:	2b00      	cmp	r3, #0
 8010dfe:	d002      	beq.n	8010e06 <xmp3_FDCT32+0xc5a>
 8010e00:	f04f 0300 	mov.w	r3, #0
 8010e04:	e001      	b.n	8010e0a <xmp3_FDCT32+0xc5e>
 8010e06:	f44f 6388 	mov.w	r3, #1088	; 0x440
 8010e0a:	18d3      	adds	r3, r2, r3
 8010e0c:	f103 0310 	add.w	r3, r3, #16
 8010e10:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010e14:	68ba      	ldr	r2, [r7, #8]
 8010e16:	18d3      	adds	r3, r2, r3
 8010e18:	667b      	str	r3, [r7, #100]	; 0x64

	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 8010e1a:	68fb      	ldr	r3, [r7, #12]
 8010e1c:	685b      	ldr	r3, [r3, #4]
 8010e1e:	673b      	str	r3, [r7, #112]	; 0x70
 8010e20:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010e22:	f103 0320 	add.w	r3, r3, #32
 8010e26:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010e28:	601a      	str	r2, [r3, #0]
 8010e2a:	681a      	ldr	r2, [r3, #0]
 8010e2c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010e2e:	601a      	str	r2, [r3, #0]
 8010e30:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010e32:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010e36:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[30] + buf[25];
 8010e38:	68fb      	ldr	r3, [r7, #12]
 8010e3a:	f103 0378 	add.w	r3, r3, #120	; 0x78
 8010e3e:	681a      	ldr	r2, [r3, #0]
 8010e40:	68fb      	ldr	r3, [r7, #12]
 8010e42:	f103 0364 	add.w	r3, r3, #100	; 0x64
 8010e46:	681b      	ldr	r3, [r3, #0]
 8010e48:	18d3      	adds	r3, r2, r3
 8010e4a:	623b      	str	r3, [r7, #32]
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 8010e4c:	68fb      	ldr	r3, [r7, #12]
 8010e4e:	f103 0344 	add.w	r3, r3, #68	; 0x44
 8010e52:	681a      	ldr	r2, [r3, #0]
 8010e54:	6a3b      	ldr	r3, [r7, #32]
 8010e56:	18d3      	adds	r3, r2, r3
 8010e58:	673b      	str	r3, [r7, #112]	; 0x70
 8010e5a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010e5c:	f103 0320 	add.w	r3, r3, #32
 8010e60:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010e62:	601a      	str	r2, [r3, #0]
 8010e64:	681a      	ldr	r2, [r3, #0]
 8010e66:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010e68:	601a      	str	r2, [r3, #0]
 8010e6a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010e6c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010e70:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[14] + buf[ 9];		d[0] = d[8] = s;	d += 64;
 8010e72:	68fb      	ldr	r3, [r7, #12]
 8010e74:	f103 0338 	add.w	r3, r3, #56	; 0x38
 8010e78:	681a      	ldr	r2, [r3, #0]
 8010e7a:	68fb      	ldr	r3, [r7, #12]
 8010e7c:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8010e80:	681b      	ldr	r3, [r3, #0]
 8010e82:	18d3      	adds	r3, r2, r3
 8010e84:	673b      	str	r3, [r7, #112]	; 0x70
 8010e86:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010e88:	f103 0320 	add.w	r3, r3, #32
 8010e8c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010e8e:	601a      	str	r2, [r3, #0]
 8010e90:	681a      	ldr	r2, [r3, #0]
 8010e92:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010e94:	601a      	str	r2, [r3, #0]
 8010e96:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010e98:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010e9c:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 8010e9e:	68fb      	ldr	r3, [r7, #12]
 8010ea0:	f103 0358 	add.w	r3, r3, #88	; 0x58
 8010ea4:	681a      	ldr	r2, [r3, #0]
 8010ea6:	6a3b      	ldr	r3, [r7, #32]
 8010ea8:	18d3      	adds	r3, r2, r3
 8010eaa:	673b      	str	r3, [r7, #112]	; 0x70
 8010eac:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010eae:	f103 0320 	add.w	r3, r3, #32
 8010eb2:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010eb4:	601a      	str	r2, [r3, #0]
 8010eb6:	681a      	ldr	r2, [r3, #0]
 8010eb8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010eba:	601a      	str	r2, [r3, #0]
 8010ebc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010ebe:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010ec2:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 6];				d[0] = d[8] = s;	d += 64;
 8010ec4:	68fb      	ldr	r3, [r7, #12]
 8010ec6:	699b      	ldr	r3, [r3, #24]
 8010ec8:	673b      	str	r3, [r7, #112]	; 0x70
 8010eca:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010ecc:	f103 0320 	add.w	r3, r3, #32
 8010ed0:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010ed2:	601a      	str	r2, [r3, #0]
 8010ed4:	681a      	ldr	r2, [r3, #0]
 8010ed6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010ed8:	601a      	str	r2, [r3, #0]
 8010eda:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010edc:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010ee0:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[26] + buf[30];
 8010ee2:	68fb      	ldr	r3, [r7, #12]
 8010ee4:	f103 0368 	add.w	r3, r3, #104	; 0x68
 8010ee8:	681a      	ldr	r2, [r3, #0]
 8010eea:	68fb      	ldr	r3, [r7, #12]
 8010eec:	f103 0378 	add.w	r3, r3, #120	; 0x78
 8010ef0:	681b      	ldr	r3, [r3, #0]
 8010ef2:	18d3      	adds	r3, r2, r3
 8010ef4:	623b      	str	r3, [r7, #32]
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 8010ef6:	68fb      	ldr	r3, [r7, #12]
 8010ef8:	f103 0358 	add.w	r3, r3, #88	; 0x58
 8010efc:	681a      	ldr	r2, [r3, #0]
 8010efe:	6a3b      	ldr	r3, [r7, #32]
 8010f00:	18d3      	adds	r3, r2, r3
 8010f02:	673b      	str	r3, [r7, #112]	; 0x70
 8010f04:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f06:	f103 0320 	add.w	r3, r3, #32
 8010f0a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010f0c:	601a      	str	r2, [r3, #0]
 8010f0e:	681a      	ldr	r2, [r3, #0]
 8010f10:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f12:	601a      	str	r2, [r3, #0]
 8010f14:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f16:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010f1a:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[10] + buf[14];		d[0] = d[8] = s;	d += 64;
 8010f1c:	68fb      	ldr	r3, [r7, #12]
 8010f1e:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8010f22:	681a      	ldr	r2, [r3, #0]
 8010f24:	68fb      	ldr	r3, [r7, #12]
 8010f26:	f103 0338 	add.w	r3, r3, #56	; 0x38
 8010f2a:	681b      	ldr	r3, [r3, #0]
 8010f2c:	18d3      	adds	r3, r2, r3
 8010f2e:	673b      	str	r3, [r7, #112]	; 0x70
 8010f30:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f32:	f103 0320 	add.w	r3, r3, #32
 8010f36:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010f38:	601a      	str	r2, [r3, #0]
 8010f3a:	681a      	ldr	r2, [r3, #0]
 8010f3c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f3e:	601a      	str	r2, [r3, #0]
 8010f40:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f42:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010f46:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 8010f48:	68fb      	ldr	r3, [r7, #12]
 8010f4a:	f103 0348 	add.w	r3, r3, #72	; 0x48
 8010f4e:	681a      	ldr	r2, [r3, #0]
 8010f50:	6a3b      	ldr	r3, [r7, #32]
 8010f52:	18d3      	adds	r3, r2, r3
 8010f54:	673b      	str	r3, [r7, #112]	; 0x70
 8010f56:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f58:	f103 0320 	add.w	r3, r3, #32
 8010f5c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010f5e:	601a      	str	r2, [r3, #0]
 8010f60:	681a      	ldr	r2, [r3, #0]
 8010f62:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f64:	601a      	str	r2, [r3, #0]
 8010f66:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f68:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010f6c:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 2];				d[0] = d[8] = s;	d += 64;
 8010f6e:	68fb      	ldr	r3, [r7, #12]
 8010f70:	689b      	ldr	r3, [r3, #8]
 8010f72:	673b      	str	r3, [r7, #112]	; 0x70
 8010f74:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f76:	f103 0320 	add.w	r3, r3, #32
 8010f7a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010f7c:	601a      	str	r2, [r3, #0]
 8010f7e:	681a      	ldr	r2, [r3, #0]
 8010f80:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f82:	601a      	str	r2, [r3, #0]
 8010f84:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010f86:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010f8a:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[28] + buf[26];
 8010f8c:	68fb      	ldr	r3, [r7, #12]
 8010f8e:	f103 0370 	add.w	r3, r3, #112	; 0x70
 8010f92:	681a      	ldr	r2, [r3, #0]
 8010f94:	68fb      	ldr	r3, [r7, #12]
 8010f96:	f103 0368 	add.w	r3, r3, #104	; 0x68
 8010f9a:	681b      	ldr	r3, [r3, #0]
 8010f9c:	18d3      	adds	r3, r2, r3
 8010f9e:	623b      	str	r3, [r7, #32]
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 8010fa0:	68fb      	ldr	r3, [r7, #12]
 8010fa2:	f103 0348 	add.w	r3, r3, #72	; 0x48
 8010fa6:	681a      	ldr	r2, [r3, #0]
 8010fa8:	6a3b      	ldr	r3, [r7, #32]
 8010faa:	18d3      	adds	r3, r2, r3
 8010fac:	673b      	str	r3, [r7, #112]	; 0x70
 8010fae:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010fb0:	f103 0320 	add.w	r3, r3, #32
 8010fb4:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010fb6:	601a      	str	r2, [r3, #0]
 8010fb8:	681a      	ldr	r2, [r3, #0]
 8010fba:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010fbc:	601a      	str	r2, [r3, #0]
 8010fbe:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010fc0:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010fc4:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[12] + buf[10];		d[0] = d[8] = s;	d += 64;
 8010fc6:	68fb      	ldr	r3, [r7, #12]
 8010fc8:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8010fcc:	681a      	ldr	r2, [r3, #0]
 8010fce:	68fb      	ldr	r3, [r7, #12]
 8010fd0:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8010fd4:	681b      	ldr	r3, [r3, #0]
 8010fd6:	18d3      	adds	r3, r2, r3
 8010fd8:	673b      	str	r3, [r7, #112]	; 0x70
 8010fda:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010fdc:	f103 0320 	add.w	r3, r3, #32
 8010fe0:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8010fe2:	601a      	str	r2, [r3, #0]
 8010fe4:	681a      	ldr	r2, [r3, #0]
 8010fe6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010fe8:	601a      	str	r2, [r3, #0]
 8010fea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010fec:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010ff0:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 8010ff2:	68fb      	ldr	r3, [r7, #12]
 8010ff4:	f103 0350 	add.w	r3, r3, #80	; 0x50
 8010ff8:	681a      	ldr	r2, [r3, #0]
 8010ffa:	6a3b      	ldr	r3, [r7, #32]
 8010ffc:	18d3      	adds	r3, r2, r3
 8010ffe:	673b      	str	r3, [r7, #112]	; 0x70
 8011000:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011002:	f103 0320 	add.w	r3, r3, #32
 8011006:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8011008:	601a      	str	r2, [r3, #0]
 801100a:	681a      	ldr	r2, [r3, #0]
 801100c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801100e:	601a      	str	r2, [r3, #0]
 8011010:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011012:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8011016:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 4];				d[0] = d[8] = s;	d += 64;
 8011018:	68fb      	ldr	r3, [r7, #12]
 801101a:	691b      	ldr	r3, [r3, #16]
 801101c:	673b      	str	r3, [r7, #112]	; 0x70
 801101e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011020:	f103 0320 	add.w	r3, r3, #32
 8011024:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8011026:	601a      	str	r2, [r3, #0]
 8011028:	681a      	ldr	r2, [r3, #0]
 801102a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801102c:	601a      	str	r2, [r3, #0]
 801102e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011030:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8011034:	667b      	str	r3, [r7, #100]	; 0x64

	tmp = buf[24] + buf[28];
 8011036:	68fb      	ldr	r3, [r7, #12]
 8011038:	f103 0360 	add.w	r3, r3, #96	; 0x60
 801103c:	681a      	ldr	r2, [r3, #0]
 801103e:	68fb      	ldr	r3, [r7, #12]
 8011040:	f103 0370 	add.w	r3, r3, #112	; 0x70
 8011044:	681b      	ldr	r3, [r3, #0]
 8011046:	18d3      	adds	r3, r2, r3
 8011048:	623b      	str	r3, [r7, #32]
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 801104a:	68fb      	ldr	r3, [r7, #12]
 801104c:	f103 0350 	add.w	r3, r3, #80	; 0x50
 8011050:	681a      	ldr	r2, [r3, #0]
 8011052:	6a3b      	ldr	r3, [r7, #32]
 8011054:	18d3      	adds	r3, r2, r3
 8011056:	673b      	str	r3, [r7, #112]	; 0x70
 8011058:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801105a:	f103 0320 	add.w	r3, r3, #32
 801105e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8011060:	601a      	str	r2, [r3, #0]
 8011062:	681a      	ldr	r2, [r3, #0]
 8011064:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011066:	601a      	str	r2, [r3, #0]
 8011068:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801106a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801106e:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[ 8] + buf[12];		d[0] = d[8] = s;	d += 64;
 8011070:	68fb      	ldr	r3, [r7, #12]
 8011072:	f103 0320 	add.w	r3, r3, #32
 8011076:	681a      	ldr	r2, [r3, #0]
 8011078:	68fb      	ldr	r3, [r7, #12]
 801107a:	f103 0330 	add.w	r3, r3, #48	; 0x30
 801107e:	681b      	ldr	r3, [r3, #0]
 8011080:	18d3      	adds	r3, r2, r3
 8011082:	673b      	str	r3, [r7, #112]	; 0x70
 8011084:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011086:	f103 0320 	add.w	r3, r3, #32
 801108a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 801108c:	601a      	str	r2, [r3, #0]
 801108e:	681a      	ldr	r2, [r3, #0]
 8011090:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011092:	601a      	str	r2, [r3, #0]
 8011094:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011096:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801109a:	667b      	str	r3, [r7, #100]	; 0x64
	s = buf[16] + tmp;			d[0] = d[8] = s;
 801109c:	68fb      	ldr	r3, [r7, #12]
 801109e:	f103 0340 	add.w	r3, r3, #64	; 0x40
 80110a2:	681a      	ldr	r2, [r3, #0]
 80110a4:	6a3b      	ldr	r3, [r7, #32]
 80110a6:	18d3      	adds	r3, r2, r3
 80110a8:	673b      	str	r3, [r7, #112]	; 0x70
 80110aa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80110ac:	f103 0320 	add.w	r3, r3, #32
 80110b0:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80110b2:	601a      	str	r2, [r3, #0]
 80110b4:	681a      	ldr	r2, [r3, #0]
 80110b6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80110b8:	601a      	str	r2, [r3, #0]

	/* this is so rarely invoked that it's not worth making two versions of the output
	 *   shuffle code (one for no shift, one for clip + variable shift) like in IMDCT
	 * here we just load, clip, shift, and store on the rare instances that es != 0
	 */
	if (es) {
 80110ba:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80110bc:	2b00      	cmp	r3, #0
 80110be:	f000 80cc 	beq.w	801125a <xmp3_FDCT32+0x10ae>
		d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 80110c2:	687a      	ldr	r2, [r7, #4]
 80110c4:	683b      	ldr	r3, [r7, #0]
 80110c6:	1ad3      	subs	r3, r2, r3
 80110c8:	f003 0207 	and.w	r2, r3, #7
 80110cc:	683b      	ldr	r3, [r7, #0]
 80110ce:	2b00      	cmp	r3, #0
 80110d0:	d002      	beq.n	80110d8 <xmp3_FDCT32+0xf2c>
 80110d2:	f04f 0300 	mov.w	r3, #0
 80110d6:	e001      	b.n	80110dc <xmp3_FDCT32+0xf30>
 80110d8:	f44f 6388 	mov.w	r3, #1088	; 0x440
 80110dc:	18d3      	adds	r3, r2, r3
 80110de:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80110e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80110e6:	68ba      	ldr	r2, [r7, #8]
 80110e8:	18d3      	adds	r3, r2, r3
 80110ea:	667b      	str	r3, [r7, #100]	; 0x64
		s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);
 80110ec:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80110ee:	681b      	ldr	r3, [r3, #0]
 80110f0:	673b      	str	r3, [r7, #112]	; 0x70
 80110f2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80110f4:	ea4f 73e3 	mov.w	r3, r3, asr #31
 80110f8:	61fb      	str	r3, [r7, #28]
 80110fa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80110fc:	f1c3 031f 	rsb	r3, r3, #31
 8011100:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8011102:	fa42 f203 	asr.w	r2, r2, r3
 8011106:	69fb      	ldr	r3, [r7, #28]
 8011108:	429a      	cmp	r2, r3
 801110a:	d00b      	beq.n	8011124 <xmp3_FDCT32+0xf78>
 801110c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801110e:	f1c3 031f 	rsb	r3, r3, #31
 8011112:	f04f 0201 	mov.w	r2, #1
 8011116:	fa02 f303 	lsl.w	r3, r2, r3
 801111a:	f103 32ff 	add.w	r2, r3, #4294967295
 801111e:	69fb      	ldr	r3, [r7, #28]
 8011120:	4053      	eors	r3, r2
 8011122:	673b      	str	r3, [r7, #112]	; 0x70
 8011124:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011126:	f103 0320 	add.w	r3, r3, #32
 801112a:	6f39      	ldr	r1, [r7, #112]	; 0x70
 801112c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801112e:	fa01 f202 	lsl.w	r2, r1, r2
 8011132:	601a      	str	r2, [r3, #0]
 8011134:	681a      	ldr	r2, [r3, #0]
 8011136:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011138:	601a      	str	r2, [r3, #0]
	
		d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 801113a:	683b      	ldr	r3, [r7, #0]
 801113c:	2b00      	cmp	r3, #0
 801113e:	d002      	beq.n	8011146 <xmp3_FDCT32+0xf9a>
 8011140:	f44f 6388 	mov.w	r3, #1088	; 0x440
 8011144:	e001      	b.n	801114a <xmp3_FDCT32+0xf9e>
 8011146:	f04f 0300 	mov.w	r3, #0
 801114a:	687a      	ldr	r2, [r7, #4]
 801114c:	189b      	adds	r3, r3, r2
 801114e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011152:	68ba      	ldr	r2, [r7, #8]
 8011154:	18d3      	adds	r3, r2, r3
 8011156:	667b      	str	r3, [r7, #100]	; 0x64
		for (i = 16; i <= 31; i++) {
 8011158:	f04f 0310 	mov.w	r3, #16
 801115c:	677b      	str	r3, [r7, #116]	; 0x74
 801115e:	e02e      	b.n	80111be <xmp3_FDCT32+0x1012>
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 8011160:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011162:	681b      	ldr	r3, [r3, #0]
 8011164:	673b      	str	r3, [r7, #112]	; 0x70
 8011166:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8011168:	ea4f 73e3 	mov.w	r3, r3, asr #31
 801116c:	61bb      	str	r3, [r7, #24]
 801116e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011170:	f1c3 031f 	rsb	r3, r3, #31
 8011174:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8011176:	fa42 f203 	asr.w	r2, r2, r3
 801117a:	69bb      	ldr	r3, [r7, #24]
 801117c:	429a      	cmp	r2, r3
 801117e:	d00b      	beq.n	8011198 <xmp3_FDCT32+0xfec>
 8011180:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011182:	f1c3 031f 	rsb	r3, r3, #31
 8011186:	f04f 0201 	mov.w	r2, #1
 801118a:	fa02 f303 	lsl.w	r3, r2, r3
 801118e:	f103 32ff 	add.w	r2, r3, #4294967295
 8011192:	69bb      	ldr	r3, [r7, #24]
 8011194:	4053      	eors	r3, r2
 8011196:	673b      	str	r3, [r7, #112]	; 0x70
 8011198:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801119a:	f103 0320 	add.w	r3, r3, #32
 801119e:	6f39      	ldr	r1, [r7, #112]	; 0x70
 80111a0:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80111a2:	fa01 f202 	lsl.w	r2, r1, r2
 80111a6:	601a      	str	r2, [r3, #0]
 80111a8:	681a      	ldr	r2, [r3, #0]
 80111aa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80111ac:	601a      	str	r2, [r3, #0]
 80111ae:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80111b0:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80111b4:	667b      	str	r3, [r7, #100]	; 0x64
	if (es) {
		d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);
	
		d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
		for (i = 16; i <= 31; i++) {
 80111b6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80111b8:	f103 0301 	add.w	r3, r3, #1
 80111bc:	677b      	str	r3, [r7, #116]	; 0x74
 80111be:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80111c0:	2b1f      	cmp	r3, #31
 80111c2:	ddcd      	ble.n	8011160 <xmp3_FDCT32+0xfb4>
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
		}

		d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 80111c4:	687a      	ldr	r2, [r7, #4]
 80111c6:	683b      	ldr	r3, [r7, #0]
 80111c8:	1ad3      	subs	r3, r2, r3
 80111ca:	f003 0207 	and.w	r2, r3, #7
 80111ce:	683b      	ldr	r3, [r7, #0]
 80111d0:	2b00      	cmp	r3, #0
 80111d2:	d002      	beq.n	80111da <xmp3_FDCT32+0x102e>
 80111d4:	f04f 0300 	mov.w	r3, #0
 80111d8:	e001      	b.n	80111de <xmp3_FDCT32+0x1032>
 80111da:	f44f 6388 	mov.w	r3, #1088	; 0x440
 80111de:	18d3      	adds	r3, r2, r3
 80111e0:	f103 0310 	add.w	r3, r3, #16
 80111e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80111e8:	68ba      	ldr	r2, [r7, #8]
 80111ea:	18d3      	adds	r3, r2, r3
 80111ec:	667b      	str	r3, [r7, #100]	; 0x64
		for (i = 15; i >= 0; i--) {
 80111ee:	f04f 030f 	mov.w	r3, #15
 80111f2:	677b      	str	r3, [r7, #116]	; 0x74
 80111f4:	e02e      	b.n	8011254 <xmp3_FDCT32+0x10a8>
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 80111f6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80111f8:	681b      	ldr	r3, [r3, #0]
 80111fa:	673b      	str	r3, [r7, #112]	; 0x70
 80111fc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80111fe:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8011202:	617b      	str	r3, [r7, #20]
 8011204:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011206:	f1c3 031f 	rsb	r3, r3, #31
 801120a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 801120c:	fa42 f203 	asr.w	r2, r2, r3
 8011210:	697b      	ldr	r3, [r7, #20]
 8011212:	429a      	cmp	r2, r3
 8011214:	d00b      	beq.n	801122e <xmp3_FDCT32+0x1082>
 8011216:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011218:	f1c3 031f 	rsb	r3, r3, #31
 801121c:	f04f 0201 	mov.w	r2, #1
 8011220:	fa02 f303 	lsl.w	r3, r2, r3
 8011224:	f103 32ff 	add.w	r2, r3, #4294967295
 8011228:	697b      	ldr	r3, [r7, #20]
 801122a:	4053      	eors	r3, r2
 801122c:	673b      	str	r3, [r7, #112]	; 0x70
 801122e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011230:	f103 0320 	add.w	r3, r3, #32
 8011234:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8011236:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8011238:	fa01 f202 	lsl.w	r2, r1, r2
 801123c:	601a      	str	r2, [r3, #0]
 801123e:	681a      	ldr	r2, [r3, #0]
 8011240:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011242:	601a      	str	r2, [r3, #0]
 8011244:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011246:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801124a:	667b      	str	r3, [r7, #100]	; 0x64
		for (i = 16; i <= 31; i++) {
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
		}

		d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		for (i = 15; i >= 0; i--) {
 801124c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801124e:	f103 33ff 	add.w	r3, r3, #4294967295
 8011252:	677b      	str	r3, [r7, #116]	; 0x74
 8011254:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8011256:	2b00      	cmp	r3, #0
 8011258:	dacd      	bge.n	80111f6 <xmp3_FDCT32+0x104a>
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
		}
	}
}
 801125a:	f107 077c 	add.w	r7, r7, #124	; 0x7c
 801125e:	46bd      	mov	sp, r7
 8011260:	bd90      	pop	{r4, r7, pc}
 8011262:	bf00      	nop

08011264 <CLZ>:

return x;
}

static __inline int CLZ(int x)
{
 8011264:	b490      	push	{r4, r7}
 8011266:	b084      	sub	sp, #16
 8011268:	af00      	add	r7, sp, #0
 801126a:	6078      	str	r0, [r7, #4]
while (!(x & 0x80000000)) {
numZeros++;
x <
}*/

__asm__ ("clz %0, %1" : "=r" (numZeros) : "r" (x) : "cc");
 801126c:	687b      	ldr	r3, [r7, #4]
 801126e:	fab3 f483 	clz	r4, r3
 8011272:	60fc      	str	r4, [r7, #12]

return numZeros;
 8011274:	68fb      	ldr	r3, [r7, #12]
}
 8011276:	4618      	mov	r0, r3
 8011278:	f107 0710 	add.w	r7, r7, #16
 801127c:	46bd      	mov	sp, r7
 801127e:	bc90      	pop	{r4, r7}
 8011280:	4770      	bx	lr
 8011282:	bf00      	nop

08011284 <xmp3_Dequantize>:
 *                round to PCM (>> by 15 less than we otherwise would have).
 *              Equivalently, we can think of the dequantized coefficients as 
 *                Q(DQ_FRACBITS_OUT - 15) with no implicit bias. 
 **************************************************************************************/
int Dequantize(MP3DecInfo *mp3DecInfo, int gr)
{
 8011284:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011286:	b095      	sub	sp, #84	; 0x54
 8011288:	af06      	add	r7, sp, #24
 801128a:	6078      	str	r0, [r7, #4]
 801128c:	6039      	str	r1, [r7, #0]
	HuffmanInfo *hi;
	DequantInfo *di;
	CriticalBandInfo *cbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 801128e:	687b      	ldr	r3, [r7, #4]
 8011290:	2b00      	cmp	r3, #0
 8011292:	d013      	beq.n	80112bc <xmp3_Dequantize+0x38>
 8011294:	687b      	ldr	r3, [r7, #4]
 8011296:	681b      	ldr	r3, [r3, #0]
 8011298:	2b00      	cmp	r3, #0
 801129a:	d00f      	beq.n	80112bc <xmp3_Dequantize+0x38>
 801129c:	687b      	ldr	r3, [r7, #4]
 801129e:	685b      	ldr	r3, [r3, #4]
 80112a0:	2b00      	cmp	r3, #0
 80112a2:	d00b      	beq.n	80112bc <xmp3_Dequantize+0x38>
 80112a4:	687b      	ldr	r3, [r7, #4]
 80112a6:	689b      	ldr	r3, [r3, #8]
 80112a8:	2b00      	cmp	r3, #0
 80112aa:	d007      	beq.n	80112bc <xmp3_Dequantize+0x38>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 80112ac:	687b      	ldr	r3, [r7, #4]
 80112ae:	68db      	ldr	r3, [r3, #12]
	HuffmanInfo *hi;
	DequantInfo *di;
	CriticalBandInfo *cbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 80112b0:	2b00      	cmp	r3, #0
 80112b2:	d003      	beq.n	80112bc <xmp3_Dequantize+0x38>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 80112b4:	687b      	ldr	r3, [r7, #4]
 80112b6:	691b      	ldr	r3, [r3, #16]
 80112b8:	2b00      	cmp	r3, #0
 80112ba:	d102      	bne.n	80112c2 <xmp3_Dequantize+0x3e>
		return -1;
 80112bc:	f04f 33ff 	mov.w	r3, #4294967295
 80112c0:	e1e2      	b.n	8011688 <xmp3_Dequantize+0x404>

	fh = (FrameHeader *)(mp3DecInfo->FrameHeaderPS);
 80112c2:	687b      	ldr	r3, [r7, #4]
 80112c4:	681b      	ldr	r3, [r3, #0]
 80112c6:	62bb      	str	r3, [r7, #40]	; 0x28

	/* si is an array of up to 4 structs, stored as gr0ch0, gr0ch1, gr1ch0, gr1ch1 */
	si = (SideInfo *)(mp3DecInfo->SideInfoPS);
 80112c8:	687b      	ldr	r3, [r7, #4]
 80112ca:	685b      	ldr	r3, [r3, #4]
 80112cc:	627b      	str	r3, [r7, #36]	; 0x24
	sfi = (ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS);
 80112ce:	687b      	ldr	r3, [r7, #4]
 80112d0:	689b      	ldr	r3, [r3, #8]
 80112d2:	623b      	str	r3, [r7, #32]
	hi = (HuffmanInfo *)mp3DecInfo->HuffmanInfoPS;
 80112d4:	687b      	ldr	r3, [r7, #4]
 80112d6:	68db      	ldr	r3, [r3, #12]
 80112d8:	61fb      	str	r3, [r7, #28]
	di = (DequantInfo *)mp3DecInfo->DequantInfoPS;
 80112da:	687b      	ldr	r3, [r7, #4]
 80112dc:	691b      	ldr	r3, [r3, #16]
 80112de:	61bb      	str	r3, [r7, #24]
	cbi = di->cbi;
 80112e0:	69bb      	ldr	r3, [r7, #24]
 80112e2:	f503 7346 	add.w	r3, r3, #792	; 0x318
 80112e6:	617b      	str	r3, [r7, #20]
	mOut[0] = mOut[1] = 0;
 80112e8:	f04f 0300 	mov.w	r3, #0
 80112ec:	613b      	str	r3, [r7, #16]
 80112ee:	693b      	ldr	r3, [r7, #16]
 80112f0:	60fb      	str	r3, [r7, #12]

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 80112f2:	f04f 0300 	mov.w	r3, #0
 80112f6:	633b      	str	r3, [r7, #48]	; 0x30
 80112f8:	e053      	b.n	80113a2 <xmp3_Dequantize+0x11e>
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 80112fa:	69f9      	ldr	r1, [r7, #28]
 80112fc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80112fe:	4613      	mov	r3, r2
 8011300:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8011304:	189b      	adds	r3, r3, r2
 8011306:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801130a:	18c8      	adds	r0, r1, r3
 801130c:	69b9      	ldr	r1, [r7, #24]
 801130e:	69fb      	ldr	r3, [r7, #28]
 8011310:	f503 5290 	add.w	r2, r3, #4608	; 0x1200
 8011314:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011316:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801131a:	18d4      	adds	r4, r2, r3
			&si->sis[gr][ch], &sfi->sfis[gr][ch], &cbi[ch]);
 801131c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801131e:	f103 0528 	add.w	r5, r3, #40	; 0x28
 8011322:	683a      	ldr	r2, [r7, #0]
 8011324:	4613      	mov	r3, r2
 8011326:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801132a:	189b      	adds	r3, r3, r2
 801132c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8011330:	461e      	mov	r6, r3
 8011332:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011334:	4613      	mov	r3, r2
 8011336:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801133a:	189b      	adds	r3, r3, r2
 801133c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8011340:	18f3      	adds	r3, r6, r3
	cbi = di->cbi;
	mOut[0] = mOut[1] = 0;

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 8011342:	18ee      	adds	r6, r5, r3
			&si->sis[gr][ch], &sfi->sfis[gr][ch], &cbi[ch]);
 8011344:	6a3d      	ldr	r5, [r7, #32]
 8011346:	683a      	ldr	r2, [r7, #0]
 8011348:	4613      	mov	r3, r2
 801134a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 801134e:	1a9b      	subs	r3, r3, r2
 8011350:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011354:	469e      	mov	lr, r3
 8011356:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011358:	4613      	mov	r3, r2
 801135a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 801135e:	1a9b      	subs	r3, r3, r2
 8011360:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011364:	4473      	add	r3, lr
	cbi = di->cbi;
	mOut[0] = mOut[1] = 0;

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 8011366:	18ed      	adds	r5, r5, r3
 8011368:	6b3a      	ldr	r2, [r7, #48]	; 0x30
			&si->sis[gr][ch], &sfi->sfis[gr][ch], &cbi[ch]);
 801136a:	4613      	mov	r3, r2
 801136c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011370:	189b      	adds	r3, r3, r2
 8011372:	ea4f 03c3 	mov.w	r3, r3, lsl #3
	cbi = di->cbi;
	mOut[0] = mOut[1] = 0;

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 8011376:	697a      	ldr	r2, [r7, #20]
 8011378:	18d3      	adds	r3, r2, r3
 801137a:	9600      	str	r6, [sp, #0]
 801137c:	9501      	str	r5, [sp, #4]
 801137e:	9302      	str	r3, [sp, #8]
 8011380:	4622      	mov	r2, r4
 8011382:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011384:	f000 fb0a 	bl	801199c <xmp3_DequantChannel>
 8011388:	4601      	mov	r1, r0
 801138a:	69fa      	ldr	r2, [r7, #28]
 801138c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801138e:	f503 6390 	add.w	r3, r3, #1152	; 0x480
 8011392:	f103 0302 	add.w	r3, r3, #2
 8011396:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	di = (DequantInfo *)mp3DecInfo->DequantInfoPS;
	cbi = di->cbi;
	mOut[0] = mOut[1] = 0;

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801139a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801139c:	f103 0301 	add.w	r3, r3, #1
 80113a0:	633b      	str	r3, [r7, #48]	; 0x30
 80113a2:	687b      	ldr	r3, [r7, #4]
 80113a4:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 80113a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80113aa:	429a      	cmp	r2, r3
 80113ac:	dca5      	bgt.n	80112fa <xmp3_Dequantize+0x76>
	/* joint stereo processing assumes one guard bit in input samples
	 * it's extremely rare not to have at least one gb, so if this is the case
	 *   just make a pass over the data and clip to [-2^30+1, 2^30-1]
	 * in practice this may never happen
	 */
	if (fh->modeExt && (hi->gb[0] < 1 || hi->gb[1] < 1)) {
 80113ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80113b0:	6a1b      	ldr	r3, [r3, #32]
 80113b2:	2b00      	cmp	r3, #0
 80113b4:	d077      	beq.n	80114a6 <xmp3_Dequantize+0x222>
 80113b6:	69fb      	ldr	r3, [r7, #28]
 80113b8:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 80113bc:	f103 0308 	add.w	r3, r3, #8
 80113c0:	681b      	ldr	r3, [r3, #0]
 80113c2:	2b00      	cmp	r3, #0
 80113c4:	dd07      	ble.n	80113d6 <xmp3_Dequantize+0x152>
 80113c6:	69fb      	ldr	r3, [r7, #28]
 80113c8:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 80113cc:	f103 030c 	add.w	r3, r3, #12
 80113d0:	681b      	ldr	r3, [r3, #0]
 80113d2:	2b00      	cmp	r3, #0
 80113d4:	dc67      	bgt.n	80114a6 <xmp3_Dequantize+0x222>
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 80113d6:	f04f 0300 	mov.w	r3, #0
 80113da:	637b      	str	r3, [r7, #52]	; 0x34
 80113dc:	e023      	b.n	8011426 <xmp3_Dequantize+0x1a2>
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 80113de:	69fb      	ldr	r3, [r7, #28]
 80113e0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80113e2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80113e6:	f04f 0301 	mov.w	r3, #1
 80113ea:	f2cc 0300 	movt	r3, #49152	; 0xc000
 80113ee:	429a      	cmp	r2, r3
 80113f0:	da07      	bge.n	8011402 <xmp3_Dequantize+0x17e>
 80113f2:	69fa      	ldr	r2, [r7, #28]
 80113f4:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80113f6:	f04f 0301 	mov.w	r3, #1
 80113fa:	f2cc 0300 	movt	r3, #49152	; 0xc000
 80113fe:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 8011402:	69fb      	ldr	r3, [r7, #28]
 8011404:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011406:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801140a:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 801140e:	429a      	cmp	r2, r3
 8011410:	dd05      	ble.n	801141e <xmp3_Dequantize+0x19a>
 8011412:	69fb      	ldr	r3, [r7, #28]
 8011414:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011416:	f06f 4140 	mvn.w	r1, #3221225472	; 0xc0000000
 801141a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	 * it's extremely rare not to have at least one gb, so if this is the case
	 *   just make a pass over the data and clip to [-2^30+1, 2^30-1]
	 * in practice this may never happen
	 */
	if (fh->modeExt && (hi->gb[0] < 1 || hi->gb[1] < 1)) {
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 801141e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011420:	f103 0301 	add.w	r3, r3, #1
 8011424:	637b      	str	r3, [r7, #52]	; 0x34
 8011426:	69fb      	ldr	r3, [r7, #28]
 8011428:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 801142c:	681a      	ldr	r2, [r3, #0]
 801142e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011430:	429a      	cmp	r2, r3
 8011432:	dcd4      	bgt.n	80113de <xmp3_Dequantize+0x15a>
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
		}
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 8011434:	f04f 0300 	mov.w	r3, #0
 8011438:	637b      	str	r3, [r7, #52]	; 0x34
 801143a:	e02b      	b.n	8011494 <xmp3_Dequantize+0x210>
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 801143c:	69fb      	ldr	r3, [r7, #28]
 801143e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011440:	f502 7210 	add.w	r2, r2, #576	; 0x240
 8011444:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011448:	f04f 0301 	mov.w	r3, #1
 801144c:	f2cc 0300 	movt	r3, #49152	; 0xc000
 8011450:	429a      	cmp	r2, r3
 8011452:	da09      	bge.n	8011468 <xmp3_Dequantize+0x1e4>
 8011454:	69fa      	ldr	r2, [r7, #28]
 8011456:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011458:	f503 7110 	add.w	r1, r3, #576	; 0x240
 801145c:	f04f 0301 	mov.w	r3, #1
 8011460:	f2cc 0300 	movt	r3, #49152	; 0xc000
 8011464:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 8011468:	69fb      	ldr	r3, [r7, #28]
 801146a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801146c:	f502 7210 	add.w	r2, r2, #576	; 0x240
 8011470:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011474:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 8011478:	429a      	cmp	r2, r3
 801147a:	dd07      	ble.n	801148c <xmp3_Dequantize+0x208>
 801147c:	69fb      	ldr	r3, [r7, #28]
 801147e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011480:	f502 7210 	add.w	r2, r2, #576	; 0x240
 8011484:	f06f 4140 	mvn.w	r1, #3221225472	; 0xc0000000
 8011488:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	if (fh->modeExt && (hi->gb[0] < 1 || hi->gb[1] < 1)) {
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
		}
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 801148c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801148e:	f103 0301 	add.w	r3, r3, #1
 8011492:	637b      	str	r3, [r7, #52]	; 0x34
 8011494:	69fb      	ldr	r3, [r7, #28]
 8011496:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 801149a:	f103 0304 	add.w	r3, r3, #4
 801149e:	681a      	ldr	r2, [r3, #0]
 80114a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80114a2:	429a      	cmp	r2, r3
 80114a4:	dcca      	bgt.n	801143c <xmp3_Dequantize+0x1b8>
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
		}
	}

	/* do mid-side stereo processing, if enabled */
	if (fh->modeExt >> 1) {
 80114a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80114a8:	6a1b      	ldr	r3, [r3, #32]
 80114aa:	ea4f 0363 	mov.w	r3, r3, asr #1
 80114ae:	2b00      	cmp	r3, #0
 80114b0:	d044      	beq.n	801153c <xmp3_Dequantize+0x2b8>
		if (fh->modeExt & 0x01) {
 80114b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80114b4:	6a1b      	ldr	r3, [r3, #32]
 80114b6:	f003 0301 	and.w	r3, r3, #1
 80114ba:	b2db      	uxtb	r3, r3
 80114bc:	2b00      	cmp	r3, #0
 80114be:	d027      	beq.n	8011510 <xmp3_Dequantize+0x28c>
			/* intensity stereo enabled - run mid-side up to start of right zero region */
			if (cbi[1].cbType == 0)
 80114c0:	697b      	ldr	r3, [r7, #20]
 80114c2:	f103 0318 	add.w	r3, r3, #24
 80114c6:	681b      	ldr	r3, [r3, #0]
 80114c8:	2b00      	cmp	r3, #0
 80114ca:	d10c      	bne.n	80114e6 <xmp3_Dequantize+0x262>
				nSamps = fh->sfBand->l[cbi[1].cbEndL + 1];
 80114cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80114ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80114d0:	697a      	ldr	r2, [r7, #20]
 80114d2:	f102 0218 	add.w	r2, r2, #24
 80114d6:	6952      	ldr	r2, [r2, #20]
 80114d8:	f102 0201 	add.w	r2, r2, #1
 80114dc:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80114e0:	b21b      	sxth	r3, r3
 80114e2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80114e4:	e022      	b.n	801152c <xmp3_Dequantize+0x2a8>
			else 
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
 80114e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80114e8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80114ea:	697b      	ldr	r3, [r7, #20]
 80114ec:	f103 0318 	add.w	r3, r3, #24
 80114f0:	691b      	ldr	r3, [r3, #16]
 80114f2:	f103 0301 	add.w	r3, r3, #1
 80114f6:	f103 0314 	add.w	r3, r3, #20
 80114fa:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80114fe:	18d3      	adds	r3, r2, r3
 8011500:	88db      	ldrh	r3, [r3, #6]
 8011502:	b21a      	sxth	r2, r3
 8011504:	4613      	mov	r3, r2
 8011506:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801150a:	189b      	adds	r3, r3, r2
 801150c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801150e:	e00d      	b.n	801152c <xmp3_Dequantize+0x2a8>
		} else {
			/* intensity stereo disabled - run mid-side on whole spectrum */
			nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 8011510:	69fb      	ldr	r3, [r7, #28]
 8011512:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8011516:	f103 0304 	add.w	r3, r3, #4
 801151a:	681a      	ldr	r2, [r3, #0]
 801151c:	69fb      	ldr	r3, [r7, #28]
 801151e:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8011522:	681b      	ldr	r3, [r3, #0]
 8011524:	429a      	cmp	r2, r3
 8011526:	bfa8      	it	ge
 8011528:	4613      	movge	r3, r2
 801152a:	62fb      	str	r3, [r7, #44]	; 0x2c
		}
		MidSideProc(hi->huffDecBuf, nSamps, mOut);
 801152c:	69fa      	ldr	r2, [r7, #28]
 801152e:	f107 030c 	add.w	r3, r7, #12
 8011532:	4610      	mov	r0, r2
 8011534:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8011536:	461a      	mov	r2, r3
 8011538:	f005 fc7e 	bl	8016e38 <xmp3_MidSideProc>
	}

	/* do intensity stereo processing, if enabled */
	if (fh->modeExt & 0x01) {
 801153c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801153e:	6a1b      	ldr	r3, [r3, #32]
 8011540:	f003 0301 	and.w	r3, r3, #1
 8011544:	b2db      	uxtb	r3, r3
 8011546:	2b00      	cmp	r3, #0
 8011548:	d064      	beq.n	8011614 <xmp3_Dequantize+0x390>
		nSamps = hi->nonZeroBound[0];
 801154a:	69fb      	ldr	r3, [r7, #28]
 801154c:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8011550:	681b      	ldr	r3, [r3, #0]
 8011552:	62fb      	str	r3, [r7, #44]	; 0x2c
		if (fh->ver == MPEG1) {
 8011554:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011556:	781b      	ldrb	r3, [r3, #0]
 8011558:	2b00      	cmp	r3, #0
 801155a:	d12b      	bne.n	80115b4 <xmp3_Dequantize+0x330>
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 801155c:	69f9      	ldr	r1, [r7, #28]
 801155e:	6a38      	ldr	r0, [r7, #32]
 8011560:	683a      	ldr	r2, [r7, #0]
 8011562:	4613      	mov	r3, r2
 8011564:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8011568:	1a9b      	subs	r3, r3, r2
 801156a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801156e:	f103 033e 	add.w	r3, r3, #62	; 0x3e
 8011572:	18c4      	adds	r4, r0, r3
 8011574:	69bb      	ldr	r3, [r7, #24]
 8011576:	f503 7546 	add.w	r5, r3, #792	; 0x318
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
 801157a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801157c:	6a1b      	ldr	r3, [r3, #32]

	/* do intensity stereo processing, if enabled */
	if (fh->modeExt & 0x01) {
		nSamps = hi->nonZeroBound[0];
		if (fh->ver == MPEG1) {
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 801157e:	ea4f 0063 	mov.w	r0, r3, asr #1
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
 8011582:	6a7e      	ldr	r6, [r7, #36]	; 0x24

	/* do intensity stereo processing, if enabled */
	if (fh->modeExt & 0x01) {
		nSamps = hi->nonZeroBound[0];
		if (fh->ver == MPEG1) {
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 8011584:	683a      	ldr	r2, [r7, #0]
 8011586:	4613      	mov	r3, r2
 8011588:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801158c:	189b      	adds	r3, r3, r2
 801158e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8011592:	18f3      	adds	r3, r6, r3
 8011594:	f103 0388 	add.w	r3, r3, #136	; 0x88
 8011598:	681b      	ldr	r3, [r3, #0]
 801159a:	9500      	str	r5, [sp, #0]
 801159c:	9001      	str	r0, [sp, #4]
 801159e:	9302      	str	r3, [sp, #8]
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
 80115a0:	f107 030c 	add.w	r3, r7, #12

	/* do intensity stereo processing, if enabled */
	if (fh->modeExt & 0x01) {
		nSamps = hi->nonZeroBound[0];
		if (fh->ver == MPEG1) {
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 80115a4:	9303      	str	r3, [sp, #12]
 80115a6:	4608      	mov	r0, r1
 80115a8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80115aa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80115ac:	4623      	mov	r3, r4
 80115ae:	f005 fca3 	bl	8016ef8 <xmp3_IntensityProcMPEG1>
 80115b2:	e02f      	b.n	8011614 <xmp3_Dequantize+0x390>
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
		} else {
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 80115b4:	69f9      	ldr	r1, [r7, #28]
 80115b6:	6a38      	ldr	r0, [r7, #32]
 80115b8:	683a      	ldr	r2, [r7, #0]
 80115ba:	4613      	mov	r3, r2
 80115bc:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80115c0:	1a9b      	subs	r3, r3, r2
 80115c2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80115c6:	f103 033e 	add.w	r3, r3, #62	; 0x3e
 80115ca:	18c4      	adds	r4, r0, r3
 80115cc:	69bb      	ldr	r3, [r7, #24]
 80115ce:	f503 7646 	add.w	r6, r3, #792	; 0x318
 80115d2:	6a3b      	ldr	r3, [r7, #32]
 80115d4:	f103 05f8 	add.w	r5, r3, #248	; 0xf8
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
 80115d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80115da:	6a1b      	ldr	r3, [r3, #32]
		nSamps = hi->nonZeroBound[0];
		if (fh->ver == MPEG1) {
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
		} else {
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 80115dc:	ea4f 0063 	mov.w	r0, r3, asr #1
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
 80115e0:	f8d7 e024 	ldr.w	lr, [r7, #36]	; 0x24
		nSamps = hi->nonZeroBound[0];
		if (fh->ver == MPEG1) {
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
		} else {
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 80115e4:	683a      	ldr	r2, [r7, #0]
 80115e6:	4613      	mov	r3, r2
 80115e8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80115ec:	189b      	adds	r3, r3, r2
 80115ee:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80115f2:	4473      	add	r3, lr
 80115f4:	f103 0388 	add.w	r3, r3, #136	; 0x88
 80115f8:	681b      	ldr	r3, [r3, #0]
 80115fa:	9600      	str	r6, [sp, #0]
 80115fc:	9501      	str	r5, [sp, #4]
 80115fe:	9002      	str	r0, [sp, #8]
 8011600:	9303      	str	r3, [sp, #12]
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
 8011602:	f107 030c 	add.w	r3, r7, #12
		nSamps = hi->nonZeroBound[0];
		if (fh->ver == MPEG1) {
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
		} else {
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 8011606:	9304      	str	r3, [sp, #16]
 8011608:	4608      	mov	r0, r1
 801160a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801160c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801160e:	4623      	mov	r3, r4
 8011610:	f005 fee2 	bl	80173d8 <xmp3_IntensityProcMPEG2>
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
		}
	}

	/* adjust guard bit count and nonZeroBound if we did any stereo processing */
	if (fh->modeExt) {
 8011614:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011616:	6a1b      	ldr	r3, [r3, #32]
 8011618:	2b00      	cmp	r3, #0
 801161a:	d033      	beq.n	8011684 <xmp3_Dequantize+0x400>
		hi->gb[0] = CLZ(mOut[0]) - 1;
 801161c:	68fb      	ldr	r3, [r7, #12]
 801161e:	4618      	mov	r0, r3
 8011620:	f7ff fe20 	bl	8011264 <CLZ>
 8011624:	4603      	mov	r3, r0
 8011626:	f103 32ff 	add.w	r2, r3, #4294967295
 801162a:	69fb      	ldr	r3, [r7, #28]
 801162c:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8011630:	f103 0308 	add.w	r3, r3, #8
 8011634:	601a      	str	r2, [r3, #0]
		hi->gb[1] = CLZ(mOut[1]) - 1;
 8011636:	693b      	ldr	r3, [r7, #16]
 8011638:	4618      	mov	r0, r3
 801163a:	f7ff fe13 	bl	8011264 <CLZ>
 801163e:	4603      	mov	r3, r0
 8011640:	f103 32ff 	add.w	r2, r3, #4294967295
 8011644:	69fb      	ldr	r3, [r7, #28]
 8011646:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 801164a:	f103 030c 	add.w	r3, r3, #12
 801164e:	601a      	str	r2, [r3, #0]
		nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 8011650:	69fb      	ldr	r3, [r7, #28]
 8011652:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8011656:	f103 0304 	add.w	r3, r3, #4
 801165a:	681a      	ldr	r2, [r3, #0]
 801165c:	69fb      	ldr	r3, [r7, #28]
 801165e:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8011662:	681b      	ldr	r3, [r3, #0]
 8011664:	429a      	cmp	r2, r3
 8011666:	bfa8      	it	ge
 8011668:	4613      	movge	r3, r2
 801166a:	62fb      	str	r3, [r7, #44]	; 0x2c
		hi->nonZeroBound[0] = nSamps;
 801166c:	69fb      	ldr	r3, [r7, #28]
 801166e:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 8011672:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011674:	601a      	str	r2, [r3, #0]
		hi->nonZeroBound[1] = nSamps;
 8011676:	69fb      	ldr	r3, [r7, #28]
 8011678:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
 801167c:	f103 0304 	add.w	r3, r3, #4
 8011680:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011682:	601a      	str	r2, [r3, #0]
	}

	/* output format Q(DQ_FRACBITS_OUT) */
	return 0;
 8011684:	f04f 0300 	mov.w	r3, #0
}
 8011688:	4618      	mov	r0, r3
 801168a:	f107 073c 	add.w	r7, r7, #60	; 0x3c
 801168e:	46bd      	mov	sp, r7
 8011690:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011692:	bf00      	nop

08011694 <MULSHIFT32>:


#if defined(__GNUC__) && defined(__arm__)

static __inline__ int MULSHIFT32(int x, int y)
{
 8011694:	b490      	push	{r4, r7}
 8011696:	b084      	sub	sp, #16
 8011698:	af00      	add	r7, sp, #0
 801169a:	6078      	str	r0, [r7, #4]
 801169c:	6039      	str	r1, [r7, #0]
int zlow;
__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 801169e:	687a      	ldr	r2, [r7, #4]
 80116a0:	683b      	ldr	r3, [r7, #0]
 80116a2:	fb82 4303 	smull	r4, r3, r2, r3
 80116a6:	60fc      	str	r4, [r7, #12]
 80116a8:	603b      	str	r3, [r7, #0]
return y;
 80116aa:	683b      	ldr	r3, [r7, #0]
}
 80116ac:	4618      	mov	r0, r3
 80116ae:	f107 0710 	add.w	r7, r7, #16
 80116b2:	46bd      	mov	sp, r7
 80116b4:	bc90      	pop	{r4, r7}
 80116b6:	4770      	bx	lr

080116b8 <CLZ>:

return x;
}

static __inline int CLZ(int x)
{
 80116b8:	b490      	push	{r4, r7}
 80116ba:	b084      	sub	sp, #16
 80116bc:	af00      	add	r7, sp, #0
 80116be:	6078      	str	r0, [r7, #4]
while (!(x & 0x80000000)) {
numZeros++;
x <
}*/

__asm__ ("clz %0, %1" : "=r" (numZeros) : "r" (x) : "cc");
 80116c0:	687b      	ldr	r3, [r7, #4]
 80116c2:	fab3 f483 	clz	r4, r3
 80116c6:	60fc      	str	r4, [r7, #12]

return numZeros;
 80116c8:	68fb      	ldr	r3, [r7, #12]
}
 80116ca:	4618      	mov	r0, r3
 80116cc:	f107 0710 	add.w	r7, r7, #16
 80116d0:	46bd      	mov	sp, r7
 80116d2:	bc90      	pop	{r4, r7}
 80116d4:	4770      	bx	lr
 80116d6:	bf00      	nop

080116d8 <DequantBlock>:
 * Outputs:     dequantized samples in Q25 format
 *
 * Return:      bitwise-OR of the unsigned outputs (for guard bit calculations)
 **************************************************************************************/
static int DequantBlock(int *inbuf, int *outbuf, int num, int scale)
{
 80116d8:	b580      	push	{r7, lr}
 80116da:	b092      	sub	sp, #72	; 0x48
 80116dc:	af00      	add	r7, sp, #0
 80116de:	60f8      	str	r0, [r7, #12]
 80116e0:	60b9      	str	r1, [r7, #8]
 80116e2:	607a      	str	r2, [r7, #4]
 80116e4:	603b      	str	r3, [r7, #0]
	int tab4[4];
	int scalef, scalei, shift;
	int sx, x, y;
	int mask = 0;
 80116e6:	f04f 0300 	mov.w	r3, #0
 80116ea:	63bb      	str	r3, [r7, #56]	; 0x38
	const int *tab16, *coef;

	tab16 = pow43_14[scale & 0x3];
 80116ec:	683b      	ldr	r3, [r7, #0]
 80116ee:	f003 0303 	and.w	r3, r3, #3
 80116f2:	ea4f 1283 	mov.w	r2, r3, lsl #6
 80116f6:	f64b 5358 	movw	r3, #48472	; 0xbd58
 80116fa:	f6c0 0302 	movt	r3, #2050	; 0x802
 80116fe:	18d3      	adds	r3, r2, r3
 8011700:	637b      	str	r3, [r7, #52]	; 0x34
	scalef = pow14[scale & 0x3];
 8011702:	683b      	ldr	r3, [r7, #0]
 8011704:	f003 0203 	and.w	r2, r3, #3
 8011708:	f64b 5348 	movw	r3, #48456	; 0xbd48
 801170c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8011710:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011714:	633b      	str	r3, [r7, #48]	; 0x30
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 8011716:	683b      	ldr	r3, [r7, #0]
 8011718:	ea4f 03a3 	mov.w	r3, r3, asr #2
 801171c:	2b1f      	cmp	r3, #31
 801171e:	bfa8      	it	ge
 8011720:	231f      	movge	r3, #31
 8011722:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* cache first 4 values */
	shift = MIN(scalei + 3, 31);
 8011724:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011726:	f103 0303 	add.w	r3, r3, #3
 801172a:	2b1f      	cmp	r3, #31
 801172c:	bfa8      	it	ge
 801172e:	231f      	movge	r3, #31
 8011730:	647b      	str	r3, [r7, #68]	; 0x44
	shift = MAX(shift, 0);
 8011732:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011734:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8011738:	647b      	str	r3, [r7, #68]	; 0x44
	tab4[0] = 0;
 801173a:	f04f 0300 	mov.w	r3, #0
 801173e:	617b      	str	r3, [r7, #20]
	tab4[1] = tab16[1] >> shift;
 8011740:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011742:	f103 0304 	add.w	r3, r3, #4
 8011746:	681a      	ldr	r2, [r3, #0]
 8011748:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801174a:	fa42 f303 	asr.w	r3, r2, r3
 801174e:	61bb      	str	r3, [r7, #24]
	tab4[2] = tab16[2] >> shift;
 8011750:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011752:	f103 0308 	add.w	r3, r3, #8
 8011756:	681a      	ldr	r2, [r3, #0]
 8011758:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801175a:	fa42 f303 	asr.w	r3, r2, r3
 801175e:	61fb      	str	r3, [r7, #28]
	tab4[3] = tab16[3] >> shift;
 8011760:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011762:	f103 030c 	add.w	r3, r3, #12
 8011766:	681a      	ldr	r2, [r3, #0]
 8011768:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801176a:	fa42 f303 	asr.w	r3, r2, r3
 801176e:	623b      	str	r3, [r7, #32]

	do {

		sx = *inbuf++;
 8011770:	68fb      	ldr	r3, [r7, #12]
 8011772:	681b      	ldr	r3, [r3, #0]
 8011774:	62bb      	str	r3, [r7, #40]	; 0x28
 8011776:	68fb      	ldr	r3, [r7, #12]
 8011778:	f103 0304 	add.w	r3, r3, #4
 801177c:	60fb      	str	r3, [r7, #12]
		x = sx & 0x7fffffff;	/* sx = sign|mag */
 801177e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011780:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8011784:	643b      	str	r3, [r7, #64]	; 0x40

		if (x < 4) {
 8011786:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011788:	2b03      	cmp	r3, #3
 801178a:	dc09      	bgt.n	80117a0 <DequantBlock+0xc8>

			y = tab4[x];
 801178c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801178e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011792:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8011796:	18d3      	adds	r3, r2, r3
 8011798:	f853 3c34 	ldr.w	r3, [r3, #-52]
 801179c:	63fb      	str	r3, [r7, #60]	; 0x3c
 801179e:	e0dc      	b.n	801195a <DequantBlock+0x282>

		} else if (x < 16) {
 80117a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80117a2:	2b0f      	cmp	r3, #15
 80117a4:	dc16      	bgt.n	80117d4 <DequantBlock+0xfc>

			y = tab16[x];
 80117a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80117a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80117ac:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80117ae:	18d3      	adds	r3, r2, r3
 80117b0:	681b      	ldr	r3, [r3, #0]
 80117b2:	63fb      	str	r3, [r7, #60]	; 0x3c
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 80117b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80117b6:	2b00      	cmp	r3, #0
 80117b8:	da06      	bge.n	80117c8 <DequantBlock+0xf0>
 80117ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80117bc:	f1c3 0300 	rsb	r3, r3, #0
 80117c0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80117c2:	fa02 f303 	lsl.w	r3, r2, r3
 80117c6:	e003      	b.n	80117d0 <DequantBlock+0xf8>
 80117c8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80117ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80117cc:	fa42 f303 	asr.w	r3, r2, r3
 80117d0:	63fb      	str	r3, [r7, #60]	; 0x3c
 80117d2:	e0c2      	b.n	801195a <DequantBlock+0x282>

		} else {

			if (x < 64) {
 80117d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80117d6:	2b3f      	cmp	r3, #63	; 0x3f
 80117d8:	dc14      	bgt.n	8011804 <DequantBlock+0x12c>

				y = pow43[x-16];
 80117da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80117dc:	f1a3 0210 	sub.w	r2, r3, #16
 80117e0:	f64b 6358 	movw	r3, #48728	; 0xbe58
 80117e4:	f6c0 0302 	movt	r3, #2050	; 0x802
 80117e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80117ec:	63fb      	str	r3, [r7, #60]	; 0x3c

				/* fractional scale */
				y = MULSHIFT32(y, scalef);
 80117ee:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80117f0:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80117f2:	f7ff ff4f 	bl	8011694 <MULSHIFT32>
 80117f6:	4603      	mov	r3, r0
 80117f8:	63fb      	str	r3, [r7, #60]	; 0x3c
				shift = scalei - 3;
 80117fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80117fc:	f1a3 0303 	sub.w	r3, r3, #3
 8011800:	647b      	str	r3, [r7, #68]	; 0x44
 8011802:	e08c      	b.n	801191e <DequantBlock+0x246>

			} else {

				/* normalize to [0x40000000, 0x7fffffff] */
				x <<= 17;
 8011804:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011806:	ea4f 4343 	mov.w	r3, r3, lsl #17
 801180a:	643b      	str	r3, [r7, #64]	; 0x40
				shift = 0;
 801180c:	f04f 0300 	mov.w	r3, #0
 8011810:	647b      	str	r3, [r7, #68]	; 0x44
				if (x < 0x08000000)
 8011812:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011814:	f06f 4378 	mvn.w	r3, #4160749568	; 0xf8000000
 8011818:	429a      	cmp	r2, r3
 801181a:	dc07      	bgt.n	801182c <DequantBlock+0x154>
					x <<= 4, shift += 4;
 801181c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801181e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8011822:	643b      	str	r3, [r7, #64]	; 0x40
 8011824:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011826:	f103 0304 	add.w	r3, r3, #4
 801182a:	647b      	str	r3, [r7, #68]	; 0x44
				if (x < 0x20000000)
 801182c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801182e:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
 8011832:	429a      	cmp	r2, r3
 8011834:	dc07      	bgt.n	8011846 <DequantBlock+0x16e>
					x <<= 2, shift += 2;
 8011836:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011838:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801183c:	643b      	str	r3, [r7, #64]	; 0x40
 801183e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011840:	f103 0302 	add.w	r3, r3, #2
 8011844:	647b      	str	r3, [r7, #68]	; 0x44
				if (x < 0x40000000)
 8011846:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011848:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 801184c:	429a      	cmp	r2, r3
 801184e:	dc07      	bgt.n	8011860 <DequantBlock+0x188>
					x <<= 1, shift += 1;
 8011850:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011852:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011856:	643b      	str	r3, [r7, #64]	; 0x40
 8011858:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801185a:	f103 0301 	add.w	r3, r3, #1
 801185e:	647b      	str	r3, [r7, #68]	; 0x44

				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
 8011860:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011862:	f647 1399 	movw	r3, #31129	; 0x7999
 8011866:	f6c5 2382 	movt	r3, #23170	; 0x5a82
 801186a:	429a      	cmp	r2, r3
 801186c:	dc04      	bgt.n	8011878 <DequantBlock+0x1a0>
 801186e:	f64b 7318 	movw	r3, #48920	; 0xbf18
 8011872:	f6c0 0302 	movt	r3, #2050	; 0x802
 8011876:	e003      	b.n	8011880 <DequantBlock+0x1a8>
 8011878:	f64b 732c 	movw	r3, #48940	; 0xbf2c
 801187c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8011880:	627b      	str	r3, [r7, #36]	; 0x24

				/* polynomial */
				y = coef[0];
 8011882:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011884:	681b      	ldr	r3, [r3, #0]
 8011886:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, x) + coef[1];
 8011888:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801188a:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801188c:	f7ff ff02 	bl	8011694 <MULSHIFT32>
 8011890:	4602      	mov	r2, r0
 8011892:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011894:	f103 0304 	add.w	r3, r3, #4
 8011898:	681b      	ldr	r3, [r3, #0]
 801189a:	18d3      	adds	r3, r2, r3
 801189c:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, x) + coef[2];
 801189e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80118a0:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80118a2:	f7ff fef7 	bl	8011694 <MULSHIFT32>
 80118a6:	4602      	mov	r2, r0
 80118a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118aa:	f103 0308 	add.w	r3, r3, #8
 80118ae:	681b      	ldr	r3, [r3, #0]
 80118b0:	18d3      	adds	r3, r2, r3
 80118b2:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, x) + coef[3];
 80118b4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80118b6:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80118b8:	f7ff feec 	bl	8011694 <MULSHIFT32>
 80118bc:	4602      	mov	r2, r0
 80118be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118c0:	f103 030c 	add.w	r3, r3, #12
 80118c4:	681b      	ldr	r3, [r3, #0]
 80118c6:	18d3      	adds	r3, r2, r3
 80118c8:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, x) + coef[4];
 80118ca:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80118cc:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80118ce:	f7ff fee1 	bl	8011694 <MULSHIFT32>
 80118d2:	4602      	mov	r2, r0
 80118d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118d6:	f103 0310 	add.w	r3, r3, #16
 80118da:	681b      	ldr	r3, [r3, #0]
 80118dc:	18d3      	adds	r3, r2, r3
 80118de:	63fb      	str	r3, [r7, #60]	; 0x3c
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 80118e0:	f64b 7360 	movw	r3, #48992	; 0xbf60
 80118e4:	f6c0 0302 	movt	r3, #2050	; 0x802
 80118e8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80118ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80118ee:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80118f0:	4619      	mov	r1, r3
 80118f2:	f7ff fecf 	bl	8011694 <MULSHIFT32>
 80118f6:	4603      	mov	r3, r0
 80118f8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80118fc:	63fb      	str	r3, [r7, #60]	; 0x3c

				/* fractional scale */
				y = MULSHIFT32(y, scalef);
 80118fe:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8011900:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8011902:	f7ff fec7 	bl	8011694 <MULSHIFT32>
 8011906:	4603      	mov	r3, r0
 8011908:	63fb      	str	r3, [r7, #60]	; 0x3c
				shift = scalei - pow2exp[shift];
 801190a:	f64b 7340 	movw	r3, #48960	; 0xbf40
 801190e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8011912:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8011914:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011918:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801191a:	1ad3      	subs	r3, r2, r3
 801191c:	647b      	str	r3, [r7, #68]	; 0x44
			}

			/* integer scale */
			if (shift < 0) {
 801191e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011920:	2b00      	cmp	r3, #0
 8011922:	da15      	bge.n	8011950 <DequantBlock+0x278>
				shift = -shift;
 8011924:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011926:	f1c3 0300 	rsb	r3, r3, #0
 801192a:	647b      	str	r3, [r7, #68]	; 0x44
				if (y > (0x7fffffff >> shift))
 801192c:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 8011930:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011932:	fa42 f203 	asr.w	r2, r2, r3
 8011936:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011938:	429a      	cmp	r2, r3
 801193a:	da03      	bge.n	8011944 <DequantBlock+0x26c>
					y = 0x7fffffff;		/* clip */
 801193c:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 8011940:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011942:	e00a      	b.n	801195a <DequantBlock+0x282>
				else
					y <<= shift;
 8011944:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011946:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011948:	fa02 f303 	lsl.w	r3, r2, r3
 801194c:	63fb      	str	r3, [r7, #60]	; 0x3c
 801194e:	e004      	b.n	801195a <DequantBlock+0x282>
			} else {
				y >>= shift;
 8011950:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011952:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011954:	fa42 f303 	asr.w	r3, r2, r3
 8011958:	63fb      	str	r3, [r7, #60]	; 0x3c
			}
		}

		/* sign and store */
		mask |= y;
 801195a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801195c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801195e:	4313      	orrs	r3, r2
 8011960:	63bb      	str	r3, [r7, #56]	; 0x38
		*outbuf++ = (sx < 0) ? -y : y;
 8011962:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011964:	2b00      	cmp	r3, #0
 8011966:	da03      	bge.n	8011970 <DequantBlock+0x298>
 8011968:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801196a:	f1c3 0300 	rsb	r3, r3, #0
 801196e:	e000      	b.n	8011972 <DequantBlock+0x29a>
 8011970:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011972:	68ba      	ldr	r2, [r7, #8]
 8011974:	6013      	str	r3, [r2, #0]
 8011976:	68bb      	ldr	r3, [r7, #8]
 8011978:	f103 0304 	add.w	r3, r3, #4
 801197c:	60bb      	str	r3, [r7, #8]

	} while (--num);
 801197e:	687b      	ldr	r3, [r7, #4]
 8011980:	f103 33ff 	add.w	r3, r3, #4294967295
 8011984:	607b      	str	r3, [r7, #4]
 8011986:	687b      	ldr	r3, [r7, #4]
 8011988:	2b00      	cmp	r3, #0
 801198a:	f47f aef1 	bne.w	8011770 <DequantBlock+0x98>

	return mask;
 801198e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
 8011990:	4618      	mov	r0, r3
 8011992:	f107 0748 	add.w	r7, r7, #72	; 0x48
 8011996:	46bd      	mov	sp, r7
 8011998:	bd80      	pop	{r7, pc}
 801199a:	bf00      	nop

0801199c <xmp3_DequantChannel>:
 *
 * Notes:       dequantized samples in Q(DQ_FRACBITS_OUT) format 
 **************************************************************************************/
int DequantChannel(int *sampleBuf, int *workBuf, int *nonZeroBound, FrameHeader *fh, SideInfoSub *sis, 
					ScaleFactorInfoSub *sfis, CriticalBandInfo *cbi)
{
 801199c:	b580      	push	{r7, lr}
 801199e:	b096      	sub	sp, #88	; 0x58
 80119a0:	af00      	add	r7, sp, #0
 80119a2:	60f8      	str	r0, [r7, #12]
 80119a4:	60b9      	str	r1, [r7, #8]
 80119a6:	607a      	str	r2, [r7, #4]
 80119a8:	603b      	str	r3, [r7, #0]
	int globalGain, gainI;
	int cbMax[3];
	ARRAY3 *buf;    /* short block reorder */
	
	/* set default start/end points for short/long blocks - will update with non-zero cb info */
	if (sis->blockType == 2) {
 80119aa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80119ac:	695b      	ldr	r3, [r3, #20]
 80119ae:	2b02      	cmp	r3, #2
 80119b0:	d11b      	bne.n	80119ea <xmp3_DequantChannel+0x4e>
//		cbStartL = 0;
		if (sis->mixedBlock) { 
 80119b2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80119b4:	699b      	ldr	r3, [r3, #24]
 80119b6:	2b00      	cmp	r3, #0
 80119b8:	d00d      	beq.n	80119d6 <xmp3_DequantChannel+0x3a>
			cbEndL = (fh->ver == MPEG1 ? 8 : 6); 
 80119ba:	683b      	ldr	r3, [r7, #0]
 80119bc:	781b      	ldrb	r3, [r3, #0]
 80119be:	2b00      	cmp	r3, #0
 80119c0:	d102      	bne.n	80119c8 <xmp3_DequantChannel+0x2c>
 80119c2:	f04f 0308 	mov.w	r3, #8
 80119c6:	e001      	b.n	80119cc <xmp3_DequantChannel+0x30>
 80119c8:	f04f 0306 	mov.w	r3, #6
 80119cc:	647b      	str	r3, [r7, #68]	; 0x44
			cbStartS = 3; 
 80119ce:	f04f 0303 	mov.w	r3, #3
 80119d2:	643b      	str	r3, [r7, #64]	; 0x40
 80119d4:	e005      	b.n	80119e2 <xmp3_DequantChannel+0x46>
		} else {
			cbEndL = 0; 
 80119d6:	f04f 0300 	mov.w	r3, #0
 80119da:	647b      	str	r3, [r7, #68]	; 0x44
			cbStartS = 0;
 80119dc:	f04f 0300 	mov.w	r3, #0
 80119e0:	643b      	str	r3, [r7, #64]	; 0x40
		}
		cbEndS = 13;
 80119e2:	f04f 030d 	mov.w	r3, #13
 80119e6:	63fb      	str	r3, [r7, #60]	; 0x3c
 80119e8:	e008      	b.n	80119fc <xmp3_DequantChannel+0x60>
	} else {
		/* long block */
//		cbStartL = 0;
		cbEndL =   22;
 80119ea:	f04f 0316 	mov.w	r3, #22
 80119ee:	647b      	str	r3, [r7, #68]	; 0x44
		cbStartS = 13;
 80119f0:	f04f 030d 	mov.w	r3, #13
 80119f4:	643b      	str	r3, [r7, #64]	; 0x40
		cbEndS =   13;
 80119f6:	f04f 030d 	mov.w	r3, #13
 80119fa:	63fb      	str	r3, [r7, #60]	; 0x3c
	}
	cbMax[2] = cbMax[1] = cbMax[0] = 0;
 80119fc:	f04f 0300 	mov.w	r3, #0
 8011a00:	617b      	str	r3, [r7, #20]
 8011a02:	697b      	ldr	r3, [r7, #20]
 8011a04:	61bb      	str	r3, [r7, #24]
 8011a06:	69bb      	ldr	r3, [r7, #24]
 8011a08:	61fb      	str	r3, [r7, #28]
	gbMask = 0;
 8011a0a:	f04f 0300 	mov.w	r3, #0
 8011a0e:	63bb      	str	r3, [r7, #56]	; 0x38
	i = 0;
 8011a10:	f04f 0300 	mov.w	r3, #0
 8011a14:	657b      	str	r3, [r7, #84]	; 0x54

	/* sfactScale = 0 --> quantizer step size = 2
	 * sfactScale = 1 --> quantizer step size = sqrt(2)
	 *   so sfactMultiplier = 2 or 4 (jump through globalGain by powers of 2 or sqrt(2))
	 */
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 8011a16:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011a18:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8011a1a:	f103 0301 	add.w	r3, r3, #1
 8011a1e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011a22:	633b      	str	r3, [r7, #48]	; 0x30

	/* offset globalGain by -2 if midSide enabled, for 1/sqrt(2) used in MidSideProc()
	 *  (DequantBlock() does 0.25 * gainI so knocking it down by two is the same as 
	 *   dividing every sample by sqrt(2) = multiplying by 2^-.5)
	 */
	globalGain = sis->globalGain;
 8011a24:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011a26:	689b      	ldr	r3, [r3, #8]
 8011a28:	637b      	str	r3, [r7, #52]	; 0x34
	if (fh->modeExt >> 1)
 8011a2a:	683b      	ldr	r3, [r7, #0]
 8011a2c:	6a1b      	ldr	r3, [r3, #32]
 8011a2e:	ea4f 0363 	mov.w	r3, r3, asr #1
 8011a32:	2b00      	cmp	r3, #0
 8011a34:	d003      	beq.n	8011a3e <xmp3_DequantChannel+0xa2>
		 globalGain -= 2;
 8011a36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011a38:	f1a3 0302 	sub.w	r3, r3, #2
 8011a3c:	637b      	str	r3, [r7, #52]	; 0x34
	globalGain += IMDCT_SCALE;		/* scale everything by sqrt(2), for fast IMDCT36 */
 8011a3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011a40:	f103 0302 	add.w	r3, r3, #2
 8011a44:	637b      	str	r3, [r7, #52]	; 0x34

	/* long blocks */
	for (cb = 0; cb < cbEndL; cb++) {
 8011a46:	f04f 0300 	mov.w	r3, #0
 8011a4a:	64bb      	str	r3, [r7, #72]	; 0x48
 8011a4c:	e058      	b.n	8011b00 <xmp3_DequantChannel+0x164>

		nonZero = 0;
 8011a4e:	f04f 0300 	mov.w	r3, #0
 8011a52:	62fb      	str	r3, [r7, #44]	; 0x2c
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8011a54:	683b      	ldr	r3, [r7, #0]
 8011a56:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011a58:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011a5a:	f102 0201 	add.w	r2, r2, #1
 8011a5e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8011a62:	b21a      	sxth	r2, r3
 8011a64:	683b      	ldr	r3, [r7, #0]
 8011a66:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011a68:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8011a6a:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8011a6e:	b21b      	sxth	r3, r3
 8011a70:	1ad3      	subs	r3, r2, r3
 8011a72:	62bb      	str	r3, [r7, #40]	; 0x28
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 8011a74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011a76:	f1c3 02d2 	rsb	r2, r3, #210	; 0xd2
 8011a7a:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8011a7c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a7e:	18cb      	adds	r3, r1, r3
 8011a80:	781b      	ldrb	r3, [r3, #0]
 8011a82:	4619      	mov	r1, r3
 8011a84:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011a86:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011a88:	2b00      	cmp	r3, #0
 8011a8a:	d007      	beq.n	8011a9c <xmp3_DequantChannel+0x100>
 8011a8c:	f64b 5330 	movw	r3, #48432	; 0xbd30
 8011a90:	f6c0 0302 	movt	r3, #2050	; 0x802
 8011a94:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8011a96:	181b      	adds	r3, r3, r0
 8011a98:	781b      	ldrb	r3, [r3, #0]
 8011a9a:	e001      	b.n	8011aa0 <xmp3_DequantChannel+0x104>
 8011a9c:	f04f 0300 	mov.w	r3, #0
 8011aa0:	18cb      	adds	r3, r1, r3
 8011aa2:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8011aa4:	fb01 f303 	mul.w	r3, r1, r3
 8011aa8:	18d3      	adds	r3, r2, r3
 8011aaa:	627b      	str	r3, [r7, #36]	; 0x24

		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 8011aac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011aae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011ab2:	68fa      	ldr	r2, [r7, #12]
 8011ab4:	18d2      	adds	r2, r2, r3
 8011ab6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011ab8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011abc:	68f9      	ldr	r1, [r7, #12]
 8011abe:	18cb      	adds	r3, r1, r3
 8011ac0:	4610      	mov	r0, r2
 8011ac2:	4619      	mov	r1, r3
 8011ac4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011ac6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ac8:	f7ff fe06 	bl	80116d8 <DequantBlock>
 8011acc:	4603      	mov	r3, r0
 8011ace:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011ad0:	4313      	orrs	r3, r2
 8011ad2:	62fb      	str	r3, [r7, #44]	; 0x2c
		i += nSamps;
 8011ad4:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8011ad6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011ad8:	18d3      	adds	r3, r2, r3
 8011ada:	657b      	str	r3, [r7, #84]	; 0x54

		/* update highest non-zero critical band */
		if (nonZero) 
 8011adc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ade:	2b00      	cmp	r3, #0
 8011ae0:	d001      	beq.n	8011ae6 <xmp3_DequantChannel+0x14a>
			cbMax[0] = cb;
 8011ae2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011ae4:	617b      	str	r3, [r7, #20]
		gbMask |= nonZero;
 8011ae6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8011ae8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011aea:	4313      	orrs	r3, r2
 8011aec:	63bb      	str	r3, [r7, #56]	; 0x38

		if (i >= *nonZeroBound) 
 8011aee:	687b      	ldr	r3, [r7, #4]
 8011af0:	681a      	ldr	r2, [r3, #0]
 8011af2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011af4:	429a      	cmp	r2, r3
 8011af6:	dd08      	ble.n	8011b0a <xmp3_DequantChannel+0x16e>
	if (fh->modeExt >> 1)
		 globalGain -= 2;
	globalGain += IMDCT_SCALE;		/* scale everything by sqrt(2), for fast IMDCT36 */

	/* long blocks */
	for (cb = 0; cb < cbEndL; cb++) {
 8011af8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011afa:	f103 0301 	add.w	r3, r3, #1
 8011afe:	64bb      	str	r3, [r7, #72]	; 0x48
 8011b00:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011b02:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011b04:	429a      	cmp	r2, r3
 8011b06:	dba2      	blt.n	8011a4e <xmp3_DequantChannel+0xb2>
 8011b08:	e000      	b.n	8011b0c <xmp3_DequantChannel+0x170>
		if (nonZero) 
			cbMax[0] = cb;
		gbMask |= nonZero;

		if (i >= *nonZeroBound) 
			break;
 8011b0a:	bf00      	nop
	}

	/* set cbi (Type, EndS[], EndSMax will be overwritten if we proceed to do short blocks) */
	cbi->cbType = 0;			/* long only */
 8011b0c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011b0e:	f04f 0200 	mov.w	r2, #0
 8011b12:	601a      	str	r2, [r3, #0]
	cbi->cbEndL  = cbMax[0];
 8011b14:	697a      	ldr	r2, [r7, #20]
 8011b16:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011b18:	615a      	str	r2, [r3, #20]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 8011b1a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011b1c:	f04f 0200 	mov.w	r2, #0
 8011b20:	60da      	str	r2, [r3, #12]
 8011b22:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011b24:	68da      	ldr	r2, [r3, #12]
 8011b26:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011b28:	609a      	str	r2, [r3, #8]
 8011b2a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011b2c:	689a      	ldr	r2, [r3, #8]
 8011b2e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011b30:	605a      	str	r2, [r3, #4]
	cbi->cbEndSMax = 0;
 8011b32:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011b34:	f04f 0200 	mov.w	r2, #0
 8011b38:	611a      	str	r2, [r3, #16]

	/* early exit if no short blocks */
	if (cbStartS >= 12) 
 8011b3a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011b3c:	2b0b      	cmp	r3, #11
 8011b3e:	dd06      	ble.n	8011b4e <xmp3_DequantChannel+0x1b2>
		return CLZ(gbMask) - 1;
 8011b40:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8011b42:	f7ff fdb9 	bl	80116b8 <CLZ>
 8011b46:	4603      	mov	r3, r0
 8011b48:	f103 33ff 	add.w	r3, r3, #4294967295
 8011b4c:	e108      	b.n	8011d60 <xmp3_DequantChannel+0x3c4>
	
	/* short blocks */
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
 8011b4e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011b50:	617b      	str	r3, [r7, #20]
 8011b52:	697b      	ldr	r3, [r7, #20]
 8011b54:	61bb      	str	r3, [r7, #24]
 8011b56:	69bb      	ldr	r3, [r7, #24]
 8011b58:	61fb      	str	r3, [r7, #28]
	for (cb = cbStartS; cb < cbEndS; cb++) {
 8011b5a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011b5c:	64bb      	str	r3, [r7, #72]	; 0x48
 8011b5e:	e0c8      	b.n	8011cf2 <xmp3_DequantChannel+0x356>

		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8011b60:	683b      	ldr	r3, [r7, #0]
 8011b62:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8011b64:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011b66:	f103 0301 	add.w	r3, r3, #1
 8011b6a:	f103 0314 	add.w	r3, r3, #20
 8011b6e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011b72:	18d3      	adds	r3, r2, r3
 8011b74:	88db      	ldrh	r3, [r3, #6]
 8011b76:	b21a      	sxth	r2, r3
 8011b78:	683b      	ldr	r3, [r7, #0]
 8011b7a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8011b7c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011b7e:	f103 0314 	add.w	r3, r3, #20
 8011b82:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011b86:	18cb      	adds	r3, r1, r3
 8011b88:	88db      	ldrh	r3, [r3, #6]
 8011b8a:	b21b      	sxth	r3, r3
 8011b8c:	1ad3      	subs	r3, r2, r3
 8011b8e:	62bb      	str	r3, [r7, #40]	; 0x28
		for (w = 0; w < 3; w++) {
 8011b90:	f04f 0300 	mov.w	r3, #0
 8011b94:	64fb      	str	r3, [r7, #76]	; 0x4c
 8011b96:	e050      	b.n	8011c3a <xmp3_DequantChannel+0x29e>
			nonZero =  0;
 8011b98:	f04f 0300 	mov.w	r3, #0
 8011b9c:	62fb      	str	r3, [r7, #44]	; 0x2c
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
 8011b9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ba0:	f1c3 01d2 	rsb	r1, r3, #210	; 0xd2
 8011ba4:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8011ba6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011ba8:	4613      	mov	r3, r2
 8011baa:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011bae:	189b      	adds	r3, r3, r2
 8011bb0:	18c2      	adds	r2, r0, r3
 8011bb2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011bb4:	18d3      	adds	r3, r2, r3
 8011bb6:	f103 0317 	add.w	r3, r3, #23
 8011bba:	781b      	ldrb	r3, [r3, #0]
 8011bbc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011bbe:	fb02 f203 	mul.w	r2, r2, r3
 8011bc2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011bc4:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8011bc6:	f100 000a 	add.w	r0, r0, #10
 8011bca:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8011bce:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8011bd2:	18d3      	adds	r3, r2, r3
 8011bd4:	18cb      	adds	r3, r1, r3
 8011bd6:	627b      	str	r3, [r7, #36]	; 0x24

			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 8011bd8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011bda:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8011bdc:	fb02 f303 	mul.w	r3, r2, r3
 8011be0:	461a      	mov	r2, r3
 8011be2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011be4:	18d3      	adds	r3, r2, r3
 8011be6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011bea:	68fa      	ldr	r2, [r7, #12]
 8011bec:	18d2      	adds	r2, r2, r3
 8011bee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011bf0:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8011bf2:	fb01 f303 	mul.w	r3, r1, r3
 8011bf6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011bfa:	68b9      	ldr	r1, [r7, #8]
 8011bfc:	18cb      	adds	r3, r1, r3
 8011bfe:	4610      	mov	r0, r2
 8011c00:	4619      	mov	r1, r3
 8011c02:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011c04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011c06:	f7ff fd67 	bl	80116d8 <DequantBlock>
 8011c0a:	4603      	mov	r3, r0
 8011c0c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011c0e:	4313      	orrs	r3, r2
 8011c10:	62fb      	str	r3, [r7, #44]	; 0x2c

			/* update highest non-zero critical band */
			if (nonZero)
 8011c12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011c14:	2b00      	cmp	r3, #0
 8011c16:	d008      	beq.n	8011c2a <xmp3_DequantChannel+0x28e>
				cbMax[w] = cb;
 8011c18:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011c1e:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8011c22:	18d3      	adds	r3, r2, r3
 8011c24:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011c26:	f843 2c44 	str.w	r2, [r3, #-68]
			gbMask |= nonZero;
 8011c2a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8011c2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011c2e:	4313      	orrs	r3, r2
 8011c30:	63bb      	str	r3, [r7, #56]	; 0x38
	/* short blocks */
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
	for (cb = cbStartS; cb < cbEndS; cb++) {

		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
		for (w = 0; w < 3; w++) {
 8011c32:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c34:	f103 0301 	add.w	r3, r3, #1
 8011c38:	64fb      	str	r3, [r7, #76]	; 0x4c
 8011c3a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c3c:	2b02      	cmp	r3, #2
 8011c3e:	ddab      	ble.n	8011b98 <xmp3_DequantChannel+0x1fc>
				cbMax[w] = cb;
			gbMask |= nonZero;
		}

		/* reorder blocks */
		buf = (ARRAY3 *)(sampleBuf + i);
 8011c40:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011c42:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011c46:	68fa      	ldr	r2, [r7, #12]
 8011c48:	18d3      	adds	r3, r2, r3
 8011c4a:	623b      	str	r3, [r7, #32]
		i += 3*nSamps;
 8011c4c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011c4e:	4613      	mov	r3, r2
 8011c50:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011c54:	189b      	adds	r3, r3, r2
 8011c56:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8011c58:	18d3      	adds	r3, r2, r3
 8011c5a:	657b      	str	r3, [r7, #84]	; 0x54
		for (j = 0; j < nSamps; j++) {
 8011c5c:	f04f 0300 	mov.w	r3, #0
 8011c60:	653b      	str	r3, [r7, #80]	; 0x50
 8011c62:	e039      	b.n	8011cd8 <xmp3_DequantChannel+0x33c>
			buf[j][0] = workBuf[0*nSamps + j];
 8011c64:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011c66:	4613      	mov	r3, r2
 8011c68:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011c6c:	189b      	adds	r3, r3, r2
 8011c6e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011c72:	6a3a      	ldr	r2, [r7, #32]
 8011c74:	18d3      	adds	r3, r2, r3
 8011c76:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011c78:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8011c7c:	68b9      	ldr	r1, [r7, #8]
 8011c7e:	188a      	adds	r2, r1, r2
 8011c80:	6812      	ldr	r2, [r2, #0]
 8011c82:	601a      	str	r2, [r3, #0]
			buf[j][1] = workBuf[1*nSamps + j];
 8011c84:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011c86:	4613      	mov	r3, r2
 8011c88:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011c8c:	189b      	adds	r3, r3, r2
 8011c8e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011c92:	6a3a      	ldr	r2, [r7, #32]
 8011c94:	18d3      	adds	r3, r2, r3
 8011c96:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8011c98:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011c9a:	188a      	adds	r2, r1, r2
 8011c9c:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8011ca0:	68b9      	ldr	r1, [r7, #8]
 8011ca2:	188a      	adds	r2, r1, r2
 8011ca4:	6812      	ldr	r2, [r2, #0]
 8011ca6:	605a      	str	r2, [r3, #4]
			buf[j][2] = workBuf[2*nSamps + j];
 8011ca8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011caa:	4613      	mov	r3, r2
 8011cac:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011cb0:	189b      	adds	r3, r3, r2
 8011cb2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011cb6:	6a3a      	ldr	r2, [r7, #32]
 8011cb8:	18d3      	adds	r3, r2, r3
 8011cba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011cbc:	ea4f 0142 	mov.w	r1, r2, lsl #1
 8011cc0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011cc2:	188a      	adds	r2, r1, r2
 8011cc4:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8011cc8:	68b9      	ldr	r1, [r7, #8]
 8011cca:	188a      	adds	r2, r1, r2
 8011ccc:	6812      	ldr	r2, [r2, #0]
 8011cce:	609a      	str	r2, [r3, #8]
		}

		/* reorder blocks */
		buf = (ARRAY3 *)(sampleBuf + i);
		i += 3*nSamps;
		for (j = 0; j < nSamps; j++) {
 8011cd0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011cd2:	f103 0301 	add.w	r3, r3, #1
 8011cd6:	653b      	str	r3, [r7, #80]	; 0x50
 8011cd8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011cda:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011cdc:	429a      	cmp	r2, r3
 8011cde:	dbc1      	blt.n	8011c64 <xmp3_DequantChannel+0x2c8>
			buf[j][2] = workBuf[2*nSamps + j];
		}

		ASSERT(3*nSamps <= MAX_REORDER_SAMPS);

		if (i >= *nonZeroBound) 
 8011ce0:	687b      	ldr	r3, [r7, #4]
 8011ce2:	681a      	ldr	r2, [r3, #0]
 8011ce4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011ce6:	429a      	cmp	r2, r3
 8011ce8:	dd09      	ble.n	8011cfe <xmp3_DequantChannel+0x362>
	if (cbStartS >= 12) 
		return CLZ(gbMask) - 1;
	
	/* short blocks */
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
	for (cb = cbStartS; cb < cbEndS; cb++) {
 8011cea:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011cec:	f103 0301 	add.w	r3, r3, #1
 8011cf0:	64bb      	str	r3, [r7, #72]	; 0x48
 8011cf2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011cf4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011cf6:	429a      	cmp	r2, r3
 8011cf8:	f6ff af32 	blt.w	8011b60 <xmp3_DequantChannel+0x1c4>
 8011cfc:	e000      	b.n	8011d00 <xmp3_DequantChannel+0x364>
		}

		ASSERT(3*nSamps <= MAX_REORDER_SAMPS);

		if (i >= *nonZeroBound) 
			break;
 8011cfe:	bf00      	nop
	 * however, the original nzb is no longer necessarily true
	 *   for each cb, buf[][] is updated with 3*nSamps samples (i increases 3*nSamps each time)
	 *   (buf[j + 1][0] = 3 (input) samples ahead of buf[j][0])
     * so update nonZeroBound to i
	 */
	*nonZeroBound = i;
 8011d00:	687b      	ldr	r3, [r7, #4]
 8011d02:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8011d04:	601a      	str	r2, [r3, #0]

	ASSERT(*nonZeroBound <= MAX_NSAMP);

	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 8011d06:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011d08:	699b      	ldr	r3, [r3, #24]
 8011d0a:	2b00      	cmp	r3, #0
 8011d0c:	d002      	beq.n	8011d14 <xmp3_DequantChannel+0x378>
 8011d0e:	f04f 0302 	mov.w	r3, #2
 8011d12:	e001      	b.n	8011d18 <xmp3_DequantChannel+0x37c>
 8011d14:	f04f 0301 	mov.w	r3, #1
 8011d18:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8011d1a:	6013      	str	r3, [r2, #0]

	cbi->cbEndS[0] = cbMax[0];
 8011d1c:	697a      	ldr	r2, [r7, #20]
 8011d1e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011d20:	605a      	str	r2, [r3, #4]
	cbi->cbEndS[1] = cbMax[1];
 8011d22:	69ba      	ldr	r2, [r7, #24]
 8011d24:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011d26:	609a      	str	r2, [r3, #8]
	cbi->cbEndS[2] = cbMax[2];
 8011d28:	69fa      	ldr	r2, [r7, #28]
 8011d2a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011d2c:	60da      	str	r2, [r3, #12]

	cbi->cbEndSMax = cbMax[0];
 8011d2e:	697a      	ldr	r2, [r7, #20]
 8011d30:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011d32:	611a      	str	r2, [r3, #16]
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[1]);
 8011d34:	69ba      	ldr	r2, [r7, #24]
 8011d36:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011d38:	691b      	ldr	r3, [r3, #16]
 8011d3a:	429a      	cmp	r2, r3
 8011d3c:	bfb8      	it	lt
 8011d3e:	461a      	movlt	r2, r3
 8011d40:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011d42:	611a      	str	r2, [r3, #16]
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 8011d44:	69fa      	ldr	r2, [r7, #28]
 8011d46:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011d48:	691b      	ldr	r3, [r3, #16]
 8011d4a:	429a      	cmp	r2, r3
 8011d4c:	bfb8      	it	lt
 8011d4e:	461a      	movlt	r2, r3
 8011d50:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011d52:	611a      	str	r2, [r3, #16]

	return CLZ(gbMask) - 1;
 8011d54:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8011d56:	f7ff fcaf 	bl	80116b8 <CLZ>
 8011d5a:	4603      	mov	r3, r0
 8011d5c:	f103 33ff 	add.w	r3, r3, #4294967295
}
 8011d60:	4618      	mov	r0, r3
 8011d62:	f107 0758 	add.w	r7, r7, #88	; 0x58
 8011d66:	46bd      	mov	sp, r7
 8011d68:	bd80      	pop	{r7, pc}
 8011d6a:	bf00      	nop

08011d6c <DecodeHuffmanPairs>:
 * Notes:       assumes that nVals is an even number
 *              si_huff.bit tests every Huffman codeword in every table (though not
 *                necessarily all linBits outputs for x,y > 15)
 **************************************************************************************/
static int DecodeHuffmanPairs(int *xy, int nVals, int tabIdx, int bitsLeft, unsigned char *buf, int bitOffset)
{
 8011d6c:	b480      	push	{r7}
 8011d6e:	b095      	sub	sp, #84	; 0x54
 8011d70:	af00      	add	r7, sp, #0
 8011d72:	60f8      	str	r0, [r7, #12]
 8011d74:	60b9      	str	r1, [r7, #8]
 8011d76:	607a      	str	r2, [r7, #4]
 8011d78:	603b      	str	r3, [r7, #0]
	int cachedBits, padBits, len, startBits, linBits, maxBits, minBits;
	HuffTabType tabType;
	unsigned short cw, *tBase, *tCurr;
	unsigned int cache;

	if(nVals <= 0) 
 8011d7a:	68bb      	ldr	r3, [r7, #8]
 8011d7c:	2b00      	cmp	r3, #0
 8011d7e:	dc02      	bgt.n	8011d86 <DecodeHuffmanPairs+0x1a>
		return 0;
 8011d80:	f04f 0300 	mov.w	r3, #0
 8011d84:	e32b      	b.n	80123de <DecodeHuffmanPairs+0x672>

	if (bitsLeft < 0)
 8011d86:	683b      	ldr	r3, [r7, #0]
 8011d88:	2b00      	cmp	r3, #0
 8011d8a:	da02      	bge.n	8011d92 <DecodeHuffmanPairs+0x26>
		return -1;
 8011d8c:	f04f 33ff 	mov.w	r3, #4294967295
 8011d90:	e325      	b.n	80123de <DecodeHuffmanPairs+0x672>
	startBits = bitsLeft;
 8011d92:	683b      	ldr	r3, [r7, #0]
 8011d94:	633b      	str	r3, [r7, #48]	; 0x30

	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 8011d96:	f24e 03a4 	movw	r3, #57508	; 0xe0a4
 8011d9a:	f6c0 0302 	movt	r3, #2050	; 0x802
 8011d9e:	687a      	ldr	r2, [r7, #4]
 8011da0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011da4:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8011da8:	f64b 7380 	movw	r3, #49024	; 0xbf80
 8011dac:	f6c0 0302 	movt	r3, #2050	; 0x802
 8011db0:	18d3      	adds	r3, r2, r3
 8011db2:	62fb      	str	r3, [r7, #44]	; 0x2c
	linBits = huffTabLookup[tabIdx].linBits;
 8011db4:	f24e 1324 	movw	r3, #57636	; 0xe124
 8011db8:	f6c0 0302 	movt	r3, #2050	; 0x802
 8011dbc:	687a      	ldr	r2, [r7, #4]
 8011dbe:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8011dc2:	62bb      	str	r3, [r7, #40]	; 0x28
	tabType = huffTabLookup[tabIdx].tabType;
 8011dc4:	f24e 1224 	movw	r2, #57636	; 0xe124
 8011dc8:	f6c0 0202 	movt	r2, #2050	; 0x802
 8011dcc:	687b      	ldr	r3, [r7, #4]
 8011dce:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8011dd2:	18d3      	adds	r3, r2, r3
 8011dd4:	791b      	ldrb	r3, [r3, #4]
 8011dd6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	ASSERT(tabIdx < HUFF_PAIRTABS);
	ASSERT(tabIdx >= 0);
	ASSERT(tabType != invalidTab);

	/* initially fill cache with any partial byte */
	cache = 0;
 8011dda:	f04f 0300 	mov.w	r3, #0
 8011dde:	637b      	str	r3, [r7, #52]	; 0x34
	cachedBits = (8 - bitOffset) & 0x07;
 8011de0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8011de2:	f1c3 0300 	rsb	r3, r3, #0
 8011de6:	f003 0307 	and.w	r3, r3, #7
 8011dea:	643b      	str	r3, [r7, #64]	; 0x40
	if (cachedBits)
 8011dec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011dee:	2b00      	cmp	r3, #0
 8011df0:	d00c      	beq.n	8011e0c <DecodeHuffmanPairs+0xa0>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 8011df2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011df4:	781b      	ldrb	r3, [r3, #0]
 8011df6:	461a      	mov	r2, r3
 8011df8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011dfa:	f1c3 0320 	rsb	r3, r3, #32
 8011dfe:	fa02 f303 	lsl.w	r3, r2, r3
 8011e02:	637b      	str	r3, [r7, #52]	; 0x34
 8011e04:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011e06:	f103 0301 	add.w	r3, r3, #1
 8011e0a:	65bb      	str	r3, [r7, #88]	; 0x58
	bitsLeft -= cachedBits;
 8011e0c:	683a      	ldr	r2, [r7, #0]
 8011e0e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011e10:	1ad3      	subs	r3, r2, r3
 8011e12:	603b      	str	r3, [r7, #0]

	if (tabType == noBits) {
 8011e14:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011e18:	2b00      	cmp	r3, #0
 8011e1a:	d120      	bne.n	8011e5e <DecodeHuffmanPairs+0xf2>
		/* table 0, no data, x = y = 0 */
		for (i = 0; i < nVals; i+=2) {
 8011e1c:	f04f 0300 	mov.w	r3, #0
 8011e20:	64fb      	str	r3, [r7, #76]	; 0x4c
 8011e22:	e015      	b.n	8011e50 <DecodeHuffmanPairs+0xe4>
			xy[i+0] = 0;
 8011e24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e26:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011e2a:	68fa      	ldr	r2, [r7, #12]
 8011e2c:	18d3      	adds	r3, r2, r3
 8011e2e:	f04f 0200 	mov.w	r2, #0
 8011e32:	601a      	str	r2, [r3, #0]
			xy[i+1] = 0;
 8011e34:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e36:	f103 0301 	add.w	r3, r3, #1
 8011e3a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8011e3e:	68fa      	ldr	r2, [r7, #12]
 8011e40:	18d3      	adds	r3, r2, r3
 8011e42:	f04f 0200 	mov.w	r2, #0
 8011e46:	601a      	str	r2, [r3, #0]
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
	bitsLeft -= cachedBits;

	if (tabType == noBits) {
		/* table 0, no data, x = y = 0 */
		for (i = 0; i < nVals; i+=2) {
 8011e48:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e4a:	f103 0302 	add.w	r3, r3, #2
 8011e4e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8011e50:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8011e52:	68bb      	ldr	r3, [r7, #8]
 8011e54:	429a      	cmp	r2, r3
 8011e56:	dbe5      	blt.n	8011e24 <DecodeHuffmanPairs+0xb8>
			xy[i+0] = 0;
			xy[i+1] = 0;
		}
		return 0;
 8011e58:	f04f 0300 	mov.w	r3, #0
 8011e5c:	e2bf      	b.n	80123de <DecodeHuffmanPairs+0x672>
	} else if (tabType == oneShot) {
 8011e5e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8011e62:	2b01      	cmp	r3, #1
 8011e64:	f040 80f5 	bne.w	8012052 <DecodeHuffmanPairs+0x2e6>
		/* single lookup, no escapes */
		maxBits = GetMaxbits(tBase[0]);
 8011e68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011e6a:	881b      	ldrh	r3, [r3, #0]
 8011e6c:	f003 030f 	and.w	r3, r3, #15
 8011e70:	623b      	str	r3, [r7, #32]
		tBase++;
 8011e72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011e74:	f103 0302 	add.w	r3, r3, #2
 8011e78:	62fb      	str	r3, [r7, #44]	; 0x2c
		padBits = 0;
 8011e7a:	f04f 0300 	mov.w	r3, #0
 8011e7e:	63fb      	str	r3, [r7, #60]	; 0x3c
		while (nVals > 0) {
 8011e80:	e0d9      	b.n	8012036 <DecodeHuffmanPairs+0x2ca>
			/* refill cache - assumes cachedBits <= 16 */
			if (bitsLeft >= 16) {
 8011e82:	683b      	ldr	r3, [r7, #0]
 8011e84:	2b0f      	cmp	r3, #15
 8011e86:	dd26      	ble.n	8011ed6 <DecodeHuffmanPairs+0x16a>
				/* load 2 new bytes into left-justified cache */
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 8011e88:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011e8a:	781b      	ldrb	r3, [r3, #0]
 8011e8c:	461a      	mov	r2, r3
 8011e8e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011e90:	f1c3 0318 	rsb	r3, r3, #24
 8011e94:	fa02 f303 	lsl.w	r3, r2, r3
 8011e98:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011e9a:	4313      	orrs	r3, r2
 8011e9c:	637b      	str	r3, [r7, #52]	; 0x34
 8011e9e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011ea0:	f103 0301 	add.w	r3, r3, #1
 8011ea4:	65bb      	str	r3, [r7, #88]	; 0x58
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 8011ea6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011ea8:	781b      	ldrb	r3, [r3, #0]
 8011eaa:	461a      	mov	r2, r3
 8011eac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011eae:	f1c3 0310 	rsb	r3, r3, #16
 8011eb2:	fa02 f303 	lsl.w	r3, r2, r3
 8011eb6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011eb8:	4313      	orrs	r3, r2
 8011eba:	637b      	str	r3, [r7, #52]	; 0x34
 8011ebc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011ebe:	f103 0301 	add.w	r3, r3, #1
 8011ec2:	65bb      	str	r3, [r7, #88]	; 0x58
				cachedBits += 16;
 8011ec4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011ec6:	f103 0310 	add.w	r3, r3, #16
 8011eca:	643b      	str	r3, [r7, #64]	; 0x40
				bitsLeft -= 16;
 8011ecc:	683b      	ldr	r3, [r7, #0]
 8011ece:	f1a3 0310 	sub.w	r3, r3, #16
 8011ed2:	603b      	str	r3, [r7, #0]
				padBits = 11;
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
			}

			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
			while (nVals > 0 && cachedBits >= 11 ) {
 8011ed4:	e0a9      	b.n	801202a <DecodeHuffmanPairs+0x2be>
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
				cachedBits += 16;
				bitsLeft -= 16;
			} else {
				/* last time through, pad cache with zeros and drain cache */
				if (cachedBits + bitsLeft <= 0)	return -1;
 8011ed6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011ed8:	683b      	ldr	r3, [r7, #0]
 8011eda:	18d3      	adds	r3, r2, r3
 8011edc:	2b00      	cmp	r3, #0
 8011ede:	dc02      	bgt.n	8011ee6 <DecodeHuffmanPairs+0x17a>
 8011ee0:	f04f 33ff 	mov.w	r3, #4294967295
 8011ee4:	e27b      	b.n	80123de <DecodeHuffmanPairs+0x672>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 8011ee6:	683b      	ldr	r3, [r7, #0]
 8011ee8:	2b00      	cmp	r3, #0
 8011eea:	dd0e      	ble.n	8011f0a <DecodeHuffmanPairs+0x19e>
 8011eec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011eee:	781b      	ldrb	r3, [r3, #0]
 8011ef0:	461a      	mov	r2, r3
 8011ef2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011ef4:	f1c3 0318 	rsb	r3, r3, #24
 8011ef8:	fa02 f303 	lsl.w	r3, r2, r3
 8011efc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011efe:	4313      	orrs	r3, r2
 8011f00:	637b      	str	r3, [r7, #52]	; 0x34
 8011f02:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011f04:	f103 0301 	add.w	r3, r3, #1
 8011f08:	65bb      	str	r3, [r7, #88]	; 0x58
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 8011f0a:	683b      	ldr	r3, [r7, #0]
 8011f0c:	2b08      	cmp	r3, #8
 8011f0e:	dd0e      	ble.n	8011f2e <DecodeHuffmanPairs+0x1c2>
 8011f10:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011f12:	781b      	ldrb	r3, [r3, #0]
 8011f14:	461a      	mov	r2, r3
 8011f16:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011f18:	f1c3 0310 	rsb	r3, r3, #16
 8011f1c:	fa02 f303 	lsl.w	r3, r2, r3
 8011f20:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011f22:	4313      	orrs	r3, r2
 8011f24:	637b      	str	r3, [r7, #52]	; 0x34
 8011f26:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011f28:	f103 0301 	add.w	r3, r3, #1
 8011f2c:	65bb      	str	r3, [r7, #88]	; 0x58
				cachedBits += bitsLeft;
 8011f2e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011f30:	683b      	ldr	r3, [r7, #0]
 8011f32:	18d3      	adds	r3, r2, r3
 8011f34:	643b      	str	r3, [r7, #64]	; 0x40
				bitsLeft = 0;
 8011f36:	f04f 0300 	mov.w	r3, #0
 8011f3a:	603b      	str	r3, [r7, #0]

				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 8011f3c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011f3e:	f103 33ff 	add.w	r3, r3, #4294967295
 8011f42:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8011f46:	fa42 f303 	asr.w	r3, r2, r3
 8011f4a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011f4c:	4013      	ands	r3, r2
 8011f4e:	637b      	str	r3, [r7, #52]	; 0x34
				padBits = 11;
 8011f50:	f04f 030b 	mov.w	r3, #11
 8011f54:	63fb      	str	r3, [r7, #60]	; 0x3c
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 8011f56:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011f58:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011f5a:	18d3      	adds	r3, r2, r3
 8011f5c:	643b      	str	r3, [r7, #64]	; 0x40
			}

			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
			while (nVals > 0 && cachedBits >= 11 ) {
 8011f5e:	e064      	b.n	801202a <DecodeHuffmanPairs+0x2be>
				cw = tBase[cache >> (32 - maxBits)];
 8011f60:	6a3b      	ldr	r3, [r7, #32]
 8011f62:	f1c3 0320 	rsb	r3, r3, #32
 8011f66:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011f68:	fa22 f303 	lsr.w	r3, r2, r3
 8011f6c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011f70:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011f72:	18d3      	adds	r3, r2, r3
 8011f74:	881b      	ldrh	r3, [r3, #0]
 8011f76:	83fb      	strh	r3, [r7, #30]
				len = GetHLen(cw);
 8011f78:	8bfb      	ldrh	r3, [r7, #30]
 8011f7a:	ea4f 3313 	mov.w	r3, r3, lsr #12
 8011f7e:	b29b      	uxth	r3, r3
 8011f80:	f003 030f 	and.w	r3, r3, #15
 8011f84:	61bb      	str	r3, [r7, #24]
				cachedBits -= len;
 8011f86:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011f88:	69bb      	ldr	r3, [r7, #24]
 8011f8a:	1ad3      	subs	r3, r2, r3
 8011f8c:	643b      	str	r3, [r7, #64]	; 0x40
				cache <<= len;
 8011f8e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011f90:	69bb      	ldr	r3, [r7, #24]
 8011f92:	fa02 f303 	lsl.w	r3, r2, r3
 8011f96:	637b      	str	r3, [r7, #52]	; 0x34

				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 8011f98:	8bfb      	ldrh	r3, [r7, #30]
 8011f9a:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8011f9e:	b29b      	uxth	r3, r3
 8011fa0:	f003 030f 	and.w	r3, r3, #15
 8011fa4:	64bb      	str	r3, [r7, #72]	; 0x48
 8011fa6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011fa8:	2b00      	cmp	r3, #0
 8011faa:	d00d      	beq.n	8011fc8 <DecodeHuffmanPairs+0x25c>
 8011fac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011fae:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8011fb2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011fb4:	4313      	orrs	r3, r2
 8011fb6:	64bb      	str	r3, [r7, #72]	; 0x48
 8011fb8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011fba:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011fbe:	637b      	str	r3, [r7, #52]	; 0x34
 8011fc0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011fc2:	f103 33ff 	add.w	r3, r3, #4294967295
 8011fc6:	643b      	str	r3, [r7, #64]	; 0x40
				y = GetCWY(cw);		if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 8011fc8:	8bfb      	ldrh	r3, [r7, #30]
 8011fca:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8011fce:	b29b      	uxth	r3, r3
 8011fd0:	f003 030f 	and.w	r3, r3, #15
 8011fd4:	647b      	str	r3, [r7, #68]	; 0x44
 8011fd6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011fd8:	2b00      	cmp	r3, #0
 8011fda:	d00d      	beq.n	8011ff8 <DecodeHuffmanPairs+0x28c>
 8011fdc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011fde:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8011fe2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011fe4:	4313      	orrs	r3, r2
 8011fe6:	647b      	str	r3, [r7, #68]	; 0x44
 8011fe8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011fea:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8011fee:	637b      	str	r3, [r7, #52]	; 0x34
 8011ff0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011ff2:	f103 33ff 	add.w	r3, r3, #4294967295
 8011ff6:	643b      	str	r3, [r7, #64]	; 0x40

				/* ran out of bits - should never have consumed padBits */
				if (cachedBits < padBits)
 8011ff8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011ffa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011ffc:	429a      	cmp	r2, r3
 8011ffe:	da02      	bge.n	8012006 <DecodeHuffmanPairs+0x29a>
					return -1;
 8012000:	f04f 33ff 	mov.w	r3, #4294967295
 8012004:	e1eb      	b.n	80123de <DecodeHuffmanPairs+0x672>

				*xy++ = x;
 8012006:	68fb      	ldr	r3, [r7, #12]
 8012008:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801200a:	601a      	str	r2, [r3, #0]
 801200c:	68fb      	ldr	r3, [r7, #12]
 801200e:	f103 0304 	add.w	r3, r3, #4
 8012012:	60fb      	str	r3, [r7, #12]
				*xy++ = y;
 8012014:	68fb      	ldr	r3, [r7, #12]
 8012016:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8012018:	601a      	str	r2, [r3, #0]
 801201a:	68fb      	ldr	r3, [r7, #12]
 801201c:	f103 0304 	add.w	r3, r3, #4
 8012020:	60fb      	str	r3, [r7, #12]
				nVals -= 2;
 8012022:	68bb      	ldr	r3, [r7, #8]
 8012024:	f1a3 0302 	sub.w	r3, r3, #2
 8012028:	60bb      	str	r3, [r7, #8]
				padBits = 11;
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
			}

			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
			while (nVals > 0 && cachedBits >= 11 ) {
 801202a:	68bb      	ldr	r3, [r7, #8]
 801202c:	2b00      	cmp	r3, #0
 801202e:	dd02      	ble.n	8012036 <DecodeHuffmanPairs+0x2ca>
 8012030:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012032:	2b0a      	cmp	r3, #10
 8012034:	dc94      	bgt.n	8011f60 <DecodeHuffmanPairs+0x1f4>
	} else if (tabType == oneShot) {
		/* single lookup, no escapes */
		maxBits = GetMaxbits(tBase[0]);
		tBase++;
		padBits = 0;
		while (nVals > 0) {
 8012036:	68bb      	ldr	r3, [r7, #8]
 8012038:	2b00      	cmp	r3, #0
 801203a:	f73f af22 	bgt.w	8011e82 <DecodeHuffmanPairs+0x116>
				*xy++ = x;
				*xy++ = y;
				nVals -= 2;
			}
		}
		bitsLeft += (cachedBits - padBits);
 801203e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012040:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012042:	1ad3      	subs	r3, r2, r3
 8012044:	683a      	ldr	r2, [r7, #0]
 8012046:	18d3      	adds	r3, r2, r3
 8012048:	603b      	str	r3, [r7, #0]
		return (startBits - bitsLeft);
 801204a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801204c:	683b      	ldr	r3, [r7, #0]
 801204e:	1ad3      	subs	r3, r2, r3
 8012050:	e1c5      	b.n	80123de <DecodeHuffmanPairs+0x672>
	} else if (tabType == loopLinbits || tabType == loopNoLinbits) {
 8012052:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8012056:	2b03      	cmp	r3, #3
 8012058:	d004      	beq.n	8012064 <DecodeHuffmanPairs+0x2f8>
 801205a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801205e:	2b02      	cmp	r3, #2
 8012060:	f040 81bb 	bne.w	80123da <DecodeHuffmanPairs+0x66e>
		tCurr = tBase;
 8012064:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012066:	63bb      	str	r3, [r7, #56]	; 0x38
		padBits = 0;
 8012068:	f04f 0300 	mov.w	r3, #0
 801206c:	63fb      	str	r3, [r7, #60]	; 0x3c
		while (nVals > 0) {
 801206e:	e1a6      	b.n	80123be <DecodeHuffmanPairs+0x652>
			/* refill cache - assumes cachedBits <= 16 */
			if (bitsLeft >= 16) {
 8012070:	683b      	ldr	r3, [r7, #0]
 8012072:	2b0f      	cmp	r3, #15
 8012074:	dd26      	ble.n	80120c4 <DecodeHuffmanPairs+0x358>
				/* load 2 new bytes into left-justified cache */
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 8012076:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8012078:	781b      	ldrb	r3, [r3, #0]
 801207a:	461a      	mov	r2, r3
 801207c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801207e:	f1c3 0318 	rsb	r3, r3, #24
 8012082:	fa02 f303 	lsl.w	r3, r2, r3
 8012086:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012088:	4313      	orrs	r3, r2
 801208a:	637b      	str	r3, [r7, #52]	; 0x34
 801208c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801208e:	f103 0301 	add.w	r3, r3, #1
 8012092:	65bb      	str	r3, [r7, #88]	; 0x58
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 8012094:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8012096:	781b      	ldrb	r3, [r3, #0]
 8012098:	461a      	mov	r2, r3
 801209a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801209c:	f1c3 0310 	rsb	r3, r3, #16
 80120a0:	fa02 f303 	lsl.w	r3, r2, r3
 80120a4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80120a6:	4313      	orrs	r3, r2
 80120a8:	637b      	str	r3, [r7, #52]	; 0x34
 80120aa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80120ac:	f103 0301 	add.w	r3, r3, #1
 80120b0:	65bb      	str	r3, [r7, #88]	; 0x58
				cachedBits += 16;
 80120b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80120b4:	f103 0310 	add.w	r3, r3, #16
 80120b8:	643b      	str	r3, [r7, #64]	; 0x40
				bitsLeft -= 16;
 80120ba:	683b      	ldr	r3, [r7, #0]
 80120bc:	f1a3 0310 	sub.w	r3, r3, #16
 80120c0:	603b      	str	r3, [r7, #0]
				padBits = 11;
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
			}

			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
			while (nVals > 0 && cachedBits >= 11 ) {
 80120c2:	e175      	b.n	80123b0 <DecodeHuffmanPairs+0x644>
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
				cachedBits += 16;
				bitsLeft -= 16;
			} else {
				/* last time through, pad cache with zeros and drain cache */
				if (cachedBits + bitsLeft <= 0)	return -1;
 80120c4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80120c6:	683b      	ldr	r3, [r7, #0]
 80120c8:	18d3      	adds	r3, r2, r3
 80120ca:	2b00      	cmp	r3, #0
 80120cc:	dc02      	bgt.n	80120d4 <DecodeHuffmanPairs+0x368>
 80120ce:	f04f 33ff 	mov.w	r3, #4294967295
 80120d2:	e184      	b.n	80123de <DecodeHuffmanPairs+0x672>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 80120d4:	683b      	ldr	r3, [r7, #0]
 80120d6:	2b00      	cmp	r3, #0
 80120d8:	dd0e      	ble.n	80120f8 <DecodeHuffmanPairs+0x38c>
 80120da:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80120dc:	781b      	ldrb	r3, [r3, #0]
 80120de:	461a      	mov	r2, r3
 80120e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80120e2:	f1c3 0318 	rsb	r3, r3, #24
 80120e6:	fa02 f303 	lsl.w	r3, r2, r3
 80120ea:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80120ec:	4313      	orrs	r3, r2
 80120ee:	637b      	str	r3, [r7, #52]	; 0x34
 80120f0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80120f2:	f103 0301 	add.w	r3, r3, #1
 80120f6:	65bb      	str	r3, [r7, #88]	; 0x58
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 80120f8:	683b      	ldr	r3, [r7, #0]
 80120fa:	2b08      	cmp	r3, #8
 80120fc:	dd0e      	ble.n	801211c <DecodeHuffmanPairs+0x3b0>
 80120fe:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8012100:	781b      	ldrb	r3, [r3, #0]
 8012102:	461a      	mov	r2, r3
 8012104:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012106:	f1c3 0310 	rsb	r3, r3, #16
 801210a:	fa02 f303 	lsl.w	r3, r2, r3
 801210e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012110:	4313      	orrs	r3, r2
 8012112:	637b      	str	r3, [r7, #52]	; 0x34
 8012114:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8012116:	f103 0301 	add.w	r3, r3, #1
 801211a:	65bb      	str	r3, [r7, #88]	; 0x58
				cachedBits += bitsLeft;
 801211c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801211e:	683b      	ldr	r3, [r7, #0]
 8012120:	18d3      	adds	r3, r2, r3
 8012122:	643b      	str	r3, [r7, #64]	; 0x40
				bitsLeft = 0;
 8012124:	f04f 0300 	mov.w	r3, #0
 8012128:	603b      	str	r3, [r7, #0]

				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801212a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801212c:	f103 33ff 	add.w	r3, r3, #4294967295
 8012130:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8012134:	fa42 f303 	asr.w	r3, r2, r3
 8012138:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801213a:	4013      	ands	r3, r2
 801213c:	637b      	str	r3, [r7, #52]	; 0x34
				padBits = 11;
 801213e:	f04f 030b 	mov.w	r3, #11
 8012142:	63fb      	str	r3, [r7, #60]	; 0x3c
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 8012144:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012146:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012148:	18d3      	adds	r3, r2, r3
 801214a:	643b      	str	r3, [r7, #64]	; 0x40
			}

			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
			while (nVals > 0 && cachedBits >= 11 ) {
 801214c:	e130      	b.n	80123b0 <DecodeHuffmanPairs+0x644>
				maxBits = GetMaxbits(tCurr[0]);
 801214e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012150:	881b      	ldrh	r3, [r3, #0]
 8012152:	f003 030f 	and.w	r3, r3, #15
 8012156:	623b      	str	r3, [r7, #32]
				cw = tCurr[(cache >> (32 - maxBits)) + 1];
 8012158:	6a3b      	ldr	r3, [r7, #32]
 801215a:	f1c3 0320 	rsb	r3, r3, #32
 801215e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012160:	fa22 f303 	lsr.w	r3, r2, r3
 8012164:	f103 0301 	add.w	r3, r3, #1
 8012168:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801216c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801216e:	18d3      	adds	r3, r2, r3
 8012170:	881b      	ldrh	r3, [r3, #0]
 8012172:	83fb      	strh	r3, [r7, #30]
				len = GetHLen(cw);
 8012174:	8bfb      	ldrh	r3, [r7, #30]
 8012176:	ea4f 3313 	mov.w	r3, r3, lsr #12
 801217a:	b29b      	uxth	r3, r3
 801217c:	f003 030f 	and.w	r3, r3, #15
 8012180:	61bb      	str	r3, [r7, #24]
				if (!len) {
 8012182:	69bb      	ldr	r3, [r7, #24]
 8012184:	2b00      	cmp	r3, #0
 8012186:	d10f      	bne.n	80121a8 <DecodeHuffmanPairs+0x43c>
					cachedBits -= maxBits;
 8012188:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801218a:	6a3b      	ldr	r3, [r7, #32]
 801218c:	1ad3      	subs	r3, r2, r3
 801218e:	643b      	str	r3, [r7, #64]	; 0x40
					cache <<= maxBits;
 8012190:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012192:	6a3b      	ldr	r3, [r7, #32]
 8012194:	fa02 f303 	lsl.w	r3, r2, r3
 8012198:	637b      	str	r3, [r7, #52]	; 0x34
					tCurr += cw;
 801219a:	8bfb      	ldrh	r3, [r7, #30]
 801219c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80121a0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80121a2:	18d3      	adds	r3, r2, r3
 80121a4:	63bb      	str	r3, [r7, #56]	; 0x38
					continue;
 80121a6:	e103      	b.n	80123b0 <DecodeHuffmanPairs+0x644>
				}
				cachedBits -= len;
 80121a8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80121aa:	69bb      	ldr	r3, [r7, #24]
 80121ac:	1ad3      	subs	r3, r2, r3
 80121ae:	643b      	str	r3, [r7, #64]	; 0x40
				cache <<= len;
 80121b0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80121b2:	69bb      	ldr	r3, [r7, #24]
 80121b4:	fa02 f303 	lsl.w	r3, r2, r3
 80121b8:	637b      	str	r3, [r7, #52]	; 0x34
			
				x = GetCWX(cw);
 80121ba:	8bfb      	ldrh	r3, [r7, #30]
 80121bc:	ea4f 1313 	mov.w	r3, r3, lsr #4
 80121c0:	b29b      	uxth	r3, r3
 80121c2:	f003 030f 	and.w	r3, r3, #15
 80121c6:	64bb      	str	r3, [r7, #72]	; 0x48
				y = GetCWY(cw);
 80121c8:	8bfb      	ldrh	r3, [r7, #30]
 80121ca:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80121ce:	b29b      	uxth	r3, r3
 80121d0:	f003 030f 	and.w	r3, r3, #15
 80121d4:	647b      	str	r3, [r7, #68]	; 0x44

				if (x == 15 && tabType == loopLinbits) {
 80121d6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80121d8:	2b0f      	cmp	r3, #15
 80121da:	d157      	bne.n	801228c <DecodeHuffmanPairs+0x520>
 80121dc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80121e0:	2b03      	cmp	r3, #3
 80121e2:	d153      	bne.n	801228c <DecodeHuffmanPairs+0x520>
					minBits = linBits + 1 + (y ? 1 : 0);
 80121e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80121e6:	f103 0201 	add.w	r2, r3, #1
 80121ea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80121ec:	2b00      	cmp	r3, #0
 80121ee:	bf0c      	ite	eq
 80121f0:	2300      	moveq	r3, #0
 80121f2:	2301      	movne	r3, #1
 80121f4:	18d3      	adds	r3, r2, r3
 80121f6:	617b      	str	r3, [r7, #20]
					if (cachedBits + bitsLeft < minBits)
 80121f8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80121fa:	683b      	ldr	r3, [r7, #0]
 80121fc:	18d2      	adds	r2, r2, r3
 80121fe:	697b      	ldr	r3, [r7, #20]
 8012200:	429a      	cmp	r2, r3
 8012202:	da19      	bge.n	8012238 <DecodeHuffmanPairs+0x4cc>
						return -1;
 8012204:	f04f 33ff 	mov.w	r3, #4294967295
 8012208:	e0e9      	b.n	80123de <DecodeHuffmanPairs+0x672>
					while (cachedBits < minBits) {
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801220a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801220c:	781b      	ldrb	r3, [r3, #0]
 801220e:	461a      	mov	r2, r3
 8012210:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012212:	f1c3 0318 	rsb	r3, r3, #24
 8012216:	fa02 f303 	lsl.w	r3, r2, r3
 801221a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801221c:	4313      	orrs	r3, r2
 801221e:	637b      	str	r3, [r7, #52]	; 0x34
 8012220:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8012222:	f103 0301 	add.w	r3, r3, #1
 8012226:	65bb      	str	r3, [r7, #88]	; 0x58
						cachedBits += 8;
 8012228:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801222a:	f103 0308 	add.w	r3, r3, #8
 801222e:	643b      	str	r3, [r7, #64]	; 0x40
						bitsLeft -= 8;
 8012230:	683b      	ldr	r3, [r7, #0]
 8012232:	f1a3 0308 	sub.w	r3, r3, #8
 8012236:	603b      	str	r3, [r7, #0]

				if (x == 15 && tabType == loopLinbits) {
					minBits = linBits + 1 + (y ? 1 : 0);
					if (cachedBits + bitsLeft < minBits)
						return -1;
					while (cachedBits < minBits) {
 8012238:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801223a:	697b      	ldr	r3, [r7, #20]
 801223c:	429a      	cmp	r2, r3
 801223e:	dbe4      	blt.n	801220a <DecodeHuffmanPairs+0x49e>
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
						cachedBits += 8;
						bitsLeft -= 8;
					}
					if (bitsLeft < 0) {
 8012240:	683b      	ldr	r3, [r7, #0]
 8012242:	2b00      	cmp	r3, #0
 8012244:	da10      	bge.n	8012268 <DecodeHuffmanPairs+0x4fc>
						cachedBits += bitsLeft;
 8012246:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012248:	683b      	ldr	r3, [r7, #0]
 801224a:	18d3      	adds	r3, r2, r3
 801224c:	643b      	str	r3, [r7, #64]	; 0x40
						bitsLeft = 0;
 801224e:	f04f 0300 	mov.w	r3, #0
 8012252:	603b      	str	r3, [r7, #0]
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 8012254:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012256:	f103 33ff 	add.w	r3, r3, #4294967295
 801225a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801225e:	fa42 f303 	asr.w	r3, r2, r3
 8012262:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012264:	4013      	ands	r3, r2
 8012266:	637b      	str	r3, [r7, #52]	; 0x34
					}
					x += (int)(cache >> (32 - linBits));
 8012268:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801226a:	f1c3 0320 	rsb	r3, r3, #32
 801226e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012270:	fa22 f303 	lsr.w	r3, r2, r3
 8012274:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8012276:	18d3      	adds	r3, r2, r3
 8012278:	64bb      	str	r3, [r7, #72]	; 0x48
					cachedBits -= linBits;
 801227a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801227c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801227e:	1ad3      	subs	r3, r2, r3
 8012280:	643b      	str	r3, [r7, #64]	; 0x40
					cache <<= linBits;
 8012282:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012284:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012286:	fa02 f303 	lsl.w	r3, r2, r3
 801228a:	637b      	str	r3, [r7, #52]	; 0x34
				}
				if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 801228c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801228e:	2b00      	cmp	r3, #0
 8012290:	d00d      	beq.n	80122ae <DecodeHuffmanPairs+0x542>
 8012292:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012294:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8012298:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801229a:	4313      	orrs	r3, r2
 801229c:	64bb      	str	r3, [r7, #72]	; 0x48
 801229e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80122a0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80122a4:	637b      	str	r3, [r7, #52]	; 0x34
 80122a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80122a8:	f103 33ff 	add.w	r3, r3, #4294967295
 80122ac:	643b      	str	r3, [r7, #64]	; 0x40

				if (y == 15 && tabType == loopLinbits) {
 80122ae:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80122b0:	2b0f      	cmp	r3, #15
 80122b2:	d151      	bne.n	8012358 <DecodeHuffmanPairs+0x5ec>
 80122b4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80122b8:	2b03      	cmp	r3, #3
 80122ba:	d14d      	bne.n	8012358 <DecodeHuffmanPairs+0x5ec>
					minBits = linBits + 1;
 80122bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80122be:	f103 0301 	add.w	r3, r3, #1
 80122c2:	617b      	str	r3, [r7, #20]
					if (cachedBits + bitsLeft < minBits)
 80122c4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80122c6:	683b      	ldr	r3, [r7, #0]
 80122c8:	18d2      	adds	r2, r2, r3
 80122ca:	697b      	ldr	r3, [r7, #20]
 80122cc:	429a      	cmp	r2, r3
 80122ce:	da19      	bge.n	8012304 <DecodeHuffmanPairs+0x598>
						return -1;
 80122d0:	f04f 33ff 	mov.w	r3, #4294967295
 80122d4:	e083      	b.n	80123de <DecodeHuffmanPairs+0x672>
					while (cachedBits < minBits) {
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 80122d6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80122d8:	781b      	ldrb	r3, [r3, #0]
 80122da:	461a      	mov	r2, r3
 80122dc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80122de:	f1c3 0318 	rsb	r3, r3, #24
 80122e2:	fa02 f303 	lsl.w	r3, r2, r3
 80122e6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80122e8:	4313      	orrs	r3, r2
 80122ea:	637b      	str	r3, [r7, #52]	; 0x34
 80122ec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80122ee:	f103 0301 	add.w	r3, r3, #1
 80122f2:	65bb      	str	r3, [r7, #88]	; 0x58
						cachedBits += 8;
 80122f4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80122f6:	f103 0308 	add.w	r3, r3, #8
 80122fa:	643b      	str	r3, [r7, #64]	; 0x40
						bitsLeft -= 8;
 80122fc:	683b      	ldr	r3, [r7, #0]
 80122fe:	f1a3 0308 	sub.w	r3, r3, #8
 8012302:	603b      	str	r3, [r7, #0]

				if (y == 15 && tabType == loopLinbits) {
					minBits = linBits + 1;
					if (cachedBits + bitsLeft < minBits)
						return -1;
					while (cachedBits < minBits) {
 8012304:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012306:	697b      	ldr	r3, [r7, #20]
 8012308:	429a      	cmp	r2, r3
 801230a:	dbe4      	blt.n	80122d6 <DecodeHuffmanPairs+0x56a>
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
						cachedBits += 8;
						bitsLeft -= 8;
					}
					if (bitsLeft < 0) {
 801230c:	683b      	ldr	r3, [r7, #0]
 801230e:	2b00      	cmp	r3, #0
 8012310:	da10      	bge.n	8012334 <DecodeHuffmanPairs+0x5c8>
						cachedBits += bitsLeft;
 8012312:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012314:	683b      	ldr	r3, [r7, #0]
 8012316:	18d3      	adds	r3, r2, r3
 8012318:	643b      	str	r3, [r7, #64]	; 0x40
						bitsLeft = 0;
 801231a:	f04f 0300 	mov.w	r3, #0
 801231e:	603b      	str	r3, [r7, #0]
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 8012320:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012322:	f103 33ff 	add.w	r3, r3, #4294967295
 8012326:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801232a:	fa42 f303 	asr.w	r3, r2, r3
 801232e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012330:	4013      	ands	r3, r2
 8012332:	637b      	str	r3, [r7, #52]	; 0x34
					}
					y += (int)(cache >> (32 - linBits));
 8012334:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012336:	f1c3 0320 	rsb	r3, r3, #32
 801233a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801233c:	fa22 f303 	lsr.w	r3, r2, r3
 8012340:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8012342:	18d3      	adds	r3, r2, r3
 8012344:	647b      	str	r3, [r7, #68]	; 0x44
					cachedBits -= linBits;
 8012346:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012348:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801234a:	1ad3      	subs	r3, r2, r3
 801234c:	643b      	str	r3, [r7, #64]	; 0x40
					cache <<= linBits;
 801234e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012350:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012352:	fa02 f303 	lsl.w	r3, r2, r3
 8012356:	637b      	str	r3, [r7, #52]	; 0x34
				}
				if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 8012358:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801235a:	2b00      	cmp	r3, #0
 801235c:	d00d      	beq.n	801237a <DecodeHuffmanPairs+0x60e>
 801235e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012360:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8012364:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012366:	4313      	orrs	r3, r2
 8012368:	647b      	str	r3, [r7, #68]	; 0x44
 801236a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801236c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012370:	637b      	str	r3, [r7, #52]	; 0x34
 8012372:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012374:	f103 33ff 	add.w	r3, r3, #4294967295
 8012378:	643b      	str	r3, [r7, #64]	; 0x40

				/* ran out of bits - should never have consumed padBits */
				if (cachedBits < padBits)
 801237a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801237c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801237e:	429a      	cmp	r2, r3
 8012380:	da02      	bge.n	8012388 <DecodeHuffmanPairs+0x61c>
					return -1;
 8012382:	f04f 33ff 	mov.w	r3, #4294967295
 8012386:	e02a      	b.n	80123de <DecodeHuffmanPairs+0x672>

				*xy++ = x;
 8012388:	68fb      	ldr	r3, [r7, #12]
 801238a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801238c:	601a      	str	r2, [r3, #0]
 801238e:	68fb      	ldr	r3, [r7, #12]
 8012390:	f103 0304 	add.w	r3, r3, #4
 8012394:	60fb      	str	r3, [r7, #12]
				*xy++ = y;
 8012396:	68fb      	ldr	r3, [r7, #12]
 8012398:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801239a:	601a      	str	r2, [r3, #0]
 801239c:	68fb      	ldr	r3, [r7, #12]
 801239e:	f103 0304 	add.w	r3, r3, #4
 80123a2:	60fb      	str	r3, [r7, #12]
				nVals -= 2;
 80123a4:	68bb      	ldr	r3, [r7, #8]
 80123a6:	f1a3 0302 	sub.w	r3, r3, #2
 80123aa:	60bb      	str	r3, [r7, #8]
				tCurr = tBase;
 80123ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80123ae:	63bb      	str	r3, [r7, #56]	; 0x38
				padBits = 11;
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
			}

			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
			while (nVals > 0 && cachedBits >= 11 ) {
 80123b0:	68bb      	ldr	r3, [r7, #8]
 80123b2:	2b00      	cmp	r3, #0
 80123b4:	dd03      	ble.n	80123be <DecodeHuffmanPairs+0x652>
 80123b6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80123b8:	2b0a      	cmp	r3, #10
 80123ba:	f73f aec8 	bgt.w	801214e <DecodeHuffmanPairs+0x3e2>
		bitsLeft += (cachedBits - padBits);
		return (startBits - bitsLeft);
	} else if (tabType == loopLinbits || tabType == loopNoLinbits) {
		tCurr = tBase;
		padBits = 0;
		while (nVals > 0) {
 80123be:	68bb      	ldr	r3, [r7, #8]
 80123c0:	2b00      	cmp	r3, #0
 80123c2:	f73f ae55 	bgt.w	8012070 <DecodeHuffmanPairs+0x304>
				*xy++ = y;
				nVals -= 2;
				tCurr = tBase;
			}
		}
		bitsLeft += (cachedBits - padBits);
 80123c6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80123c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80123ca:	1ad3      	subs	r3, r2, r3
 80123cc:	683a      	ldr	r2, [r7, #0]
 80123ce:	18d3      	adds	r3, r2, r3
 80123d0:	603b      	str	r3, [r7, #0]
		return (startBits - bitsLeft);
 80123d2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80123d4:	683b      	ldr	r3, [r7, #0]
 80123d6:	1ad3      	subs	r3, r2, r3
 80123d8:	e001      	b.n	80123de <DecodeHuffmanPairs+0x672>
	}

	/* error in bitstream - trying to access unused Huffman table */
	return -1;
 80123da:	f04f 33ff 	mov.w	r3, #4294967295
}
 80123de:	4618      	mov	r0, r3
 80123e0:	f107 0754 	add.w	r7, r7, #84	; 0x54
 80123e4:	46bd      	mov	sp, r7
 80123e6:	bc80      	pop	{r7}
 80123e8:	4770      	bx	lr
 80123ea:	bf00      	nop

080123ec <DecodeHuffmanQuads>:
 *                of the quad word after which all samples are 0)
 * 
 * Notes:        si_huff.bit tests every vwxy output in both quad tables
 **************************************************************************************/
static int DecodeHuffmanQuads(int *vwxy, int nVals, int tabIdx, int bitsLeft, unsigned char *buf, int bitOffset)
{
 80123ec:	b480      	push	{r7}
 80123ee:	b091      	sub	sp, #68	; 0x44
 80123f0:	af00      	add	r7, sp, #0
 80123f2:	60f8      	str	r0, [r7, #12]
 80123f4:	60b9      	str	r1, [r7, #8]
 80123f6:	607a      	str	r2, [r7, #4]
 80123f8:	603b      	str	r3, [r7, #0]
	int i, v, w, x, y;
	int len, maxBits, cachedBits, padBits;
	unsigned int cache;
	unsigned char cw, *tBase;

	if (bitsLeft <= 0)
 80123fa:	683b      	ldr	r3, [r7, #0]
 80123fc:	2b00      	cmp	r3, #0
 80123fe:	dc02      	bgt.n	8012406 <DecodeHuffmanQuads+0x1a>
		return 0;
 8012400:	f04f 0300 	mov.w	r3, #0
 8012404:	e155      	b.n	80126b2 <DecodeHuffmanQuads+0x2c6>

	tBase = (unsigned char *)quadTable + quadTabOffset[tabIdx];
 8012406:	f24e 2374 	movw	r3, #57972	; 0xe274
 801240a:	f6c0 0302 	movt	r3, #2050	; 0x802
 801240e:	687a      	ldr	r2, [r7, #4]
 8012410:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012414:	461a      	mov	r2, r3
 8012416:	f24e 2324 	movw	r3, #57892	; 0xe224
 801241a:	f6c0 0302 	movt	r3, #2050	; 0x802
 801241e:	18d3      	adds	r3, r2, r3
 8012420:	61fb      	str	r3, [r7, #28]
	maxBits = quadTabMaxBits[tabIdx];
 8012422:	f24e 237c 	movw	r3, #57980	; 0xe27c
 8012426:	f6c0 0302 	movt	r3, #2050	; 0x802
 801242a:	687a      	ldr	r2, [r7, #4]
 801242c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012430:	61bb      	str	r3, [r7, #24]

	/* initially fill cache with any partial byte */
	cache = 0;
 8012432:	f04f 0300 	mov.w	r3, #0
 8012436:	623b      	str	r3, [r7, #32]
	cachedBits = (8 - bitOffset) & 0x07;
 8012438:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801243a:	f1c3 0300 	rsb	r3, r3, #0
 801243e:	f003 0307 	and.w	r3, r3, #7
 8012442:	62bb      	str	r3, [r7, #40]	; 0x28
	if (cachedBits)
 8012444:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012446:	2b00      	cmp	r3, #0
 8012448:	d00c      	beq.n	8012464 <DecodeHuffmanQuads+0x78>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 801244a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801244c:	781b      	ldrb	r3, [r3, #0]
 801244e:	461a      	mov	r2, r3
 8012450:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012452:	f1c3 0320 	rsb	r3, r3, #32
 8012456:	fa02 f303 	lsl.w	r3, r2, r3
 801245a:	623b      	str	r3, [r7, #32]
 801245c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801245e:	f103 0301 	add.w	r3, r3, #1
 8012462:	64bb      	str	r3, [r7, #72]	; 0x48
	bitsLeft -= cachedBits;
 8012464:	683a      	ldr	r2, [r7, #0]
 8012466:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012468:	1ad3      	subs	r3, r2, r3
 801246a:	603b      	str	r3, [r7, #0]

	i = padBits = 0;
 801246c:	f04f 0300 	mov.w	r3, #0
 8012470:	627b      	str	r3, [r7, #36]	; 0x24
 8012472:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012474:	63fb      	str	r3, [r7, #60]	; 0x3c
	while (i < (nVals - 3)) {
 8012476:	e114      	b.n	80126a2 <DecodeHuffmanQuads+0x2b6>
		/* refill cache - assumes cachedBits <= 16 */
		if (bitsLeft >= 16) {
 8012478:	683b      	ldr	r3, [r7, #0]
 801247a:	2b0f      	cmp	r3, #15
 801247c:	dd26      	ble.n	80124cc <DecodeHuffmanQuads+0xe0>
			/* load 2 new bytes into left-justified cache */
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801247e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8012480:	781b      	ldrb	r3, [r3, #0]
 8012482:	461a      	mov	r2, r3
 8012484:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012486:	f1c3 0318 	rsb	r3, r3, #24
 801248a:	fa02 f303 	lsl.w	r3, r2, r3
 801248e:	6a3a      	ldr	r2, [r7, #32]
 8012490:	4313      	orrs	r3, r2
 8012492:	623b      	str	r3, [r7, #32]
 8012494:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8012496:	f103 0301 	add.w	r3, r3, #1
 801249a:	64bb      	str	r3, [r7, #72]	; 0x48
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801249c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801249e:	781b      	ldrb	r3, [r3, #0]
 80124a0:	461a      	mov	r2, r3
 80124a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80124a4:	f1c3 0310 	rsb	r3, r3, #16
 80124a8:	fa02 f303 	lsl.w	r3, r2, r3
 80124ac:	6a3a      	ldr	r2, [r7, #32]
 80124ae:	4313      	orrs	r3, r2
 80124b0:	623b      	str	r3, [r7, #32]
 80124b2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80124b4:	f103 0301 	add.w	r3, r3, #1
 80124b8:	64bb      	str	r3, [r7, #72]	; 0x48
			cachedBits += 16;
 80124ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80124bc:	f103 0310 	add.w	r3, r3, #16
 80124c0:	62bb      	str	r3, [r7, #40]	; 0x28
			bitsLeft -= 16;
 80124c2:	683b      	ldr	r3, [r7, #0]
 80124c4:	f1a3 0310 	sub.w	r3, r3, #16
 80124c8:	603b      	str	r3, [r7, #0]
			padBits = 10;
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
		}

		/* largest maxBits = 6, plus 4 for sign bits, so make sure cache has at least 10 bits */
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 80124ca:	e0e0      	b.n	801268e <DecodeHuffmanQuads+0x2a2>
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
			cachedBits += 16;
			bitsLeft -= 16;
		} else {
			/* last time through, pad cache with zeros and drain cache */
			if (cachedBits + bitsLeft <= 0) return i;
 80124cc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80124ce:	683b      	ldr	r3, [r7, #0]
 80124d0:	18d3      	adds	r3, r2, r3
 80124d2:	2b00      	cmp	r3, #0
 80124d4:	dc01      	bgt.n	80124da <DecodeHuffmanQuads+0xee>
 80124d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80124d8:	e0eb      	b.n	80126b2 <DecodeHuffmanQuads+0x2c6>
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 80124da:	683b      	ldr	r3, [r7, #0]
 80124dc:	2b00      	cmp	r3, #0
 80124de:	dd0e      	ble.n	80124fe <DecodeHuffmanQuads+0x112>
 80124e0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80124e2:	781b      	ldrb	r3, [r3, #0]
 80124e4:	461a      	mov	r2, r3
 80124e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80124e8:	f1c3 0318 	rsb	r3, r3, #24
 80124ec:	fa02 f303 	lsl.w	r3, r2, r3
 80124f0:	6a3a      	ldr	r2, [r7, #32]
 80124f2:	4313      	orrs	r3, r2
 80124f4:	623b      	str	r3, [r7, #32]
 80124f6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80124f8:	f103 0301 	add.w	r3, r3, #1
 80124fc:	64bb      	str	r3, [r7, #72]	; 0x48
			if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 80124fe:	683b      	ldr	r3, [r7, #0]
 8012500:	2b08      	cmp	r3, #8
 8012502:	dd0e      	ble.n	8012522 <DecodeHuffmanQuads+0x136>
 8012504:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8012506:	781b      	ldrb	r3, [r3, #0]
 8012508:	461a      	mov	r2, r3
 801250a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801250c:	f1c3 0310 	rsb	r3, r3, #16
 8012510:	fa02 f303 	lsl.w	r3, r2, r3
 8012514:	6a3a      	ldr	r2, [r7, #32]
 8012516:	4313      	orrs	r3, r2
 8012518:	623b      	str	r3, [r7, #32]
 801251a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801251c:	f103 0301 	add.w	r3, r3, #1
 8012520:	64bb      	str	r3, [r7, #72]	; 0x48
			cachedBits += bitsLeft;
 8012522:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8012524:	683b      	ldr	r3, [r7, #0]
 8012526:	18d3      	adds	r3, r2, r3
 8012528:	62bb      	str	r3, [r7, #40]	; 0x28
			bitsLeft = 0;
 801252a:	f04f 0300 	mov.w	r3, #0
 801252e:	603b      	str	r3, [r7, #0]

			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 8012530:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012532:	f103 33ff 	add.w	r3, r3, #4294967295
 8012536:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801253a:	fa42 f303 	asr.w	r3, r2, r3
 801253e:	6a3a      	ldr	r2, [r7, #32]
 8012540:	4013      	ands	r3, r2
 8012542:	623b      	str	r3, [r7, #32]
			padBits = 10;
 8012544:	f04f 030a 	mov.w	r3, #10
 8012548:	627b      	str	r3, [r7, #36]	; 0x24
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 801254a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801254c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801254e:	18d3      	adds	r3, r2, r3
 8012550:	62bb      	str	r3, [r7, #40]	; 0x28
		}

		/* largest maxBits = 6, plus 4 for sign bits, so make sure cache has at least 10 bits */
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 8012552:	e09c      	b.n	801268e <DecodeHuffmanQuads+0x2a2>
			cw = tBase[cache >> (32 - maxBits)];
 8012554:	69bb      	ldr	r3, [r7, #24]
 8012556:	f1c3 0320 	rsb	r3, r3, #32
 801255a:	6a3a      	ldr	r2, [r7, #32]
 801255c:	fa22 f303 	lsr.w	r3, r2, r3
 8012560:	69fa      	ldr	r2, [r7, #28]
 8012562:	18d3      	adds	r3, r2, r3
 8012564:	781b      	ldrb	r3, [r3, #0]
 8012566:	75fb      	strb	r3, [r7, #23]
			len = GetHLenQ(cw);
 8012568:	7dfb      	ldrb	r3, [r7, #23]
 801256a:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801256e:	b2db      	uxtb	r3, r3
 8012570:	f003 030f 	and.w	r3, r3, #15
 8012574:	613b      	str	r3, [r7, #16]
			cachedBits -= len;
 8012576:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8012578:	693b      	ldr	r3, [r7, #16]
 801257a:	1ad3      	subs	r3, r2, r3
 801257c:	62bb      	str	r3, [r7, #40]	; 0x28
			cache <<= len;
 801257e:	6a3a      	ldr	r2, [r7, #32]
 8012580:	693b      	ldr	r3, [r7, #16]
 8012582:	fa02 f303 	lsl.w	r3, r2, r3
 8012586:	623b      	str	r3, [r7, #32]

			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 8012588:	7dfb      	ldrb	r3, [r7, #23]
 801258a:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 801258e:	b2db      	uxtb	r3, r3
 8012590:	f003 0301 	and.w	r3, r3, #1
 8012594:	63bb      	str	r3, [r7, #56]	; 0x38
 8012596:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012598:	2b00      	cmp	r3, #0
 801259a:	d00d      	beq.n	80125b8 <DecodeHuffmanQuads+0x1cc>
 801259c:	6a3b      	ldr	r3, [r7, #32]
 801259e:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 80125a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80125a4:	4313      	orrs	r3, r2
 80125a6:	63bb      	str	r3, [r7, #56]	; 0x38
 80125a8:	6a3b      	ldr	r3, [r7, #32]
 80125aa:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80125ae:	623b      	str	r3, [r7, #32]
 80125b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80125b2:	f103 33ff 	add.w	r3, r3, #4294967295
 80125b6:	62bb      	str	r3, [r7, #40]	; 0x28
			w = GetCWWQ(cw);	if(w) {ApplySign(w, cache); cache <<= 1; cachedBits--;}
 80125b8:	7dfb      	ldrb	r3, [r7, #23]
 80125ba:	ea4f 0393 	mov.w	r3, r3, lsr #2
 80125be:	b2db      	uxtb	r3, r3
 80125c0:	f003 0301 	and.w	r3, r3, #1
 80125c4:	637b      	str	r3, [r7, #52]	; 0x34
 80125c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80125c8:	2b00      	cmp	r3, #0
 80125ca:	d00d      	beq.n	80125e8 <DecodeHuffmanQuads+0x1fc>
 80125cc:	6a3b      	ldr	r3, [r7, #32]
 80125ce:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 80125d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80125d4:	4313      	orrs	r3, r2
 80125d6:	637b      	str	r3, [r7, #52]	; 0x34
 80125d8:	6a3b      	ldr	r3, [r7, #32]
 80125da:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80125de:	623b      	str	r3, [r7, #32]
 80125e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80125e2:	f103 33ff 	add.w	r3, r3, #4294967295
 80125e6:	62bb      	str	r3, [r7, #40]	; 0x28
			x = GetCWXQ(cw);	if(x) {ApplySign(x, cache); cache <<= 1; cachedBits--;}
 80125e8:	7dfb      	ldrb	r3, [r7, #23]
 80125ea:	ea4f 0353 	mov.w	r3, r3, lsr #1
 80125ee:	b2db      	uxtb	r3, r3
 80125f0:	f003 0301 	and.w	r3, r3, #1
 80125f4:	633b      	str	r3, [r7, #48]	; 0x30
 80125f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80125f8:	2b00      	cmp	r3, #0
 80125fa:	d00d      	beq.n	8012618 <DecodeHuffmanQuads+0x22c>
 80125fc:	6a3b      	ldr	r3, [r7, #32]
 80125fe:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8012602:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012604:	4313      	orrs	r3, r2
 8012606:	633b      	str	r3, [r7, #48]	; 0x30
 8012608:	6a3b      	ldr	r3, [r7, #32]
 801260a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801260e:	623b      	str	r3, [r7, #32]
 8012610:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012612:	f103 33ff 	add.w	r3, r3, #4294967295
 8012616:	62bb      	str	r3, [r7, #40]	; 0x28
			y = GetCWYQ(cw);	if(y) {ApplySign(y, cache); cache <<= 1; cachedBits--;}
 8012618:	7dfb      	ldrb	r3, [r7, #23]
 801261a:	f003 0301 	and.w	r3, r3, #1
 801261e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8012620:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012622:	2b00      	cmp	r3, #0
 8012624:	d00d      	beq.n	8012642 <DecodeHuffmanQuads+0x256>
 8012626:	6a3b      	ldr	r3, [r7, #32]
 8012628:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 801262c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801262e:	4313      	orrs	r3, r2
 8012630:	62fb      	str	r3, [r7, #44]	; 0x2c
 8012632:	6a3b      	ldr	r3, [r7, #32]
 8012634:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012638:	623b      	str	r3, [r7, #32]
 801263a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801263c:	f103 33ff 	add.w	r3, r3, #4294967295
 8012640:	62bb      	str	r3, [r7, #40]	; 0x28

			/* ran out of bits - okay (means we're done) */
			if (cachedBits < padBits)
 8012642:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8012644:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012646:	429a      	cmp	r2, r3
 8012648:	da01      	bge.n	801264e <DecodeHuffmanQuads+0x262>
				return i;
 801264a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801264c:	e031      	b.n	80126b2 <DecodeHuffmanQuads+0x2c6>

			*vwxy++ = v;
 801264e:	68fb      	ldr	r3, [r7, #12]
 8012650:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8012652:	601a      	str	r2, [r3, #0]
 8012654:	68fb      	ldr	r3, [r7, #12]
 8012656:	f103 0304 	add.w	r3, r3, #4
 801265a:	60fb      	str	r3, [r7, #12]
			*vwxy++ = w;
 801265c:	68fb      	ldr	r3, [r7, #12]
 801265e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012660:	601a      	str	r2, [r3, #0]
 8012662:	68fb      	ldr	r3, [r7, #12]
 8012664:	f103 0304 	add.w	r3, r3, #4
 8012668:	60fb      	str	r3, [r7, #12]
			*vwxy++ = x;
 801266a:	68fb      	ldr	r3, [r7, #12]
 801266c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801266e:	601a      	str	r2, [r3, #0]
 8012670:	68fb      	ldr	r3, [r7, #12]
 8012672:	f103 0304 	add.w	r3, r3, #4
 8012676:	60fb      	str	r3, [r7, #12]
			*vwxy++ = y;
 8012678:	68fb      	ldr	r3, [r7, #12]
 801267a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801267c:	601a      	str	r2, [r3, #0]
 801267e:	68fb      	ldr	r3, [r7, #12]
 8012680:	f103 0304 	add.w	r3, r3, #4
 8012684:	60fb      	str	r3, [r7, #12]
			i += 4;
 8012686:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012688:	f103 0304 	add.w	r3, r3, #4
 801268c:	63fb      	str	r3, [r7, #60]	; 0x3c
			padBits = 10;
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
		}

		/* largest maxBits = 6, plus 4 for sign bits, so make sure cache has at least 10 bits */
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 801268e:	68bb      	ldr	r3, [r7, #8]
 8012690:	f1a3 0203 	sub.w	r2, r3, #3
 8012694:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012696:	429a      	cmp	r2, r3
 8012698:	dd03      	ble.n	80126a2 <DecodeHuffmanQuads+0x2b6>
 801269a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801269c:	2b09      	cmp	r3, #9
 801269e:	f73f af59 	bgt.w	8012554 <DecodeHuffmanQuads+0x168>
	if (cachedBits)
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
	bitsLeft -= cachedBits;

	i = padBits = 0;
	while (i < (nVals - 3)) {
 80126a2:	68bb      	ldr	r3, [r7, #8]
 80126a4:	f1a3 0203 	sub.w	r2, r3, #3
 80126a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80126aa:	429a      	cmp	r2, r3
 80126ac:	f73f aee4 	bgt.w	8012478 <DecodeHuffmanQuads+0x8c>
			i += 4;
		}
	}

	/* decoded max number of quad values */
	return i;
 80126b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
 80126b2:	4618      	mov	r0, r3
 80126b4:	f107 0744 	add.w	r7, r7, #68	; 0x44
 80126b8:	46bd      	mov	sp, r7
 80126ba:	bc80      	pop	{r7}
 80126bc:	4770      	bx	lr
 80126be:	bf00      	nop

080126c0 <xmp3_DecodeHuffman>:
 *                byte located at buf + offset)
 *              -1 if null input pointers, huffBlockBits < 0, or decoder runs 
 *                out of bits prematurely (invalid bitstream)
 **************************************************************************************/
int DecodeHuffman(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int huffBlockBits, int gr, int ch)
{
 80126c0:	b5b0      	push	{r4, r5, r7, lr}
 80126c2:	b096      	sub	sp, #88	; 0x58
 80126c4:	af02      	add	r7, sp, #8
 80126c6:	60f8      	str	r0, [r7, #12]
 80126c8:	60b9      	str	r1, [r7, #8]
 80126ca:	607a      	str	r2, [r7, #4]
 80126cc:	603b      	str	r3, [r7, #0]
	int r1Start, r2Start, rEnd[4];	/* region boundaries */
	int i, w, bitsUsed, bitsLeft;
	unsigned char *startBuf = buf;
 80126ce:	68bb      	ldr	r3, [r7, #8]
 80126d0:	63fb      	str	r3, [r7, #60]	; 0x3c
	SideInfoSub *sis;
//	ScaleFactorInfo *sfi;
	HuffmanInfo *hi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || !mp3DecInfo->HuffmanInfoPS)
 80126d2:	68fb      	ldr	r3, [r7, #12]
 80126d4:	2b00      	cmp	r3, #0
 80126d6:	d00f      	beq.n	80126f8 <xmp3_DecodeHuffman+0x38>
 80126d8:	68fb      	ldr	r3, [r7, #12]
 80126da:	681b      	ldr	r3, [r3, #0]
 80126dc:	2b00      	cmp	r3, #0
 80126de:	d00b      	beq.n	80126f8 <xmp3_DecodeHuffman+0x38>
 80126e0:	68fb      	ldr	r3, [r7, #12]
 80126e2:	685b      	ldr	r3, [r3, #4]
 80126e4:	2b00      	cmp	r3, #0
 80126e6:	d007      	beq.n	80126f8 <xmp3_DecodeHuffman+0x38>
 80126e8:	68fb      	ldr	r3, [r7, #12]
 80126ea:	689b      	ldr	r3, [r3, #8]
 80126ec:	2b00      	cmp	r3, #0
 80126ee:	d003      	beq.n	80126f8 <xmp3_DecodeHuffman+0x38>
 80126f0:	68fb      	ldr	r3, [r7, #12]
 80126f2:	68db      	ldr	r3, [r3, #12]
 80126f4:	2b00      	cmp	r3, #0
 80126f6:	d102      	bne.n	80126fe <xmp3_DecodeHuffman+0x3e>
		return -1;
 80126f8:	f04f 33ff 	mov.w	r3, #4294967295
 80126fc:	e172      	b.n	80129e4 <xmp3_DecodeHuffman+0x324>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 80126fe:	68fb      	ldr	r3, [r7, #12]
 8012700:	681b      	ldr	r3, [r3, #0]
 8012702:	63bb      	str	r3, [r7, #56]	; 0x38
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
 8012704:	68fb      	ldr	r3, [r7, #12]
 8012706:	685b      	ldr	r3, [r3, #4]
 8012708:	637b      	str	r3, [r7, #52]	; 0x34
	sis = &si->sis[gr][ch];
 801270a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801270c:	f103 0128 	add.w	r1, r3, #40	; 0x28
 8012710:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8012712:	4613      	mov	r3, r2
 8012714:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8012718:	189b      	adds	r3, r3, r2
 801271a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 801271e:	4618      	mov	r0, r3
 8012720:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8012722:	4613      	mov	r3, r2
 8012724:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8012728:	189b      	adds	r3, r3, r2
 801272a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801272e:	18c3      	adds	r3, r0, r3
 8012730:	18cb      	adds	r3, r1, r3
 8012732:	633b      	str	r3, [r7, #48]	; 0x30
//	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));
	hi = (HuffmanInfo*)(mp3DecInfo->HuffmanInfoPS);
 8012734:	68fb      	ldr	r3, [r7, #12]
 8012736:	68db      	ldr	r3, [r3, #12]
 8012738:	62fb      	str	r3, [r7, #44]	; 0x2c

	if (huffBlockBits < 0)
 801273a:	683b      	ldr	r3, [r7, #0]
 801273c:	2b00      	cmp	r3, #0
 801273e:	da02      	bge.n	8012746 <xmp3_DecodeHuffman+0x86>
		return -1;
 8012740:	f04f 33ff 	mov.w	r3, #4294967295
 8012744:	e14e      	b.n	80129e4 <xmp3_DecodeHuffman+0x324>

	/* figure out region boundaries (the first 2*bigVals coefficients divided into 3 regions) */
	if (sis->winSwitchFlag && sis->blockType == 2) {
 8012746:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012748:	691b      	ldr	r3, [r3, #16]
 801274a:	2b00      	cmp	r3, #0
 801274c:	d049      	beq.n	80127e2 <xmp3_DecodeHuffman+0x122>
 801274e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012750:	695b      	ldr	r3, [r3, #20]
 8012752:	2b02      	cmp	r3, #2
 8012754:	d145      	bne.n	80127e2 <xmp3_DecodeHuffman+0x122>
		if (sis->mixedBlock == 0) {
 8012756:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012758:	699b      	ldr	r3, [r3, #24]
 801275a:	2b00      	cmp	r3, #0
 801275c:	d11b      	bne.n	8012796 <xmp3_DecodeHuffman+0xd6>
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 801275e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012760:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8012762:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012764:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012766:	f103 0201 	add.w	r2, r3, #1
 801276a:	f245 5356 	movw	r3, #21846	; 0x5556
 801276e:	f2c5 5355 	movt	r3, #21845	; 0x5555
 8012772:	fb83 c002 	smull	ip, r0, r3, r2
 8012776:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801277a:	1ac3      	subs	r3, r0, r3
 801277c:	f103 0314 	add.w	r3, r3, #20
 8012780:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012784:	18cb      	adds	r3, r1, r3
 8012786:	88db      	ldrh	r3, [r3, #6]
 8012788:	b21a      	sxth	r2, r3
 801278a:	4613      	mov	r3, r2
 801278c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012790:	189b      	adds	r3, r3, r2
 8012792:	64fb      	str	r3, [r7, #76]	; 0x4c
 8012794:	e021      	b.n	80127da <xmp3_DecodeHuffman+0x11a>
		} else {
			if (fh->ver == MPEG1) {
 8012796:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012798:	781b      	ldrb	r3, [r3, #0]
 801279a:	2b00      	cmp	r3, #0
 801279c:	d10a      	bne.n	80127b4 <xmp3_DecodeHuffman+0xf4>
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 801279e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80127a0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80127a2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80127a4:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80127a6:	f102 0201 	add.w	r2, r2, #1
 80127aa:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80127ae:	b21b      	sxth	r3, r3
 80127b0:	64fb      	str	r3, [r7, #76]	; 0x4c
 80127b2:	e012      	b.n	80127da <xmp3_DecodeHuffman+0x11a>
			} else {
				/* see MPEG2 spec for explanation */
				w = fh->sfBand->s[4] - fh->sfBand->s[3];
 80127b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80127b6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80127b8:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80127ba:	b21a      	sxth	r2, r3
 80127bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80127be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80127c0:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 80127c2:	b21b      	sxth	r3, r3
 80127c4:	1ad3      	subs	r3, r2, r3
 80127c6:	62bb      	str	r3, [r7, #40]	; 0x28
				r1Start = fh->sfBand->l[6] + 2*w;
 80127c8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80127ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80127cc:	899b      	ldrh	r3, [r3, #12]
 80127ce:	b21a      	sxth	r2, r3
 80127d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80127d2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80127d6:	18d3      	adds	r3, r2, r3
 80127d8:	64fb      	str	r3, [r7, #76]	; 0x4c
			}
		}
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 80127da:	f44f 7310 	mov.w	r3, #576	; 0x240
 80127de:	64bb      	str	r3, [r7, #72]	; 0x48
 80127e0:	e018      	b.n	8012814 <xmp3_DecodeHuffman+0x154>
	} else {
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 80127e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80127e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80127e6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80127e8:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80127ea:	f102 0201 	add.w	r2, r2, #1
 80127ee:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80127f2:	b21b      	sxth	r3, r3
 80127f4:	64fb      	str	r3, [r7, #76]	; 0x4c
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 80127f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80127f8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80127fa:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80127fc:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80127fe:	f102 0101 	add.w	r1, r2, #1
 8012802:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8012804:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8012806:	188a      	adds	r2, r1, r2
 8012808:	f102 0201 	add.w	r2, r2, #1
 801280c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8012810:	b21b      	sxth	r3, r3
 8012812:	64bb      	str	r3, [r7, #72]	; 0x48
	}

	/* offset rEnd index by 1 so first region = rEnd[1] - rEnd[0], etc. */
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 8012814:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012816:	685b      	ldr	r3, [r3, #4]
 8012818:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801281c:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 8012820:	bfa8      	it	ge
 8012822:	f44f 7310 	movge.w	r3, #576	; 0x240
 8012826:	623b      	str	r3, [r7, #32]
	rEnd[2] = MIN(r2Start, rEnd[3]);
 8012828:	6a3a      	ldr	r2, [r7, #32]
 801282a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801282c:	429a      	cmp	r2, r3
 801282e:	bfb8      	it	lt
 8012830:	4613      	movlt	r3, r2
 8012832:	61fb      	str	r3, [r7, #28]
	rEnd[1] = MIN(r1Start, rEnd[3]);
 8012834:	6a3a      	ldr	r2, [r7, #32]
 8012836:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012838:	429a      	cmp	r2, r3
 801283a:	bfb8      	it	lt
 801283c:	4613      	movlt	r3, r2
 801283e:	61bb      	str	r3, [r7, #24]
	rEnd[0] = 0;
 8012840:	f04f 0300 	mov.w	r3, #0
 8012844:	617b      	str	r3, [r7, #20]

	/* rounds up to first all-zero pair (we don't check last pair for (x,y) == (non-zero, zero)) */
	hi->nonZeroBound[ch] = rEnd[3];
 8012846:	6a39      	ldr	r1, [r7, #32]
 8012848:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801284a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801284c:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 8012850:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	/* decode Huffman pairs (rEnd[i] are always even numbers) */
	bitsLeft = huffBlockBits;
 8012854:	683b      	ldr	r3, [r7, #0]
 8012856:	643b      	str	r3, [r7, #64]	; 0x40
	for (i = 0; i < 3; i++) {
 8012858:	f04f 0300 	mov.w	r3, #0
 801285c:	647b      	str	r3, [r7, #68]	; 0x44
 801285e:	e05f      	b.n	8012920 <xmp3_DecodeHuffman+0x260>
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 8012860:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8012862:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8012864:	4613      	mov	r3, r2
 8012866:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801286a:	189b      	adds	r3, r3, r2
 801286c:	ea4f 1383 	mov.w	r3, r3, lsl #6
 8012870:	461a      	mov	r2, r3
 8012872:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012874:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8012878:	f107 0050 	add.w	r0, r7, #80	; 0x50
 801287c:	18c3      	adds	r3, r0, r3
 801287e:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 8012882:	18d3      	adds	r3, r2, r3
 8012884:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8012888:	18c9      	adds	r1, r1, r3
 801288a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801288c:	f103 0301 	add.w	r3, r3, #1
 8012890:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8012894:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8012898:	18d3      	adds	r3, r2, r3
 801289a:	f853 2c3c 	ldr.w	r2, [r3, #-60]
 801289e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80128a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80128a4:	f107 0c50 	add.w	ip, r7, #80	; 0x50
 80128a8:	4463      	add	r3, ip
 80128aa:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 80128ae:	1ad2      	subs	r2, r2, r3
 80128b0:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80128b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80128b4:	f103 0306 	add.w	r3, r3, #6
 80128b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80128bc:	18c3      	adds	r3, r0, r3
 80128be:	685b      	ldr	r3, [r3, #4]
 80128c0:	6878      	ldr	r0, [r7, #4]
 80128c2:	6800      	ldr	r0, [r0, #0]
 80128c4:	68bc      	ldr	r4, [r7, #8]
 80128c6:	9400      	str	r4, [sp, #0]
 80128c8:	9001      	str	r0, [sp, #4]
 80128ca:	4608      	mov	r0, r1
 80128cc:	4611      	mov	r1, r2
 80128ce:	461a      	mov	r2, r3
 80128d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80128d2:	f7ff fa4b 	bl	8011d6c <DecodeHuffmanPairs>
 80128d6:	4603      	mov	r3, r0
 80128d8:	627b      	str	r3, [r7, #36]	; 0x24
		if (bitsUsed < 0 || bitsUsed > bitsLeft)	/* error - overran end of bitstream */
 80128da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80128dc:	2b00      	cmp	r3, #0
 80128de:	db03      	blt.n	80128e8 <xmp3_DecodeHuffman+0x228>
 80128e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80128e2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80128e4:	429a      	cmp	r2, r3
 80128e6:	dd02      	ble.n	80128ee <xmp3_DecodeHuffman+0x22e>
			return -1;
 80128e8:	f04f 33ff 	mov.w	r3, #4294967295
 80128ec:	e07a      	b.n	80129e4 <xmp3_DecodeHuffman+0x324>

		/* update bitstream position */
		buf += (bitsUsed + *bitOffset) >> 3;
 80128ee:	687b      	ldr	r3, [r7, #4]
 80128f0:	681a      	ldr	r2, [r3, #0]
 80128f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80128f4:	18d3      	adds	r3, r2, r3
 80128f6:	ea4f 03e3 	mov.w	r3, r3, asr #3
 80128fa:	68ba      	ldr	r2, [r7, #8]
 80128fc:	18d3      	adds	r3, r2, r3
 80128fe:	60bb      	str	r3, [r7, #8]
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 8012900:	687b      	ldr	r3, [r7, #4]
 8012902:	681a      	ldr	r2, [r3, #0]
 8012904:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012906:	18d3      	adds	r3, r2, r3
 8012908:	f003 0207 	and.w	r2, r3, #7
 801290c:	687b      	ldr	r3, [r7, #4]
 801290e:	601a      	str	r2, [r3, #0]
		bitsLeft -= bitsUsed;
 8012910:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012912:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012914:	1ad3      	subs	r3, r2, r3
 8012916:	643b      	str	r3, [r7, #64]	; 0x40
	/* rounds up to first all-zero pair (we don't check last pair for (x,y) == (non-zero, zero)) */
	hi->nonZeroBound[ch] = rEnd[3];

	/* decode Huffman pairs (rEnd[i] are always even numbers) */
	bitsLeft = huffBlockBits;
	for (i = 0; i < 3; i++) {
 8012918:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801291a:	f103 0301 	add.w	r3, r3, #1
 801291e:	647b      	str	r3, [r7, #68]	; 0x44
 8012920:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012922:	2b02      	cmp	r3, #2
 8012924:	dd9c      	ble.n	8012860 <xmp3_DecodeHuffman+0x1a0>
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
		bitsLeft -= bitsUsed;
	}

	/* decode Huffman quads (if any) */
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 8012926:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012928:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801292a:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 801292e:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
 8012932:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8012934:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8012936:	4613      	mov	r3, r2
 8012938:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801293c:	189b      	adds	r3, r3, r2
 801293e:	ea4f 1383 	mov.w	r3, r3, lsl #6
 8012942:	461a      	mov	r2, r3
 8012944:	6a3b      	ldr	r3, [r7, #32]
 8012946:	18d3      	adds	r3, r2, r3
 8012948:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801294c:	18c9      	adds	r1, r1, r3
 801294e:	6a3b      	ldr	r3, [r7, #32]
 8012950:	f5c3 7210 	rsb	r2, r3, #576	; 0x240
 8012954:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012956:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012958:	6878      	ldr	r0, [r7, #4]
 801295a:	6800      	ldr	r0, [r0, #0]
 801295c:	68bd      	ldr	r5, [r7, #8]
 801295e:	9500      	str	r5, [sp, #0]
 8012960:	9001      	str	r0, [sp, #4]
 8012962:	4608      	mov	r0, r1
 8012964:	4611      	mov	r1, r2
 8012966:	461a      	mov	r2, r3
 8012968:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801296a:	f7ff fd3f 	bl	80123ec <DecodeHuffmanQuads>
 801296e:	4603      	mov	r3, r0
 8012970:	18e1      	adds	r1, r4, r3
 8012972:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012974:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8012976:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 801297a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	ASSERT(hi->nonZeroBound[ch] <= MAX_NSAMP);
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 801297e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012980:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8012982:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 8012986:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801298a:	647b      	str	r3, [r7, #68]	; 0x44
 801298c:	e011      	b.n	80129b2 <xmp3_DecodeHuffman+0x2f2>
		hi->huffDecBuf[ch][i] = 0;
 801298e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8012990:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8012992:	4613      	mov	r3, r2
 8012994:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8012998:	189b      	adds	r3, r3, r2
 801299a:	ea4f 1383 	mov.w	r3, r3, lsl #6
 801299e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80129a0:	189b      	adds	r3, r3, r2
 80129a2:	f04f 0200 	mov.w	r2, #0
 80129a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	/* decode Huffman quads (if any) */
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);

	ASSERT(hi->nonZeroBound[ch] <= MAX_NSAMP);
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 80129aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80129ac:	f103 0301 	add.w	r3, r3, #1
 80129b0:	647b      	str	r3, [r7, #68]	; 0x44
 80129b2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80129b4:	f240 233f 	movw	r3, #575	; 0x23f
 80129b8:	429a      	cmp	r2, r3
 80129ba:	dde8      	ble.n	801298e <xmp3_DecodeHuffman+0x2ce>
		hi->huffDecBuf[ch][i] = 0;
	
	/* If bits used for 576 samples < huffBlockBits, then the extras are considered
	 *  to be stuffing bits (throw away, but need to return correct bitstream position) 
	 */
	buf += (bitsLeft + *bitOffset) >> 3;
 80129bc:	687b      	ldr	r3, [r7, #4]
 80129be:	681a      	ldr	r2, [r3, #0]
 80129c0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80129c2:	18d3      	adds	r3, r2, r3
 80129c4:	ea4f 03e3 	mov.w	r3, r3, asr #3
 80129c8:	68ba      	ldr	r2, [r7, #8]
 80129ca:	18d3      	adds	r3, r2, r3
 80129cc:	60bb      	str	r3, [r7, #8]
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
 80129ce:	687b      	ldr	r3, [r7, #4]
 80129d0:	681a      	ldr	r2, [r3, #0]
 80129d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80129d4:	18d3      	adds	r3, r2, r3
 80129d6:	f003 0207 	and.w	r2, r3, #7
 80129da:	687b      	ldr	r3, [r7, #4]
 80129dc:	601a      	str	r2, [r3, #0]
	
	return (buf - startBuf);
 80129de:	68ba      	ldr	r2, [r7, #8]
 80129e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80129e2:	1ad3      	subs	r3, r2, r3
}
 80129e4:	4618      	mov	r0, r3
 80129e6:	f107 0750 	add.w	r7, r7, #80	; 0x50
 80129ea:	46bd      	mov	sp, r7
 80129ec:	bdb0      	pop	{r4, r5, r7, pc}
 80129ee:	bf00      	nop

080129f0 <MULSHIFT32>:


#if defined(__GNUC__) && defined(__arm__)

static __inline__ int MULSHIFT32(int x, int y)
{
 80129f0:	b490      	push	{r4, r7}
 80129f2:	b084      	sub	sp, #16
 80129f4:	af00      	add	r7, sp, #0
 80129f6:	6078      	str	r0, [r7, #4]
 80129f8:	6039      	str	r1, [r7, #0]
int zlow;
__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 80129fa:	687a      	ldr	r2, [r7, #4]
 80129fc:	683b      	ldr	r3, [r7, #0]
 80129fe:	fb82 4303 	smull	r4, r3, r2, r3
 8012a02:	60fc      	str	r4, [r7, #12]
 8012a04:	603b      	str	r3, [r7, #0]
return y;
 8012a06:	683b      	ldr	r3, [r7, #0]
}
 8012a08:	4618      	mov	r0, r3
 8012a0a:	f107 0710 	add.w	r7, r7, #16
 8012a0e:	46bd      	mov	sp, r7
 8012a10:	bc90      	pop	{r4, r7}
 8012a12:	4770      	bx	lr

08012a14 <FASTABS>:

	return (short)x;
}

static __inline int FASTABS(int x)
{
 8012a14:	b480      	push	{r7}
 8012a16:	b085      	sub	sp, #20
 8012a18:	af00      	add	r7, sp, #0
 8012a1a:	6078      	str	r0, [r7, #4]
int sign;

sign = x >> (sizeof(int) * 8 - 1);
 8012a1c:	687b      	ldr	r3, [r7, #4]
 8012a1e:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8012a22:	60fb      	str	r3, [r7, #12]
x ^= sign;
 8012a24:	687a      	ldr	r2, [r7, #4]
 8012a26:	68fb      	ldr	r3, [r7, #12]
 8012a28:	4053      	eors	r3, r2
 8012a2a:	607b      	str	r3, [r7, #4]
x -= sign;
 8012a2c:	687a      	ldr	r2, [r7, #4]
 8012a2e:	68fb      	ldr	r3, [r7, #12]
 8012a30:	1ad3      	subs	r3, r2, r3
 8012a32:	607b      	str	r3, [r7, #4]

return x;
 8012a34:	687b      	ldr	r3, [r7, #4]
}
 8012a36:	4618      	mov	r0, r3
 8012a38:	f107 0714 	add.w	r7, r7, #20
 8012a3c:	46bd      	mov	sp, r7
 8012a3e:	bc80      	pop	{r7}
 8012a40:	4770      	bx	lr
 8012a42:	bf00      	nop

08012a44 <CLZ>:

static __inline int CLZ(int x)
{
 8012a44:	b490      	push	{r4, r7}
 8012a46:	b084      	sub	sp, #16
 8012a48:	af00      	add	r7, sp, #0
 8012a4a:	6078      	str	r0, [r7, #4]
while (!(x & 0x80000000)) {
numZeros++;
x <
}*/

__asm__ ("clz %0, %1" : "=r" (numZeros) : "r" (x) : "cc");
 8012a4c:	687b      	ldr	r3, [r7, #4]
 8012a4e:	fab3 f483 	clz	r4, r3
 8012a52:	60fc      	str	r4, [r7, #12]

return numZeros;
 8012a54:	68fb      	ldr	r3, [r7, #12]
}
 8012a56:	4618      	mov	r0, r3
 8012a58:	f107 0710 	add.w	r7, r7, #16
 8012a5c:	46bd      	mov	sp, r7
 8012a5e:	bc90      	pop	{r4, r7}
 8012a60:	4770      	bx	lr
 8012a62:	bf00      	nop

08012a64 <AntiAlias>:
 *              assume at least 1 guard bit in x[] to avoid overflow
 *                (should be guaranteed from dequant, and max gain from stproc * max 
 *                 gain from AntiAlias < 2.0)
 **************************************************************************************/
static void AntiAlias(int *x, int nBfly)
{
 8012a64:	b5b0      	push	{r4, r5, r7, lr}
 8012a66:	b088      	sub	sp, #32
 8012a68:	af00      	add	r7, sp, #0
 8012a6a:	6078      	str	r0, [r7, #4]
 8012a6c:	6039      	str	r1, [r7, #0]
	int k, a0, b0, c0, c1;
	const int *c;

	/* csa = Q31 */
	for (k = nBfly; k > 0; k--) {
 8012a6e:	683b      	ldr	r3, [r7, #0]
 8012a70:	61fb      	str	r3, [r7, #28]
 8012a72:	e1c2      	b.n	8012dfa <AntiAlias+0x396>
		c = csa[0];
 8012a74:	f24e 7304 	movw	r3, #59140	; 0xe704
 8012a78:	f6c0 0302 	movt	r3, #2050	; 0x802
 8012a7c:	61bb      	str	r3, [r7, #24]
		x += 18;
 8012a7e:	687b      	ldr	r3, [r7, #4]
 8012a80:	f103 0348 	add.w	r3, r3, #72	; 0x48
 8012a84:	607b      	str	r3, [r7, #4]

		a0 = x[-1];			c0 = *c;	c++;	b0 = x[0];		c1 = *c;	c++;
 8012a86:	687b      	ldr	r3, [r7, #4]
 8012a88:	f853 3c04 	ldr.w	r3, [r3, #-4]
 8012a8c:	617b      	str	r3, [r7, #20]
 8012a8e:	69bb      	ldr	r3, [r7, #24]
 8012a90:	681b      	ldr	r3, [r3, #0]
 8012a92:	613b      	str	r3, [r7, #16]
 8012a94:	69bb      	ldr	r3, [r7, #24]
 8012a96:	f103 0304 	add.w	r3, r3, #4
 8012a9a:	61bb      	str	r3, [r7, #24]
 8012a9c:	687b      	ldr	r3, [r7, #4]
 8012a9e:	681b      	ldr	r3, [r3, #0]
 8012aa0:	60fb      	str	r3, [r7, #12]
 8012aa2:	69bb      	ldr	r3, [r7, #24]
 8012aa4:	681b      	ldr	r3, [r3, #0]
 8012aa6:	60bb      	str	r3, [r7, #8]
 8012aa8:	69bb      	ldr	r3, [r7, #24]
 8012aaa:	f103 0304 	add.w	r3, r3, #4
 8012aae:	61bb      	str	r3, [r7, #24]
		x[-1] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8012ab0:	687b      	ldr	r3, [r7, #4]
 8012ab2:	f1a3 0404 	sub.w	r4, r3, #4
 8012ab6:	6938      	ldr	r0, [r7, #16]
 8012ab8:	6979      	ldr	r1, [r7, #20]
 8012aba:	f7ff ff99 	bl	80129f0 <MULSHIFT32>
 8012abe:	4605      	mov	r5, r0
 8012ac0:	68b8      	ldr	r0, [r7, #8]
 8012ac2:	68f9      	ldr	r1, [r7, #12]
 8012ac4:	f7ff ff94 	bl	80129f0 <MULSHIFT32>
 8012ac8:	4603      	mov	r3, r0
 8012aca:	1aeb      	subs	r3, r5, r3
 8012acc:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012ad0:	6023      	str	r3, [r4, #0]
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8012ad2:	6938      	ldr	r0, [r7, #16]
 8012ad4:	68f9      	ldr	r1, [r7, #12]
 8012ad6:	f7ff ff8b 	bl	80129f0 <MULSHIFT32>
 8012ada:	4604      	mov	r4, r0
 8012adc:	68b8      	ldr	r0, [r7, #8]
 8012ade:	6979      	ldr	r1, [r7, #20]
 8012ae0:	f7ff ff86 	bl	80129f0 <MULSHIFT32>
 8012ae4:	4603      	mov	r3, r0
 8012ae6:	18e3      	adds	r3, r4, r3
 8012ae8:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8012aec:	687b      	ldr	r3, [r7, #4]
 8012aee:	601a      	str	r2, [r3, #0]

		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 8012af0:	687b      	ldr	r3, [r7, #4]
 8012af2:	f853 3c08 	ldr.w	r3, [r3, #-8]
 8012af6:	617b      	str	r3, [r7, #20]
 8012af8:	69bb      	ldr	r3, [r7, #24]
 8012afa:	681b      	ldr	r3, [r3, #0]
 8012afc:	613b      	str	r3, [r7, #16]
 8012afe:	69bb      	ldr	r3, [r7, #24]
 8012b00:	f103 0304 	add.w	r3, r3, #4
 8012b04:	61bb      	str	r3, [r7, #24]
 8012b06:	687b      	ldr	r3, [r7, #4]
 8012b08:	685b      	ldr	r3, [r3, #4]
 8012b0a:	60fb      	str	r3, [r7, #12]
 8012b0c:	69bb      	ldr	r3, [r7, #24]
 8012b0e:	681b      	ldr	r3, [r3, #0]
 8012b10:	60bb      	str	r3, [r7, #8]
 8012b12:	69bb      	ldr	r3, [r7, #24]
 8012b14:	f103 0304 	add.w	r3, r3, #4
 8012b18:	61bb      	str	r3, [r7, #24]
		x[-2] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8012b1a:	687b      	ldr	r3, [r7, #4]
 8012b1c:	f1a3 0408 	sub.w	r4, r3, #8
 8012b20:	6938      	ldr	r0, [r7, #16]
 8012b22:	6979      	ldr	r1, [r7, #20]
 8012b24:	f7ff ff64 	bl	80129f0 <MULSHIFT32>
 8012b28:	4605      	mov	r5, r0
 8012b2a:	68b8      	ldr	r0, [r7, #8]
 8012b2c:	68f9      	ldr	r1, [r7, #12]
 8012b2e:	f7ff ff5f 	bl	80129f0 <MULSHIFT32>
 8012b32:	4603      	mov	r3, r0
 8012b34:	1aeb      	subs	r3, r5, r3
 8012b36:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012b3a:	6023      	str	r3, [r4, #0]
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8012b3c:	687b      	ldr	r3, [r7, #4]
 8012b3e:	f103 0404 	add.w	r4, r3, #4
 8012b42:	6938      	ldr	r0, [r7, #16]
 8012b44:	68f9      	ldr	r1, [r7, #12]
 8012b46:	f7ff ff53 	bl	80129f0 <MULSHIFT32>
 8012b4a:	4605      	mov	r5, r0
 8012b4c:	68b8      	ldr	r0, [r7, #8]
 8012b4e:	6979      	ldr	r1, [r7, #20]
 8012b50:	f7ff ff4e 	bl	80129f0 <MULSHIFT32>
 8012b54:	4603      	mov	r3, r0
 8012b56:	18eb      	adds	r3, r5, r3
 8012b58:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012b5c:	6023      	str	r3, [r4, #0]
		
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 8012b5e:	687b      	ldr	r3, [r7, #4]
 8012b60:	f853 3c0c 	ldr.w	r3, [r3, #-12]
 8012b64:	617b      	str	r3, [r7, #20]
 8012b66:	69bb      	ldr	r3, [r7, #24]
 8012b68:	681b      	ldr	r3, [r3, #0]
 8012b6a:	613b      	str	r3, [r7, #16]
 8012b6c:	69bb      	ldr	r3, [r7, #24]
 8012b6e:	f103 0304 	add.w	r3, r3, #4
 8012b72:	61bb      	str	r3, [r7, #24]
 8012b74:	687b      	ldr	r3, [r7, #4]
 8012b76:	689b      	ldr	r3, [r3, #8]
 8012b78:	60fb      	str	r3, [r7, #12]
 8012b7a:	69bb      	ldr	r3, [r7, #24]
 8012b7c:	681b      	ldr	r3, [r3, #0]
 8012b7e:	60bb      	str	r3, [r7, #8]
 8012b80:	69bb      	ldr	r3, [r7, #24]
 8012b82:	f103 0304 	add.w	r3, r3, #4
 8012b86:	61bb      	str	r3, [r7, #24]
		x[-3] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8012b88:	687b      	ldr	r3, [r7, #4]
 8012b8a:	f1a3 040c 	sub.w	r4, r3, #12
 8012b8e:	6938      	ldr	r0, [r7, #16]
 8012b90:	6979      	ldr	r1, [r7, #20]
 8012b92:	f7ff ff2d 	bl	80129f0 <MULSHIFT32>
 8012b96:	4605      	mov	r5, r0
 8012b98:	68b8      	ldr	r0, [r7, #8]
 8012b9a:	68f9      	ldr	r1, [r7, #12]
 8012b9c:	f7ff ff28 	bl	80129f0 <MULSHIFT32>
 8012ba0:	4603      	mov	r3, r0
 8012ba2:	1aeb      	subs	r3, r5, r3
 8012ba4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012ba8:	6023      	str	r3, [r4, #0]
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8012baa:	687b      	ldr	r3, [r7, #4]
 8012bac:	f103 0408 	add.w	r4, r3, #8
 8012bb0:	6938      	ldr	r0, [r7, #16]
 8012bb2:	68f9      	ldr	r1, [r7, #12]
 8012bb4:	f7ff ff1c 	bl	80129f0 <MULSHIFT32>
 8012bb8:	4605      	mov	r5, r0
 8012bba:	68b8      	ldr	r0, [r7, #8]
 8012bbc:	6979      	ldr	r1, [r7, #20]
 8012bbe:	f7ff ff17 	bl	80129f0 <MULSHIFT32>
 8012bc2:	4603      	mov	r3, r0
 8012bc4:	18eb      	adds	r3, r5, r3
 8012bc6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012bca:	6023      	str	r3, [r4, #0]

		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 8012bcc:	687b      	ldr	r3, [r7, #4]
 8012bce:	f853 3c10 	ldr.w	r3, [r3, #-16]
 8012bd2:	617b      	str	r3, [r7, #20]
 8012bd4:	69bb      	ldr	r3, [r7, #24]
 8012bd6:	681b      	ldr	r3, [r3, #0]
 8012bd8:	613b      	str	r3, [r7, #16]
 8012bda:	69bb      	ldr	r3, [r7, #24]
 8012bdc:	f103 0304 	add.w	r3, r3, #4
 8012be0:	61bb      	str	r3, [r7, #24]
 8012be2:	687b      	ldr	r3, [r7, #4]
 8012be4:	68db      	ldr	r3, [r3, #12]
 8012be6:	60fb      	str	r3, [r7, #12]
 8012be8:	69bb      	ldr	r3, [r7, #24]
 8012bea:	681b      	ldr	r3, [r3, #0]
 8012bec:	60bb      	str	r3, [r7, #8]
 8012bee:	69bb      	ldr	r3, [r7, #24]
 8012bf0:	f103 0304 	add.w	r3, r3, #4
 8012bf4:	61bb      	str	r3, [r7, #24]
		x[-4] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8012bf6:	687b      	ldr	r3, [r7, #4]
 8012bf8:	f1a3 0410 	sub.w	r4, r3, #16
 8012bfc:	6938      	ldr	r0, [r7, #16]
 8012bfe:	6979      	ldr	r1, [r7, #20]
 8012c00:	f7ff fef6 	bl	80129f0 <MULSHIFT32>
 8012c04:	4605      	mov	r5, r0
 8012c06:	68b8      	ldr	r0, [r7, #8]
 8012c08:	68f9      	ldr	r1, [r7, #12]
 8012c0a:	f7ff fef1 	bl	80129f0 <MULSHIFT32>
 8012c0e:	4603      	mov	r3, r0
 8012c10:	1aeb      	subs	r3, r5, r3
 8012c12:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012c16:	6023      	str	r3, [r4, #0]
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8012c18:	687b      	ldr	r3, [r7, #4]
 8012c1a:	f103 040c 	add.w	r4, r3, #12
 8012c1e:	6938      	ldr	r0, [r7, #16]
 8012c20:	68f9      	ldr	r1, [r7, #12]
 8012c22:	f7ff fee5 	bl	80129f0 <MULSHIFT32>
 8012c26:	4605      	mov	r5, r0
 8012c28:	68b8      	ldr	r0, [r7, #8]
 8012c2a:	6979      	ldr	r1, [r7, #20]
 8012c2c:	f7ff fee0 	bl	80129f0 <MULSHIFT32>
 8012c30:	4603      	mov	r3, r0
 8012c32:	18eb      	adds	r3, r5, r3
 8012c34:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012c38:	6023      	str	r3, [r4, #0]

		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 8012c3a:	687b      	ldr	r3, [r7, #4]
 8012c3c:	f853 3c14 	ldr.w	r3, [r3, #-20]
 8012c40:	617b      	str	r3, [r7, #20]
 8012c42:	69bb      	ldr	r3, [r7, #24]
 8012c44:	681b      	ldr	r3, [r3, #0]
 8012c46:	613b      	str	r3, [r7, #16]
 8012c48:	69bb      	ldr	r3, [r7, #24]
 8012c4a:	f103 0304 	add.w	r3, r3, #4
 8012c4e:	61bb      	str	r3, [r7, #24]
 8012c50:	687b      	ldr	r3, [r7, #4]
 8012c52:	691b      	ldr	r3, [r3, #16]
 8012c54:	60fb      	str	r3, [r7, #12]
 8012c56:	69bb      	ldr	r3, [r7, #24]
 8012c58:	681b      	ldr	r3, [r3, #0]
 8012c5a:	60bb      	str	r3, [r7, #8]
 8012c5c:	69bb      	ldr	r3, [r7, #24]
 8012c5e:	f103 0304 	add.w	r3, r3, #4
 8012c62:	61bb      	str	r3, [r7, #24]
		x[-5] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8012c64:	687b      	ldr	r3, [r7, #4]
 8012c66:	f1a3 0414 	sub.w	r4, r3, #20
 8012c6a:	6938      	ldr	r0, [r7, #16]
 8012c6c:	6979      	ldr	r1, [r7, #20]
 8012c6e:	f7ff febf 	bl	80129f0 <MULSHIFT32>
 8012c72:	4605      	mov	r5, r0
 8012c74:	68b8      	ldr	r0, [r7, #8]
 8012c76:	68f9      	ldr	r1, [r7, #12]
 8012c78:	f7ff feba 	bl	80129f0 <MULSHIFT32>
 8012c7c:	4603      	mov	r3, r0
 8012c7e:	1aeb      	subs	r3, r5, r3
 8012c80:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012c84:	6023      	str	r3, [r4, #0]
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8012c86:	687b      	ldr	r3, [r7, #4]
 8012c88:	f103 0410 	add.w	r4, r3, #16
 8012c8c:	6938      	ldr	r0, [r7, #16]
 8012c8e:	68f9      	ldr	r1, [r7, #12]
 8012c90:	f7ff feae 	bl	80129f0 <MULSHIFT32>
 8012c94:	4605      	mov	r5, r0
 8012c96:	68b8      	ldr	r0, [r7, #8]
 8012c98:	6979      	ldr	r1, [r7, #20]
 8012c9a:	f7ff fea9 	bl	80129f0 <MULSHIFT32>
 8012c9e:	4603      	mov	r3, r0
 8012ca0:	18eb      	adds	r3, r5, r3
 8012ca2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012ca6:	6023      	str	r3, [r4, #0]

		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 8012ca8:	687b      	ldr	r3, [r7, #4]
 8012caa:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8012cae:	617b      	str	r3, [r7, #20]
 8012cb0:	69bb      	ldr	r3, [r7, #24]
 8012cb2:	681b      	ldr	r3, [r3, #0]
 8012cb4:	613b      	str	r3, [r7, #16]
 8012cb6:	69bb      	ldr	r3, [r7, #24]
 8012cb8:	f103 0304 	add.w	r3, r3, #4
 8012cbc:	61bb      	str	r3, [r7, #24]
 8012cbe:	687b      	ldr	r3, [r7, #4]
 8012cc0:	695b      	ldr	r3, [r3, #20]
 8012cc2:	60fb      	str	r3, [r7, #12]
 8012cc4:	69bb      	ldr	r3, [r7, #24]
 8012cc6:	681b      	ldr	r3, [r3, #0]
 8012cc8:	60bb      	str	r3, [r7, #8]
 8012cca:	69bb      	ldr	r3, [r7, #24]
 8012ccc:	f103 0304 	add.w	r3, r3, #4
 8012cd0:	61bb      	str	r3, [r7, #24]
		x[-6] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8012cd2:	687b      	ldr	r3, [r7, #4]
 8012cd4:	f1a3 0418 	sub.w	r4, r3, #24
 8012cd8:	6938      	ldr	r0, [r7, #16]
 8012cda:	6979      	ldr	r1, [r7, #20]
 8012cdc:	f7ff fe88 	bl	80129f0 <MULSHIFT32>
 8012ce0:	4605      	mov	r5, r0
 8012ce2:	68b8      	ldr	r0, [r7, #8]
 8012ce4:	68f9      	ldr	r1, [r7, #12]
 8012ce6:	f7ff fe83 	bl	80129f0 <MULSHIFT32>
 8012cea:	4603      	mov	r3, r0
 8012cec:	1aeb      	subs	r3, r5, r3
 8012cee:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012cf2:	6023      	str	r3, [r4, #0]
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8012cf4:	687b      	ldr	r3, [r7, #4]
 8012cf6:	f103 0414 	add.w	r4, r3, #20
 8012cfa:	6938      	ldr	r0, [r7, #16]
 8012cfc:	68f9      	ldr	r1, [r7, #12]
 8012cfe:	f7ff fe77 	bl	80129f0 <MULSHIFT32>
 8012d02:	4605      	mov	r5, r0
 8012d04:	68b8      	ldr	r0, [r7, #8]
 8012d06:	6979      	ldr	r1, [r7, #20]
 8012d08:	f7ff fe72 	bl	80129f0 <MULSHIFT32>
 8012d0c:	4603      	mov	r3, r0
 8012d0e:	18eb      	adds	r3, r5, r3
 8012d10:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012d14:	6023      	str	r3, [r4, #0]

		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 8012d16:	687b      	ldr	r3, [r7, #4]
 8012d18:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 8012d1c:	617b      	str	r3, [r7, #20]
 8012d1e:	69bb      	ldr	r3, [r7, #24]
 8012d20:	681b      	ldr	r3, [r3, #0]
 8012d22:	613b      	str	r3, [r7, #16]
 8012d24:	69bb      	ldr	r3, [r7, #24]
 8012d26:	f103 0304 	add.w	r3, r3, #4
 8012d2a:	61bb      	str	r3, [r7, #24]
 8012d2c:	687b      	ldr	r3, [r7, #4]
 8012d2e:	699b      	ldr	r3, [r3, #24]
 8012d30:	60fb      	str	r3, [r7, #12]
 8012d32:	69bb      	ldr	r3, [r7, #24]
 8012d34:	681b      	ldr	r3, [r3, #0]
 8012d36:	60bb      	str	r3, [r7, #8]
 8012d38:	69bb      	ldr	r3, [r7, #24]
 8012d3a:	f103 0304 	add.w	r3, r3, #4
 8012d3e:	61bb      	str	r3, [r7, #24]
		x[-7] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8012d40:	687b      	ldr	r3, [r7, #4]
 8012d42:	f1a3 041c 	sub.w	r4, r3, #28
 8012d46:	6938      	ldr	r0, [r7, #16]
 8012d48:	6979      	ldr	r1, [r7, #20]
 8012d4a:	f7ff fe51 	bl	80129f0 <MULSHIFT32>
 8012d4e:	4605      	mov	r5, r0
 8012d50:	68b8      	ldr	r0, [r7, #8]
 8012d52:	68f9      	ldr	r1, [r7, #12]
 8012d54:	f7ff fe4c 	bl	80129f0 <MULSHIFT32>
 8012d58:	4603      	mov	r3, r0
 8012d5a:	1aeb      	subs	r3, r5, r3
 8012d5c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012d60:	6023      	str	r3, [r4, #0]
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8012d62:	687b      	ldr	r3, [r7, #4]
 8012d64:	f103 0418 	add.w	r4, r3, #24
 8012d68:	6938      	ldr	r0, [r7, #16]
 8012d6a:	68f9      	ldr	r1, [r7, #12]
 8012d6c:	f7ff fe40 	bl	80129f0 <MULSHIFT32>
 8012d70:	4605      	mov	r5, r0
 8012d72:	68b8      	ldr	r0, [r7, #8]
 8012d74:	6979      	ldr	r1, [r7, #20]
 8012d76:	f7ff fe3b 	bl	80129f0 <MULSHIFT32>
 8012d7a:	4603      	mov	r3, r0
 8012d7c:	18eb      	adds	r3, r5, r3
 8012d7e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012d82:	6023      	str	r3, [r4, #0]

		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 8012d84:	687b      	ldr	r3, [r7, #4]
 8012d86:	f853 3c20 	ldr.w	r3, [r3, #-32]
 8012d8a:	617b      	str	r3, [r7, #20]
 8012d8c:	69bb      	ldr	r3, [r7, #24]
 8012d8e:	681b      	ldr	r3, [r3, #0]
 8012d90:	613b      	str	r3, [r7, #16]
 8012d92:	69bb      	ldr	r3, [r7, #24]
 8012d94:	f103 0304 	add.w	r3, r3, #4
 8012d98:	61bb      	str	r3, [r7, #24]
 8012d9a:	687b      	ldr	r3, [r7, #4]
 8012d9c:	69db      	ldr	r3, [r3, #28]
 8012d9e:	60fb      	str	r3, [r7, #12]
 8012da0:	69bb      	ldr	r3, [r7, #24]
 8012da2:	681b      	ldr	r3, [r3, #0]
 8012da4:	60bb      	str	r3, [r7, #8]
 8012da6:	69bb      	ldr	r3, [r7, #24]
 8012da8:	f103 0304 	add.w	r3, r3, #4
 8012dac:	61bb      	str	r3, [r7, #24]
		x[-8] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8012dae:	687b      	ldr	r3, [r7, #4]
 8012db0:	f1a3 0420 	sub.w	r4, r3, #32
 8012db4:	6938      	ldr	r0, [r7, #16]
 8012db6:	6979      	ldr	r1, [r7, #20]
 8012db8:	f7ff fe1a 	bl	80129f0 <MULSHIFT32>
 8012dbc:	4605      	mov	r5, r0
 8012dbe:	68b8      	ldr	r0, [r7, #8]
 8012dc0:	68f9      	ldr	r1, [r7, #12]
 8012dc2:	f7ff fe15 	bl	80129f0 <MULSHIFT32>
 8012dc6:	4603      	mov	r3, r0
 8012dc8:	1aeb      	subs	r3, r5, r3
 8012dca:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012dce:	6023      	str	r3, [r4, #0]
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8012dd0:	687b      	ldr	r3, [r7, #4]
 8012dd2:	f103 041c 	add.w	r4, r3, #28
 8012dd6:	6938      	ldr	r0, [r7, #16]
 8012dd8:	68f9      	ldr	r1, [r7, #12]
 8012dda:	f7ff fe09 	bl	80129f0 <MULSHIFT32>
 8012dde:	4605      	mov	r5, r0
 8012de0:	68b8      	ldr	r0, [r7, #8]
 8012de2:	6979      	ldr	r1, [r7, #20]
 8012de4:	f7ff fe04 	bl	80129f0 <MULSHIFT32>
 8012de8:	4603      	mov	r3, r0
 8012dea:	18eb      	adds	r3, r5, r3
 8012dec:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8012df0:	6023      	str	r3, [r4, #0]
{
	int k, a0, b0, c0, c1;
	const int *c;

	/* csa = Q31 */
	for (k = nBfly; k > 0; k--) {
 8012df2:	69fb      	ldr	r3, [r7, #28]
 8012df4:	f103 33ff 	add.w	r3, r3, #4294967295
 8012df8:	61fb      	str	r3, [r7, #28]
 8012dfa:	69fb      	ldr	r3, [r7, #28]
 8012dfc:	2b00      	cmp	r3, #0
 8012dfe:	f73f ae39 	bgt.w	8012a74 <AntiAlias+0x10>

		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
		x[-8] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
	}
}
 8012e02:	f107 0720 	add.w	r7, r7, #32
 8012e06:	46bd      	mov	sp, r7
 8012e08:	bdb0      	pop	{r4, r5, r7, pc}
 8012e0a:	bf00      	nop

08012e0c <WinPrevious>:
 * Notes:       produces 9 output samples from 18 input samples via symmetry
 *              all blocks gain at least 1 guard bit via window (long blocks get extra
 *                sign bit, short blocks can have one addition but max gain < 1.0)
 **************************************************************************************/
static void WinPrevious(int *xPrev, int *xPrevWin, int btPrev)
{
 8012e0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012e0e:	b08f      	sub	sp, #60	; 0x3c
 8012e10:	af00      	add	r7, sp, #0
 8012e12:	60f8      	str	r0, [r7, #12]
 8012e14:	60b9      	str	r1, [r7, #8]
 8012e16:	607a      	str	r2, [r7, #4]
	int i, x, *xp, *xpwLo, *xpwHi, wLo, wHi;
	const int *wpLo, *wpHi;

	xp = xPrev;
 8012e18:	68fb      	ldr	r3, [r7, #12]
 8012e1a:	633b      	str	r3, [r7, #48]	; 0x30
	/* mapping (see IMDCT12x3): xPrev[0-2] = sum[6-8], xPrev[3-8] = sum[12-17] */
	if (btPrev == 2) {
 8012e1c:	687b      	ldr	r3, [r7, #4]
 8012e1e:	2b02      	cmp	r3, #2
 8012e20:	f040 8146 	bne.w	80130b0 <WinPrevious+0x2a4>
		/* this could be reordered for minimum loads/stores */
		wpLo = imdctWin[btPrev];
 8012e24:	687a      	ldr	r2, [r7, #4]
 8012e26:	4613      	mov	r3, r2
 8012e28:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8012e2c:	189b      	adds	r3, r3, r2
 8012e2e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8012e32:	461a      	mov	r2, r3
 8012e34:	f24e 337c 	movw	r3, #58236	; 0xe37c
 8012e38:	f6c0 0302 	movt	r3, #2050	; 0x802
 8012e3c:	18d3      	adds	r3, r2, r3
 8012e3e:	627b      	str	r3, [r7, #36]	; 0x24
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 8012e40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e42:	f103 0318 	add.w	r3, r3, #24
 8012e46:	681a      	ldr	r2, [r3, #0]
 8012e48:	68fb      	ldr	r3, [r7, #12]
 8012e4a:	f103 0308 	add.w	r3, r3, #8
 8012e4e:	681b      	ldr	r3, [r3, #0]
 8012e50:	4610      	mov	r0, r2
 8012e52:	4619      	mov	r1, r3
 8012e54:	f7ff fdcc 	bl	80129f0 <MULSHIFT32>
 8012e58:	4604      	mov	r4, r0
 8012e5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e5c:	681a      	ldr	r2, [r3, #0]
 8012e5e:	68fb      	ldr	r3, [r7, #12]
 8012e60:	f103 0318 	add.w	r3, r3, #24
 8012e64:	681b      	ldr	r3, [r3, #0]
 8012e66:	4610      	mov	r0, r2
 8012e68:	4619      	mov	r1, r3
 8012e6a:	f7ff fdc1 	bl	80129f0 <MULSHIFT32>
 8012e6e:	4603      	mov	r3, r0
 8012e70:	18e2      	adds	r2, r4, r3
 8012e72:	68bb      	ldr	r3, [r7, #8]
 8012e74:	601a      	str	r2, [r3, #0]
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 8012e76:	68bb      	ldr	r3, [r7, #8]
 8012e78:	f103 0404 	add.w	r4, r3, #4
 8012e7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e7e:	f103 031c 	add.w	r3, r3, #28
 8012e82:	681a      	ldr	r2, [r3, #0]
 8012e84:	68fb      	ldr	r3, [r7, #12]
 8012e86:	f103 0304 	add.w	r3, r3, #4
 8012e8a:	681b      	ldr	r3, [r3, #0]
 8012e8c:	4610      	mov	r0, r2
 8012e8e:	4619      	mov	r1, r3
 8012e90:	f7ff fdae 	bl	80129f0 <MULSHIFT32>
 8012e94:	4605      	mov	r5, r0
 8012e96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e98:	f103 0304 	add.w	r3, r3, #4
 8012e9c:	681a      	ldr	r2, [r3, #0]
 8012e9e:	68fb      	ldr	r3, [r7, #12]
 8012ea0:	f103 031c 	add.w	r3, r3, #28
 8012ea4:	681b      	ldr	r3, [r3, #0]
 8012ea6:	4610      	mov	r0, r2
 8012ea8:	4619      	mov	r1, r3
 8012eaa:	f7ff fda1 	bl	80129f0 <MULSHIFT32>
 8012eae:	4603      	mov	r3, r0
 8012eb0:	18eb      	adds	r3, r5, r3
 8012eb2:	6023      	str	r3, [r4, #0]
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 8012eb4:	68bb      	ldr	r3, [r7, #8]
 8012eb6:	f103 0408 	add.w	r4, r3, #8
 8012eba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012ebc:	f103 0320 	add.w	r3, r3, #32
 8012ec0:	681a      	ldr	r2, [r3, #0]
 8012ec2:	68fb      	ldr	r3, [r7, #12]
 8012ec4:	681b      	ldr	r3, [r3, #0]
 8012ec6:	4610      	mov	r0, r2
 8012ec8:	4619      	mov	r1, r3
 8012eca:	f7ff fd91 	bl	80129f0 <MULSHIFT32>
 8012ece:	4605      	mov	r5, r0
 8012ed0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012ed2:	f103 0308 	add.w	r3, r3, #8
 8012ed6:	681a      	ldr	r2, [r3, #0]
 8012ed8:	68fb      	ldr	r3, [r7, #12]
 8012eda:	f103 0320 	add.w	r3, r3, #32
 8012ede:	681b      	ldr	r3, [r3, #0]
 8012ee0:	4610      	mov	r0, r2
 8012ee2:	4619      	mov	r1, r3
 8012ee4:	f7ff fd84 	bl	80129f0 <MULSHIFT32>
 8012ee8:	4603      	mov	r3, r0
 8012eea:	18eb      	adds	r3, r5, r3
 8012eec:	6023      	str	r3, [r4, #0]
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 8012eee:	68bb      	ldr	r3, [r7, #8]
 8012ef0:	f103 040c 	add.w	r4, r3, #12
 8012ef4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012ef6:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8012efa:	681a      	ldr	r2, [r3, #0]
 8012efc:	68fb      	ldr	r3, [r7, #12]
 8012efe:	681b      	ldr	r3, [r3, #0]
 8012f00:	4610      	mov	r0, r2
 8012f02:	4619      	mov	r1, r3
 8012f04:	f7ff fd74 	bl	80129f0 <MULSHIFT32>
 8012f08:	4605      	mov	r5, r0
 8012f0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012f0c:	f103 030c 	add.w	r3, r3, #12
 8012f10:	681a      	ldr	r2, [r3, #0]
 8012f12:	68fb      	ldr	r3, [r7, #12]
 8012f14:	f103 0320 	add.w	r3, r3, #32
 8012f18:	681b      	ldr	r3, [r3, #0]
 8012f1a:	4610      	mov	r0, r2
 8012f1c:	4619      	mov	r1, r3
 8012f1e:	f7ff fd67 	bl	80129f0 <MULSHIFT32>
 8012f22:	4603      	mov	r3, r0
 8012f24:	18eb      	adds	r3, r5, r3
 8012f26:	6023      	str	r3, [r4, #0]
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 8012f28:	68bb      	ldr	r3, [r7, #8]
 8012f2a:	f103 0410 	add.w	r4, r3, #16
 8012f2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012f30:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8012f34:	681a      	ldr	r2, [r3, #0]
 8012f36:	68fb      	ldr	r3, [r7, #12]
 8012f38:	f103 0304 	add.w	r3, r3, #4
 8012f3c:	681b      	ldr	r3, [r3, #0]
 8012f3e:	4610      	mov	r0, r2
 8012f40:	4619      	mov	r1, r3
 8012f42:	f7ff fd55 	bl	80129f0 <MULSHIFT32>
 8012f46:	4605      	mov	r5, r0
 8012f48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012f4a:	f103 0310 	add.w	r3, r3, #16
 8012f4e:	681a      	ldr	r2, [r3, #0]
 8012f50:	68fb      	ldr	r3, [r7, #12]
 8012f52:	f103 031c 	add.w	r3, r3, #28
 8012f56:	681b      	ldr	r3, [r3, #0]
 8012f58:	4610      	mov	r0, r2
 8012f5a:	4619      	mov	r1, r3
 8012f5c:	f7ff fd48 	bl	80129f0 <MULSHIFT32>
 8012f60:	4603      	mov	r3, r0
 8012f62:	18eb      	adds	r3, r5, r3
 8012f64:	6023      	str	r3, [r4, #0]
		xPrevWin[ 5] = MULSHIFT32(wpLo[11], xPrev[2]) + MULSHIFT32(wpLo[5], xPrev[6]);
 8012f66:	68bb      	ldr	r3, [r7, #8]
 8012f68:	f103 0414 	add.w	r4, r3, #20
 8012f6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012f6e:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8012f72:	681a      	ldr	r2, [r3, #0]
 8012f74:	68fb      	ldr	r3, [r7, #12]
 8012f76:	f103 0308 	add.w	r3, r3, #8
 8012f7a:	681b      	ldr	r3, [r3, #0]
 8012f7c:	4610      	mov	r0, r2
 8012f7e:	4619      	mov	r1, r3
 8012f80:	f7ff fd36 	bl	80129f0 <MULSHIFT32>
 8012f84:	4605      	mov	r5, r0
 8012f86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012f88:	f103 0314 	add.w	r3, r3, #20
 8012f8c:	681a      	ldr	r2, [r3, #0]
 8012f8e:	68fb      	ldr	r3, [r7, #12]
 8012f90:	f103 0318 	add.w	r3, r3, #24
 8012f94:	681b      	ldr	r3, [r3, #0]
 8012f96:	4610      	mov	r0, r2
 8012f98:	4619      	mov	r1, r3
 8012f9a:	f7ff fd29 	bl	80129f0 <MULSHIFT32>
 8012f9e:	4603      	mov	r3, r0
 8012fa0:	18eb      	adds	r3, r5, r3
 8012fa2:	6023      	str	r3, [r4, #0]
		xPrevWin[ 6] = MULSHIFT32(wpLo[ 6], xPrev[5]);
 8012fa4:	68bb      	ldr	r3, [r7, #8]
 8012fa6:	f103 0418 	add.w	r4, r3, #24
 8012faa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012fac:	f103 0318 	add.w	r3, r3, #24
 8012fb0:	681a      	ldr	r2, [r3, #0]
 8012fb2:	68fb      	ldr	r3, [r7, #12]
 8012fb4:	f103 0314 	add.w	r3, r3, #20
 8012fb8:	681b      	ldr	r3, [r3, #0]
 8012fba:	4610      	mov	r0, r2
 8012fbc:	4619      	mov	r1, r3
 8012fbe:	f7ff fd17 	bl	80129f0 <MULSHIFT32>
 8012fc2:	4603      	mov	r3, r0
 8012fc4:	6023      	str	r3, [r4, #0]
		xPrevWin[ 7] = MULSHIFT32(wpLo[ 7], xPrev[4]);
 8012fc6:	68bb      	ldr	r3, [r7, #8]
 8012fc8:	f103 041c 	add.w	r4, r3, #28
 8012fcc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012fce:	f103 031c 	add.w	r3, r3, #28
 8012fd2:	681a      	ldr	r2, [r3, #0]
 8012fd4:	68fb      	ldr	r3, [r7, #12]
 8012fd6:	f103 0310 	add.w	r3, r3, #16
 8012fda:	681b      	ldr	r3, [r3, #0]
 8012fdc:	4610      	mov	r0, r2
 8012fde:	4619      	mov	r1, r3
 8012fe0:	f7ff fd06 	bl	80129f0 <MULSHIFT32>
 8012fe4:	4603      	mov	r3, r0
 8012fe6:	6023      	str	r3, [r4, #0]
		xPrevWin[ 8] = MULSHIFT32(wpLo[ 8], xPrev[3]);
 8012fe8:	68bb      	ldr	r3, [r7, #8]
 8012fea:	f103 0420 	add.w	r4, r3, #32
 8012fee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012ff0:	f103 0320 	add.w	r3, r3, #32
 8012ff4:	681a      	ldr	r2, [r3, #0]
 8012ff6:	68fb      	ldr	r3, [r7, #12]
 8012ff8:	f103 030c 	add.w	r3, r3, #12
 8012ffc:	681b      	ldr	r3, [r3, #0]
 8012ffe:	4610      	mov	r0, r2
 8013000:	4619      	mov	r1, r3
 8013002:	f7ff fcf5 	bl	80129f0 <MULSHIFT32>
 8013006:	4603      	mov	r3, r0
 8013008:	6023      	str	r3, [r4, #0]
		xPrevWin[ 9] = MULSHIFT32(wpLo[ 9], xPrev[3]);
 801300a:	68bb      	ldr	r3, [r7, #8]
 801300c:	f103 0424 	add.w	r4, r3, #36	; 0x24
 8013010:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013012:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8013016:	681a      	ldr	r2, [r3, #0]
 8013018:	68fb      	ldr	r3, [r7, #12]
 801301a:	f103 030c 	add.w	r3, r3, #12
 801301e:	681b      	ldr	r3, [r3, #0]
 8013020:	4610      	mov	r0, r2
 8013022:	4619      	mov	r1, r3
 8013024:	f7ff fce4 	bl	80129f0 <MULSHIFT32>
 8013028:	4603      	mov	r3, r0
 801302a:	6023      	str	r3, [r4, #0]
		xPrevWin[10] = MULSHIFT32(wpLo[10], xPrev[4]);
 801302c:	68bb      	ldr	r3, [r7, #8]
 801302e:	f103 0428 	add.w	r4, r3, #40	; 0x28
 8013032:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013034:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8013038:	681a      	ldr	r2, [r3, #0]
 801303a:	68fb      	ldr	r3, [r7, #12]
 801303c:	f103 0310 	add.w	r3, r3, #16
 8013040:	681b      	ldr	r3, [r3, #0]
 8013042:	4610      	mov	r0, r2
 8013044:	4619      	mov	r1, r3
 8013046:	f7ff fcd3 	bl	80129f0 <MULSHIFT32>
 801304a:	4603      	mov	r3, r0
 801304c:	6023      	str	r3, [r4, #0]
		xPrevWin[11] = MULSHIFT32(wpLo[11], xPrev[5]);
 801304e:	68bb      	ldr	r3, [r7, #8]
 8013050:	f103 042c 	add.w	r4, r3, #44	; 0x2c
 8013054:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013056:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 801305a:	681a      	ldr	r2, [r3, #0]
 801305c:	68fb      	ldr	r3, [r7, #12]
 801305e:	f103 0314 	add.w	r3, r3, #20
 8013062:	681b      	ldr	r3, [r3, #0]
 8013064:	4610      	mov	r0, r2
 8013066:	4619      	mov	r1, r3
 8013068:	f7ff fcc2 	bl	80129f0 <MULSHIFT32>
 801306c:	4603      	mov	r3, r0
 801306e:	6023      	str	r3, [r4, #0]
		xPrevWin[12] = xPrevWin[13] = xPrevWin[14] = xPrevWin[15] = xPrevWin[16] = xPrevWin[17] = 0;
 8013070:	68bb      	ldr	r3, [r7, #8]
 8013072:	f103 0530 	add.w	r5, r3, #48	; 0x30
 8013076:	68bb      	ldr	r3, [r7, #8]
 8013078:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801307c:	68ba      	ldr	r2, [r7, #8]
 801307e:	f102 0238 	add.w	r2, r2, #56	; 0x38
 8013082:	68b9      	ldr	r1, [r7, #8]
 8013084:	f101 013c 	add.w	r1, r1, #60	; 0x3c
 8013088:	68b8      	ldr	r0, [r7, #8]
 801308a:	f100 0040 	add.w	r0, r0, #64	; 0x40
 801308e:	68bc      	ldr	r4, [r7, #8]
 8013090:	f104 0444 	add.w	r4, r4, #68	; 0x44
 8013094:	f04f 0600 	mov.w	r6, #0
 8013098:	6026      	str	r6, [r4, #0]
 801309a:	6824      	ldr	r4, [r4, #0]
 801309c:	6004      	str	r4, [r0, #0]
 801309e:	6800      	ldr	r0, [r0, #0]
 80130a0:	6008      	str	r0, [r1, #0]
 80130a2:	6809      	ldr	r1, [r1, #0]
 80130a4:	6011      	str	r1, [r2, #0]
 80130a6:	6812      	ldr	r2, [r2, #0]
 80130a8:	601a      	str	r2, [r3, #0]
 80130aa:	681b      	ldr	r3, [r3, #0]
 80130ac:	602b      	str	r3, [r5, #0]
 80130ae:	e04e      	b.n	801314e <WinPrevious+0x342>
	} else {
		/* use ARM-style pointers (*ptr++) so that ADS compiles well */
		wpLo = imdctWin[btPrev] + 18;
 80130b0:	687a      	ldr	r2, [r7, #4]
 80130b2:	4613      	mov	r3, r2
 80130b4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80130b8:	189b      	adds	r3, r3, r2
 80130ba:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80130be:	f103 0248 	add.w	r2, r3, #72	; 0x48
 80130c2:	f24e 337c 	movw	r3, #58236	; 0xe37c
 80130c6:	f6c0 0302 	movt	r3, #2050	; 0x802
 80130ca:	18d3      	adds	r3, r2, r3
 80130cc:	627b      	str	r3, [r7, #36]	; 0x24
		wpHi = wpLo + 17;
 80130ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80130d0:	f103 0344 	add.w	r3, r3, #68	; 0x44
 80130d4:	623b      	str	r3, [r7, #32]
		xpwLo = xPrevWin;
 80130d6:	68bb      	ldr	r3, [r7, #8]
 80130d8:	62fb      	str	r3, [r7, #44]	; 0x2c
		xpwHi = xPrevWin + 17;
 80130da:	68bb      	ldr	r3, [r7, #8]
 80130dc:	f103 0344 	add.w	r3, r3, #68	; 0x44
 80130e0:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 9; i > 0; i--) {
 80130e2:	f04f 0309 	mov.w	r3, #9
 80130e6:	637b      	str	r3, [r7, #52]	; 0x34
 80130e8:	e02e      	b.n	8013148 <WinPrevious+0x33c>
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80130ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80130ec:	681b      	ldr	r3, [r3, #0]
 80130ee:	61fb      	str	r3, [r7, #28]
 80130f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80130f2:	f103 0304 	add.w	r3, r3, #4
 80130f6:	633b      	str	r3, [r7, #48]	; 0x30
 80130f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80130fa:	681b      	ldr	r3, [r3, #0]
 80130fc:	61bb      	str	r3, [r7, #24]
 80130fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013100:	f103 0304 	add.w	r3, r3, #4
 8013104:	627b      	str	r3, [r7, #36]	; 0x24
 8013106:	6a3b      	ldr	r3, [r7, #32]
 8013108:	681b      	ldr	r3, [r3, #0]
 801310a:	617b      	str	r3, [r7, #20]
 801310c:	6a3b      	ldr	r3, [r7, #32]
 801310e:	f1a3 0304 	sub.w	r3, r3, #4
 8013112:	623b      	str	r3, [r7, #32]
			*xpwLo++ = MULSHIFT32(wLo, x);
 8013114:	69b8      	ldr	r0, [r7, #24]
 8013116:	69f9      	ldr	r1, [r7, #28]
 8013118:	f7ff fc6a 	bl	80129f0 <MULSHIFT32>
 801311c:	4602      	mov	r2, r0
 801311e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013120:	601a      	str	r2, [r3, #0]
 8013122:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013124:	f103 0304 	add.w	r3, r3, #4
 8013128:	62fb      	str	r3, [r7, #44]	; 0x2c
			*xpwHi-- = MULSHIFT32(wHi, x);
 801312a:	6978      	ldr	r0, [r7, #20]
 801312c:	69f9      	ldr	r1, [r7, #28]
 801312e:	f7ff fc5f 	bl	80129f0 <MULSHIFT32>
 8013132:	4602      	mov	r2, r0
 8013134:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013136:	601a      	str	r2, [r3, #0]
 8013138:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801313a:	f1a3 0304 	sub.w	r3, r3, #4
 801313e:	62bb      	str	r3, [r7, #40]	; 0x28
		/* use ARM-style pointers (*ptr++) so that ADS compiles well */
		wpLo = imdctWin[btPrev] + 18;
		wpHi = wpLo + 17;
		xpwLo = xPrevWin;
		xpwHi = xPrevWin + 17;
		for (i = 9; i > 0; i--) {
 8013140:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013142:	f103 33ff 	add.w	r3, r3, #4294967295
 8013146:	637b      	str	r3, [r7, #52]	; 0x34
 8013148:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801314a:	2b00      	cmp	r3, #0
 801314c:	dccd      	bgt.n	80130ea <WinPrevious+0x2de>
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
			*xpwLo++ = MULSHIFT32(wLo, x);
			*xpwHi-- = MULSHIFT32(wHi, x);
		}
	}
}
 801314e:	f107 073c 	add.w	r7, r7, #60	; 0x3c
 8013152:	46bd      	mov	sp, r7
 8013154:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013156:	bf00      	nop

08013158 <FreqInvertRescale>:
 *              rescaled (as necessary) previous samples
 *
 * Return:      updated mOut (from new outputs y)
 **************************************************************************************/
static int FreqInvertRescale(int *y, int *xPrev, int blockIdx, int es)
{
 8013158:	b580      	push	{r7, lr}
 801315a:	b096      	sub	sp, #88	; 0x58
 801315c:	af00      	add	r7, sp, #0
 801315e:	60f8      	str	r0, [r7, #12]
 8013160:	60b9      	str	r1, [r7, #8]
 8013162:	607a      	str	r2, [r7, #4]
 8013164:	603b      	str	r3, [r7, #0]
	int i, d, mOut;
	int y0, y1, y2, y3, y4, y5, y6, y7, y8;

	if (es == 0) {
 8013166:	683b      	ldr	r3, [r7, #0]
 8013168:	2b00      	cmp	r3, #0
 801316a:	f040 80a2 	bne.w	80132b2 <FreqInvertRescale+0x15a>
		/* fast case - frequency invert only (no rescaling) - can fuse into overlap-add for speed, if desired */
		if (blockIdx & 0x01) {
 801316e:	687b      	ldr	r3, [r7, #4]
 8013170:	f003 0301 	and.w	r3, r3, #1
 8013174:	b2db      	uxtb	r3, r3
 8013176:	2b00      	cmp	r3, #0
 8013178:	f000 8098 	beq.w	80132ac <FreqInvertRescale+0x154>
			y += NBANDS;
 801317c:	68fb      	ldr	r3, [r7, #12]
 801317e:	f103 0380 	add.w	r3, r3, #128	; 0x80
 8013182:	60fb      	str	r3, [r7, #12]
			y0 = *y;	y += 2*NBANDS;
 8013184:	68fb      	ldr	r3, [r7, #12]
 8013186:	681b      	ldr	r3, [r3, #0]
 8013188:	64bb      	str	r3, [r7, #72]	; 0x48
 801318a:	68fb      	ldr	r3, [r7, #12]
 801318c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8013190:	60fb      	str	r3, [r7, #12]
			y1 = *y;	y += 2*NBANDS;
 8013192:	68fb      	ldr	r3, [r7, #12]
 8013194:	681b      	ldr	r3, [r3, #0]
 8013196:	647b      	str	r3, [r7, #68]	; 0x44
 8013198:	68fb      	ldr	r3, [r7, #12]
 801319a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801319e:	60fb      	str	r3, [r7, #12]
			y2 = *y;	y += 2*NBANDS;
 80131a0:	68fb      	ldr	r3, [r7, #12]
 80131a2:	681b      	ldr	r3, [r3, #0]
 80131a4:	643b      	str	r3, [r7, #64]	; 0x40
 80131a6:	68fb      	ldr	r3, [r7, #12]
 80131a8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80131ac:	60fb      	str	r3, [r7, #12]
			y3 = *y;	y += 2*NBANDS;
 80131ae:	68fb      	ldr	r3, [r7, #12]
 80131b0:	681b      	ldr	r3, [r3, #0]
 80131b2:	63fb      	str	r3, [r7, #60]	; 0x3c
 80131b4:	68fb      	ldr	r3, [r7, #12]
 80131b6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80131ba:	60fb      	str	r3, [r7, #12]
			y4 = *y;	y += 2*NBANDS;
 80131bc:	68fb      	ldr	r3, [r7, #12]
 80131be:	681b      	ldr	r3, [r3, #0]
 80131c0:	63bb      	str	r3, [r7, #56]	; 0x38
 80131c2:	68fb      	ldr	r3, [r7, #12]
 80131c4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80131c8:	60fb      	str	r3, [r7, #12]
			y5 = *y;	y += 2*NBANDS;
 80131ca:	68fb      	ldr	r3, [r7, #12]
 80131cc:	681b      	ldr	r3, [r3, #0]
 80131ce:	637b      	str	r3, [r7, #52]	; 0x34
 80131d0:	68fb      	ldr	r3, [r7, #12]
 80131d2:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80131d6:	60fb      	str	r3, [r7, #12]
			y6 = *y;	y += 2*NBANDS;
 80131d8:	68fb      	ldr	r3, [r7, #12]
 80131da:	681b      	ldr	r3, [r3, #0]
 80131dc:	633b      	str	r3, [r7, #48]	; 0x30
 80131de:	68fb      	ldr	r3, [r7, #12]
 80131e0:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80131e4:	60fb      	str	r3, [r7, #12]
			y7 = *y;	y += 2*NBANDS;
 80131e6:	68fb      	ldr	r3, [r7, #12]
 80131e8:	681b      	ldr	r3, [r3, #0]
 80131ea:	62fb      	str	r3, [r7, #44]	; 0x2c
 80131ec:	68fb      	ldr	r3, [r7, #12]
 80131ee:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80131f2:	60fb      	str	r3, [r7, #12]
			y8 = *y;	y += 2*NBANDS;
 80131f4:	68fb      	ldr	r3, [r7, #12]
 80131f6:	681b      	ldr	r3, [r3, #0]
 80131f8:	62bb      	str	r3, [r7, #40]	; 0x28
 80131fa:	68fb      	ldr	r3, [r7, #12]
 80131fc:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8013200:	60fb      	str	r3, [r7, #12]

			y -= 18*NBANDS;
 8013202:	68fb      	ldr	r3, [r7, #12]
 8013204:	f5a3 6310 	sub.w	r3, r3, #2304	; 0x900
 8013208:	60fb      	str	r3, [r7, #12]
			*y = -y0;	y += 2*NBANDS;
 801320a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801320c:	f1c3 0200 	rsb	r2, r3, #0
 8013210:	68fb      	ldr	r3, [r7, #12]
 8013212:	601a      	str	r2, [r3, #0]
 8013214:	68fb      	ldr	r3, [r7, #12]
 8013216:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801321a:	60fb      	str	r3, [r7, #12]
			*y = -y1;	y += 2*NBANDS;
 801321c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801321e:	f1c3 0200 	rsb	r2, r3, #0
 8013222:	68fb      	ldr	r3, [r7, #12]
 8013224:	601a      	str	r2, [r3, #0]
 8013226:	68fb      	ldr	r3, [r7, #12]
 8013228:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801322c:	60fb      	str	r3, [r7, #12]
			*y = -y2;	y += 2*NBANDS;
 801322e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013230:	f1c3 0200 	rsb	r2, r3, #0
 8013234:	68fb      	ldr	r3, [r7, #12]
 8013236:	601a      	str	r2, [r3, #0]
 8013238:	68fb      	ldr	r3, [r7, #12]
 801323a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801323e:	60fb      	str	r3, [r7, #12]
			*y = -y3;	y += 2*NBANDS;
 8013240:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013242:	f1c3 0200 	rsb	r2, r3, #0
 8013246:	68fb      	ldr	r3, [r7, #12]
 8013248:	601a      	str	r2, [r3, #0]
 801324a:	68fb      	ldr	r3, [r7, #12]
 801324c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8013250:	60fb      	str	r3, [r7, #12]
			*y = -y4;	y += 2*NBANDS;
 8013252:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013254:	f1c3 0200 	rsb	r2, r3, #0
 8013258:	68fb      	ldr	r3, [r7, #12]
 801325a:	601a      	str	r2, [r3, #0]
 801325c:	68fb      	ldr	r3, [r7, #12]
 801325e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8013262:	60fb      	str	r3, [r7, #12]
			*y = -y5;	y += 2*NBANDS;
 8013264:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013266:	f1c3 0200 	rsb	r2, r3, #0
 801326a:	68fb      	ldr	r3, [r7, #12]
 801326c:	601a      	str	r2, [r3, #0]
 801326e:	68fb      	ldr	r3, [r7, #12]
 8013270:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8013274:	60fb      	str	r3, [r7, #12]
			*y = -y6;	y += 2*NBANDS;
 8013276:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013278:	f1c3 0200 	rsb	r2, r3, #0
 801327c:	68fb      	ldr	r3, [r7, #12]
 801327e:	601a      	str	r2, [r3, #0]
 8013280:	68fb      	ldr	r3, [r7, #12]
 8013282:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8013286:	60fb      	str	r3, [r7, #12]
			*y = -y7;	y += 2*NBANDS;
 8013288:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801328a:	f1c3 0200 	rsb	r2, r3, #0
 801328e:	68fb      	ldr	r3, [r7, #12]
 8013290:	601a      	str	r2, [r3, #0]
 8013292:	68fb      	ldr	r3, [r7, #12]
 8013294:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8013298:	60fb      	str	r3, [r7, #12]
			*y = -y8;	y += 2*NBANDS;
 801329a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801329c:	f1c3 0200 	rsb	r2, r3, #0
 80132a0:	68fb      	ldr	r3, [r7, #12]
 80132a2:	601a      	str	r2, [r3, #0]
 80132a4:	68fb      	ldr	r3, [r7, #12]
 80132a6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80132aa:	60fb      	str	r3, [r7, #12]
		}
		return 0;
 80132ac:	f04f 0300 	mov.w	r3, #0
 80132b0:	e12d      	b.n	801350e <FreqInvertRescale+0x3b6>
	} else {
		/* undo pre-IMDCT scaling, clipping if necessary */
		mOut = 0;
 80132b2:	f04f 0300 	mov.w	r3, #0
 80132b6:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (blockIdx & 0x01) {
 80132b8:	687b      	ldr	r3, [r7, #4]
 80132ba:	f003 0301 	and.w	r3, r3, #1
 80132be:	b2db      	uxtb	r3, r3
 80132c0:	2b00      	cmp	r3, #0
 80132c2:	f000 8093 	beq.w	80133ec <FreqInvertRescale+0x294>
			/* frequency invert */
			for (i = 0; i < 18; i+=2) {
 80132c6:	f04f 0300 	mov.w	r3, #0
 80132ca:	657b      	str	r3, [r7, #84]	; 0x54
 80132cc:	e089      	b.n	80133e2 <FreqInvertRescale+0x28a>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 80132ce:	68fb      	ldr	r3, [r7, #12]
 80132d0:	681b      	ldr	r3, [r3, #0]
 80132d2:	653b      	str	r3, [r7, #80]	; 0x50
 80132d4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80132d6:	ea4f 73e3 	mov.w	r3, r3, asr #31
 80132da:	627b      	str	r3, [r7, #36]	; 0x24
 80132dc:	683b      	ldr	r3, [r7, #0]
 80132de:	f1c3 031f 	rsb	r3, r3, #31
 80132e2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80132e4:	fa42 f203 	asr.w	r2, r2, r3
 80132e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80132ea:	429a      	cmp	r2, r3
 80132ec:	d00b      	beq.n	8013306 <FreqInvertRescale+0x1ae>
 80132ee:	683b      	ldr	r3, [r7, #0]
 80132f0:	f1c3 031f 	rsb	r3, r3, #31
 80132f4:	f04f 0201 	mov.w	r2, #1
 80132f8:	fa02 f303 	lsl.w	r3, r2, r3
 80132fc:	f103 32ff 	add.w	r2, r3, #4294967295
 8013300:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013302:	4053      	eors	r3, r2
 8013304:	653b      	str	r3, [r7, #80]	; 0x50
 8013306:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8013308:	683b      	ldr	r3, [r7, #0]
 801330a:	fa02 f203 	lsl.w	r2, r2, r3
 801330e:	68fb      	ldr	r3, [r7, #12]
 8013310:	601a      	str	r2, [r3, #0]
 8013312:	68fb      	ldr	r3, [r7, #12]
 8013314:	681b      	ldr	r3, [r3, #0]
 8013316:	4618      	mov	r0, r3
 8013318:	f7ff fb7c 	bl	8012a14 <FASTABS>
 801331c:	4603      	mov	r3, r0
 801331e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8013320:	4313      	orrs	r3, r2
 8013322:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013324:	68fb      	ldr	r3, [r7, #12]
 8013326:	f103 0380 	add.w	r3, r3, #128	; 0x80
 801332a:	60fb      	str	r3, [r7, #12]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801332c:	68fb      	ldr	r3, [r7, #12]
 801332e:	681b      	ldr	r3, [r3, #0]
 8013330:	f1c3 0300 	rsb	r3, r3, #0
 8013334:	653b      	str	r3, [r7, #80]	; 0x50
 8013336:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013338:	ea4f 73e3 	mov.w	r3, r3, asr #31
 801333c:	623b      	str	r3, [r7, #32]
 801333e:	683b      	ldr	r3, [r7, #0]
 8013340:	f1c3 031f 	rsb	r3, r3, #31
 8013344:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8013346:	fa42 f203 	asr.w	r2, r2, r3
 801334a:	6a3b      	ldr	r3, [r7, #32]
 801334c:	429a      	cmp	r2, r3
 801334e:	d00b      	beq.n	8013368 <FreqInvertRescale+0x210>
 8013350:	683b      	ldr	r3, [r7, #0]
 8013352:	f1c3 031f 	rsb	r3, r3, #31
 8013356:	f04f 0201 	mov.w	r2, #1
 801335a:	fa02 f303 	lsl.w	r3, r2, r3
 801335e:	f103 32ff 	add.w	r2, r3, #4294967295
 8013362:	6a3b      	ldr	r3, [r7, #32]
 8013364:	4053      	eors	r3, r2
 8013366:	653b      	str	r3, [r7, #80]	; 0x50
 8013368:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801336a:	683b      	ldr	r3, [r7, #0]
 801336c:	fa02 f203 	lsl.w	r2, r2, r3
 8013370:	68fb      	ldr	r3, [r7, #12]
 8013372:	601a      	str	r2, [r3, #0]
 8013374:	68fb      	ldr	r3, [r7, #12]
 8013376:	681b      	ldr	r3, [r3, #0]
 8013378:	4618      	mov	r0, r3
 801337a:	f7ff fb4b 	bl	8012a14 <FASTABS>
 801337e:	4603      	mov	r3, r0
 8013380:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8013382:	4313      	orrs	r3, r2
 8013384:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013386:	68fb      	ldr	r3, [r7, #12]
 8013388:	f103 0380 	add.w	r3, r3, #128	; 0x80
 801338c:	60fb      	str	r3, [r7, #12]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801338e:	68bb      	ldr	r3, [r7, #8]
 8013390:	681b      	ldr	r3, [r3, #0]
 8013392:	653b      	str	r3, [r7, #80]	; 0x50
 8013394:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013396:	ea4f 73e3 	mov.w	r3, r3, asr #31
 801339a:	61fb      	str	r3, [r7, #28]
 801339c:	683b      	ldr	r3, [r7, #0]
 801339e:	f1c3 031f 	rsb	r3, r3, #31
 80133a2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80133a4:	fa42 f203 	asr.w	r2, r2, r3
 80133a8:	69fb      	ldr	r3, [r7, #28]
 80133aa:	429a      	cmp	r2, r3
 80133ac:	d00b      	beq.n	80133c6 <FreqInvertRescale+0x26e>
 80133ae:	683b      	ldr	r3, [r7, #0]
 80133b0:	f1c3 031f 	rsb	r3, r3, #31
 80133b4:	f04f 0201 	mov.w	r2, #1
 80133b8:	fa02 f303 	lsl.w	r3, r2, r3
 80133bc:	f103 32ff 	add.w	r2, r3, #4294967295
 80133c0:	69fb      	ldr	r3, [r7, #28]
 80133c2:	4053      	eors	r3, r2
 80133c4:	653b      	str	r3, [r7, #80]	; 0x50
 80133c6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80133c8:	683b      	ldr	r3, [r7, #0]
 80133ca:	fa02 f203 	lsl.w	r2, r2, r3
 80133ce:	68bb      	ldr	r3, [r7, #8]
 80133d0:	601a      	str	r2, [r3, #0]
 80133d2:	68bb      	ldr	r3, [r7, #8]
 80133d4:	f103 0304 	add.w	r3, r3, #4
 80133d8:	60bb      	str	r3, [r7, #8]
	} else {
		/* undo pre-IMDCT scaling, clipping if necessary */
		mOut = 0;
		if (blockIdx & 0x01) {
			/* frequency invert */
			for (i = 0; i < 18; i+=2) {
 80133da:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80133dc:	f103 0302 	add.w	r3, r3, #2
 80133e0:	657b      	str	r3, [r7, #84]	; 0x54
 80133e2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80133e4:	2b11      	cmp	r3, #17
 80133e6:	f77f af72 	ble.w	80132ce <FreqInvertRescale+0x176>
 80133ea:	e08f      	b.n	801350c <FreqInvertRescale+0x3b4>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
			}
		} else {
			for (i = 0; i < 18; i+=2) {
 80133ec:	f04f 0300 	mov.w	r3, #0
 80133f0:	657b      	str	r3, [r7, #84]	; 0x54
 80133f2:	e087      	b.n	8013504 <FreqInvertRescale+0x3ac>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 80133f4:	68fb      	ldr	r3, [r7, #12]
 80133f6:	681b      	ldr	r3, [r3, #0]
 80133f8:	653b      	str	r3, [r7, #80]	; 0x50
 80133fa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80133fc:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8013400:	61bb      	str	r3, [r7, #24]
 8013402:	683b      	ldr	r3, [r7, #0]
 8013404:	f1c3 031f 	rsb	r3, r3, #31
 8013408:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801340a:	fa42 f203 	asr.w	r2, r2, r3
 801340e:	69bb      	ldr	r3, [r7, #24]
 8013410:	429a      	cmp	r2, r3
 8013412:	d00b      	beq.n	801342c <FreqInvertRescale+0x2d4>
 8013414:	683b      	ldr	r3, [r7, #0]
 8013416:	f1c3 031f 	rsb	r3, r3, #31
 801341a:	f04f 0201 	mov.w	r2, #1
 801341e:	fa02 f303 	lsl.w	r3, r2, r3
 8013422:	f103 32ff 	add.w	r2, r3, #4294967295
 8013426:	69bb      	ldr	r3, [r7, #24]
 8013428:	4053      	eors	r3, r2
 801342a:	653b      	str	r3, [r7, #80]	; 0x50
 801342c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801342e:	683b      	ldr	r3, [r7, #0]
 8013430:	fa02 f203 	lsl.w	r2, r2, r3
 8013434:	68fb      	ldr	r3, [r7, #12]
 8013436:	601a      	str	r2, [r3, #0]
 8013438:	68fb      	ldr	r3, [r7, #12]
 801343a:	681b      	ldr	r3, [r3, #0]
 801343c:	4618      	mov	r0, r3
 801343e:	f7ff fae9 	bl	8012a14 <FASTABS>
 8013442:	4603      	mov	r3, r0
 8013444:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8013446:	4313      	orrs	r3, r2
 8013448:	64fb      	str	r3, [r7, #76]	; 0x4c
 801344a:	68fb      	ldr	r3, [r7, #12]
 801344c:	f103 0380 	add.w	r3, r3, #128	; 0x80
 8013450:	60fb      	str	r3, [r7, #12]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 8013452:	68fb      	ldr	r3, [r7, #12]
 8013454:	681b      	ldr	r3, [r3, #0]
 8013456:	653b      	str	r3, [r7, #80]	; 0x50
 8013458:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801345a:	ea4f 73e3 	mov.w	r3, r3, asr #31
 801345e:	617b      	str	r3, [r7, #20]
 8013460:	683b      	ldr	r3, [r7, #0]
 8013462:	f1c3 031f 	rsb	r3, r3, #31
 8013466:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8013468:	fa42 f203 	asr.w	r2, r2, r3
 801346c:	697b      	ldr	r3, [r7, #20]
 801346e:	429a      	cmp	r2, r3
 8013470:	d00b      	beq.n	801348a <FreqInvertRescale+0x332>
 8013472:	683b      	ldr	r3, [r7, #0]
 8013474:	f1c3 031f 	rsb	r3, r3, #31
 8013478:	f04f 0201 	mov.w	r2, #1
 801347c:	fa02 f303 	lsl.w	r3, r2, r3
 8013480:	f103 32ff 	add.w	r2, r3, #4294967295
 8013484:	697b      	ldr	r3, [r7, #20]
 8013486:	4053      	eors	r3, r2
 8013488:	653b      	str	r3, [r7, #80]	; 0x50
 801348a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801348c:	683b      	ldr	r3, [r7, #0]
 801348e:	fa02 f203 	lsl.w	r2, r2, r3
 8013492:	68fb      	ldr	r3, [r7, #12]
 8013494:	601a      	str	r2, [r3, #0]
 8013496:	68fb      	ldr	r3, [r7, #12]
 8013498:	681b      	ldr	r3, [r3, #0]
 801349a:	4618      	mov	r0, r3
 801349c:	f7ff faba 	bl	8012a14 <FASTABS>
 80134a0:	4603      	mov	r3, r0
 80134a2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80134a4:	4313      	orrs	r3, r2
 80134a6:	64fb      	str	r3, [r7, #76]	; 0x4c
 80134a8:	68fb      	ldr	r3, [r7, #12]
 80134aa:	f103 0380 	add.w	r3, r3, #128	; 0x80
 80134ae:	60fb      	str	r3, [r7, #12]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 80134b0:	68bb      	ldr	r3, [r7, #8]
 80134b2:	681b      	ldr	r3, [r3, #0]
 80134b4:	653b      	str	r3, [r7, #80]	; 0x50
 80134b6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80134b8:	ea4f 73e3 	mov.w	r3, r3, asr #31
 80134bc:	613b      	str	r3, [r7, #16]
 80134be:	683b      	ldr	r3, [r7, #0]
 80134c0:	f1c3 031f 	rsb	r3, r3, #31
 80134c4:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80134c6:	fa42 f203 	asr.w	r2, r2, r3
 80134ca:	693b      	ldr	r3, [r7, #16]
 80134cc:	429a      	cmp	r2, r3
 80134ce:	d00b      	beq.n	80134e8 <FreqInvertRescale+0x390>
 80134d0:	683b      	ldr	r3, [r7, #0]
 80134d2:	f1c3 031f 	rsb	r3, r3, #31
 80134d6:	f04f 0201 	mov.w	r2, #1
 80134da:	fa02 f303 	lsl.w	r3, r2, r3
 80134de:	f103 32ff 	add.w	r2, r3, #4294967295
 80134e2:	693b      	ldr	r3, [r7, #16]
 80134e4:	4053      	eors	r3, r2
 80134e6:	653b      	str	r3, [r7, #80]	; 0x50
 80134e8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80134ea:	683b      	ldr	r3, [r7, #0]
 80134ec:	fa02 f203 	lsl.w	r2, r2, r3
 80134f0:	68bb      	ldr	r3, [r7, #8]
 80134f2:	601a      	str	r2, [r3, #0]
 80134f4:	68bb      	ldr	r3, [r7, #8]
 80134f6:	f103 0304 	add.w	r3, r3, #4
 80134fa:	60bb      	str	r3, [r7, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
			}
		} else {
			for (i = 0; i < 18; i+=2) {
 80134fc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80134fe:	f103 0302 	add.w	r3, r3, #2
 8013502:	657b      	str	r3, [r7, #84]	; 0x54
 8013504:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8013506:	2b11      	cmp	r3, #17
 8013508:	f77f af74 	ble.w	80133f4 <FreqInvertRescale+0x29c>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
			}
		}
		return mOut;
 801350c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
	}
}
 801350e:	4618      	mov	r0, r3
 8013510:	f107 0758 	add.w	r7, r7, #88	; 0x58
 8013514:	46bd      	mov	sp, r7
 8013516:	bd80      	pop	{r7, pc}

08013518 <idct9>:
	0x7f834ed0, 0x7ba3751d, 0x7401e4c1, 0x68d9f964, 0x5a82799a, 0x496af3e2, 0x36185aee, 0x2120fb83, 0x0b27eb5c, 
};

/* require at least 3 guard bits in x[] to ensure no overflow */
static __inline void idct9(int *x)
{
 8013518:	b580      	push	{r7, lr}
 801351a:	b0b0      	sub	sp, #192	; 0xc0
 801351c:	af00      	add	r7, sp, #0
 801351e:	6078      	str	r0, [r7, #4]
	int a10, a11, a12, a13, a14, a15, a16, a17, a18;
	int a19, a20, a21, a22, a23, a24, a25, a26, a27;
	int m1, m3, m5, m6, m7, m8, m9, m10, m11, m12;
	int x0, x1, x2, x3, x4, x5, x6, x7, x8;

	x0 = x[0]; x1 = x[1]; x2 = x[2]; x3 = x[3]; x4 = x[4];
 8013520:	687b      	ldr	r3, [r7, #4]
 8013522:	681b      	ldr	r3, [r3, #0]
 8013524:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8013528:	687b      	ldr	r3, [r7, #4]
 801352a:	685b      	ldr	r3, [r3, #4]
 801352c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8013530:	687b      	ldr	r3, [r7, #4]
 8013532:	689b      	ldr	r3, [r3, #8]
 8013534:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8013538:	687b      	ldr	r3, [r7, #4]
 801353a:	68db      	ldr	r3, [r3, #12]
 801353c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8013540:	687b      	ldr	r3, [r7, #4]
 8013542:	691b      	ldr	r3, [r3, #16]
 8013544:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	x5 = x[5]; x6 = x[6]; x7 = x[7]; x8 = x[8];
 8013548:	687b      	ldr	r3, [r7, #4]
 801354a:	695b      	ldr	r3, [r3, #20]
 801354c:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8013550:	687b      	ldr	r3, [r7, #4]
 8013552:	699b      	ldr	r3, [r3, #24]
 8013554:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8013558:	687b      	ldr	r3, [r7, #4]
 801355a:	69db      	ldr	r3, [r3, #28]
 801355c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8013560:	687b      	ldr	r3, [r7, #4]
 8013562:	6a1b      	ldr	r3, [r3, #32]
 8013564:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

	a1 = x0 - x6;
 8013568:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 801356c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8013570:	1ad3      	subs	r3, r2, r3
 8013572:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
	a2 = x1 - x5;
 8013576:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 801357a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801357e:	1ad3      	subs	r3, r2, r3
 8013580:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
	a3 = x1 + x5;
 8013584:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8013588:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801358c:	18d3      	adds	r3, r2, r3
 801358e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
	a4 = x2 - x4;
 8013592:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8013596:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801359a:	1ad3      	subs	r3, r2, r3
 801359c:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	a5 = x2 + x4;
 80135a0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80135a4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80135a8:	18d3      	adds	r3, r2, r3
 80135aa:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
	a6 = x2 + x8;
 80135ae:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80135b2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80135b6:	18d3      	adds	r3, r2, r3
 80135b8:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
	a7 = x1 + x7;
 80135bc:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 80135c0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80135c4:	18d3      	adds	r3, r2, r3
 80135c6:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

	a8 = a6 - a5;		/* ie x[8] - x[4] */
 80135ca:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 80135ce:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80135d2:	1ad3      	subs	r3, r2, r3
 80135d4:	67fb      	str	r3, [r7, #124]	; 0x7c
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 80135d6:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 80135da:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80135de:	1ad3      	subs	r3, r2, r3
 80135e0:	67bb      	str	r3, [r7, #120]	; 0x78
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 80135e2:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80135e6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80135ea:	1ad3      	subs	r3, r2, r3
 80135ec:	677b      	str	r3, [r7, #116]	; 0x74
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 80135ee:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 80135f2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80135f6:	1ad3      	subs	r3, r2, r3
 80135f8:	673b      	str	r3, [r7, #112]	; 0x70

	/* do the << 1 as constant shifts where mX is actually used (free, no stall or extra inst.) */
	m1 =  MULSHIFT32(c9_0, x3);
 80135fa:	f24e 2384 	movw	r3, #57988	; 0xe284
 80135fe:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013602:	681b      	ldr	r3, [r3, #0]
 8013604:	4618      	mov	r0, r3
 8013606:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
 801360a:	f7ff f9f1 	bl	80129f0 <MULSHIFT32>
 801360e:	4603      	mov	r3, r0
 8013610:	66fb      	str	r3, [r7, #108]	; 0x6c
	m3 =  MULSHIFT32(c9_0, a10);
 8013612:	f24e 2384 	movw	r3, #57988	; 0xe284
 8013616:	f6c0 0302 	movt	r3, #2050	; 0x802
 801361a:	681b      	ldr	r3, [r3, #0]
 801361c:	4618      	mov	r0, r3
 801361e:	6f79      	ldr	r1, [r7, #116]	; 0x74
 8013620:	f7ff f9e6 	bl	80129f0 <MULSHIFT32>
 8013624:	4603      	mov	r3, r0
 8013626:	66bb      	str	r3, [r7, #104]	; 0x68
	m5 =  MULSHIFT32(c9_1, a5);
 8013628:	f24e 2388 	movw	r3, #57992	; 0xe288
 801362c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013630:	681b      	ldr	r3, [r3, #0]
 8013632:	4618      	mov	r0, r3
 8013634:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 8013638:	f7ff f9da 	bl	80129f0 <MULSHIFT32>
 801363c:	4603      	mov	r3, r0
 801363e:	667b      	str	r3, [r7, #100]	; 0x64
	m6 =  MULSHIFT32(c9_2, a6);
 8013640:	f24e 238c 	movw	r3, #57996	; 0xe28c
 8013644:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013648:	681b      	ldr	r3, [r3, #0]
 801364a:	4618      	mov	r0, r3
 801364c:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 8013650:	f7ff f9ce 	bl	80129f0 <MULSHIFT32>
 8013654:	4603      	mov	r3, r0
 8013656:	663b      	str	r3, [r7, #96]	; 0x60
	m7 =  MULSHIFT32(c9_1, a8);
 8013658:	f24e 2388 	movw	r3, #57992	; 0xe288
 801365c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013660:	681b      	ldr	r3, [r3, #0]
 8013662:	4618      	mov	r0, r3
 8013664:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 8013666:	f7ff f9c3 	bl	80129f0 <MULSHIFT32>
 801366a:	4603      	mov	r3, r0
 801366c:	65fb      	str	r3, [r7, #92]	; 0x5c
	m8 =  MULSHIFT32(c9_2, a5);
 801366e:	f24e 238c 	movw	r3, #57996	; 0xe28c
 8013672:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013676:	681b      	ldr	r3, [r3, #0]
 8013678:	4618      	mov	r0, r3
 801367a:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 801367e:	f7ff f9b7 	bl	80129f0 <MULSHIFT32>
 8013682:	4603      	mov	r3, r0
 8013684:	65bb      	str	r3, [r7, #88]	; 0x58
	m9 =  MULSHIFT32(c9_3, a9);
 8013686:	f24e 2390 	movw	r3, #58000	; 0xe290
 801368a:	f6c0 0302 	movt	r3, #2050	; 0x802
 801368e:	681b      	ldr	r3, [r3, #0]
 8013690:	4618      	mov	r0, r3
 8013692:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 8013694:	f7ff f9ac 	bl	80129f0 <MULSHIFT32>
 8013698:	4603      	mov	r3, r0
 801369a:	657b      	str	r3, [r7, #84]	; 0x54
	m10 = MULSHIFT32(c9_4, a7);
 801369c:	f24e 2394 	movw	r3, #58004	; 0xe294
 80136a0:	f6c0 0302 	movt	r3, #2050	; 0x802
 80136a4:	681b      	ldr	r3, [r3, #0]
 80136a6:	4618      	mov	r0, r3
 80136a8:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 80136ac:	f7ff f9a0 	bl	80129f0 <MULSHIFT32>
 80136b0:	4603      	mov	r3, r0
 80136b2:	653b      	str	r3, [r7, #80]	; 0x50
	m11 = MULSHIFT32(c9_3, a3);
 80136b4:	f24e 2390 	movw	r3, #58000	; 0xe290
 80136b8:	f6c0 0302 	movt	r3, #2050	; 0x802
 80136bc:	681b      	ldr	r3, [r3, #0]
 80136be:	4618      	mov	r0, r3
 80136c0:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
 80136c4:	f7ff f994 	bl	80129f0 <MULSHIFT32>
 80136c8:	4603      	mov	r3, r0
 80136ca:	64fb      	str	r3, [r7, #76]	; 0x4c
	m12 = MULSHIFT32(c9_4, a9);
 80136cc:	f24e 2394 	movw	r3, #58004	; 0xe294
 80136d0:	f6c0 0302 	movt	r3, #2050	; 0x802
 80136d4:	681b      	ldr	r3, [r3, #0]
 80136d6:	4618      	mov	r0, r3
 80136d8:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 80136da:	f7ff f989 	bl	80129f0 <MULSHIFT32>
 80136de:	4603      	mov	r3, r0
 80136e0:	64bb      	str	r3, [r7, #72]	; 0x48

	a12 = x[0] +  (x[6] >> 1);
 80136e2:	687b      	ldr	r3, [r7, #4]
 80136e4:	681a      	ldr	r2, [r3, #0]
 80136e6:	687b      	ldr	r3, [r7, #4]
 80136e8:	f103 0318 	add.w	r3, r3, #24
 80136ec:	681b      	ldr	r3, [r3, #0]
 80136ee:	ea4f 0363 	mov.w	r3, r3, asr #1
 80136f2:	18d3      	adds	r3, r2, r3
 80136f4:	647b      	str	r3, [r7, #68]	; 0x44
	a13 = a12  +  (  m1 << 1);
 80136f6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80136f8:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80136fc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80136fe:	18d3      	adds	r3, r2, r3
 8013700:	643b      	str	r3, [r7, #64]	; 0x40
	a14 = a12  -  (  m1 << 1);
 8013702:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8013704:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8013708:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801370a:	1ad3      	subs	r3, r2, r3
 801370c:	63fb      	str	r3, [r7, #60]	; 0x3c
	a15 = a1   +  ( a11 >> 1);
 801370e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8013710:	ea4f 0263 	mov.w	r2, r3, asr #1
 8013714:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8013718:	18d3      	adds	r3, r2, r3
 801371a:	63bb      	str	r3, [r7, #56]	; 0x38
	a16 = ( m5 << 1) + (m6 << 1);
 801371c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801371e:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8013722:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8013724:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8013728:	18d3      	adds	r3, r2, r3
 801372a:	637b      	str	r3, [r7, #52]	; 0x34
	a17 = ( m7 << 1) - (m8 << 1);
 801372c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801372e:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8013732:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8013734:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8013738:	1ad3      	subs	r3, r2, r3
 801373a:	633b      	str	r3, [r7, #48]	; 0x30
	a18 = a16 + a17;
 801373c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801373e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013740:	18d3      	adds	r3, r2, r3
 8013742:	62fb      	str	r3, [r7, #44]	; 0x2c
	a19 = ( m9 << 1) + (m10 << 1);
 8013744:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8013746:	ea4f 0243 	mov.w	r2, r3, lsl #1
 801374a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801374c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8013750:	18d3      	adds	r3, r2, r3
 8013752:	62bb      	str	r3, [r7, #40]	; 0x28
	a20 = (m11 << 1) - (m12 << 1);
 8013754:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013756:	ea4f 0243 	mov.w	r2, r3, lsl #1
 801375a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801375c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8013760:	1ad3      	subs	r3, r2, r3
 8013762:	627b      	str	r3, [r7, #36]	; 0x24

	a21 = a20 - a19;
 8013764:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013766:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013768:	1ad3      	subs	r3, r2, r3
 801376a:	623b      	str	r3, [r7, #32]
	a22 = a13 + a16;
 801376c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801376e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013770:	18d3      	adds	r3, r2, r3
 8013772:	61fb      	str	r3, [r7, #28]
	a23 = a14 + a16;
 8013774:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8013776:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013778:	18d3      	adds	r3, r2, r3
 801377a:	61bb      	str	r3, [r7, #24]
	a24 = a14 + a17;
 801377c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801377e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013780:	18d3      	adds	r3, r2, r3
 8013782:	617b      	str	r3, [r7, #20]
	a25 = a13 + a17;
 8013784:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013786:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013788:	18d3      	adds	r3, r2, r3
 801378a:	613b      	str	r3, [r7, #16]
	a26 = a14 - a18;
 801378c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801378e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013790:	1ad3      	subs	r3, r2, r3
 8013792:	60fb      	str	r3, [r7, #12]
	a27 = a13 - a18;
 8013794:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013796:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013798:	1ad3      	subs	r3, r2, r3
 801379a:	60bb      	str	r3, [r7, #8]

	x0 = a22 + a19;			x[0] = x0;
 801379c:	69fa      	ldr	r2, [r7, #28]
 801379e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80137a0:	18d3      	adds	r3, r2, r3
 80137a2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 80137a6:	687b      	ldr	r3, [r7, #4]
 80137a8:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80137ac:	601a      	str	r2, [r3, #0]
	x1 = a15 + (m3 << 1);	x[1] = x1;
 80137ae:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80137b0:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80137b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80137b6:	18d3      	adds	r3, r2, r3
 80137b8:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 80137bc:	687b      	ldr	r3, [r7, #4]
 80137be:	f103 0304 	add.w	r3, r3, #4
 80137c2:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 80137c6:	601a      	str	r2, [r3, #0]
	x2 = a24 + a20;			x[2] = x2;
 80137c8:	697a      	ldr	r2, [r7, #20]
 80137ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80137cc:	18d3      	adds	r3, r2, r3
 80137ce:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 80137d2:	687b      	ldr	r3, [r7, #4]
 80137d4:	f103 0308 	add.w	r3, r3, #8
 80137d8:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80137dc:	601a      	str	r2, [r3, #0]
	x3 = a26 - a21;			x[3] = x3;
 80137de:	68fa      	ldr	r2, [r7, #12]
 80137e0:	6a3b      	ldr	r3, [r7, #32]
 80137e2:	1ad3      	subs	r3, r2, r3
 80137e4:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 80137e8:	687b      	ldr	r3, [r7, #4]
 80137ea:	f103 030c 	add.w	r3, r3, #12
 80137ee:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 80137f2:	601a      	str	r2, [r3, #0]
	x4 = a1 - a11;			x[4] = x4;
 80137f4:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80137f8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80137fa:	1ad3      	subs	r3, r2, r3
 80137fc:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8013800:	687b      	ldr	r3, [r7, #4]
 8013802:	f103 0310 	add.w	r3, r3, #16
 8013806:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 801380a:	601a      	str	r2, [r3, #0]
	x5 = a27 + a21;			x[5] = x5;
 801380c:	68ba      	ldr	r2, [r7, #8]
 801380e:	6a3b      	ldr	r3, [r7, #32]
 8013810:	18d3      	adds	r3, r2, r3
 8013812:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8013816:	687b      	ldr	r3, [r7, #4]
 8013818:	f103 0314 	add.w	r3, r3, #20
 801381c:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8013820:	601a      	str	r2, [r3, #0]
	x6 = a25 - a20;			x[6] = x6;
 8013822:	693a      	ldr	r2, [r7, #16]
 8013824:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013826:	1ad3      	subs	r3, r2, r3
 8013828:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 801382c:	687b      	ldr	r3, [r7, #4]
 801382e:	f103 0318 	add.w	r3, r3, #24
 8013832:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8013836:	601a      	str	r2, [r3, #0]
	x7 = a15 - (m3 << 1);	x[7] = x7;
 8013838:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801383a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801383e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8013840:	1ad3      	subs	r3, r2, r3
 8013842:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8013846:	687b      	ldr	r3, [r7, #4]
 8013848:	f103 031c 	add.w	r3, r3, #28
 801384c:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8013850:	601a      	str	r2, [r3, #0]
	x8 = a23 - a19;			x[8] = x8;
 8013852:	69ba      	ldr	r2, [r7, #24]
 8013854:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013856:	1ad3      	subs	r3, r2, r3
 8013858:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 801385c:	687b      	ldr	r3, [r7, #4]
 801385e:	f103 0320 	add.w	r3, r3, #32
 8013862:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8013866:	601a      	str	r2, [r3, #0]
}
 8013868:	f107 07c0 	add.w	r7, r7, #192	; 0xc0
 801386c:	46bd      	mov	sp, r7
 801386e:	bd80      	pop	{r7, pc}

08013870 <IMDCT36>:
 *
 * TODO:        optimize for ARM (reorder window coefs, ARM-style pointers in C, 
 *                inline asm may or may not be helpful)
 **************************************************************************************/
static int IMDCT36(int *xCurr, int *xPrev, int *y, int btCurr, int btPrev, int blockIdx, int gb)
{
 8013870:	b590      	push	{r4, r7, lr}
 8013872:	b0b9      	sub	sp, #228	; 0xe4
 8013874:	af00      	add	r7, sp, #0
 8013876:	60f8      	str	r0, [r7, #12]
 8013878:	60b9      	str	r1, [r7, #8]
 801387a:	607a      	str	r2, [r7, #4]
 801387c:	603b      	str	r3, [r7, #0]
	int i, es, xBuf[18], xPrevWin[18];
	int acc1, acc2, s, d, t, mOut;
	int xo, xe, c, *xp, yLo, yHi;
	const int *cp, *wp;

	acc1 = acc2 = 0;
 801387e:	f04f 0300 	mov.w	r3, #0
 8013882:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8013886:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 801388a:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	xCurr += 17;
 801388e:	68fb      	ldr	r3, [r7, #12]
 8013890:	f103 0344 	add.w	r3, r3, #68	; 0x44
 8013894:	60fb      	str	r3, [r7, #12]

	/* 7 gb is always adequate for antialias + accumulator loop + idct9 */
	if (gb < 7) {
 8013896:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 801389a:	2b06      	cmp	r3, #6
 801389c:	dc64      	bgt.n	8013968 <IMDCT36+0xf8>
		/* rarely triggered - 5% to 10% of the time on normal clips (with Q25 input) */
		es = 7 - gb;
 801389e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80138a2:	f1c3 0307 	rsb	r3, r3, #7
 80138a6:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
		for (i = 8; i >= 0; i--) {	
 80138aa:	f04f 0308 	mov.w	r3, #8
 80138ae:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 80138b2:	e054      	b.n	801395e <IMDCT36+0xee>
			acc1 = ((*xCurr--) >> es) - acc1;
 80138b4:	68fb      	ldr	r3, [r7, #12]
 80138b6:	681a      	ldr	r2, [r3, #0]
 80138b8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80138bc:	fa42 f203 	asr.w	r2, r2, r3
 80138c0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80138c4:	1ad3      	subs	r3, r2, r3
 80138c6:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 80138ca:	68fb      	ldr	r3, [r7, #12]
 80138cc:	f1a3 0304 	sub.w	r3, r3, #4
 80138d0:	60fb      	str	r3, [r7, #12]
			acc2 = acc1 - acc2;
 80138d2:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 80138d6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80138da:	1ad3      	subs	r3, r2, r3
 80138dc:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
			acc1 = ((*xCurr--) >> es) - acc1;
 80138e0:	68fb      	ldr	r3, [r7, #12]
 80138e2:	681a      	ldr	r2, [r3, #0]
 80138e4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80138e8:	fa42 f203 	asr.w	r2, r2, r3
 80138ec:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80138f0:	1ad3      	subs	r3, r2, r3
 80138f2:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 80138f6:	68fb      	ldr	r3, [r7, #12]
 80138f8:	f1a3 0304 	sub.w	r3, r3, #4
 80138fc:	60fb      	str	r3, [r7, #12]
			xBuf[i+9] = acc2;	/* odd */
 80138fe:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013902:	f103 0309 	add.w	r3, r3, #9
 8013906:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801390a:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 801390e:	18d3      	adds	r3, r2, r3
 8013910:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8013914:	f843 2c88 	str.w	r2, [r3, #-136]
			xBuf[i+0] = acc1;	/* even */
 8013918:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801391c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013920:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 8013924:	18d3      	adds	r3, r2, r3
 8013926:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 801392a:	f843 2c88 	str.w	r2, [r3, #-136]
			xPrev[i] >>= es;
 801392e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013932:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013936:	68ba      	ldr	r2, [r7, #8]
 8013938:	18d3      	adds	r3, r2, r3
 801393a:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 801393e:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8013942:	68b9      	ldr	r1, [r7, #8]
 8013944:	188a      	adds	r2, r1, r2
 8013946:	6811      	ldr	r1, [r2, #0]
 8013948:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 801394c:	fa41 f202 	asr.w	r2, r1, r2
 8013950:	601a      	str	r2, [r3, #0]

	/* 7 gb is always adequate for antialias + accumulator loop + idct9 */
	if (gb < 7) {
		/* rarely triggered - 5% to 10% of the time on normal clips (with Q25 input) */
		es = 7 - gb;
		for (i = 8; i >= 0; i--) {	
 8013952:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013956:	f103 33ff 	add.w	r3, r3, #4294967295
 801395a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 801395e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013962:	2b00      	cmp	r3, #0
 8013964:	daa6      	bge.n	80138b4 <IMDCT36+0x44>
 8013966:	e047      	b.n	80139f8 <IMDCT36+0x188>
			xBuf[i+9] = acc2;	/* odd */
			xBuf[i+0] = acc1;	/* even */
			xPrev[i] >>= es;
		}
	} else {
		es = 0;
 8013968:	f04f 0300 	mov.w	r3, #0
 801396c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
		/* max gain = 18, assume adequate guard bits */
		for (i = 8; i >= 0; i--) {	
 8013970:	f04f 0308 	mov.w	r3, #8
 8013974:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8013978:	e03a      	b.n	80139f0 <IMDCT36+0x180>
			acc1 = (*xCurr--) - acc1;
 801397a:	68fb      	ldr	r3, [r7, #12]
 801397c:	681a      	ldr	r2, [r3, #0]
 801397e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8013982:	1ad3      	subs	r3, r2, r3
 8013984:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8013988:	68fb      	ldr	r3, [r7, #12]
 801398a:	f1a3 0304 	sub.w	r3, r3, #4
 801398e:	60fb      	str	r3, [r7, #12]
			acc2 = acc1 - acc2;
 8013990:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8013994:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8013998:	1ad3      	subs	r3, r2, r3
 801399a:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
			acc1 = (*xCurr--) - acc1;
 801399e:	68fb      	ldr	r3, [r7, #12]
 80139a0:	681a      	ldr	r2, [r3, #0]
 80139a2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80139a6:	1ad3      	subs	r3, r2, r3
 80139a8:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 80139ac:	68fb      	ldr	r3, [r7, #12]
 80139ae:	f1a3 0304 	sub.w	r3, r3, #4
 80139b2:	60fb      	str	r3, [r7, #12]
			xBuf[i+9] = acc2;	/* odd */
 80139b4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80139b8:	f103 0309 	add.w	r3, r3, #9
 80139bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80139c0:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 80139c4:	18d3      	adds	r3, r2, r3
 80139c6:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 80139ca:	f843 2c88 	str.w	r2, [r3, #-136]
			xBuf[i+0] = acc1;	/* even */
 80139ce:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80139d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80139d6:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 80139da:	18d3      	adds	r3, r2, r3
 80139dc:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 80139e0:	f843 2c88 	str.w	r2, [r3, #-136]
			xPrev[i] >>= es;
		}
	} else {
		es = 0;
		/* max gain = 18, assume adequate guard bits */
		for (i = 8; i >= 0; i--) {	
 80139e4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80139e8:	f103 33ff 	add.w	r3, r3, #4294967295
 80139ec:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 80139f0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80139f4:	2b00      	cmp	r3, #0
 80139f6:	dac0      	bge.n	801397a <IMDCT36+0x10a>
			xBuf[i+9] = acc2;	/* odd */
			xBuf[i+0] = acc1;	/* even */
		}
	}
	/* xEven[0] and xOdd[0] scaled by 0.5 */
	xBuf[9] >>= 1;
 80139f8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80139fa:	ea4f 0363 	mov.w	r3, r3, asr #1
 80139fe:	67fb      	str	r3, [r7, #124]	; 0x7c
	xBuf[0] >>= 1;
 8013a00:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8013a02:	ea4f 0363 	mov.w	r3, r3, asr #1
 8013a06:	65bb      	str	r3, [r7, #88]	; 0x58

	/* do 9-point IDCT on even and odd */
	idct9(xBuf+0);	/* even */
 8013a08:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8013a0c:	4618      	mov	r0, r3
 8013a0e:	f7ff fd83 	bl	8013518 <idct9>
	idct9(xBuf+9);	/* odd */
 8013a12:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8013a16:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8013a1a:	4618      	mov	r0, r3
 8013a1c:	f7ff fd7c 	bl	8013518 <idct9>

	xp = xBuf + 8;
 8013a20:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8013a24:	f103 0320 	add.w	r3, r3, #32
 8013a28:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	cp = c18 + 8;
 8013a2c:	4bd1      	ldr	r3, [pc, #836]	; (8013d74 <IMDCT36+0x504>)
 8013a2e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
	mOut = 0;
 8013a32:	f04f 0300 	mov.w	r3, #0
 8013a36:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	if (btPrev == 0 && btCurr == 0) {
 8013a3a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8013a3e:	2b00      	cmp	r3, #0
 8013a40:	f040 80b8 	bne.w	8013bb4 <IMDCT36+0x344>
 8013a44:	683b      	ldr	r3, [r7, #0]
 8013a46:	2b00      	cmp	r3, #0
 8013a48:	f040 80b4 	bne.w	8013bb4 <IMDCT36+0x344>
		/* fast path - use symmetry of sin window to reduce windowing multiplies to 18 (N/2) */
		wp = fastWin36;
 8013a4c:	f24e 23bc 	movw	r3, #58044	; 0xe2bc
 8013a50:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013a54:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
		for (i = 0; i < 9; i++) {
 8013a58:	f04f 0300 	mov.w	r3, #0
 8013a5c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8013a60:	e0a2      	b.n	8013ba8 <IMDCT36+0x338>
			/* do ARM-style pointer arithmetic (i still needed for y[] indexing - compiler spills if 2 y pointers) */
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 8013a62:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8013a66:	681b      	ldr	r3, [r3, #0]
 8013a68:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8013a6c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8013a70:	f1a3 0304 	sub.w	r3, r3, #4
 8013a74:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8013a78:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8013a7c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013a7e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8013a82:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8013a86:	681b      	ldr	r3, [r3, #0]
 8013a88:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8013a8c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8013a90:	f1a3 0304 	sub.w	r3, r3, #4
 8013a94:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
			/* gain 2 int bits here */
			xo = MULSHIFT32(c, xo);			/* 2*c18*xOdd (mul by 2 implicit in scaling)  */
 8013a98:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 8013a9c:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
 8013aa0:	f7fe ffa6 	bl	80129f0 <MULSHIFT32>
 8013aa4:	4603      	mov	r3, r0
 8013aa6:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
			xe >>= 2;
 8013aaa:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8013aae:	ea4f 03a3 	mov.w	r3, r3, asr #2
 8013ab2:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4

			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 8013ab6:	68bb      	ldr	r3, [r7, #8]
 8013ab8:	681b      	ldr	r3, [r3, #0]
 8013aba:	f1c3 0300 	rsb	r3, r3, #0
 8013abe:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 8013ac2:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8013ac6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8013aca:	1ad3      	subs	r3, r2, r3
 8013acc:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 8013ad0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8013ad4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8013ad8:	18d2      	adds	r2, r2, r3
 8013ada:	68bb      	ldr	r3, [r7, #8]
 8013adc:	601a      	str	r2, [r3, #0]
 8013ade:	68bb      	ldr	r3, [r7, #8]
 8013ae0:	f103 0304 	add.w	r3, r3, #4
 8013ae4:	60bb      	str	r3, [r7, #8]
			t = s - d;
 8013ae6:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8013aea:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8013aee:	1ad3      	subs	r3, r2, r3
 8013af0:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 8013af4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8013af8:	681b      	ldr	r3, [r3, #0]
 8013afa:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8013afe:	f102 0204 	add.w	r2, r2, #4
 8013b02:	f8c7 20c0 	str.w	r2, [r7, #192]	; 0xc0
 8013b06:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8013b0a:	4619      	mov	r1, r3
 8013b0c:	f7fe ff70 	bl	80129f0 <MULSHIFT32>
 8013b10:	4603      	mov	r3, r0
 8013b12:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8013b16:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8013b1a:	18d3      	adds	r3, r2, r3
 8013b1c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 8013b20:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8013b24:	681b      	ldr	r3, [r3, #0]
 8013b26:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8013b2a:	f102 0204 	add.w	r2, r2, #4
 8013b2e:	f8c7 20c0 	str.w	r2, [r7, #192]	; 0xc0
 8013b32:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8013b36:	4619      	mov	r1, r3
 8013b38:	f7fe ff5a 	bl	80129f0 <MULSHIFT32>
 8013b3c:	4603      	mov	r3, r0
 8013b3e:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8013b42:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8013b46:	18d3      	adds	r3, r2, r3
 8013b48:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
			y[(i)*NBANDS]    = 	yLo;
 8013b4c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013b50:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8013b54:	687a      	ldr	r2, [r7, #4]
 8013b56:	18d3      	adds	r3, r2, r3
 8013b58:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8013b5c:	601a      	str	r2, [r3, #0]
			y[(17-i)*NBANDS] =  yHi;
 8013b5e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013b62:	f1c3 0311 	rsb	r3, r3, #17
 8013b66:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8013b6a:	687a      	ldr	r2, [r7, #4]
 8013b6c:	18d3      	adds	r3, r2, r3
 8013b6e:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8013b72:	601a      	str	r2, [r3, #0]
			mOut |= FASTABS(yLo);
 8013b74:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8013b78:	f7fe ff4c 	bl	8012a14 <FASTABS>
 8013b7c:	4603      	mov	r3, r0
 8013b7e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8013b82:	4313      	orrs	r3, r2
 8013b84:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
			mOut |= FASTABS(yHi);
 8013b88:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8013b8c:	f7fe ff42 	bl	8012a14 <FASTABS>
 8013b90:	4603      	mov	r3, r0
 8013b92:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8013b96:	4313      	orrs	r3, r2
 8013b98:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	cp = c18 + 8;
	mOut = 0;
	if (btPrev == 0 && btCurr == 0) {
		/* fast path - use symmetry of sin window to reduce windowing multiplies to 18 (N/2) */
		wp = fastWin36;
		for (i = 0; i < 9; i++) {
 8013b9c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013ba0:	f103 0301 	add.w	r3, r3, #1
 8013ba4:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8013ba8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013bac:	2b08      	cmp	r3, #8
 8013bae:	f77f af58 	ble.w	8013a62 <IMDCT36+0x1f2>
	idct9(xBuf+9);	/* odd */

	xp = xBuf + 8;
	cp = c18 + 8;
	mOut = 0;
	if (btPrev == 0 && btCurr == 0) {
 8013bb2:	e0c6      	b.n	8013d42 <IMDCT36+0x4d2>
		}
	} else {
		/* slower method - either prev or curr is using window type != 0 so do full 36-point window 
		 * output xPrevWin has at least 3 guard bits (xPrev has 2, gain 1 in WinPrevious)
		 */
		WinPrevious(xPrev, xPrevWin, btPrev);
 8013bb4:	f107 0310 	add.w	r3, r7, #16
 8013bb8:	68b8      	ldr	r0, [r7, #8]
 8013bba:	4619      	mov	r1, r3
 8013bbc:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 8013bc0:	f7ff f924 	bl	8012e0c <WinPrevious>

		wp = imdctWin[btCurr];
 8013bc4:	683a      	ldr	r2, [r7, #0]
 8013bc6:	4613      	mov	r3, r2
 8013bc8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8013bcc:	189b      	adds	r3, r3, r2
 8013bce:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8013bd2:	461a      	mov	r2, r3
 8013bd4:	f24e 337c 	movw	r3, #58236	; 0xe37c
 8013bd8:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013bdc:	18d3      	adds	r3, r2, r3
 8013bde:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
		for (i = 0; i < 9; i++) {
 8013be2:	f04f 0300 	mov.w	r3, #0
 8013be6:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8013bea:	e0a5      	b.n	8013d38 <IMDCT36+0x4c8>
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 8013bec:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8013bf0:	681b      	ldr	r3, [r3, #0]
 8013bf2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8013bf6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8013bfa:	f1a3 0304 	sub.w	r3, r3, #4
 8013bfe:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8013c02:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8013c06:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013c08:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8013c0c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8013c10:	681b      	ldr	r3, [r3, #0]
 8013c12:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8013c16:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8013c1a:	f1a3 0304 	sub.w	r3, r3, #4
 8013c1e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
			/* gain 2 int bits here */
			xo = MULSHIFT32(c, xo);			/* 2*c18*xOdd (mul by 2 implicit in scaling)  */
 8013c22:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 8013c26:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
 8013c2a:	f7fe fee1 	bl	80129f0 <MULSHIFT32>
 8013c2e:	4603      	mov	r3, r0
 8013c30:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
			xe >>= 2;
 8013c34:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8013c38:	ea4f 03a3 	mov.w	r3, r3, asr #2
 8013c3c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4

			d = xe - xo;
 8013c40:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8013c44:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8013c48:	1ad3      	subs	r3, r2, r3
 8013c4a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 8013c4e:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8013c52:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8013c56:	18d2      	adds	r2, r2, r3
 8013c58:	68bb      	ldr	r3, [r7, #8]
 8013c5a:	601a      	str	r2, [r3, #0]
 8013c5c:	68bb      	ldr	r3, [r7, #8]
 8013c5e:	f103 0304 	add.w	r3, r3, #4
 8013c62:	60bb      	str	r3, [r7, #8]
			
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 8013c64:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013c68:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013c6c:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 8013c70:	18d3      	adds	r3, r2, r3
 8013c72:	f853 4cd0 	ldr.w	r4, [r3, #-208]
 8013c76:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013c7a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013c7e:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8013c82:	18d3      	adds	r3, r2, r3
 8013c84:	681b      	ldr	r3, [r3, #0]
 8013c86:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 8013c8a:	4619      	mov	r1, r3
 8013c8c:	f7fe feb0 	bl	80129f0 <MULSHIFT32>
 8013c90:	4603      	mov	r3, r0
 8013c92:	18e3      	adds	r3, r4, r3
 8013c94:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013c98:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 8013c9c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013ca0:	f1c3 0311 	rsb	r3, r3, #17
 8013ca4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013ca8:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 8013cac:	18d3      	adds	r3, r2, r3
 8013cae:	f853 4cd0 	ldr.w	r4, [r3, #-208]
 8013cb2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013cb6:	f1c3 0311 	rsb	r3, r3, #17
 8013cba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013cbe:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8013cc2:	18d3      	adds	r3, r2, r3
 8013cc4:	681b      	ldr	r3, [r3, #0]
 8013cc6:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 8013cca:	4619      	mov	r1, r3
 8013ccc:	f7fe fe90 	bl	80129f0 <MULSHIFT32>
 8013cd0:	4603      	mov	r3, r0
 8013cd2:	18e3      	adds	r3, r4, r3
 8013cd4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013cd8:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
			y[(i)*NBANDS]    = yLo;
 8013cdc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013ce0:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8013ce4:	687a      	ldr	r2, [r7, #4]
 8013ce6:	18d3      	adds	r3, r2, r3
 8013ce8:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8013cec:	601a      	str	r2, [r3, #0]
			y[(17-i)*NBANDS] = yHi;
 8013cee:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013cf2:	f1c3 0311 	rsb	r3, r3, #17
 8013cf6:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8013cfa:	687a      	ldr	r2, [r7, #4]
 8013cfc:	18d3      	adds	r3, r2, r3
 8013cfe:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8013d02:	601a      	str	r2, [r3, #0]
			mOut |= FASTABS(yLo);
 8013d04:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8013d08:	f7fe fe84 	bl	8012a14 <FASTABS>
 8013d0c:	4603      	mov	r3, r0
 8013d0e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8013d12:	4313      	orrs	r3, r2
 8013d14:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
			mOut |= FASTABS(yHi);
 8013d18:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8013d1c:	f7fe fe7a 	bl	8012a14 <FASTABS>
 8013d20:	4603      	mov	r3, r0
 8013d22:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8013d26:	4313      	orrs	r3, r2
 8013d28:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
		 * output xPrevWin has at least 3 guard bits (xPrev has 2, gain 1 in WinPrevious)
		 */
		WinPrevious(xPrev, xPrevWin, btPrev);

		wp = imdctWin[btCurr];
		for (i = 0; i < 9; i++) {
 8013d2c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013d30:	f103 0301 	add.w	r3, r3, #1
 8013d34:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8013d38:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8013d3c:	2b08      	cmp	r3, #8
 8013d3e:	f77f af55 	ble.w	8013bec <IMDCT36+0x37c>
			mOut |= FASTABS(yLo);
			mOut |= FASTABS(yHi);
		}
	}

	xPrev -= 9;
 8013d42:	68bb      	ldr	r3, [r7, #8]
 8013d44:	f1a3 0324 	sub.w	r3, r3, #36	; 0x24
 8013d48:	60bb      	str	r3, [r7, #8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8013d4a:	6878      	ldr	r0, [r7, #4]
 8013d4c:	68b9      	ldr	r1, [r7, #8]
 8013d4e:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8013d52:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8013d56:	f7ff f9ff 	bl	8013158 <FreqInvertRescale>
 8013d5a:	4603      	mov	r3, r0
 8013d5c:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8013d60:	4313      	orrs	r3, r2
 8013d62:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc

	return mOut;
 8013d66:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
}
 8013d6a:	4618      	mov	r0, r3
 8013d6c:	f107 07e4 	add.w	r7, r7, #228	; 0xe4
 8013d70:	46bd      	mov	sp, r7
 8013d72:	bd90      	pop	{r4, r7, pc}
 8013d74:	0802e2b8 	.word	0x0802e2b8

08013d78 <imdct12>:

/* 12-point inverse DCT, used in IMDCT12x3() 
 * 4 input guard bits will ensure no overflow
 */
static __inline void imdct12 (int *x, int *out)
{
 8013d78:	b580      	push	{r7, lr}
 8013d7a:	b08c      	sub	sp, #48	; 0x30
 8013d7c:	af00      	add	r7, sp, #0
 8013d7e:	6078      	str	r0, [r7, #4]
 8013d80:	6039      	str	r1, [r7, #0]
	int a0, a1, a2;
	int x0, x1, x2, x3, x4, x5;

	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8013d82:	687b      	ldr	r3, [r7, #4]
 8013d84:	681b      	ldr	r3, [r3, #0]
 8013d86:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013d88:	687b      	ldr	r3, [r7, #4]
 8013d8a:	f103 030c 	add.w	r3, r3, #12
 8013d8e:	607b      	str	r3, [r7, #4]
 8013d90:	687b      	ldr	r3, [r7, #4]
 8013d92:	681b      	ldr	r3, [r3, #0]
 8013d94:	62bb      	str	r3, [r7, #40]	; 0x28
 8013d96:	687b      	ldr	r3, [r7, #4]
 8013d98:	f103 030c 	add.w	r3, r3, #12
 8013d9c:	607b      	str	r3, [r7, #4]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8013d9e:	687b      	ldr	r3, [r7, #4]
 8013da0:	681b      	ldr	r3, [r3, #0]
 8013da2:	627b      	str	r3, [r7, #36]	; 0x24
 8013da4:	687b      	ldr	r3, [r7, #4]
 8013da6:	f103 030c 	add.w	r3, r3, #12
 8013daa:	607b      	str	r3, [r7, #4]
 8013dac:	687b      	ldr	r3, [r7, #4]
 8013dae:	681b      	ldr	r3, [r3, #0]
 8013db0:	623b      	str	r3, [r7, #32]
 8013db2:	687b      	ldr	r3, [r7, #4]
 8013db4:	f103 030c 	add.w	r3, r3, #12
 8013db8:	607b      	str	r3, [r7, #4]
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8013dba:	687b      	ldr	r3, [r7, #4]
 8013dbc:	681b      	ldr	r3, [r3, #0]
 8013dbe:	61fb      	str	r3, [r7, #28]
 8013dc0:	687b      	ldr	r3, [r7, #4]
 8013dc2:	f103 030c 	add.w	r3, r3, #12
 8013dc6:	607b      	str	r3, [r7, #4]
 8013dc8:	687b      	ldr	r3, [r7, #4]
 8013dca:	681b      	ldr	r3, [r3, #0]
 8013dcc:	61bb      	str	r3, [r7, #24]
 8013dce:	687b      	ldr	r3, [r7, #4]
 8013dd0:	f103 030c 	add.w	r3, r3, #12
 8013dd4:	607b      	str	r3, [r7, #4]

	x4 -= x5;
 8013dd6:	69fa      	ldr	r2, [r7, #28]
 8013dd8:	69bb      	ldr	r3, [r7, #24]
 8013dda:	1ad3      	subs	r3, r2, r3
 8013ddc:	61fb      	str	r3, [r7, #28]
	x3 -= x4;
 8013dde:	6a3a      	ldr	r2, [r7, #32]
 8013de0:	69fb      	ldr	r3, [r7, #28]
 8013de2:	1ad3      	subs	r3, r2, r3
 8013de4:	623b      	str	r3, [r7, #32]
	x2 -= x3;
 8013de6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013de8:	6a3b      	ldr	r3, [r7, #32]
 8013dea:	1ad3      	subs	r3, r2, r3
 8013dec:	627b      	str	r3, [r7, #36]	; 0x24
	x3 -= x5;
 8013dee:	6a3a      	ldr	r2, [r7, #32]
 8013df0:	69bb      	ldr	r3, [r7, #24]
 8013df2:	1ad3      	subs	r3, r2, r3
 8013df4:	623b      	str	r3, [r7, #32]
	x1 -= x2;
 8013df6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013df8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013dfa:	1ad3      	subs	r3, r2, r3
 8013dfc:	62bb      	str	r3, [r7, #40]	; 0x28
	x0 -= x1;
 8013dfe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013e00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013e02:	1ad3      	subs	r3, r2, r3
 8013e04:	62fb      	str	r3, [r7, #44]	; 0x2c
	x1 -= x3;
 8013e06:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013e08:	6a3b      	ldr	r3, [r7, #32]
 8013e0a:	1ad3      	subs	r3, r2, r3
 8013e0c:	62bb      	str	r3, [r7, #40]	; 0x28

	x0 >>= 1;
 8013e0e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013e10:	ea4f 0363 	mov.w	r3, r3, asr #1
 8013e14:	62fb      	str	r3, [r7, #44]	; 0x2c
	x1 >>= 1;
 8013e16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013e18:	ea4f 0363 	mov.w	r3, r3, asr #1
 8013e1c:	62bb      	str	r3, [r7, #40]	; 0x28

	a0 = MULSHIFT32(c3_0, x2) << 1;
 8013e1e:	f24e 3304 	movw	r3, #58116	; 0xe304
 8013e22:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013e26:	681b      	ldr	r3, [r3, #0]
 8013e28:	4618      	mov	r0, r3
 8013e2a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8013e2c:	f7fe fde0 	bl	80129f0 <MULSHIFT32>
 8013e30:	4603      	mov	r3, r0
 8013e32:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8013e36:	617b      	str	r3, [r7, #20]
	a1 = x0 + (x4 >> 1);
 8013e38:	69fb      	ldr	r3, [r7, #28]
 8013e3a:	ea4f 0263 	mov.w	r2, r3, asr #1
 8013e3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013e40:	18d3      	adds	r3, r2, r3
 8013e42:	613b      	str	r3, [r7, #16]
	a2 = x0 - x4;
 8013e44:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013e46:	69fb      	ldr	r3, [r7, #28]
 8013e48:	1ad3      	subs	r3, r2, r3
 8013e4a:	60fb      	str	r3, [r7, #12]
	x0 = a1 + a0;
 8013e4c:	693a      	ldr	r2, [r7, #16]
 8013e4e:	697b      	ldr	r3, [r7, #20]
 8013e50:	18d3      	adds	r3, r2, r3
 8013e52:	62fb      	str	r3, [r7, #44]	; 0x2c
	x2 = a2;
 8013e54:	68fb      	ldr	r3, [r7, #12]
 8013e56:	627b      	str	r3, [r7, #36]	; 0x24
	x4 = a1 - a0;
 8013e58:	693a      	ldr	r2, [r7, #16]
 8013e5a:	697b      	ldr	r3, [r7, #20]
 8013e5c:	1ad3      	subs	r3, r2, r3
 8013e5e:	61fb      	str	r3, [r7, #28]

	a0 = MULSHIFT32(c3_0, x3) << 1;
 8013e60:	f24e 3304 	movw	r3, #58116	; 0xe304
 8013e64:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013e68:	681b      	ldr	r3, [r3, #0]
 8013e6a:	4618      	mov	r0, r3
 8013e6c:	6a39      	ldr	r1, [r7, #32]
 8013e6e:	f7fe fdbf 	bl	80129f0 <MULSHIFT32>
 8013e72:	4603      	mov	r3, r0
 8013e74:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8013e78:	617b      	str	r3, [r7, #20]
	a1 = x1 + (x5 >> 1);
 8013e7a:	69bb      	ldr	r3, [r7, #24]
 8013e7c:	ea4f 0263 	mov.w	r2, r3, asr #1
 8013e80:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013e82:	18d3      	adds	r3, r2, r3
 8013e84:	613b      	str	r3, [r7, #16]
	a2 = x1 - x5;
 8013e86:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013e88:	69bb      	ldr	r3, [r7, #24]
 8013e8a:	1ad3      	subs	r3, r2, r3
 8013e8c:	60fb      	str	r3, [r7, #12]

	/* cos window odd samples, mul by 2, eat sign bit */
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8013e8e:	f24e 3308 	movw	r3, #58120	; 0xe308
 8013e92:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013e96:	681a      	ldr	r2, [r3, #0]
 8013e98:	6939      	ldr	r1, [r7, #16]
 8013e9a:	697b      	ldr	r3, [r7, #20]
 8013e9c:	18cb      	adds	r3, r1, r3
 8013e9e:	4610      	mov	r0, r2
 8013ea0:	4619      	mov	r1, r3
 8013ea2:	f7fe fda5 	bl	80129f0 <MULSHIFT32>
 8013ea6:	4603      	mov	r3, r0
 8013ea8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013eac:	62bb      	str	r3, [r7, #40]	; 0x28
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8013eae:	f24e 3308 	movw	r3, #58120	; 0xe308
 8013eb2:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013eb6:	685b      	ldr	r3, [r3, #4]
 8013eb8:	4618      	mov	r0, r3
 8013eba:	68f9      	ldr	r1, [r7, #12]
 8013ebc:	f7fe fd98 	bl	80129f0 <MULSHIFT32>
 8013ec0:	4603      	mov	r3, r0
 8013ec2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013ec6:	623b      	str	r3, [r7, #32]
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8013ec8:	f24e 3308 	movw	r3, #58120	; 0xe308
 8013ecc:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013ed0:	689a      	ldr	r2, [r3, #8]
 8013ed2:	6939      	ldr	r1, [r7, #16]
 8013ed4:	697b      	ldr	r3, [r7, #20]
 8013ed6:	1acb      	subs	r3, r1, r3
 8013ed8:	4610      	mov	r0, r2
 8013eda:	4619      	mov	r1, r3
 8013edc:	f7fe fd88 	bl	80129f0 <MULSHIFT32>
 8013ee0:	4603      	mov	r3, r0
 8013ee2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013ee6:	61bb      	str	r3, [r7, #24]

	*out = x0 + x1;	out++;
 8013ee8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013eea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013eec:	18d2      	adds	r2, r2, r3
 8013eee:	683b      	ldr	r3, [r7, #0]
 8013ef0:	601a      	str	r2, [r3, #0]
 8013ef2:	683b      	ldr	r3, [r7, #0]
 8013ef4:	f103 0304 	add.w	r3, r3, #4
 8013ef8:	603b      	str	r3, [r7, #0]
	*out = x2 + x3;	out++;
 8013efa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013efc:	6a3b      	ldr	r3, [r7, #32]
 8013efe:	18d2      	adds	r2, r2, r3
 8013f00:	683b      	ldr	r3, [r7, #0]
 8013f02:	601a      	str	r2, [r3, #0]
 8013f04:	683b      	ldr	r3, [r7, #0]
 8013f06:	f103 0304 	add.w	r3, r3, #4
 8013f0a:	603b      	str	r3, [r7, #0]
	*out = x4 + x5;	out++;
 8013f0c:	69fa      	ldr	r2, [r7, #28]
 8013f0e:	69bb      	ldr	r3, [r7, #24]
 8013f10:	18d2      	adds	r2, r2, r3
 8013f12:	683b      	ldr	r3, [r7, #0]
 8013f14:	601a      	str	r2, [r3, #0]
 8013f16:	683b      	ldr	r3, [r7, #0]
 8013f18:	f103 0304 	add.w	r3, r3, #4
 8013f1c:	603b      	str	r3, [r7, #0]
	*out = x4 - x5;	out++;
 8013f1e:	69fa      	ldr	r2, [r7, #28]
 8013f20:	69bb      	ldr	r3, [r7, #24]
 8013f22:	1ad2      	subs	r2, r2, r3
 8013f24:	683b      	ldr	r3, [r7, #0]
 8013f26:	601a      	str	r2, [r3, #0]
 8013f28:	683b      	ldr	r3, [r7, #0]
 8013f2a:	f103 0304 	add.w	r3, r3, #4
 8013f2e:	603b      	str	r3, [r7, #0]
	*out = x2 - x3;	out++;
 8013f30:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013f32:	6a3b      	ldr	r3, [r7, #32]
 8013f34:	1ad2      	subs	r2, r2, r3
 8013f36:	683b      	ldr	r3, [r7, #0]
 8013f38:	601a      	str	r2, [r3, #0]
 8013f3a:	683b      	ldr	r3, [r7, #0]
 8013f3c:	f103 0304 	add.w	r3, r3, #4
 8013f40:	603b      	str	r3, [r7, #0]
	*out = x0 - x1;
 8013f42:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013f44:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013f46:	1ad2      	subs	r2, r2, r3
 8013f48:	683b      	ldr	r3, [r7, #0]
 8013f4a:	601a      	str	r2, [r3, #0]
}
 8013f4c:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8013f50:	46bd      	mov	sp, r7
 8013f52:	bd80      	pop	{r7, pc}

08013f54 <IMDCT12x3>:
 * Return:      mOut (OR of abs(y) for all y calculated here)
 *
 * TODO:        optimize for ARM
 **************************************************************************************/
static int IMDCT12x3(int *xCurr, int *xPrev, int *y, int btPrev, int blockIdx, int gb)
{
 8013f54:	b5b0      	push	{r4, r5, r7, lr}
 8013f56:	b0ae      	sub	sp, #184	; 0xb8
 8013f58:	af00      	add	r7, sp, #0
 8013f5a:	60f8      	str	r0, [r7, #12]
 8013f5c:	60b9      	str	r1, [r7, #8]
 8013f5e:	607a      	str	r2, [r7, #4]
 8013f60:	603b      	str	r3, [r7, #0]
	int i, es, mOut, yLo, xBuf[18], xPrevWin[18];	/* need temp buffer for reordering short blocks */
	const int *wp;

	es = 0;
 8013f62:	f04f 0300 	mov.w	r3, #0
 8013f66:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
	/* 7 gb is always adequate for accumulator loop + idct12 + window + overlap */
	if (gb < 7) {
 8013f6a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8013f6e:	2b06      	cmp	r3, #6
 8013f70:	dc4b      	bgt.n	801400a <IMDCT12x3+0xb6>
		es = 7 - gb;
 8013f72:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8013f76:	f1c3 0307 	rsb	r3, r3, #7
 8013f7a:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
		for (i = 0; i < 18; i+=2) {
 8013f7e:	f04f 0300 	mov.w	r3, #0
 8013f82:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8013f86:	e038      	b.n	8013ffa <IMDCT12x3+0xa6>
			xCurr[i+0] >>= es;
 8013f88:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8013f8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013f90:	68fa      	ldr	r2, [r7, #12]
 8013f92:	18d3      	adds	r3, r2, r3
 8013f94:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8013f98:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8013f9c:	68f9      	ldr	r1, [r7, #12]
 8013f9e:	188a      	adds	r2, r1, r2
 8013fa0:	6811      	ldr	r1, [r2, #0]
 8013fa2:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8013fa6:	fa41 f202 	asr.w	r2, r1, r2
 8013faa:	601a      	str	r2, [r3, #0]
			xCurr[i+1] >>= es;
 8013fac:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8013fb0:	f103 0301 	add.w	r3, r3, #1
 8013fb4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8013fb8:	68fa      	ldr	r2, [r7, #12]
 8013fba:	18d3      	adds	r3, r2, r3
 8013fbc:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8013fc0:	f102 0201 	add.w	r2, r2, #1
 8013fc4:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8013fc8:	68f9      	ldr	r1, [r7, #12]
 8013fca:	188a      	adds	r2, r1, r2
 8013fcc:	6811      	ldr	r1, [r2, #0]
 8013fce:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8013fd2:	fa41 f202 	asr.w	r2, r1, r2
 8013fd6:	601a      	str	r2, [r3, #0]
			*xPrev++ >>= es;
 8013fd8:	68bb      	ldr	r3, [r7, #8]
 8013fda:	6819      	ldr	r1, [r3, #0]
 8013fdc:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8013fe0:	fa41 f202 	asr.w	r2, r1, r2
 8013fe4:	601a      	str	r2, [r3, #0]
 8013fe6:	68bb      	ldr	r3, [r7, #8]
 8013fe8:	f103 0304 	add.w	r3, r3, #4
 8013fec:	60bb      	str	r3, [r7, #8]

	es = 0;
	/* 7 gb is always adequate for accumulator loop + idct12 + window + overlap */
	if (gb < 7) {
		es = 7 - gb;
		for (i = 0; i < 18; i+=2) {
 8013fee:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8013ff2:	f103 0302 	add.w	r3, r3, #2
 8013ff6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8013ffa:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8013ffe:	2b11      	cmp	r3, #17
 8014000:	ddc2      	ble.n	8013f88 <IMDCT12x3+0x34>
			xCurr[i+0] >>= es;
			xCurr[i+1] >>= es;
			*xPrev++ >>= es;
		}
		xPrev -= 9;
 8014002:	68bb      	ldr	r3, [r7, #8]
 8014004:	f1a3 0324 	sub.w	r3, r3, #36	; 0x24
 8014008:	60bb      	str	r3, [r7, #8]
	}

	/* requires 4 input guard bits for each imdct12 */
	imdct12(xCurr + 0, xBuf + 0);
 801400a:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801400e:	68f8      	ldr	r0, [r7, #12]
 8014010:	4619      	mov	r1, r3
 8014012:	f7ff feb1 	bl	8013d78 <imdct12>
	imdct12(xCurr + 1, xBuf + 6);
 8014016:	68fb      	ldr	r3, [r7, #12]
 8014018:	f103 0204 	add.w	r2, r3, #4
 801401c:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8014020:	f103 0318 	add.w	r3, r3, #24
 8014024:	4610      	mov	r0, r2
 8014026:	4619      	mov	r1, r3
 8014028:	f7ff fea6 	bl	8013d78 <imdct12>
	imdct12(xCurr + 2, xBuf + 12);
 801402c:	68fb      	ldr	r3, [r7, #12]
 801402e:	f103 0208 	add.w	r2, r3, #8
 8014032:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8014036:	f103 0330 	add.w	r3, r3, #48	; 0x30
 801403a:	4610      	mov	r0, r2
 801403c:	4619      	mov	r1, r3
 801403e:	f7ff fe9b 	bl	8013d78 <imdct12>

	/* window previous from last time */
	WinPrevious(xPrev, xPrevWin, btPrev);
 8014042:	f107 0314 	add.w	r3, r7, #20
 8014046:	68b8      	ldr	r0, [r7, #8]
 8014048:	4619      	mov	r1, r3
 801404a:	683a      	ldr	r2, [r7, #0]
 801404c:	f7fe fede 	bl	8012e0c <WinPrevious>

	/* could unroll this for speed, minimum loads (short blocks usually rare, so doesn't make much overall difference) 
	 * xPrevWin[i] << 2 still has 1 gb always, max gain of windowed xBuf stuff also < 1.0 and gain the sign bit
	 * so y calculations won't overflow
	 */
	wp = imdctWin[2];
 8014050:	4bd5      	ldr	r3, [pc, #852]	; (80143a8 <IMDCT12x3+0x454>)
 8014052:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
	mOut = 0;
 8014056:	f04f 0300 	mov.w	r3, #0
 801405a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	for (i = 0; i < 3; i++) {
 801405e:	f04f 0300 	mov.w	r3, #0
 8014062:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8014066:	e175      	b.n	8014354 <IMDCT12x3+0x400>
		yLo = (xPrevWin[ 0+i] << 2);
 8014068:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801406c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014070:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8014074:	18cb      	adds	r3, r1, r3
 8014076:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 801407a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801407e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 8014082:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8014086:	f7fe fcc5 	bl	8012a14 <FASTABS>
 801408a:	4603      	mov	r3, r0
 801408c:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8014090:	4313      	orrs	r3, r2
 8014092:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8014096:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801409a:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 801409e:	687a      	ldr	r2, [r7, #4]
 80140a0:	18d3      	adds	r3, r2, r3
 80140a2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80140a6:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[ 3+i] << 2);
 80140a8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80140ac:	f103 0303 	add.w	r3, r3, #3
 80140b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80140b4:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80140b8:	18d3      	adds	r3, r2, r3
 80140ba:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 80140be:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80140c2:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 80140c6:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 80140ca:	f7fe fca3 	bl	8012a14 <FASTABS>
 80140ce:	4603      	mov	r3, r0
 80140d0:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 80140d4:	4313      	orrs	r3, r2
 80140d6:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 80140da:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80140de:	f103 0303 	add.w	r3, r3, #3
 80140e2:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 80140e6:	687a      	ldr	r2, [r7, #4]
 80140e8:	18d3      	adds	r3, r2, r3
 80140ea:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80140ee:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 80140f0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80140f4:	f103 0306 	add.w	r3, r3, #6
 80140f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80140fc:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8014100:	18cb      	adds	r3, r1, r3
 8014102:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 8014106:	ea4f 0483 	mov.w	r4, r3, lsl #2
 801410a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801410e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014112:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8014116:	18d3      	adds	r3, r2, r3
 8014118:	681a      	ldr	r2, [r3, #0]
 801411a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801411e:	f103 0303 	add.w	r3, r3, #3
 8014122:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014126:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 801412a:	18cb      	adds	r3, r1, r3
 801412c:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 8014130:	4610      	mov	r0, r2
 8014132:	4619      	mov	r1, r3
 8014134:	f7fe fc5c 	bl	80129f0 <MULSHIFT32>
 8014138:	4603      	mov	r3, r0
 801413a:	18e3      	adds	r3, r4, r3
 801413c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 8014140:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8014144:	f7fe fc66 	bl	8012a14 <FASTABS>
 8014148:	4603      	mov	r3, r0
 801414a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 801414e:	4313      	orrs	r3, r2
 8014150:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8014154:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014158:	f103 0306 	add.w	r3, r3, #6
 801415c:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8014160:	687a      	ldr	r2, [r7, #4]
 8014162:	18d3      	adds	r3, r2, r3
 8014164:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8014168:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 801416a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801416e:	f103 0309 	add.w	r3, r3, #9
 8014172:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014176:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 801417a:	18d3      	adds	r3, r2, r3
 801417c:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 8014180:	ea4f 0483 	mov.w	r4, r3, lsl #2
 8014184:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014188:	f103 0303 	add.w	r3, r3, #3
 801418c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014190:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8014194:	18d3      	adds	r3, r2, r3
 8014196:	681a      	ldr	r2, [r3, #0]
 8014198:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801419c:	f1c3 0305 	rsb	r3, r3, #5
 80141a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80141a4:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80141a8:	18cb      	adds	r3, r1, r3
 80141aa:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 80141ae:	4610      	mov	r0, r2
 80141b0:	4619      	mov	r1, r3
 80141b2:	f7fe fc1d 	bl	80129f0 <MULSHIFT32>
 80141b6:	4603      	mov	r3, r0
 80141b8:	18e3      	adds	r3, r4, r3
 80141ba:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 80141be:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 80141c2:	f7fe fc27 	bl	8012a14 <FASTABS>
 80141c6:	4603      	mov	r3, r0
 80141c8:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 80141cc:	4313      	orrs	r3, r2
 80141ce:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 80141d2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80141d6:	f103 0309 	add.w	r3, r3, #9
 80141da:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 80141de:	687a      	ldr	r2, [r7, #4]
 80141e0:	18d3      	adds	r3, r2, r3
 80141e2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80141e6:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 80141e8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80141ec:	f103 030c 	add.w	r3, r3, #12
 80141f0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80141f4:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80141f8:	18d3      	adds	r3, r2, r3
 80141fa:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 80141fe:	ea4f 0483 	mov.w	r4, r3, lsl #2
 8014202:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014206:	f103 0306 	add.w	r3, r3, #6
 801420a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801420e:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8014212:	18d3      	adds	r3, r2, r3
 8014214:	681a      	ldr	r2, [r3, #0]
 8014216:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801421a:	f1c3 0302 	rsb	r3, r3, #2
 801421e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014222:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8014226:	18cb      	adds	r3, r1, r3
 8014228:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 801422c:	4610      	mov	r0, r2
 801422e:	4619      	mov	r1, r3
 8014230:	f7fe fbde 	bl	80129f0 <MULSHIFT32>
 8014234:	4605      	mov	r5, r0
 8014236:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801423a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801423e:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8014242:	18d3      	adds	r3, r2, r3
 8014244:	681a      	ldr	r2, [r3, #0]
 8014246:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801424a:	f103 0309 	add.w	r3, r3, #9
 801424e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014252:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8014256:	18cb      	adds	r3, r1, r3
 8014258:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 801425c:	4610      	mov	r0, r2
 801425e:	4619      	mov	r1, r3
 8014260:	f7fe fbc6 	bl	80129f0 <MULSHIFT32>
 8014264:	4603      	mov	r3, r0
 8014266:	18eb      	adds	r3, r5, r3
 8014268:	18e3      	adds	r3, r4, r3
 801426a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 801426e:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8014272:	f7fe fbcf 	bl	8012a14 <FASTABS>
 8014276:	4603      	mov	r3, r0
 8014278:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 801427c:	4313      	orrs	r3, r2
 801427e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8014282:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014286:	f103 030c 	add.w	r3, r3, #12
 801428a:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 801428e:	687a      	ldr	r2, [r7, #4]
 8014290:	18d3      	adds	r3, r2, r3
 8014292:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8014296:	601a      	str	r2, [r3, #0]
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8014298:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801429c:	f103 030f 	add.w	r3, r3, #15
 80142a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80142a4:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80142a8:	18d3      	adds	r3, r2, r3
 80142aa:	f853 3ca4 	ldr.w	r3, [r3, #-164]
 80142ae:	ea4f 0483 	mov.w	r4, r3, lsl #2
 80142b2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80142b6:	f103 0309 	add.w	r3, r3, #9
 80142ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80142be:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 80142c2:	18d3      	adds	r3, r2, r3
 80142c4:	681a      	ldr	r2, [r3, #0]
 80142c6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80142ca:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80142ce:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80142d2:	18cb      	adds	r3, r1, r3
 80142d4:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 80142d8:	4610      	mov	r0, r2
 80142da:	4619      	mov	r1, r3
 80142dc:	f7fe fb88 	bl	80129f0 <MULSHIFT32>
 80142e0:	4605      	mov	r5, r0
 80142e2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80142e6:	f103 0303 	add.w	r3, r3, #3
 80142ea:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80142ee:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 80142f2:	18d3      	adds	r3, r2, r3
 80142f4:	681a      	ldr	r2, [r3, #0]
 80142f6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80142fa:	f1c3 030b 	rsb	r3, r3, #11
 80142fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014302:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8014306:	18cb      	adds	r3, r1, r3
 8014308:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 801430c:	4610      	mov	r0, r2
 801430e:	4619      	mov	r1, r3
 8014310:	f7fe fb6e 	bl	80129f0 <MULSHIFT32>
 8014314:	4603      	mov	r3, r0
 8014316:	18eb      	adds	r3, r5, r3
 8014318:	18e3      	adds	r3, r4, r3
 801431a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 801431e:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8014322:	f7fe fb77 	bl	8012a14 <FASTABS>
 8014326:	4603      	mov	r3, r0
 8014328:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 801432c:	4313      	orrs	r3, r2
 801432e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8014332:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014336:	f103 030f 	add.w	r3, r3, #15
 801433a:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 801433e:	687a      	ldr	r2, [r7, #4]
 8014340:	18d3      	adds	r3, r2, r3
 8014342:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8014346:	601a      	str	r2, [r3, #0]
	 * xPrevWin[i] << 2 still has 1 gb always, max gain of windowed xBuf stuff also < 1.0 and gain the sign bit
	 * so y calculations won't overflow
	 */
	wp = imdctWin[2];
	mOut = 0;
	for (i = 0; i < 3; i++) {
 8014348:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801434c:	f103 0301 	add.w	r3, r3, #1
 8014350:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8014354:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8014358:	2b02      	cmp	r3, #2
 801435a:	f77f ae85 	ble.w	8014068 <IMDCT12x3+0x114>
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
	}

	/* save previous (unwindowed) for overlap - only need samples 6-8, 12-17 */
	for (i = 6; i < 9; i++)
 801435e:	f04f 0306 	mov.w	r3, #6
 8014362:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8014366:	e016      	b.n	8014396 <IMDCT12x3+0x442>
		*xPrev++ = xBuf[i] >> 2;
 8014368:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801436c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014370:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 8014374:	18d3      	adds	r3, r2, r3
 8014376:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 801437a:	ea4f 02a3 	mov.w	r2, r3, asr #2
 801437e:	68bb      	ldr	r3, [r7, #8]
 8014380:	601a      	str	r2, [r3, #0]
 8014382:	68bb      	ldr	r3, [r7, #8]
 8014384:	f103 0304 	add.w	r3, r3, #4
 8014388:	60bb      	str	r3, [r7, #8]
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
	}

	/* save previous (unwindowed) for overlap - only need samples 6-8, 12-17 */
	for (i = 6; i < 9; i++)
 801438a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801438e:	f103 0301 	add.w	r3, r3, #1
 8014392:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8014396:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801439a:	2b08      	cmp	r3, #8
 801439c:	dde4      	ble.n	8014368 <IMDCT12x3+0x414>
		*xPrev++ = xBuf[i] >> 2;
	for (i = 12; i < 18; i++)
 801439e:	f04f 030c 	mov.w	r3, #12
 80143a2:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 80143a6:	e018      	b.n	80143da <IMDCT12x3+0x486>
 80143a8:	0802e49c 	.word	0x0802e49c
		*xPrev++ = xBuf[i] >> 2;
 80143ac:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80143b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80143b4:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80143b8:	18cb      	adds	r3, r1, r3
 80143ba:	f853 3c5c 	ldr.w	r3, [r3, #-92]
 80143be:	ea4f 02a3 	mov.w	r2, r3, asr #2
 80143c2:	68bb      	ldr	r3, [r7, #8]
 80143c4:	601a      	str	r2, [r3, #0]
 80143c6:	68bb      	ldr	r3, [r7, #8]
 80143c8:	f103 0304 	add.w	r3, r3, #4
 80143cc:	60bb      	str	r3, [r7, #8]
	}

	/* save previous (unwindowed) for overlap - only need samples 6-8, 12-17 */
	for (i = 6; i < 9; i++)
		*xPrev++ = xBuf[i] >> 2;
	for (i = 12; i < 18; i++)
 80143ce:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80143d2:	f103 0301 	add.w	r3, r3, #1
 80143d6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 80143da:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80143de:	2b11      	cmp	r3, #17
 80143e0:	dde4      	ble.n	80143ac <IMDCT12x3+0x458>
		*xPrev++ = xBuf[i] >> 2;

	xPrev -= 9;
 80143e2:	68bb      	ldr	r3, [r7, #8]
 80143e4:	f1a3 0324 	sub.w	r3, r3, #36	; 0x24
 80143e8:	60bb      	str	r3, [r7, #8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 80143ea:	6878      	ldr	r0, [r7, #4]
 80143ec:	68b9      	ldr	r1, [r7, #8]
 80143ee:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 80143f2:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80143f6:	f7fe feaf 	bl	8013158 <FreqInvertRescale>
 80143fa:	4603      	mov	r3, r0
 80143fc:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8014400:	4313      	orrs	r3, r2
 8014402:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

	return mOut;
 8014406:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
}
 801440a:	4618      	mov	r0, r3
 801440c:	f107 07b8 	add.w	r7, r7, #184	; 0xb8
 8014410:	46bd      	mov	sp, r7
 8014412:	bdb0      	pop	{r4, r5, r7, pc}

08014414 <HybridTransform>:
 *                (including overlap-add)
 *
 * TODO:        examine mixedBlock/winSwitch logic carefully (test he_mode.bit)
 **************************************************************************************/
static int HybridTransform(int *xCurr, int *xPrev, int y[BLOCK_SIZE][NBANDS], SideInfoSub *sis, BlockCount *bc)
{
 8014414:	b580      	push	{r7, lr}
 8014416:	b0a4      	sub	sp, #144	; 0x90
 8014418:	af04      	add	r7, sp, #16
 801441a:	60f8      	str	r0, [r7, #12]
 801441c:	60b9      	str	r1, [r7, #8]
 801441e:	607a      	str	r2, [r7, #4]
 8014420:	603b      	str	r3, [r7, #0]

	ASSERT(bc->nBlocksLong  <= NBANDS);
	ASSERT(bc->nBlocksTotal <= NBANDS);
	ASSERT(bc->nBlocksPrev  <= NBANDS);

	mOut = 0;
 8014422:	f04f 0300 	mov.w	r3, #0
 8014426:	667b      	str	r3, [r7, #100]	; 0x64

	/* do long blocks, if any */
	for(i = 0; i < bc->nBlocksLong; i++) {
 8014428:	f04f 0300 	mov.w	r3, #0
 801442c:	677b      	str	r3, [r7, #116]	; 0x74
 801442e:	e03f      	b.n	80144b0 <HybridTransform+0x9c>
		/* currWinIdx picks the right window for long blocks (if mixed, long blocks use window type 0) */
		currWinIdx = sis->blockType;
 8014430:	683b      	ldr	r3, [r7, #0]
 8014432:	695b      	ldr	r3, [r3, #20]
 8014434:	67fb      	str	r3, [r7, #124]	; 0x7c
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 8014436:	683b      	ldr	r3, [r7, #0]
 8014438:	699b      	ldr	r3, [r3, #24]
 801443a:	2b00      	cmp	r3, #0
 801443c:	d008      	beq.n	8014450 <HybridTransform+0x3c>
 801443e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8014442:	695a      	ldr	r2, [r3, #20]
 8014444:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014446:	429a      	cmp	r2, r3
 8014448:	dd02      	ble.n	8014450 <HybridTransform+0x3c>
			currWinIdx = 0;
 801444a:	f04f 0300 	mov.w	r3, #0
 801444e:	67fb      	str	r3, [r7, #124]	; 0x7c

		prevWinIdx = bc->prevType;
 8014450:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8014454:	68db      	ldr	r3, [r3, #12]
 8014456:	67bb      	str	r3, [r7, #120]	; 0x78
		if (i < bc->prevWinSwitch)
 8014458:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801445c:	691a      	ldr	r2, [r3, #16]
 801445e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014460:	429a      	cmp	r2, r3
 8014462:	dd02      	ble.n	801446a <HybridTransform+0x56>
			 prevWinIdx = 0;
 8014464:	f04f 0300 	mov.w	r3, #0
 8014468:	67bb      	str	r3, [r7, #120]	; 0x78

		/* do 36-point IMDCT, including windowing and overlap-add */
		mOut |= IMDCT36(xCurr, xPrev, &(y[0][i]), currWinIdx, prevWinIdx, i, bc->gbIn);
 801446a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801446c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014470:	687a      	ldr	r2, [r7, #4]
 8014472:	18d3      	adds	r3, r2, r3
 8014474:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8014478:	6992      	ldr	r2, [r2, #24]
 801447a:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 801447c:	9100      	str	r1, [sp, #0]
 801447e:	6f79      	ldr	r1, [r7, #116]	; 0x74
 8014480:	9101      	str	r1, [sp, #4]
 8014482:	9202      	str	r2, [sp, #8]
 8014484:	68f8      	ldr	r0, [r7, #12]
 8014486:	68b9      	ldr	r1, [r7, #8]
 8014488:	461a      	mov	r2, r3
 801448a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801448c:	f7ff f9f0 	bl	8013870 <IMDCT36>
 8014490:	4603      	mov	r3, r0
 8014492:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8014494:	4313      	orrs	r3, r2
 8014496:	667b      	str	r3, [r7, #100]	; 0x64
		xCurr += 18;
 8014498:	68fb      	ldr	r3, [r7, #12]
 801449a:	f103 0348 	add.w	r3, r3, #72	; 0x48
 801449e:	60fb      	str	r3, [r7, #12]
		xPrev += 9;
 80144a0:	68bb      	ldr	r3, [r7, #8]
 80144a2:	f103 0324 	add.w	r3, r3, #36	; 0x24
 80144a6:	60bb      	str	r3, [r7, #8]
	ASSERT(bc->nBlocksPrev  <= NBANDS);

	mOut = 0;

	/* do long blocks, if any */
	for(i = 0; i < bc->nBlocksLong; i++) {
 80144a8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80144aa:	f103 0301 	add.w	r3, r3, #1
 80144ae:	677b      	str	r3, [r7, #116]	; 0x74
 80144b0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80144b4:	681a      	ldr	r2, [r3, #0]
 80144b6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80144b8:	429a      	cmp	r2, r3
 80144ba:	dcb9      	bgt.n	8014430 <HybridTransform+0x1c>
		xCurr += 18;
		xPrev += 9;
	}

	/* do short blocks (if any) */
	for (   ; i < bc->nBlocksTotal; i++) {
 80144bc:	e02d      	b.n	801451a <HybridTransform+0x106>
		ASSERT(sis->blockType == 2);

		prevWinIdx = bc->prevType;
 80144be:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80144c2:	68db      	ldr	r3, [r3, #12]
 80144c4:	67bb      	str	r3, [r7, #120]	; 0x78
		if (i < bc->prevWinSwitch)
 80144c6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80144ca:	691a      	ldr	r2, [r3, #16]
 80144cc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80144ce:	429a      	cmp	r2, r3
 80144d0:	dd02      	ble.n	80144d8 <HybridTransform+0xc4>
			 prevWinIdx = 0;
 80144d2:	f04f 0300 	mov.w	r3, #0
 80144d6:	67bb      	str	r3, [r7, #120]	; 0x78
		
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 80144d8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80144da:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80144de:	687a      	ldr	r2, [r7, #4]
 80144e0:	18d3      	adds	r3, r2, r3
 80144e2:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 80144e6:	6992      	ldr	r2, [r2, #24]
 80144e8:	6f79      	ldr	r1, [r7, #116]	; 0x74
 80144ea:	9100      	str	r1, [sp, #0]
 80144ec:	9201      	str	r2, [sp, #4]
 80144ee:	68f8      	ldr	r0, [r7, #12]
 80144f0:	68b9      	ldr	r1, [r7, #8]
 80144f2:	461a      	mov	r2, r3
 80144f4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80144f6:	f7ff fd2d 	bl	8013f54 <IMDCT12x3>
 80144fa:	4603      	mov	r3, r0
 80144fc:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80144fe:	4313      	orrs	r3, r2
 8014500:	667b      	str	r3, [r7, #100]	; 0x64
		xCurr += 18;
 8014502:	68fb      	ldr	r3, [r7, #12]
 8014504:	f103 0348 	add.w	r3, r3, #72	; 0x48
 8014508:	60fb      	str	r3, [r7, #12]
		xPrev += 9;
 801450a:	68bb      	ldr	r3, [r7, #8]
 801450c:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8014510:	60bb      	str	r3, [r7, #8]
		xCurr += 18;
		xPrev += 9;
	}

	/* do short blocks (if any) */
	for (   ; i < bc->nBlocksTotal; i++) {
 8014512:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014514:	f103 0301 	add.w	r3, r3, #1
 8014518:	677b      	str	r3, [r7, #116]	; 0x74
 801451a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801451e:	685a      	ldr	r2, [r3, #4]
 8014520:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014522:	429a      	cmp	r2, r3
 8014524:	dccb      	bgt.n	80144be <HybridTransform+0xaa>
		
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
		xCurr += 18;
		xPrev += 9;
	}
	nBlocksOut = i;
 8014526:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014528:	66fb      	str	r3, [r7, #108]	; 0x6c
	
	/* window and overlap prev if prev longer that current */
	for (   ; i < bc->nBlocksPrev; i++) {
 801452a:	e08a      	b.n	8014642 <HybridTransform+0x22e>
		prevWinIdx = bc->prevType;
 801452c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8014530:	68db      	ldr	r3, [r3, #12]
 8014532:	67bb      	str	r3, [r7, #120]	; 0x78
		if (i < bc->prevWinSwitch)
 8014534:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8014538:	691a      	ldr	r2, [r3, #16]
 801453a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801453c:	429a      	cmp	r2, r3
 801453e:	dd02      	ble.n	8014546 <HybridTransform+0x132>
			 prevWinIdx = 0;
 8014540:	f04f 0300 	mov.w	r3, #0
 8014544:	67bb      	str	r3, [r7, #120]	; 0x78
		WinPrevious(xPrev, xPrevWin, prevWinIdx);
 8014546:	f107 0314 	add.w	r3, r7, #20
 801454a:	68b8      	ldr	r0, [r7, #8]
 801454c:	4619      	mov	r1, r3
 801454e:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8014550:	f7fe fc5c 	bl	8012e0c <WinPrevious>

		nonZero = 0;
 8014554:	f04f 0300 	mov.w	r3, #0
 8014558:	66bb      	str	r3, [r7, #104]	; 0x68
		fiBit = i << 31;
 801455a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801455c:	ea4f 73c3 	mov.w	r3, r3, lsl #31
 8014560:	663b      	str	r3, [r7, #96]	; 0x60
		for (j = 0; j < 9; j++) {
 8014562:	f04f 0300 	mov.w	r3, #0
 8014566:	673b      	str	r3, [r7, #112]	; 0x70
 8014568:	e05b      	b.n	8014622 <HybridTransform+0x20e>
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 801456a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801456c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8014570:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014574:	f107 0280 	add.w	r2, r7, #128	; 0x80
 8014578:	18d3      	adds	r3, r2, r3
 801457a:	f853 3c6c 	ldr.w	r3, [r3, #-108]
 801457e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014582:	65fb      	str	r3, [r7, #92]	; 0x5c
			nonZero |= xp;
 8014584:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8014586:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8014588:	4313      	orrs	r3, r2
 801458a:	66bb      	str	r3, [r7, #104]	; 0x68
			y[2*j+0][i] = xp;
 801458c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801458e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8014592:	687a      	ldr	r2, [r7, #4]
 8014594:	18d3      	adds	r3, r2, r3
 8014596:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8014598:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 801459a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			mOut |= FASTABS(xp);
 801459e:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 80145a0:	f7fe fa38 	bl	8012a14 <FASTABS>
 80145a4:	4603      	mov	r3, r0
 80145a6:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80145a8:	4313      	orrs	r3, r2
 80145aa:	667b      	str	r3, [r7, #100]	; 0x64

			/* frequency inversion on odd blocks/odd samples (flip sign if i odd, j odd) */
			xp = xPrevWin[2*j+1] << 2;
 80145ac:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80145ae:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80145b2:	f103 0301 	add.w	r3, r3, #1
 80145b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80145ba:	f107 0280 	add.w	r2, r7, #128	; 0x80
 80145be:	18d3      	adds	r3, r2, r3
 80145c0:	f853 3c6c 	ldr.w	r3, [r3, #-108]
 80145c4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80145c8:	65fb      	str	r3, [r7, #92]	; 0x5c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 80145ca:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80145cc:	ea4f 72e3 	mov.w	r2, r3, asr #31
 80145d0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80145d2:	405a      	eors	r2, r3
 80145d4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80145d6:	f003 0301 	and.w	r3, r3, #1
 80145da:	18d3      	adds	r3, r2, r3
 80145dc:	65fb      	str	r3, [r7, #92]	; 0x5c
			nonZero |= xp;
 80145de:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80145e0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80145e2:	4313      	orrs	r3, r2
 80145e4:	66bb      	str	r3, [r7, #104]	; 0x68
			y[2*j+1][i] = xp;
 80145e6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80145e8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80145ec:	f103 0380 	add.w	r3, r3, #128	; 0x80
 80145f0:	687a      	ldr	r2, [r7, #4]
 80145f2:	18d3      	adds	r3, r2, r3
 80145f4:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80145f6:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 80145f8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			mOut |= FASTABS(xp);
 80145fc:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 80145fe:	f7fe fa09 	bl	8012a14 <FASTABS>
 8014602:	4603      	mov	r3, r0
 8014604:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8014606:	4313      	orrs	r3, r2
 8014608:	667b      	str	r3, [r7, #100]	; 0x64

			xPrev[j] = 0;
 801460a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801460c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014610:	68ba      	ldr	r2, [r7, #8]
 8014612:	18d3      	adds	r3, r2, r3
 8014614:	f04f 0200 	mov.w	r2, #0
 8014618:	601a      	str	r2, [r3, #0]
			 prevWinIdx = 0;
		WinPrevious(xPrev, xPrevWin, prevWinIdx);

		nonZero = 0;
		fiBit = i << 31;
		for (j = 0; j < 9; j++) {
 801461a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801461c:	f103 0301 	add.w	r3, r3, #1
 8014620:	673b      	str	r3, [r7, #112]	; 0x70
 8014622:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8014624:	2b08      	cmp	r3, #8
 8014626:	dda0      	ble.n	801456a <HybridTransform+0x156>
			y[2*j+1][i] = xp;
			mOut |= FASTABS(xp);

			xPrev[j] = 0;
		}
		xPrev += 9;
 8014628:	68bb      	ldr	r3, [r7, #8]
 801462a:	f103 0324 	add.w	r3, r3, #36	; 0x24
 801462e:	60bb      	str	r3, [r7, #8]
		if (nonZero)
 8014630:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8014632:	2b00      	cmp	r3, #0
 8014634:	d001      	beq.n	801463a <HybridTransform+0x226>
			nBlocksOut = i;
 8014636:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014638:	66fb      	str	r3, [r7, #108]	; 0x6c
		xPrev += 9;
	}
	nBlocksOut = i;
	
	/* window and overlap prev if prev longer that current */
	for (   ; i < bc->nBlocksPrev; i++) {
 801463a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801463c:	f103 0301 	add.w	r3, r3, #1
 8014640:	677b      	str	r3, [r7, #116]	; 0x74
 8014642:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8014646:	689a      	ldr	r2, [r3, #8]
 8014648:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801464a:	429a      	cmp	r2, r3
 801464c:	f73f af6e 	bgt.w	801452c <HybridTransform+0x118>
		if (nonZero)
			nBlocksOut = i;
	}
	
	/* clear rest of blocks */
	for (   ; i < 32; i++) {
 8014650:	e018      	b.n	8014684 <HybridTransform+0x270>
		for (j = 0; j < 18; j++) 
 8014652:	f04f 0300 	mov.w	r3, #0
 8014656:	673b      	str	r3, [r7, #112]	; 0x70
 8014658:	e00d      	b.n	8014676 <HybridTransform+0x262>
			y[j][i] = 0;
 801465a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801465c:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8014660:	687a      	ldr	r2, [r7, #4]
 8014662:	18d3      	adds	r3, r2, r3
 8014664:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8014666:	f04f 0100 	mov.w	r1, #0
 801466a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			nBlocksOut = i;
	}
	
	/* clear rest of blocks */
	for (   ; i < 32; i++) {
		for (j = 0; j < 18; j++) 
 801466e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8014670:	f103 0301 	add.w	r3, r3, #1
 8014674:	673b      	str	r3, [r7, #112]	; 0x70
 8014676:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8014678:	2b11      	cmp	r3, #17
 801467a:	ddee      	ble.n	801465a <HybridTransform+0x246>
		if (nonZero)
			nBlocksOut = i;
	}
	
	/* clear rest of blocks */
	for (   ; i < 32; i++) {
 801467c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801467e:	f103 0301 	add.w	r3, r3, #1
 8014682:	677b      	str	r3, [r7, #116]	; 0x74
 8014684:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014686:	2b1f      	cmp	r3, #31
 8014688:	dde3      	ble.n	8014652 <HybridTransform+0x23e>
		for (j = 0; j < 18; j++) 
			y[j][i] = 0;
	}

	bc->gbOut = CLZ(mOut) - 1;
 801468a:	6e78      	ldr	r0, [r7, #100]	; 0x64
 801468c:	f7fe f9da 	bl	8012a44 <CLZ>
 8014690:	4603      	mov	r3, r0
 8014692:	f103 32ff 	add.w	r2, r3, #4294967295
 8014696:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801469a:	61da      	str	r2, [r3, #28]

	return nBlocksOut;
 801469c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
}
 801469e:	4618      	mov	r0, r3
 80146a0:	f107 0780 	add.w	r7, r7, #128	; 0x80
 80146a4:	46bd      	mov	sp, r7
 80146a6:	bd80      	pop	{r7, pc}

080146a8 <xmp3_IMDCT>:
 *              updated hi->nonZeroBound index for this channel
 *
 * Return:      0 on success,  -1 if null input pointers
 **************************************************************************************/
int IMDCT(MP3DecInfo *mp3DecInfo, int gr, int ch)
{
 80146a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80146aa:	b095      	sub	sp, #84	; 0x54
 80146ac:	af02      	add	r7, sp, #8
 80146ae:	60f8      	str	r0, [r7, #12]
 80146b0:	60b9      	str	r1, [r7, #8]
 80146b2:	607a      	str	r2, [r7, #4]
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	BlockCount bc;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 80146b4:	68fb      	ldr	r3, [r7, #12]
 80146b6:	2b00      	cmp	r3, #0
 80146b8:	d00f      	beq.n	80146da <xmp3_IMDCT+0x32>
 80146ba:	68fb      	ldr	r3, [r7, #12]
 80146bc:	681b      	ldr	r3, [r3, #0]
 80146be:	2b00      	cmp	r3, #0
 80146c0:	d00b      	beq.n	80146da <xmp3_IMDCT+0x32>
 80146c2:	68fb      	ldr	r3, [r7, #12]
 80146c4:	685b      	ldr	r3, [r3, #4]
 80146c6:	2b00      	cmp	r3, #0
 80146c8:	d007      	beq.n	80146da <xmp3_IMDCT+0x32>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 80146ca:	68fb      	ldr	r3, [r7, #12]
 80146cc:	68db      	ldr	r3, [r3, #12]
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	BlockCount bc;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 80146ce:	2b00      	cmp	r3, #0
 80146d0:	d003      	beq.n	80146da <xmp3_IMDCT+0x32>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 80146d2:	68fb      	ldr	r3, [r7, #12]
 80146d4:	695b      	ldr	r3, [r3, #20]
 80146d6:	2b00      	cmp	r3, #0
 80146d8:	d102      	bne.n	80146e0 <xmp3_IMDCT+0x38>
		return -1;
 80146da:	f04f 33ff 	mov.w	r3, #4294967295
 80146de:	e17e      	b.n	80149de <xmp3_IMDCT+0x336>

	/* si is an array of up to 4 structs, stored as gr0ch0, gr0ch1, gr1ch0, gr1ch1 */
	fh = (FrameHeader *)(mp3DecInfo->FrameHeaderPS);
 80146e0:	68fb      	ldr	r3, [r7, #12]
 80146e2:	681b      	ldr	r3, [r3, #0]
 80146e4:	643b      	str	r3, [r7, #64]	; 0x40
	si = (SideInfo *)(mp3DecInfo->SideInfoPS);
 80146e6:	68fb      	ldr	r3, [r7, #12]
 80146e8:	685b      	ldr	r3, [r3, #4]
 80146ea:	63fb      	str	r3, [r7, #60]	; 0x3c
	hi = (HuffmanInfo*)(mp3DecInfo->HuffmanInfoPS);
 80146ec:	68fb      	ldr	r3, [r7, #12]
 80146ee:	68db      	ldr	r3, [r3, #12]
 80146f0:	63bb      	str	r3, [r7, #56]	; 0x38
	mi = (IMDCTInfo *)(mp3DecInfo->IMDCTInfoPS);
 80146f2:	68fb      	ldr	r3, [r7, #12]
 80146f4:	695b      	ldr	r3, [r3, #20]
 80146f6:	637b      	str	r3, [r7, #52]	; 0x34
	/* anti-aliasing done on whole long blocks only
	 * for mixed blocks, nBfly always 1, except 3 for 8 kHz MPEG 2.5 (see sfBandTab) 
     *   nLongBlocks = number of blocks with (possibly) non-zero power 
	 *   nBfly = number of butterflies to do (nLongBlocks - 1, unless no long blocks)
	 */
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 80146f8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80146fa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80146fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80146fe:	781b      	ldrb	r3, [r3, #0]
 8014700:	2b00      	cmp	r3, #0
 8014702:	d102      	bne.n	801470a <xmp3_IMDCT+0x62>
 8014704:	f04f 0308 	mov.w	r3, #8
 8014708:	e001      	b.n	801470e <xmp3_IMDCT+0x66>
 801470a:	f04f 0306 	mov.w	r3, #6
 801470e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8014712:	b21a      	sxth	r2, r3
 8014714:	f648 6339 	movw	r3, #36409	; 0x8e39
 8014718:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
 801471c:	fb83 1302 	smull	r1, r3, r3, r2
 8014720:	ea4f 01a3 	mov.w	r1, r3, asr #2
 8014724:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8014728:	1acb      	subs	r3, r1, r3
 801472a:	b29b      	uxth	r3, r3
 801472c:	b21b      	sxth	r3, r3
 801472e:	633b      	str	r3, [r7, #48]	; 0x30
	if (si->sis[gr][ch].blockType != 2) {
 8014730:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8014732:	687b      	ldr	r3, [r7, #4]
 8014734:	68b9      	ldr	r1, [r7, #8]
 8014736:	461a      	mov	r2, r3
 8014738:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 801473c:	18d2      	adds	r2, r2, r3
 801473e:	ea4f 03c2 	mov.w	r3, r2, lsl #3
 8014742:	461a      	mov	r2, r3
 8014744:	460b      	mov	r3, r1
 8014746:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801474a:	185b      	adds	r3, r3, r1
 801474c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8014750:	18d3      	adds	r3, r2, r3
 8014752:	18c3      	adds	r3, r0, r3
 8014754:	f103 033c 	add.w	r3, r3, #60	; 0x3c
 8014758:	681b      	ldr	r3, [r3, #0]
 801475a:	2b02      	cmp	r3, #2
 801475c:	d01d      	beq.n	801479a <xmp3_IMDCT+0xf2>
		/* all long transforms */
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 801475e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014760:	687a      	ldr	r2, [r7, #4]
 8014762:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 8014766:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801476a:	f103 0207 	add.w	r2, r3, #7
 801476e:	f648 6339 	movw	r3, #36409	; 0x8e39
 8014772:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
 8014776:	fb83 1302 	smull	r1, r3, r3, r2
 801477a:	ea4f 01a3 	mov.w	r1, r3, asr #2
 801477e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8014782:	1acb      	subs	r3, r1, r3
 8014784:	f103 0301 	add.w	r3, r3, #1
 8014788:	2b20      	cmp	r3, #32
 801478a:	bfa8      	it	ge
 801478c:	2320      	movge	r3, #32
 801478e:	613b      	str	r3, [r7, #16]
		nBfly = bc.nBlocksLong - 1;
 8014790:	693b      	ldr	r3, [r7, #16]
 8014792:	f103 33ff 	add.w	r3, r3, #4294967295
 8014796:	647b      	str	r3, [r7, #68]	; 0x44
 8014798:	e03a      	b.n	8014810 <xmp3_IMDCT+0x168>
	} else if (si->sis[gr][ch].blockType == 2 && si->sis[gr][ch].mixedBlock) {
 801479a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801479c:	687b      	ldr	r3, [r7, #4]
 801479e:	68b9      	ldr	r1, [r7, #8]
 80147a0:	461a      	mov	r2, r3
 80147a2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80147a6:	18d2      	adds	r2, r2, r3
 80147a8:	ea4f 03c2 	mov.w	r3, r2, lsl #3
 80147ac:	461a      	mov	r2, r3
 80147ae:	460b      	mov	r3, r1
 80147b0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80147b4:	185b      	adds	r3, r3, r1
 80147b6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80147ba:	18d3      	adds	r3, r2, r3
 80147bc:	18c3      	adds	r3, r0, r3
 80147be:	f103 033c 	add.w	r3, r3, #60	; 0x3c
 80147c2:	681b      	ldr	r3, [r3, #0]
 80147c4:	2b02      	cmp	r3, #2
 80147c6:	d11d      	bne.n	8014804 <xmp3_IMDCT+0x15c>
 80147c8:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80147ca:	687b      	ldr	r3, [r7, #4]
 80147cc:	68b9      	ldr	r1, [r7, #8]
 80147ce:	461a      	mov	r2, r3
 80147d0:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80147d4:	18d2      	adds	r2, r2, r3
 80147d6:	ea4f 03c2 	mov.w	r3, r2, lsl #3
 80147da:	461a      	mov	r2, r3
 80147dc:	460b      	mov	r3, r1
 80147de:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80147e2:	185b      	adds	r3, r3, r1
 80147e4:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80147e8:	18d3      	adds	r3, r2, r3
 80147ea:	18c3      	adds	r3, r0, r3
 80147ec:	f103 0340 	add.w	r3, r3, #64	; 0x40
 80147f0:	681b      	ldr	r3, [r3, #0]
 80147f2:	2b00      	cmp	r3, #0
 80147f4:	d006      	beq.n	8014804 <xmp3_IMDCT+0x15c>
		/* mixed block - long transforms until cutoff, then short transforms */
		bc.nBlocksLong = blockCutoff;	
 80147f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80147f8:	613b      	str	r3, [r7, #16]
		nBfly = bc.nBlocksLong - 1;
 80147fa:	693b      	ldr	r3, [r7, #16]
 80147fc:	f103 33ff 	add.w	r3, r3, #4294967295
 8014800:	647b      	str	r3, [r7, #68]	; 0x44
 8014802:	e005      	b.n	8014810 <xmp3_IMDCT+0x168>
	} else {
		/* all short transforms */
		bc.nBlocksLong = 0;
 8014804:	f04f 0300 	mov.w	r3, #0
 8014808:	613b      	str	r3, [r7, #16]
		nBfly = 0;
 801480a:	f04f 0300 	mov.w	r3, #0
 801480e:	647b      	str	r3, [r7, #68]	; 0x44
	}
 
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 8014810:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8014812:	687a      	ldr	r2, [r7, #4]
 8014814:	4613      	mov	r3, r2
 8014816:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801481a:	189b      	adds	r3, r3, r2
 801481c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8014820:	18cb      	adds	r3, r1, r3
 8014822:	4618      	mov	r0, r3
 8014824:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8014826:	f7fe f91d 	bl	8012a64 <AntiAlias>
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801482a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801482c:	4613      	mov	r3, r2
 801482e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8014832:	189b      	adds	r3, r3, r2
 8014834:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8014838:	f103 0208 	add.w	r2, r3, #8
 801483c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801483e:	6879      	ldr	r1, [r7, #4]
 8014840:	f501 6190 	add.w	r1, r1, #1152	; 0x480
 8014844:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8014848:	429a      	cmp	r2, r3
 801484a:	bfac      	ite	ge
 801484c:	4611      	movge	r1, r2
 801484e:	4619      	movlt	r1, r3
 8014850:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014852:	687a      	ldr	r2, [r7, #4]
 8014854:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 8014858:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	ASSERT(hi->nonZeroBound[ch] <= MAX_NSAMP);

	/* for readability, use a struct instead of passing a million parameters to HybridTransform() */
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 801485c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801485e:	687a      	ldr	r2, [r7, #4]
 8014860:	f502 6290 	add.w	r2, r2, #1152	; 0x480
 8014864:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8014868:	f103 0211 	add.w	r2, r3, #17
 801486c:	f648 6339 	movw	r3, #36409	; 0x8e39
 8014870:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
 8014874:	fb83 1302 	smull	r1, r3, r3, r2
 8014878:	ea4f 01a3 	mov.w	r1, r3, asr #2
 801487c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8014880:	1acb      	subs	r3, r1, r3
 8014882:	617b      	str	r3, [r7, #20]
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 8014884:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014886:	687a      	ldr	r2, [r7, #4]
 8014888:	f502 62d8 	add.w	r2, r2, #1728	; 0x6c0
 801488c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8014890:	61bb      	str	r3, [r7, #24]
	bc.prevType = mi->prevType[ch];
 8014892:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014894:	687b      	ldr	r3, [r7, #4]
 8014896:	f503 63d8 	add.w	r3, r3, #1728	; 0x6c0
 801489a:	f103 0302 	add.w	r3, r3, #2
 801489e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80148a2:	61fb      	str	r3, [r7, #28]
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 80148a4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80148a6:	687b      	ldr	r3, [r7, #4]
 80148a8:	f503 63d8 	add.w	r3, r3, #1728	; 0x6c0
 80148ac:	f103 0304 	add.w	r3, r3, #4
 80148b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80148b4:	623b      	str	r3, [r7, #32]
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 80148b6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80148b8:	687b      	ldr	r3, [r7, #4]
 80148ba:	68b9      	ldr	r1, [r7, #8]
 80148bc:	461a      	mov	r2, r3
 80148be:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80148c2:	18d2      	adds	r2, r2, r3
 80148c4:	ea4f 03c2 	mov.w	r3, r2, lsl #3
 80148c8:	461a      	mov	r2, r3
 80148ca:	460b      	mov	r3, r1
 80148cc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80148d0:	185b      	adds	r3, r3, r1
 80148d2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80148d6:	18d3      	adds	r3, r2, r3
 80148d8:	18c3      	adds	r3, r0, r3
 80148da:	f103 0340 	add.w	r3, r3, #64	; 0x40
 80148de:	681b      	ldr	r3, [r3, #0]
 80148e0:	2b00      	cmp	r3, #0
 80148e2:	d001      	beq.n	80148e8 <xmp3_IMDCT+0x240>
 80148e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80148e6:	e001      	b.n	80148ec <xmp3_IMDCT+0x244>
 80148e8:	f04f 0300 	mov.w	r3, #0
 80148ec:	627b      	str	r3, [r7, #36]	; 0x24
	bc.gbIn = hi->gb[ch];
 80148ee:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80148f0:	687b      	ldr	r3, [r7, #4]
 80148f2:	f503 6390 	add.w	r3, r3, #1152	; 0x480
 80148f6:	f103 0302 	add.w	r3, r3, #2
 80148fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80148fe:	62bb      	str	r3, [r7, #40]	; 0x28

	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8014900:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8014902:	687a      	ldr	r2, [r7, #4]
 8014904:	4613      	mov	r3, r2
 8014906:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801490a:	189b      	adds	r3, r3, r2
 801490c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8014910:	18c8      	adds	r0, r1, r3
 8014912:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014914:	f503 5190 	add.w	r1, r3, #4608	; 0x1200
 8014918:	687a      	ldr	r2, [r7, #4]
 801491a:	4613      	mov	r3, r2
 801491c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8014920:	189b      	adds	r3, r3, r2
 8014922:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8014926:	18c9      	adds	r1, r1, r3
 8014928:	6b7c      	ldr	r4, [r7, #52]	; 0x34
 801492a:	687a      	ldr	r2, [r7, #4]
 801492c:	4613      	mov	r3, r2
 801492e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8014932:	189b      	adds	r3, r3, r2
 8014934:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8014938:	18e4      	adds	r4, r4, r3
 801493a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801493c:	f103 0528 	add.w	r5, r3, #40	; 0x28
 8014940:	68ba      	ldr	r2, [r7, #8]
 8014942:	4613      	mov	r3, r2
 8014944:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8014948:	189b      	adds	r3, r3, r2
 801494a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 801494e:	461e      	mov	r6, r3
 8014950:	687a      	ldr	r2, [r7, #4]
 8014952:	4613      	mov	r3, r2
 8014954:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8014958:	189b      	adds	r3, r3, r2
 801495a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801495e:	18f3      	adds	r3, r6, r3
 8014960:	18eb      	adds	r3, r5, r3
 8014962:	f107 0210 	add.w	r2, r7, #16
 8014966:	9200      	str	r2, [sp, #0]
 8014968:	4622      	mov	r2, r4
 801496a:	f7ff fd53 	bl	8014414 <HybridTransform>
 801496e:	4601      	mov	r1, r0
 8014970:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014972:	687a      	ldr	r2, [r7, #4]
 8014974:	f502 62d8 	add.w	r2, r2, #1728	; 0x6c0
 8014978:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 801497c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801497e:	687b      	ldr	r3, [r7, #4]
 8014980:	68b9      	ldr	r1, [r7, #8]
 8014982:	461a      	mov	r2, r3
 8014984:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8014988:	18d2      	adds	r2, r2, r3
 801498a:	ea4f 03c2 	mov.w	r3, r2, lsl #3
 801498e:	461a      	mov	r2, r3
 8014990:	460b      	mov	r3, r1
 8014992:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8014996:	185b      	adds	r3, r3, r1
 8014998:	ea4f 1303 	mov.w	r3, r3, lsl #4
 801499c:	18d3      	adds	r3, r2, r3
 801499e:	18c3      	adds	r3, r0, r3
 80149a0:	f103 033c 	add.w	r3, r3, #60	; 0x3c
 80149a4:	6819      	ldr	r1, [r3, #0]
 80149a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80149a8:	687b      	ldr	r3, [r7, #4]
 80149aa:	f503 63d8 	add.w	r3, r3, #1728	; 0x6c0
 80149ae:	f103 0302 	add.w	r3, r3, #2
 80149b2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
 80149b6:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80149b8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80149ba:	687b      	ldr	r3, [r7, #4]
 80149bc:	f503 63d8 	add.w	r3, r3, #1728	; 0x6c0
 80149c0:	f103 0304 	add.w	r3, r3, #4
 80149c4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	mi->gb[ch] = bc.gbOut;
 80149c8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80149ca:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80149cc:	687b      	ldr	r3, [r7, #4]
 80149ce:	f503 63d8 	add.w	r3, r3, #1728	; 0x6c0
 80149d2:	f103 0306 	add.w	r3, r3, #6
 80149d6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

	ASSERT(mi->numPrevIMDCT[ch] <= NBANDS);

	/* output has gained 2 int bits */
	return 0;
 80149da:	f04f 0300 	mov.w	r3, #0
}
 80149de:	4618      	mov	r0, r3
 80149e0:	f107 074c 	add.w	r7, r7, #76	; 0x4c
 80149e4:	46bd      	mov	sp, r7
 80149e6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080149e8 <MADD64>:
signed int hi32;
} r;
} U64;

static __inline Word64 MADD64(Word64 sum64, int x, int y)
{
 80149e8:	b480      	push	{r7}
 80149ea:	b087      	sub	sp, #28
 80149ec:	af00      	add	r7, sp, #0
 80149ee:	e9c7 0102 	strd	r0, r1, [r7, #8]
 80149f2:	607a      	str	r2, [r7, #4]
 80149f4:	603b      	str	r3, [r7, #0]
U64 u;
u.w64 = sum64;
 80149f6:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80149fa:	e9c7 2304 	strd	r2, r3, [r7, #16]

__asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 80149fe:	693a      	ldr	r2, [r7, #16]
 8014a00:	697b      	ldr	r3, [r7, #20]
 8014a02:	6879      	ldr	r1, [r7, #4]
 8014a04:	6838      	ldr	r0, [r7, #0]
 8014a06:	fbc1 2300 	smlal	r2, r3, r1, r0
 8014a0a:	613a      	str	r2, [r7, #16]
 8014a0c:	617b      	str	r3, [r7, #20]

return u.w64;
 8014a0e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
}
 8014a12:	4610      	mov	r0, r2
 8014a14:	4619      	mov	r1, r3
 8014a16:	f107 071c 	add.w	r7, r7, #28
 8014a1a:	46bd      	mov	sp, r7
 8014a1c:	bc80      	pop	{r7}
 8014a1e:	4770      	bx	lr

08014a20 <SAR64>:
static __inline Word64 SAR64(Word64 x, int n)
{
 8014a20:	b4f0      	push	{r4, r5, r6, r7}
 8014a22:	b084      	sub	sp, #16
 8014a24:	af00      	add	r7, sp, #0
 8014a26:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8014a2a:	607a      	str	r2, [r7, #4]
return x >> n;
 8014a2c:	687b      	ldr	r3, [r7, #4]
 8014a2e:	f1a3 0320 	sub.w	r3, r3, #32
 8014a32:	68fa      	ldr	r2, [r7, #12]
 8014a34:	fa42 f203 	asr.w	r2, r2, r3
 8014a38:	6879      	ldr	r1, [r7, #4]
 8014a3a:	f1c1 0120 	rsb	r1, r1, #32
 8014a3e:	68f8      	ldr	r0, [r7, #12]
 8014a40:	fa00 f101 	lsl.w	r1, r0, r1
 8014a44:	68be      	ldr	r6, [r7, #8]
 8014a46:	6878      	ldr	r0, [r7, #4]
 8014a48:	fa26 f400 	lsr.w	r4, r6, r0
 8014a4c:	430c      	orrs	r4, r1
 8014a4e:	2b00      	cmp	r3, #0
 8014a50:	bfa8      	it	ge
 8014a52:	4614      	movge	r4, r2
 8014a54:	68fa      	ldr	r2, [r7, #12]
 8014a56:	687b      	ldr	r3, [r7, #4]
 8014a58:	fa42 f503 	asr.w	r5, r2, r3
 8014a5c:	4622      	mov	r2, r4
 8014a5e:	462b      	mov	r3, r5

}
 8014a60:	4610      	mov	r0, r2
 8014a62:	4619      	mov	r1, r3
 8014a64:	f107 0710 	add.w	r7, r7, #16
 8014a68:	46bd      	mov	sp, r7
 8014a6a:	bcf0      	pop	{r4, r5, r6, r7}
 8014a6c:	4770      	bx	lr
 8014a6e:	bf00      	nop

08014a70 <ClipToShort>:
 */
#define DEF_NFRACBITS	(DQ_FRACBITS_OUT - 2 - 2 - 15)	
#define CSHIFT	12	/* coefficients have 12 leading sign bits for early-terminating mulitplies */

static __inline short ClipToShort(int x, int fracBits)
{
 8014a70:	b480      	push	{r7}
 8014a72:	b085      	sub	sp, #20
 8014a74:	af00      	add	r7, sp, #0
 8014a76:	6078      	str	r0, [r7, #4]
 8014a78:	6039      	str	r1, [r7, #0]
	int sign;
	
	/* assumes you've already rounded (x += (1 << (fracBits-1))) */
	x >>= fracBits;
 8014a7a:	687a      	ldr	r2, [r7, #4]
 8014a7c:	683b      	ldr	r3, [r7, #0]
 8014a7e:	fa42 f303 	asr.w	r3, r2, r3
 8014a82:	607b      	str	r3, [r7, #4]
	
	/* Ken's trick: clips to [-32768, 32767] */
	sign = x >> 31;
 8014a84:	687b      	ldr	r3, [r7, #4]
 8014a86:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8014a8a:	60fb      	str	r3, [r7, #12]
	if (sign != (x >> 15))
 8014a8c:	687b      	ldr	r3, [r7, #4]
 8014a8e:	ea4f 32e3 	mov.w	r2, r3, asr #15
 8014a92:	68fb      	ldr	r3, [r7, #12]
 8014a94:	429a      	cmp	r2, r3
 8014a96:	d005      	beq.n	8014aa4 <ClipToShort+0x34>
		x = sign ^ ((1 << 15) - 1);
 8014a98:	68fb      	ldr	r3, [r7, #12]
 8014a9a:	f483 43fe 	eor.w	r3, r3, #32512	; 0x7f00
 8014a9e:	f083 03ff 	eor.w	r3, r3, #255	; 0xff
 8014aa2:	607b      	str	r3, [r7, #4]

	return (short)x;
 8014aa4:	687b      	ldr	r3, [r7, #4]
 8014aa6:	b29b      	uxth	r3, r3
 8014aa8:	b21b      	sxth	r3, r3
}
 8014aaa:	4618      	mov	r0, r3
 8014aac:	f107 0714 	add.w	r7, r7, #20
 8014ab0:	46bd      	mov	sp, r7
 8014ab2:	bc80      	pop	{r7}
 8014ab4:	4770      	bx	lr
 8014ab6:	bf00      	nop

08014ab8 <xmp3_PolyphaseMono>:
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 *                (note max filter gain - see polyCoef[] comments)
 **************************************************************************************/
void PolyphaseMono(short *pcm, int *vbuf, const int *coefBase)
{	
 8014ab8:	b590      	push	{r4, r7, lr}
 8014aba:	b093      	sub	sp, #76	; 0x4c
 8014abc:	af00      	add	r7, sp, #0
 8014abe:	60f8      	str	r0, [r7, #12]
 8014ac0:	60b9      	str	r1, [r7, #8]
 8014ac2:	607a      	str	r2, [r7, #4]
	const int *coef;
	int *vb1;
	int vLo, vHi, c1, c2;
	Word64 sum1L, sum2L, rndVal;

	rndVal = (Word64)( 1 << (DEF_NFRACBITS - 1 + (32 - CSHIFT)) );
 8014ac4:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8014ac8:	f04f 0300 	mov.w	r3, #0
 8014acc:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

	/* special case, output sample 0 */
	coef = coefBase;
 8014ad0:	687b      	ldr	r3, [r7, #4]
 8014ad2:	643b      	str	r3, [r7, #64]	; 0x40
	vb1 = vbuf;
 8014ad4:	68bb      	ldr	r3, [r7, #8]
 8014ad6:	63fb      	str	r3, [r7, #60]	; 0x3c
	sum1L = rndVal;
 8014ad8:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 8014adc:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

	MC0M(0)
 8014ae0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014ae2:	681b      	ldr	r3, [r3, #0]
 8014ae4:	627b      	str	r3, [r7, #36]	; 0x24
 8014ae6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014ae8:	f103 0304 	add.w	r3, r3, #4
 8014aec:	643b      	str	r3, [r7, #64]	; 0x40
 8014aee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014af0:	681b      	ldr	r3, [r3, #0]
 8014af2:	623b      	str	r3, [r7, #32]
 8014af4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014af6:	f103 0304 	add.w	r3, r3, #4
 8014afa:	643b      	str	r3, [r7, #64]	; 0x40
 8014afc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014afe:	681b      	ldr	r3, [r3, #0]
 8014b00:	61fb      	str	r3, [r7, #28]
 8014b02:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014b04:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8014b06:	61bb      	str	r3, [r7, #24]
 8014b08:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014b0c:	69fa      	ldr	r2, [r7, #28]
 8014b0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014b10:	f7ff ff6a 	bl	80149e8 <MADD64>
 8014b14:	4602      	mov	r2, r0
 8014b16:	460b      	mov	r3, r1
 8014b18:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014b1c:	6a3b      	ldr	r3, [r7, #32]
 8014b1e:	f1c3 0300 	rsb	r3, r3, #0
 8014b22:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014b26:	69ba      	ldr	r2, [r7, #24]
 8014b28:	f7ff ff5e 	bl	80149e8 <MADD64>
 8014b2c:	4602      	mov	r2, r0
 8014b2e:	460b      	mov	r3, r1
 8014b30:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC0M(1)
 8014b34:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014b36:	681b      	ldr	r3, [r3, #0]
 8014b38:	627b      	str	r3, [r7, #36]	; 0x24
 8014b3a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014b3c:	f103 0304 	add.w	r3, r3, #4
 8014b40:	643b      	str	r3, [r7, #64]	; 0x40
 8014b42:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014b44:	681b      	ldr	r3, [r3, #0]
 8014b46:	623b      	str	r3, [r7, #32]
 8014b48:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014b4a:	f103 0304 	add.w	r3, r3, #4
 8014b4e:	643b      	str	r3, [r7, #64]	; 0x40
 8014b50:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014b52:	685b      	ldr	r3, [r3, #4]
 8014b54:	61fb      	str	r3, [r7, #28]
 8014b56:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014b58:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8014b5a:	61bb      	str	r3, [r7, #24]
 8014b5c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014b60:	69fa      	ldr	r2, [r7, #28]
 8014b62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014b64:	f7ff ff40 	bl	80149e8 <MADD64>
 8014b68:	4602      	mov	r2, r0
 8014b6a:	460b      	mov	r3, r1
 8014b6c:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014b70:	6a3b      	ldr	r3, [r7, #32]
 8014b72:	f1c3 0300 	rsb	r3, r3, #0
 8014b76:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014b7a:	69ba      	ldr	r2, [r7, #24]
 8014b7c:	f7ff ff34 	bl	80149e8 <MADD64>
 8014b80:	4602      	mov	r2, r0
 8014b82:	460b      	mov	r3, r1
 8014b84:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC0M(2)
 8014b88:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014b8a:	681b      	ldr	r3, [r3, #0]
 8014b8c:	627b      	str	r3, [r7, #36]	; 0x24
 8014b8e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014b90:	f103 0304 	add.w	r3, r3, #4
 8014b94:	643b      	str	r3, [r7, #64]	; 0x40
 8014b96:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014b98:	681b      	ldr	r3, [r3, #0]
 8014b9a:	623b      	str	r3, [r7, #32]
 8014b9c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014b9e:	f103 0304 	add.w	r3, r3, #4
 8014ba2:	643b      	str	r3, [r7, #64]	; 0x40
 8014ba4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014ba6:	689b      	ldr	r3, [r3, #8]
 8014ba8:	61fb      	str	r3, [r7, #28]
 8014baa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014bac:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8014bae:	61bb      	str	r3, [r7, #24]
 8014bb0:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014bb4:	69fa      	ldr	r2, [r7, #28]
 8014bb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014bb8:	f7ff ff16 	bl	80149e8 <MADD64>
 8014bbc:	4602      	mov	r2, r0
 8014bbe:	460b      	mov	r3, r1
 8014bc0:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014bc4:	6a3b      	ldr	r3, [r7, #32]
 8014bc6:	f1c3 0300 	rsb	r3, r3, #0
 8014bca:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014bce:	69ba      	ldr	r2, [r7, #24]
 8014bd0:	f7ff ff0a 	bl	80149e8 <MADD64>
 8014bd4:	4602      	mov	r2, r0
 8014bd6:	460b      	mov	r3, r1
 8014bd8:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC0M(3)
 8014bdc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014bde:	681b      	ldr	r3, [r3, #0]
 8014be0:	627b      	str	r3, [r7, #36]	; 0x24
 8014be2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014be4:	f103 0304 	add.w	r3, r3, #4
 8014be8:	643b      	str	r3, [r7, #64]	; 0x40
 8014bea:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014bec:	681b      	ldr	r3, [r3, #0]
 8014bee:	623b      	str	r3, [r7, #32]
 8014bf0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014bf2:	f103 0304 	add.w	r3, r3, #4
 8014bf6:	643b      	str	r3, [r7, #64]	; 0x40
 8014bf8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014bfa:	68db      	ldr	r3, [r3, #12]
 8014bfc:	61fb      	str	r3, [r7, #28]
 8014bfe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014c00:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014c02:	61bb      	str	r3, [r7, #24]
 8014c04:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014c08:	69fa      	ldr	r2, [r7, #28]
 8014c0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014c0c:	f7ff feec 	bl	80149e8 <MADD64>
 8014c10:	4602      	mov	r2, r0
 8014c12:	460b      	mov	r3, r1
 8014c14:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014c18:	6a3b      	ldr	r3, [r7, #32]
 8014c1a:	f1c3 0300 	rsb	r3, r3, #0
 8014c1e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014c22:	69ba      	ldr	r2, [r7, #24]
 8014c24:	f7ff fee0 	bl	80149e8 <MADD64>
 8014c28:	4602      	mov	r2, r0
 8014c2a:	460b      	mov	r3, r1
 8014c2c:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC0M(4)
 8014c30:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014c32:	681b      	ldr	r3, [r3, #0]
 8014c34:	627b      	str	r3, [r7, #36]	; 0x24
 8014c36:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014c38:	f103 0304 	add.w	r3, r3, #4
 8014c3c:	643b      	str	r3, [r7, #64]	; 0x40
 8014c3e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014c40:	681b      	ldr	r3, [r3, #0]
 8014c42:	623b      	str	r3, [r7, #32]
 8014c44:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014c46:	f103 0304 	add.w	r3, r3, #4
 8014c4a:	643b      	str	r3, [r7, #64]	; 0x40
 8014c4c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014c4e:	691b      	ldr	r3, [r3, #16]
 8014c50:	61fb      	str	r3, [r7, #28]
 8014c52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014c54:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014c56:	61bb      	str	r3, [r7, #24]
 8014c58:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014c5c:	69fa      	ldr	r2, [r7, #28]
 8014c5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014c60:	f7ff fec2 	bl	80149e8 <MADD64>
 8014c64:	4602      	mov	r2, r0
 8014c66:	460b      	mov	r3, r1
 8014c68:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014c6c:	6a3b      	ldr	r3, [r7, #32]
 8014c6e:	f1c3 0300 	rsb	r3, r3, #0
 8014c72:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014c76:	69ba      	ldr	r2, [r7, #24]
 8014c78:	f7ff feb6 	bl	80149e8 <MADD64>
 8014c7c:	4602      	mov	r2, r0
 8014c7e:	460b      	mov	r3, r1
 8014c80:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC0M(5)
 8014c84:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014c86:	681b      	ldr	r3, [r3, #0]
 8014c88:	627b      	str	r3, [r7, #36]	; 0x24
 8014c8a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014c8c:	f103 0304 	add.w	r3, r3, #4
 8014c90:	643b      	str	r3, [r7, #64]	; 0x40
 8014c92:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014c94:	681b      	ldr	r3, [r3, #0]
 8014c96:	623b      	str	r3, [r7, #32]
 8014c98:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014c9a:	f103 0304 	add.w	r3, r3, #4
 8014c9e:	643b      	str	r3, [r7, #64]	; 0x40
 8014ca0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014ca2:	695b      	ldr	r3, [r3, #20]
 8014ca4:	61fb      	str	r3, [r7, #28]
 8014ca6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014ca8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014caa:	61bb      	str	r3, [r7, #24]
 8014cac:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014cb0:	69fa      	ldr	r2, [r7, #28]
 8014cb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014cb4:	f7ff fe98 	bl	80149e8 <MADD64>
 8014cb8:	4602      	mov	r2, r0
 8014cba:	460b      	mov	r3, r1
 8014cbc:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014cc0:	6a3b      	ldr	r3, [r7, #32]
 8014cc2:	f1c3 0300 	rsb	r3, r3, #0
 8014cc6:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014cca:	69ba      	ldr	r2, [r7, #24]
 8014ccc:	f7ff fe8c 	bl	80149e8 <MADD64>
 8014cd0:	4602      	mov	r2, r0
 8014cd2:	460b      	mov	r3, r1
 8014cd4:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC0M(6)
 8014cd8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014cda:	681b      	ldr	r3, [r3, #0]
 8014cdc:	627b      	str	r3, [r7, #36]	; 0x24
 8014cde:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014ce0:	f103 0304 	add.w	r3, r3, #4
 8014ce4:	643b      	str	r3, [r7, #64]	; 0x40
 8014ce6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014ce8:	681b      	ldr	r3, [r3, #0]
 8014cea:	623b      	str	r3, [r7, #32]
 8014cec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014cee:	f103 0304 	add.w	r3, r3, #4
 8014cf2:	643b      	str	r3, [r7, #64]	; 0x40
 8014cf4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014cf6:	699b      	ldr	r3, [r3, #24]
 8014cf8:	61fb      	str	r3, [r7, #28]
 8014cfa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014cfc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014cfe:	61bb      	str	r3, [r7, #24]
 8014d00:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014d04:	69fa      	ldr	r2, [r7, #28]
 8014d06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014d08:	f7ff fe6e 	bl	80149e8 <MADD64>
 8014d0c:	4602      	mov	r2, r0
 8014d0e:	460b      	mov	r3, r1
 8014d10:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014d14:	6a3b      	ldr	r3, [r7, #32]
 8014d16:	f1c3 0300 	rsb	r3, r3, #0
 8014d1a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014d1e:	69ba      	ldr	r2, [r7, #24]
 8014d20:	f7ff fe62 	bl	80149e8 <MADD64>
 8014d24:	4602      	mov	r2, r0
 8014d26:	460b      	mov	r3, r1
 8014d28:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC0M(7)
 8014d2c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014d2e:	681b      	ldr	r3, [r3, #0]
 8014d30:	627b      	str	r3, [r7, #36]	; 0x24
 8014d32:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014d34:	f103 0304 	add.w	r3, r3, #4
 8014d38:	643b      	str	r3, [r7, #64]	; 0x40
 8014d3a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014d3c:	681b      	ldr	r3, [r3, #0]
 8014d3e:	623b      	str	r3, [r7, #32]
 8014d40:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014d42:	f103 0304 	add.w	r3, r3, #4
 8014d46:	643b      	str	r3, [r7, #64]	; 0x40
 8014d48:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014d4a:	69db      	ldr	r3, [r3, #28]
 8014d4c:	61fb      	str	r3, [r7, #28]
 8014d4e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014d50:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014d52:	61bb      	str	r3, [r7, #24]
 8014d54:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014d58:	69fa      	ldr	r2, [r7, #28]
 8014d5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014d5c:	f7ff fe44 	bl	80149e8 <MADD64>
 8014d60:	4602      	mov	r2, r0
 8014d62:	460b      	mov	r3, r1
 8014d64:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014d68:	6a3b      	ldr	r3, [r7, #32]
 8014d6a:	f1c3 0300 	rsb	r3, r3, #0
 8014d6e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014d72:	69ba      	ldr	r2, [r7, #24]
 8014d74:	f7ff fe38 	bl	80149e8 <MADD64>
 8014d78:	4602      	mov	r2, r0
 8014d7a:	460b      	mov	r3, r1
 8014d7c:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

	*(pcm + 0) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 8014d80:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014d84:	f04f 0214 	mov.w	r2, #20
 8014d88:	f7ff fe4a 	bl	8014a20 <SAR64>
 8014d8c:	4602      	mov	r2, r0
 8014d8e:	460b      	mov	r3, r1
 8014d90:	4613      	mov	r3, r2
 8014d92:	4618      	mov	r0, r3
 8014d94:	f04f 0106 	mov.w	r1, #6
 8014d98:	f7ff fe6a 	bl	8014a70 <ClipToShort>
 8014d9c:	4603      	mov	r3, r0
 8014d9e:	461a      	mov	r2, r3
 8014da0:	68fb      	ldr	r3, [r7, #12]
 8014da2:	801a      	strh	r2, [r3, #0]

	/* special case, output sample 16 */
	coef = coefBase + 256;
 8014da4:	687b      	ldr	r3, [r7, #4]
 8014da6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8014daa:	643b      	str	r3, [r7, #64]	; 0x40
	vb1 = vbuf + 64*16;
 8014dac:	68bb      	ldr	r3, [r7, #8]
 8014dae:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8014db2:	63fb      	str	r3, [r7, #60]	; 0x3c
	sum1L = rndVal;
 8014db4:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 8014db8:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

	MC1M(0)
 8014dbc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014dbe:	681b      	ldr	r3, [r3, #0]
 8014dc0:	627b      	str	r3, [r7, #36]	; 0x24
 8014dc2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014dc4:	f103 0304 	add.w	r3, r3, #4
 8014dc8:	643b      	str	r3, [r7, #64]	; 0x40
 8014dca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014dcc:	681b      	ldr	r3, [r3, #0]
 8014dce:	61fb      	str	r3, [r7, #28]
 8014dd0:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014dd4:	69fa      	ldr	r2, [r7, #28]
 8014dd6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014dd8:	f7ff fe06 	bl	80149e8 <MADD64>
 8014ddc:	4602      	mov	r2, r0
 8014dde:	460b      	mov	r3, r1
 8014de0:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC1M(1)
 8014de4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014de6:	681b      	ldr	r3, [r3, #0]
 8014de8:	627b      	str	r3, [r7, #36]	; 0x24
 8014dea:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014dec:	f103 0304 	add.w	r3, r3, #4
 8014df0:	643b      	str	r3, [r7, #64]	; 0x40
 8014df2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014df4:	685b      	ldr	r3, [r3, #4]
 8014df6:	61fb      	str	r3, [r7, #28]
 8014df8:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014dfc:	69fa      	ldr	r2, [r7, #28]
 8014dfe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014e00:	f7ff fdf2 	bl	80149e8 <MADD64>
 8014e04:	4602      	mov	r2, r0
 8014e06:	460b      	mov	r3, r1
 8014e08:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC1M(2)
 8014e0c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014e0e:	681b      	ldr	r3, [r3, #0]
 8014e10:	627b      	str	r3, [r7, #36]	; 0x24
 8014e12:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014e14:	f103 0304 	add.w	r3, r3, #4
 8014e18:	643b      	str	r3, [r7, #64]	; 0x40
 8014e1a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014e1c:	689b      	ldr	r3, [r3, #8]
 8014e1e:	61fb      	str	r3, [r7, #28]
 8014e20:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014e24:	69fa      	ldr	r2, [r7, #28]
 8014e26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014e28:	f7ff fdde 	bl	80149e8 <MADD64>
 8014e2c:	4602      	mov	r2, r0
 8014e2e:	460b      	mov	r3, r1
 8014e30:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC1M(3)
 8014e34:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014e36:	681b      	ldr	r3, [r3, #0]
 8014e38:	627b      	str	r3, [r7, #36]	; 0x24
 8014e3a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014e3c:	f103 0304 	add.w	r3, r3, #4
 8014e40:	643b      	str	r3, [r7, #64]	; 0x40
 8014e42:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014e44:	68db      	ldr	r3, [r3, #12]
 8014e46:	61fb      	str	r3, [r7, #28]
 8014e48:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014e4c:	69fa      	ldr	r2, [r7, #28]
 8014e4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014e50:	f7ff fdca 	bl	80149e8 <MADD64>
 8014e54:	4602      	mov	r2, r0
 8014e56:	460b      	mov	r3, r1
 8014e58:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC1M(4)
 8014e5c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014e5e:	681b      	ldr	r3, [r3, #0]
 8014e60:	627b      	str	r3, [r7, #36]	; 0x24
 8014e62:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014e64:	f103 0304 	add.w	r3, r3, #4
 8014e68:	643b      	str	r3, [r7, #64]	; 0x40
 8014e6a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014e6c:	691b      	ldr	r3, [r3, #16]
 8014e6e:	61fb      	str	r3, [r7, #28]
 8014e70:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014e74:	69fa      	ldr	r2, [r7, #28]
 8014e76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014e78:	f7ff fdb6 	bl	80149e8 <MADD64>
 8014e7c:	4602      	mov	r2, r0
 8014e7e:	460b      	mov	r3, r1
 8014e80:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC1M(5)
 8014e84:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014e86:	681b      	ldr	r3, [r3, #0]
 8014e88:	627b      	str	r3, [r7, #36]	; 0x24
 8014e8a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014e8c:	f103 0304 	add.w	r3, r3, #4
 8014e90:	643b      	str	r3, [r7, #64]	; 0x40
 8014e92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014e94:	695b      	ldr	r3, [r3, #20]
 8014e96:	61fb      	str	r3, [r7, #28]
 8014e98:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014e9c:	69fa      	ldr	r2, [r7, #28]
 8014e9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014ea0:	f7ff fda2 	bl	80149e8 <MADD64>
 8014ea4:	4602      	mov	r2, r0
 8014ea6:	460b      	mov	r3, r1
 8014ea8:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC1M(6)
 8014eac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014eae:	681b      	ldr	r3, [r3, #0]
 8014eb0:	627b      	str	r3, [r7, #36]	; 0x24
 8014eb2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014eb4:	f103 0304 	add.w	r3, r3, #4
 8014eb8:	643b      	str	r3, [r7, #64]	; 0x40
 8014eba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014ebc:	699b      	ldr	r3, [r3, #24]
 8014ebe:	61fb      	str	r3, [r7, #28]
 8014ec0:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014ec4:	69fa      	ldr	r2, [r7, #28]
 8014ec6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014ec8:	f7ff fd8e 	bl	80149e8 <MADD64>
 8014ecc:	4602      	mov	r2, r0
 8014ece:	460b      	mov	r3, r1
 8014ed0:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	MC1M(7)
 8014ed4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014ed6:	681b      	ldr	r3, [r3, #0]
 8014ed8:	627b      	str	r3, [r7, #36]	; 0x24
 8014eda:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014edc:	f103 0304 	add.w	r3, r3, #4
 8014ee0:	643b      	str	r3, [r7, #64]	; 0x40
 8014ee2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014ee4:	69db      	ldr	r3, [r3, #28]
 8014ee6:	61fb      	str	r3, [r7, #28]
 8014ee8:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014eec:	69fa      	ldr	r2, [r7, #28]
 8014eee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014ef0:	f7ff fd7a 	bl	80149e8 <MADD64>
 8014ef4:	4602      	mov	r2, r0
 8014ef6:	460b      	mov	r3, r1
 8014ef8:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

	*(pcm + 16) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 8014efc:	68fb      	ldr	r3, [r7, #12]
 8014efe:	f103 0420 	add.w	r4, r3, #32
 8014f02:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014f06:	f04f 0214 	mov.w	r2, #20
 8014f0a:	f7ff fd89 	bl	8014a20 <SAR64>
 8014f0e:	4602      	mov	r2, r0
 8014f10:	460b      	mov	r3, r1
 8014f12:	4613      	mov	r3, r2
 8014f14:	4618      	mov	r0, r3
 8014f16:	f04f 0106 	mov.w	r1, #6
 8014f1a:	f7ff fda9 	bl	8014a70 <ClipToShort>
 8014f1e:	4603      	mov	r3, r0
 8014f20:	8023      	strh	r3, [r4, #0]

	/* main convolution loop: sum1L = samples 1, 2, 3, ... 15   sum2L = samples 31, 30, ... 17 */
	coef = coefBase + 16;
 8014f22:	687b      	ldr	r3, [r7, #4]
 8014f24:	f103 0340 	add.w	r3, r3, #64	; 0x40
 8014f28:	643b      	str	r3, [r7, #64]	; 0x40
	vb1 = vbuf + 64;
 8014f2a:	68bb      	ldr	r3, [r7, #8]
 8014f2c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8014f30:	63fb      	str	r3, [r7, #60]	; 0x3c
	pcm++;
 8014f32:	68fb      	ldr	r3, [r7, #12]
 8014f34:	f103 0302 	add.w	r3, r3, #2
 8014f38:	60fb      	str	r3, [r7, #12]

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 8014f3a:	f04f 030f 	mov.w	r3, #15
 8014f3e:	647b      	str	r3, [r7, #68]	; 0x44
 8014f40:	e22a      	b.n	8015398 <xmp3_PolyphaseMono+0x8e0>
		sum1L = sum2L = rndVal;
 8014f42:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 8014f46:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8014f4a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8014f4e:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

		MC2M(0)
 8014f52:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014f54:	681b      	ldr	r3, [r3, #0]
 8014f56:	627b      	str	r3, [r7, #36]	; 0x24
 8014f58:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014f5a:	f103 0304 	add.w	r3, r3, #4
 8014f5e:	643b      	str	r3, [r7, #64]	; 0x40
 8014f60:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014f62:	681b      	ldr	r3, [r3, #0]
 8014f64:	623b      	str	r3, [r7, #32]
 8014f66:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014f68:	f103 0304 	add.w	r3, r3, #4
 8014f6c:	643b      	str	r3, [r7, #64]	; 0x40
 8014f6e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014f70:	681b      	ldr	r3, [r3, #0]
 8014f72:	61fb      	str	r3, [r7, #28]
 8014f74:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014f76:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8014f78:	61bb      	str	r3, [r7, #24]
 8014f7a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014f7e:	69fa      	ldr	r2, [r7, #28]
 8014f80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014f82:	f7ff fd31 	bl	80149e8 <MADD64>
 8014f86:	4602      	mov	r2, r0
 8014f88:	460b      	mov	r3, r1
 8014f8a:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014f8e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8014f92:	69fa      	ldr	r2, [r7, #28]
 8014f94:	6a3b      	ldr	r3, [r7, #32]
 8014f96:	f7ff fd27 	bl	80149e8 <MADD64>
 8014f9a:	4602      	mov	r2, r0
 8014f9c:	460b      	mov	r3, r1
 8014f9e:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8014fa2:	6a3b      	ldr	r3, [r7, #32]
 8014fa4:	f1c3 0300 	rsb	r3, r3, #0
 8014fa8:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014fac:	69ba      	ldr	r2, [r7, #24]
 8014fae:	f7ff fd1b 	bl	80149e8 <MADD64>
 8014fb2:	4602      	mov	r2, r0
 8014fb4:	460b      	mov	r3, r1
 8014fb6:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8014fba:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8014fbe:	69ba      	ldr	r2, [r7, #24]
 8014fc0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014fc2:	f7ff fd11 	bl	80149e8 <MADD64>
 8014fc6:	4602      	mov	r2, r0
 8014fc8:	460b      	mov	r3, r1
 8014fca:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2M(1)
 8014fce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014fd0:	681b      	ldr	r3, [r3, #0]
 8014fd2:	627b      	str	r3, [r7, #36]	; 0x24
 8014fd4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014fd6:	f103 0304 	add.w	r3, r3, #4
 8014fda:	643b      	str	r3, [r7, #64]	; 0x40
 8014fdc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014fde:	681b      	ldr	r3, [r3, #0]
 8014fe0:	623b      	str	r3, [r7, #32]
 8014fe2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014fe4:	f103 0304 	add.w	r3, r3, #4
 8014fe8:	643b      	str	r3, [r7, #64]	; 0x40
 8014fea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014fec:	685b      	ldr	r3, [r3, #4]
 8014fee:	61fb      	str	r3, [r7, #28]
 8014ff0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014ff2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8014ff4:	61bb      	str	r3, [r7, #24]
 8014ff6:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014ffa:	69fa      	ldr	r2, [r7, #28]
 8014ffc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014ffe:	f7ff fcf3 	bl	80149e8 <MADD64>
 8015002:	4602      	mov	r2, r0
 8015004:	460b      	mov	r3, r1
 8015006:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 801500a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801500e:	69fa      	ldr	r2, [r7, #28]
 8015010:	6a3b      	ldr	r3, [r7, #32]
 8015012:	f7ff fce9 	bl	80149e8 <MADD64>
 8015016:	4602      	mov	r2, r0
 8015018:	460b      	mov	r3, r1
 801501a:	e9c7 2304 	strd	r2, r3, [r7, #16]
 801501e:	6a3b      	ldr	r3, [r7, #32]
 8015020:	f1c3 0300 	rsb	r3, r3, #0
 8015024:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8015028:	69ba      	ldr	r2, [r7, #24]
 801502a:	f7ff fcdd 	bl	80149e8 <MADD64>
 801502e:	4602      	mov	r2, r0
 8015030:	460b      	mov	r3, r1
 8015032:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8015036:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801503a:	69ba      	ldr	r2, [r7, #24]
 801503c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801503e:	f7ff fcd3 	bl	80149e8 <MADD64>
 8015042:	4602      	mov	r2, r0
 8015044:	460b      	mov	r3, r1
 8015046:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2M(2)
 801504a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801504c:	681b      	ldr	r3, [r3, #0]
 801504e:	627b      	str	r3, [r7, #36]	; 0x24
 8015050:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015052:	f103 0304 	add.w	r3, r3, #4
 8015056:	643b      	str	r3, [r7, #64]	; 0x40
 8015058:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801505a:	681b      	ldr	r3, [r3, #0]
 801505c:	623b      	str	r3, [r7, #32]
 801505e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015060:	f103 0304 	add.w	r3, r3, #4
 8015064:	643b      	str	r3, [r7, #64]	; 0x40
 8015066:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015068:	689b      	ldr	r3, [r3, #8]
 801506a:	61fb      	str	r3, [r7, #28]
 801506c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801506e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015070:	61bb      	str	r3, [r7, #24]
 8015072:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8015076:	69fa      	ldr	r2, [r7, #28]
 8015078:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801507a:	f7ff fcb5 	bl	80149e8 <MADD64>
 801507e:	4602      	mov	r2, r0
 8015080:	460b      	mov	r3, r1
 8015082:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8015086:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801508a:	69fa      	ldr	r2, [r7, #28]
 801508c:	6a3b      	ldr	r3, [r7, #32]
 801508e:	f7ff fcab 	bl	80149e8 <MADD64>
 8015092:	4602      	mov	r2, r0
 8015094:	460b      	mov	r3, r1
 8015096:	e9c7 2304 	strd	r2, r3, [r7, #16]
 801509a:	6a3b      	ldr	r3, [r7, #32]
 801509c:	f1c3 0300 	rsb	r3, r3, #0
 80150a0:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80150a4:	69ba      	ldr	r2, [r7, #24]
 80150a6:	f7ff fc9f 	bl	80149e8 <MADD64>
 80150aa:	4602      	mov	r2, r0
 80150ac:	460b      	mov	r3, r1
 80150ae:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 80150b2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80150b6:	69ba      	ldr	r2, [r7, #24]
 80150b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80150ba:	f7ff fc95 	bl	80149e8 <MADD64>
 80150be:	4602      	mov	r2, r0
 80150c0:	460b      	mov	r3, r1
 80150c2:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2M(3)
 80150c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80150c8:	681b      	ldr	r3, [r3, #0]
 80150ca:	627b      	str	r3, [r7, #36]	; 0x24
 80150cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80150ce:	f103 0304 	add.w	r3, r3, #4
 80150d2:	643b      	str	r3, [r7, #64]	; 0x40
 80150d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80150d6:	681b      	ldr	r3, [r3, #0]
 80150d8:	623b      	str	r3, [r7, #32]
 80150da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80150dc:	f103 0304 	add.w	r3, r3, #4
 80150e0:	643b      	str	r3, [r7, #64]	; 0x40
 80150e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80150e4:	68db      	ldr	r3, [r3, #12]
 80150e6:	61fb      	str	r3, [r7, #28]
 80150e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80150ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80150ec:	61bb      	str	r3, [r7, #24]
 80150ee:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80150f2:	69fa      	ldr	r2, [r7, #28]
 80150f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80150f6:	f7ff fc77 	bl	80149e8 <MADD64>
 80150fa:	4602      	mov	r2, r0
 80150fc:	460b      	mov	r3, r1
 80150fe:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8015102:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015106:	69fa      	ldr	r2, [r7, #28]
 8015108:	6a3b      	ldr	r3, [r7, #32]
 801510a:	f7ff fc6d 	bl	80149e8 <MADD64>
 801510e:	4602      	mov	r2, r0
 8015110:	460b      	mov	r3, r1
 8015112:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8015116:	6a3b      	ldr	r3, [r7, #32]
 8015118:	f1c3 0300 	rsb	r3, r3, #0
 801511c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8015120:	69ba      	ldr	r2, [r7, #24]
 8015122:	f7ff fc61 	bl	80149e8 <MADD64>
 8015126:	4602      	mov	r2, r0
 8015128:	460b      	mov	r3, r1
 801512a:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 801512e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015132:	69ba      	ldr	r2, [r7, #24]
 8015134:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015136:	f7ff fc57 	bl	80149e8 <MADD64>
 801513a:	4602      	mov	r2, r0
 801513c:	460b      	mov	r3, r1
 801513e:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2M(4)
 8015142:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015144:	681b      	ldr	r3, [r3, #0]
 8015146:	627b      	str	r3, [r7, #36]	; 0x24
 8015148:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801514a:	f103 0304 	add.w	r3, r3, #4
 801514e:	643b      	str	r3, [r7, #64]	; 0x40
 8015150:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015152:	681b      	ldr	r3, [r3, #0]
 8015154:	623b      	str	r3, [r7, #32]
 8015156:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015158:	f103 0304 	add.w	r3, r3, #4
 801515c:	643b      	str	r3, [r7, #64]	; 0x40
 801515e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015160:	691b      	ldr	r3, [r3, #16]
 8015162:	61fb      	str	r3, [r7, #28]
 8015164:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015166:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8015168:	61bb      	str	r3, [r7, #24]
 801516a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 801516e:	69fa      	ldr	r2, [r7, #28]
 8015170:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015172:	f7ff fc39 	bl	80149e8 <MADD64>
 8015176:	4602      	mov	r2, r0
 8015178:	460b      	mov	r3, r1
 801517a:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 801517e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015182:	69fa      	ldr	r2, [r7, #28]
 8015184:	6a3b      	ldr	r3, [r7, #32]
 8015186:	f7ff fc2f 	bl	80149e8 <MADD64>
 801518a:	4602      	mov	r2, r0
 801518c:	460b      	mov	r3, r1
 801518e:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8015192:	6a3b      	ldr	r3, [r7, #32]
 8015194:	f1c3 0300 	rsb	r3, r3, #0
 8015198:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 801519c:	69ba      	ldr	r2, [r7, #24]
 801519e:	f7ff fc23 	bl	80149e8 <MADD64>
 80151a2:	4602      	mov	r2, r0
 80151a4:	460b      	mov	r3, r1
 80151a6:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 80151aa:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80151ae:	69ba      	ldr	r2, [r7, #24]
 80151b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80151b2:	f7ff fc19 	bl	80149e8 <MADD64>
 80151b6:	4602      	mov	r2, r0
 80151b8:	460b      	mov	r3, r1
 80151ba:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2M(5)
 80151be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80151c0:	681b      	ldr	r3, [r3, #0]
 80151c2:	627b      	str	r3, [r7, #36]	; 0x24
 80151c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80151c6:	f103 0304 	add.w	r3, r3, #4
 80151ca:	643b      	str	r3, [r7, #64]	; 0x40
 80151cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80151ce:	681b      	ldr	r3, [r3, #0]
 80151d0:	623b      	str	r3, [r7, #32]
 80151d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80151d4:	f103 0304 	add.w	r3, r3, #4
 80151d8:	643b      	str	r3, [r7, #64]	; 0x40
 80151da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80151dc:	695b      	ldr	r3, [r3, #20]
 80151de:	61fb      	str	r3, [r7, #28]
 80151e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80151e2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80151e4:	61bb      	str	r3, [r7, #24]
 80151e6:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80151ea:	69fa      	ldr	r2, [r7, #28]
 80151ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80151ee:	f7ff fbfb 	bl	80149e8 <MADD64>
 80151f2:	4602      	mov	r2, r0
 80151f4:	460b      	mov	r3, r1
 80151f6:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 80151fa:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80151fe:	69fa      	ldr	r2, [r7, #28]
 8015200:	6a3b      	ldr	r3, [r7, #32]
 8015202:	f7ff fbf1 	bl	80149e8 <MADD64>
 8015206:	4602      	mov	r2, r0
 8015208:	460b      	mov	r3, r1
 801520a:	e9c7 2304 	strd	r2, r3, [r7, #16]
 801520e:	6a3b      	ldr	r3, [r7, #32]
 8015210:	f1c3 0300 	rsb	r3, r3, #0
 8015214:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8015218:	69ba      	ldr	r2, [r7, #24]
 801521a:	f7ff fbe5 	bl	80149e8 <MADD64>
 801521e:	4602      	mov	r2, r0
 8015220:	460b      	mov	r3, r1
 8015222:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8015226:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801522a:	69ba      	ldr	r2, [r7, #24]
 801522c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801522e:	f7ff fbdb 	bl	80149e8 <MADD64>
 8015232:	4602      	mov	r2, r0
 8015234:	460b      	mov	r3, r1
 8015236:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2M(6)
 801523a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801523c:	681b      	ldr	r3, [r3, #0]
 801523e:	627b      	str	r3, [r7, #36]	; 0x24
 8015240:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015242:	f103 0304 	add.w	r3, r3, #4
 8015246:	643b      	str	r3, [r7, #64]	; 0x40
 8015248:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801524a:	681b      	ldr	r3, [r3, #0]
 801524c:	623b      	str	r3, [r7, #32]
 801524e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015250:	f103 0304 	add.w	r3, r3, #4
 8015254:	643b      	str	r3, [r7, #64]	; 0x40
 8015256:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015258:	699b      	ldr	r3, [r3, #24]
 801525a:	61fb      	str	r3, [r7, #28]
 801525c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801525e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015260:	61bb      	str	r3, [r7, #24]
 8015262:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8015266:	69fa      	ldr	r2, [r7, #28]
 8015268:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801526a:	f7ff fbbd 	bl	80149e8 <MADD64>
 801526e:	4602      	mov	r2, r0
 8015270:	460b      	mov	r3, r1
 8015272:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 8015276:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801527a:	69fa      	ldr	r2, [r7, #28]
 801527c:	6a3b      	ldr	r3, [r7, #32]
 801527e:	f7ff fbb3 	bl	80149e8 <MADD64>
 8015282:	4602      	mov	r2, r0
 8015284:	460b      	mov	r3, r1
 8015286:	e9c7 2304 	strd	r2, r3, [r7, #16]
 801528a:	6a3b      	ldr	r3, [r7, #32]
 801528c:	f1c3 0300 	rsb	r3, r3, #0
 8015290:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8015294:	69ba      	ldr	r2, [r7, #24]
 8015296:	f7ff fba7 	bl	80149e8 <MADD64>
 801529a:	4602      	mov	r2, r0
 801529c:	460b      	mov	r3, r1
 801529e:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 80152a2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80152a6:	69ba      	ldr	r2, [r7, #24]
 80152a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80152aa:	f7ff fb9d 	bl	80149e8 <MADD64>
 80152ae:	4602      	mov	r2, r0
 80152b0:	460b      	mov	r3, r1
 80152b2:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2M(7)
 80152b6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80152b8:	681b      	ldr	r3, [r3, #0]
 80152ba:	627b      	str	r3, [r7, #36]	; 0x24
 80152bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80152be:	f103 0304 	add.w	r3, r3, #4
 80152c2:	643b      	str	r3, [r7, #64]	; 0x40
 80152c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80152c6:	681b      	ldr	r3, [r3, #0]
 80152c8:	623b      	str	r3, [r7, #32]
 80152ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80152cc:	f103 0304 	add.w	r3, r3, #4
 80152d0:	643b      	str	r3, [r7, #64]	; 0x40
 80152d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80152d4:	69db      	ldr	r3, [r3, #28]
 80152d6:	61fb      	str	r3, [r7, #28]
 80152d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80152da:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80152dc:	61bb      	str	r3, [r7, #24]
 80152de:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 80152e2:	69fa      	ldr	r2, [r7, #28]
 80152e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80152e6:	f7ff fb7f 	bl	80149e8 <MADD64>
 80152ea:	4602      	mov	r2, r0
 80152ec:	460b      	mov	r3, r1
 80152ee:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 80152f2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80152f6:	69fa      	ldr	r2, [r7, #28]
 80152f8:	6a3b      	ldr	r3, [r7, #32]
 80152fa:	f7ff fb75 	bl	80149e8 <MADD64>
 80152fe:	4602      	mov	r2, r0
 8015300:	460b      	mov	r3, r1
 8015302:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8015306:	6a3b      	ldr	r3, [r7, #32]
 8015308:	f1c3 0300 	rsb	r3, r3, #0
 801530c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8015310:	69ba      	ldr	r2, [r7, #24]
 8015312:	f7ff fb69 	bl	80149e8 <MADD64>
 8015316:	4602      	mov	r2, r0
 8015318:	460b      	mov	r3, r1
 801531a:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
 801531e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015322:	69ba      	ldr	r2, [r7, #24]
 8015324:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015326:	f7ff fb5f 	bl	80149e8 <MADD64>
 801532a:	4602      	mov	r2, r0
 801532c:	460b      	mov	r3, r1
 801532e:	e9c7 2304 	strd	r2, r3, [r7, #16]

		vb1 += 64;
 8015332:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015334:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8015338:	63fb      	str	r3, [r7, #60]	; 0x3c
		*(pcm)       = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 801533a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 801533e:	f04f 0214 	mov.w	r2, #20
 8015342:	f7ff fb6d 	bl	8014a20 <SAR64>
 8015346:	4602      	mov	r2, r0
 8015348:	460b      	mov	r3, r1
 801534a:	4613      	mov	r3, r2
 801534c:	4618      	mov	r0, r3
 801534e:	f04f 0106 	mov.w	r1, #6
 8015352:	f7ff fb8d 	bl	8014a70 <ClipToShort>
 8015356:	4603      	mov	r3, r0
 8015358:	461a      	mov	r2, r3
 801535a:	68fb      	ldr	r3, [r7, #12]
 801535c:	801a      	strh	r2, [r3, #0]
		*(pcm + 2*i) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
 801535e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015360:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015364:	68fa      	ldr	r2, [r7, #12]
 8015366:	18d4      	adds	r4, r2, r3
 8015368:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801536c:	f04f 0214 	mov.w	r2, #20
 8015370:	f7ff fb56 	bl	8014a20 <SAR64>
 8015374:	4602      	mov	r2, r0
 8015376:	460b      	mov	r3, r1
 8015378:	4613      	mov	r3, r2
 801537a:	4618      	mov	r0, r3
 801537c:	f04f 0106 	mov.w	r1, #6
 8015380:	f7ff fb76 	bl	8014a70 <ClipToShort>
 8015384:	4603      	mov	r3, r0
 8015386:	8023      	strh	r3, [r4, #0]
		pcm++;
 8015388:	68fb      	ldr	r3, [r7, #12]
 801538a:	f103 0302 	add.w	r3, r3, #2
 801538e:	60fb      	str	r3, [r7, #12]
	coef = coefBase + 16;
	vb1 = vbuf + 64;
	pcm++;

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 8015390:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015392:	f103 33ff 	add.w	r3, r3, #4294967295
 8015396:	647b      	str	r3, [r7, #68]	; 0x44
 8015398:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801539a:	2b00      	cmp	r3, #0
 801539c:	f73f add1 	bgt.w	8014f42 <xmp3_PolyphaseMono+0x48a>
		vb1 += 64;
		*(pcm)       = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*i) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
		pcm++;
	}
}
 80153a0:	f107 074c 	add.w	r7, r7, #76	; 0x4c
 80153a4:	46bd      	mov	sp, r7
 80153a6:	bd90      	pop	{r4, r7, pc}

080153a8 <xmp3_PolyphaseStereo>:
 * Notes:       interleaves PCM samples LRLRLR...
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 **************************************************************************************/
void PolyphaseStereo(short *pcm, int *vbuf, const int *coefBase)
{
 80153a8:	b590      	push	{r4, r7, lr}
 80153aa:	b097      	sub	sp, #92	; 0x5c
 80153ac:	af00      	add	r7, sp, #0
 80153ae:	60f8      	str	r0, [r7, #12]
 80153b0:	60b9      	str	r1, [r7, #8]
 80153b2:	607a      	str	r2, [r7, #4]
	const int *coef;
	int *vb1;
	int vLo, vHi, c1, c2;
	Word64 sum1L, sum2L, sum1R, sum2R, rndVal;

	rndVal = (Word64)( 1 << (DEF_NFRACBITS - 1 + (32 - CSHIFT)) );
 80153b4:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 80153b8:	f04f 0300 	mov.w	r3, #0
 80153bc:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40

	/* special case, output sample 0 */
	coef = coefBase;
 80153c0:	687b      	ldr	r3, [r7, #4]
 80153c2:	653b      	str	r3, [r7, #80]	; 0x50
	vb1 = vbuf;
 80153c4:	68bb      	ldr	r3, [r7, #8]
 80153c6:	64fb      	str	r3, [r7, #76]	; 0x4c
	sum1L = sum1R = rndVal;
 80153c8:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 80153cc:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 80153d0:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 80153d4:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

	MC0S(0)
 80153d8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80153da:	681b      	ldr	r3, [r3, #0]
 80153dc:	62fb      	str	r3, [r7, #44]	; 0x2c
 80153de:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80153e0:	f103 0304 	add.w	r3, r3, #4
 80153e4:	653b      	str	r3, [r7, #80]	; 0x50
 80153e6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80153e8:	681b      	ldr	r3, [r3, #0]
 80153ea:	62bb      	str	r3, [r7, #40]	; 0x28
 80153ec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80153ee:	f103 0304 	add.w	r3, r3, #4
 80153f2:	653b      	str	r3, [r7, #80]	; 0x50
 80153f4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80153f6:	681b      	ldr	r3, [r3, #0]
 80153f8:	627b      	str	r3, [r7, #36]	; 0x24
 80153fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80153fc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80153fe:	623b      	str	r3, [r7, #32]
 8015400:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015404:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015406:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015408:	f7ff faee 	bl	80149e8 <MADD64>
 801540c:	4602      	mov	r2, r0
 801540e:	460b      	mov	r3, r1
 8015410:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015414:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015416:	f1c3 0300 	rsb	r3, r3, #0
 801541a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801541e:	6a3a      	ldr	r2, [r7, #32]
 8015420:	f7ff fae2 	bl	80149e8 <MADD64>
 8015424:	4602      	mov	r2, r0
 8015426:	460b      	mov	r3, r1
 8015428:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 801542c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801542e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8015432:	627b      	str	r3, [r7, #36]	; 0x24
 8015434:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015436:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 801543a:	623b      	str	r3, [r7, #32]
 801543c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015440:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015442:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015444:	f7ff fad0 	bl	80149e8 <MADD64>
 8015448:	4602      	mov	r2, r0
 801544a:	460b      	mov	r3, r1
 801544c:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015450:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015452:	f1c3 0300 	rsb	r3, r3, #0
 8015456:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801545a:	6a3a      	ldr	r2, [r7, #32]
 801545c:	f7ff fac4 	bl	80149e8 <MADD64>
 8015460:	4602      	mov	r2, r0
 8015462:	460b      	mov	r3, r1
 8015464:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC0S(1)
 8015468:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801546a:	681b      	ldr	r3, [r3, #0]
 801546c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801546e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015470:	f103 0304 	add.w	r3, r3, #4
 8015474:	653b      	str	r3, [r7, #80]	; 0x50
 8015476:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015478:	681b      	ldr	r3, [r3, #0]
 801547a:	62bb      	str	r3, [r7, #40]	; 0x28
 801547c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801547e:	f103 0304 	add.w	r3, r3, #4
 8015482:	653b      	str	r3, [r7, #80]	; 0x50
 8015484:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015486:	685b      	ldr	r3, [r3, #4]
 8015488:	627b      	str	r3, [r7, #36]	; 0x24
 801548a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801548c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801548e:	623b      	str	r3, [r7, #32]
 8015490:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015494:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015496:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015498:	f7ff faa6 	bl	80149e8 <MADD64>
 801549c:	4602      	mov	r2, r0
 801549e:	460b      	mov	r3, r1
 80154a0:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80154a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80154a6:	f1c3 0300 	rsb	r3, r3, #0
 80154aa:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80154ae:	6a3a      	ldr	r2, [r7, #32]
 80154b0:	f7ff fa9a 	bl	80149e8 <MADD64>
 80154b4:	4602      	mov	r2, r0
 80154b6:	460b      	mov	r3, r1
 80154b8:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80154bc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80154be:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80154c2:	627b      	str	r3, [r7, #36]	; 0x24
 80154c4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80154c6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 80154ca:	623b      	str	r3, [r7, #32]
 80154cc:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80154d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80154d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80154d4:	f7ff fa88 	bl	80149e8 <MADD64>
 80154d8:	4602      	mov	r2, r0
 80154da:	460b      	mov	r3, r1
 80154dc:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 80154e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80154e2:	f1c3 0300 	rsb	r3, r3, #0
 80154e6:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80154ea:	6a3a      	ldr	r2, [r7, #32]
 80154ec:	f7ff fa7c 	bl	80149e8 <MADD64>
 80154f0:	4602      	mov	r2, r0
 80154f2:	460b      	mov	r3, r1
 80154f4:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC0S(2)
 80154f8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80154fa:	681b      	ldr	r3, [r3, #0]
 80154fc:	62fb      	str	r3, [r7, #44]	; 0x2c
 80154fe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015500:	f103 0304 	add.w	r3, r3, #4
 8015504:	653b      	str	r3, [r7, #80]	; 0x50
 8015506:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015508:	681b      	ldr	r3, [r3, #0]
 801550a:	62bb      	str	r3, [r7, #40]	; 0x28
 801550c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801550e:	f103 0304 	add.w	r3, r3, #4
 8015512:	653b      	str	r3, [r7, #80]	; 0x50
 8015514:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015516:	689b      	ldr	r3, [r3, #8]
 8015518:	627b      	str	r3, [r7, #36]	; 0x24
 801551a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801551c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801551e:	623b      	str	r3, [r7, #32]
 8015520:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015524:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015526:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015528:	f7ff fa5e 	bl	80149e8 <MADD64>
 801552c:	4602      	mov	r2, r0
 801552e:	460b      	mov	r3, r1
 8015530:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015534:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015536:	f1c3 0300 	rsb	r3, r3, #0
 801553a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801553e:	6a3a      	ldr	r2, [r7, #32]
 8015540:	f7ff fa52 	bl	80149e8 <MADD64>
 8015544:	4602      	mov	r2, r0
 8015546:	460b      	mov	r3, r1
 8015548:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 801554c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801554e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8015552:	627b      	str	r3, [r7, #36]	; 0x24
 8015554:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015556:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801555a:	623b      	str	r3, [r7, #32]
 801555c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015560:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015562:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015564:	f7ff fa40 	bl	80149e8 <MADD64>
 8015568:	4602      	mov	r2, r0
 801556a:	460b      	mov	r3, r1
 801556c:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015570:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015572:	f1c3 0300 	rsb	r3, r3, #0
 8015576:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801557a:	6a3a      	ldr	r2, [r7, #32]
 801557c:	f7ff fa34 	bl	80149e8 <MADD64>
 8015580:	4602      	mov	r2, r0
 8015582:	460b      	mov	r3, r1
 8015584:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC0S(3)
 8015588:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801558a:	681b      	ldr	r3, [r3, #0]
 801558c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801558e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015590:	f103 0304 	add.w	r3, r3, #4
 8015594:	653b      	str	r3, [r7, #80]	; 0x50
 8015596:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015598:	681b      	ldr	r3, [r3, #0]
 801559a:	62bb      	str	r3, [r7, #40]	; 0x28
 801559c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801559e:	f103 0304 	add.w	r3, r3, #4
 80155a2:	653b      	str	r3, [r7, #80]	; 0x50
 80155a4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80155a6:	68db      	ldr	r3, [r3, #12]
 80155a8:	627b      	str	r3, [r7, #36]	; 0x24
 80155aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80155ac:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80155ae:	623b      	str	r3, [r7, #32]
 80155b0:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80155b4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80155b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155b8:	f7ff fa16 	bl	80149e8 <MADD64>
 80155bc:	4602      	mov	r2, r0
 80155be:	460b      	mov	r3, r1
 80155c0:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80155c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80155c6:	f1c3 0300 	rsb	r3, r3, #0
 80155ca:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80155ce:	6a3a      	ldr	r2, [r7, #32]
 80155d0:	f7ff fa0a 	bl	80149e8 <MADD64>
 80155d4:	4602      	mov	r2, r0
 80155d6:	460b      	mov	r3, r1
 80155d8:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80155dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80155de:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80155e2:	627b      	str	r3, [r7, #36]	; 0x24
 80155e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80155e6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 80155ea:	623b      	str	r3, [r7, #32]
 80155ec:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80155f0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80155f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155f4:	f7ff f9f8 	bl	80149e8 <MADD64>
 80155f8:	4602      	mov	r2, r0
 80155fa:	460b      	mov	r3, r1
 80155fc:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015600:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015602:	f1c3 0300 	rsb	r3, r3, #0
 8015606:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801560a:	6a3a      	ldr	r2, [r7, #32]
 801560c:	f7ff f9ec 	bl	80149e8 <MADD64>
 8015610:	4602      	mov	r2, r0
 8015612:	460b      	mov	r3, r1
 8015614:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC0S(4)
 8015618:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801561a:	681b      	ldr	r3, [r3, #0]
 801561c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801561e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015620:	f103 0304 	add.w	r3, r3, #4
 8015624:	653b      	str	r3, [r7, #80]	; 0x50
 8015626:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015628:	681b      	ldr	r3, [r3, #0]
 801562a:	62bb      	str	r3, [r7, #40]	; 0x28
 801562c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801562e:	f103 0304 	add.w	r3, r3, #4
 8015632:	653b      	str	r3, [r7, #80]	; 0x50
 8015634:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015636:	691b      	ldr	r3, [r3, #16]
 8015638:	627b      	str	r3, [r7, #36]	; 0x24
 801563a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801563c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801563e:	623b      	str	r3, [r7, #32]
 8015640:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015644:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015646:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015648:	f7ff f9ce 	bl	80149e8 <MADD64>
 801564c:	4602      	mov	r2, r0
 801564e:	460b      	mov	r3, r1
 8015650:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015654:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015656:	f1c3 0300 	rsb	r3, r3, #0
 801565a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801565e:	6a3a      	ldr	r2, [r7, #32]
 8015660:	f7ff f9c2 	bl	80149e8 <MADD64>
 8015664:	4602      	mov	r2, r0
 8015666:	460b      	mov	r3, r1
 8015668:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 801566c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801566e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8015672:	627b      	str	r3, [r7, #36]	; 0x24
 8015674:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015676:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 801567a:	623b      	str	r3, [r7, #32]
 801567c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015680:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015682:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015684:	f7ff f9b0 	bl	80149e8 <MADD64>
 8015688:	4602      	mov	r2, r0
 801568a:	460b      	mov	r3, r1
 801568c:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015690:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015692:	f1c3 0300 	rsb	r3, r3, #0
 8015696:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801569a:	6a3a      	ldr	r2, [r7, #32]
 801569c:	f7ff f9a4 	bl	80149e8 <MADD64>
 80156a0:	4602      	mov	r2, r0
 80156a2:	460b      	mov	r3, r1
 80156a4:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC0S(5)
 80156a8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80156aa:	681b      	ldr	r3, [r3, #0]
 80156ac:	62fb      	str	r3, [r7, #44]	; 0x2c
 80156ae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80156b0:	f103 0304 	add.w	r3, r3, #4
 80156b4:	653b      	str	r3, [r7, #80]	; 0x50
 80156b6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80156b8:	681b      	ldr	r3, [r3, #0]
 80156ba:	62bb      	str	r3, [r7, #40]	; 0x28
 80156bc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80156be:	f103 0304 	add.w	r3, r3, #4
 80156c2:	653b      	str	r3, [r7, #80]	; 0x50
 80156c4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80156c6:	695b      	ldr	r3, [r3, #20]
 80156c8:	627b      	str	r3, [r7, #36]	; 0x24
 80156ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80156cc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80156ce:	623b      	str	r3, [r7, #32]
 80156d0:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80156d4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80156d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80156d8:	f7ff f986 	bl	80149e8 <MADD64>
 80156dc:	4602      	mov	r2, r0
 80156de:	460b      	mov	r3, r1
 80156e0:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80156e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80156e6:	f1c3 0300 	rsb	r3, r3, #0
 80156ea:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80156ee:	6a3a      	ldr	r2, [r7, #32]
 80156f0:	f7ff f97a 	bl	80149e8 <MADD64>
 80156f4:	4602      	mov	r2, r0
 80156f6:	460b      	mov	r3, r1
 80156f8:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80156fc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80156fe:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8015702:	627b      	str	r3, [r7, #36]	; 0x24
 8015704:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015706:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 801570a:	623b      	str	r3, [r7, #32]
 801570c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015710:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015712:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015714:	f7ff f968 	bl	80149e8 <MADD64>
 8015718:	4602      	mov	r2, r0
 801571a:	460b      	mov	r3, r1
 801571c:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015720:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015722:	f1c3 0300 	rsb	r3, r3, #0
 8015726:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801572a:	6a3a      	ldr	r2, [r7, #32]
 801572c:	f7ff f95c 	bl	80149e8 <MADD64>
 8015730:	4602      	mov	r2, r0
 8015732:	460b      	mov	r3, r1
 8015734:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC0S(6)
 8015738:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801573a:	681b      	ldr	r3, [r3, #0]
 801573c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801573e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015740:	f103 0304 	add.w	r3, r3, #4
 8015744:	653b      	str	r3, [r7, #80]	; 0x50
 8015746:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015748:	681b      	ldr	r3, [r3, #0]
 801574a:	62bb      	str	r3, [r7, #40]	; 0x28
 801574c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801574e:	f103 0304 	add.w	r3, r3, #4
 8015752:	653b      	str	r3, [r7, #80]	; 0x50
 8015754:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015756:	699b      	ldr	r3, [r3, #24]
 8015758:	627b      	str	r3, [r7, #36]	; 0x24
 801575a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801575c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801575e:	623b      	str	r3, [r7, #32]
 8015760:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015764:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015766:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015768:	f7ff f93e 	bl	80149e8 <MADD64>
 801576c:	4602      	mov	r2, r0
 801576e:	460b      	mov	r3, r1
 8015770:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015774:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015776:	f1c3 0300 	rsb	r3, r3, #0
 801577a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801577e:	6a3a      	ldr	r2, [r7, #32]
 8015780:	f7ff f932 	bl	80149e8 <MADD64>
 8015784:	4602      	mov	r2, r0
 8015786:	460b      	mov	r3, r1
 8015788:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 801578c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801578e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8015792:	627b      	str	r3, [r7, #36]	; 0x24
 8015794:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015796:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 801579a:	623b      	str	r3, [r7, #32]
 801579c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80157a0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80157a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80157a4:	f7ff f920 	bl	80149e8 <MADD64>
 80157a8:	4602      	mov	r2, r0
 80157aa:	460b      	mov	r3, r1
 80157ac:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 80157b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80157b2:	f1c3 0300 	rsb	r3, r3, #0
 80157b6:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80157ba:	6a3a      	ldr	r2, [r7, #32]
 80157bc:	f7ff f914 	bl	80149e8 <MADD64>
 80157c0:	4602      	mov	r2, r0
 80157c2:	460b      	mov	r3, r1
 80157c4:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC0S(7)
 80157c8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80157ca:	681b      	ldr	r3, [r3, #0]
 80157cc:	62fb      	str	r3, [r7, #44]	; 0x2c
 80157ce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80157d0:	f103 0304 	add.w	r3, r3, #4
 80157d4:	653b      	str	r3, [r7, #80]	; 0x50
 80157d6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80157d8:	681b      	ldr	r3, [r3, #0]
 80157da:	62bb      	str	r3, [r7, #40]	; 0x28
 80157dc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80157de:	f103 0304 	add.w	r3, r3, #4
 80157e2:	653b      	str	r3, [r7, #80]	; 0x50
 80157e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80157e6:	69db      	ldr	r3, [r3, #28]
 80157e8:	627b      	str	r3, [r7, #36]	; 0x24
 80157ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80157ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80157ee:	623b      	str	r3, [r7, #32]
 80157f0:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80157f4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80157f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80157f8:	f7ff f8f6 	bl	80149e8 <MADD64>
 80157fc:	4602      	mov	r2, r0
 80157fe:	460b      	mov	r3, r1
 8015800:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015804:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015806:	f1c3 0300 	rsb	r3, r3, #0
 801580a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801580e:	6a3a      	ldr	r2, [r7, #32]
 8015810:	f7ff f8ea 	bl	80149e8 <MADD64>
 8015814:	4602      	mov	r2, r0
 8015816:	460b      	mov	r3, r1
 8015818:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 801581c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801581e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8015822:	627b      	str	r3, [r7, #36]	; 0x24
 8015824:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015826:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 801582a:	623b      	str	r3, [r7, #32]
 801582c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015830:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015832:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015834:	f7ff f8d8 	bl	80149e8 <MADD64>
 8015838:	4602      	mov	r2, r0
 801583a:	460b      	mov	r3, r1
 801583c:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015840:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015842:	f1c3 0300 	rsb	r3, r3, #0
 8015846:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801584a:	6a3a      	ldr	r2, [r7, #32]
 801584c:	f7ff f8cc 	bl	80149e8 <MADD64>
 8015850:	4602      	mov	r2, r0
 8015852:	460b      	mov	r3, r1
 8015854:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38

	*(pcm + 0) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 8015858:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801585c:	f04f 0214 	mov.w	r2, #20
 8015860:	f7ff f8de 	bl	8014a20 <SAR64>
 8015864:	4602      	mov	r2, r0
 8015866:	460b      	mov	r3, r1
 8015868:	4613      	mov	r3, r2
 801586a:	4618      	mov	r0, r3
 801586c:	f04f 0106 	mov.w	r1, #6
 8015870:	f7ff f8fe 	bl	8014a70 <ClipToShort>
 8015874:	4603      	mov	r3, r0
 8015876:	461a      	mov	r2, r3
 8015878:	68fb      	ldr	r3, [r7, #12]
 801587a:	801a      	strh	r2, [r3, #0]
	*(pcm + 1) = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
 801587c:	68fb      	ldr	r3, [r7, #12]
 801587e:	f103 0402 	add.w	r4, r3, #2
 8015882:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015886:	f04f 0214 	mov.w	r2, #20
 801588a:	f7ff f8c9 	bl	8014a20 <SAR64>
 801588e:	4602      	mov	r2, r0
 8015890:	460b      	mov	r3, r1
 8015892:	4613      	mov	r3, r2
 8015894:	4618      	mov	r0, r3
 8015896:	f04f 0106 	mov.w	r1, #6
 801589a:	f7ff f8e9 	bl	8014a70 <ClipToShort>
 801589e:	4603      	mov	r3, r0
 80158a0:	8023      	strh	r3, [r4, #0]

	/* special case, output sample 16 */
	coef = coefBase + 256;
 80158a2:	687b      	ldr	r3, [r7, #4]
 80158a4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80158a8:	653b      	str	r3, [r7, #80]	; 0x50
	vb1 = vbuf + 64*16;
 80158aa:	68bb      	ldr	r3, [r7, #8]
 80158ac:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80158b0:	64fb      	str	r3, [r7, #76]	; 0x4c
	sum1L = sum1R = rndVal;
 80158b2:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 80158b6:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 80158ba:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 80158be:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

	MC1S(0)
 80158c2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80158c4:	681b      	ldr	r3, [r3, #0]
 80158c6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80158c8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80158ca:	f103 0304 	add.w	r3, r3, #4
 80158ce:	653b      	str	r3, [r7, #80]	; 0x50
 80158d0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80158d2:	681b      	ldr	r3, [r3, #0]
 80158d4:	627b      	str	r3, [r7, #36]	; 0x24
 80158d6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80158da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80158dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80158de:	f7ff f883 	bl	80149e8 <MADD64>
 80158e2:	4602      	mov	r2, r0
 80158e4:	460b      	mov	r3, r1
 80158e6:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80158ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80158ec:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80158f0:	627b      	str	r3, [r7, #36]	; 0x24
 80158f2:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80158f6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80158f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80158fa:	f7ff f875 	bl	80149e8 <MADD64>
 80158fe:	4602      	mov	r2, r0
 8015900:	460b      	mov	r3, r1
 8015902:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC1S(1)
 8015906:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015908:	681b      	ldr	r3, [r3, #0]
 801590a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801590c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801590e:	f103 0304 	add.w	r3, r3, #4
 8015912:	653b      	str	r3, [r7, #80]	; 0x50
 8015914:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015916:	685b      	ldr	r3, [r3, #4]
 8015918:	627b      	str	r3, [r7, #36]	; 0x24
 801591a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801591e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015920:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015922:	f7ff f861 	bl	80149e8 <MADD64>
 8015926:	4602      	mov	r2, r0
 8015928:	460b      	mov	r3, r1
 801592a:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 801592e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015930:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8015934:	627b      	str	r3, [r7, #36]	; 0x24
 8015936:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801593a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801593c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801593e:	f7ff f853 	bl	80149e8 <MADD64>
 8015942:	4602      	mov	r2, r0
 8015944:	460b      	mov	r3, r1
 8015946:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC1S(2)
 801594a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801594c:	681b      	ldr	r3, [r3, #0]
 801594e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015950:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015952:	f103 0304 	add.w	r3, r3, #4
 8015956:	653b      	str	r3, [r7, #80]	; 0x50
 8015958:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801595a:	689b      	ldr	r3, [r3, #8]
 801595c:	627b      	str	r3, [r7, #36]	; 0x24
 801595e:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015962:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015964:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015966:	f7ff f83f 	bl	80149e8 <MADD64>
 801596a:	4602      	mov	r2, r0
 801596c:	460b      	mov	r3, r1
 801596e:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015972:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015974:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8015978:	627b      	str	r3, [r7, #36]	; 0x24
 801597a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801597e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015980:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015982:	f7ff f831 	bl	80149e8 <MADD64>
 8015986:	4602      	mov	r2, r0
 8015988:	460b      	mov	r3, r1
 801598a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC1S(3)
 801598e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015990:	681b      	ldr	r3, [r3, #0]
 8015992:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015994:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015996:	f103 0304 	add.w	r3, r3, #4
 801599a:	653b      	str	r3, [r7, #80]	; 0x50
 801599c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801599e:	68db      	ldr	r3, [r3, #12]
 80159a0:	627b      	str	r3, [r7, #36]	; 0x24
 80159a2:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80159a6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80159a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80159aa:	f7ff f81d 	bl	80149e8 <MADD64>
 80159ae:	4602      	mov	r2, r0
 80159b0:	460b      	mov	r3, r1
 80159b2:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80159b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80159b8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80159bc:	627b      	str	r3, [r7, #36]	; 0x24
 80159be:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80159c2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80159c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80159c6:	f7ff f80f 	bl	80149e8 <MADD64>
 80159ca:	4602      	mov	r2, r0
 80159cc:	460b      	mov	r3, r1
 80159ce:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC1S(4)
 80159d2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80159d4:	681b      	ldr	r3, [r3, #0]
 80159d6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80159d8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80159da:	f103 0304 	add.w	r3, r3, #4
 80159de:	653b      	str	r3, [r7, #80]	; 0x50
 80159e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80159e2:	691b      	ldr	r3, [r3, #16]
 80159e4:	627b      	str	r3, [r7, #36]	; 0x24
 80159e6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80159ea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80159ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80159ee:	f7fe fffb 	bl	80149e8 <MADD64>
 80159f2:	4602      	mov	r2, r0
 80159f4:	460b      	mov	r3, r1
 80159f6:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80159fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80159fc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8015a00:	627b      	str	r3, [r7, #36]	; 0x24
 8015a02:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015a06:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015a08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015a0a:	f7fe ffed 	bl	80149e8 <MADD64>
 8015a0e:	4602      	mov	r2, r0
 8015a10:	460b      	mov	r3, r1
 8015a12:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC1S(5)
 8015a16:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015a18:	681b      	ldr	r3, [r3, #0]
 8015a1a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015a1c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015a1e:	f103 0304 	add.w	r3, r3, #4
 8015a22:	653b      	str	r3, [r7, #80]	; 0x50
 8015a24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a26:	695b      	ldr	r3, [r3, #20]
 8015a28:	627b      	str	r3, [r7, #36]	; 0x24
 8015a2a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015a2e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015a30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015a32:	f7fe ffd9 	bl	80149e8 <MADD64>
 8015a36:	4602      	mov	r2, r0
 8015a38:	460b      	mov	r3, r1
 8015a3a:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015a3e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a40:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8015a44:	627b      	str	r3, [r7, #36]	; 0x24
 8015a46:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015a4a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015a4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015a4e:	f7fe ffcb 	bl	80149e8 <MADD64>
 8015a52:	4602      	mov	r2, r0
 8015a54:	460b      	mov	r3, r1
 8015a56:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC1S(6)
 8015a5a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015a5c:	681b      	ldr	r3, [r3, #0]
 8015a5e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015a60:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015a62:	f103 0304 	add.w	r3, r3, #4
 8015a66:	653b      	str	r3, [r7, #80]	; 0x50
 8015a68:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a6a:	699b      	ldr	r3, [r3, #24]
 8015a6c:	627b      	str	r3, [r7, #36]	; 0x24
 8015a6e:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015a72:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015a74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015a76:	f7fe ffb7 	bl	80149e8 <MADD64>
 8015a7a:	4602      	mov	r2, r0
 8015a7c:	460b      	mov	r3, r1
 8015a7e:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015a82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a84:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8015a88:	627b      	str	r3, [r7, #36]	; 0x24
 8015a8a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015a8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015a90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015a92:	f7fe ffa9 	bl	80149e8 <MADD64>
 8015a96:	4602      	mov	r2, r0
 8015a98:	460b      	mov	r3, r1
 8015a9a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	MC1S(7)
 8015a9e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015aa0:	681b      	ldr	r3, [r3, #0]
 8015aa2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015aa4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015aa6:	f103 0304 	add.w	r3, r3, #4
 8015aaa:	653b      	str	r3, [r7, #80]	; 0x50
 8015aac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015aae:	69db      	ldr	r3, [r3, #28]
 8015ab0:	627b      	str	r3, [r7, #36]	; 0x24
 8015ab2:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015ab6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015ab8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015aba:	f7fe ff95 	bl	80149e8 <MADD64>
 8015abe:	4602      	mov	r2, r0
 8015ac0:	460b      	mov	r3, r1
 8015ac2:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015ac6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015ac8:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8015acc:	627b      	str	r3, [r7, #36]	; 0x24
 8015ace:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015ad2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015ad4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015ad6:	f7fe ff87 	bl	80149e8 <MADD64>
 8015ada:	4602      	mov	r2, r0
 8015adc:	460b      	mov	r3, r1
 8015ade:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38

	*(pcm + 2*16 + 0) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 8015ae2:	68fb      	ldr	r3, [r7, #12]
 8015ae4:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8015ae8:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015aec:	f04f 0214 	mov.w	r2, #20
 8015af0:	f7fe ff96 	bl	8014a20 <SAR64>
 8015af4:	4602      	mov	r2, r0
 8015af6:	460b      	mov	r3, r1
 8015af8:	4613      	mov	r3, r2
 8015afa:	4618      	mov	r0, r3
 8015afc:	f04f 0106 	mov.w	r1, #6
 8015b00:	f7fe ffb6 	bl	8014a70 <ClipToShort>
 8015b04:	4603      	mov	r3, r0
 8015b06:	8023      	strh	r3, [r4, #0]
	*(pcm + 2*16 + 1) = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
 8015b08:	68fb      	ldr	r3, [r7, #12]
 8015b0a:	f103 0442 	add.w	r4, r3, #66	; 0x42
 8015b0e:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015b12:	f04f 0214 	mov.w	r2, #20
 8015b16:	f7fe ff83 	bl	8014a20 <SAR64>
 8015b1a:	4602      	mov	r2, r0
 8015b1c:	460b      	mov	r3, r1
 8015b1e:	4613      	mov	r3, r2
 8015b20:	4618      	mov	r0, r3
 8015b22:	f04f 0106 	mov.w	r1, #6
 8015b26:	f7fe ffa3 	bl	8014a70 <ClipToShort>
 8015b2a:	4603      	mov	r3, r0
 8015b2c:	8023      	strh	r3, [r4, #0]

	/* main convolution loop: sum1L = samples 1, 2, 3, ... 15   sum2L = samples 31, 30, ... 17 */
	coef = coefBase + 16;
 8015b2e:	687b      	ldr	r3, [r7, #4]
 8015b30:	f103 0340 	add.w	r3, r3, #64	; 0x40
 8015b34:	653b      	str	r3, [r7, #80]	; 0x50
	vb1 = vbuf + 64;
 8015b36:	68bb      	ldr	r3, [r7, #8]
 8015b38:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8015b3c:	64fb      	str	r3, [r7, #76]	; 0x4c
	pcm += 2;
 8015b3e:	68fb      	ldr	r3, [r7, #12]
 8015b40:	f103 0304 	add.w	r3, r3, #4
 8015b44:	60fb      	str	r3, [r7, #12]

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 8015b46:	f04f 030f 	mov.w	r3, #15
 8015b4a:	657b      	str	r3, [r7, #84]	; 0x54
 8015b4c:	e3ec      	b.n	8016328 <xmp3_PolyphaseStereo+0xf80>
		sum1L = sum2L = rndVal;
 8015b4e:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 8015b52:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015b56:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8015b5a:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
		sum1R = sum2R = rndVal;
 8015b5e:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 8015b62:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8015b66:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8015b6a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38

		MC2S(0)
 8015b6e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015b70:	681b      	ldr	r3, [r3, #0]
 8015b72:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015b74:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015b76:	f103 0304 	add.w	r3, r3, #4
 8015b7a:	653b      	str	r3, [r7, #80]	; 0x50
 8015b7c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015b7e:	681b      	ldr	r3, [r3, #0]
 8015b80:	62bb      	str	r3, [r7, #40]	; 0x28
 8015b82:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015b84:	f103 0304 	add.w	r3, r3, #4
 8015b88:	653b      	str	r3, [r7, #80]	; 0x50
 8015b8a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015b8c:	681b      	ldr	r3, [r3, #0]
 8015b8e:	627b      	str	r3, [r7, #36]	; 0x24
 8015b90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015b92:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8015b94:	623b      	str	r3, [r7, #32]
 8015b96:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015b9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015b9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015b9e:	f7fe ff23 	bl	80149e8 <MADD64>
 8015ba2:	4602      	mov	r2, r0
 8015ba4:	460b      	mov	r3, r1
 8015ba6:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015baa:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015bae:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015bb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015bb2:	f7fe ff19 	bl	80149e8 <MADD64>
 8015bb6:	4602      	mov	r2, r0
 8015bb8:	460b      	mov	r3, r1
 8015bba:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015bbe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015bc0:	f1c3 0300 	rsb	r3, r3, #0
 8015bc4:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015bc8:	6a3a      	ldr	r2, [r7, #32]
 8015bca:	f7fe ff0d 	bl	80149e8 <MADD64>
 8015bce:	4602      	mov	r2, r0
 8015bd0:	460b      	mov	r3, r1
 8015bd2:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015bd6:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015bda:	6a3a      	ldr	r2, [r7, #32]
 8015bdc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015bde:	f7fe ff03 	bl	80149e8 <MADD64>
 8015be2:	4602      	mov	r2, r0
 8015be4:	460b      	mov	r3, r1
 8015be6:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015bea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015bec:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8015bf0:	627b      	str	r3, [r7, #36]	; 0x24
 8015bf2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015bf4:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 8015bf8:	623b      	str	r3, [r7, #32]
 8015bfa:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015bfe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015c00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015c02:	f7fe fef1 	bl	80149e8 <MADD64>
 8015c06:	4602      	mov	r2, r0
 8015c08:	460b      	mov	r3, r1
 8015c0a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015c0e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015c12:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015c14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015c16:	f7fe fee7 	bl	80149e8 <MADD64>
 8015c1a:	4602      	mov	r2, r0
 8015c1c:	460b      	mov	r3, r1
 8015c1e:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8015c22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015c24:	f1c3 0300 	rsb	r3, r3, #0
 8015c28:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015c2c:	6a3a      	ldr	r2, [r7, #32]
 8015c2e:	f7fe fedb 	bl	80149e8 <MADD64>
 8015c32:	4602      	mov	r2, r0
 8015c34:	460b      	mov	r3, r1
 8015c36:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015c3a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015c3e:	6a3a      	ldr	r2, [r7, #32]
 8015c40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015c42:	f7fe fed1 	bl	80149e8 <MADD64>
 8015c46:	4602      	mov	r2, r0
 8015c48:	460b      	mov	r3, r1
 8015c4a:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2S(1)
 8015c4e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015c50:	681b      	ldr	r3, [r3, #0]
 8015c52:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015c54:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015c56:	f103 0304 	add.w	r3, r3, #4
 8015c5a:	653b      	str	r3, [r7, #80]	; 0x50
 8015c5c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015c5e:	681b      	ldr	r3, [r3, #0]
 8015c60:	62bb      	str	r3, [r7, #40]	; 0x28
 8015c62:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015c64:	f103 0304 	add.w	r3, r3, #4
 8015c68:	653b      	str	r3, [r7, #80]	; 0x50
 8015c6a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015c6c:	685b      	ldr	r3, [r3, #4]
 8015c6e:	627b      	str	r3, [r7, #36]	; 0x24
 8015c70:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015c72:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8015c74:	623b      	str	r3, [r7, #32]
 8015c76:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015c7a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015c7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015c7e:	f7fe feb3 	bl	80149e8 <MADD64>
 8015c82:	4602      	mov	r2, r0
 8015c84:	460b      	mov	r3, r1
 8015c86:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015c8a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015c8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015c90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015c92:	f7fe fea9 	bl	80149e8 <MADD64>
 8015c96:	4602      	mov	r2, r0
 8015c98:	460b      	mov	r3, r1
 8015c9a:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015c9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015ca0:	f1c3 0300 	rsb	r3, r3, #0
 8015ca4:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015ca8:	6a3a      	ldr	r2, [r7, #32]
 8015caa:	f7fe fe9d 	bl	80149e8 <MADD64>
 8015cae:	4602      	mov	r2, r0
 8015cb0:	460b      	mov	r3, r1
 8015cb2:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015cb6:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015cba:	6a3a      	ldr	r2, [r7, #32]
 8015cbc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015cbe:	f7fe fe93 	bl	80149e8 <MADD64>
 8015cc2:	4602      	mov	r2, r0
 8015cc4:	460b      	mov	r3, r1
 8015cc6:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015cca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015ccc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8015cd0:	627b      	str	r3, [r7, #36]	; 0x24
 8015cd2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015cd4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015cd8:	623b      	str	r3, [r7, #32]
 8015cda:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015cde:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015ce0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015ce2:	f7fe fe81 	bl	80149e8 <MADD64>
 8015ce6:	4602      	mov	r2, r0
 8015ce8:	460b      	mov	r3, r1
 8015cea:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015cee:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015cf2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015cf4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015cf6:	f7fe fe77 	bl	80149e8 <MADD64>
 8015cfa:	4602      	mov	r2, r0
 8015cfc:	460b      	mov	r3, r1
 8015cfe:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8015d02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d04:	f1c3 0300 	rsb	r3, r3, #0
 8015d08:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015d0c:	6a3a      	ldr	r2, [r7, #32]
 8015d0e:	f7fe fe6b 	bl	80149e8 <MADD64>
 8015d12:	4602      	mov	r2, r0
 8015d14:	460b      	mov	r3, r1
 8015d16:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015d1a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015d1e:	6a3a      	ldr	r2, [r7, #32]
 8015d20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015d22:	f7fe fe61 	bl	80149e8 <MADD64>
 8015d26:	4602      	mov	r2, r0
 8015d28:	460b      	mov	r3, r1
 8015d2a:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2S(2)
 8015d2e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015d30:	681b      	ldr	r3, [r3, #0]
 8015d32:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015d34:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015d36:	f103 0304 	add.w	r3, r3, #4
 8015d3a:	653b      	str	r3, [r7, #80]	; 0x50
 8015d3c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015d3e:	681b      	ldr	r3, [r3, #0]
 8015d40:	62bb      	str	r3, [r7, #40]	; 0x28
 8015d42:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015d44:	f103 0304 	add.w	r3, r3, #4
 8015d48:	653b      	str	r3, [r7, #80]	; 0x50
 8015d4a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015d4c:	689b      	ldr	r3, [r3, #8]
 8015d4e:	627b      	str	r3, [r7, #36]	; 0x24
 8015d50:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015d52:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015d54:	623b      	str	r3, [r7, #32]
 8015d56:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015d5a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015d5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015d5e:	f7fe fe43 	bl	80149e8 <MADD64>
 8015d62:	4602      	mov	r2, r0
 8015d64:	460b      	mov	r3, r1
 8015d66:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015d6a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015d6e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015d70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d72:	f7fe fe39 	bl	80149e8 <MADD64>
 8015d76:	4602      	mov	r2, r0
 8015d78:	460b      	mov	r3, r1
 8015d7a:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015d7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d80:	f1c3 0300 	rsb	r3, r3, #0
 8015d84:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015d88:	6a3a      	ldr	r2, [r7, #32]
 8015d8a:	f7fe fe2d 	bl	80149e8 <MADD64>
 8015d8e:	4602      	mov	r2, r0
 8015d90:	460b      	mov	r3, r1
 8015d92:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015d96:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015d9a:	6a3a      	ldr	r2, [r7, #32]
 8015d9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015d9e:	f7fe fe23 	bl	80149e8 <MADD64>
 8015da2:	4602      	mov	r2, r0
 8015da4:	460b      	mov	r3, r1
 8015da6:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015daa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015dac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8015db0:	627b      	str	r3, [r7, #36]	; 0x24
 8015db2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015db4:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8015db8:	623b      	str	r3, [r7, #32]
 8015dba:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015dbe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015dc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015dc2:	f7fe fe11 	bl	80149e8 <MADD64>
 8015dc6:	4602      	mov	r2, r0
 8015dc8:	460b      	mov	r3, r1
 8015dca:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015dce:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015dd2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015dd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015dd6:	f7fe fe07 	bl	80149e8 <MADD64>
 8015dda:	4602      	mov	r2, r0
 8015ddc:	460b      	mov	r3, r1
 8015dde:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8015de2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015de4:	f1c3 0300 	rsb	r3, r3, #0
 8015de8:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015dec:	6a3a      	ldr	r2, [r7, #32]
 8015dee:	f7fe fdfb 	bl	80149e8 <MADD64>
 8015df2:	4602      	mov	r2, r0
 8015df4:	460b      	mov	r3, r1
 8015df6:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015dfa:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015dfe:	6a3a      	ldr	r2, [r7, #32]
 8015e00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015e02:	f7fe fdf1 	bl	80149e8 <MADD64>
 8015e06:	4602      	mov	r2, r0
 8015e08:	460b      	mov	r3, r1
 8015e0a:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2S(3)
 8015e0e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015e10:	681b      	ldr	r3, [r3, #0]
 8015e12:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015e14:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015e16:	f103 0304 	add.w	r3, r3, #4
 8015e1a:	653b      	str	r3, [r7, #80]	; 0x50
 8015e1c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015e1e:	681b      	ldr	r3, [r3, #0]
 8015e20:	62bb      	str	r3, [r7, #40]	; 0x28
 8015e22:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015e24:	f103 0304 	add.w	r3, r3, #4
 8015e28:	653b      	str	r3, [r7, #80]	; 0x50
 8015e2a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015e2c:	68db      	ldr	r3, [r3, #12]
 8015e2e:	627b      	str	r3, [r7, #36]	; 0x24
 8015e30:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015e32:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8015e34:	623b      	str	r3, [r7, #32]
 8015e36:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015e3a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015e3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015e3e:	f7fe fdd3 	bl	80149e8 <MADD64>
 8015e42:	4602      	mov	r2, r0
 8015e44:	460b      	mov	r3, r1
 8015e46:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015e4a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015e4e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015e50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015e52:	f7fe fdc9 	bl	80149e8 <MADD64>
 8015e56:	4602      	mov	r2, r0
 8015e58:	460b      	mov	r3, r1
 8015e5a:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015e5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015e60:	f1c3 0300 	rsb	r3, r3, #0
 8015e64:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015e68:	6a3a      	ldr	r2, [r7, #32]
 8015e6a:	f7fe fdbd 	bl	80149e8 <MADD64>
 8015e6e:	4602      	mov	r2, r0
 8015e70:	460b      	mov	r3, r1
 8015e72:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015e76:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015e7a:	6a3a      	ldr	r2, [r7, #32]
 8015e7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015e7e:	f7fe fdb3 	bl	80149e8 <MADD64>
 8015e82:	4602      	mov	r2, r0
 8015e84:	460b      	mov	r3, r1
 8015e86:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015e8a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015e8c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8015e90:	627b      	str	r3, [r7, #36]	; 0x24
 8015e92:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015e94:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 8015e98:	623b      	str	r3, [r7, #32]
 8015e9a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015e9e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015ea0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015ea2:	f7fe fda1 	bl	80149e8 <MADD64>
 8015ea6:	4602      	mov	r2, r0
 8015ea8:	460b      	mov	r3, r1
 8015eaa:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015eae:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015eb2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015eb4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015eb6:	f7fe fd97 	bl	80149e8 <MADD64>
 8015eba:	4602      	mov	r2, r0
 8015ebc:	460b      	mov	r3, r1
 8015ebe:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8015ec2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015ec4:	f1c3 0300 	rsb	r3, r3, #0
 8015ec8:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015ecc:	6a3a      	ldr	r2, [r7, #32]
 8015ece:	f7fe fd8b 	bl	80149e8 <MADD64>
 8015ed2:	4602      	mov	r2, r0
 8015ed4:	460b      	mov	r3, r1
 8015ed6:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015eda:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015ede:	6a3a      	ldr	r2, [r7, #32]
 8015ee0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015ee2:	f7fe fd81 	bl	80149e8 <MADD64>
 8015ee6:	4602      	mov	r2, r0
 8015ee8:	460b      	mov	r3, r1
 8015eea:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2S(4)
 8015eee:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015ef0:	681b      	ldr	r3, [r3, #0]
 8015ef2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015ef4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015ef6:	f103 0304 	add.w	r3, r3, #4
 8015efa:	653b      	str	r3, [r7, #80]	; 0x50
 8015efc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015efe:	681b      	ldr	r3, [r3, #0]
 8015f00:	62bb      	str	r3, [r7, #40]	; 0x28
 8015f02:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015f04:	f103 0304 	add.w	r3, r3, #4
 8015f08:	653b      	str	r3, [r7, #80]	; 0x50
 8015f0a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015f0c:	691b      	ldr	r3, [r3, #16]
 8015f0e:	627b      	str	r3, [r7, #36]	; 0x24
 8015f10:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015f12:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8015f14:	623b      	str	r3, [r7, #32]
 8015f16:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015f1a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015f1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015f1e:	f7fe fd63 	bl	80149e8 <MADD64>
 8015f22:	4602      	mov	r2, r0
 8015f24:	460b      	mov	r3, r1
 8015f26:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015f2a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015f2e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015f30:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015f32:	f7fe fd59 	bl	80149e8 <MADD64>
 8015f36:	4602      	mov	r2, r0
 8015f38:	460b      	mov	r3, r1
 8015f3a:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015f3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015f40:	f1c3 0300 	rsb	r3, r3, #0
 8015f44:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015f48:	6a3a      	ldr	r2, [r7, #32]
 8015f4a:	f7fe fd4d 	bl	80149e8 <MADD64>
 8015f4e:	4602      	mov	r2, r0
 8015f50:	460b      	mov	r3, r1
 8015f52:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8015f56:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8015f5a:	6a3a      	ldr	r2, [r7, #32]
 8015f5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015f5e:	f7fe fd43 	bl	80149e8 <MADD64>
 8015f62:	4602      	mov	r2, r0
 8015f64:	460b      	mov	r3, r1
 8015f66:	e9c7 2306 	strd	r2, r3, [r7, #24]
 8015f6a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015f6c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8015f70:	627b      	str	r3, [r7, #36]	; 0x24
 8015f72:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015f74:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8015f78:	623b      	str	r3, [r7, #32]
 8015f7a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015f7e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015f80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015f82:	f7fe fd31 	bl	80149e8 <MADD64>
 8015f86:	4602      	mov	r2, r0
 8015f88:	460b      	mov	r3, r1
 8015f8a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015f8e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015f92:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015f94:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015f96:	f7fe fd27 	bl	80149e8 <MADD64>
 8015f9a:	4602      	mov	r2, r0
 8015f9c:	460b      	mov	r3, r1
 8015f9e:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8015fa2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015fa4:	f1c3 0300 	rsb	r3, r3, #0
 8015fa8:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8015fac:	6a3a      	ldr	r2, [r7, #32]
 8015fae:	f7fe fd1b 	bl	80149e8 <MADD64>
 8015fb2:	4602      	mov	r2, r0
 8015fb4:	460b      	mov	r3, r1
 8015fb6:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 8015fba:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8015fbe:	6a3a      	ldr	r2, [r7, #32]
 8015fc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015fc2:	f7fe fd11 	bl	80149e8 <MADD64>
 8015fc6:	4602      	mov	r2, r0
 8015fc8:	460b      	mov	r3, r1
 8015fca:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2S(5)
 8015fce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015fd0:	681b      	ldr	r3, [r3, #0]
 8015fd2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015fd4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015fd6:	f103 0304 	add.w	r3, r3, #4
 8015fda:	653b      	str	r3, [r7, #80]	; 0x50
 8015fdc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015fde:	681b      	ldr	r3, [r3, #0]
 8015fe0:	62bb      	str	r3, [r7, #40]	; 0x28
 8015fe2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015fe4:	f103 0304 	add.w	r3, r3, #4
 8015fe8:	653b      	str	r3, [r7, #80]	; 0x50
 8015fea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015fec:	695b      	ldr	r3, [r3, #20]
 8015fee:	627b      	str	r3, [r7, #36]	; 0x24
 8015ff0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015ff2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015ff4:	623b      	str	r3, [r7, #32]
 8015ff6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8015ffa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015ffc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015ffe:	f7fe fcf3 	bl	80149e8 <MADD64>
 8016002:	4602      	mov	r2, r0
 8016004:	460b      	mov	r3, r1
 8016006:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 801600a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 801600e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016010:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016012:	f7fe fce9 	bl	80149e8 <MADD64>
 8016016:	4602      	mov	r2, r0
 8016018:	460b      	mov	r3, r1
 801601a:	e9c7 2306 	strd	r2, r3, [r7, #24]
 801601e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016020:	f1c3 0300 	rsb	r3, r3, #0
 8016024:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8016028:	6a3a      	ldr	r2, [r7, #32]
 801602a:	f7fe fcdd 	bl	80149e8 <MADD64>
 801602e:	4602      	mov	r2, r0
 8016030:	460b      	mov	r3, r1
 8016032:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8016036:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 801603a:	6a3a      	ldr	r2, [r7, #32]
 801603c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801603e:	f7fe fcd3 	bl	80149e8 <MADD64>
 8016042:	4602      	mov	r2, r0
 8016044:	460b      	mov	r3, r1
 8016046:	e9c7 2306 	strd	r2, r3, [r7, #24]
 801604a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801604c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8016050:	627b      	str	r3, [r7, #36]	; 0x24
 8016052:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016054:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 8016058:	623b      	str	r3, [r7, #32]
 801605a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801605e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016060:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016062:	f7fe fcc1 	bl	80149e8 <MADD64>
 8016066:	4602      	mov	r2, r0
 8016068:	460b      	mov	r3, r1
 801606a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 801606e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8016072:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016074:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016076:	f7fe fcb7 	bl	80149e8 <MADD64>
 801607a:	4602      	mov	r2, r0
 801607c:	460b      	mov	r3, r1
 801607e:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8016082:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016084:	f1c3 0300 	rsb	r3, r3, #0
 8016088:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801608c:	6a3a      	ldr	r2, [r7, #32]
 801608e:	f7fe fcab 	bl	80149e8 <MADD64>
 8016092:	4602      	mov	r2, r0
 8016094:	460b      	mov	r3, r1
 8016096:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 801609a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801609e:	6a3a      	ldr	r2, [r7, #32]
 80160a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80160a2:	f7fe fca1 	bl	80149e8 <MADD64>
 80160a6:	4602      	mov	r2, r0
 80160a8:	460b      	mov	r3, r1
 80160aa:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2S(6)
 80160ae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80160b0:	681b      	ldr	r3, [r3, #0]
 80160b2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80160b4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80160b6:	f103 0304 	add.w	r3, r3, #4
 80160ba:	653b      	str	r3, [r7, #80]	; 0x50
 80160bc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80160be:	681b      	ldr	r3, [r3, #0]
 80160c0:	62bb      	str	r3, [r7, #40]	; 0x28
 80160c2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80160c4:	f103 0304 	add.w	r3, r3, #4
 80160c8:	653b      	str	r3, [r7, #80]	; 0x50
 80160ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80160cc:	699b      	ldr	r3, [r3, #24]
 80160ce:	627b      	str	r3, [r7, #36]	; 0x24
 80160d0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80160d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80160d4:	623b      	str	r3, [r7, #32]
 80160d6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80160da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80160dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80160de:	f7fe fc83 	bl	80149e8 <MADD64>
 80160e2:	4602      	mov	r2, r0
 80160e4:	460b      	mov	r3, r1
 80160e6:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80160ea:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80160ee:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80160f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80160f2:	f7fe fc79 	bl	80149e8 <MADD64>
 80160f6:	4602      	mov	r2, r0
 80160f8:	460b      	mov	r3, r1
 80160fa:	e9c7 2306 	strd	r2, r3, [r7, #24]
 80160fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016100:	f1c3 0300 	rsb	r3, r3, #0
 8016104:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 8016108:	6a3a      	ldr	r2, [r7, #32]
 801610a:	f7fe fc6d 	bl	80149e8 <MADD64>
 801610e:	4602      	mov	r2, r0
 8016110:	460b      	mov	r3, r1
 8016112:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8016116:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 801611a:	6a3a      	ldr	r2, [r7, #32]
 801611c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801611e:	f7fe fc63 	bl	80149e8 <MADD64>
 8016122:	4602      	mov	r2, r0
 8016124:	460b      	mov	r3, r1
 8016126:	e9c7 2306 	strd	r2, r3, [r7, #24]
 801612a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801612c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8016130:	627b      	str	r3, [r7, #36]	; 0x24
 8016132:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016134:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8016138:	623b      	str	r3, [r7, #32]
 801613a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801613e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016140:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016142:	f7fe fc51 	bl	80149e8 <MADD64>
 8016146:	4602      	mov	r2, r0
 8016148:	460b      	mov	r3, r1
 801614a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 801614e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8016152:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016154:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016156:	f7fe fc47 	bl	80149e8 <MADD64>
 801615a:	4602      	mov	r2, r0
 801615c:	460b      	mov	r3, r1
 801615e:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8016162:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016164:	f1c3 0300 	rsb	r3, r3, #0
 8016168:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801616c:	6a3a      	ldr	r2, [r7, #32]
 801616e:	f7fe fc3b 	bl	80149e8 <MADD64>
 8016172:	4602      	mov	r2, r0
 8016174:	460b      	mov	r3, r1
 8016176:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 801617a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801617e:	6a3a      	ldr	r2, [r7, #32]
 8016180:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016182:	f7fe fc31 	bl	80149e8 <MADD64>
 8016186:	4602      	mov	r2, r0
 8016188:	460b      	mov	r3, r1
 801618a:	e9c7 2304 	strd	r2, r3, [r7, #16]
		MC2S(7)
 801618e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016190:	681b      	ldr	r3, [r3, #0]
 8016192:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016194:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016196:	f103 0304 	add.w	r3, r3, #4
 801619a:	653b      	str	r3, [r7, #80]	; 0x50
 801619c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801619e:	681b      	ldr	r3, [r3, #0]
 80161a0:	62bb      	str	r3, [r7, #40]	; 0x28
 80161a2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80161a4:	f103 0304 	add.w	r3, r3, #4
 80161a8:	653b      	str	r3, [r7, #80]	; 0x50
 80161aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80161ac:	69db      	ldr	r3, [r3, #28]
 80161ae:	627b      	str	r3, [r7, #36]	; 0x24
 80161b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80161b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80161b4:	623b      	str	r3, [r7, #32]
 80161b6:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80161ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80161bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80161be:	f7fe fc13 	bl	80149e8 <MADD64>
 80161c2:	4602      	mov	r2, r0
 80161c4:	460b      	mov	r3, r1
 80161c6:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80161ca:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80161ce:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80161d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80161d2:	f7fe fc09 	bl	80149e8 <MADD64>
 80161d6:	4602      	mov	r2, r0
 80161d8:	460b      	mov	r3, r1
 80161da:	e9c7 2306 	strd	r2, r3, [r7, #24]
 80161de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80161e0:	f1c3 0300 	rsb	r3, r3, #0
 80161e4:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80161e8:	6a3a      	ldr	r2, [r7, #32]
 80161ea:	f7fe fbfd 	bl	80149e8 <MADD64>
 80161ee:	4602      	mov	r2, r0
 80161f0:	460b      	mov	r3, r1
 80161f2:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80161f6:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80161fa:	6a3a      	ldr	r2, [r7, #32]
 80161fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80161fe:	f7fe fbf3 	bl	80149e8 <MADD64>
 8016202:	4602      	mov	r2, r0
 8016204:	460b      	mov	r3, r1
 8016206:	e9c7 2306 	strd	r2, r3, [r7, #24]
 801620a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801620c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8016210:	627b      	str	r3, [r7, #36]	; 0x24
 8016212:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016214:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8016218:	623b      	str	r3, [r7, #32]
 801621a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801621e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016220:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016222:	f7fe fbe1 	bl	80149e8 <MADD64>
 8016226:	4602      	mov	r2, r0
 8016228:	460b      	mov	r3, r1
 801622a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 801622e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8016232:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016234:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016236:	f7fe fbd7 	bl	80149e8 <MADD64>
 801623a:	4602      	mov	r2, r0
 801623c:	460b      	mov	r3, r1
 801623e:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8016242:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016244:	f1c3 0300 	rsb	r3, r3, #0
 8016248:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801624c:	6a3a      	ldr	r2, [r7, #32]
 801624e:	f7fe fbcb 	bl	80149e8 <MADD64>
 8016252:	4602      	mov	r2, r0
 8016254:	460b      	mov	r3, r1
 8016256:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 801625a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801625e:	6a3a      	ldr	r2, [r7, #32]
 8016260:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016262:	f7fe fbc1 	bl	80149e8 <MADD64>
 8016266:	4602      	mov	r2, r0
 8016268:	460b      	mov	r3, r1
 801626a:	e9c7 2304 	strd	r2, r3, [r7, #16]

		vb1 += 64;
 801626e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016270:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8016274:	64fb      	str	r3, [r7, #76]	; 0x4c
		*(pcm + 0)         = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
 8016276:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801627a:	f04f 0214 	mov.w	r2, #20
 801627e:	f7fe fbcf 	bl	8014a20 <SAR64>
 8016282:	4602      	mov	r2, r0
 8016284:	460b      	mov	r3, r1
 8016286:	4613      	mov	r3, r2
 8016288:	4618      	mov	r0, r3
 801628a:	f04f 0106 	mov.w	r1, #6
 801628e:	f7fe fbef 	bl	8014a70 <ClipToShort>
 8016292:	4603      	mov	r3, r0
 8016294:	461a      	mov	r2, r3
 8016296:	68fb      	ldr	r3, [r7, #12]
 8016298:	801a      	strh	r2, [r3, #0]
		*(pcm + 1)         = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
 801629a:	68fb      	ldr	r3, [r7, #12]
 801629c:	f103 0402 	add.w	r4, r3, #2
 80162a0:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 80162a4:	f04f 0214 	mov.w	r2, #20
 80162a8:	f7fe fbba 	bl	8014a20 <SAR64>
 80162ac:	4602      	mov	r2, r0
 80162ae:	460b      	mov	r3, r1
 80162b0:	4613      	mov	r3, r2
 80162b2:	4618      	mov	r0, r3
 80162b4:	f04f 0106 	mov.w	r1, #6
 80162b8:	f7fe fbda 	bl	8014a70 <ClipToShort>
 80162bc:	4603      	mov	r3, r0
 80162be:	8023      	strh	r3, [r4, #0]
		*(pcm + 2*2*i + 0) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
 80162c0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80162c2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80162c6:	68fa      	ldr	r2, [r7, #12]
 80162c8:	18d4      	adds	r4, r2, r3
 80162ca:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80162ce:	f04f 0214 	mov.w	r2, #20
 80162d2:	f7fe fba5 	bl	8014a20 <SAR64>
 80162d6:	4602      	mov	r2, r0
 80162d8:	460b      	mov	r3, r1
 80162da:	4613      	mov	r3, r2
 80162dc:	4618      	mov	r0, r3
 80162de:	f04f 0106 	mov.w	r1, #6
 80162e2:	f7fe fbc5 	bl	8014a70 <ClipToShort>
 80162e6:	4603      	mov	r3, r0
 80162e8:	8023      	strh	r3, [r4, #0]
		*(pcm + 2*2*i + 1) = ClipToShort((int)SAR64(sum2R, (32-CSHIFT)), DEF_NFRACBITS);
 80162ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80162ec:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80162f0:	f103 0302 	add.w	r3, r3, #2
 80162f4:	68fa      	ldr	r2, [r7, #12]
 80162f6:	18d4      	adds	r4, r2, r3
 80162f8:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80162fc:	f04f 0214 	mov.w	r2, #20
 8016300:	f7fe fb8e 	bl	8014a20 <SAR64>
 8016304:	4602      	mov	r2, r0
 8016306:	460b      	mov	r3, r1
 8016308:	4613      	mov	r3, r2
 801630a:	4618      	mov	r0, r3
 801630c:	f04f 0106 	mov.w	r1, #6
 8016310:	f7fe fbae 	bl	8014a70 <ClipToShort>
 8016314:	4603      	mov	r3, r0
 8016316:	8023      	strh	r3, [r4, #0]
		pcm += 2;
 8016318:	68fb      	ldr	r3, [r7, #12]
 801631a:	f103 0304 	add.w	r3, r3, #4
 801631e:	60fb      	str	r3, [r7, #12]
	coef = coefBase + 16;
	vb1 = vbuf + 64;
	pcm += 2;

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 8016320:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016322:	f103 33ff 	add.w	r3, r3, #4294967295
 8016326:	657b      	str	r3, [r7, #84]	; 0x54
 8016328:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801632a:	2b00      	cmp	r3, #0
 801632c:	f73f ac0f 	bgt.w	8015b4e <xmp3_PolyphaseStereo+0x7a6>
		*(pcm + 1)         = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*2*i + 0) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*2*i + 1) = ClipToShort((int)SAR64(sum2R, (32-CSHIFT)), DEF_NFRACBITS);
		pcm += 2;
	}
}
 8016330:	f107 075c 	add.w	r7, r7, #92	; 0x5c
 8016334:	46bd      	mov	sp, r7
 8016336:	bd90      	pop	{r4, r7, pc}

08016338 <UnpackSFMPEG1>:
 *                so that we index through consectutive memory locations when unpacking 
 *                (make sure dequantizer follows same convention)
 *              Illegal Intensity Position = 7 (always) for MPEG1 scale factors
 **************************************************************************************/
static void UnpackSFMPEG1(BitStreamInfo *bsi, SideInfoSub *sis, ScaleFactorInfoSub *sfis, int *scfsi, int gr, ScaleFactorInfoSub *sfisGr0)
{
 8016338:	b580      	push	{r7, lr}
 801633a:	b088      	sub	sp, #32
 801633c:	af00      	add	r7, sp, #0
 801633e:	60f8      	str	r0, [r7, #12]
 8016340:	60b9      	str	r1, [r7, #8]
 8016342:	607a      	str	r2, [r7, #4]
 8016344:	603b      	str	r3, [r7, #0]
	int sfb;
	int slen0, slen1;
	
	/* these can be 0, so make sure GetBits(bsi, 0) returns 0 (no >> 32 or anything) */
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 8016346:	68bb      	ldr	r3, [r7, #8]
 8016348:	68da      	ldr	r2, [r3, #12]
 801634a:	f24e 3314 	movw	r3, #58132	; 0xe314
 801634e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8016352:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
 8016356:	61bb      	str	r3, [r7, #24]
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 8016358:	68bb      	ldr	r3, [r7, #8]
 801635a:	68db      	ldr	r3, [r3, #12]
 801635c:	f24e 3214 	movw	r2, #58132	; 0xe314
 8016360:	f6c0 0202 	movt	r2, #2050	; 0x802
 8016364:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016368:	18d3      	adds	r3, r2, r3
 801636a:	785b      	ldrb	r3, [r3, #1]
 801636c:	617b      	str	r3, [r7, #20]
	
	if (sis->blockType == 2) {
 801636e:	68bb      	ldr	r3, [r7, #8]
 8016370:	695b      	ldr	r3, [r3, #20]
 8016372:	2b02      	cmp	r3, #2
 8016374:	f040 80a8 	bne.w	80164c8 <UnpackSFMPEG1+0x190>
		/* short block, type 2 (implies winSwitchFlag == 1) */
		if (sis->mixedBlock) {          
 8016378:	68bb      	ldr	r3, [r7, #8]
 801637a:	699b      	ldr	r3, [r3, #24]
 801637c:	2b00      	cmp	r3, #0
 801637e:	d018      	beq.n	80163b2 <UnpackSFMPEG1+0x7a>
			/* do long block portion */
			for (sfb = 0; sfb < 8; sfb++)
 8016380:	f04f 0300 	mov.w	r3, #0
 8016384:	61fb      	str	r3, [r7, #28]
 8016386:	e00d      	b.n	80163a4 <UnpackSFMPEG1+0x6c>
				sfis->l[sfb] =    (char)GetBits(bsi, slen0);
 8016388:	68f8      	ldr	r0, [r7, #12]
 801638a:	69b9      	ldr	r1, [r7, #24]
 801638c:	f7f9 fa30 	bl	800f7f0 <xmp3_GetBits>
 8016390:	4603      	mov	r3, r0
 8016392:	b2da      	uxtb	r2, r3
 8016394:	6879      	ldr	r1, [r7, #4]
 8016396:	69fb      	ldr	r3, [r7, #28]
 8016398:	18cb      	adds	r3, r1, r3
 801639a:	701a      	strb	r2, [r3, #0]
	
	if (sis->blockType == 2) {
		/* short block, type 2 (implies winSwitchFlag == 1) */
		if (sis->mixedBlock) {          
			/* do long block portion */
			for (sfb = 0; sfb < 8; sfb++)
 801639c:	69fb      	ldr	r3, [r7, #28]
 801639e:	f103 0301 	add.w	r3, r3, #1
 80163a2:	61fb      	str	r3, [r7, #28]
 80163a4:	69fb      	ldr	r3, [r7, #28]
 80163a6:	2b07      	cmp	r3, #7
 80163a8:	ddee      	ble.n	8016388 <UnpackSFMPEG1+0x50>
				sfis->l[sfb] =    (char)GetBits(bsi, slen0);
			sfb = 3;
 80163aa:	f04f 0303 	mov.w	r3, #3
 80163ae:	61fb      	str	r3, [r7, #28]
		} else {
			/* all short blocks */
			sfb = 0;
		}

		for (      ; sfb < 6; sfb++) {
 80163b0:	e03a      	b.n	8016428 <UnpackSFMPEG1+0xf0>
			for (sfb = 0; sfb < 8; sfb++)
				sfis->l[sfb] =    (char)GetBits(bsi, slen0);
			sfb = 3;
		} else {
			/* all short blocks */
			sfb = 0;
 80163b2:	f04f 0300 	mov.w	r3, #0
 80163b6:	61fb      	str	r3, [r7, #28]
		}

		for (      ; sfb < 6; sfb++) {
 80163b8:	e036      	b.n	8016428 <UnpackSFMPEG1+0xf0>
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 80163ba:	68f8      	ldr	r0, [r7, #12]
 80163bc:	69b9      	ldr	r1, [r7, #24]
 80163be:	f7f9 fa17 	bl	800f7f0 <xmp3_GetBits>
 80163c2:	4603      	mov	r3, r0
 80163c4:	b2d9      	uxtb	r1, r3
 80163c6:	6878      	ldr	r0, [r7, #4]
 80163c8:	69fa      	ldr	r2, [r7, #28]
 80163ca:	4613      	mov	r3, r2
 80163cc:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80163d0:	189b      	adds	r3, r3, r2
 80163d2:	18c3      	adds	r3, r0, r3
 80163d4:	f103 0317 	add.w	r3, r3, #23
 80163d8:	460a      	mov	r2, r1
 80163da:	701a      	strb	r2, [r3, #0]
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 80163dc:	68f8      	ldr	r0, [r7, #12]
 80163de:	69b9      	ldr	r1, [r7, #24]
 80163e0:	f7f9 fa06 	bl	800f7f0 <xmp3_GetBits>
 80163e4:	4603      	mov	r3, r0
 80163e6:	b2d9      	uxtb	r1, r3
 80163e8:	6878      	ldr	r0, [r7, #4]
 80163ea:	69fa      	ldr	r2, [r7, #28]
 80163ec:	4613      	mov	r3, r2
 80163ee:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80163f2:	189b      	adds	r3, r3, r2
 80163f4:	18c3      	adds	r3, r0, r3
 80163f6:	f103 0318 	add.w	r3, r3, #24
 80163fa:	460a      	mov	r2, r1
 80163fc:	701a      	strb	r2, [r3, #0]
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 80163fe:	68f8      	ldr	r0, [r7, #12]
 8016400:	69b9      	ldr	r1, [r7, #24]
 8016402:	f7f9 f9f5 	bl	800f7f0 <xmp3_GetBits>
 8016406:	4603      	mov	r3, r0
 8016408:	b2d9      	uxtb	r1, r3
 801640a:	6878      	ldr	r0, [r7, #4]
 801640c:	69fa      	ldr	r2, [r7, #28]
 801640e:	4613      	mov	r3, r2
 8016410:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016414:	189b      	adds	r3, r3, r2
 8016416:	18c3      	adds	r3, r0, r3
 8016418:	f103 0319 	add.w	r3, r3, #25
 801641c:	460a      	mov	r2, r1
 801641e:	701a      	strb	r2, [r3, #0]
		} else {
			/* all short blocks */
			sfb = 0;
		}

		for (      ; sfb < 6; sfb++) {
 8016420:	69fb      	ldr	r3, [r7, #28]
 8016422:	f103 0301 	add.w	r3, r3, #1
 8016426:	61fb      	str	r3, [r7, #28]
 8016428:	69fb      	ldr	r3, [r7, #28]
 801642a:	2b05      	cmp	r3, #5
 801642c:	ddc5      	ble.n	80163ba <UnpackSFMPEG1+0x82>
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
		}

		for (      ; sfb < 12; sfb++) {
 801642e:	e036      	b.n	801649e <UnpackSFMPEG1+0x166>
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 8016430:	68f8      	ldr	r0, [r7, #12]
 8016432:	6979      	ldr	r1, [r7, #20]
 8016434:	f7f9 f9dc 	bl	800f7f0 <xmp3_GetBits>
 8016438:	4603      	mov	r3, r0
 801643a:	b2d9      	uxtb	r1, r3
 801643c:	6878      	ldr	r0, [r7, #4]
 801643e:	69fa      	ldr	r2, [r7, #28]
 8016440:	4613      	mov	r3, r2
 8016442:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016446:	189b      	adds	r3, r3, r2
 8016448:	18c3      	adds	r3, r0, r3
 801644a:	f103 0317 	add.w	r3, r3, #23
 801644e:	460a      	mov	r2, r1
 8016450:	701a      	strb	r2, [r3, #0]
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 8016452:	68f8      	ldr	r0, [r7, #12]
 8016454:	6979      	ldr	r1, [r7, #20]
 8016456:	f7f9 f9cb 	bl	800f7f0 <xmp3_GetBits>
 801645a:	4603      	mov	r3, r0
 801645c:	b2d9      	uxtb	r1, r3
 801645e:	6878      	ldr	r0, [r7, #4]
 8016460:	69fa      	ldr	r2, [r7, #28]
 8016462:	4613      	mov	r3, r2
 8016464:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016468:	189b      	adds	r3, r3, r2
 801646a:	18c3      	adds	r3, r0, r3
 801646c:	f103 0318 	add.w	r3, r3, #24
 8016470:	460a      	mov	r2, r1
 8016472:	701a      	strb	r2, [r3, #0]
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 8016474:	68f8      	ldr	r0, [r7, #12]
 8016476:	6979      	ldr	r1, [r7, #20]
 8016478:	f7f9 f9ba 	bl	800f7f0 <xmp3_GetBits>
 801647c:	4603      	mov	r3, r0
 801647e:	b2d9      	uxtb	r1, r3
 8016480:	6878      	ldr	r0, [r7, #4]
 8016482:	69fa      	ldr	r2, [r7, #28]
 8016484:	4613      	mov	r3, r2
 8016486:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801648a:	189b      	adds	r3, r3, r2
 801648c:	18c3      	adds	r3, r0, r3
 801648e:	f103 0319 	add.w	r3, r3, #25
 8016492:	460a      	mov	r2, r1
 8016494:	701a      	strb	r2, [r3, #0]
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
		}

		for (      ; sfb < 12; sfb++) {
 8016496:	69fb      	ldr	r3, [r7, #28]
 8016498:	f103 0301 	add.w	r3, r3, #1
 801649c:	61fb      	str	r3, [r7, #28]
 801649e:	69fb      	ldr	r3, [r7, #28]
 80164a0:	2b0b      	cmp	r3, #11
 80164a2:	ddc5      	ble.n	8016430 <UnpackSFMPEG1+0xf8>
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
		}

		/* last sf band not transmitted */
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 80164a4:	687b      	ldr	r3, [r7, #4]
 80164a6:	f04f 0200 	mov.w	r2, #0
 80164aa:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 80164ae:	687b      	ldr	r3, [r7, #4]
 80164b0:	f893 203d 	ldrb.w	r2, [r3, #61]	; 0x3d
 80164b4:	687b      	ldr	r3, [r7, #4]
 80164b6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
 80164ba:	687b      	ldr	r3, [r7, #4]
 80164bc:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 80164c0:	687b      	ldr	r3, [r7, #4]
 80164c2:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
 80164c6:	e0d6      	b.n	8016676 <UnpackSFMPEG1+0x33e>
	} else {
		/* long blocks, type 0, 1, or 3 */
		if(gr == 0) {
 80164c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80164ca:	2b00      	cmp	r3, #0
 80164cc:	d12a      	bne.n	8016524 <UnpackSFMPEG1+0x1ec>
			/* first granule */
			for (sfb = 0;  sfb < 11; sfb++) 
 80164ce:	f04f 0300 	mov.w	r3, #0
 80164d2:	61fb      	str	r3, [r7, #28]
 80164d4:	e00d      	b.n	80164f2 <UnpackSFMPEG1+0x1ba>
				sfis->l[sfb] = (char)GetBits(bsi, slen0);
 80164d6:	68f8      	ldr	r0, [r7, #12]
 80164d8:	69b9      	ldr	r1, [r7, #24]
 80164da:	f7f9 f989 	bl	800f7f0 <xmp3_GetBits>
 80164de:	4603      	mov	r3, r0
 80164e0:	b2da      	uxtb	r2, r3
 80164e2:	6879      	ldr	r1, [r7, #4]
 80164e4:	69fb      	ldr	r3, [r7, #28]
 80164e6:	18cb      	adds	r3, r1, r3
 80164e8:	701a      	strb	r2, [r3, #0]
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
	} else {
		/* long blocks, type 0, 1, or 3 */
		if(gr == 0) {
			/* first granule */
			for (sfb = 0;  sfb < 11; sfb++) 
 80164ea:	69fb      	ldr	r3, [r7, #28]
 80164ec:	f103 0301 	add.w	r3, r3, #1
 80164f0:	61fb      	str	r3, [r7, #28]
 80164f2:	69fb      	ldr	r3, [r7, #28]
 80164f4:	2b0a      	cmp	r3, #10
 80164f6:	ddee      	ble.n	80164d6 <UnpackSFMPEG1+0x19e>
				sfis->l[sfb] = (char)GetBits(bsi, slen0);
			for (sfb = 11; sfb < 21; sfb++) 
 80164f8:	f04f 030b 	mov.w	r3, #11
 80164fc:	61fb      	str	r3, [r7, #28]
 80164fe:	e00d      	b.n	801651c <UnpackSFMPEG1+0x1e4>
				sfis->l[sfb] = (char)GetBits(bsi, slen1);
 8016500:	68f8      	ldr	r0, [r7, #12]
 8016502:	6979      	ldr	r1, [r7, #20]
 8016504:	f7f9 f974 	bl	800f7f0 <xmp3_GetBits>
 8016508:	4603      	mov	r3, r0
 801650a:	b2da      	uxtb	r2, r3
 801650c:	6879      	ldr	r1, [r7, #4]
 801650e:	69fb      	ldr	r3, [r7, #28]
 8016510:	18cb      	adds	r3, r1, r3
 8016512:	701a      	strb	r2, [r3, #0]
		/* long blocks, type 0, 1, or 3 */
		if(gr == 0) {
			/* first granule */
			for (sfb = 0;  sfb < 11; sfb++) 
				sfis->l[sfb] = (char)GetBits(bsi, slen0);
			for (sfb = 11; sfb < 21; sfb++) 
 8016514:	69fb      	ldr	r3, [r7, #28]
 8016516:	f103 0301 	add.w	r3, r3, #1
 801651a:	61fb      	str	r3, [r7, #28]
 801651c:	69fb      	ldr	r3, [r7, #28]
 801651e:	2b14      	cmp	r3, #20
 8016520:	ddee      	ble.n	8016500 <UnpackSFMPEG1+0x1c8>
				sfis->l[sfb] = (char)GetBits(bsi, slen1);
			return;
 8016522:	e0a8      	b.n	8016676 <UnpackSFMPEG1+0x33e>
		} else {
			/* second granule
			 * scfsi: 0 = different scalefactors for each granule, 1 = copy sf's from granule 0 into granule 1 
			 * for block type == 2, scfsi is always 0
			 */
			sfb = 0;
 8016524:	f04f 0300 	mov.w	r3, #0
 8016528:	61fb      	str	r3, [r7, #28]
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801652a:	683b      	ldr	r3, [r7, #0]
 801652c:	681b      	ldr	r3, [r3, #0]
 801652e:	2b00      	cmp	r3, #0
 8016530:	d01e      	beq.n	8016570 <UnpackSFMPEG1+0x238>
 8016532:	e00b      	b.n	801654c <UnpackSFMPEG1+0x214>
 8016534:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016536:	69fb      	ldr	r3, [r7, #28]
 8016538:	18d3      	adds	r3, r2, r3
 801653a:	781a      	ldrb	r2, [r3, #0]
 801653c:	6879      	ldr	r1, [r7, #4]
 801653e:	69fb      	ldr	r3, [r7, #28]
 8016540:	18cb      	adds	r3, r1, r3
 8016542:	701a      	strb	r2, [r3, #0]
 8016544:	69fb      	ldr	r3, [r7, #28]
 8016546:	f103 0301 	add.w	r3, r3, #1
 801654a:	61fb      	str	r3, [r7, #28]
 801654c:	69fb      	ldr	r3, [r7, #28]
 801654e:	2b05      	cmp	r3, #5
 8016550:	ddf0      	ble.n	8016534 <UnpackSFMPEG1+0x1fc>
 8016552:	e010      	b.n	8016576 <UnpackSFMPEG1+0x23e>
			else          for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 8016554:	68f8      	ldr	r0, [r7, #12]
 8016556:	69b9      	ldr	r1, [r7, #24]
 8016558:	f7f9 f94a 	bl	800f7f0 <xmp3_GetBits>
 801655c:	4603      	mov	r3, r0
 801655e:	b2da      	uxtb	r2, r3
 8016560:	6879      	ldr	r1, [r7, #4]
 8016562:	69fb      	ldr	r3, [r7, #28]
 8016564:	18cb      	adds	r3, r1, r3
 8016566:	701a      	strb	r2, [r3, #0]
 8016568:	69fb      	ldr	r3, [r7, #28]
 801656a:	f103 0301 	add.w	r3, r3, #1
 801656e:	61fb      	str	r3, [r7, #28]
 8016570:	69fb      	ldr	r3, [r7, #28]
 8016572:	2b05      	cmp	r3, #5
 8016574:	ddee      	ble.n	8016554 <UnpackSFMPEG1+0x21c>
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8016576:	683b      	ldr	r3, [r7, #0]
 8016578:	f103 0304 	add.w	r3, r3, #4
 801657c:	681b      	ldr	r3, [r3, #0]
 801657e:	2b00      	cmp	r3, #0
 8016580:	d01e      	beq.n	80165c0 <UnpackSFMPEG1+0x288>
 8016582:	e00b      	b.n	801659c <UnpackSFMPEG1+0x264>
 8016584:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016586:	69fb      	ldr	r3, [r7, #28]
 8016588:	18d3      	adds	r3, r2, r3
 801658a:	781a      	ldrb	r2, [r3, #0]
 801658c:	6879      	ldr	r1, [r7, #4]
 801658e:	69fb      	ldr	r3, [r7, #28]
 8016590:	18cb      	adds	r3, r1, r3
 8016592:	701a      	strb	r2, [r3, #0]
 8016594:	69fb      	ldr	r3, [r7, #28]
 8016596:	f103 0301 	add.w	r3, r3, #1
 801659a:	61fb      	str	r3, [r7, #28]
 801659c:	69fb      	ldr	r3, [r7, #28]
 801659e:	2b0a      	cmp	r3, #10
 80165a0:	ddf0      	ble.n	8016584 <UnpackSFMPEG1+0x24c>
 80165a2:	e010      	b.n	80165c6 <UnpackSFMPEG1+0x28e>
			else          for(  ; sfb <11 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 80165a4:	68f8      	ldr	r0, [r7, #12]
 80165a6:	69b9      	ldr	r1, [r7, #24]
 80165a8:	f7f9 f922 	bl	800f7f0 <xmp3_GetBits>
 80165ac:	4603      	mov	r3, r0
 80165ae:	b2da      	uxtb	r2, r3
 80165b0:	6879      	ldr	r1, [r7, #4]
 80165b2:	69fb      	ldr	r3, [r7, #28]
 80165b4:	18cb      	adds	r3, r1, r3
 80165b6:	701a      	strb	r2, [r3, #0]
 80165b8:	69fb      	ldr	r3, [r7, #28]
 80165ba:	f103 0301 	add.w	r3, r3, #1
 80165be:	61fb      	str	r3, [r7, #28]
 80165c0:	69fb      	ldr	r3, [r7, #28]
 80165c2:	2b0a      	cmp	r3, #10
 80165c4:	ddee      	ble.n	80165a4 <UnpackSFMPEG1+0x26c>
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80165c6:	683b      	ldr	r3, [r7, #0]
 80165c8:	f103 0308 	add.w	r3, r3, #8
 80165cc:	681b      	ldr	r3, [r3, #0]
 80165ce:	2b00      	cmp	r3, #0
 80165d0:	d01e      	beq.n	8016610 <UnpackSFMPEG1+0x2d8>
 80165d2:	e00b      	b.n	80165ec <UnpackSFMPEG1+0x2b4>
 80165d4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80165d6:	69fb      	ldr	r3, [r7, #28]
 80165d8:	18d3      	adds	r3, r2, r3
 80165da:	781a      	ldrb	r2, [r3, #0]
 80165dc:	6879      	ldr	r1, [r7, #4]
 80165de:	69fb      	ldr	r3, [r7, #28]
 80165e0:	18cb      	adds	r3, r1, r3
 80165e2:	701a      	strb	r2, [r3, #0]
 80165e4:	69fb      	ldr	r3, [r7, #28]
 80165e6:	f103 0301 	add.w	r3, r3, #1
 80165ea:	61fb      	str	r3, [r7, #28]
 80165ec:	69fb      	ldr	r3, [r7, #28]
 80165ee:	2b0f      	cmp	r3, #15
 80165f0:	ddf0      	ble.n	80165d4 <UnpackSFMPEG1+0x29c>
 80165f2:	e010      	b.n	8016616 <UnpackSFMPEG1+0x2de>
			else          for(  ; sfb <16 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 80165f4:	68f8      	ldr	r0, [r7, #12]
 80165f6:	6979      	ldr	r1, [r7, #20]
 80165f8:	f7f9 f8fa 	bl	800f7f0 <xmp3_GetBits>
 80165fc:	4603      	mov	r3, r0
 80165fe:	b2da      	uxtb	r2, r3
 8016600:	6879      	ldr	r1, [r7, #4]
 8016602:	69fb      	ldr	r3, [r7, #28]
 8016604:	18cb      	adds	r3, r1, r3
 8016606:	701a      	strb	r2, [r3, #0]
 8016608:	69fb      	ldr	r3, [r7, #28]
 801660a:	f103 0301 	add.w	r3, r3, #1
 801660e:	61fb      	str	r3, [r7, #28]
 8016610:	69fb      	ldr	r3, [r7, #28]
 8016612:	2b0f      	cmp	r3, #15
 8016614:	ddee      	ble.n	80165f4 <UnpackSFMPEG1+0x2bc>
			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8016616:	683b      	ldr	r3, [r7, #0]
 8016618:	f103 030c 	add.w	r3, r3, #12
 801661c:	681b      	ldr	r3, [r3, #0]
 801661e:	2b00      	cmp	r3, #0
 8016620:	d01e      	beq.n	8016660 <UnpackSFMPEG1+0x328>
 8016622:	e00b      	b.n	801663c <UnpackSFMPEG1+0x304>
 8016624:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016626:	69fb      	ldr	r3, [r7, #28]
 8016628:	18d3      	adds	r3, r2, r3
 801662a:	781a      	ldrb	r2, [r3, #0]
 801662c:	6879      	ldr	r1, [r7, #4]
 801662e:	69fb      	ldr	r3, [r7, #28]
 8016630:	18cb      	adds	r3, r1, r3
 8016632:	701a      	strb	r2, [r3, #0]
 8016634:	69fb      	ldr	r3, [r7, #28]
 8016636:	f103 0301 	add.w	r3, r3, #1
 801663a:	61fb      	str	r3, [r7, #28]
 801663c:	69fb      	ldr	r3, [r7, #28]
 801663e:	2b14      	cmp	r3, #20
 8016640:	ddf0      	ble.n	8016624 <UnpackSFMPEG1+0x2ec>
 8016642:	e010      	b.n	8016666 <UnpackSFMPEG1+0x32e>
			else          for(  ; sfb <21 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 8016644:	68f8      	ldr	r0, [r7, #12]
 8016646:	6979      	ldr	r1, [r7, #20]
 8016648:	f7f9 f8d2 	bl	800f7f0 <xmp3_GetBits>
 801664c:	4603      	mov	r3, r0
 801664e:	b2da      	uxtb	r2, r3
 8016650:	6879      	ldr	r1, [r7, #4]
 8016652:	69fb      	ldr	r3, [r7, #28]
 8016654:	18cb      	adds	r3, r1, r3
 8016656:	701a      	strb	r2, [r3, #0]
 8016658:	69fb      	ldr	r3, [r7, #28]
 801665a:	f103 0301 	add.w	r3, r3, #1
 801665e:	61fb      	str	r3, [r7, #28]
 8016660:	69fb      	ldr	r3, [r7, #28]
 8016662:	2b14      	cmp	r3, #20
 8016664:	ddee      	ble.n	8016644 <UnpackSFMPEG1+0x30c>
		}
		/* last sf band not transmitted */
		sfis->l[21] = 0;
 8016666:	687b      	ldr	r3, [r7, #4]
 8016668:	f04f 0200 	mov.w	r2, #0
 801666c:	755a      	strb	r2, [r3, #21]
		sfis->l[22] = 0;
 801666e:	687b      	ldr	r3, [r7, #4]
 8016670:	f04f 0200 	mov.w	r2, #0
 8016674:	759a      	strb	r2, [r3, #22]
	}
}
 8016676:	f107 0720 	add.w	r7, r7, #32
 801667a:	46bd      	mov	sp, r7
 801667c:	bd80      	pop	{r7, pc}
 801667e:	bf00      	nop

08016680 <UnpackSFMPEG2>:
 *
 * TODO:        optimize the / and % stuff (only do one divide, get modulo x 
 *                with (x / m) * m, etc.)
 **************************************************************************************/
static void UnpackSFMPEG2(BitStreamInfo *bsi, SideInfoSub *sis, ScaleFactorInfoSub *sfis, int gr, int ch, int modeExt, ScaleFactorJS *sfjs)
{
 8016680:	b580      	push	{r7, lr}
 8016682:	b094      	sub	sp, #80	; 0x50
 8016684:	af00      	add	r7, sp, #0
 8016686:	60f8      	str	r0, [r7, #12]
 8016688:	60b9      	str	r1, [r7, #8]
 801668a:	607a      	str	r2, [r7, #4]
 801668c:	603b      	str	r3, [r7, #0]
//	int iipTest;
	int i, sfb, sfcIdx, btIdx, nrIdx;
	int slen[4], nr[4];
	int sfCompress, preFlag, intensityScale;
	
	sfCompress = sis->sfCompress;
 801668e:	68bb      	ldr	r3, [r7, #8]
 8016690:	68db      	ldr	r3, [r3, #12]
 8016692:	633b      	str	r3, [r7, #48]	; 0x30
	preFlag = 0;
 8016694:	f04f 0300 	mov.w	r3, #0
 8016698:	63bb      	str	r3, [r7, #56]	; 0x38
	intensityScale = 0;
 801669a:	f04f 0300 	mov.w	r3, #0
 801669e:	637b      	str	r3, [r7, #52]	; 0x34

	/* stereo mode bits (1 = on): bit 1 = mid-side on/off, bit 0 = intensity on/off */
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
 80166a0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80166a2:	f003 0301 	and.w	r3, r3, #1
 80166a6:	2b00      	cmp	r3, #0
 80166a8:	d003      	beq.n	80166b2 <UnpackSFMPEG2+0x32>
 80166aa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80166ac:	2b01      	cmp	r3, #1
 80166ae:	f000 80a0 	beq.w	80167f2 <UnpackSFMPEG2+0x172>
		/* in other words: if ((modeExt & 0x01) == 0 || ch == 0) */
		if (sfCompress < 400) {
 80166b2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80166b4:	f240 138f 	movw	r3, #399	; 0x18f
 80166b8:	429a      	cmp	r2, r3
 80166ba:	dc30      	bgt.n	801671e <UnpackSFMPEG2+0x9e>
			/* max slen = floor[(399/16) / 5] = 4 */
			slen[0] = (sfCompress >> 4) / 5;
 80166bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80166be:	ea4f 1223 	mov.w	r2, r3, asr #4
 80166c2:	f246 6367 	movw	r3, #26215	; 0x6667
 80166c6:	f2c6 6366 	movt	r3, #26214	; 0x6666
 80166ca:	fb83 0302 	smull	r0, r3, r3, r2
 80166ce:	ea4f 0163 	mov.w	r1, r3, asr #1
 80166d2:	ea4f 73e2 	mov.w	r3, r2, asr #31
 80166d6:	1acb      	subs	r3, r1, r3
 80166d8:	623b      	str	r3, [r7, #32]
			slen[1]= (sfCompress >> 4) % 5;
 80166da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80166dc:	ea4f 1123 	mov.w	r1, r3, asr #4
 80166e0:	f246 6367 	movw	r3, #26215	; 0x6667
 80166e4:	f2c6 6366 	movt	r3, #26214	; 0x6666
 80166e8:	fb83 2301 	smull	r2, r3, r3, r1
 80166ec:	ea4f 0263 	mov.w	r2, r3, asr #1
 80166f0:	ea4f 73e1 	mov.w	r3, r1, asr #31
 80166f4:	1ad2      	subs	r2, r2, r3
 80166f6:	4613      	mov	r3, r2
 80166f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80166fc:	189b      	adds	r3, r3, r2
 80166fe:	1aca      	subs	r2, r1, r3
 8016700:	627a      	str	r2, [r7, #36]	; 0x24
			slen[2]= (sfCompress & 0x0f) >> 2;
 8016702:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016704:	f003 030f 	and.w	r3, r3, #15
 8016708:	ea4f 03a3 	mov.w	r3, r3, asr #2
 801670c:	62bb      	str	r3, [r7, #40]	; 0x28
			slen[3]= (sfCompress & 0x03);
 801670e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016710:	f003 0303 	and.w	r3, r3, #3
 8016714:	62fb      	str	r3, [r7, #44]	; 0x2c
			sfcIdx = 0;
 8016716:	f04f 0300 	mov.w	r3, #0
 801671a:	647b      	str	r3, [r7, #68]	; 0x44
	intensityScale = 0;

	/* stereo mode bits (1 = on): bit 1 = mid-side on/off, bit 0 = intensity on/off */
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
		/* in other words: if ((modeExt & 0x01) == 0 || ch == 0) */
		if (sfCompress < 400) {
 801671c:	e10e      	b.n	801693c <UnpackSFMPEG2+0x2bc>
			slen[0] = (sfCompress >> 4) / 5;
			slen[1]= (sfCompress >> 4) % 5;
			slen[2]= (sfCompress & 0x0f) >> 2;
			slen[3]= (sfCompress & 0x03);
			sfcIdx = 0;
		} else if (sfCompress < 500) {
 801671e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016720:	f240 13f3 	movw	r3, #499	; 0x1f3
 8016724:	429a      	cmp	r2, r3
 8016726:	dc31      	bgt.n	801678c <UnpackSFMPEG2+0x10c>
			/* max slen = floor[(99/4) / 5] = 4 */
			sfCompress -= 400;
 8016728:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801672a:	f5a3 73c8 	sub.w	r3, r3, #400	; 0x190
 801672e:	633b      	str	r3, [r7, #48]	; 0x30
			slen[0] = (sfCompress >> 2) / 5;
 8016730:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016732:	ea4f 02a3 	mov.w	r2, r3, asr #2
 8016736:	f246 6367 	movw	r3, #26215	; 0x6667
 801673a:	f2c6 6366 	movt	r3, #26214	; 0x6666
 801673e:	fb83 0302 	smull	r0, r3, r3, r2
 8016742:	ea4f 0163 	mov.w	r1, r3, asr #1
 8016746:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801674a:	1acb      	subs	r3, r1, r3
 801674c:	623b      	str	r3, [r7, #32]
			slen[1]= (sfCompress >> 2) % 5;
 801674e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016750:	ea4f 01a3 	mov.w	r1, r3, asr #2
 8016754:	f246 6367 	movw	r3, #26215	; 0x6667
 8016758:	f2c6 6366 	movt	r3, #26214	; 0x6666
 801675c:	fb83 2301 	smull	r2, r3, r3, r1
 8016760:	ea4f 0263 	mov.w	r2, r3, asr #1
 8016764:	ea4f 73e1 	mov.w	r3, r1, asr #31
 8016768:	1ad2      	subs	r2, r2, r3
 801676a:	4613      	mov	r3, r2
 801676c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016770:	189b      	adds	r3, r3, r2
 8016772:	1aca      	subs	r2, r1, r3
 8016774:	627a      	str	r2, [r7, #36]	; 0x24
			slen[2]= (sfCompress & 0x03);
 8016776:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016778:	f003 0303 	and.w	r3, r3, #3
 801677c:	62bb      	str	r3, [r7, #40]	; 0x28
			slen[3]= 0;
 801677e:	f04f 0300 	mov.w	r3, #0
 8016782:	62fb      	str	r3, [r7, #44]	; 0x2c
			sfcIdx = 1;
 8016784:	f04f 0301 	mov.w	r3, #1
 8016788:	647b      	str	r3, [r7, #68]	; 0x44
	intensityScale = 0;

	/* stereo mode bits (1 = on): bit 1 = mid-side on/off, bit 0 = intensity on/off */
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
		/* in other words: if ((modeExt & 0x01) == 0 || ch == 0) */
		if (sfCompress < 400) {
 801678a:	e0d7      	b.n	801693c <UnpackSFMPEG2+0x2bc>
			slen[2]= (sfCompress & 0x03);
			slen[3]= 0;
			sfcIdx = 1;
		} else {
			/* max slen = floor[11/3] = 3 (sfCompress = 9 bits in MPEG2) */
			sfCompress -= 500;
 801678c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801678e:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
 8016792:	633b      	str	r3, [r7, #48]	; 0x30
			slen[0] = sfCompress / 3;
 8016794:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016796:	f245 5356 	movw	r3, #21846	; 0x5556
 801679a:	f2c5 5355 	movt	r3, #21845	; 0x5555
 801679e:	fb83 0102 	smull	r0, r1, r3, r2
 80167a2:	ea4f 73e2 	mov.w	r3, r2, asr #31
 80167a6:	1acb      	subs	r3, r1, r3
 80167a8:	623b      	str	r3, [r7, #32]
			slen[1] = sfCompress % 3;
 80167aa:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80167ac:	f245 5356 	movw	r3, #21846	; 0x5556
 80167b0:	f2c5 5355 	movt	r3, #21845	; 0x5555
 80167b4:	fb83 0201 	smull	r0, r2, r3, r1
 80167b8:	ea4f 73e1 	mov.w	r3, r1, asr #31
 80167bc:	1ad2      	subs	r2, r2, r3
 80167be:	4613      	mov	r3, r2
 80167c0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80167c4:	189b      	adds	r3, r3, r2
 80167c6:	1aca      	subs	r2, r1, r3
 80167c8:	627a      	str	r2, [r7, #36]	; 0x24
			slen[2] = slen[3] = 0;
 80167ca:	f04f 0300 	mov.w	r3, #0
 80167ce:	62fb      	str	r3, [r7, #44]	; 0x2c
 80167d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80167d2:	62bb      	str	r3, [r7, #40]	; 0x28
			if (sis->mixedBlock) {
 80167d4:	68bb      	ldr	r3, [r7, #8]
 80167d6:	699b      	ldr	r3, [r3, #24]
 80167d8:	2b00      	cmp	r3, #0
 80167da:	d003      	beq.n	80167e4 <UnpackSFMPEG2+0x164>
				/* adjust for long/short mix logic (see comment above in NRTab[] definition) */
				slen[2] = slen[1];  
 80167dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80167de:	62bb      	str	r3, [r7, #40]	; 0x28
				slen[1] = slen[0];
 80167e0:	6a3b      	ldr	r3, [r7, #32]
 80167e2:	627b      	str	r3, [r7, #36]	; 0x24
			}  
			preFlag = 1;
 80167e4:	f04f 0301 	mov.w	r3, #1
 80167e8:	63bb      	str	r3, [r7, #56]	; 0x38
			sfcIdx = 2;
 80167ea:	f04f 0302 	mov.w	r3, #2
 80167ee:	647b      	str	r3, [r7, #68]	; 0x44
	intensityScale = 0;

	/* stereo mode bits (1 = on): bit 1 = mid-side on/off, bit 0 = intensity on/off */
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
		/* in other words: if ((modeExt & 0x01) == 0 || ch == 0) */
		if (sfCompress < 400) {
 80167f0:	e0a4      	b.n	801693c <UnpackSFMPEG2+0x2bc>
			preFlag = 1;
			sfcIdx = 2;
		}
	} else {    
		/* intensity stereo ch = 1 (right) */
		intensityScale = sfCompress & 0x01;
 80167f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80167f4:	f003 0301 	and.w	r3, r3, #1
 80167f8:	637b      	str	r3, [r7, #52]	; 0x34
		sfCompress >>= 1;
 80167fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80167fc:	ea4f 0363 	mov.w	r3, r3, asr #1
 8016800:	633b      	str	r3, [r7, #48]	; 0x30
		if (sfCompress < 180) {
 8016802:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016804:	2bb3      	cmp	r3, #179	; 0xb3
 8016806:	dc54      	bgt.n	80168b2 <UnpackSFMPEG2+0x232>
			/* max slen = floor[35/6] = 5 (from mod 36) */
			slen[0] = (sfCompress / 36);
 8016808:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801680a:	f648 6339 	movw	r3, #36409	; 0x8e39
 801680e:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
 8016812:	fb83 1302 	smull	r1, r3, r3, r2
 8016816:	ea4f 01e3 	mov.w	r1, r3, asr #3
 801681a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801681e:	1acb      	subs	r3, r1, r3
 8016820:	623b      	str	r3, [r7, #32]
			slen[1] = (sfCompress % 36) / 6;
 8016822:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8016824:	f648 6339 	movw	r3, #36409	; 0x8e39
 8016828:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
 801682c:	fb83 2301 	smull	r2, r3, r3, r1
 8016830:	ea4f 02e3 	mov.w	r2, r3, asr #3
 8016834:	ea4f 73e1 	mov.w	r3, r1, asr #31
 8016838:	1ad2      	subs	r2, r2, r3
 801683a:	4613      	mov	r3, r2
 801683c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016840:	189b      	adds	r3, r3, r2
 8016842:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016846:	1aca      	subs	r2, r1, r3
 8016848:	f64a 23ab 	movw	r3, #43691	; 0xaaab
 801684c:	f6c2 23aa 	movt	r3, #10922	; 0x2aaa
 8016850:	fb83 0102 	smull	r0, r1, r3, r2
 8016854:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8016858:	1acb      	subs	r3, r1, r3
 801685a:	627b      	str	r3, [r7, #36]	; 0x24
			slen[2] = (sfCompress % 36) % 6;
 801685c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801685e:	f648 6339 	movw	r3, #36409	; 0x8e39
 8016862:	f6c3 03e3 	movt	r3, #14563	; 0x38e3
 8016866:	fb83 2301 	smull	r2, r3, r3, r1
 801686a:	ea4f 02e3 	mov.w	r2, r3, asr #3
 801686e:	ea4f 73e1 	mov.w	r3, r1, asr #31
 8016872:	1ad2      	subs	r2, r2, r3
 8016874:	4613      	mov	r3, r2
 8016876:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801687a:	189b      	adds	r3, r3, r2
 801687c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016880:	1aca      	subs	r2, r1, r3
 8016882:	f64a 23ab 	movw	r3, #43691	; 0xaaab
 8016886:	f6c2 23aa 	movt	r3, #10922	; 0x2aaa
 801688a:	fb83 0102 	smull	r0, r1, r3, r2
 801688e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8016892:	1ac9      	subs	r1, r1, r3
 8016894:	460b      	mov	r3, r1
 8016896:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801689a:	185b      	adds	r3, r3, r1
 801689c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80168a0:	1ad1      	subs	r1, r2, r3
 80168a2:	62b9      	str	r1, [r7, #40]	; 0x28
			slen[3] = 0;
 80168a4:	f04f 0300 	mov.w	r3, #0
 80168a8:	62fb      	str	r3, [r7, #44]	; 0x2c
			sfcIdx = 3;
 80168aa:	f04f 0303 	mov.w	r3, #3
 80168ae:	647b      	str	r3, [r7, #68]	; 0x44
 80168b0:	e044      	b.n	801693c <UnpackSFMPEG2+0x2bc>
		} else if (sfCompress < 244) {
 80168b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80168b4:	2bf3      	cmp	r3, #243	; 0xf3
 80168b6:	dc1a      	bgt.n	80168ee <UnpackSFMPEG2+0x26e>
			/* max slen = floor[63/16] = 3 */
			sfCompress -= 180;
 80168b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80168ba:	f1a3 03b4 	sub.w	r3, r3, #180	; 0xb4
 80168be:	633b      	str	r3, [r7, #48]	; 0x30
			slen[0] = (sfCompress & 0x3f) >> 4;
 80168c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80168c2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80168c6:	ea4f 1323 	mov.w	r3, r3, asr #4
 80168ca:	623b      	str	r3, [r7, #32]
			slen[1] = (sfCompress & 0x0f) >> 2;
 80168cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80168ce:	f003 030f 	and.w	r3, r3, #15
 80168d2:	ea4f 03a3 	mov.w	r3, r3, asr #2
 80168d6:	627b      	str	r3, [r7, #36]	; 0x24
			slen[2] = (sfCompress & 0x03);
 80168d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80168da:	f003 0303 	and.w	r3, r3, #3
 80168de:	62bb      	str	r3, [r7, #40]	; 0x28
			slen[3] = 0;
 80168e0:	f04f 0300 	mov.w	r3, #0
 80168e4:	62fb      	str	r3, [r7, #44]	; 0x2c
			sfcIdx = 4;
 80168e6:	f04f 0304 	mov.w	r3, #4
 80168ea:	647b      	str	r3, [r7, #68]	; 0x44
 80168ec:	e026      	b.n	801693c <UnpackSFMPEG2+0x2bc>
		} else {
			/* max slen = floor[11/3] = 3 (max sfCompress >> 1 = 511/2 = 255) */
			sfCompress -= 244;
 80168ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80168f0:	f1a3 03f4 	sub.w	r3, r3, #244	; 0xf4
 80168f4:	633b      	str	r3, [r7, #48]	; 0x30
			slen[0] = (sfCompress / 3);
 80168f6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80168f8:	f245 5356 	movw	r3, #21846	; 0x5556
 80168fc:	f2c5 5355 	movt	r3, #21845	; 0x5555
 8016900:	fb83 0102 	smull	r0, r1, r3, r2
 8016904:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8016908:	1acb      	subs	r3, r1, r3
 801690a:	623b      	str	r3, [r7, #32]
			slen[1] = (sfCompress % 3);
 801690c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801690e:	f245 5356 	movw	r3, #21846	; 0x5556
 8016912:	f2c5 5355 	movt	r3, #21845	; 0x5555
 8016916:	fb83 0201 	smull	r0, r2, r3, r1
 801691a:	ea4f 73e1 	mov.w	r3, r1, asr #31
 801691e:	1ad2      	subs	r2, r2, r3
 8016920:	4613      	mov	r3, r2
 8016922:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016926:	189b      	adds	r3, r3, r2
 8016928:	1aca      	subs	r2, r1, r3
 801692a:	627a      	str	r2, [r7, #36]	; 0x24
			slen[2] = slen[3] = 0;
 801692c:	f04f 0300 	mov.w	r3, #0
 8016930:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016932:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016934:	62bb      	str	r3, [r7, #40]	; 0x28
			sfcIdx = 5;
 8016936:	f04f 0305 	mov.w	r3, #5
 801693a:	647b      	str	r3, [r7, #68]	; 0x44
		}
	}
	
	/* set index based on block type: (0,1,3) --> 0, (2 non-mixed) --> 1, (2 mixed) ---> 2 */
	btIdx = 0;
 801693c:	f04f 0300 	mov.w	r3, #0
 8016940:	643b      	str	r3, [r7, #64]	; 0x40
	if (sis->blockType == 2) 
 8016942:	68bb      	ldr	r3, [r7, #8]
 8016944:	695b      	ldr	r3, [r3, #20]
 8016946:	2b02      	cmp	r3, #2
 8016948:	d109      	bne.n	801695e <UnpackSFMPEG2+0x2de>
		btIdx = (sis->mixedBlock ? 2 : 1);
 801694a:	68bb      	ldr	r3, [r7, #8]
 801694c:	699b      	ldr	r3, [r3, #24]
 801694e:	2b00      	cmp	r3, #0
 8016950:	d002      	beq.n	8016958 <UnpackSFMPEG2+0x2d8>
 8016952:	f04f 0302 	mov.w	r3, #2
 8016956:	e001      	b.n	801695c <UnpackSFMPEG2+0x2dc>
 8016958:	f04f 0301 	mov.w	r3, #1
 801695c:	643b      	str	r3, [r7, #64]	; 0x40
	for (i = 0; i < 4; i++)
 801695e:	f04f 0300 	mov.w	r3, #0
 8016962:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016964:	e01d      	b.n	80169a2 <UnpackSFMPEG2+0x322>
		nr[i] = (int)NRTab[sfcIdx][btIdx][i];
 8016966:	f24e 3234 	movw	r2, #58164	; 0xe334
 801696a:	f6c0 0202 	movt	r2, #2050	; 0x802
 801696e:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8016970:	460b      	mov	r3, r1
 8016972:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016976:	185b      	adds	r3, r3, r1
 8016978:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801697a:	185b      	adds	r3, r3, r1
 801697c:	ea4f 0183 	mov.w	r1, r3, lsl #2
 8016980:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016982:	18cb      	adds	r3, r1, r3
 8016984:	18d3      	adds	r3, r2, r3
 8016986:	781b      	ldrb	r3, [r3, #0]
 8016988:	461a      	mov	r2, r3
 801698a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801698c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016990:	f107 0150 	add.w	r1, r7, #80	; 0x50
 8016994:	18cb      	adds	r3, r1, r3
 8016996:	f843 2c40 	str.w	r2, [r3, #-64]
	
	/* set index based on block type: (0,1,3) --> 0, (2 non-mixed) --> 1, (2 mixed) ---> 2 */
	btIdx = 0;
	if (sis->blockType == 2) 
		btIdx = (sis->mixedBlock ? 2 : 1);
	for (i = 0; i < 4; i++)
 801699a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801699c:	f103 0301 	add.w	r3, r3, #1
 80169a0:	64fb      	str	r3, [r7, #76]	; 0x4c
 80169a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80169a4:	2b03      	cmp	r3, #3
 80169a6:	ddde      	ble.n	8016966 <UnpackSFMPEG2+0x2e6>
		nr[i] = (int)NRTab[sfcIdx][btIdx][i];

	/* save intensity stereo scale factor info */
	if( (modeExt & 0x01) && (ch == 1) ) {
 80169a8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80169aa:	f003 0301 	and.w	r3, r3, #1
 80169ae:	b2db      	uxtb	r3, r3
 80169b0:	2b00      	cmp	r3, #0
 80169b2:	d02e      	beq.n	8016a12 <UnpackSFMPEG2+0x392>
 80169b4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80169b6:	2b01      	cmp	r3, #1
 80169b8:	d12b      	bne.n	8016a12 <UnpackSFMPEG2+0x392>
		for (i = 0; i < 4; i++) {
 80169ba:	f04f 0300 	mov.w	r3, #0
 80169be:	64fb      	str	r3, [r7, #76]	; 0x4c
 80169c0:	e021      	b.n	8016a06 <UnpackSFMPEG2+0x386>
			sfjs->slen[i] = slen[i];
 80169c2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80169c4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80169c8:	f107 0250 	add.w	r2, r7, #80	; 0x50
 80169cc:	18d3      	adds	r3, r2, r3
 80169ce:	f853 2c30 	ldr.w	r2, [r3, #-48]
 80169d2:	6e39      	ldr	r1, [r7, #96]	; 0x60
 80169d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80169d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80169da:	18cb      	adds	r3, r1, r3
 80169dc:	605a      	str	r2, [r3, #4]
			sfjs->nr[i] = nr[i];
 80169de:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80169e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80169e4:	f107 0050 	add.w	r0, r7, #80	; 0x50
 80169e8:	18c3      	adds	r3, r0, r3
 80169ea:	f853 2c40 	ldr.w	r2, [r3, #-64]
 80169ee:	6e39      	ldr	r1, [r7, #96]	; 0x60
 80169f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80169f2:	f103 0304 	add.w	r3, r3, #4
 80169f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80169fa:	18cb      	adds	r3, r1, r3
 80169fc:	605a      	str	r2, [r3, #4]
	for (i = 0; i < 4; i++)
		nr[i] = (int)NRTab[sfcIdx][btIdx][i];

	/* save intensity stereo scale factor info */
	if( (modeExt & 0x01) && (ch == 1) ) {
		for (i = 0; i < 4; i++) {
 80169fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016a00:	f103 0301 	add.w	r3, r3, #1
 8016a04:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016a06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016a08:	2b03      	cmp	r3, #3
 8016a0a:	ddda      	ble.n	80169c2 <UnpackSFMPEG2+0x342>
			sfjs->slen[i] = slen[i];
			sfjs->nr[i] = nr[i];
		}
		sfjs->intensityScale = intensityScale;
 8016a0c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016a0e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8016a10:	601a      	str	r2, [r3, #0]
	}
	sis->preFlag = preFlag;
 8016a12:	68bb      	ldr	r3, [r7, #8]
 8016a14:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8016a16:	63da      	str	r2, [r3, #60]	; 0x3c

	/* short blocks */
	if(sis->blockType == 2) {
 8016a18:	68bb      	ldr	r3, [r7, #8]
 8016a1a:	695b      	ldr	r3, [r3, #20]
 8016a1c:	2b02      	cmp	r3, #2
 8016a1e:	f040 80a3 	bne.w	8016b68 <UnpackSFMPEG2+0x4e8>
		if(sis->mixedBlock) {
 8016a22:	68bb      	ldr	r3, [r7, #8]
 8016a24:	699b      	ldr	r3, [r3, #24]
 8016a26:	2b00      	cmp	r3, #0
 8016a28:	d01c      	beq.n	8016a64 <UnpackSFMPEG2+0x3e4>
			/* do long block portion */
//			iipTest = (1 << slen[0]) - 1;
			for (sfb=0; sfb < 6; sfb++) {
 8016a2a:	f04f 0300 	mov.w	r3, #0
 8016a2e:	64bb      	str	r3, [r7, #72]	; 0x48
 8016a30:	e00e      	b.n	8016a50 <UnpackSFMPEG2+0x3d0>
				sfis->l[sfb] = (char)GetBits(bsi, slen[0]);
 8016a32:	6a3b      	ldr	r3, [r7, #32]
 8016a34:	68f8      	ldr	r0, [r7, #12]
 8016a36:	4619      	mov	r1, r3
 8016a38:	f7f8 feda 	bl	800f7f0 <xmp3_GetBits>
 8016a3c:	4603      	mov	r3, r0
 8016a3e:	b2da      	uxtb	r2, r3
 8016a40:	6879      	ldr	r1, [r7, #4]
 8016a42:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016a44:	18cb      	adds	r3, r1, r3
 8016a46:	701a      	strb	r2, [r3, #0]
	/* short blocks */
	if(sis->blockType == 2) {
		if(sis->mixedBlock) {
			/* do long block portion */
//			iipTest = (1 << slen[0]) - 1;
			for (sfb=0; sfb < 6; sfb++) {
 8016a48:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016a4a:	f103 0301 	add.w	r3, r3, #1
 8016a4e:	64bb      	str	r3, [r7, #72]	; 0x48
 8016a50:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016a52:	2b05      	cmp	r3, #5
 8016a54:	dded      	ble.n	8016a32 <UnpackSFMPEG2+0x3b2>
				sfis->l[sfb] = (char)GetBits(bsi, slen[0]);
			}
			sfb = 3;  /* start sfb for short */
 8016a56:	f04f 0303 	mov.w	r3, #3
 8016a5a:	64bb      	str	r3, [r7, #72]	; 0x48
			nrIdx = 1;
 8016a5c:	f04f 0301 	mov.w	r3, #1
 8016a60:	63fb      	str	r3, [r7, #60]	; 0x3c
			sfb = 0;
			nrIdx = 0;
		}

		/* remaining short blocks, sfb just keeps incrementing */
		for (    ; nrIdx <= 3; nrIdx++) {
 8016a62:	e06c      	b.n	8016b3e <UnpackSFMPEG2+0x4be>
			}
			sfb = 3;  /* start sfb for short */
			nrIdx = 1;
		} else {      
			/* all short blocks, so start nr, sfb at 0 */
			sfb = 0;
 8016a64:	f04f 0300 	mov.w	r3, #0
 8016a68:	64bb      	str	r3, [r7, #72]	; 0x48
			nrIdx = 0;
 8016a6a:	f04f 0300 	mov.w	r3, #0
 8016a6e:	63fb      	str	r3, [r7, #60]	; 0x3c
		}

		/* remaining short blocks, sfb just keeps incrementing */
		for (    ; nrIdx <= 3; nrIdx++) {
 8016a70:	e065      	b.n	8016b3e <UnpackSFMPEG2+0x4be>
//			iipTest = (1 << slen[nrIdx]) - 1;
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 8016a72:	f04f 0300 	mov.w	r3, #0
 8016a76:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016a78:	e052      	b.n	8016b20 <UnpackSFMPEG2+0x4a0>
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 8016a7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016a7c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016a80:	f107 0150 	add.w	r1, r7, #80	; 0x50
 8016a84:	18cb      	adds	r3, r1, r3
 8016a86:	f853 3c30 	ldr.w	r3, [r3, #-48]
 8016a8a:	68f8      	ldr	r0, [r7, #12]
 8016a8c:	4619      	mov	r1, r3
 8016a8e:	f7f8 feaf 	bl	800f7f0 <xmp3_GetBits>
 8016a92:	4603      	mov	r3, r0
 8016a94:	b2d9      	uxtb	r1, r3
 8016a96:	6878      	ldr	r0, [r7, #4]
 8016a98:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016a9a:	4613      	mov	r3, r2
 8016a9c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016aa0:	189b      	adds	r3, r3, r2
 8016aa2:	18c3      	adds	r3, r0, r3
 8016aa4:	f103 0317 	add.w	r3, r3, #23
 8016aa8:	460a      	mov	r2, r1
 8016aaa:	701a      	strb	r2, [r3, #0]
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 8016aac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016aae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016ab2:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8016ab6:	18d3      	adds	r3, r2, r3
 8016ab8:	f853 3c30 	ldr.w	r3, [r3, #-48]
 8016abc:	68f8      	ldr	r0, [r7, #12]
 8016abe:	4619      	mov	r1, r3
 8016ac0:	f7f8 fe96 	bl	800f7f0 <xmp3_GetBits>
 8016ac4:	4603      	mov	r3, r0
 8016ac6:	b2d9      	uxtb	r1, r3
 8016ac8:	6878      	ldr	r0, [r7, #4]
 8016aca:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016acc:	4613      	mov	r3, r2
 8016ace:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016ad2:	189b      	adds	r3, r3, r2
 8016ad4:	18c3      	adds	r3, r0, r3
 8016ad6:	f103 0318 	add.w	r3, r3, #24
 8016ada:	460a      	mov	r2, r1
 8016adc:	701a      	strb	r2, [r3, #0]
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 8016ade:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016ae0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016ae4:	f107 0050 	add.w	r0, r7, #80	; 0x50
 8016ae8:	18c3      	adds	r3, r0, r3
 8016aea:	f853 3c30 	ldr.w	r3, [r3, #-48]
 8016aee:	68f8      	ldr	r0, [r7, #12]
 8016af0:	4619      	mov	r1, r3
 8016af2:	f7f8 fe7d 	bl	800f7f0 <xmp3_GetBits>
 8016af6:	4603      	mov	r3, r0
 8016af8:	b2d9      	uxtb	r1, r3
 8016afa:	6878      	ldr	r0, [r7, #4]
 8016afc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016afe:	4613      	mov	r3, r2
 8016b00:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016b04:	189b      	adds	r3, r3, r2
 8016b06:	18c3      	adds	r3, r0, r3
 8016b08:	f103 0319 	add.w	r3, r3, #25
 8016b0c:	460a      	mov	r2, r1
 8016b0e:	701a      	strb	r2, [r3, #0]
		}

		/* remaining short blocks, sfb just keeps incrementing */
		for (    ; nrIdx <= 3; nrIdx++) {
//			iipTest = (1 << slen[nrIdx]) - 1;
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 8016b10:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016b12:	f103 0301 	add.w	r3, r3, #1
 8016b16:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016b18:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016b1a:	f103 0301 	add.w	r3, r3, #1
 8016b1e:	64bb      	str	r3, [r7, #72]	; 0x48
 8016b20:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016b22:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016b26:	f107 0150 	add.w	r1, r7, #80	; 0x50
 8016b2a:	18cb      	adds	r3, r1, r3
 8016b2c:	f853 2c40 	ldr.w	r2, [r3, #-64]
 8016b30:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016b32:	429a      	cmp	r2, r3
 8016b34:	dca1      	bgt.n	8016a7a <UnpackSFMPEG2+0x3fa>
			sfb = 0;
			nrIdx = 0;
		}

		/* remaining short blocks, sfb just keeps incrementing */
		for (    ; nrIdx <= 3; nrIdx++) {
 8016b36:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016b38:	f103 0301 	add.w	r3, r3, #1
 8016b3c:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016b3e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016b40:	2b03      	cmp	r3, #3
 8016b42:	dd96      	ble.n	8016a72 <UnpackSFMPEG2+0x3f2>
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
			}
		}
		/* last sf band not transmitted */
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 8016b44:	687b      	ldr	r3, [r7, #4]
 8016b46:	f04f 0200 	mov.w	r2, #0
 8016b4a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
 8016b4e:	687b      	ldr	r3, [r7, #4]
 8016b50:	f893 203d 	ldrb.w	r2, [r3, #61]	; 0x3d
 8016b54:	687b      	ldr	r3, [r7, #4]
 8016b56:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
 8016b5a:	687b      	ldr	r3, [r7, #4]
 8016b5c:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 8016b60:	687b      	ldr	r3, [r7, #4]
 8016b62:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
 8016b66:	e03e      	b.n	8016be6 <UnpackSFMPEG2+0x566>
	} else {
		/* long blocks */
		sfb = 0;
 8016b68:	f04f 0300 	mov.w	r3, #0
 8016b6c:	64bb      	str	r3, [r7, #72]	; 0x48
		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
 8016b6e:	f04f 0300 	mov.w	r3, #0
 8016b72:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016b74:	e02c      	b.n	8016bd0 <UnpackSFMPEG2+0x550>
//			iipTest = (1 << slen[nrIdx]) - 1;
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 8016b76:	f04f 0300 	mov.w	r3, #0
 8016b7a:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016b7c:	e019      	b.n	8016bb2 <UnpackSFMPEG2+0x532>
				sfis->l[sfb] = (char)GetBits(bsi, slen[nrIdx]);
 8016b7e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016b80:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016b84:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8016b88:	18d3      	adds	r3, r2, r3
 8016b8a:	f853 3c30 	ldr.w	r3, [r3, #-48]
 8016b8e:	68f8      	ldr	r0, [r7, #12]
 8016b90:	4619      	mov	r1, r3
 8016b92:	f7f8 fe2d 	bl	800f7f0 <xmp3_GetBits>
 8016b96:	4603      	mov	r3, r0
 8016b98:	b2da      	uxtb	r2, r3
 8016b9a:	6879      	ldr	r1, [r7, #4]
 8016b9c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016b9e:	18cb      	adds	r3, r1, r3
 8016ba0:	701a      	strb	r2, [r3, #0]
	} else {
		/* long blocks */
		sfb = 0;
		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
//			iipTest = (1 << slen[nrIdx]) - 1;
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 8016ba2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016ba4:	f103 0301 	add.w	r3, r3, #1
 8016ba8:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016baa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016bac:	f103 0301 	add.w	r3, r3, #1
 8016bb0:	64bb      	str	r3, [r7, #72]	; 0x48
 8016bb2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016bb4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016bb8:	f107 0050 	add.w	r0, r7, #80	; 0x50
 8016bbc:	18c3      	adds	r3, r0, r3
 8016bbe:	f853 2c40 	ldr.w	r2, [r3, #-64]
 8016bc2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016bc4:	429a      	cmp	r2, r3
 8016bc6:	dcda      	bgt.n	8016b7e <UnpackSFMPEG2+0x4fe>
		/* last sf band not transmitted */
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
	} else {
		/* long blocks */
		sfb = 0;
		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
 8016bc8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016bca:	f103 0301 	add.w	r3, r3, #1
 8016bce:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016bd0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016bd2:	2b03      	cmp	r3, #3
 8016bd4:	ddcf      	ble.n	8016b76 <UnpackSFMPEG2+0x4f6>
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
				sfis->l[sfb] = (char)GetBits(bsi, slen[nrIdx]);
			}
		}
		/* last sf band not transmitted */
		sfis->l[21] = sfis->l[22] = 0;
 8016bd6:	687b      	ldr	r3, [r7, #4]
 8016bd8:	f04f 0200 	mov.w	r2, #0
 8016bdc:	759a      	strb	r2, [r3, #22]
 8016bde:	687b      	ldr	r3, [r7, #4]
 8016be0:	7d9a      	ldrb	r2, [r3, #22]
 8016be2:	687b      	ldr	r3, [r7, #4]
 8016be4:	755a      	strb	r2, [r3, #21]

	}
}
 8016be6:	f107 0750 	add.w	r7, r7, #80	; 0x50
 8016bea:	46bd      	mov	sp, r7
 8016bec:	bd80      	pop	{r7, pc}
 8016bee:	bf00      	nop

08016bf0 <xmp3_UnpackScaleFactors>:
 *              updated bitOffset
 *
 * Return:      length (in bytes) of scale factor data, -1 if null input pointers
 **************************************************************************************/
int UnpackScaleFactors(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int bitsAvail, int gr, int ch)
{
 8016bf0:	b5b0      	push	{r4, r5, r7, lr}
 8016bf2:	b092      	sub	sp, #72	; 0x48
 8016bf4:	af04      	add	r7, sp, #16
 8016bf6:	60f8      	str	r0, [r7, #12]
 8016bf8:	60b9      	str	r1, [r7, #8]
 8016bfa:	607a      	str	r2, [r7, #4]
 8016bfc:	603b      	str	r3, [r7, #0]
	FrameHeader *fh;
	SideInfo *si;
	ScaleFactorInfo *sfi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS)
 8016bfe:	68fb      	ldr	r3, [r7, #12]
 8016c00:	2b00      	cmp	r3, #0
 8016c02:	d00b      	beq.n	8016c1c <xmp3_UnpackScaleFactors+0x2c>
 8016c04:	68fb      	ldr	r3, [r7, #12]
 8016c06:	681b      	ldr	r3, [r3, #0]
 8016c08:	2b00      	cmp	r3, #0
 8016c0a:	d007      	beq.n	8016c1c <xmp3_UnpackScaleFactors+0x2c>
 8016c0c:	68fb      	ldr	r3, [r7, #12]
 8016c0e:	685b      	ldr	r3, [r3, #4]
 8016c10:	2b00      	cmp	r3, #0
 8016c12:	d003      	beq.n	8016c1c <xmp3_UnpackScaleFactors+0x2c>
 8016c14:	68fb      	ldr	r3, [r7, #12]
 8016c16:	689b      	ldr	r3, [r3, #8]
 8016c18:	2b00      	cmp	r3, #0
 8016c1a:	d102      	bne.n	8016c22 <xmp3_UnpackScaleFactors+0x32>
		return -1;
 8016c1c:	f04f 33ff 	mov.w	r3, #4294967295
 8016c20:	e0db      	b.n	8016dda <xmp3_UnpackScaleFactors+0x1ea>
	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
 8016c22:	68fb      	ldr	r3, [r7, #12]
 8016c24:	681b      	ldr	r3, [r3, #0]
 8016c26:	637b      	str	r3, [r7, #52]	; 0x34
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
 8016c28:	68fb      	ldr	r3, [r7, #12]
 8016c2a:	685b      	ldr	r3, [r3, #4]
 8016c2c:	633b      	str	r3, [r7, #48]	; 0x30
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));
 8016c2e:	68fb      	ldr	r3, [r7, #12]
 8016c30:	689b      	ldr	r3, [r3, #8]
 8016c32:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* init GetBits reader */
	startBuf = buf;
 8016c34:	68bb      	ldr	r3, [r7, #8]
 8016c36:	62bb      	str	r3, [r7, #40]	; 0x28
	bsi = &bitStreamInfo;
 8016c38:	f107 0310 	add.w	r3, r7, #16
 8016c3c:	627b      	str	r3, [r7, #36]	; 0x24
	SetBitstreamPointer(bsi, (bitsAvail + *bitOffset + 7) / 8, buf);
 8016c3e:	687b      	ldr	r3, [r7, #4]
 8016c40:	681a      	ldr	r2, [r3, #0]
 8016c42:	683b      	ldr	r3, [r7, #0]
 8016c44:	18d3      	adds	r3, r2, r3
 8016c46:	f103 0307 	add.w	r3, r3, #7
 8016c4a:	2b00      	cmp	r3, #0
 8016c4c:	da01      	bge.n	8016c52 <xmp3_UnpackScaleFactors+0x62>
 8016c4e:	f103 0307 	add.w	r3, r3, #7
 8016c52:	ea4f 03e3 	mov.w	r3, r3, asr #3
 8016c56:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8016c58:	4619      	mov	r1, r3
 8016c5a:	68ba      	ldr	r2, [r7, #8]
 8016c5c:	f7f8 fd26 	bl	800f6ac <xmp3_SetBitstreamPointer>
	if (*bitOffset)
 8016c60:	687b      	ldr	r3, [r7, #4]
 8016c62:	681b      	ldr	r3, [r3, #0]
 8016c64:	2b00      	cmp	r3, #0
 8016c66:	d005      	beq.n	8016c74 <xmp3_UnpackScaleFactors+0x84>
		GetBits(bsi, *bitOffset);
 8016c68:	687b      	ldr	r3, [r7, #4]
 8016c6a:	681b      	ldr	r3, [r3, #0]
 8016c6c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8016c6e:	4619      	mov	r1, r3
 8016c70:	f7f8 fdbe 	bl	800f7f0 <xmp3_GetBits>

	if (fh->ver == MPEG1) 
 8016c74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016c76:	781b      	ldrb	r3, [r3, #0]
 8016c78:	2b00      	cmp	r3, #0
 8016c7a:	d13e      	bne.n	8016cfa <xmp3_UnpackScaleFactors+0x10a>
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 8016c7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016c7e:	f103 0128 	add.w	r1, r3, #40	; 0x28
 8016c82:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016c84:	4613      	mov	r3, r2
 8016c86:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016c8a:	189b      	adds	r3, r3, r2
 8016c8c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8016c90:	4618      	mov	r0, r3
 8016c92:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8016c94:	4613      	mov	r3, r2
 8016c96:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016c9a:	189b      	adds	r3, r3, r2
 8016c9c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016ca0:	18c3      	adds	r3, r0, r3
 8016ca2:	18c9      	adds	r1, r1, r3
 8016ca4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8016ca6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016ca8:	4613      	mov	r3, r2
 8016caa:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8016cae:	1a9b      	subs	r3, r3, r2
 8016cb0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016cb4:	461c      	mov	r4, r3
 8016cb6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8016cb8:	4613      	mov	r3, r2
 8016cba:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8016cbe:	1a9b      	subs	r3, r3, r2
 8016cc0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016cc4:	18e3      	adds	r3, r4, r3
 8016cc6:	18c5      	adds	r5, r0, r3
 8016cc8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016cca:	f103 0208 	add.w	r2, r3, #8
 8016cce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016cd0:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8016cd4:	18d4      	adds	r4, r2, r3
 8016cd6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8016cd8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8016cda:	4613      	mov	r3, r2
 8016cdc:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8016ce0:	1a9b      	subs	r3, r3, r2
 8016ce2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016ce6:	18c3      	adds	r3, r0, r3
 8016ce8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016cea:	9200      	str	r2, [sp, #0]
 8016cec:	9301      	str	r3, [sp, #4]
 8016cee:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8016cf0:	462a      	mov	r2, r5
 8016cf2:	4623      	mov	r3, r4
 8016cf4:	f7ff fb20 	bl	8016338 <UnpackSFMPEG1>
 8016cf8:	e033      	b.n	8016d62 <xmp3_UnpackScaleFactors+0x172>
	else 
		UnpackSFMPEG2(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], gr, ch, fh->modeExt, &sfi->sfjs);
 8016cfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016cfc:	f103 0128 	add.w	r1, r3, #40	; 0x28
 8016d00:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016d02:	4613      	mov	r3, r2
 8016d04:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016d08:	189b      	adds	r3, r3, r2
 8016d0a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8016d0e:	4618      	mov	r0, r3
 8016d10:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8016d12:	4613      	mov	r3, r2
 8016d14:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016d18:	189b      	adds	r3, r3, r2
 8016d1a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016d1e:	18c3      	adds	r3, r0, r3
 8016d20:	18c9      	adds	r1, r1, r3
 8016d22:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8016d24:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016d26:	4613      	mov	r3, r2
 8016d28:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8016d2c:	1a9b      	subs	r3, r3, r2
 8016d2e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016d32:	461c      	mov	r4, r3
 8016d34:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8016d36:	4613      	mov	r3, r2
 8016d38:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8016d3c:	1a9b      	subs	r3, r3, r2
 8016d3e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016d42:	18e3      	adds	r3, r4, r3
 8016d44:	18c3      	adds	r3, r0, r3
 8016d46:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8016d48:	6a10      	ldr	r0, [r2, #32]
 8016d4a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016d4c:	f102 02f8 	add.w	r2, r2, #248	; 0xf8
 8016d50:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
 8016d52:	9400      	str	r4, [sp, #0]
 8016d54:	9001      	str	r0, [sp, #4]
 8016d56:	9202      	str	r2, [sp, #8]
 8016d58:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8016d5a:	461a      	mov	r2, r3
 8016d5c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016d5e:	f7ff fc8f 	bl	8016680 <UnpackSFMPEG2>

	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 8016d62:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8016d64:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016d66:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8016d68:	461a      	mov	r2, r3
 8016d6a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8016d6e:	18d2      	adds	r2, r2, r3
 8016d70:	ea4f 03c2 	mov.w	r3, r2, lsl #3
 8016d74:	461a      	mov	r2, r3
 8016d76:	460b      	mov	r3, r1
 8016d78:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016d7c:	185b      	adds	r3, r3, r1
 8016d7e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8016d82:	18d3      	adds	r3, r2, r3
 8016d84:	18c3      	adds	r3, r0, r3
 8016d86:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8016d8a:	6819      	ldr	r1, [r3, #0]
 8016d8c:	68fb      	ldr	r3, [r7, #12]
 8016d8e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016d90:	ea4f 0042 	mov.w	r0, r2, lsl #1
 8016d94:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8016d96:	1882      	adds	r2, r0, r2
 8016d98:	f502 72fc 	add.w	r2, r2, #504	; 0x1f8
 8016d9c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 8016da0:	687b      	ldr	r3, [r7, #4]
 8016da2:	681b      	ldr	r3, [r3, #0]
 8016da4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8016da6:	68b9      	ldr	r1, [r7, #8]
 8016da8:	461a      	mov	r2, r3
 8016daa:	f7f8 fd6f 	bl	800f88c <xmp3_CalcBitsUsed>
 8016dae:	4603      	mov	r3, r0
 8016db0:	623b      	str	r3, [r7, #32]
	buf += (bitsUsed + *bitOffset) >> 3;
 8016db2:	687b      	ldr	r3, [r7, #4]
 8016db4:	681a      	ldr	r2, [r3, #0]
 8016db6:	6a3b      	ldr	r3, [r7, #32]
 8016db8:	18d3      	adds	r3, r2, r3
 8016dba:	ea4f 03e3 	mov.w	r3, r3, asr #3
 8016dbe:	68ba      	ldr	r2, [r7, #8]
 8016dc0:	18d3      	adds	r3, r2, r3
 8016dc2:	60bb      	str	r3, [r7, #8]
	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 8016dc4:	687b      	ldr	r3, [r7, #4]
 8016dc6:	681a      	ldr	r2, [r3, #0]
 8016dc8:	6a3b      	ldr	r3, [r7, #32]
 8016dca:	18d3      	adds	r3, r2, r3
 8016dcc:	f003 0207 	and.w	r2, r3, #7
 8016dd0:	687b      	ldr	r3, [r7, #4]
 8016dd2:	601a      	str	r2, [r3, #0]

	return (buf - startBuf);
 8016dd4:	68ba      	ldr	r2, [r7, #8]
 8016dd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016dd8:	1ad3      	subs	r3, r2, r3
}
 8016dda:	4618      	mov	r0, r3
 8016ddc:	f107 0738 	add.w	r7, r7, #56	; 0x38
 8016de0:	46bd      	mov	sp, r7
 8016de2:	bdb0      	pop	{r4, r5, r7, pc}

08016de4 <MULSHIFT32>:


#if defined(__GNUC__) && defined(__arm__)

static __inline__ int MULSHIFT32(int x, int y)
{
 8016de4:	b490      	push	{r4, r7}
 8016de6:	b084      	sub	sp, #16
 8016de8:	af00      	add	r7, sp, #0
 8016dea:	6078      	str	r0, [r7, #4]
 8016dec:	6039      	str	r1, [r7, #0]
int zlow;
__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 8016dee:	687a      	ldr	r2, [r7, #4]
 8016df0:	683b      	ldr	r3, [r7, #0]
 8016df2:	fb82 4303 	smull	r4, r3, r2, r3
 8016df6:	60fc      	str	r4, [r7, #12]
 8016df8:	603b      	str	r3, [r7, #0]
return y;
 8016dfa:	683b      	ldr	r3, [r7, #0]
}
 8016dfc:	4618      	mov	r0, r3
 8016dfe:	f107 0710 	add.w	r7, r7, #16
 8016e02:	46bd      	mov	sp, r7
 8016e04:	bc90      	pop	{r4, r7}
 8016e06:	4770      	bx	lr

08016e08 <FASTABS>:

	return (short)x;
}

static __inline int FASTABS(int x)
{
 8016e08:	b480      	push	{r7}
 8016e0a:	b085      	sub	sp, #20
 8016e0c:	af00      	add	r7, sp, #0
 8016e0e:	6078      	str	r0, [r7, #4]
int sign;

sign = x >> (sizeof(int) * 8 - 1);
 8016e10:	687b      	ldr	r3, [r7, #4]
 8016e12:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8016e16:	60fb      	str	r3, [r7, #12]
x ^= sign;
 8016e18:	687a      	ldr	r2, [r7, #4]
 8016e1a:	68fb      	ldr	r3, [r7, #12]
 8016e1c:	4053      	eors	r3, r2
 8016e1e:	607b      	str	r3, [r7, #4]
x -= sign;
 8016e20:	687a      	ldr	r2, [r7, #4]
 8016e22:	68fb      	ldr	r3, [r7, #12]
 8016e24:	1ad3      	subs	r3, r2, r3
 8016e26:	607b      	str	r3, [r7, #4]

return x;
 8016e28:	687b      	ldr	r3, [r7, #4]
}
 8016e2a:	4618      	mov	r0, r3
 8016e2c:	f107 0714 	add.w	r7, r7, #20
 8016e30:	46bd      	mov	sp, r7
 8016e32:	bc80      	pop	{r7}
 8016e34:	4770      	bx	lr
 8016e36:	bf00      	nop

08016e38 <xmp3_MidSideProc>:
 * Return:      none
 *
 * Notes:       assume at least 1 GB in input
 **************************************************************************************/
void MidSideProc(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, int mOut[2])  
{
 8016e38:	b580      	push	{r7, lr}
 8016e3a:	b08a      	sub	sp, #40	; 0x28
 8016e3c:	af00      	add	r7, sp, #0
 8016e3e:	60f8      	str	r0, [r7, #12]
 8016e40:	60b9      	str	r1, [r7, #8]
 8016e42:	607a      	str	r2, [r7, #4]
	int i, xr, xl, mOutL, mOutR;
	
	/* L = (M+S)/sqrt(2), R = (M-S)/sqrt(2) 
	 * NOTE: 1/sqrt(2) done in DequantChannel() - see comments there
	 */
	mOutL = mOutR = 0;
 8016e44:	f04f 0300 	mov.w	r3, #0
 8016e48:	61fb      	str	r3, [r7, #28]
 8016e4a:	69fb      	ldr	r3, [r7, #28]
 8016e4c:	623b      	str	r3, [r7, #32]
	for(i = 0; i < nSamps; i++) {
 8016e4e:	f04f 0300 	mov.w	r3, #0
 8016e52:	627b      	str	r3, [r7, #36]	; 0x24
 8016e54:	e037      	b.n	8016ec6 <xmp3_MidSideProc+0x8e>
		xl = x[0][i];
 8016e56:	68fb      	ldr	r3, [r7, #12]
 8016e58:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016e5a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8016e5e:	61bb      	str	r3, [r7, #24]
		xr = x[1][i];
 8016e60:	68fb      	ldr	r3, [r7, #12]
 8016e62:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8016e66:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016e68:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8016e6c:	617b      	str	r3, [r7, #20]
		x[0][i] = xl + xr;
 8016e6e:	69ba      	ldr	r2, [r7, #24]
 8016e70:	697b      	ldr	r3, [r7, #20]
 8016e72:	18d1      	adds	r1, r2, r3
 8016e74:	68fb      	ldr	r3, [r7, #12]
 8016e76:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016e78:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		x[1][i] = xl - xr;
 8016e7c:	68fb      	ldr	r3, [r7, #12]
 8016e7e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8016e82:	69b9      	ldr	r1, [r7, #24]
 8016e84:	697a      	ldr	r2, [r7, #20]
 8016e86:	1a89      	subs	r1, r1, r2
 8016e88:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016e8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		mOutL |= FASTABS(x[0][i]);
 8016e8e:	68fb      	ldr	r3, [r7, #12]
 8016e90:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016e92:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8016e96:	4618      	mov	r0, r3
 8016e98:	f7ff ffb6 	bl	8016e08 <FASTABS>
 8016e9c:	4603      	mov	r3, r0
 8016e9e:	6a3a      	ldr	r2, [r7, #32]
 8016ea0:	4313      	orrs	r3, r2
 8016ea2:	623b      	str	r3, [r7, #32]
		mOutR |= FASTABS(x[1][i]);
 8016ea4:	68fb      	ldr	r3, [r7, #12]
 8016ea6:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8016eaa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016eac:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8016eb0:	4618      	mov	r0, r3
 8016eb2:	f7ff ffa9 	bl	8016e08 <FASTABS>
 8016eb6:	4603      	mov	r3, r0
 8016eb8:	69fa      	ldr	r2, [r7, #28]
 8016eba:	4313      	orrs	r3, r2
 8016ebc:	61fb      	str	r3, [r7, #28]
	
	/* L = (M+S)/sqrt(2), R = (M-S)/sqrt(2) 
	 * NOTE: 1/sqrt(2) done in DequantChannel() - see comments there
	 */
	mOutL = mOutR = 0;
	for(i = 0; i < nSamps; i++) {
 8016ebe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016ec0:	f103 0301 	add.w	r3, r3, #1
 8016ec4:	627b      	str	r3, [r7, #36]	; 0x24
 8016ec6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016ec8:	68bb      	ldr	r3, [r7, #8]
 8016eca:	429a      	cmp	r2, r3
 8016ecc:	dbc3      	blt.n	8016e56 <xmp3_MidSideProc+0x1e>
		x[0][i] = xl + xr;
		x[1][i] = xl - xr;
		mOutL |= FASTABS(x[0][i]);
		mOutR |= FASTABS(x[1][i]);
	}
	mOut[0] |= mOutL;
 8016ece:	687b      	ldr	r3, [r7, #4]
 8016ed0:	681a      	ldr	r2, [r3, #0]
 8016ed2:	6a3b      	ldr	r3, [r7, #32]
 8016ed4:	431a      	orrs	r2, r3
 8016ed6:	687b      	ldr	r3, [r7, #4]
 8016ed8:	601a      	str	r2, [r3, #0]
	mOut[1] |= mOutR;
 8016eda:	687b      	ldr	r3, [r7, #4]
 8016edc:	f103 0304 	add.w	r3, r3, #4
 8016ee0:	687a      	ldr	r2, [r7, #4]
 8016ee2:	f102 0204 	add.w	r2, r2, #4
 8016ee6:	6811      	ldr	r1, [r2, #0]
 8016ee8:	69fa      	ldr	r2, [r7, #28]
 8016eea:	430a      	orrs	r2, r1
 8016eec:	601a      	str	r2, [r3, #0]
}
 8016eee:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8016ef2:	46bd      	mov	sp, r7
 8016ef4:	bd80      	pop	{r7, pc}
 8016ef6:	bf00      	nop

08016ef8 <xmp3_IntensityProcMPEG1>:
 * TODO:        combine MPEG1/2 into one function (maybe)
 *              make sure all the mixed-block and IIP logic is right
 **************************************************************************************/
void IntensityProcMPEG1(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, int midSideFlag, int mixFlag, int mOut[2])
{
 8016ef8:	b580      	push	{r7, lr}
 8016efa:	b09c      	sub	sp, #112	; 0x70
 8016efc:	af00      	add	r7, sp, #0
 8016efe:	60f8      	str	r0, [r7, #12]
 8016f00:	60b9      	str	r1, [r7, #8]
 8016f02:	607a      	str	r2, [r7, #4]
 8016f04:	603b      	str	r3, [r7, #0]
	int i=0, j=0, n=0, cb=0, w=0;
 8016f06:	f04f 0300 	mov.w	r3, #0
 8016f0a:	66fb      	str	r3, [r7, #108]	; 0x6c
 8016f0c:	f04f 0300 	mov.w	r3, #0
 8016f10:	66bb      	str	r3, [r7, #104]	; 0x68
 8016f12:	f04f 0300 	mov.w	r3, #0
 8016f16:	63bb      	str	r3, [r7, #56]	; 0x38
 8016f18:	f04f 0300 	mov.w	r3, #0
 8016f1c:	667b      	str	r3, [r7, #100]	; 0x64
 8016f1e:	f04f 0300 	mov.w	r3, #0
 8016f22:	663b      	str	r3, [r7, #96]	; 0x60
	int sampsLeft, isf, mOutL, mOutR, xl, xr;
	int fl, fr, fls[3], frs[3];
	int cbStartL=0, cbStartS=0, cbEndL=0, cbEndS=0;
 8016f24:	f04f 0300 	mov.w	r3, #0
 8016f28:	64bb      	str	r3, [r7, #72]	; 0x48
 8016f2a:	f04f 0300 	mov.w	r3, #0
 8016f2e:	647b      	str	r3, [r7, #68]	; 0x44
 8016f30:	f04f 0300 	mov.w	r3, #0
 8016f34:	643b      	str	r3, [r7, #64]	; 0x40
 8016f36:	f04f 0300 	mov.w	r3, #0
 8016f3a:	63fb      	str	r3, [r7, #60]	; 0x3c
	 *  short block section (i.e. on or after sample 36 = sfBand->l[8] = 3*sfBand->s[3]
	 * is this a safe assumption?
	 * TODO - intensity + mixed not quite right (diff = 11 on he_mode)
	 *  figure out correct implementation (spec ambiguous about when to do short block reorder)
	 */
	if (cbi[1].cbType == 0) {
 8016f3c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8016f3e:	f103 0318 	add.w	r3, r3, #24
 8016f42:	681b      	ldr	r3, [r3, #0]
 8016f44:	2b00      	cmp	r3, #0
 8016f46:	d118      	bne.n	8016f7a <xmp3_IntensityProcMPEG1+0x82>
		/* long block */
		cbStartL = cbi[1].cbEndL + 1;
 8016f48:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8016f4a:	f103 0318 	add.w	r3, r3, #24
 8016f4e:	695b      	ldr	r3, [r3, #20]
 8016f50:	f103 0301 	add.w	r3, r3, #1
 8016f54:	64bb      	str	r3, [r7, #72]	; 0x48
		cbEndL =   cbi[0].cbEndL + 1;
 8016f56:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8016f58:	695b      	ldr	r3, [r3, #20]
 8016f5a:	f103 0301 	add.w	r3, r3, #1
 8016f5e:	643b      	str	r3, [r7, #64]	; 0x40
		cbStartS = cbEndS = 0;
 8016f60:	f04f 0300 	mov.w	r3, #0
 8016f64:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016f66:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016f68:	647b      	str	r3, [r7, #68]	; 0x44
		i = fh->sfBand->l[cbStartL];
 8016f6a:	687b      	ldr	r3, [r7, #4]
 8016f6c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016f6e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016f70:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8016f74:	b21b      	sxth	r3, r3
 8016f76:	66fb      	str	r3, [r7, #108]	; 0x6c
 8016f78:	e02b      	b.n	8016fd2 <xmp3_IntensityProcMPEG1+0xda>
	} else if (cbi[1].cbType == 1 || cbi[1].cbType == 2) {
 8016f7a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8016f7c:	f103 0318 	add.w	r3, r3, #24
 8016f80:	681b      	ldr	r3, [r3, #0]
 8016f82:	2b01      	cmp	r3, #1
 8016f84:	d005      	beq.n	8016f92 <xmp3_IntensityProcMPEG1+0x9a>
 8016f86:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8016f88:	f103 0318 	add.w	r3, r3, #24
 8016f8c:	681b      	ldr	r3, [r3, #0]
 8016f8e:	2b02      	cmp	r3, #2
 8016f90:	d11f      	bne.n	8016fd2 <xmp3_IntensityProcMPEG1+0xda>
		/* short or mixed block */
		cbStartS = cbi[1].cbEndSMax + 1;
 8016f92:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8016f94:	f103 0318 	add.w	r3, r3, #24
 8016f98:	691b      	ldr	r3, [r3, #16]
 8016f9a:	f103 0301 	add.w	r3, r3, #1
 8016f9e:	647b      	str	r3, [r7, #68]	; 0x44
		cbEndS =   cbi[0].cbEndSMax + 1;
 8016fa0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8016fa2:	691b      	ldr	r3, [r3, #16]
 8016fa4:	f103 0301 	add.w	r3, r3, #1
 8016fa8:	63fb      	str	r3, [r7, #60]	; 0x3c
		cbStartL = cbEndL = 0;
 8016faa:	f04f 0300 	mov.w	r3, #0
 8016fae:	643b      	str	r3, [r7, #64]	; 0x40
 8016fb0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016fb2:	64bb      	str	r3, [r7, #72]	; 0x48
		i = 3 * fh->sfBand->s[cbStartS];
 8016fb4:	687b      	ldr	r3, [r7, #4]
 8016fb6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8016fb8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016fba:	f103 0314 	add.w	r3, r3, #20
 8016fbe:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016fc2:	18d3      	adds	r3, r2, r3
 8016fc4:	88db      	ldrh	r3, [r3, #6]
 8016fc6:	b21a      	sxth	r2, r3
 8016fc8:	4613      	mov	r3, r2
 8016fca:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8016fce:	189b      	adds	r3, r3, r2
 8016fd0:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	sampsLeft = nSamps - i;		/* process to length of left */
 8016fd2:	68ba      	ldr	r2, [r7, #8]
 8016fd4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8016fd6:	1ad3      	subs	r3, r2, r3
 8016fd8:	65fb      	str	r3, [r7, #92]	; 0x5c
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8016fda:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8016fdc:	4613      	mov	r3, r2
 8016fde:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016fe2:	1a9b      	subs	r3, r3, r2
 8016fe4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016fe8:	461a      	mov	r2, r3
 8016fea:	f24e 53bc 	movw	r3, #58812	; 0xe5bc
 8016fee:	f6c0 0302 	movt	r3, #2050	; 0x802
 8016ff2:	18d3      	adds	r3, r2, r3
 8016ff4:	637b      	str	r3, [r7, #52]	; 0x34
	mOutL = mOutR = 0;
 8016ff6:	f04f 0300 	mov.w	r3, #0
 8016ffa:	657b      	str	r3, [r7, #84]	; 0x54
 8016ffc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016ffe:	65bb      	str	r3, [r7, #88]	; 0x58

	/* long blocks */
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 8017000:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017002:	667b      	str	r3, [r7, #100]	; 0x64
 8017004:	e08a      	b.n	801711c <xmp3_IntensityProcMPEG1+0x224>
		isf = sfis->l[cb];
 8017006:	683a      	ldr	r2, [r7, #0]
 8017008:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801700a:	18d3      	adds	r3, r2, r3
 801700c:	781b      	ldrb	r3, [r3, #0]
 801700e:	633b      	str	r3, [r7, #48]	; 0x30
		if (isf == 7) {
 8017010:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017012:	2b07      	cmp	r3, #7
 8017014:	d112      	bne.n	801703c <xmp3_IntensityProcMPEG1+0x144>
			fl = ISFIIP[midSideFlag][0];
 8017016:	f24e 63f4 	movw	r3, #59124	; 0xe6f4
 801701a:	f6c0 0302 	movt	r3, #2050	; 0x802
 801701e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8017020:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8017024:	653b      	str	r3, [r7, #80]	; 0x50
			fr = ISFIIP[midSideFlag][1];
 8017026:	f24e 62f4 	movw	r2, #59124	; 0xe6f4
 801702a:	f6c0 0202 	movt	r2, #2050	; 0x802
 801702e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8017030:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8017034:	18d3      	adds	r3, r2, r3
 8017036:	685b      	ldr	r3, [r3, #4]
 8017038:	64fb      	str	r3, [r7, #76]	; 0x4c
 801703a:	e012      	b.n	8017062 <xmp3_IntensityProcMPEG1+0x16a>
		} else {
			fl = isfTab[isf];	
 801703c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801703e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017042:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8017044:	18d3      	adds	r3, r2, r3
 8017046:	681b      	ldr	r3, [r3, #0]
 8017048:	653b      	str	r3, [r7, #80]	; 0x50
			fr = isfTab[6] - isfTab[isf];
 801704a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801704c:	f103 0318 	add.w	r3, r3, #24
 8017050:	681a      	ldr	r2, [r3, #0]
 8017052:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017054:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017058:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801705a:	18cb      	adds	r3, r1, r3
 801705c:	681b      	ldr	r3, [r3, #0]
 801705e:	1ad3      	subs	r3, r2, r3
 8017060:	64fb      	str	r3, [r7, #76]	; 0x4c
		}

		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8017062:	687b      	ldr	r3, [r7, #4]
 8017064:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8017066:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8017068:	f102 0201 	add.w	r2, r2, #1
 801706c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8017070:	b21a      	sxth	r2, r3
 8017072:	687b      	ldr	r3, [r7, #4]
 8017074:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8017076:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8017078:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 801707c:	b21b      	sxth	r3, r3
 801707e:	1ad3      	subs	r3, r2, r3
 8017080:	63bb      	str	r3, [r7, #56]	; 0x38
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8017082:	f04f 0300 	mov.w	r3, #0
 8017086:	66bb      	str	r3, [r7, #104]	; 0x68
 8017088:	e03d      	b.n	8017106 <xmp3_IntensityProcMPEG1+0x20e>
			xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr; mOutR |= FASTABS(xr);
 801708a:	68fb      	ldr	r3, [r7, #12]
 801708c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801708e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8017092:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8017094:	4619      	mov	r1, r3
 8017096:	f7ff fea5 	bl	8016de4 <MULSHIFT32>
 801709a:	4603      	mov	r3, r0
 801709c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80170a0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80170a2:	68fb      	ldr	r3, [r7, #12]
 80170a4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80170a8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80170aa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80170ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80170b0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80170b2:	f7ff fea9 	bl	8016e08 <FASTABS>
 80170b6:	4603      	mov	r3, r0
 80170b8:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80170ba:	4313      	orrs	r3, r2
 80170bc:	657b      	str	r3, [r7, #84]	; 0x54
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 80170be:	68fb      	ldr	r3, [r7, #12]
 80170c0:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80170c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80170c6:	6d38      	ldr	r0, [r7, #80]	; 0x50
 80170c8:	4619      	mov	r1, r3
 80170ca:	f7ff fe8b 	bl	8016de4 <MULSHIFT32>
 80170ce:	4603      	mov	r3, r0
 80170d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80170d4:	62bb      	str	r3, [r7, #40]	; 0x28
 80170d6:	68fb      	ldr	r3, [r7, #12]
 80170d8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80170da:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80170dc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80170e0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80170e2:	f7ff fe91 	bl	8016e08 <FASTABS>
 80170e6:	4603      	mov	r3, r0
 80170e8:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80170ea:	4313      	orrs	r3, r2
 80170ec:	65bb      	str	r3, [r7, #88]	; 0x58
			sampsLeft--;
 80170ee:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80170f0:	f103 33ff 	add.w	r3, r3, #4294967295
 80170f4:	65fb      	str	r3, [r7, #92]	; 0x5c
			fl = isfTab[isf];	
			fr = isfTab[6] - isfTab[isf];
		}

		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 80170f6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80170f8:	f103 0301 	add.w	r3, r3, #1
 80170fc:	66bb      	str	r3, [r7, #104]	; 0x68
 80170fe:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017100:	f103 0301 	add.w	r3, r3, #1
 8017104:	66fb      	str	r3, [r7, #108]	; 0x6c
 8017106:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8017108:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801710a:	429a      	cmp	r2, r3
 801710c:	da02      	bge.n	8017114 <xmp3_IntensityProcMPEG1+0x21c>
 801710e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8017110:	2b00      	cmp	r3, #0
 8017112:	dcba      	bgt.n	801708a <xmp3_IntensityProcMPEG1+0x192>
	sampsLeft = nSamps - i;		/* process to length of left */
	isfTab = (int *)ISFMpeg1[midSideFlag];
	mOutL = mOutR = 0;

	/* long blocks */
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 8017114:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017116:	f103 0301 	add.w	r3, r3, #1
 801711a:	667b      	str	r3, [r7, #100]	; 0x64
 801711c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801711e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017120:	429a      	cmp	r2, r3
 8017122:	da03      	bge.n	801712c <xmp3_IntensityProcMPEG1+0x234>
 8017124:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8017126:	2b00      	cmp	r3, #0
 8017128:	f73f af6d 	bgt.w	8017006 <xmp3_IntensityProcMPEG1+0x10e>
			sampsLeft--;
		}
	}

	/* short blocks */
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 801712c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801712e:	667b      	str	r3, [r7, #100]	; 0x64
 8017130:	e13c      	b.n	80173ac <xmp3_IntensityProcMPEG1+0x4b4>
		for (w = 0; w < 3; w++) {
 8017132:	f04f 0300 	mov.w	r3, #0
 8017136:	663b      	str	r3, [r7, #96]	; 0x60
 8017138:	e055      	b.n	80171e6 <xmp3_IntensityProcMPEG1+0x2ee>
			isf = sfis->s[cb][w];
 801713a:	6839      	ldr	r1, [r7, #0]
 801713c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801713e:	4613      	mov	r3, r2
 8017140:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017144:	189b      	adds	r3, r3, r2
 8017146:	18ca      	adds	r2, r1, r3
 8017148:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801714a:	18d3      	adds	r3, r2, r3
 801714c:	f103 0317 	add.w	r3, r3, #23
 8017150:	781b      	ldrb	r3, [r3, #0]
 8017152:	633b      	str	r3, [r7, #48]	; 0x30
			if (isf == 7) {
 8017154:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017156:	2b07      	cmp	r3, #7
 8017158:	d120      	bne.n	801719c <xmp3_IntensityProcMPEG1+0x2a4>
				fls[w] = ISFIIP[midSideFlag][0];
 801715a:	f24e 63f4 	movw	r3, #59124	; 0xe6f4
 801715e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8017162:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8017164:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8017168:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801716a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801716e:	f107 0170 	add.w	r1, r7, #112	; 0x70
 8017172:	18cb      	adds	r3, r1, r3
 8017174:	f843 2c54 	str.w	r2, [r3, #-84]
				frs[w] = ISFIIP[midSideFlag][1];
 8017178:	f24e 62f4 	movw	r2, #59124	; 0xe6f4
 801717c:	f6c0 0202 	movt	r2, #2050	; 0x802
 8017180:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8017182:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8017186:	18d3      	adds	r3, r2, r3
 8017188:	685a      	ldr	r2, [r3, #4]
 801718a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801718c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017190:	f107 0170 	add.w	r1, r7, #112	; 0x70
 8017194:	18cb      	adds	r3, r1, r3
 8017196:	f843 2c60 	str.w	r2, [r3, #-96]
 801719a:	e020      	b.n	80171de <xmp3_IntensityProcMPEG1+0x2e6>
			} else {
				fls[w] = isfTab[isf];
 801719c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801719e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80171a2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80171a4:	18d3      	adds	r3, r2, r3
 80171a6:	681a      	ldr	r2, [r3, #0]
 80171a8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80171aa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80171ae:	f107 0170 	add.w	r1, r7, #112	; 0x70
 80171b2:	18cb      	adds	r3, r1, r3
 80171b4:	f843 2c54 	str.w	r2, [r3, #-84]
				frs[w] = isfTab[6] - isfTab[isf];
 80171b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80171ba:	f103 0318 	add.w	r3, r3, #24
 80171be:	681a      	ldr	r2, [r3, #0]
 80171c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80171c2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80171c6:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80171c8:	18cb      	adds	r3, r1, r3
 80171ca:	681b      	ldr	r3, [r3, #0]
 80171cc:	1ad2      	subs	r2, r2, r3
 80171ce:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80171d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80171d4:	f107 0170 	add.w	r1, r7, #112	; 0x70
 80171d8:	18cb      	adds	r3, r1, r3
 80171da:	f843 2c60 	str.w	r2, [r3, #-96]
		}
	}

	/* short blocks */
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
		for (w = 0; w < 3; w++) {
 80171de:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80171e0:	f103 0301 	add.w	r3, r3, #1
 80171e4:	663b      	str	r3, [r7, #96]	; 0x60
 80171e6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80171e8:	2b02      	cmp	r3, #2
 80171ea:	dda6      	ble.n	801713a <xmp3_IntensityProcMPEG1+0x242>
				fls[w] = isfTab[isf];
				frs[w] = isfTab[6] - isfTab[isf];
			}
		}

		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 80171ec:	687b      	ldr	r3, [r7, #4]
 80171ee:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80171f0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80171f2:	f103 0301 	add.w	r3, r3, #1
 80171f6:	f103 0314 	add.w	r3, r3, #20
 80171fa:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80171fe:	18d3      	adds	r3, r2, r3
 8017200:	88db      	ldrh	r3, [r3, #6]
 8017202:	b21a      	sxth	r2, r3
 8017204:	687b      	ldr	r3, [r7, #4]
 8017206:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8017208:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801720a:	f103 0314 	add.w	r3, r3, #20
 801720e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017212:	18cb      	adds	r3, r1, r3
 8017214:	88db      	ldrh	r3, [r3, #6]
 8017216:	b21b      	sxth	r3, r3
 8017218:	1ad3      	subs	r3, r2, r3
 801721a:	63bb      	str	r3, [r7, #56]	; 0x38
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 801721c:	f04f 0300 	mov.w	r3, #0
 8017220:	66bb      	str	r3, [r7, #104]	; 0x68
 8017222:	e0b7      	b.n	8017394 <xmp3_IntensityProcMPEG1+0x49c>
			xr = MULSHIFT32(frs[0], x[0][i+0]) << 2;	x[1][i+0] = xr;	mOutR |= FASTABS(xr);
 8017224:	693a      	ldr	r2, [r7, #16]
 8017226:	68fb      	ldr	r3, [r7, #12]
 8017228:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 801722a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 801722e:	4610      	mov	r0, r2
 8017230:	4619      	mov	r1, r3
 8017232:	f7ff fdd7 	bl	8016de4 <MULSHIFT32>
 8017236:	4603      	mov	r3, r0
 8017238:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801723c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801723e:	68fb      	ldr	r3, [r7, #12]
 8017240:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017244:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8017246:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8017248:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 801724c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801724e:	f7ff fddb 	bl	8016e08 <FASTABS>
 8017252:	4603      	mov	r3, r0
 8017254:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8017256:	4313      	orrs	r3, r2
 8017258:	657b      	str	r3, [r7, #84]	; 0x54
			xl = MULSHIFT32(fls[0], x[0][i+0]) << 2;	x[0][i+0] = xl;	mOutL |= FASTABS(xl);
 801725a:	69fa      	ldr	r2, [r7, #28]
 801725c:	68fb      	ldr	r3, [r7, #12]
 801725e:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 8017260:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8017264:	4610      	mov	r0, r2
 8017266:	4619      	mov	r1, r3
 8017268:	f7ff fdbc 	bl	8016de4 <MULSHIFT32>
 801726c:	4603      	mov	r3, r0
 801726e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017272:	62bb      	str	r3, [r7, #40]	; 0x28
 8017274:	68fb      	ldr	r3, [r7, #12]
 8017276:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8017278:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801727a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 801727e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017280:	f7ff fdc2 	bl	8016e08 <FASTABS>
 8017284:	4603      	mov	r3, r0
 8017286:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8017288:	4313      	orrs	r3, r2
 801728a:	65bb      	str	r3, [r7, #88]	; 0x58
			xr = MULSHIFT32(frs[1], x[0][i+1]) << 2;	x[1][i+1] = xr;	mOutR |= FASTABS(xr);
 801728c:	697a      	ldr	r2, [r7, #20]
 801728e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017290:	f103 0101 	add.w	r1, r3, #1
 8017294:	68fb      	ldr	r3, [r7, #12]
 8017296:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 801729a:	4610      	mov	r0, r2
 801729c:	4619      	mov	r1, r3
 801729e:	f7ff fda1 	bl	8016de4 <MULSHIFT32>
 80172a2:	4603      	mov	r3, r0
 80172a4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80172a8:	62fb      	str	r3, [r7, #44]	; 0x2c
 80172aa:	68fb      	ldr	r3, [r7, #12]
 80172ac:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80172b0:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80172b2:	f102 0201 	add.w	r2, r2, #1
 80172b6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80172b8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80172bc:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80172be:	f7ff fda3 	bl	8016e08 <FASTABS>
 80172c2:	4603      	mov	r3, r0
 80172c4:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80172c6:	4313      	orrs	r3, r2
 80172c8:	657b      	str	r3, [r7, #84]	; 0x54
			xl = MULSHIFT32(fls[1], x[0][i+1]) << 2;	x[0][i+1] = xl;	mOutL |= FASTABS(xl);
 80172ca:	6a3a      	ldr	r2, [r7, #32]
 80172cc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80172ce:	f103 0101 	add.w	r1, r3, #1
 80172d2:	68fb      	ldr	r3, [r7, #12]
 80172d4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80172d8:	4610      	mov	r0, r2
 80172da:	4619      	mov	r1, r3
 80172dc:	f7ff fd82 	bl	8016de4 <MULSHIFT32>
 80172e0:	4603      	mov	r3, r0
 80172e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80172e6:	62bb      	str	r3, [r7, #40]	; 0x28
 80172e8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80172ea:	f103 0201 	add.w	r2, r3, #1
 80172ee:	68fb      	ldr	r3, [r7, #12]
 80172f0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80172f2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80172f6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80172f8:	f7ff fd86 	bl	8016e08 <FASTABS>
 80172fc:	4603      	mov	r3, r0
 80172fe:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8017300:	4313      	orrs	r3, r2
 8017302:	65bb      	str	r3, [r7, #88]	; 0x58
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
 8017304:	69ba      	ldr	r2, [r7, #24]
 8017306:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017308:	f103 0102 	add.w	r1, r3, #2
 801730c:	68fb      	ldr	r3, [r7, #12]
 801730e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8017312:	4610      	mov	r0, r2
 8017314:	4619      	mov	r1, r3
 8017316:	f7ff fd65 	bl	8016de4 <MULSHIFT32>
 801731a:	4603      	mov	r3, r0
 801731c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017320:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017322:	68fb      	ldr	r3, [r7, #12]
 8017324:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017328:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801732a:	f102 0202 	add.w	r2, r2, #2
 801732e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8017330:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8017334:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8017336:	f7ff fd67 	bl	8016e08 <FASTABS>
 801733a:	4603      	mov	r3, r0
 801733c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801733e:	4313      	orrs	r3, r2
 8017340:	657b      	str	r3, [r7, #84]	; 0x54
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8017342:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8017344:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017346:	f103 0102 	add.w	r1, r3, #2
 801734a:	68fb      	ldr	r3, [r7, #12]
 801734c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8017350:	4610      	mov	r0, r2
 8017352:	4619      	mov	r1, r3
 8017354:	f7ff fd46 	bl	8016de4 <MULSHIFT32>
 8017358:	4603      	mov	r3, r0
 801735a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801735e:	62bb      	str	r3, [r7, #40]	; 0x28
 8017360:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017362:	f103 0202 	add.w	r2, r3, #2
 8017366:	68fb      	ldr	r3, [r7, #12]
 8017368:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801736a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 801736e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017370:	f7ff fd4a 	bl	8016e08 <FASTABS>
 8017374:	4603      	mov	r3, r0
 8017376:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8017378:	4313      	orrs	r3, r2
 801737a:	65bb      	str	r3, [r7, #88]	; 0x58
			sampsLeft -= 3;
 801737c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801737e:	f1a3 0303 	sub.w	r3, r3, #3
 8017382:	65fb      	str	r3, [r7, #92]	; 0x5c
				frs[w] = isfTab[6] - isfTab[isf];
			}
		}

		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8017384:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017386:	f103 0301 	add.w	r3, r3, #1
 801738a:	66bb      	str	r3, [r7, #104]	; 0x68
 801738c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801738e:	f103 0303 	add.w	r3, r3, #3
 8017392:	66fb      	str	r3, [r7, #108]	; 0x6c
 8017394:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8017396:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8017398:	429a      	cmp	r2, r3
 801739a:	da03      	bge.n	80173a4 <xmp3_IntensityProcMPEG1+0x4ac>
 801739c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801739e:	2b02      	cmp	r3, #2
 80173a0:	f73f af40 	bgt.w	8017224 <xmp3_IntensityProcMPEG1+0x32c>
			sampsLeft--;
		}
	}

	/* short blocks */
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 80173a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80173a6:	f103 0301 	add.w	r3, r3, #1
 80173aa:	667b      	str	r3, [r7, #100]	; 0x64
 80173ac:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80173ae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80173b0:	429a      	cmp	r2, r3
 80173b2:	da03      	bge.n	80173bc <xmp3_IntensityProcMPEG1+0x4c4>
 80173b4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80173b6:	2b02      	cmp	r3, #2
 80173b8:	f73f aebb 	bgt.w	8017132 <xmp3_IntensityProcMPEG1+0x23a>
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
			sampsLeft -= 3;
		}
	}
	mOut[0] = mOutL;
 80173bc:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80173c0:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80173c2:	601a      	str	r2, [r3, #0]
	mOut[1] = mOutR;
 80173c4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80173c8:	f103 0304 	add.w	r3, r3, #4
 80173cc:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80173ce:	601a      	str	r2, [r3, #0]
	
	return;
}
 80173d0:	f107 0770 	add.w	r7, r7, #112	; 0x70
 80173d4:	46bd      	mov	sp, r7
 80173d6:	bd80      	pop	{r7, pc}

080173d8 <xmp3_IntensityProcMPEG2>:
 *              make sure all the mixed-block and IIP logic is right
 *                probably redo IIP logic to be simpler
 **************************************************************************************/
void IntensityProcMPEG2(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, ScaleFactorJS *sfjs, int midSideFlag, int mixFlag, int mOut[2])
{
 80173d8:	b580      	push	{r7, lr}
 80173da:	b0b2      	sub	sp, #200	; 0xc8
 80173dc:	af00      	add	r7, sp, #0
 80173de:	60f8      	str	r0, [r7, #12]
 80173e0:	60b9      	str	r1, [r7, #8]
 80173e2:	607a      	str	r2, [r7, #4]
 80173e4:	603b      	str	r3, [r7, #0]
	int sampsLeft;
	int isf, sfIdx, tmp, il[23];
	int *isfTab;
	int cbStartL, cbStartS, cbEndL, cbEndS;
	
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 80173e6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80173ea:	681b      	ldr	r3, [r3, #0]
 80173ec:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80173f0:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80173f4:	18d3      	adds	r3, r2, r3
 80173f6:	ea4f 1283 	mov.w	r2, r3, lsl #6
 80173fa:	f24e 53f4 	movw	r3, #58868	; 0xe5f4
 80173fe:	f6c0 0302 	movt	r3, #2050	; 0x802
 8017402:	18d3      	adds	r3, r2, r3
 8017404:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
	mOutL = mOutR = 0;
 8017408:	f04f 0300 	mov.w	r3, #0
 801740c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8017410:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8017414:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4

	/* fill buffer with illegal intensity positions (depending on slen) */
	for (k = r = 0; r < 4; r++) {
 8017418:	f04f 0300 	mov.w	r3, #0
 801741c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8017420:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8017424:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8017428:	e03f      	b.n	80174aa <xmp3_IntensityProcMPEG2+0xd2>
		tmp = (1 << sfjs->slen[r]) - 1;
 801742a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 801742e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8017432:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017436:	18d3      	adds	r3, r2, r3
 8017438:	685b      	ldr	r3, [r3, #4]
 801743a:	f04f 0201 	mov.w	r2, #1
 801743e:	fa02 f303 	lsl.w	r3, r2, r3
 8017442:	f103 33ff 	add.w	r3, r3, #4294967295
 8017446:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 801744a:	f04f 0300 	mov.w	r3, #0
 801744e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8017452:	e016      	b.n	8017482 <xmp3_IntensityProcMPEG2+0xaa>
			il[k] = tmp;
 8017454:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8017458:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801745c:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 8017460:	18d3      	adds	r3, r2, r3
 8017462:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8017466:	f843 2cb4 	str.w	r2, [r3, #-180]
	mOutL = mOutR = 0;

	/* fill buffer with illegal intensity positions (depending on slen) */
	for (k = r = 0; r < 4; r++) {
		tmp = (1 << sfjs->slen[r]) - 1;
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 801746a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 801746e:	f103 0301 	add.w	r3, r3, #1
 8017472:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8017476:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801747a:	f103 0301 	add.w	r3, r3, #1
 801747e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8017482:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8017486:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801748a:	f103 0304 	add.w	r3, r3, #4
 801748e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017492:	18d3      	adds	r3, r2, r3
 8017494:	685a      	ldr	r2, [r3, #4]
 8017496:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 801749a:	429a      	cmp	r2, r3
 801749c:	dcda      	bgt.n	8017454 <xmp3_IntensityProcMPEG2+0x7c>
	
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
	mOutL = mOutR = 0;

	/* fill buffer with illegal intensity positions (depending on slen) */
	for (k = r = 0; r < 4; r++) {
 801749e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80174a2:	f103 0301 	add.w	r3, r3, #1
 80174a6:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 80174aa:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80174ae:	2b03      	cmp	r3, #3
 80174b0:	ddbb      	ble.n	801742a <xmp3_IntensityProcMPEG2+0x52>
		tmp = (1 << sfjs->slen[r]) - 1;
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
			il[k] = tmp;
	}

	if (cbi[1].cbType == 0) {
 80174b2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80174b6:	f103 0318 	add.w	r3, r3, #24
 80174ba:	681b      	ldr	r3, [r3, #0]
 80174bc:	2b00      	cmp	r3, #0
 80174be:	f040 810b 	bne.w	80176d8 <xmp3_IntensityProcMPEG2+0x300>
		/* long blocks */
		il[21] = il[22] = 1;
 80174c2:	f04f 0301 	mov.w	r3, #1
 80174c6:	66fb      	str	r3, [r7, #108]	; 0x6c
 80174c8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80174ca:	66bb      	str	r3, [r7, #104]	; 0x68
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
 80174cc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80174d0:	f103 0318 	add.w	r3, r3, #24
 80174d4:	695b      	ldr	r3, [r3, #20]
 80174d6:	f103 0301 	add.w	r3, r3, #1
 80174da:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
 80174de:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80174e2:	695b      	ldr	r3, [r3, #20]
 80174e4:	f103 0301 	add.w	r3, r3, #1
 80174e8:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
		i = fh->sfBand->l[cbStartL];
 80174ec:	687b      	ldr	r3, [r7, #4]
 80174ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80174f0:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 80174f4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80174f8:	b21b      	sxth	r3, r3
 80174fa:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
		sampsLeft = nSamps - i;
 80174fe:	68ba      	ldr	r2, [r7, #8]
 8017500:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8017504:	1ad3      	subs	r3, r2, r3
 8017506:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

		for(cb = cbStartL; cb < cbEndL; cb++) {
 801750a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801750e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8017512:	e0d9      	b.n	80176c8 <xmp3_IntensityProcMPEG2+0x2f0>
			sfIdx = sfis->l[cb];
 8017514:	683a      	ldr	r2, [r7, #0]
 8017516:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801751a:	18d3      	adds	r3, r2, r3
 801751c:	781b      	ldrb	r3, [r3, #0]
 801751e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			if (sfIdx == il[cb]) {
 8017522:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8017526:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801752a:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 801752e:	18d3      	adds	r3, r2, r3
 8017530:	f853 2cb4 	ldr.w	r2, [r3, #-180]
 8017534:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8017538:	429a      	cmp	r2, r3
 801753a:	d116      	bne.n	801756a <xmp3_IntensityProcMPEG2+0x192>
				fl = ISFIIP[midSideFlag][0];
 801753c:	f24e 63f4 	movw	r3, #59124	; 0xe6f4
 8017540:	f6c0 0302 	movt	r3, #2050	; 0x802
 8017544:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 8017548:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 801754c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
				fr = ISFIIP[midSideFlag][1];
 8017550:	f24e 62f4 	movw	r2, #59124	; 0xe6f4
 8017554:	f6c0 0202 	movt	r2, #2050	; 0x802
 8017558:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801755c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8017560:	18d3      	adds	r3, r2, r3
 8017562:	685b      	ldr	r3, [r3, #4]
 8017564:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8017568:	e031      	b.n	80175ce <xmp3_IntensityProcMPEG2+0x1f6>
			} else {
				isf = (sfis->l[cb] + 1) >> 1;
 801756a:	683a      	ldr	r2, [r7, #0]
 801756c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8017570:	18d3      	adds	r3, r2, r3
 8017572:	781b      	ldrb	r3, [r3, #0]
 8017574:	f103 0301 	add.w	r3, r3, #1
 8017578:	ea4f 0363 	mov.w	r3, r3, asr #1
 801757c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8017580:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8017584:	f003 0301 	and.w	r3, r3, #1
 8017588:	b2db      	uxtb	r3, r3
 801758a:	2b00      	cmp	r3, #0
 801758c:	d004      	beq.n	8017598 <xmp3_IntensityProcMPEG2+0x1c0>
 801758e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017592:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017596:	e001      	b.n	801759c <xmp3_IntensityProcMPEG2+0x1c4>
 8017598:	f04f 0300 	mov.w	r3, #0
 801759c:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80175a0:	18d3      	adds	r3, r2, r3
 80175a2:	681b      	ldr	r3, [r3, #0]
 80175a4:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 80175a8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80175ac:	f003 0301 	and.w	r3, r3, #1
 80175b0:	2b00      	cmp	r3, #0
 80175b2:	d104      	bne.n	80175be <xmp3_IntensityProcMPEG2+0x1e6>
 80175b4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80175b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80175bc:	e001      	b.n	80175c2 <xmp3_IntensityProcMPEG2+0x1ea>
 80175be:	f04f 0300 	mov.w	r3, #0
 80175c2:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80175c6:	18d3      	adds	r3, r2, r3
 80175c8:	681b      	ldr	r3, [r3, #0]
 80175ca:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
			}
			n = MIN(fh->sfBand->l[cb + 1] - fh->sfBand->l[cb], sampsLeft);
 80175ce:	687b      	ldr	r3, [r7, #4]
 80175d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80175d2:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80175d6:	f102 0201 	add.w	r2, r2, #1
 80175da:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80175de:	b21a      	sxth	r2, r3
 80175e0:	687b      	ldr	r3, [r7, #4]
 80175e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80175e4:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 80175e8:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 80175ec:	b21b      	sxth	r3, r3
 80175ee:	1ad2      	subs	r2, r2, r3
 80175f0:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80175f4:	429a      	cmp	r2, r3
 80175f6:	bfb8      	it	lt
 80175f8:	4613      	movlt	r3, r2
 80175fa:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

			for(j = 0; j < n; j++, i++) {
 80175fe:	f04f 0300 	mov.w	r3, #0
 8017602:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8017606:	e047      	b.n	8017698 <xmp3_IntensityProcMPEG2+0x2c0>
				xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 8017608:	68fb      	ldr	r3, [r7, #12]
 801760a:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 801760e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8017612:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8017616:	4619      	mov	r1, r3
 8017618:	f7ff fbe4 	bl	8016de4 <MULSHIFT32>
 801761c:	4603      	mov	r3, r0
 801761e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017622:	67fb      	str	r3, [r7, #124]	; 0x7c
 8017624:	68fb      	ldr	r3, [r7, #12]
 8017626:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 801762a:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 801762e:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 8017630:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8017634:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8017636:	f7ff fbe7 	bl	8016e08 <FASTABS>
 801763a:	4603      	mov	r3, r0
 801763c:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8017640:	4313      	orrs	r3, r2
 8017642:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8017646:	68fb      	ldr	r3, [r7, #12]
 8017648:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 801764c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8017650:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 8017654:	4619      	mov	r1, r3
 8017656:	f7ff fbc5 	bl	8016de4 <MULSHIFT32>
 801765a:	4603      	mov	r3, r0
 801765c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017660:	67bb      	str	r3, [r7, #120]	; 0x78
 8017662:	68fb      	ldr	r3, [r7, #12]
 8017664:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8017668:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 801766a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 801766e:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 8017670:	f7ff fbca 	bl	8016e08 <FASTABS>
 8017674:	4603      	mov	r3, r0
 8017676:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 801767a:	4313      	orrs	r3, r2
 801767c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
			}
			n = MIN(fh->sfBand->l[cb + 1] - fh->sfBand->l[cb], sampsLeft);

			for(j = 0; j < n; j++, i++) {
 8017680:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8017684:	f103 0301 	add.w	r3, r3, #1
 8017688:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 801768c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8017690:	f103 0301 	add.w	r3, r3, #1
 8017694:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8017698:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 801769c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80176a0:	429a      	cmp	r2, r3
 80176a2:	dbb1      	blt.n	8017608 <xmp3_IntensityProcMPEG2+0x230>
				xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
			}

			/* early exit once we've used all the non-zero samples */
			sampsLeft -= n;
 80176a4:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 80176a8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80176ac:	1ad3      	subs	r3, r2, r3
 80176ae:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
			if (sampsLeft == 0)		
 80176b2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80176b6:	2b00      	cmp	r3, #0
 80176b8:	f000 813a 	beq.w	8017930 <xmp3_IntensityProcMPEG2+0x558>
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
		i = fh->sfBand->l[cbStartL];
		sampsLeft = nSamps - i;

		for(cb = cbStartL; cb < cbEndL; cb++) {
 80176bc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80176c0:	f103 0301 	add.w	r3, r3, #1
 80176c4:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 80176c8:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80176cc:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80176d0:	429a      	cmp	r2, r3
 80176d2:	f6ff af1f 	blt.w	8017514 <xmp3_IntensityProcMPEG2+0x13c>
 80176d6:	e12c      	b.n	8017932 <xmp3_IntensityProcMPEG2+0x55a>
			if (sampsLeft == 0)		
				break;
		}
	} else {
		/* short or mixed blocks */
		il[12] = 1;
 80176d8:	f04f 0301 	mov.w	r3, #1
 80176dc:	647b      	str	r3, [r7, #68]	; 0x44

		for(w = 0; w < 3; w++) {
 80176de:	f04f 0300 	mov.w	r3, #0
 80176e2:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 80176e6:	e11d      	b.n	8017924 <xmp3_IntensityProcMPEG2+0x54c>
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 80176e8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80176ec:	f103 0218 	add.w	r2, r3, #24
 80176f0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80176f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80176f8:	18d3      	adds	r3, r2, r3
 80176fa:	685b      	ldr	r3, [r3, #4]
 80176fc:	f103 0301 	add.w	r3, r3, #1
 8017700:	677b      	str	r3, [r7, #116]	; 0x74
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 8017702:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8017706:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801770a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801770e:	18d3      	adds	r3, r2, r3
 8017710:	685b      	ldr	r3, [r3, #4]
 8017712:	f103 0301 	add.w	r3, r3, #1
 8017716:	673b      	str	r3, [r7, #112]	; 0x70
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8017718:	687b      	ldr	r3, [r7, #4]
 801771a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801771c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801771e:	f103 0314 	add.w	r3, r3, #20
 8017722:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017726:	18d3      	adds	r3, r2, r3
 8017728:	88db      	ldrh	r3, [r3, #6]
 801772a:	b21a      	sxth	r2, r3
 801772c:	4613      	mov	r3, r2
 801772e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017732:	189a      	adds	r2, r3, r2
 8017734:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8017738:	18d3      	adds	r3, r2, r3
 801773a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

			/* skip through sample array by 3, so early-exit logic would be more tricky */
			for(cb = cbStartS; cb < cbEndS; cb++) {
 801773e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8017740:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8017744:	e0e2      	b.n	801790c <xmp3_IntensityProcMPEG2+0x534>
				sfIdx = sfis->s[cb][w];
 8017746:	6839      	ldr	r1, [r7, #0]
 8017748:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 801774c:	4613      	mov	r3, r2
 801774e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017752:	189b      	adds	r3, r3, r2
 8017754:	18ca      	adds	r2, r1, r3
 8017756:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801775a:	18d3      	adds	r3, r2, r3
 801775c:	f103 0317 	add.w	r3, r3, #23
 8017760:	781b      	ldrb	r3, [r3, #0]
 8017762:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
				if (sfIdx == il[cb]) {
 8017766:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801776a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801776e:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 8017772:	18d3      	adds	r3, r2, r3
 8017774:	f853 2cb4 	ldr.w	r2, [r3, #-180]
 8017778:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801777c:	429a      	cmp	r2, r3
 801777e:	d116      	bne.n	80177ae <xmp3_IntensityProcMPEG2+0x3d6>
					fl = ISFIIP[midSideFlag][0];
 8017780:	f24e 63f4 	movw	r3, #59124	; 0xe6f4
 8017784:	f6c0 0302 	movt	r3, #2050	; 0x802
 8017788:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 801778c:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8017790:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
					fr = ISFIIP[midSideFlag][1];
 8017794:	f24e 62f4 	movw	r2, #59124	; 0xe6f4
 8017798:	f6c0 0202 	movt	r2, #2050	; 0x802
 801779c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80177a0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80177a4:	18d3      	adds	r3, r2, r3
 80177a6:	685b      	ldr	r3, [r3, #4]
 80177a8:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 80177ac:	e03a      	b.n	8017824 <xmp3_IntensityProcMPEG2+0x44c>
				} else {
					isf = (sfis->s[cb][w] + 1) >> 1;
 80177ae:	6839      	ldr	r1, [r7, #0]
 80177b0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80177b4:	4613      	mov	r3, r2
 80177b6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80177ba:	189b      	adds	r3, r3, r2
 80177bc:	18ca      	adds	r2, r1, r3
 80177be:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80177c2:	18d3      	adds	r3, r2, r3
 80177c4:	f103 0317 	add.w	r3, r3, #23
 80177c8:	781b      	ldrb	r3, [r3, #0]
 80177ca:	f103 0301 	add.w	r3, r3, #1
 80177ce:	ea4f 0363 	mov.w	r3, r3, asr #1
 80177d2:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 80177d6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80177da:	f003 0301 	and.w	r3, r3, #1
 80177de:	b2db      	uxtb	r3, r3
 80177e0:	2b00      	cmp	r3, #0
 80177e2:	d004      	beq.n	80177ee <xmp3_IntensityProcMPEG2+0x416>
 80177e4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80177e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80177ec:	e001      	b.n	80177f2 <xmp3_IntensityProcMPEG2+0x41a>
 80177ee:	f04f 0300 	mov.w	r3, #0
 80177f2:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80177f6:	18d3      	adds	r3, r2, r3
 80177f8:	681b      	ldr	r3, [r3, #0]
 80177fa:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 80177fe:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8017802:	f003 0301 	and.w	r3, r3, #1
 8017806:	2b00      	cmp	r3, #0
 8017808:	d104      	bne.n	8017814 <xmp3_IntensityProcMPEG2+0x43c>
 801780a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801780e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017812:	e001      	b.n	8017818 <xmp3_IntensityProcMPEG2+0x440>
 8017814:	f04f 0300 	mov.w	r3, #0
 8017818:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 801781c:	18d3      	adds	r3, r2, r3
 801781e:	681b      	ldr	r3, [r3, #0]
 8017820:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
				}
				n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8017824:	687b      	ldr	r3, [r7, #4]
 8017826:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8017828:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801782c:	f103 0301 	add.w	r3, r3, #1
 8017830:	f103 0314 	add.w	r3, r3, #20
 8017834:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017838:	18d3      	adds	r3, r2, r3
 801783a:	88db      	ldrh	r3, [r3, #6]
 801783c:	b21a      	sxth	r2, r3
 801783e:	687b      	ldr	r3, [r7, #4]
 8017840:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8017842:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8017846:	f103 0314 	add.w	r3, r3, #20
 801784a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801784e:	18cb      	adds	r3, r1, r3
 8017850:	88db      	ldrh	r3, [r3, #6]
 8017852:	b21b      	sxth	r3, r3
 8017854:	1ad3      	subs	r3, r2, r3
 8017856:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

				for(j = 0; j < n; j++, i+=3) {
 801785a:	f04f 0300 	mov.w	r3, #0
 801785e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8017862:	e047      	b.n	80178f4 <xmp3_IntensityProcMPEG2+0x51c>
					xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 8017864:	68fb      	ldr	r3, [r7, #12]
 8017866:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 801786a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801786e:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8017872:	4619      	mov	r1, r3
 8017874:	f7ff fab6 	bl	8016de4 <MULSHIFT32>
 8017878:	4603      	mov	r3, r0
 801787a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801787e:	67fb      	str	r3, [r7, #124]	; 0x7c
 8017880:	68fb      	ldr	r3, [r7, #12]
 8017882:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017886:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 801788a:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 801788c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8017890:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8017892:	f7ff fab9 	bl	8016e08 <FASTABS>
 8017896:	4603      	mov	r3, r0
 8017898:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 801789c:	4313      	orrs	r3, r2
 801789e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 80178a2:	68fb      	ldr	r3, [r7, #12]
 80178a4:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80178a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80178ac:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 80178b0:	4619      	mov	r1, r3
 80178b2:	f7ff fa97 	bl	8016de4 <MULSHIFT32>
 80178b6:	4603      	mov	r3, r0
 80178b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80178bc:	67bb      	str	r3, [r7, #120]	; 0x78
 80178be:	68fb      	ldr	r3, [r7, #12]
 80178c0:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80178c4:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 80178c6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80178ca:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 80178cc:	f7ff fa9c 	bl	8016e08 <FASTABS>
 80178d0:	4603      	mov	r3, r0
 80178d2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80178d6:	4313      	orrs	r3, r2
 80178d8:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
				}
				n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];

				for(j = 0; j < n; j++, i+=3) {
 80178dc:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80178e0:	f103 0301 	add.w	r3, r3, #1
 80178e4:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 80178e8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80178ec:	f103 0303 	add.w	r3, r3, #3
 80178f0:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 80178f4:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80178f8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80178fc:	429a      	cmp	r2, r3
 80178fe:	dbb1      	blt.n	8017864 <xmp3_IntensityProcMPEG2+0x48c>
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
			i = 3 * fh->sfBand->s[cbStartS] + w;

			/* skip through sample array by 3, so early-exit logic would be more tricky */
			for(cb = cbStartS; cb < cbEndS; cb++) {
 8017900:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8017904:	f103 0301 	add.w	r3, r3, #1
 8017908:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 801790c:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8017910:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8017912:	429a      	cmp	r2, r3
 8017914:	f6ff af17 	blt.w	8017746 <xmp3_IntensityProcMPEG2+0x36e>
		}
	} else {
		/* short or mixed blocks */
		il[12] = 1;

		for(w = 0; w < 3; w++) {
 8017918:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801791c:	f103 0301 	add.w	r3, r3, #1
 8017920:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8017924:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8017928:	2b02      	cmp	r3, #2
 801792a:	f77f aedd 	ble.w	80176e8 <xmp3_IntensityProcMPEG2+0x310>
 801792e:	e000      	b.n	8017932 <xmp3_IntensityProcMPEG2+0x55a>
			}

			/* early exit once we've used all the non-zero samples */
			sampsLeft -= n;
			if (sampsLeft == 0)		
				break;
 8017930:	bf00      	nop
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
				}
			}
		}
	}
	mOut[0] = mOutL;
 8017932:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8017936:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 801793a:	601a      	str	r2, [r3, #0]
	mOut[1] = mOutR;
 801793c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8017940:	f103 0304 	add.w	r3, r3, #4
 8017944:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8017948:	601a      	str	r2, [r3, #0]

	return;
}
 801794a:	f107 07c8 	add.w	r7, r7, #200	; 0xc8
 801794e:	46bd      	mov	sp, r7
 8017950:	bd80      	pop	{r7, pc}
 8017952:	bf00      	nop

08017954 <xmp3_Subband>:
 * Outputs:     decoded PCM data, interleaved LRLRLR... if stereo
 *
 * Return:      0 on success,  -1 if null input pointers
 **************************************************************************************/
int Subband(MP3DecInfo *mp3DecInfo, short *pcmBuf)
{
 8017954:	b590      	push	{r4, r7, lr}
 8017956:	b089      	sub	sp, #36	; 0x24
 8017958:	af02      	add	r7, sp, #8
 801795a:	6078      	str	r0, [r7, #4]
 801795c:	6039      	str	r1, [r7, #0]
//	HuffmanInfo *hi;
	IMDCTInfo *mi;
	SubbandInfo *sbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 801795e:	687b      	ldr	r3, [r7, #4]
 8017960:	2b00      	cmp	r3, #0
 8017962:	d00b      	beq.n	801797c <xmp3_Subband+0x28>
 8017964:	687b      	ldr	r3, [r7, #4]
 8017966:	68db      	ldr	r3, [r3, #12]
 8017968:	2b00      	cmp	r3, #0
 801796a:	d007      	beq.n	801797c <xmp3_Subband+0x28>
 801796c:	687b      	ldr	r3, [r7, #4]
 801796e:	695b      	ldr	r3, [r3, #20]
 8017970:	2b00      	cmp	r3, #0
 8017972:	d003      	beq.n	801797c <xmp3_Subband+0x28>
 8017974:	687b      	ldr	r3, [r7, #4]
 8017976:	699b      	ldr	r3, [r3, #24]
 8017978:	2b00      	cmp	r3, #0
 801797a:	d102      	bne.n	8017982 <xmp3_Subband+0x2e>
		return -1;
 801797c:	f04f 33ff 	mov.w	r3, #4294967295
 8017980:	e0c6      	b.n	8017b10 <xmp3_Subband+0x1bc>

//	hi = (HuffmanInfo *)mp3DecInfo->HuffmanInfoPS;
	mi = (IMDCTInfo *)(mp3DecInfo->IMDCTInfoPS);
 8017982:	687b      	ldr	r3, [r7, #4]
 8017984:	695b      	ldr	r3, [r3, #20]
 8017986:	613b      	str	r3, [r7, #16]
	sbi = (SubbandInfo*)(mp3DecInfo->SubbandInfoPS);
 8017988:	687b      	ldr	r3, [r7, #4]
 801798a:	699b      	ldr	r3, [r3, #24]
 801798c:	60fb      	str	r3, [r7, #12]

	if (mp3DecInfo->nChans == 2) {
 801798e:	687b      	ldr	r3, [r7, #4]
 8017990:	f8d3 37bc 	ldr.w	r3, [r3, #1980]	; 0x7bc
 8017994:	2b02      	cmp	r3, #2
 8017996:	d16a      	bne.n	8017a6e <xmp3_Subband+0x11a>
		/* stereo */
		for (b = 0; b < BLOCK_SIZE; b++) {
 8017998:	f04f 0300 	mov.w	r3, #0
 801799c:	617b      	str	r3, [r7, #20]
 801799e:	e062      	b.n	8017a66 <xmp3_Subband+0x112>
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 80179a0:	693a      	ldr	r2, [r7, #16]
 80179a2:	697b      	ldr	r3, [r7, #20]
 80179a4:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 80179a8:	18d0      	adds	r0, r2, r3
 80179aa:	68f9      	ldr	r1, [r7, #12]
 80179ac:	68fb      	ldr	r3, [r7, #12]
 80179ae:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 80179b2:	681a      	ldr	r2, [r3, #0]
 80179b4:	697b      	ldr	r3, [r7, #20]
 80179b6:	f003 0401 	and.w	r4, r3, #1
 80179ba:	693b      	ldr	r3, [r7, #16]
 80179bc:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 80179c0:	f103 0318 	add.w	r3, r3, #24
 80179c4:	681b      	ldr	r3, [r3, #0]
 80179c6:	9300      	str	r3, [sp, #0]
 80179c8:	4623      	mov	r3, r4
 80179ca:	f7f8 fbef 	bl	80101ac <xmp3_FDCT32>
			FDCT32(mi->outBuf[1][b], sbi->vbuf + 1*32, sbi->vindex, (b & 0x01), mi->gb[1]);
 80179ce:	693a      	ldr	r2, [r7, #16]
 80179d0:	697b      	ldr	r3, [r7, #20]
 80179d2:	f103 0312 	add.w	r3, r3, #18
 80179d6:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 80179da:	18d0      	adds	r0, r2, r3
 80179dc:	68fb      	ldr	r3, [r7, #12]
 80179de:	f103 0180 	add.w	r1, r3, #128	; 0x80
 80179e2:	68fb      	ldr	r3, [r7, #12]
 80179e4:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 80179e8:	681a      	ldr	r2, [r3, #0]
 80179ea:	697b      	ldr	r3, [r7, #20]
 80179ec:	f003 0401 	and.w	r4, r3, #1
 80179f0:	693b      	ldr	r3, [r7, #16]
 80179f2:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 80179f6:	f103 031c 	add.w	r3, r3, #28
 80179fa:	681b      	ldr	r3, [r3, #0]
 80179fc:	9300      	str	r3, [sp, #0]
 80179fe:	4623      	mov	r3, r4
 8017a00:	f7f8 fbd4 	bl	80101ac <xmp3_FDCT32>
			PolyphaseStereo(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8017a04:	68f9      	ldr	r1, [r7, #12]
 8017a06:	68fb      	ldr	r3, [r7, #12]
 8017a08:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8017a0c:	681b      	ldr	r3, [r3, #0]
 8017a0e:	4618      	mov	r0, r3
 8017a10:	697b      	ldr	r3, [r7, #20]
 8017a12:	f003 0201 	and.w	r2, r3, #1
 8017a16:	4613      	mov	r3, r2
 8017a18:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8017a1c:	189b      	adds	r3, r3, r2
 8017a1e:	ea4f 1383 	mov.w	r3, r3, lsl #6
 8017a22:	18c3      	adds	r3, r0, r3
 8017a24:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017a28:	18cb      	adds	r3, r1, r3
 8017a2a:	6838      	ldr	r0, [r7, #0]
 8017a2c:	4619      	mov	r1, r3
 8017a2e:	f24e 7244 	movw	r2, #59204	; 0xe744
 8017a32:	f6c0 0202 	movt	r2, #2050	; 0x802
 8017a36:	f7fd fcb7 	bl	80153a8 <xmp3_PolyphaseStereo>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8017a3a:	68fb      	ldr	r3, [r7, #12]
 8017a3c:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8017a40:	681a      	ldr	r2, [r3, #0]
 8017a42:	697b      	ldr	r3, [r7, #20]
 8017a44:	f003 0301 	and.w	r3, r3, #1
 8017a48:	1ad3      	subs	r3, r2, r3
 8017a4a:	f003 0207 	and.w	r2, r3, #7
 8017a4e:	68fb      	ldr	r3, [r7, #12]
 8017a50:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8017a54:	601a      	str	r2, [r3, #0]
			pcmBuf += (2 * NBANDS);
 8017a56:	683b      	ldr	r3, [r7, #0]
 8017a58:	f103 0380 	add.w	r3, r3, #128	; 0x80
 8017a5c:	603b      	str	r3, [r7, #0]
	mi = (IMDCTInfo *)(mp3DecInfo->IMDCTInfoPS);
	sbi = (SubbandInfo*)(mp3DecInfo->SubbandInfoPS);

	if (mp3DecInfo->nChans == 2) {
		/* stereo */
		for (b = 0; b < BLOCK_SIZE; b++) {
 8017a5e:	697b      	ldr	r3, [r7, #20]
 8017a60:	f103 0301 	add.w	r3, r3, #1
 8017a64:	617b      	str	r3, [r7, #20]
 8017a66:	697b      	ldr	r3, [r7, #20]
 8017a68:	2b11      	cmp	r3, #17
 8017a6a:	dd99      	ble.n	80179a0 <xmp3_Subband+0x4c>
 8017a6c:	e04e      	b.n	8017b0c <xmp3_Subband+0x1b8>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
			pcmBuf += (2 * NBANDS);
		}
	} else {
		/* mono */
		for (b = 0; b < BLOCK_SIZE; b++) {
 8017a6e:	f04f 0300 	mov.w	r3, #0
 8017a72:	617b      	str	r3, [r7, #20]
 8017a74:	e047      	b.n	8017b06 <xmp3_Subband+0x1b2>
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8017a76:	693a      	ldr	r2, [r7, #16]
 8017a78:	697b      	ldr	r3, [r7, #20]
 8017a7a:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8017a7e:	18d0      	adds	r0, r2, r3
 8017a80:	68f9      	ldr	r1, [r7, #12]
 8017a82:	68fb      	ldr	r3, [r7, #12]
 8017a84:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8017a88:	681a      	ldr	r2, [r3, #0]
 8017a8a:	697b      	ldr	r3, [r7, #20]
 8017a8c:	f003 0401 	and.w	r4, r3, #1
 8017a90:	693b      	ldr	r3, [r7, #16]
 8017a92:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 8017a96:	f103 0318 	add.w	r3, r3, #24
 8017a9a:	681b      	ldr	r3, [r3, #0]
 8017a9c:	9300      	str	r3, [sp, #0]
 8017a9e:	4623      	mov	r3, r4
 8017aa0:	f7f8 fb84 	bl	80101ac <xmp3_FDCT32>
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8017aa4:	68f9      	ldr	r1, [r7, #12]
 8017aa6:	68fb      	ldr	r3, [r7, #12]
 8017aa8:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8017aac:	681b      	ldr	r3, [r3, #0]
 8017aae:	4618      	mov	r0, r3
 8017ab0:	697b      	ldr	r3, [r7, #20]
 8017ab2:	f003 0201 	and.w	r2, r3, #1
 8017ab6:	4613      	mov	r3, r2
 8017ab8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8017abc:	189b      	adds	r3, r3, r2
 8017abe:	ea4f 1383 	mov.w	r3, r3, lsl #6
 8017ac2:	18c3      	adds	r3, r0, r3
 8017ac4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017ac8:	18cb      	adds	r3, r1, r3
 8017aca:	6838      	ldr	r0, [r7, #0]
 8017acc:	4619      	mov	r1, r3
 8017ace:	f24e 7244 	movw	r2, #59204	; 0xe744
 8017ad2:	f6c0 0202 	movt	r2, #2050	; 0x802
 8017ad6:	f7fc ffef 	bl	8014ab8 <xmp3_PolyphaseMono>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8017ada:	68fb      	ldr	r3, [r7, #12]
 8017adc:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8017ae0:	681a      	ldr	r2, [r3, #0]
 8017ae2:	697b      	ldr	r3, [r7, #20]
 8017ae4:	f003 0301 	and.w	r3, r3, #1
 8017ae8:	1ad3      	subs	r3, r2, r3
 8017aea:	f003 0207 	and.w	r2, r3, #7
 8017aee:	68fb      	ldr	r3, [r7, #12]
 8017af0:	f503 5308 	add.w	r3, r3, #8704	; 0x2200
 8017af4:	601a      	str	r2, [r3, #0]
			pcmBuf += NBANDS;
 8017af6:	683b      	ldr	r3, [r7, #0]
 8017af8:	f103 0340 	add.w	r3, r3, #64	; 0x40
 8017afc:	603b      	str	r3, [r7, #0]
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
			pcmBuf += (2 * NBANDS);
		}
	} else {
		/* mono */
		for (b = 0; b < BLOCK_SIZE; b++) {
 8017afe:	697b      	ldr	r3, [r7, #20]
 8017b00:	f103 0301 	add.w	r3, r3, #1
 8017b04:	617b      	str	r3, [r7, #20]
 8017b06:	697b      	ldr	r3, [r7, #20]
 8017b08:	2b11      	cmp	r3, #17
 8017b0a:	ddb4      	ble.n	8017a76 <xmp3_Subband+0x122>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
			pcmBuf += NBANDS;
		}
	}

	return 0;
 8017b0c:	f04f 0300 	mov.w	r3, #0
}
 8017b10:	4618      	mov	r0, r3
 8017b12:	f107 071c 	add.w	r7, r7, #28
 8017b16:	46bd      	mov	sp, r7
 8017b18:	bd90      	pop	{r4, r7, pc}
 8017b1a:	bf00      	nop

08017b1c <MP3InitDecoder>:
 * Outputs:     none
 *
 * Return:      handle to mp3 decoder instance, 0 if malloc fails
 **************************************************************************************/
HMP3Decoder MP3InitDecoder(void)
{
 8017b1c:	b580      	push	{r7, lr}
 8017b1e:	b082      	sub	sp, #8
 8017b20:	af00      	add	r7, sp, #0
	MP3DecInfo *mp3DecInfo;

	mp3DecInfo = AllocateBuffers();
 8017b22:	f7f8 fa99 	bl	8010058 <xmp3_AllocateBuffers>
 8017b26:	4603      	mov	r3, r0
 8017b28:	607b      	str	r3, [r7, #4]

	return (HMP3Decoder)mp3DecInfo;
 8017b2a:	687b      	ldr	r3, [r7, #4]
}
 8017b2c:	4618      	mov	r0, r3
 8017b2e:	f107 0708 	add.w	r7, r7, #8
 8017b32:	46bd      	mov	sp, r7
 8017b34:	bd80      	pop	{r7, pc}
 8017b36:	bf00      	nop

08017b38 <MP3FreeDecoder>:
 * Outputs:     none
 *
 * Return:      none
 **************************************************************************************/
void MP3FreeDecoder(HMP3Decoder hMP3Decoder)
{
 8017b38:	b580      	push	{r7, lr}
 8017b3a:	b084      	sub	sp, #16
 8017b3c:	af00      	add	r7, sp, #0
 8017b3e:	6078      	str	r0, [r7, #4]
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
 8017b40:	687b      	ldr	r3, [r7, #4]
 8017b42:	60fb      	str	r3, [r7, #12]

	if (!mp3DecInfo)
 8017b44:	68fb      	ldr	r3, [r7, #12]
 8017b46:	2b00      	cmp	r3, #0
 8017b48:	d003      	beq.n	8017b52 <MP3FreeDecoder+0x1a>
		return;

	FreeBuffers(mp3DecInfo);
 8017b4a:	68f8      	ldr	r0, [r7, #12]
 8017b4c:	f7f8 fb12 	bl	8010174 <xmp3_FreeBuffers>
 8017b50:	e000      	b.n	8017b54 <MP3FreeDecoder+0x1c>
void MP3FreeDecoder(HMP3Decoder hMP3Decoder)
{
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;

	if (!mp3DecInfo)
		return;
 8017b52:	bf00      	nop

	FreeBuffers(mp3DecInfo);
}
 8017b54:	f107 0710 	add.w	r7, r7, #16
 8017b58:	46bd      	mov	sp, r7
 8017b5a:	bd80      	pop	{r7, pc}

08017b5c <MP3FindSyncWord>:
 *
 * Return:      offset to first sync word (bytes from start of buf)
 *              -1 if sync not found after searching nBytes
 **************************************************************************************/
int MP3FindSyncWord(unsigned char *buf, int nBytes)
{
 8017b5c:	b480      	push	{r7}
 8017b5e:	b085      	sub	sp, #20
 8017b60:	af00      	add	r7, sp, #0
 8017b62:	6078      	str	r0, [r7, #4]
 8017b64:	6039      	str	r1, [r7, #0]
	int i;

	/* find byte-aligned syncword - need 12 (MPEG 1,2) or 11 (MPEG 2.5) matching bits */
	for (i = 0; i < nBytes - 1; i++) {
 8017b66:	f04f 0300 	mov.w	r3, #0
 8017b6a:	60fb      	str	r3, [r7, #12]
 8017b6c:	e015      	b.n	8017b9a <MP3FindSyncWord+0x3e>
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 8017b6e:	68fb      	ldr	r3, [r7, #12]
 8017b70:	687a      	ldr	r2, [r7, #4]
 8017b72:	18d3      	adds	r3, r2, r3
 8017b74:	781b      	ldrb	r3, [r3, #0]
 8017b76:	2bff      	cmp	r3, #255	; 0xff
 8017b78:	d10b      	bne.n	8017b92 <MP3FindSyncWord+0x36>
 8017b7a:	68fb      	ldr	r3, [r7, #12]
 8017b7c:	f103 0301 	add.w	r3, r3, #1
 8017b80:	687a      	ldr	r2, [r7, #4]
 8017b82:	18d3      	adds	r3, r2, r3
 8017b84:	781b      	ldrb	r3, [r3, #0]
 8017b86:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 8017b8a:	2be0      	cmp	r3, #224	; 0xe0
 8017b8c:	d101      	bne.n	8017b92 <MP3FindSyncWord+0x36>
			return i;
 8017b8e:	68fb      	ldr	r3, [r7, #12]
 8017b90:	e00b      	b.n	8017baa <MP3FindSyncWord+0x4e>
int MP3FindSyncWord(unsigned char *buf, int nBytes)
{
	int i;

	/* find byte-aligned syncword - need 12 (MPEG 1,2) or 11 (MPEG 2.5) matching bits */
	for (i = 0; i < nBytes - 1; i++) {
 8017b92:	68fb      	ldr	r3, [r7, #12]
 8017b94:	f103 0301 	add.w	r3, r3, #1
 8017b98:	60fb      	str	r3, [r7, #12]
 8017b9a:	683b      	ldr	r3, [r7, #0]
 8017b9c:	f103 32ff 	add.w	r2, r3, #4294967295
 8017ba0:	68fb      	ldr	r3, [r7, #12]
 8017ba2:	429a      	cmp	r2, r3
 8017ba4:	dce3      	bgt.n	8017b6e <MP3FindSyncWord+0x12>
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
			return i;
	}
	
	return -1;
 8017ba6:	f04f 33ff 	mov.w	r3, #4294967295
}
 8017baa:	4618      	mov	r0, r3
 8017bac:	f107 0714 	add.w	r7, r7, #20
 8017bb0:	46bd      	mov	sp, r7
 8017bb2:	bc80      	pop	{r7}
 8017bb4:	4770      	bx	lr
 8017bb6:	bf00      	nop

08017bb8 <MP3FindFreeSync>:
 *              since free mode requires CBR (see spec) we generally only call
 *                this function once (first frame) then store the result (nSlots)
 *                and just use it from then on
 **************************************************************************************/
static int MP3FindFreeSync(unsigned char *buf, unsigned char firstFH[4], int nBytes)
{
 8017bb8:	b580      	push	{r7, lr}
 8017bba:	b086      	sub	sp, #24
 8017bbc:	af00      	add	r7, sp, #0
 8017bbe:	60f8      	str	r0, [r7, #12]
 8017bc0:	60b9      	str	r1, [r7, #8]
 8017bc2:	607a      	str	r2, [r7, #4]
	int offset = 0;
 8017bc4:	f04f 0300 	mov.w	r3, #0
 8017bc8:	613b      	str	r3, [r7, #16]
	unsigned char *bufPtr = buf;
 8017bca:	68fb      	ldr	r3, [r7, #12]
 8017bcc:	617b      	str	r3, [r7, #20]
	 *  - run out of nBytes (FindMP3SyncWord() returns -1)
	 *  - find the next valid frame header (sync word, version, layer, CRC flag, bitrate, and sample rate
	 *      in next header must match current header)
	 */
	while (1) {
		offset = MP3FindSyncWord(bufPtr, nBytes);
 8017bce:	6978      	ldr	r0, [r7, #20]
 8017bd0:	6879      	ldr	r1, [r7, #4]
 8017bd2:	f7ff ffc3 	bl	8017b5c <MP3FindSyncWord>
 8017bd6:	4603      	mov	r3, r0
 8017bd8:	613b      	str	r3, [r7, #16]
		bufPtr += offset;
 8017bda:	693b      	ldr	r3, [r7, #16]
 8017bdc:	697a      	ldr	r2, [r7, #20]
 8017bde:	18d3      	adds	r3, r2, r3
 8017be0:	617b      	str	r3, [r7, #20]
		if (offset < 0) {
 8017be2:	693b      	ldr	r3, [r7, #16]
 8017be4:	2b00      	cmp	r3, #0
 8017be6:	da02      	bge.n	8017bee <MP3FindFreeSync+0x36>
			return -1;
 8017be8:	f04f 33ff 	mov.w	r3, #4294967295
 8017bec:	e03f      	b.n	8017c6e <MP3FindFreeSync+0xb6>
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 8017bee:	697b      	ldr	r3, [r7, #20]
 8017bf0:	781a      	ldrb	r2, [r3, #0]
 8017bf2:	68bb      	ldr	r3, [r7, #8]
 8017bf4:	781b      	ldrb	r3, [r3, #0]
 8017bf6:	429a      	cmp	r2, r3
 8017bf8:	d12b      	bne.n	8017c52 <MP3FindFreeSync+0x9a>
 8017bfa:	697b      	ldr	r3, [r7, #20]
 8017bfc:	f103 0301 	add.w	r3, r3, #1
 8017c00:	781a      	ldrb	r2, [r3, #0]
 8017c02:	68bb      	ldr	r3, [r7, #8]
 8017c04:	f103 0301 	add.w	r3, r3, #1
 8017c08:	781b      	ldrb	r3, [r3, #0]
 8017c0a:	429a      	cmp	r2, r3
 8017c0c:	d121      	bne.n	8017c52 <MP3FindFreeSync+0x9a>
 8017c0e:	697b      	ldr	r3, [r7, #20]
 8017c10:	f103 0302 	add.w	r3, r3, #2
 8017c14:	781b      	ldrb	r3, [r3, #0]
 8017c16:	461a      	mov	r2, r3
 8017c18:	68bb      	ldr	r3, [r7, #8]
 8017c1a:	f103 0302 	add.w	r3, r3, #2
 8017c1e:	781b      	ldrb	r3, [r3, #0]
 8017c20:	4053      	eors	r3, r2
 8017c22:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
 8017c26:	2b00      	cmp	r3, #0
 8017c28:	d113      	bne.n	8017c52 <MP3FindFreeSync+0x9a>
			/* want to return number of bytes per frame, NOT counting the padding byte, so subtract one if padFlag == 1 */
			if ((firstFH[2] >> 1) & 0x01)
 8017c2a:	68bb      	ldr	r3, [r7, #8]
 8017c2c:	f103 0302 	add.w	r3, r3, #2
 8017c30:	781b      	ldrb	r3, [r3, #0]
 8017c32:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8017c36:	b2db      	uxtb	r3, r3
 8017c38:	f003 0301 	and.w	r3, r3, #1
 8017c3c:	b2db      	uxtb	r3, r3
 8017c3e:	2b00      	cmp	r3, #0
 8017c40:	d003      	beq.n	8017c4a <MP3FindFreeSync+0x92>
				bufPtr--;
 8017c42:	697b      	ldr	r3, [r7, #20]
 8017c44:	f103 33ff 	add.w	r3, r3, #4294967295
 8017c48:	617b      	str	r3, [r7, #20]
			return bufPtr - buf;
 8017c4a:	697a      	ldr	r2, [r7, #20]
 8017c4c:	68fb      	ldr	r3, [r7, #12]
 8017c4e:	1ad3      	subs	r3, r2, r3
 8017c50:	e00d      	b.n	8017c6e <MP3FindFreeSync+0xb6>
		}
		bufPtr += 3;
 8017c52:	697b      	ldr	r3, [r7, #20]
 8017c54:	f103 0303 	add.w	r3, r3, #3
 8017c58:	617b      	str	r3, [r7, #20]
		nBytes -= (offset + 3);
 8017c5a:	693a      	ldr	r2, [r7, #16]
 8017c5c:	f64f 73fd 	movw	r3, #65533	; 0xfffd
 8017c60:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8017c64:	1a9b      	subs	r3, r3, r2
 8017c66:	687a      	ldr	r2, [r7, #4]
 8017c68:	18d3      	adds	r3, r2, r3
 8017c6a:	607b      	str	r3, [r7, #4]
	};
 8017c6c:	e7af      	b.n	8017bce <MP3FindFreeSync+0x16>

		return -1;
}
 8017c6e:	4618      	mov	r0, r3
 8017c70:	f107 0718 	add.w	r7, r7, #24
 8017c74:	46bd      	mov	sp, r7
 8017c76:	bd80      	pop	{r7, pc}

08017c78 <MP3GetLastFrameInfo>:
 * Return:      none
 *
 * Notes:       call this right after calling MP3Decode
 **************************************************************************************/
void MP3GetLastFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo)
{
 8017c78:	b490      	push	{r4, r7}
 8017c7a:	b084      	sub	sp, #16
 8017c7c:	af00      	add	r7, sp, #0
 8017c7e:	6078      	str	r0, [r7, #4]
 8017c80:	6039      	str	r1, [r7, #0]
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
 8017c82:	687b      	ldr	r3, [r7, #4]
 8017c84:	60fb      	str	r3, [r7, #12]

	if (!mp3DecInfo || mp3DecInfo->layer != 3) {
 8017c86:	68fb      	ldr	r3, [r7, #12]
 8017c88:	2b00      	cmp	r3, #0
 8017c8a:	d004      	beq.n	8017c96 <MP3GetLastFrameInfo+0x1e>
 8017c8c:	68fb      	ldr	r3, [r7, #12]
 8017c8e:	f8d3 37d0 	ldr.w	r3, [r3, #2000]	; 0x7d0
 8017c92:	2b03      	cmp	r3, #3
 8017c94:	d01c      	beq.n	8017cd0 <MP3GetLastFrameInfo+0x58>
		mp3FrameInfo->bitrate = 0;
 8017c96:	683b      	ldr	r3, [r7, #0]
 8017c98:	f04f 0200 	mov.w	r2, #0
 8017c9c:	601a      	str	r2, [r3, #0]
		mp3FrameInfo->nChans = 0;
 8017c9e:	683b      	ldr	r3, [r7, #0]
 8017ca0:	f04f 0200 	mov.w	r2, #0
 8017ca4:	605a      	str	r2, [r3, #4]
		mp3FrameInfo->samprate = 0;
 8017ca6:	683b      	ldr	r3, [r7, #0]
 8017ca8:	f04f 0200 	mov.w	r2, #0
 8017cac:	609a      	str	r2, [r3, #8]
		mp3FrameInfo->bitsPerSample = 0;
 8017cae:	683b      	ldr	r3, [r7, #0]
 8017cb0:	f04f 0200 	mov.w	r2, #0
 8017cb4:	60da      	str	r2, [r3, #12]
		mp3FrameInfo->outputSamps = 0;
 8017cb6:	683b      	ldr	r3, [r7, #0]
 8017cb8:	f04f 0200 	mov.w	r2, #0
 8017cbc:	611a      	str	r2, [r3, #16]
		mp3FrameInfo->layer = 0;
 8017cbe:	683b      	ldr	r3, [r7, #0]
 8017cc0:	f04f 0200 	mov.w	r2, #0
 8017cc4:	615a      	str	r2, [r3, #20]
		mp3FrameInfo->version = 0;
 8017cc6:	683b      	ldr	r3, [r7, #0]
 8017cc8:	f04f 0200 	mov.w	r2, #0
 8017ccc:	619a      	str	r2, [r3, #24]
 8017cce:	e039      	b.n	8017d44 <MP3GetLastFrameInfo+0xcc>
	} else {
		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
 8017cd0:	68fb      	ldr	r3, [r7, #12]
 8017cd2:	f8d3 27b8 	ldr.w	r2, [r3, #1976]	; 0x7b8
 8017cd6:	683b      	ldr	r3, [r7, #0]
 8017cd8:	601a      	str	r2, [r3, #0]
		mp3FrameInfo->nChans = mp3DecInfo->nChans;
 8017cda:	68fb      	ldr	r3, [r7, #12]
 8017cdc:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 8017ce0:	683b      	ldr	r3, [r7, #0]
 8017ce2:	605a      	str	r2, [r3, #4]
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
 8017ce4:	68fb      	ldr	r3, [r7, #12]
 8017ce6:	f8d3 27c0 	ldr.w	r2, [r3, #1984]	; 0x7c0
 8017cea:	683b      	ldr	r3, [r7, #0]
 8017cec:	609a      	str	r2, [r3, #8]
		mp3FrameInfo->bitsPerSample = 16;
 8017cee:	683b      	ldr	r3, [r7, #0]
 8017cf0:	f04f 0210 	mov.w	r2, #16
 8017cf4:	60da      	str	r2, [r3, #12]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 8017cf6:	68fb      	ldr	r3, [r7, #12]
 8017cf8:	f8d3 07bc 	ldr.w	r0, [r3, #1980]	; 0x7bc
 8017cfc:	68fb      	ldr	r3, [r7, #12]
 8017cfe:	f893 37d4 	ldrb.w	r3, [r3, #2004]	; 0x7d4
 8017d02:	4619      	mov	r1, r3
 8017d04:	68fb      	ldr	r3, [r7, #12]
 8017d06:	f8d3 37d0 	ldr.w	r3, [r3, #2000]	; 0x7d0
 8017d0a:	f103 34ff 	add.w	r4, r3, #4294967295
 8017d0e:	f64e 4298 	movw	r2, #60568	; 0xec98
 8017d12:	f6c0 0202 	movt	r2, #2050	; 0x802
 8017d16:	460b      	mov	r3, r1
 8017d18:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017d1c:	185b      	adds	r3, r3, r1
 8017d1e:	191b      	adds	r3, r3, r4
 8017d20:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8017d24:	b21b      	sxth	r3, r3
 8017d26:	fb03 f200 	mul.w	r2, r3, r0
 8017d2a:	683b      	ldr	r3, [r7, #0]
 8017d2c:	611a      	str	r2, [r3, #16]
		mp3FrameInfo->layer = mp3DecInfo->layer;
 8017d2e:	68fb      	ldr	r3, [r7, #12]
 8017d30:	f8d3 27d0 	ldr.w	r2, [r3, #2000]	; 0x7d0
 8017d34:	683b      	ldr	r3, [r7, #0]
 8017d36:	615a      	str	r2, [r3, #20]
		mp3FrameInfo->version = mp3DecInfo->version;
 8017d38:	68fb      	ldr	r3, [r7, #12]
 8017d3a:	f893 37d4 	ldrb.w	r3, [r3, #2004]	; 0x7d4
 8017d3e:	461a      	mov	r2, r3
 8017d40:	683b      	ldr	r3, [r7, #0]
 8017d42:	619a      	str	r2, [r3, #24]
	}
}
 8017d44:	f107 0710 	add.w	r7, r7, #16
 8017d48:	46bd      	mov	sp, r7
 8017d4a:	bc90      	pop	{r4, r7}
 8017d4c:	4770      	bx	lr
 8017d4e:	bf00      	nop

08017d50 <MP3GetNextFrameInfo>:
 * Outputs:     filled-in MP3FrameInfo struct
 *
 * Return:      error code, defined in mp3dec.h (0 means no error, < 0 means error)
 **************************************************************************************/
int MP3GetNextFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo, unsigned char *buf)
{
 8017d50:	b580      	push	{r7, lr}
 8017d52:	b086      	sub	sp, #24
 8017d54:	af00      	add	r7, sp, #0
 8017d56:	60f8      	str	r0, [r7, #12]
 8017d58:	60b9      	str	r1, [r7, #8]
 8017d5a:	607a      	str	r2, [r7, #4]
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
 8017d5c:	68fb      	ldr	r3, [r7, #12]
 8017d5e:	617b      	str	r3, [r7, #20]

	if (!mp3DecInfo)
 8017d60:	697b      	ldr	r3, [r7, #20]
 8017d62:	2b00      	cmp	r3, #0
 8017d64:	d102      	bne.n	8017d6c <MP3GetNextFrameInfo+0x1c>
		return ERR_MP3_NULL_POINTER;
 8017d66:	f06f 0304 	mvn.w	r3, #4
 8017d6a:	e015      	b.n	8017d98 <MP3GetNextFrameInfo+0x48>

	if (UnpackFrameHeader(mp3DecInfo, buf) == -1 || mp3DecInfo->layer != 3)
 8017d6c:	6978      	ldr	r0, [r7, #20]
 8017d6e:	6879      	ldr	r1, [r7, #4]
 8017d70:	f7f7 fdc8 	bl	800f904 <xmp3_UnpackFrameHeader>
 8017d74:	4603      	mov	r3, r0
 8017d76:	f1b3 3fff 	cmp.w	r3, #4294967295
 8017d7a:	d004      	beq.n	8017d86 <MP3GetNextFrameInfo+0x36>
 8017d7c:	697b      	ldr	r3, [r7, #20]
 8017d7e:	f8d3 37d0 	ldr.w	r3, [r3, #2000]	; 0x7d0
 8017d82:	2b03      	cmp	r3, #3
 8017d84:	d002      	beq.n	8017d8c <MP3GetNextFrameInfo+0x3c>
		return ERR_MP3_INVALID_FRAMEHEADER;
 8017d86:	f06f 0305 	mvn.w	r3, #5
 8017d8a:	e005      	b.n	8017d98 <MP3GetNextFrameInfo+0x48>

	MP3GetLastFrameInfo(mp3DecInfo, mp3FrameInfo);
 8017d8c:	6978      	ldr	r0, [r7, #20]
 8017d8e:	68b9      	ldr	r1, [r7, #8]
 8017d90:	f7ff ff72 	bl	8017c78 <MP3GetLastFrameInfo>

	return ERR_MP3_NONE;
 8017d94:	f04f 0300 	mov.w	r3, #0
}
 8017d98:	4618      	mov	r0, r3
 8017d9a:	f107 0718 	add.w	r7, r7, #24
 8017d9e:	46bd      	mov	sp, r7
 8017da0:	bd80      	pop	{r7, pc}
 8017da2:	bf00      	nop

08017da4 <MP3ClearBadFrame>:
 * Outputs:     zeroed out pcm buffer
 *
 * Return:      none
 **************************************************************************************/
static void MP3ClearBadFrame(MP3DecInfo *mp3DecInfo, short *outbuf)
{
 8017da4:	b480      	push	{r7}
 8017da6:	b085      	sub	sp, #20
 8017da8:	af00      	add	r7, sp, #0
 8017daa:	6078      	str	r0, [r7, #4]
 8017dac:	6039      	str	r1, [r7, #0]
	int i;

	if (!mp3DecInfo)
 8017dae:	687b      	ldr	r3, [r7, #4]
 8017db0:	2b00      	cmp	r3, #0
 8017db2:	d020      	beq.n	8017df6 <MP3ClearBadFrame+0x52>
		return;

	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 8017db4:	f04f 0300 	mov.w	r3, #0
 8017db8:	60fb      	str	r3, [r7, #12]
 8017dba:	e00b      	b.n	8017dd4 <MP3ClearBadFrame+0x30>
		outbuf[i] = 0;
 8017dbc:	68fb      	ldr	r3, [r7, #12]
 8017dbe:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017dc2:	683a      	ldr	r2, [r7, #0]
 8017dc4:	18d3      	adds	r3, r2, r3
 8017dc6:	f04f 0200 	mov.w	r2, #0
 8017dca:	801a      	strh	r2, [r3, #0]
	int i;

	if (!mp3DecInfo)
		return;

	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 8017dcc:	68fb      	ldr	r3, [r7, #12]
 8017dce:	f103 0301 	add.w	r3, r3, #1
 8017dd2:	60fb      	str	r3, [r7, #12]
 8017dd4:	687b      	ldr	r3, [r7, #4]
 8017dd6:	f8d3 37c4 	ldr.w	r3, [r3, #1988]	; 0x7c4
 8017dda:	687a      	ldr	r2, [r7, #4]
 8017ddc:	f8d2 27c8 	ldr.w	r2, [r2, #1992]	; 0x7c8
 8017de0:	fb02 f303 	mul.w	r3, r2, r3
 8017de4:	687a      	ldr	r2, [r7, #4]
 8017de6:	f8d2 27bc 	ldr.w	r2, [r2, #1980]	; 0x7bc
 8017dea:	fb02 f203 	mul.w	r2, r2, r3
 8017dee:	68fb      	ldr	r3, [r7, #12]
 8017df0:	429a      	cmp	r2, r3
 8017df2:	dce3      	bgt.n	8017dbc <MP3ClearBadFrame+0x18>
 8017df4:	e000      	b.n	8017df8 <MP3ClearBadFrame+0x54>
static void MP3ClearBadFrame(MP3DecInfo *mp3DecInfo, short *outbuf)
{
	int i;

	if (!mp3DecInfo)
		return;
 8017df6:	bf00      	nop

	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
		outbuf[i] = 0;
}
 8017df8:	f107 0714 	add.w	r7, r7, #20
 8017dfc:	46bd      	mov	sp, r7
 8017dfe:	bc80      	pop	{r7}
 8017e00:	4770      	bx	lr
 8017e02:	bf00      	nop

08017e04 <MP3Decode>:
 *
 * Notes:       switching useSize on and off between frames in the same stream 
 *                is not supported (bit reservoir is not maintained if useSize on)
 **************************************************************************************/
int MP3Decode(HMP3Decoder hMP3Decoder, unsigned char **inbuf, int *bytesLeft, short *outbuf, int useSize)
{
 8017e04:	b590      	push	{r4, r7, lr}
 8017e06:	b095      	sub	sp, #84	; 0x54
 8017e08:	af02      	add	r7, sp, #8
 8017e0a:	60f8      	str	r0, [r7, #12]
 8017e0c:	60b9      	str	r1, [r7, #8]
 8017e0e:	607a      	str	r2, [r7, #4]
 8017e10:	603b      	str	r3, [r7, #0]
	int offset, bitOffset, mainBits, gr, ch, fhBytes, siBytes, freeFrameBytes;
	int prevBitOffset, sfBlockBits, huffBlockBits;
	unsigned char *mainPtr;
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
 8017e12:	68fb      	ldr	r3, [r7, #12]
 8017e14:	637b      	str	r3, [r7, #52]	; 0x34

	if (!mp3DecInfo)
 8017e16:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017e18:	2b00      	cmp	r3, #0
 8017e1a:	d102      	bne.n	8017e22 <MP3Decode+0x1e>
		return ERR_MP3_NULL_POINTER;
 8017e1c:	f06f 0304 	mvn.w	r3, #4
 8017e20:	e22a      	b.n	8018278 <MP3Decode+0x474>

	/* unpack frame header */
	fhBytes = UnpackFrameHeader(mp3DecInfo, *inbuf);
 8017e22:	68bb      	ldr	r3, [r7, #8]
 8017e24:	681b      	ldr	r3, [r3, #0]
 8017e26:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8017e28:	4619      	mov	r1, r3
 8017e2a:	f7f7 fd6b 	bl	800f904 <xmp3_UnpackFrameHeader>
 8017e2e:	4603      	mov	r3, r0
 8017e30:	633b      	str	r3, [r7, #48]	; 0x30
	if (fhBytes < 0)	
 8017e32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017e34:	2b00      	cmp	r3, #0
 8017e36:	da02      	bge.n	8017e3e <MP3Decode+0x3a>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
 8017e38:	f06f 0305 	mvn.w	r3, #5
 8017e3c:	e21c      	b.n	8018278 <MP3Decode+0x474>
	*inbuf += fhBytes;
 8017e3e:	68bb      	ldr	r3, [r7, #8]
 8017e40:	681a      	ldr	r2, [r3, #0]
 8017e42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017e44:	18d2      	adds	r2, r2, r3
 8017e46:	68bb      	ldr	r3, [r7, #8]
 8017e48:	601a      	str	r2, [r3, #0]
	
	/* unpack side info */
	siBytes = UnpackSideInfo(mp3DecInfo, *inbuf);
 8017e4a:	68bb      	ldr	r3, [r7, #8]
 8017e4c:	681b      	ldr	r3, [r3, #0]
 8017e4e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8017e50:	4619      	mov	r1, r3
 8017e52:	f7f7 ff0d 	bl	800fc70 <xmp3_UnpackSideInfo>
 8017e56:	4603      	mov	r3, r0
 8017e58:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (siBytes < 0) {
 8017e5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017e5c:	2b00      	cmp	r3, #0
 8017e5e:	da06      	bge.n	8017e6e <MP3Decode+0x6a>
		MP3ClearBadFrame(mp3DecInfo, outbuf);
 8017e60:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8017e62:	6839      	ldr	r1, [r7, #0]
 8017e64:	f7ff ff9e 	bl	8017da4 <MP3ClearBadFrame>
		return ERR_MP3_INVALID_SIDEINFO;
 8017e68:	f06f 0306 	mvn.w	r3, #6
 8017e6c:	e204      	b.n	8018278 <MP3Decode+0x474>
	}
	*inbuf += siBytes;
 8017e6e:	68bb      	ldr	r3, [r7, #8]
 8017e70:	681a      	ldr	r2, [r3, #0]
 8017e72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017e74:	18d2      	adds	r2, r2, r3
 8017e76:	68bb      	ldr	r3, [r7, #8]
 8017e78:	601a      	str	r2, [r3, #0]
	*bytesLeft -= (fhBytes + siBytes);
 8017e7a:	687b      	ldr	r3, [r7, #4]
 8017e7c:	681a      	ldr	r2, [r3, #0]
 8017e7e:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8017e80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017e82:	18cb      	adds	r3, r1, r3
 8017e84:	1ad2      	subs	r2, r2, r3
 8017e86:	687b      	ldr	r3, [r7, #4]
 8017e88:	601a      	str	r2, [r3, #0]
	
	/* if free mode, need to calculate bitrate and nSlots manually, based on frame size */
	if (mp3DecInfo->bitrate == 0 || mp3DecInfo->freeBitrateFlag) {
 8017e8a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017e8c:	f8d3 37b8 	ldr.w	r3, [r3, #1976]	; 0x7b8
 8017e90:	2b00      	cmp	r3, #0
 8017e92:	d004      	beq.n	8017e9e <MP3Decode+0x9a>
 8017e94:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017e96:	f8d3 37b0 	ldr.w	r3, [r3, #1968]	; 0x7b0
 8017e9a:	2b00      	cmp	r3, #0
 8017e9c:	d052      	beq.n	8017f44 <MP3Decode+0x140>
		if (!mp3DecInfo->freeBitrateFlag) {
 8017e9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017ea0:	f8d3 37b0 	ldr.w	r3, [r3, #1968]	; 0x7b0
 8017ea4:	2b00      	cmp	r3, #0
 8017ea6:	d142      	bne.n	8017f2e <MP3Decode+0x12a>
			/* first time through, need to scan for next sync word and figure out frame size */
			mp3DecInfo->freeBitrateFlag = 1;
 8017ea8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017eaa:	f04f 0201 	mov.w	r2, #1
 8017eae:	f8c3 27b0 	str.w	r2, [r3, #1968]	; 0x7b0
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 8017eb2:	68bb      	ldr	r3, [r7, #8]
 8017eb4:	6819      	ldr	r1, [r3, #0]
 8017eb6:	68bb      	ldr	r3, [r7, #8]
 8017eb8:	681a      	ldr	r2, [r3, #0]
 8017eba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017ebc:	f1c3 0000 	rsb	r0, r3, #0
 8017ec0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017ec2:	1ac3      	subs	r3, r0, r3
 8017ec4:	18d2      	adds	r2, r2, r3
 8017ec6:	687b      	ldr	r3, [r7, #4]
 8017ec8:	681b      	ldr	r3, [r3, #0]
 8017eca:	4608      	mov	r0, r1
 8017ecc:	4611      	mov	r1, r2
 8017ece:	461a      	mov	r2, r3
 8017ed0:	f7ff fe72 	bl	8017bb8 <MP3FindFreeSync>
 8017ed4:	4602      	mov	r2, r0
 8017ed6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017ed8:	f8c3 27b4 	str.w	r2, [r3, #1972]	; 0x7b4
			if (mp3DecInfo->freeBitrateSlots < 0) {
 8017edc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017ede:	f8d3 37b4 	ldr.w	r3, [r3, #1972]	; 0x7b4
 8017ee2:	2b00      	cmp	r3, #0
 8017ee4:	da06      	bge.n	8017ef4 <MP3Decode+0xf0>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
 8017ee6:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8017ee8:	6839      	ldr	r1, [r7, #0]
 8017eea:	f7ff ff5b 	bl	8017da4 <MP3ClearBadFrame>
				return ERR_MP3_FREE_BITRATE_SYNC;
 8017eee:	f06f 0302 	mvn.w	r3, #2
 8017ef2:	e1c1      	b.n	8018278 <MP3Decode+0x474>
			}
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
 8017ef4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017ef6:	f8d3 27b4 	ldr.w	r2, [r3, #1972]	; 0x7b4
 8017efa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017efc:	18d2      	adds	r2, r2, r3
 8017efe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017f00:	18d3      	adds	r3, r2, r3
 8017f02:	62bb      	str	r3, [r7, #40]	; 0x28
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
 8017f04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f06:	f8d3 37c0 	ldr.w	r3, [r3, #1984]	; 0x7c0
 8017f0a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017f0c:	fb02 f303 	mul.w	r3, r2, r3
 8017f10:	ea4f 02c3 	mov.w	r2, r3, lsl #3
 8017f14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f16:	f8d3 37c4 	ldr.w	r3, [r3, #1988]	; 0x7c4
 8017f1a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8017f1c:	f8d1 17c8 	ldr.w	r1, [r1, #1992]	; 0x7c8
 8017f20:	fb01 f303 	mul.w	r3, r1, r3
 8017f24:	fb92 f2f3 	sdiv	r2, r2, r3
 8017f28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f2a:	f8c3 27b8 	str.w	r2, [r3, #1976]	; 0x7b8
		}
		mp3DecInfo->nSlots = mp3DecInfo->freeBitrateSlots + CheckPadBit(mp3DecInfo);	/* add pad byte, if required */
 8017f2e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f30:	f8d3 47b4 	ldr.w	r4, [r3, #1972]	; 0x7b4
 8017f34:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8017f36:	f7f7 fcc7 	bl	800f8c8 <xmp3_CheckPadBit>
 8017f3a:	4603      	mov	r3, r0
 8017f3c:	18e2      	adds	r2, r4, r3
 8017f3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f40:	f8c3 27cc 	str.w	r2, [r3, #1996]	; 0x7cc
	 *  - calling function assembles "self-contained" MP3 frames by shifting any main_data 
	 *      from the bit reservoir (in previous frames) to AFTER the sync word and side info
	 *  - calling function should set mainDataBegin to 0, and tell us exactly how large this
	 *      frame is (in bytesLeft)
	 */
	if (useSize) {
 8017f44:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8017f46:	2b00      	cmp	r3, #0
 8017f48:	d02f      	beq.n	8017faa <MP3Decode+0x1a6>
		mp3DecInfo->nSlots = *bytesLeft;
 8017f4a:	687b      	ldr	r3, [r7, #4]
 8017f4c:	681a      	ldr	r2, [r3, #0]
 8017f4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f50:	f8c3 27cc 	str.w	r2, [r3, #1996]	; 0x7cc
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 8017f54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f56:	f8d3 37d8 	ldr.w	r3, [r3, #2008]	; 0x7d8
 8017f5a:	2b00      	cmp	r3, #0
 8017f5c:	d104      	bne.n	8017f68 <MP3Decode+0x164>
 8017f5e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f60:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8017f64:	2b00      	cmp	r3, #0
 8017f66:	dc06      	bgt.n	8017f76 <MP3Decode+0x172>
			/* error - non self-contained frame, or missing frame (size <= 0), could do loss concealment here */
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 8017f68:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8017f6a:	6839      	ldr	r1, [r7, #0]
 8017f6c:	f7ff ff1a 	bl	8017da4 <MP3ClearBadFrame>
			return ERR_MP3_INVALID_FRAMEHEADER;
 8017f70:	f06f 0305 	mvn.w	r3, #5
 8017f74:	e180      	b.n	8018278 <MP3Decode+0x474>
		}

		/* can operate in-place on reformatted frames */
		mp3DecInfo->mainDataBytes = mp3DecInfo->nSlots;
 8017f76:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f78:	f8d3 27cc 	ldr.w	r2, [r3, #1996]	; 0x7cc
 8017f7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f7e:	f8c3 27dc 	str.w	r2, [r3, #2012]	; 0x7dc
		mainPtr = *inbuf;
 8017f82:	68bb      	ldr	r3, [r7, #8]
 8017f84:	681b      	ldr	r3, [r3, #0]
 8017f86:	63bb      	str	r3, [r7, #56]	; 0x38
		*inbuf += mp3DecInfo->nSlots;
 8017f88:	68bb      	ldr	r3, [r7, #8]
 8017f8a:	681a      	ldr	r2, [r3, #0]
 8017f8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f8e:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8017f92:	18d2      	adds	r2, r2, r3
 8017f94:	68bb      	ldr	r3, [r7, #8]
 8017f96:	601a      	str	r2, [r3, #0]
		*bytesLeft -= (mp3DecInfo->nSlots);
 8017f98:	687b      	ldr	r3, [r7, #4]
 8017f9a:	681a      	ldr	r2, [r3, #0]
 8017f9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017f9e:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8017fa2:	1ad2      	subs	r2, r2, r3
 8017fa4:	687b      	ldr	r3, [r7, #4]
 8017fa6:	601a      	str	r2, [r3, #0]
 8017fa8:	e08e      	b.n	80180c8 <MP3Decode+0x2c4>
	} else {
		/* out of data - assume last or truncated frame */
		if (mp3DecInfo->nSlots > *bytesLeft) {
 8017faa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017fac:	f8d3 27cc 	ldr.w	r2, [r3, #1996]	; 0x7cc
 8017fb0:	687b      	ldr	r3, [r7, #4]
 8017fb2:	681b      	ldr	r3, [r3, #0]
 8017fb4:	429a      	cmp	r2, r3
 8017fb6:	dd06      	ble.n	8017fc6 <MP3Decode+0x1c2>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 8017fb8:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8017fba:	6839      	ldr	r1, [r7, #0]
 8017fbc:	f7ff fef2 	bl	8017da4 <MP3ClearBadFrame>
			return ERR_MP3_INDATA_UNDERFLOW;	
 8017fc0:	f04f 33ff 	mov.w	r3, #4294967295
 8017fc4:	e158      	b.n	8018278 <MP3Decode+0x474>
		}
		/* fill main data buffer with enough new data for this frame */
		if (mp3DecInfo->mainDataBytes >= mp3DecInfo->mainDataBegin) {
 8017fc6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017fc8:	f8d3 27dc 	ldr.w	r2, [r3, #2012]	; 0x7dc
 8017fcc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017fce:	f8d3 37d8 	ldr.w	r3, [r3, #2008]	; 0x7d8
 8017fd2:	429a      	cmp	r2, r3
 8017fd4:	db46      	blt.n	8018064 <MP3Decode+0x260>
			/* adequate "old" main data available (i.e. bit reservoir) */
			memmove(mp3DecInfo->mainBuf, mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes - mp3DecInfo->mainDataBegin, mp3DecInfo->mainDataBegin);
 8017fd6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017fd8:	f103 011c 	add.w	r1, r3, #28
 8017fdc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017fde:	f103 021c 	add.w	r2, r3, #28
 8017fe2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017fe4:	f8d3 37dc 	ldr.w	r3, [r3, #2012]	; 0x7dc
 8017fe8:	4618      	mov	r0, r3
 8017fea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017fec:	f8d3 37d8 	ldr.w	r3, [r3, #2008]	; 0x7d8
 8017ff0:	1ac3      	subs	r3, r0, r3
 8017ff2:	18d2      	adds	r2, r2, r3
 8017ff4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017ff6:	f8d3 37d8 	ldr.w	r3, [r3, #2008]	; 0x7d8
 8017ffa:	4608      	mov	r0, r1
 8017ffc:	4611      	mov	r1, r2
 8017ffe:	461a      	mov	r2, r3
 8018000:	f00d f9cc 	bl	802539c <memmove>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBegin, *inbuf, mp3DecInfo->nSlots);
 8018004:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018006:	f103 021c 	add.w	r2, r3, #28
 801800a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801800c:	f8d3 37d8 	ldr.w	r3, [r3, #2008]	; 0x7d8
 8018010:	18d1      	adds	r1, r2, r3
 8018012:	68bb      	ldr	r3, [r7, #8]
 8018014:	681a      	ldr	r2, [r3, #0]
 8018016:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018018:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 801801c:	4608      	mov	r0, r1
 801801e:	4611      	mov	r1, r2
 8018020:	461a      	mov	r2, r3
 8018022:	f00d f979 	bl	8025318 <memcpy>

			mp3DecInfo->mainDataBytes = mp3DecInfo->mainDataBegin + mp3DecInfo->nSlots;
 8018026:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018028:	f8d3 27d8 	ldr.w	r2, [r3, #2008]	; 0x7d8
 801802c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801802e:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8018032:	18d2      	adds	r2, r2, r3
 8018034:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018036:	f8c3 27dc 	str.w	r2, [r3, #2012]	; 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 801803a:	68bb      	ldr	r3, [r7, #8]
 801803c:	681a      	ldr	r2, [r3, #0]
 801803e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018040:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8018044:	18d2      	adds	r2, r2, r3
 8018046:	68bb      	ldr	r3, [r7, #8]
 8018048:	601a      	str	r2, [r3, #0]
			*bytesLeft -= (mp3DecInfo->nSlots);
 801804a:	687b      	ldr	r3, [r7, #4]
 801804c:	681a      	ldr	r2, [r3, #0]
 801804e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018050:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8018054:	1ad2      	subs	r2, r2, r3
 8018056:	687b      	ldr	r3, [r7, #4]
 8018058:	601a      	str	r2, [r3, #0]
			mainPtr = mp3DecInfo->mainBuf;
 801805a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801805c:	f103 031c 	add.w	r3, r3, #28
 8018060:	63bb      	str	r3, [r7, #56]	; 0x38
 8018062:	e031      	b.n	80180c8 <MP3Decode+0x2c4>
		} else {
			/* not enough data in bit reservoir from previous frames (perhaps starting in middle of file) */
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes, *inbuf, mp3DecInfo->nSlots);
 8018064:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018066:	f103 021c 	add.w	r2, r3, #28
 801806a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801806c:	f8d3 37dc 	ldr.w	r3, [r3, #2012]	; 0x7dc
 8018070:	18d1      	adds	r1, r2, r3
 8018072:	68bb      	ldr	r3, [r7, #8]
 8018074:	681a      	ldr	r2, [r3, #0]
 8018076:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018078:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 801807c:	4608      	mov	r0, r1
 801807e:	4611      	mov	r1, r2
 8018080:	461a      	mov	r2, r3
 8018082:	f00d f949 	bl	8025318 <memcpy>
			mp3DecInfo->mainDataBytes += mp3DecInfo->nSlots;
 8018086:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018088:	f8d3 27dc 	ldr.w	r2, [r3, #2012]	; 0x7dc
 801808c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801808e:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 8018092:	18d2      	adds	r2, r2, r3
 8018094:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018096:	f8c3 27dc 	str.w	r2, [r3, #2012]	; 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 801809a:	68bb      	ldr	r3, [r7, #8]
 801809c:	681a      	ldr	r2, [r3, #0]
 801809e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80180a0:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 80180a4:	18d2      	adds	r2, r2, r3
 80180a6:	68bb      	ldr	r3, [r7, #8]
 80180a8:	601a      	str	r2, [r3, #0]
			*bytesLeft -= (mp3DecInfo->nSlots);
 80180aa:	687b      	ldr	r3, [r7, #4]
 80180ac:	681a      	ldr	r2, [r3, #0]
 80180ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80180b0:	f8d3 37cc 	ldr.w	r3, [r3, #1996]	; 0x7cc
 80180b4:	1ad2      	subs	r2, r2, r3
 80180b6:	687b      	ldr	r3, [r7, #4]
 80180b8:	601a      	str	r2, [r3, #0]
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 80180ba:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80180bc:	6839      	ldr	r1, [r7, #0]
 80180be:	f7ff fe71 	bl	8017da4 <MP3ClearBadFrame>
			return ERR_MP3_MAINDATA_UNDERFLOW;
 80180c2:	f06f 0301 	mvn.w	r3, #1
 80180c6:	e0d7      	b.n	8018278 <MP3Decode+0x474>
		}
	}
	bitOffset = 0;
 80180c8:	f04f 0300 	mov.w	r3, #0
 80180cc:	617b      	str	r3, [r7, #20]
	mainBits = mp3DecInfo->mainDataBytes * 8;
 80180ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80180d0:	f8d3 37dc 	ldr.w	r3, [r3, #2012]	; 0x7dc
 80180d4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80180d8:	647b      	str	r3, [r7, #68]	; 0x44

	/* decode one complete frame */
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 80180da:	f04f 0300 	mov.w	r3, #0
 80180de:	643b      	str	r3, [r7, #64]	; 0x40
 80180e0:	e0c1      	b.n	8018266 <MP3Decode+0x462>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 80180e2:	f04f 0300 	mov.w	r3, #0
 80180e6:	63fb      	str	r3, [r7, #60]	; 0x3c
 80180e8:	e06b      	b.n	80181c2 <MP3Decode+0x3be>
			/* unpack scale factors and compute size of scale factor block */
			prevBitOffset = bitOffset;
 80180ea:	697b      	ldr	r3, [r7, #20]
 80180ec:	627b      	str	r3, [r7, #36]	; 0x24
			offset = UnpackScaleFactors(mp3DecInfo, mainPtr, &bitOffset, mainBits, gr, ch);
 80180ee:	f107 0314 	add.w	r3, r7, #20
 80180f2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80180f4:	9200      	str	r2, [sp, #0]
 80180f6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80180f8:	9201      	str	r2, [sp, #4]
 80180fa:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80180fc:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80180fe:	461a      	mov	r2, r3
 8018100:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018102:	f7fe fd75 	bl	8016bf0 <xmp3_UnpackScaleFactors>
 8018106:	4603      	mov	r3, r0
 8018108:	623b      	str	r3, [r7, #32]

			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 801810a:	6a3b      	ldr	r3, [r7, #32]
 801810c:	ea4f 02c3 	mov.w	r2, r3, lsl #3
 8018110:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018112:	1ad2      	subs	r2, r2, r3
 8018114:	697b      	ldr	r3, [r7, #20]
 8018116:	18d3      	adds	r3, r2, r3
 8018118:	61fb      	str	r3, [r7, #28]
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 801811a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801811c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801811e:	ea4f 0142 	mov.w	r1, r2, lsl #1
 8018122:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8018124:	188a      	adds	r2, r1, r2
 8018126:	f502 72fc 	add.w	r2, r2, #504	; 0x1f8
 801812a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801812e:	69fb      	ldr	r3, [r7, #28]
 8018130:	1ad3      	subs	r3, r2, r3
 8018132:	61bb      	str	r3, [r7, #24]
			mainPtr += offset;
 8018134:	6a3b      	ldr	r3, [r7, #32]
 8018136:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8018138:	18d3      	adds	r3, r2, r3
 801813a:	63bb      	str	r3, [r7, #56]	; 0x38
			mainBits -= sfBlockBits;
 801813c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801813e:	69fb      	ldr	r3, [r7, #28]
 8018140:	1ad3      	subs	r3, r2, r3
 8018142:	647b      	str	r3, [r7, #68]	; 0x44

			if (offset < 0 || mainBits < huffBlockBits) {
 8018144:	6a3b      	ldr	r3, [r7, #32]
 8018146:	2b00      	cmp	r3, #0
 8018148:	db03      	blt.n	8018152 <MP3Decode+0x34e>
 801814a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801814c:	69bb      	ldr	r3, [r7, #24]
 801814e:	429a      	cmp	r2, r3
 8018150:	da06      	bge.n	8018160 <MP3Decode+0x35c>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
 8018152:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018154:	6839      	ldr	r1, [r7, #0]
 8018156:	f7ff fe25 	bl	8017da4 <MP3ClearBadFrame>
				return ERR_MP3_INVALID_SCALEFACT;
 801815a:	f06f 0307 	mvn.w	r3, #7
 801815e:	e08b      	b.n	8018278 <MP3Decode+0x474>
			}

			/* decode Huffman code words */
			prevBitOffset = bitOffset;
 8018160:	697b      	ldr	r3, [r7, #20]
 8018162:	627b      	str	r3, [r7, #36]	; 0x24
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 8018164:	f107 0314 	add.w	r3, r7, #20
 8018168:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801816a:	9200      	str	r2, [sp, #0]
 801816c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801816e:	9201      	str	r2, [sp, #4]
 8018170:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018172:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8018174:	461a      	mov	r2, r3
 8018176:	69bb      	ldr	r3, [r7, #24]
 8018178:	f7fa faa2 	bl	80126c0 <xmp3_DecodeHuffman>
 801817c:	4603      	mov	r3, r0
 801817e:	623b      	str	r3, [r7, #32]
			if (offset < 0) {
 8018180:	6a3b      	ldr	r3, [r7, #32]
 8018182:	2b00      	cmp	r3, #0
 8018184:	da06      	bge.n	8018194 <MP3Decode+0x390>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
 8018186:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018188:	6839      	ldr	r1, [r7, #0]
 801818a:	f7ff fe0b 	bl	8017da4 <MP3ClearBadFrame>
				return ERR_MP3_INVALID_HUFFCODES;
 801818e:	f06f 0308 	mvn.w	r3, #8
 8018192:	e071      	b.n	8018278 <MP3Decode+0x474>
			}

			mainPtr += offset;
 8018194:	6a3b      	ldr	r3, [r7, #32]
 8018196:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8018198:	18d3      	adds	r3, r2, r3
 801819a:	63bb      	str	r3, [r7, #56]	; 0x38
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 801819c:	6a3a      	ldr	r2, [r7, #32]
 801819e:	4613      	mov	r3, r2
 80181a0:	ea4f 7343 	mov.w	r3, r3, lsl #29
 80181a4:	1a9b      	subs	r3, r3, r2
 80181a6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80181aa:	461a      	mov	r2, r3
 80181ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80181ae:	18d2      	adds	r2, r2, r3
 80181b0:	697b      	ldr	r3, [r7, #20]
 80181b2:	1ad3      	subs	r3, r2, r3
 80181b4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80181b6:	18d3      	adds	r3, r2, r3
 80181b8:	647b      	str	r3, [r7, #68]	; 0x44
	bitOffset = 0;
	mainBits = mp3DecInfo->mainDataBytes * 8;

	/* decode one complete frame */
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 80181ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80181bc:	f103 0301 	add.w	r3, r3, #1
 80181c0:	63fb      	str	r3, [r7, #60]	; 0x3c
 80181c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80181c4:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 80181c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80181ca:	429a      	cmp	r2, r3
 80181cc:	dc8d      	bgt.n	80180ea <MP3Decode+0x2e6>

			mainPtr += offset;
			mainBits -= (8*offset - prevBitOffset + bitOffset);
		}
		/* dequantize coefficients, decode stereo, reorder short blocks */
		if (Dequantize(mp3DecInfo, gr) < 0) {
 80181ce:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80181d0:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80181d2:	f7f9 f857 	bl	8011284 <xmp3_Dequantize>
 80181d6:	4603      	mov	r3, r0
 80181d8:	2b00      	cmp	r3, #0
 80181da:	da06      	bge.n	80181ea <MP3Decode+0x3e6>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 80181dc:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80181de:	6839      	ldr	r1, [r7, #0]
 80181e0:	f7ff fde0 	bl	8017da4 <MP3ClearBadFrame>
			return ERR_MP3_INVALID_DEQUANTIZE;			
 80181e4:	f06f 0309 	mvn.w	r3, #9
 80181e8:	e046      	b.n	8018278 <MP3Decode+0x474>
		}

		/* alias reduction, inverse MDCT, overlap-add, frequency inversion */
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 80181ea:	f04f 0300 	mov.w	r3, #0
 80181ee:	63fb      	str	r3, [r7, #60]	; 0x3c
 80181f0:	e012      	b.n	8018218 <MP3Decode+0x414>
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 80181f2:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80181f4:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80181f6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80181f8:	f7fc fa56 	bl	80146a8 <xmp3_IMDCT>
 80181fc:	4603      	mov	r3, r0
 80181fe:	2b00      	cmp	r3, #0
 8018200:	da06      	bge.n	8018210 <MP3Decode+0x40c>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
 8018202:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018204:	6839      	ldr	r1, [r7, #0]
 8018206:	f7ff fdcd 	bl	8017da4 <MP3ClearBadFrame>
				return ERR_MP3_INVALID_IMDCT;			
 801820a:	f06f 030a 	mvn.w	r3, #10
 801820e:	e033      	b.n	8018278 <MP3Decode+0x474>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_INVALID_DEQUANTIZE;			
		}

		/* alias reduction, inverse MDCT, overlap-add, frequency inversion */
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 8018210:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018212:	f103 0301 	add.w	r3, r3, #1
 8018216:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018218:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801821a:	f8d3 27bc 	ldr.w	r2, [r3, #1980]	; 0x7bc
 801821e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018220:	429a      	cmp	r2, r3
 8018222:	dce6      	bgt.n	80181f2 <MP3Decode+0x3ee>
				MP3ClearBadFrame(mp3DecInfo, outbuf);
				return ERR_MP3_INVALID_IMDCT;			
			}

		/* subband transform - if stereo, interleaves pcm LRLRLR */
		if (Subband(mp3DecInfo, outbuf + gr*mp3DecInfo->nGranSamps*mp3DecInfo->nChans) < 0) {
 8018224:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018226:	f8d3 37c8 	ldr.w	r3, [r3, #1992]	; 0x7c8
 801822a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801822c:	fb02 f303 	mul.w	r3, r2, r3
 8018230:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8018232:	f8d2 27bc 	ldr.w	r2, [r2, #1980]	; 0x7bc
 8018236:	fb02 f303 	mul.w	r3, r2, r3
 801823a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801823e:	683a      	ldr	r2, [r7, #0]
 8018240:	18d3      	adds	r3, r2, r3
 8018242:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018244:	4619      	mov	r1, r3
 8018246:	f7ff fb85 	bl	8017954 <xmp3_Subband>
 801824a:	4603      	mov	r3, r0
 801824c:	2b00      	cmp	r3, #0
 801824e:	da06      	bge.n	801825e <MP3Decode+0x45a>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
 8018250:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8018252:	6839      	ldr	r1, [r7, #0]
 8018254:	f7ff fda6 	bl	8017da4 <MP3ClearBadFrame>
			return ERR_MP3_INVALID_SUBBAND;			
 8018258:	f06f 030b 	mvn.w	r3, #11
 801825c:	e00c      	b.n	8018278 <MP3Decode+0x474>
	}
	bitOffset = 0;
	mainBits = mp3DecInfo->mainDataBytes * 8;

	/* decode one complete frame */
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 801825e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8018260:	f103 0301 	add.w	r3, r3, #1
 8018264:	643b      	str	r3, [r7, #64]	; 0x40
 8018266:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018268:	f8d3 27c4 	ldr.w	r2, [r3, #1988]	; 0x7c4
 801826c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801826e:	429a      	cmp	r2, r3
 8018270:	f73f af37 	bgt.w	80180e2 <MP3Decode+0x2de>
		if (Subband(mp3DecInfo, outbuf + gr*mp3DecInfo->nGranSamps*mp3DecInfo->nChans) < 0) {
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_INVALID_SUBBAND;			
		}
	}
	return ERR_MP3_NONE;
 8018274:	f04f 0300 	mov.w	r3, #0
}
 8018278:	4618      	mov	r0, r3
 801827a:	f107 074c 	add.w	r7, r7, #76	; 0x4c
 801827e:	46bd      	mov	sp, r7
 8018280:	bd90      	pop	{r4, r7, pc}
 8018282:	bf00      	nop

08018284 <_ZN11CGraphicLCDC1Ev>:
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

CGraphicLCD::CGraphicLCD() {
 8018284:	b480      	push	{r7}
 8018286:	b083      	sub	sp, #12
 8018288:	af00      	add	r7, sp, #0
 801828a:	6078      	str	r0, [r7, #4]
 801828c:	687b      	ldr	r3, [r7, #4]
 801828e:	4a06      	ldr	r2, [pc, #24]	; (80182a8 <_ZN11CGraphicLCDC1Ev+0x24>)
 8018290:	601a      	str	r2, [r3, #0]
	bInverse=false;
 8018292:	687b      	ldr	r3, [r7, #4]
 8018294:	f04f 0200 	mov.w	r2, #0
 8018298:	711a      	strb	r2, [r3, #4]
}
 801829a:	687b      	ldr	r3, [r7, #4]
 801829c:	4618      	mov	r0, r3
 801829e:	f107 070c 	add.w	r7, r7, #12
 80182a2:	46bd      	mov	sp, r7
 80182a4:	bc80      	pop	{r7}
 80182a6:	4770      	bx	lr
 80182a8:	0802f070 	.word	0x0802f070

080182ac <_ZN11CGraphicLCDC1Eb>:

CGraphicLCD::CGraphicLCD(bool inverse) {
 80182ac:	b480      	push	{r7}
 80182ae:	b083      	sub	sp, #12
 80182b0:	af00      	add	r7, sp, #0
 80182b2:	6078      	str	r0, [r7, #4]
 80182b4:	460b      	mov	r3, r1
 80182b6:	70fb      	strb	r3, [r7, #3]
 80182b8:	687b      	ldr	r3, [r7, #4]
 80182ba:	4a06      	ldr	r2, [pc, #24]	; (80182d4 <_ZN11CGraphicLCDC1Eb+0x28>)
 80182bc:	601a      	str	r2, [r3, #0]
	bInverse=inverse;
 80182be:	687b      	ldr	r3, [r7, #4]
 80182c0:	78fa      	ldrb	r2, [r7, #3]
 80182c2:	711a      	strb	r2, [r3, #4]
}
 80182c4:	687b      	ldr	r3, [r7, #4]
 80182c6:	4618      	mov	r0, r3
 80182c8:	f107 070c 	add.w	r7, r7, #12
 80182cc:	46bd      	mov	sp, r7
 80182ce:	bc80      	pop	{r7}
 80182d0:	4770      	bx	lr
 80182d2:	bf00      	nop
 80182d4:	0802f070 	.word	0x0802f070

080182d8 <_ZN11CGraphicLCDD1Ev>:

CGraphicLCD::~CGraphicLCD() {
 80182d8:	b580      	push	{r7, lr}
 80182da:	b082      	sub	sp, #8
 80182dc:	af00      	add	r7, sp, #0
 80182de:	6078      	str	r0, [r7, #4]
 80182e0:	687b      	ldr	r3, [r7, #4]
 80182e2:	4a09      	ldr	r2, [pc, #36]	; (8018308 <_ZN11CGraphicLCDD1Ev+0x30>)
 80182e4:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated destructor stub
}
 80182e6:	f04f 0300 	mov.w	r3, #0
 80182ea:	f003 0301 	and.w	r3, r3, #1
 80182ee:	b2db      	uxtb	r3, r3
 80182f0:	2b00      	cmp	r3, #0
 80182f2:	d002      	beq.n	80182fa <_ZN11CGraphicLCDD1Ev+0x22>
 80182f4:	6878      	ldr	r0, [r7, #4]
 80182f6:	f009 ff6d 	bl	80221d4 <_ZdlPv>
 80182fa:	687b      	ldr	r3, [r7, #4]
 80182fc:	4618      	mov	r0, r3
 80182fe:	f107 0708 	add.w	r7, r7, #8
 8018302:	46bd      	mov	sp, r7
 8018304:	bd80      	pop	{r7, pc}
 8018306:	bf00      	nop
 8018308:	0802f070 	.word	0x0802f070

0801830c <_ZN11CGraphicLCDD0Ev>:

CGraphicLCD::CGraphicLCD(bool inverse) {
	bInverse=inverse;
}

CGraphicLCD::~CGraphicLCD() {
 801830c:	b580      	push	{r7, lr}
 801830e:	b082      	sub	sp, #8
 8018310:	af00      	add	r7, sp, #0
 8018312:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated destructor stub
}
 8018314:	6878      	ldr	r0, [r7, #4]
 8018316:	f7ff ffdf 	bl	80182d8 <_ZN11CGraphicLCDD1Ev>
 801831a:	6878      	ldr	r0, [r7, #4]
 801831c:	f009 ff5a 	bl	80221d4 <_ZdlPv>
 8018320:	687b      	ldr	r3, [r7, #4]
 8018322:	4618      	mov	r0, r3
 8018324:	f107 0708 	add.w	r7, r7, #8
 8018328:	46bd      	mov	sp, r7
 801832a:	bd80      	pop	{r7, pc}

0801832c <_ZN11CGraphicLCD7InverseEv>:
/**
  * @brief gives inverted draw status
  * @param  None
  * @retval true on inverse mode
  */
bool CGraphicLCD::Inverse(){
 801832c:	b480      	push	{r7}
 801832e:	b083      	sub	sp, #12
 8018330:	af00      	add	r7, sp, #0
 8018332:	6078      	str	r0, [r7, #4]
	return bInverse;
 8018334:	687b      	ldr	r3, [r7, #4]
 8018336:	791b      	ldrb	r3, [r3, #4]
}
 8018338:	4618      	mov	r0, r3
 801833a:	f107 070c 	add.w	r7, r7, #12
 801833e:	46bd      	mov	sp, r7
 8018340:	bc80      	pop	{r7}
 8018342:	4770      	bx	lr

08018344 <_ZN11CGraphicLCD7InverseEb>:
/**
  * @brief  sets inverted draw mode
  * @param  ture for inverted draw mode
  * @retval None
  */
void CGraphicLCD::Inverse(bool inverse){
 8018344:	b480      	push	{r7}
 8018346:	b083      	sub	sp, #12
 8018348:	af00      	add	r7, sp, #0
 801834a:	6078      	str	r0, [r7, #4]
 801834c:	460b      	mov	r3, r1
 801834e:	70fb      	strb	r3, [r7, #3]
	bInverse = inverse;
 8018350:	687b      	ldr	r3, [r7, #4]
 8018352:	78fa      	ldrb	r2, [r7, #3]
 8018354:	711a      	strb	r2, [r3, #4]
}
 8018356:	f107 070c 	add.w	r7, r7, #12
 801835a:	46bd      	mov	sp, r7
 801835c:	bc80      	pop	{r7}
 801835e:	4770      	bx	lr

08018360 <_ZN13CT6963CDriverC1Ev>:
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/


CT6963CDriver::CT6963CDriver() {
 8018360:	b580      	push	{r7, lr}
 8018362:	b082      	sub	sp, #8
 8018364:	af00      	add	r7, sp, #0
 8018366:	6078      	str	r0, [r7, #4]
 8018368:	687b      	ldr	r3, [r7, #4]
 801836a:	4618      	mov	r0, r3
 801836c:	f7ff ff8a 	bl	8018284 <_ZN11CGraphicLCDC1Ev>
 8018370:	687b      	ldr	r3, [r7, #4]
 8018372:	4a04      	ldr	r2, [pc, #16]	; (8018384 <_ZN13CT6963CDriverC1Ev+0x24>)
 8018374:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated constructor stub

}
 8018376:	687b      	ldr	r3, [r7, #4]
 8018378:	4618      	mov	r0, r3
 801837a:	f107 0708 	add.w	r7, r7, #8
 801837e:	46bd      	mov	sp, r7
 8018380:	bd80      	pop	{r7, pc}
 8018382:	bf00      	nop
 8018384:	0802f0a8 	.word	0x0802f0a8

08018388 <_ZN13CT6963CDriverD1Ev>:

CT6963CDriver::~CT6963CDriver() {
 8018388:	b580      	push	{r7, lr}
 801838a:	b082      	sub	sp, #8
 801838c:	af00      	add	r7, sp, #0
 801838e:	6078      	str	r0, [r7, #4]
 8018390:	687b      	ldr	r3, [r7, #4]
 8018392:	4a0a      	ldr	r2, [pc, #40]	; (80183bc <_ZN13CT6963CDriverD1Ev+0x34>)
 8018394:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated destructor stub
}
 8018396:	6878      	ldr	r0, [r7, #4]
 8018398:	f7ff ff9e 	bl	80182d8 <_ZN11CGraphicLCDD1Ev>
 801839c:	f04f 0300 	mov.w	r3, #0
 80183a0:	f003 0301 	and.w	r3, r3, #1
 80183a4:	b2db      	uxtb	r3, r3
 80183a6:	2b00      	cmp	r3, #0
 80183a8:	d002      	beq.n	80183b0 <_ZN13CT6963CDriverD1Ev+0x28>
 80183aa:	6878      	ldr	r0, [r7, #4]
 80183ac:	f009 ff12 	bl	80221d4 <_ZdlPv>
 80183b0:	687b      	ldr	r3, [r7, #4]
 80183b2:	4618      	mov	r0, r3
 80183b4:	f107 0708 	add.w	r7, r7, #8
 80183b8:	46bd      	mov	sp, r7
 80183ba:	bd80      	pop	{r7, pc}
 80183bc:	0802f0a8 	.word	0x0802f0a8

080183c0 <_ZN13CT6963CDriverD0Ev>:
CT6963CDriver::CT6963CDriver() {
	// TODO Auto-generated constructor stub

}

CT6963CDriver::~CT6963CDriver() {
 80183c0:	b580      	push	{r7, lr}
 80183c2:	b082      	sub	sp, #8
 80183c4:	af00      	add	r7, sp, #0
 80183c6:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated destructor stub
}
 80183c8:	6878      	ldr	r0, [r7, #4]
 80183ca:	f7ff ffdd 	bl	8018388 <_ZN13CT6963CDriverD1Ev>
 80183ce:	6878      	ldr	r0, [r7, #4]
 80183d0:	f009 ff00 	bl	80221d4 <_ZdlPv>
 80183d4:	687b      	ldr	r3, [r7, #4]
 80183d6:	4618      	mov	r0, r3
 80183d8:	f107 0708 	add.w	r7, r7, #8
 80183dc:	46bd      	mov	sp, r7
 80183de:	bd80      	pop	{r7, pc}

080183e0 <_ZN13CT6963CDriver4InitEv>:
/**
  * @brief  initializes Display controller
  * @param  None
  * @retval None
  */
void CT6963CDriver::Init(){
 80183e0:	b580      	push	{r7, lr}
 80183e2:	b082      	sub	sp, #8
 80183e4:	af00      	add	r7, sp, #0
 80183e6:	6078      	str	r0, [r7, #4]

	HardwareInit();
 80183e8:	687b      	ldr	r3, [r7, #4]
 80183ea:	681b      	ldr	r3, [r3, #0]
 80183ec:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 80183f0:	681b      	ldr	r3, [r3, #0]
 80183f2:	6878      	ldr	r0, [r7, #4]
 80183f4:	4798      	blx	r3

	Reset();
 80183f6:	687b      	ldr	r3, [r7, #4]
 80183f8:	681b      	ldr	r3, [r3, #0]
 80183fa:	f103 0330 	add.w	r3, r3, #48	; 0x30
 80183fe:	681b      	ldr	r3, [r3, #0]
 8018400:	6878      	ldr	r0, [r7, #4]
 8018402:	4798      	blx	r3

	// Graphic home address
	WriteData(GLCD_GRAPHIC_HOME & 0xFF);
 8018404:	687b      	ldr	r3, [r7, #4]
 8018406:	681b      	ldr	r3, [r3, #0]
 8018408:	f103 0338 	add.w	r3, r3, #56	; 0x38
 801840c:	681b      	ldr	r3, [r3, #0]
 801840e:	6878      	ldr	r0, [r7, #4]
 8018410:	f04f 01e0 	mov.w	r1, #224	; 0xe0
 8018414:	4798      	blx	r3
	WriteData(GLCD_GRAPHIC_HOME >> 8);
 8018416:	687b      	ldr	r3, [r7, #4]
 8018418:	681b      	ldr	r3, [r3, #0]
 801841a:	f103 0338 	add.w	r3, r3, #56	; 0x38
 801841e:	681b      	ldr	r3, [r3, #0]
 8018420:	6878      	ldr	r0, [r7, #4]
 8018422:	f04f 0101 	mov.w	r1, #1
 8018426:	4798      	blx	r3
	WriteCommand(T6963_SET_GRAPHIC_HOME_ADDRESS);
 8018428:	687b      	ldr	r3, [r7, #4]
 801842a:	681b      	ldr	r3, [r3, #0]
 801842c:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8018430:	681b      	ldr	r3, [r3, #0]
 8018432:	6878      	ldr	r0, [r7, #4]
 8018434:	f04f 0142 	mov.w	r1, #66	; 0x42
 8018438:	4798      	blx	r3

	//graphic line length
	WriteData(GLCD_GRAPHIC_AREA);
 801843a:	687b      	ldr	r3, [r7, #4]
 801843c:	681b      	ldr	r3, [r3, #0]
 801843e:	f103 0338 	add.w	r3, r3, #56	; 0x38
 8018442:	681b      	ldr	r3, [r3, #0]
 8018444:	6878      	ldr	r0, [r7, #4]
 8018446:	f04f 011e 	mov.w	r1, #30
 801844a:	4798      	blx	r3
	WriteData(0x00);
 801844c:	687b      	ldr	r3, [r7, #4]
 801844e:	681b      	ldr	r3, [r3, #0]
 8018450:	f103 0338 	add.w	r3, r3, #56	; 0x38
 8018454:	681b      	ldr	r3, [r3, #0]
 8018456:	6878      	ldr	r0, [r7, #4]
 8018458:	f04f 0100 	mov.w	r1, #0
 801845c:	4798      	blx	r3
	WriteCommand(T6963_SET_GRAPHIC_AREA);
 801845e:	687b      	ldr	r3, [r7, #4]
 8018460:	681b      	ldr	r3, [r3, #0]
 8018462:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8018466:	681b      	ldr	r3, [r3, #0]
 8018468:	6878      	ldr	r0, [r7, #4]
 801846a:	f04f 0143 	mov.w	r1, #67	; 0x43
 801846e:	4798      	blx	r3

	//text home address
	WriteData(GLCD_TEXT_HOME & 0xFF);
 8018470:	687b      	ldr	r3, [r7, #4]
 8018472:	681b      	ldr	r3, [r3, #0]
 8018474:	f103 0338 	add.w	r3, r3, #56	; 0x38
 8018478:	681b      	ldr	r3, [r3, #0]
 801847a:	6878      	ldr	r0, [r7, #4]
 801847c:	f04f 0100 	mov.w	r1, #0
 8018480:	4798      	blx	r3
	WriteData(GLCD_TEXT_HOME >> 8);
 8018482:	687b      	ldr	r3, [r7, #4]
 8018484:	681b      	ldr	r3, [r3, #0]
 8018486:	f103 0338 	add.w	r3, r3, #56	; 0x38
 801848a:	681b      	ldr	r3, [r3, #0]
 801848c:	6878      	ldr	r0, [r7, #4]
 801848e:	f04f 0100 	mov.w	r1, #0
 8018492:	4798      	blx	r3
	WriteCommand(T6963_SET_TEXT_HOME_ADDRESS);
 8018494:	687b      	ldr	r3, [r7, #4]
 8018496:	681b      	ldr	r3, [r3, #0]
 8018498:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801849c:	681b      	ldr	r3, [r3, #0]
 801849e:	6878      	ldr	r0, [r7, #4]
 80184a0:	f04f 0140 	mov.w	r1, #64	; 0x40
 80184a4:	4798      	blx	r3

	//text line length
	WriteData(GLCD_TEXT_AREA);
 80184a6:	687b      	ldr	r3, [r7, #4]
 80184a8:	681b      	ldr	r3, [r3, #0]
 80184aa:	f103 0338 	add.w	r3, r3, #56	; 0x38
 80184ae:	681b      	ldr	r3, [r3, #0]
 80184b0:	6878      	ldr	r0, [r7, #4]
 80184b2:	f04f 011e 	mov.w	r1, #30
 80184b6:	4798      	blx	r3
	WriteData(0x00);
 80184b8:	687b      	ldr	r3, [r7, #4]
 80184ba:	681b      	ldr	r3, [r3, #0]
 80184bc:	f103 0338 	add.w	r3, r3, #56	; 0x38
 80184c0:	681b      	ldr	r3, [r3, #0]
 80184c2:	6878      	ldr	r0, [r7, #4]
 80184c4:	f04f 0100 	mov.w	r1, #0
 80184c8:	4798      	blx	r3
	WriteCommand(T6963_SET_TEXT_AREA);
 80184ca:	687b      	ldr	r3, [r7, #4]
 80184cc:	681b      	ldr	r3, [r3, #0]
 80184ce:	f103 0334 	add.w	r3, r3, #52	; 0x34
 80184d2:	681b      	ldr	r3, [r3, #0]
 80184d4:	6878      	ldr	r0, [r7, #4]
 80184d6:	f04f 0141 	mov.w	r1, #65	; 0x41
 80184da:	4798      	blx	r3

	//write offset register  (no effect)
	WriteData(GLCD_OFFSET_REGISTER);
 80184dc:	687b      	ldr	r3, [r7, #4]
 80184de:	681b      	ldr	r3, [r3, #0]
 80184e0:	f103 0338 	add.w	r3, r3, #56	; 0x38
 80184e4:	681b      	ldr	r3, [r3, #0]
 80184e6:	6878      	ldr	r0, [r7, #4]
 80184e8:	f04f 0102 	mov.w	r1, #2
 80184ec:	4798      	blx	r3
	WriteData(0x00);
 80184ee:	687b      	ldr	r3, [r7, #4]
 80184f0:	681b      	ldr	r3, [r3, #0]
 80184f2:	f103 0338 	add.w	r3, r3, #56	; 0x38
 80184f6:	681b      	ldr	r3, [r3, #0]
 80184f8:	6878      	ldr	r0, [r7, #4]
 80184fa:	f04f 0100 	mov.w	r1, #0
 80184fe:	4798      	blx	r3
	WriteCommand(T6963_SET_OFFSET_REGISTER);
 8018500:	687b      	ldr	r3, [r7, #4]
 8018502:	681b      	ldr	r3, [r3, #0]
 8018504:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8018508:	681b      	ldr	r3, [r3, #0]
 801850a:	6878      	ldr	r0, [r7, #4]
 801850c:	f04f 0122 	mov.w	r1, #34	; 0x22
 8018510:	4798      	blx	r3

	// display in XOR Mode
	WriteCommand(T6963_MODE_SET | 1);
 8018512:	687b      	ldr	r3, [r7, #4]
 8018514:	681b      	ldr	r3, [r3, #0]
 8018516:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801851a:	681b      	ldr	r3, [r3, #0]
 801851c:	6878      	ldr	r0, [r7, #4]
 801851e:	f04f 0181 	mov.w	r1, #129	; 0x81
 8018522:	4798      	blx	r3

	//Graphic and Text mode
	WriteCommand(T6963_DISPLAY_MODE  | T6963_TEXT_DISPLAY_ON | T6963_GRAPHIC_DISPLAY_ON );
 8018524:	687b      	ldr	r3, [r7, #4]
 8018526:	681b      	ldr	r3, [r3, #0]
 8018528:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801852c:	681b      	ldr	r3, [r3, #0]
 801852e:	6878      	ldr	r0, [r7, #4]
 8018530:	f04f 019c 	mov.w	r1, #156	; 0x9c
 8018534:	4798      	blx	r3
}
 8018536:	f107 0708 	add.w	r7, r7, #8
 801853a:	46bd      	mov	sp, r7
 801853c:	bd80      	pop	{r7, pc}
 801853e:	bf00      	nop

08018540 <_ZN13CT6963CDriver17SetAddressPointerEj>:
/**
  * @brief  set address pointer in T6963C
  * @param  address
  * @retval None
  */
void CT6963CDriver::SetAddressPointer(unsigned int address){
 8018540:	b580      	push	{r7, lr}
 8018542:	b082      	sub	sp, #8
 8018544:	af00      	add	r7, sp, #0
 8018546:	6078      	str	r0, [r7, #4]
 8018548:	6039      	str	r1, [r7, #0]
	address += 2; // display offset
 801854a:	683b      	ldr	r3, [r7, #0]
 801854c:	f103 0302 	add.w	r3, r3, #2
 8018550:	603b      	str	r3, [r7, #0]
	WriteData(address & 0xFF);
 8018552:	687b      	ldr	r3, [r7, #4]
 8018554:	681b      	ldr	r3, [r3, #0]
 8018556:	f103 0338 	add.w	r3, r3, #56	; 0x38
 801855a:	681b      	ldr	r3, [r3, #0]
 801855c:	683a      	ldr	r2, [r7, #0]
 801855e:	b2d2      	uxtb	r2, r2
 8018560:	6878      	ldr	r0, [r7, #4]
 8018562:	4611      	mov	r1, r2
 8018564:	4798      	blx	r3
	WriteData(address >> 8);
 8018566:	687b      	ldr	r3, [r7, #4]
 8018568:	681b      	ldr	r3, [r3, #0]
 801856a:	f103 0338 	add.w	r3, r3, #56	; 0x38
 801856e:	681b      	ldr	r3, [r3, #0]
 8018570:	683a      	ldr	r2, [r7, #0]
 8018572:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8018576:	b2d2      	uxtb	r2, r2
 8018578:	6878      	ldr	r0, [r7, #4]
 801857a:	4611      	mov	r1, r2
 801857c:	4798      	blx	r3
	WriteCommand(T6963_SET_ADDRESS_POINTER);
 801857e:	687b      	ldr	r3, [r7, #4]
 8018580:	681b      	ldr	r3, [r3, #0]
 8018582:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8018586:	681b      	ldr	r3, [r3, #0]
 8018588:	6878      	ldr	r0, [r7, #4]
 801858a:	f04f 0124 	mov.w	r1, #36	; 0x24
 801858e:	4798      	blx	r3
}
 8018590:	f107 0708 	add.w	r7, r7, #8
 8018594:	46bd      	mov	sp, r7
 8018596:	bd80      	pop	{r7, pc}

08018598 <_ZN13CT6963CDriver8TextGoToEhh>:
  * @brief  sets address pointer to specific text address
  * @param  column and line
  * @retval None
  */
void CT6963CDriver::TextGoTo(unsigned char x, unsigned char y)
{
 8018598:	b580      	push	{r7, lr}
 801859a:	b084      	sub	sp, #16
 801859c:	af00      	add	r7, sp, #0
 801859e:	6078      	str	r0, [r7, #4]
 80185a0:	4613      	mov	r3, r2
 80185a2:	460a      	mov	r2, r1
 80185a4:	70fa      	strb	r2, [r7, #3]
 80185a6:	70bb      	strb	r3, [r7, #2]
	unsigned int address;

	address = GLCD_TEXT_HOME +  x + (GLCD_TEXT_AREA * y);
 80185a8:	78f9      	ldrb	r1, [r7, #3]
 80185aa:	78ba      	ldrb	r2, [r7, #2]
 80185ac:	4613      	mov	r3, r2
 80185ae:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80185b2:	1a9b      	subs	r3, r3, r2
 80185b4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80185b8:	18cb      	adds	r3, r1, r3
 80185ba:	60fb      	str	r3, [r7, #12]
	SetAddressPointer(address);
 80185bc:	6878      	ldr	r0, [r7, #4]
 80185be:	68f9      	ldr	r1, [r7, #12]
 80185c0:	f7ff ffbe 	bl	8018540 <_ZN13CT6963CDriver17SetAddressPointerEj>
}
 80185c4:	f107 0710 	add.w	r7, r7, #16
 80185c8:	46bd      	mov	sp, r7
 80185ca:	bd80      	pop	{r7, pc}

080185cc <_ZN13CT6963CDriver11GraphicGoToEhh>:
  * @brief  sets address pointer to specific pixel in graphics ram
  * @param  coordinates of the pixel byte
  * @retval None
  */
void CT6963CDriver::GraphicGoTo(unsigned char x, unsigned char y)
{
 80185cc:	b580      	push	{r7, lr}
 80185ce:	b084      	sub	sp, #16
 80185d0:	af00      	add	r7, sp, #0
 80185d2:	6078      	str	r0, [r7, #4]
 80185d4:	4613      	mov	r3, r2
 80185d6:	460a      	mov	r2, r1
 80185d8:	70fa      	strb	r2, [r7, #3]
 80185da:	70bb      	strb	r3, [r7, #2]
	unsigned int address;
	address = GLCD_GRAPHIC_HOME + ((x) / GLCD_FONT_WIDTH) + (GLCD_GRAPHIC_AREA * y);
 80185dc:	78fb      	ldrb	r3, [r7, #3]
 80185de:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80185e2:	b2db      	uxtb	r3, r3
 80185e4:	4619      	mov	r1, r3
 80185e6:	78ba      	ldrb	r2, [r7, #2]
 80185e8:	4613      	mov	r3, r2
 80185ea:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80185ee:	1a9b      	subs	r3, r3, r2
 80185f0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80185f4:	18cb      	adds	r3, r1, r3
 80185f6:	f503 73f0 	add.w	r3, r3, #480	; 0x1e0
 80185fa:	60fb      	str	r3, [r7, #12]
	SetAddressPointer(address);
 80185fc:	6878      	ldr	r0, [r7, #4]
 80185fe:	68f9      	ldr	r1, [r7, #12]
 8018600:	f7ff ff9e 	bl	8018540 <_ZN13CT6963CDriver17SetAddressPointerEj>
}
 8018604:	f107 0710 	add.w	r7, r7, #16
 8018608:	46bd      	mov	sp, r7
 801860a:	bd80      	pop	{r7, pc}

0801860c <_ZN13CT6963CDriver5ClearEv>:
/**
  * @brief  Clear Display
  * @param  None
  * @retval None
  */
void CT6963CDriver::Clear(){
 801860c:	b580      	push	{r7, lr}
 801860e:	b084      	sub	sp, #16
 8018610:	af00      	add	r7, sp, #0
 8018612:	6078      	str	r0, [r7, #4]
	unsigned int i;
	// Graphics and Text are different mem pools in this Controller
	SetAddressPointer(GLCD_GRAPHIC_HOME);
 8018614:	6878      	ldr	r0, [r7, #4]
 8018616:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
 801861a:	f7ff ff91 	bl	8018540 <_ZN13CT6963CDriver17SetAddressPointerEj>

	for(i = 0; i < GLCD_GRAPHIC_SIZE; i++)
 801861e:	f04f 0300 	mov.w	r3, #0
 8018622:	60fb      	str	r3, [r7, #12]
 8018624:	e015      	b.n	8018652 <_ZN13CT6963CDriver5ClearEv+0x46>
	{
		if(Inverse())
 8018626:	687b      	ldr	r3, [r7, #4]
 8018628:	4618      	mov	r0, r3
 801862a:	f7ff fe7f 	bl	801832c <_ZN11CGraphicLCD7InverseEv>
 801862e:	4603      	mov	r3, r0
 8018630:	2b00      	cmp	r3, #0
 8018632:	d005      	beq.n	8018640 <_ZN13CT6963CDriver5ClearEv+0x34>
			WriteDisplayData(0xFF);
 8018634:	6878      	ldr	r0, [r7, #4]
 8018636:	f04f 01ff 	mov.w	r1, #255	; 0xff
 801863a:	f000 f835 	bl	80186a8 <_ZN13CT6963CDriver16WriteDisplayDataEh>
 801863e:	e004      	b.n	801864a <_ZN13CT6963CDriver5ClearEv+0x3e>
		else
			WriteDisplayData(0x00);
 8018640:	6878      	ldr	r0, [r7, #4]
 8018642:	f04f 0100 	mov.w	r1, #0
 8018646:	f000 f82f 	bl	80186a8 <_ZN13CT6963CDriver16WriteDisplayDataEh>
void CT6963CDriver::Clear(){
	unsigned int i;
	// Graphics and Text are different mem pools in this Controller
	SetAddressPointer(GLCD_GRAPHIC_HOME);

	for(i = 0; i < GLCD_GRAPHIC_SIZE; i++)
 801864a:	68fb      	ldr	r3, [r7, #12]
 801864c:	f103 0301 	add.w	r3, r3, #1
 8018650:	60fb      	str	r3, [r7, #12]
 8018652:	68fa      	ldr	r2, [r7, #12]
 8018654:	f640 63ff 	movw	r3, #3839	; 0xeff
 8018658:	429a      	cmp	r2, r3
 801865a:	bf8c      	ite	hi
 801865c:	2300      	movhi	r3, #0
 801865e:	2301      	movls	r3, #1
 8018660:	b2db      	uxtb	r3, r3
 8018662:	2b00      	cmp	r3, #0
 8018664:	d1df      	bne.n	8018626 <_ZN13CT6963CDriver5ClearEv+0x1a>
			WriteDisplayData(0xFF);
		else
			WriteDisplayData(0x00);
	}

	SetAddressPointer(GLCD_TEXT_HOME);
 8018666:	6878      	ldr	r0, [r7, #4]
 8018668:	f04f 0100 	mov.w	r1, #0
 801866c:	f7ff ff68 	bl	8018540 <_ZN13CT6963CDriver17SetAddressPointerEj>

	for(i = 0; i < GLCD_TEXT_SIZE; i++)
 8018670:	f04f 0300 	mov.w	r3, #0
 8018674:	60fb      	str	r3, [r7, #12]
 8018676:	e008      	b.n	801868a <_ZN13CT6963CDriver5ClearEv+0x7e>
	{
			WriteDisplayData(0x00);
 8018678:	6878      	ldr	r0, [r7, #4]
 801867a:	f04f 0100 	mov.w	r1, #0
 801867e:	f000 f813 	bl	80186a8 <_ZN13CT6963CDriver16WriteDisplayDataEh>
			WriteDisplayData(0x00);
	}

	SetAddressPointer(GLCD_TEXT_HOME);

	for(i = 0; i < GLCD_TEXT_SIZE; i++)
 8018682:	68fb      	ldr	r3, [r7, #12]
 8018684:	f103 0301 	add.w	r3, r3, #1
 8018688:	60fb      	str	r3, [r7, #12]
 801868a:	68fa      	ldr	r2, [r7, #12]
 801868c:	f240 13df 	movw	r3, #479	; 0x1df
 8018690:	429a      	cmp	r2, r3
 8018692:	bf8c      	ite	hi
 8018694:	2300      	movhi	r3, #0
 8018696:	2301      	movls	r3, #1
 8018698:	b2db      	uxtb	r3, r3
 801869a:	2b00      	cmp	r3, #0
 801869c:	d1ec      	bne.n	8018678 <_ZN13CT6963CDriver5ClearEv+0x6c>
	{
			WriteDisplayData(0x00);
	}
}
 801869e:	f107 0710 	add.w	r7, r7, #16
 80186a2:	46bd      	mov	sp, r7
 80186a4:	bd80      	pop	{r7, pc}
 80186a6:	bf00      	nop

080186a8 <_ZN13CT6963CDriver16WriteDisplayDataEh>:
  * @brief  writes incremental data to display ram
  * @param  data byte
  * @retval None
  */
void CT6963CDriver::WriteDisplayData(unsigned char x)
{
 80186a8:	b580      	push	{r7, lr}
 80186aa:	b082      	sub	sp, #8
 80186ac:	af00      	add	r7, sp, #0
 80186ae:	6078      	str	r0, [r7, #4]
 80186b0:	460b      	mov	r3, r1
 80186b2:	70fb      	strb	r3, [r7, #3]
	WriteData(x);
 80186b4:	687b      	ldr	r3, [r7, #4]
 80186b6:	681b      	ldr	r3, [r3, #0]
 80186b8:	f103 0338 	add.w	r3, r3, #56	; 0x38
 80186bc:	681b      	ldr	r3, [r3, #0]
 80186be:	78fa      	ldrb	r2, [r7, #3]
 80186c0:	6878      	ldr	r0, [r7, #4]
 80186c2:	4611      	mov	r1, r2
 80186c4:	4798      	blx	r3
	WriteCommand(T6963_DATA_WRITE_AND_INCREMENT);
 80186c6:	687b      	ldr	r3, [r7, #4]
 80186c8:	681b      	ldr	r3, [r3, #0]
 80186ca:	f103 0334 	add.w	r3, r3, #52	; 0x34
 80186ce:	681b      	ldr	r3, [r3, #0]
 80186d0:	6878      	ldr	r0, [r7, #4]
 80186d2:	f04f 01c0 	mov.w	r1, #192	; 0xc0
 80186d6:	4798      	blx	r3
}
 80186d8:	f107 0708 	add.w	r7, r7, #8
 80186dc:	46bd      	mov	sp, r7
 80186de:	bd80      	pop	{r7, pc}

080186e0 <_ZN13CT6963CDriver9WriteCharEc>:
  * @brief  writes single ASCII char to display
  * @param  ASCII char
  * @retval None
  */
void CT6963CDriver::WriteChar(char charCode)
{
 80186e0:	b580      	push	{r7, lr}
 80186e2:	b082      	sub	sp, #8
 80186e4:	af00      	add	r7, sp, #0
 80186e6:	6078      	str	r0, [r7, #4]
 80186e8:	460b      	mov	r3, r1
 80186ea:	70fb      	strb	r3, [r7, #3]
	WriteDisplayData(charCode - 32);
 80186ec:	78fb      	ldrb	r3, [r7, #3]
 80186ee:	f1a3 0320 	sub.w	r3, r3, #32
 80186f2:	b2db      	uxtb	r3, r3
 80186f4:	6878      	ldr	r0, [r7, #4]
 80186f6:	4619      	mov	r1, r3
 80186f8:	f7ff ffd6 	bl	80186a8 <_ZN13CT6963CDriver16WriteDisplayDataEh>
}
 80186fc:	f107 0708 	add.w	r7, r7, #8
 8018700:	46bd      	mov	sp, r7
 8018702:	bd80      	pop	{r7, pc}

08018704 <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj>:
  * 		ground must be cleared
  * @param  null terminated string, font structure, x, y
  * @retval None
  */
void CT6963CDriver::WriteString(const char * str, const tFont &font,unsigned int x, unsigned int y)
{
 8018704:	b580      	push	{r7, lr}
 8018706:	b08c      	sub	sp, #48	; 0x30
 8018708:	af00      	add	r7, sp, #0
 801870a:	60f8      	str	r0, [r7, #12]
 801870c:	60b9      	str	r1, [r7, #8]
 801870e:	607a      	str	r2, [r7, #4]
 8018710:	603b      	str	r3, [r7, #0]
	unsigned int offset,width;
	unsigned int i,j,map,height,allwidth=0;
 8018712:	f04f 0300 	mov.w	r3, #0
 8018716:	623b      	str	r3, [r7, #32]

	// use internal Character generator
	if(font.glyph_height == 0){
 8018718:	687b      	ldr	r3, [r7, #4]
 801871a:	685b      	ldr	r3, [r3, #4]
 801871c:	2b00      	cmp	r3, #0
 801871e:	f040 80aa 	bne.w	8018876 <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0x172>
		TextGoTo(x/GLCD_FONT_WIDTH, y/8);
 8018722:	683b      	ldr	r3, [r7, #0]
 8018724:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8018728:	b2da      	uxtb	r2, r3
 801872a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801872c:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8018730:	b2db      	uxtb	r3, r3
 8018732:	68f8      	ldr	r0, [r7, #12]
 8018734:	4611      	mov	r1, r2
 8018736:	461a      	mov	r2, r3
 8018738:	f7ff ff2e 	bl	8018598 <_ZN13CT6963CDriver8TextGoToEhh>

		while(*str)
 801873c:	e009      	b.n	8018752 <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0x4e>
		{
			WriteChar(*str++);
 801873e:	68bb      	ldr	r3, [r7, #8]
 8018740:	781b      	ldrb	r3, [r3, #0]
 8018742:	68ba      	ldr	r2, [r7, #8]
 8018744:	f102 0201 	add.w	r2, r2, #1
 8018748:	60ba      	str	r2, [r7, #8]
 801874a:	68f8      	ldr	r0, [r7, #12]
 801874c:	4619      	mov	r1, r3
 801874e:	f7ff ffc7 	bl	80186e0 <_ZN13CT6963CDriver9WriteCharEc>

	// use internal Character generator
	if(font.glyph_height == 0){
		TextGoTo(x/GLCD_FONT_WIDTH, y/8);

		while(*str)
 8018752:	68bb      	ldr	r3, [r7, #8]
 8018754:	781b      	ldrb	r3, [r3, #0]
 8018756:	2b00      	cmp	r3, #0
 8018758:	bf0c      	ite	eq
 801875a:	2300      	moveq	r3, #0
 801875c:	2301      	movne	r3, #1
 801875e:	b2db      	uxtb	r3, r3
 8018760:	2b00      	cmp	r3, #0
 8018762:	d1ec      	bne.n	801873e <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0x3a>
 8018764:	e097      	b.n	8018896 <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0x192>
	// generate fonts
	else {
		while((map = *str++))
		{
			// get char position in font table
			map = font.mapping_table[map];
 8018766:	687b      	ldr	r3, [r7, #4]
 8018768:	68da      	ldr	r2, [r3, #12]
 801876a:	69fb      	ldr	r3, [r7, #28]
 801876c:	18d3      	adds	r3, r2, r3
 801876e:	781b      	ldrb	r3, [r3, #0]
 8018770:	61fb      	str	r3, [r7, #28]
			// determine char width
			width = font.glyph_width;
 8018772:	687b      	ldr	r3, [r7, #4]
 8018774:	681b      	ldr	r3, [r3, #0]
 8018776:	62fb      	str	r3, [r7, #44]	; 0x2c
			// font has no constant width
			if(width == 0)
 8018778:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801877a:	2b00      	cmp	r3, #0
 801877c:	d105      	bne.n	801878a <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0x86>
				width = font.width_table[map];
 801877e:	687b      	ldr	r3, [r7, #4]
 8018780:	691a      	ldr	r2, [r3, #16]
 8018782:	69fb      	ldr	r3, [r7, #28]
 8018784:	18d3      	adds	r3, r2, r3
 8018786:	781b      	ldrb	r3, [r3, #0]
 8018788:	62fb      	str	r3, [r7, #44]	; 0x2c

			// char data offset
			offset = font.offset_table[map];
 801878a:	687b      	ldr	r3, [r7, #4]
 801878c:	695a      	ldr	r2, [r3, #20]
 801878e:	69fb      	ldr	r3, [r7, #28]
 8018790:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8018794:	18d3      	adds	r3, r2, r3
 8018796:	681b      	ldr	r3, [r3, #0]
 8018798:	61bb      	str	r3, [r7, #24]
			// height is ever constant
			height = font.glyph_height;
 801879a:	687b      	ldr	r3, [r7, #4]
 801879c:	685b      	ldr	r3, [r3, #4]
 801879e:	617b      	str	r3, [r7, #20]

			//step through all lines of an char
			for(j=0 ; j<height * (((width-1)/8)+1) ; j+=(((width-1)/8)+1)    )
 80187a0:	f04f 0300 	mov.w	r3, #0
 80187a4:	627b      	str	r3, [r7, #36]	; 0x24
 80187a6:	e050      	b.n	801884a <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0x146>
			{   // step through every single point of a line of the char
				for(i=0 ; i<width  ; i++)
 80187a8:	f04f 0300 	mov.w	r3, #0
 80187ac:	62bb      	str	r3, [r7, #40]	; 0x28
 80187ae:	e039      	b.n	8018824 <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0x120>
				{   //  the pixel needs to be set
					if( font.glyph_table[ offset+j+(i/8) ] & (1 << ( 7 - ( i % 8 ) ) ) )
 80187b0:	687b      	ldr	r3, [r7, #4]
 80187b2:	689a      	ldr	r2, [r3, #8]
 80187b4:	69b9      	ldr	r1, [r7, #24]
 80187b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80187b8:	18c9      	adds	r1, r1, r3
 80187ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80187bc:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80187c0:	18cb      	adds	r3, r1, r3
 80187c2:	18d3      	adds	r3, r2, r3
 80187c4:	781b      	ldrb	r3, [r3, #0]
 80187c6:	461a      	mov	r2, r3
 80187c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80187ca:	ea6f 0303 	mvn.w	r3, r3
 80187ce:	f003 0307 	and.w	r3, r3, #7
 80187d2:	fa42 f303 	asr.w	r3, r2, r3
 80187d6:	f003 0301 	and.w	r3, r3, #1
 80187da:	b2db      	uxtb	r3, r3
 80187dc:	2b00      	cmp	r3, #0
 80187de:	d01d      	beq.n	801881c <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0x118>
						SetPixel( x+i+allwidth , y+j/ (((width-1)/8)+1)  );
 80187e0:	683b      	ldr	r3, [r7, #0]
 80187e2:	b2da      	uxtb	r2, r3
 80187e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80187e6:	b2db      	uxtb	r3, r3
 80187e8:	18d3      	adds	r3, r2, r3
 80187ea:	b2da      	uxtb	r2, r3
 80187ec:	6a3b      	ldr	r3, [r7, #32]
 80187ee:	b2db      	uxtb	r3, r3
 80187f0:	18d3      	adds	r3, r2, r3
 80187f2:	b2da      	uxtb	r2, r3
 80187f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80187f6:	f103 33ff 	add.w	r3, r3, #4294967295
 80187fa:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80187fe:	f103 0301 	add.w	r3, r3, #1
 8018802:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8018804:	fbb1 f3f3 	udiv	r3, r1, r3
 8018808:	b2d9      	uxtb	r1, r3
 801880a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801880c:	b2db      	uxtb	r3, r3
 801880e:	18cb      	adds	r3, r1, r3
 8018810:	b2db      	uxtb	r3, r3
 8018812:	68f8      	ldr	r0, [r7, #12]
 8018814:	4611      	mov	r1, r2
 8018816:	461a      	mov	r2, r3
 8018818:	f000 f842 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
			height = font.glyph_height;

			//step through all lines of an char
			for(j=0 ; j<height * (((width-1)/8)+1) ; j+=(((width-1)/8)+1)    )
			{   // step through every single point of a line of the char
				for(i=0 ; i<width  ; i++)
 801881c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801881e:	f103 0301 	add.w	r3, r3, #1
 8018822:	62bb      	str	r3, [r7, #40]	; 0x28
 8018824:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8018826:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018828:	429a      	cmp	r2, r3
 801882a:	bf2c      	ite	cs
 801882c:	2300      	movcs	r3, #0
 801882e:	2301      	movcc	r3, #1
 8018830:	b2db      	uxtb	r3, r3
 8018832:	2b00      	cmp	r3, #0
 8018834:	d1bc      	bne.n	80187b0 <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0xac>
			offset = font.offset_table[map];
			// height is ever constant
			height = font.glyph_height;

			//step through all lines of an char
			for(j=0 ; j<height * (((width-1)/8)+1) ; j+=(((width-1)/8)+1)    )
 8018836:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018838:	f103 33ff 	add.w	r3, r3, #4294967295
 801883c:	ea4f 02d3 	mov.w	r2, r3, lsr #3
 8018840:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018842:	18d3      	adds	r3, r2, r3
 8018844:	f103 0301 	add.w	r3, r3, #1
 8018848:	627b      	str	r3, [r7, #36]	; 0x24
 801884a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801884c:	f103 33ff 	add.w	r3, r3, #4294967295
 8018850:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8018854:	f103 0301 	add.w	r3, r3, #1
 8018858:	697a      	ldr	r2, [r7, #20]
 801885a:	fb02 f203 	mul.w	r2, r2, r3
 801885e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018860:	429a      	cmp	r2, r3
 8018862:	bf94      	ite	ls
 8018864:	2300      	movls	r3, #0
 8018866:	2301      	movhi	r3, #1
 8018868:	b2db      	uxtb	r3, r3
 801886a:	2b00      	cmp	r3, #0
 801886c:	d19c      	bne.n	80187a8 <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0xa4>
					if( font.glyph_table[ offset+j+(i/8) ] & (1 << ( 7 - ( i % 8 ) ) ) )
						SetPixel( x+i+allwidth , y+j/ (((width-1)/8)+1)  );
				}//End i
			}// End j
			//remember string width to set the next char directly net to the previous
			allwidth+=width;
 801886e:	6a3a      	ldr	r2, [r7, #32]
 8018870:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018872:	18d3      	adds	r3, r2, r3
 8018874:	623b      	str	r3, [r7, #32]
		}

	}
	// generate fonts
	else {
		while((map = *str++))
 8018876:	68bb      	ldr	r3, [r7, #8]
 8018878:	781b      	ldrb	r3, [r3, #0]
 801887a:	61fb      	str	r3, [r7, #28]
 801887c:	69fb      	ldr	r3, [r7, #28]
 801887e:	2b00      	cmp	r3, #0
 8018880:	bf0c      	ite	eq
 8018882:	2300      	moveq	r3, #0
 8018884:	2301      	movne	r3, #1
 8018886:	b2db      	uxtb	r3, r3
 8018888:	68ba      	ldr	r2, [r7, #8]
 801888a:	f102 0201 	add.w	r2, r2, #1
 801888e:	60ba      	str	r2, [r7, #8]
 8018890:	2b00      	cmp	r3, #0
 8018892:	f47f af68 	bne.w	8018766 <_ZN13CT6963CDriver11WriteStringEPKcRK5tFontjj+0x62>
			allwidth+=width;
		}

	}

}
 8018896:	f107 0730 	add.w	r7, r7, #48	; 0x30
 801889a:	46bd      	mov	sp, r7
 801889c:	bd80      	pop	{r7, pc}
 801889e:	bf00      	nop

080188a0 <_ZN13CT6963CDriver8SetPixelEhh>:
  * @brief  sets a pixel in graphics ram
  * @param  coordinates from upper left corner
  * @retval None
  */
void CT6963CDriver::SetPixel(unsigned char x, unsigned char y)
{
 80188a0:	b580      	push	{r7, lr}
 80188a2:	b084      	sub	sp, #16
 80188a4:	af00      	add	r7, sp, #0
 80188a6:	6078      	str	r0, [r7, #4]
 80188a8:	4613      	mov	r3, r2
 80188aa:	460a      	mov	r2, r1
 80188ac:	70fa      	strb	r2, [r7, #3]
 80188ae:	70bb      	strb	r3, [r7, #2]
	unsigned char tmp;

	// do nothing for pixel out of range
	if(x > (GLCD_PIXELS_PER_LINE-1) || y > (GLCD_NUMBER_OF_LINES-1))
 80188b0:	78fb      	ldrb	r3, [r7, #3]
 80188b2:	2bef      	cmp	r3, #239	; 0xef
 80188b4:	d832      	bhi.n	801891c <_ZN13CT6963CDriver8SetPixelEhh+0x7c>
 80188b6:	78bb      	ldrb	r3, [r7, #2]
 80188b8:	b25b      	sxtb	r3, r3
 80188ba:	2b00      	cmp	r3, #0
 80188bc:	db2e      	blt.n	801891c <_ZN13CT6963CDriver8SetPixelEhh+0x7c>
		return;

	GraphicGoTo(x,y);
 80188be:	78fa      	ldrb	r2, [r7, #3]
 80188c0:	78bb      	ldrb	r3, [r7, #2]
 80188c2:	6878      	ldr	r0, [r7, #4]
 80188c4:	4611      	mov	r1, r2
 80188c6:	461a      	mov	r2, r3
 80188c8:	f7ff fe80 	bl	80185cc <_ZN13CT6963CDriver11GraphicGoToEhh>


	tmp = (GLCD_FONT_WIDTH - 1) - (x % GLCD_FONT_WIDTH);
 80188cc:	78fb      	ldrb	r3, [r7, #3]
 80188ce:	ea6f 0303 	mvn.w	r3, r3
 80188d2:	b2db      	uxtb	r3, r3
 80188d4:	f003 0307 	and.w	r3, r3, #7
 80188d8:	73fb      	strb	r3, [r7, #15]

	if(Inverse())
 80188da:	687b      	ldr	r3, [r7, #4]
 80188dc:	4618      	mov	r0, r3
 80188de:	f7ff fd25 	bl	801832c <_ZN11CGraphicLCD7InverseEv>
 80188e2:	4603      	mov	r3, r0
 80188e4:	2b00      	cmp	r3, #0
 80188e6:	d00c      	beq.n	8018902 <_ZN13CT6963CDriver8SetPixelEhh+0x62>
		WriteCommand(T6963_BIT_RESET | tmp);
 80188e8:	687b      	ldr	r3, [r7, #4]
 80188ea:	681b      	ldr	r3, [r3, #0]
 80188ec:	f103 0334 	add.w	r3, r3, #52	; 0x34
 80188f0:	681b      	ldr	r3, [r3, #0]
 80188f2:	7bfa      	ldrb	r2, [r7, #15]
 80188f4:	f062 020f 	orn	r2, r2, #15
 80188f8:	b2d2      	uxtb	r2, r2
 80188fa:	6878      	ldr	r0, [r7, #4]
 80188fc:	4611      	mov	r1, r2
 80188fe:	4798      	blx	r3
 8018900:	e00d      	b.n	801891e <_ZN13CT6963CDriver8SetPixelEhh+0x7e>
	else
		WriteCommand(T6963_BIT_SET | tmp);
 8018902:	687b      	ldr	r3, [r7, #4]
 8018904:	681b      	ldr	r3, [r3, #0]
 8018906:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801890a:	681b      	ldr	r3, [r3, #0]
 801890c:	7bfa      	ldrb	r2, [r7, #15]
 801890e:	f062 0207 	orn	r2, r2, #7
 8018912:	b2d2      	uxtb	r2, r2
 8018914:	6878      	ldr	r0, [r7, #4]
 8018916:	4611      	mov	r1, r2
 8018918:	4798      	blx	r3
 801891a:	e000      	b.n	801891e <_ZN13CT6963CDriver8SetPixelEhh+0x7e>
{
	unsigned char tmp;

	// do nothing for pixel out of range
	if(x > (GLCD_PIXELS_PER_LINE-1) || y > (GLCD_NUMBER_OF_LINES-1))
		return;
 801891c:	bf00      	nop

	if(Inverse())
		WriteCommand(T6963_BIT_RESET | tmp);
	else
		WriteCommand(T6963_BIT_SET | tmp);
}
 801891e:	f107 0710 	add.w	r7, r7, #16
 8018922:	46bd      	mov	sp, r7
 8018924:	bd80      	pop	{r7, pc}
 8018926:	bf00      	nop

08018928 <_ZN13CT6963CDriver4LineEjjjj>:
  * @retval None
  *
  * Copyright (c) Radoslaw Kwiecien, 2007r
  * http://en.radzio.dxp.pl/t6963/
  */
void CT6963CDriver::Line(unsigned int x1, unsigned int y1,unsigned int x2, unsigned int y2){
 8018928:	b580      	push	{r7, lr}
 801892a:	b08e      	sub	sp, #56	; 0x38
 801892c:	af00      	add	r7, sp, #0
 801892e:	60f8      	str	r0, [r7, #12]
 8018930:	60b9      	str	r1, [r7, #8]
 8018932:	607a      	str	r2, [r7, #4]
 8018934:	603b      	str	r3, [r7, #0]
	unsigned int CurrentX, CurrentY;
	int Xinc, Yinc,
	Dx, Dy, TwoDx, TwoDy,
	TwoDxAccumulatedError, TwoDyAccumulatedError;

	Dx = (x2-x1);
 8018936:	683a      	ldr	r2, [r7, #0]
 8018938:	68bb      	ldr	r3, [r7, #8]
 801893a:	1ad3      	subs	r3, r2, r3
 801893c:	627b      	str	r3, [r7, #36]	; 0x24
	Dy = (y2-y1);
 801893e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8018940:	687b      	ldr	r3, [r7, #4]
 8018942:	1ad3      	subs	r3, r2, r3
 8018944:	623b      	str	r3, [r7, #32]

	TwoDx = Dx + Dx;
 8018946:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018948:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801894a:	18d3      	adds	r3, r2, r3
 801894c:	61fb      	str	r3, [r7, #28]
	TwoDy = Dy + Dy;
 801894e:	6a3a      	ldr	r2, [r7, #32]
 8018950:	6a3b      	ldr	r3, [r7, #32]
 8018952:	18d3      	adds	r3, r2, r3
 8018954:	61bb      	str	r3, [r7, #24]

	CurrentX = x1;
 8018956:	68bb      	ldr	r3, [r7, #8]
 8018958:	637b      	str	r3, [r7, #52]	; 0x34
	CurrentY = y1;
 801895a:	687b      	ldr	r3, [r7, #4]
 801895c:	633b      	str	r3, [r7, #48]	; 0x30

	Xinc = 1;
 801895e:	f04f 0301 	mov.w	r3, #1
 8018962:	62fb      	str	r3, [r7, #44]	; 0x2c
	Yinc = 1;
 8018964:	f04f 0301 	mov.w	r3, #1
 8018968:	62bb      	str	r3, [r7, #40]	; 0x28

	if(Dx < 0)	// line from right to left
 801896a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801896c:	2b00      	cmp	r3, #0
 801896e:	da0a      	bge.n	8018986 <_ZN13CT6963CDriver4LineEjjjj+0x5e>
	{
		Xinc = -1;
 8018970:	f04f 33ff 	mov.w	r3, #4294967295
 8018974:	62fb      	str	r3, [r7, #44]	; 0x2c
		Dx = -Dx;
 8018976:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018978:	f1c3 0300 	rsb	r3, r3, #0
 801897c:	627b      	str	r3, [r7, #36]	; 0x24
		TwoDx = -TwoDx;
 801897e:	69fb      	ldr	r3, [r7, #28]
 8018980:	f1c3 0300 	rsb	r3, r3, #0
 8018984:	61fb      	str	r3, [r7, #28]
	}

	if (Dy < 0) // line from bottom to top
 8018986:	6a3b      	ldr	r3, [r7, #32]
 8018988:	2b00      	cmp	r3, #0
 801898a:	da0a      	bge.n	80189a2 <_ZN13CT6963CDriver4LineEjjjj+0x7a>
	{
		Yinc = -1;
 801898c:	f04f 33ff 	mov.w	r3, #4294967295
 8018990:	62bb      	str	r3, [r7, #40]	; 0x28
		Dy = -Dy;
 8018992:	6a3b      	ldr	r3, [r7, #32]
 8018994:	f1c3 0300 	rsb	r3, r3, #0
 8018998:	623b      	str	r3, [r7, #32]
		TwoDy = -TwoDy;
 801899a:	69bb      	ldr	r3, [r7, #24]
 801899c:	f1c3 0300 	rsb	r3, r3, #0
 80189a0:	61bb      	str	r3, [r7, #24]
	}

	SetPixel(x1,y1); // starting point
 80189a2:	68bb      	ldr	r3, [r7, #8]
 80189a4:	b2da      	uxtb	r2, r3
 80189a6:	687b      	ldr	r3, [r7, #4]
 80189a8:	b2db      	uxtb	r3, r3
 80189aa:	68f8      	ldr	r0, [r7, #12]
 80189ac:	4611      	mov	r1, r2
 80189ae:	461a      	mov	r2, r3
 80189b0:	f7ff ff76 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>

	if ((Dx != 0) || (Dy != 0)) // line is vertical or horizontal
 80189b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80189b6:	2b00      	cmp	r3, #0
 80189b8:	d102      	bne.n	80189c0 <_ZN13CT6963CDriver4LineEjjjj+0x98>
 80189ba:	6a3b      	ldr	r3, [r7, #32]
 80189bc:	2b00      	cmp	r3, #0
 80189be:	d056      	beq.n	8018a6e <_ZN13CT6963CDriver4LineEjjjj+0x146>
	{

		if (Dy <= Dx) // x is running var
 80189c0:	6a3a      	ldr	r2, [r7, #32]
 80189c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80189c4:	429a      	cmp	r2, r3
 80189c6:	dc29      	bgt.n	8018a1c <_ZN13CT6963CDriver4LineEjjjj+0xf4>
		{
			TwoDxAccumulatedError = 0;
 80189c8:	f04f 0300 	mov.w	r3, #0
 80189cc:	617b      	str	r3, [r7, #20]
			do
			{
				CurrentX += Xinc; // step X
 80189ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80189d0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80189d2:	18d3      	adds	r3, r2, r3
 80189d4:	637b      	str	r3, [r7, #52]	; 0x34
				TwoDxAccumulatedError += TwoDy;
 80189d6:	697a      	ldr	r2, [r7, #20]
 80189d8:	69bb      	ldr	r3, [r7, #24]
 80189da:	18d3      	adds	r3, r2, r3
 80189dc:	617b      	str	r3, [r7, #20]
				if(TwoDxAccumulatedError > Dx)  // Increase Y
 80189de:	697a      	ldr	r2, [r7, #20]
 80189e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80189e2:	429a      	cmp	r2, r3
 80189e4:	dd07      	ble.n	80189f6 <_ZN13CT6963CDriver4LineEjjjj+0xce>
				{
					CurrentY += Yinc;
 80189e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80189e8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80189ea:	18d3      	adds	r3, r2, r3
 80189ec:	633b      	str	r3, [r7, #48]	; 0x30
					TwoDxAccumulatedError -= TwoDx;
 80189ee:	697a      	ldr	r2, [r7, #20]
 80189f0:	69fb      	ldr	r3, [r7, #28]
 80189f2:	1ad3      	subs	r3, r2, r3
 80189f4:	617b      	str	r3, [r7, #20]
				}
				SetPixel(CurrentX,CurrentY);
 80189f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80189f8:	b2da      	uxtb	r2, r3
 80189fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80189fc:	b2db      	uxtb	r3, r3
 80189fe:	68f8      	ldr	r0, [r7, #12]
 8018a00:	4611      	mov	r1, r2
 8018a02:	461a      	mov	r2, r3
 8018a04:	f7ff ff4c 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
	{

		if (Dy <= Dx) // x is running var
		{
			TwoDxAccumulatedError = 0;
			do
 8018a08:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8018a0a:	683b      	ldr	r3, [r7, #0]
 8018a0c:	429a      	cmp	r2, r3
 8018a0e:	bf0c      	ite	eq
 8018a10:	2300      	moveq	r3, #0
 8018a12:	2301      	movne	r3, #1
 8018a14:	b2db      	uxtb	r3, r3
 8018a16:	2b00      	cmp	r3, #0
 8018a18:	d1d9      	bne.n	80189ce <_ZN13CT6963CDriver4LineEjjjj+0xa6>
 8018a1a:	e028      	b.n	8018a6e <_ZN13CT6963CDriver4LineEjjjj+0x146>
				SetPixel(CurrentX,CurrentY);
			}while (CurrentX != x2); // line finished
		}
		else // y is running var
		{
			TwoDyAccumulatedError = 0;
 8018a1c:	f04f 0300 	mov.w	r3, #0
 8018a20:	613b      	str	r3, [r7, #16]
			do
			{
				CurrentY += Yinc;
 8018a22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018a24:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8018a26:	18d3      	adds	r3, r2, r3
 8018a28:	633b      	str	r3, [r7, #48]	; 0x30
				TwoDyAccumulatedError += TwoDx;
 8018a2a:	693a      	ldr	r2, [r7, #16]
 8018a2c:	69fb      	ldr	r3, [r7, #28]
 8018a2e:	18d3      	adds	r3, r2, r3
 8018a30:	613b      	str	r3, [r7, #16]
				if(TwoDyAccumulatedError>Dy)
 8018a32:	693a      	ldr	r2, [r7, #16]
 8018a34:	6a3b      	ldr	r3, [r7, #32]
 8018a36:	429a      	cmp	r2, r3
 8018a38:	dd07      	ble.n	8018a4a <_ZN13CT6963CDriver4LineEjjjj+0x122>
				{
					CurrentX += Xinc;
 8018a3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018a3c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8018a3e:	18d3      	adds	r3, r2, r3
 8018a40:	637b      	str	r3, [r7, #52]	; 0x34
					TwoDyAccumulatedError -= TwoDy;
 8018a42:	693a      	ldr	r2, [r7, #16]
 8018a44:	69bb      	ldr	r3, [r7, #24]
 8018a46:	1ad3      	subs	r3, r2, r3
 8018a48:	613b      	str	r3, [r7, #16]
				}
				SetPixel(CurrentX,CurrentY);
 8018a4a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018a4c:	b2da      	uxtb	r2, r3
 8018a4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8018a50:	b2db      	uxtb	r3, r3
 8018a52:	68f8      	ldr	r0, [r7, #12]
 8018a54:	4611      	mov	r1, r2
 8018a56:	461a      	mov	r2, r3
 8018a58:	f7ff ff22 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
			}while (CurrentX != x2); // line finished
		}
		else // y is running var
		{
			TwoDyAccumulatedError = 0;
			do
 8018a5c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8018a5e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8018a60:	429a      	cmp	r2, r3
 8018a62:	bf0c      	ite	eq
 8018a64:	2300      	moveq	r3, #0
 8018a66:	2301      	movne	r3, #1
 8018a68:	b2db      	uxtb	r3, r3
 8018a6a:	2b00      	cmp	r3, #0
 8018a6c:	d1d9      	bne.n	8018a22 <_ZN13CT6963CDriver4LineEjjjj+0xfa>
				}
				SetPixel(CurrentX,CurrentY);
			}while (CurrentY != y2); // line finished
		}
	}
}
 8018a6e:	f107 0738 	add.w	r7, r7, #56	; 0x38
 8018a72:	46bd      	mov	sp, r7
 8018a74:	bd80      	pop	{r7, pc}
 8018a76:	bf00      	nop

08018a78 <_ZN13CT6963CDriver6WindowEjjjj>:
/**
  * @brief  draw a window with upper left corner at (x,y) and specified width and height, edges round or square
  * @param  x1,y1,width,heigth, edge type enum
  * @retval None
  */
void CT6963CDriver::Window(unsigned int x,unsigned int y,unsigned int width,unsigned int height){
 8018a78:	b5b0      	push	{r4, r5, r7, lr}
 8018a7a:	b088      	sub	sp, #32
 8018a7c:	af02      	add	r7, sp, #8
 8018a7e:	60f8      	str	r0, [r7, #12]
 8018a80:	60b9      	str	r1, [r7, #8]
 8018a82:	607a      	str	r2, [r7, #4]
 8018a84:	603b      	str	r3, [r7, #0]
	unsigned int i;

	Rectangle(x+3,y,width-4,4,true); // filled top bar
 8018a86:	68fb      	ldr	r3, [r7, #12]
 8018a88:	681b      	ldr	r3, [r3, #0]
 8018a8a:	f103 030c 	add.w	r3, r3, #12
 8018a8e:	681c      	ldr	r4, [r3, #0]
 8018a90:	68bb      	ldr	r3, [r7, #8]
 8018a92:	f103 0203 	add.w	r2, r3, #3
 8018a96:	683b      	ldr	r3, [r7, #0]
 8018a98:	f1a3 0304 	sub.w	r3, r3, #4
 8018a9c:	f04f 0104 	mov.w	r1, #4
 8018aa0:	9100      	str	r1, [sp, #0]
 8018aa2:	f04f 0101 	mov.w	r1, #1
 8018aa6:	9101      	str	r1, [sp, #4]
 8018aa8:	68f8      	ldr	r0, [r7, #12]
 8018aaa:	4611      	mov	r1, r2
 8018aac:	687a      	ldr	r2, [r7, #4]
 8018aae:	47a0      	blx	r4
	Line(x,y+4,x,y+height-4);			// left border
 8018ab0:	68fb      	ldr	r3, [r7, #12]
 8018ab2:	681b      	ldr	r3, [r3, #0]
 8018ab4:	f103 0304 	add.w	r3, r3, #4
 8018ab8:	681c      	ldr	r4, [r3, #0]
 8018aba:	687b      	ldr	r3, [r7, #4]
 8018abc:	f103 0304 	add.w	r3, r3, #4
 8018ac0:	6879      	ldr	r1, [r7, #4]
 8018ac2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8018ac4:	188a      	adds	r2, r1, r2
 8018ac6:	f1a2 0204 	sub.w	r2, r2, #4
 8018aca:	9200      	str	r2, [sp, #0]
 8018acc:	68f8      	ldr	r0, [r7, #12]
 8018ace:	68b9      	ldr	r1, [r7, #8]
 8018ad0:	461a      	mov	r2, r3
 8018ad2:	68bb      	ldr	r3, [r7, #8]
 8018ad4:	47a0      	blx	r4
	Line(x+width,y+4,x+width,y+height-4);// right border
 8018ad6:	68fb      	ldr	r3, [r7, #12]
 8018ad8:	681b      	ldr	r3, [r3, #0]
 8018ada:	f103 0304 	add.w	r3, r3, #4
 8018ade:	681c      	ldr	r4, [r3, #0]
 8018ae0:	68ba      	ldr	r2, [r7, #8]
 8018ae2:	683b      	ldr	r3, [r7, #0]
 8018ae4:	18d1      	adds	r1, r2, r3
 8018ae6:	687b      	ldr	r3, [r7, #4]
 8018ae8:	f103 0204 	add.w	r2, r3, #4
 8018aec:	68b8      	ldr	r0, [r7, #8]
 8018aee:	683b      	ldr	r3, [r7, #0]
 8018af0:	18c3      	adds	r3, r0, r3
 8018af2:	687d      	ldr	r5, [r7, #4]
 8018af4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8018af6:	1828      	adds	r0, r5, r0
 8018af8:	f1a0 0004 	sub.w	r0, r0, #4
 8018afc:	9000      	str	r0, [sp, #0]
 8018afe:	68f8      	ldr	r0, [r7, #12]
 8018b00:	47a0      	blx	r4
	Line(x+4,y+height,x+width-5,y+height);// bottom border
 8018b02:	68fb      	ldr	r3, [r7, #12]
 8018b04:	681b      	ldr	r3, [r3, #0]
 8018b06:	f103 0304 	add.w	r3, r3, #4
 8018b0a:	681c      	ldr	r4, [r3, #0]
 8018b0c:	68bb      	ldr	r3, [r7, #8]
 8018b0e:	f103 0104 	add.w	r1, r3, #4
 8018b12:	687a      	ldr	r2, [r7, #4]
 8018b14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018b16:	18d2      	adds	r2, r2, r3
 8018b18:	68b8      	ldr	r0, [r7, #8]
 8018b1a:	683b      	ldr	r3, [r7, #0]
 8018b1c:	18c3      	adds	r3, r0, r3
 8018b1e:	f1a3 0305 	sub.w	r3, r3, #5
 8018b22:	687d      	ldr	r5, [r7, #4]
 8018b24:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8018b26:	1828      	adds	r0, r5, r0
 8018b28:	9000      	str	r0, [sp, #0]
 8018b2a:	68f8      	ldr	r0, [r7, #12]
 8018b2c:	47a0      	blx	r4

	for(i=1;i<3;i++){
 8018b2e:	f04f 0301 	mov.w	r3, #1
 8018b32:	617b      	str	r3, [r7, #20]
 8018b34:	e04b      	b.n	8018bce <_ZN13CT6963CDriver6WindowEjjjj+0x156>
		// upper left
		SetPixel(x+i,y+3);
 8018b36:	68bb      	ldr	r3, [r7, #8]
 8018b38:	b2da      	uxtb	r2, r3
 8018b3a:	697b      	ldr	r3, [r7, #20]
 8018b3c:	b2db      	uxtb	r3, r3
 8018b3e:	18d3      	adds	r3, r2, r3
 8018b40:	b2da      	uxtb	r2, r3
 8018b42:	687b      	ldr	r3, [r7, #4]
 8018b44:	b2db      	uxtb	r3, r3
 8018b46:	f103 0303 	add.w	r3, r3, #3
 8018b4a:	b2db      	uxtb	r3, r3
 8018b4c:	68f8      	ldr	r0, [r7, #12]
 8018b4e:	4611      	mov	r1, r2
 8018b50:	461a      	mov	r2, r3
 8018b52:	f7ff fea5 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		SetPixel(x+i,y+2);
 8018b56:	68bb      	ldr	r3, [r7, #8]
 8018b58:	b2da      	uxtb	r2, r3
 8018b5a:	697b      	ldr	r3, [r7, #20]
 8018b5c:	b2db      	uxtb	r3, r3
 8018b5e:	18d3      	adds	r3, r2, r3
 8018b60:	b2da      	uxtb	r2, r3
 8018b62:	687b      	ldr	r3, [r7, #4]
 8018b64:	b2db      	uxtb	r3, r3
 8018b66:	f103 0302 	add.w	r3, r3, #2
 8018b6a:	b2db      	uxtb	r3, r3
 8018b6c:	68f8      	ldr	r0, [r7, #12]
 8018b6e:	4611      	mov	r1, r2
 8018b70:	461a      	mov	r2, r3
 8018b72:	f7ff fe95 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>

		// upper right
		SetPixel(x+width-i,y+3);
 8018b76:	68bb      	ldr	r3, [r7, #8]
 8018b78:	b2da      	uxtb	r2, r3
 8018b7a:	683b      	ldr	r3, [r7, #0]
 8018b7c:	b2db      	uxtb	r3, r3
 8018b7e:	18d3      	adds	r3, r2, r3
 8018b80:	b2da      	uxtb	r2, r3
 8018b82:	697b      	ldr	r3, [r7, #20]
 8018b84:	b2db      	uxtb	r3, r3
 8018b86:	1ad3      	subs	r3, r2, r3
 8018b88:	b2da      	uxtb	r2, r3
 8018b8a:	687b      	ldr	r3, [r7, #4]
 8018b8c:	b2db      	uxtb	r3, r3
 8018b8e:	f103 0303 	add.w	r3, r3, #3
 8018b92:	b2db      	uxtb	r3, r3
 8018b94:	68f8      	ldr	r0, [r7, #12]
 8018b96:	4611      	mov	r1, r2
 8018b98:	461a      	mov	r2, r3
 8018b9a:	f7ff fe81 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		SetPixel(x+width-i,y+2);
 8018b9e:	68bb      	ldr	r3, [r7, #8]
 8018ba0:	b2da      	uxtb	r2, r3
 8018ba2:	683b      	ldr	r3, [r7, #0]
 8018ba4:	b2db      	uxtb	r3, r3
 8018ba6:	18d3      	adds	r3, r2, r3
 8018ba8:	b2da      	uxtb	r2, r3
 8018baa:	697b      	ldr	r3, [r7, #20]
 8018bac:	b2db      	uxtb	r3, r3
 8018bae:	1ad3      	subs	r3, r2, r3
 8018bb0:	b2da      	uxtb	r2, r3
 8018bb2:	687b      	ldr	r3, [r7, #4]
 8018bb4:	b2db      	uxtb	r3, r3
 8018bb6:	f103 0302 	add.w	r3, r3, #2
 8018bba:	b2db      	uxtb	r3, r3
 8018bbc:	68f8      	ldr	r0, [r7, #12]
 8018bbe:	4611      	mov	r1, r2
 8018bc0:	461a      	mov	r2, r3
 8018bc2:	f7ff fe6d 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
	Rectangle(x+3,y,width-4,4,true); // filled top bar
	Line(x,y+4,x,y+height-4);			// left border
	Line(x+width,y+4,x+width,y+height-4);// right border
	Line(x+4,y+height,x+width-5,y+height);// bottom border

	for(i=1;i<3;i++){
 8018bc6:	697b      	ldr	r3, [r7, #20]
 8018bc8:	f103 0301 	add.w	r3, r3, #1
 8018bcc:	617b      	str	r3, [r7, #20]
 8018bce:	697b      	ldr	r3, [r7, #20]
 8018bd0:	2b02      	cmp	r3, #2
 8018bd2:	bf8c      	ite	hi
 8018bd4:	2300      	movhi	r3, #0
 8018bd6:	2301      	movls	r3, #1
 8018bd8:	b2db      	uxtb	r3, r3
 8018bda:	2b00      	cmp	r3, #0
 8018bdc:	d1ab      	bne.n	8018b36 <_ZN13CT6963CDriver6WindowEjjjj+0xbe>
		SetPixel(x+width-i,y+3);
		SetPixel(x+width-i,y+2);
	}

	// upper left
	SetPixel(x+3,y+1);
 8018bde:	68bb      	ldr	r3, [r7, #8]
 8018be0:	b2db      	uxtb	r3, r3
 8018be2:	f103 0303 	add.w	r3, r3, #3
 8018be6:	b2da      	uxtb	r2, r3
 8018be8:	687b      	ldr	r3, [r7, #4]
 8018bea:	b2db      	uxtb	r3, r3
 8018bec:	f103 0301 	add.w	r3, r3, #1
 8018bf0:	b2db      	uxtb	r3, r3
 8018bf2:	68f8      	ldr	r0, [r7, #12]
 8018bf4:	4611      	mov	r1, r2
 8018bf6:	461a      	mov	r2, r3
 8018bf8:	f7ff fe52 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
	SetPixel(x+2,y+1);
 8018bfc:	68bb      	ldr	r3, [r7, #8]
 8018bfe:	b2db      	uxtb	r3, r3
 8018c00:	f103 0302 	add.w	r3, r3, #2
 8018c04:	b2da      	uxtb	r2, r3
 8018c06:	687b      	ldr	r3, [r7, #4]
 8018c08:	b2db      	uxtb	r3, r3
 8018c0a:	f103 0301 	add.w	r3, r3, #1
 8018c0e:	b2db      	uxtb	r3, r3
 8018c10:	68f8      	ldr	r0, [r7, #12]
 8018c12:	4611      	mov	r1, r2
 8018c14:	461a      	mov	r2, r3
 8018c16:	f7ff fe43 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>

	// upper right
	SetPixel(x+width-3,y+1);
 8018c1a:	68bb      	ldr	r3, [r7, #8]
 8018c1c:	b2da      	uxtb	r2, r3
 8018c1e:	683b      	ldr	r3, [r7, #0]
 8018c20:	b2db      	uxtb	r3, r3
 8018c22:	18d3      	adds	r3, r2, r3
 8018c24:	b2db      	uxtb	r3, r3
 8018c26:	f1a3 0303 	sub.w	r3, r3, #3
 8018c2a:	b2da      	uxtb	r2, r3
 8018c2c:	687b      	ldr	r3, [r7, #4]
 8018c2e:	b2db      	uxtb	r3, r3
 8018c30:	f103 0301 	add.w	r3, r3, #1
 8018c34:	b2db      	uxtb	r3, r3
 8018c36:	68f8      	ldr	r0, [r7, #12]
 8018c38:	4611      	mov	r1, r2
 8018c3a:	461a      	mov	r2, r3
 8018c3c:	f7ff fe30 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
	SetPixel(x+width-2,y+1);
 8018c40:	68bb      	ldr	r3, [r7, #8]
 8018c42:	b2da      	uxtb	r2, r3
 8018c44:	683b      	ldr	r3, [r7, #0]
 8018c46:	b2db      	uxtb	r3, r3
 8018c48:	18d3      	adds	r3, r2, r3
 8018c4a:	b2db      	uxtb	r3, r3
 8018c4c:	f1a3 0302 	sub.w	r3, r3, #2
 8018c50:	b2da      	uxtb	r2, r3
 8018c52:	687b      	ldr	r3, [r7, #4]
 8018c54:	b2db      	uxtb	r3, r3
 8018c56:	f103 0301 	add.w	r3, r3, #1
 8018c5a:	b2db      	uxtb	r3, r3
 8018c5c:	68f8      	ldr	r0, [r7, #12]
 8018c5e:	4611      	mov	r1, r2
 8018c60:	461a      	mov	r2, r3
 8018c62:	f7ff fe1d 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>


	// bottom left
	SetPixel(x+1,y+height-2);
 8018c66:	68bb      	ldr	r3, [r7, #8]
 8018c68:	b2db      	uxtb	r3, r3
 8018c6a:	f103 0301 	add.w	r3, r3, #1
 8018c6e:	b2da      	uxtb	r2, r3
 8018c70:	687b      	ldr	r3, [r7, #4]
 8018c72:	b2d9      	uxtb	r1, r3
 8018c74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018c76:	b2db      	uxtb	r3, r3
 8018c78:	18cb      	adds	r3, r1, r3
 8018c7a:	b2db      	uxtb	r3, r3
 8018c7c:	f1a3 0302 	sub.w	r3, r3, #2
 8018c80:	b2db      	uxtb	r3, r3
 8018c82:	68f8      	ldr	r0, [r7, #12]
 8018c84:	4611      	mov	r1, r2
 8018c86:	461a      	mov	r2, r3
 8018c88:	f7ff fe0a 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
	SetPixel(x+1,y+height-3);
 8018c8c:	68bb      	ldr	r3, [r7, #8]
 8018c8e:	b2db      	uxtb	r3, r3
 8018c90:	f103 0301 	add.w	r3, r3, #1
 8018c94:	b2da      	uxtb	r2, r3
 8018c96:	687b      	ldr	r3, [r7, #4]
 8018c98:	b2d9      	uxtb	r1, r3
 8018c9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018c9c:	b2db      	uxtb	r3, r3
 8018c9e:	18cb      	adds	r3, r1, r3
 8018ca0:	b2db      	uxtb	r3, r3
 8018ca2:	f1a3 0303 	sub.w	r3, r3, #3
 8018ca6:	b2db      	uxtb	r3, r3
 8018ca8:	68f8      	ldr	r0, [r7, #12]
 8018caa:	4611      	mov	r1, r2
 8018cac:	461a      	mov	r2, r3
 8018cae:	f7ff fdf7 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>

	// bottom left
	SetPixel(x+3,y+height-1);
 8018cb2:	68bb      	ldr	r3, [r7, #8]
 8018cb4:	b2db      	uxtb	r3, r3
 8018cb6:	f103 0303 	add.w	r3, r3, #3
 8018cba:	b2da      	uxtb	r2, r3
 8018cbc:	687b      	ldr	r3, [r7, #4]
 8018cbe:	b2d9      	uxtb	r1, r3
 8018cc0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018cc2:	b2db      	uxtb	r3, r3
 8018cc4:	18cb      	adds	r3, r1, r3
 8018cc6:	b2db      	uxtb	r3, r3
 8018cc8:	f103 33ff 	add.w	r3, r3, #4294967295
 8018ccc:	b2db      	uxtb	r3, r3
 8018cce:	68f8      	ldr	r0, [r7, #12]
 8018cd0:	4611      	mov	r1, r2
 8018cd2:	461a      	mov	r2, r3
 8018cd4:	f7ff fde4 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
	SetPixel(x+2,y+height-1);
 8018cd8:	68bb      	ldr	r3, [r7, #8]
 8018cda:	b2db      	uxtb	r3, r3
 8018cdc:	f103 0302 	add.w	r3, r3, #2
 8018ce0:	b2da      	uxtb	r2, r3
 8018ce2:	687b      	ldr	r3, [r7, #4]
 8018ce4:	b2d9      	uxtb	r1, r3
 8018ce6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018ce8:	b2db      	uxtb	r3, r3
 8018cea:	18cb      	adds	r3, r1, r3
 8018cec:	b2db      	uxtb	r3, r3
 8018cee:	f103 33ff 	add.w	r3, r3, #4294967295
 8018cf2:	b2db      	uxtb	r3, r3
 8018cf4:	68f8      	ldr	r0, [r7, #12]
 8018cf6:	4611      	mov	r1, r2
 8018cf8:	461a      	mov	r2, r3
 8018cfa:	f7ff fdd1 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>


	// bottom right
	SetPixel(x+width-1,y+height-2);
 8018cfe:	68bb      	ldr	r3, [r7, #8]
 8018d00:	b2da      	uxtb	r2, r3
 8018d02:	683b      	ldr	r3, [r7, #0]
 8018d04:	b2db      	uxtb	r3, r3
 8018d06:	18d3      	adds	r3, r2, r3
 8018d08:	b2db      	uxtb	r3, r3
 8018d0a:	f103 33ff 	add.w	r3, r3, #4294967295
 8018d0e:	b2da      	uxtb	r2, r3
 8018d10:	687b      	ldr	r3, [r7, #4]
 8018d12:	b2d9      	uxtb	r1, r3
 8018d14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018d16:	b2db      	uxtb	r3, r3
 8018d18:	18cb      	adds	r3, r1, r3
 8018d1a:	b2db      	uxtb	r3, r3
 8018d1c:	f1a3 0302 	sub.w	r3, r3, #2
 8018d20:	b2db      	uxtb	r3, r3
 8018d22:	68f8      	ldr	r0, [r7, #12]
 8018d24:	4611      	mov	r1, r2
 8018d26:	461a      	mov	r2, r3
 8018d28:	f7ff fdba 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
	SetPixel(x+width-1,y+height-3);
 8018d2c:	68bb      	ldr	r3, [r7, #8]
 8018d2e:	b2da      	uxtb	r2, r3
 8018d30:	683b      	ldr	r3, [r7, #0]
 8018d32:	b2db      	uxtb	r3, r3
 8018d34:	18d3      	adds	r3, r2, r3
 8018d36:	b2db      	uxtb	r3, r3
 8018d38:	f103 33ff 	add.w	r3, r3, #4294967295
 8018d3c:	b2da      	uxtb	r2, r3
 8018d3e:	687b      	ldr	r3, [r7, #4]
 8018d40:	b2d9      	uxtb	r1, r3
 8018d42:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018d44:	b2db      	uxtb	r3, r3
 8018d46:	18cb      	adds	r3, r1, r3
 8018d48:	b2db      	uxtb	r3, r3
 8018d4a:	f1a3 0303 	sub.w	r3, r3, #3
 8018d4e:	b2db      	uxtb	r3, r3
 8018d50:	68f8      	ldr	r0, [r7, #12]
 8018d52:	4611      	mov	r1, r2
 8018d54:	461a      	mov	r2, r3
 8018d56:	f7ff fda3 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>

	// bottom right
	SetPixel(x+width-2,y+height-1);
 8018d5a:	68bb      	ldr	r3, [r7, #8]
 8018d5c:	b2da      	uxtb	r2, r3
 8018d5e:	683b      	ldr	r3, [r7, #0]
 8018d60:	b2db      	uxtb	r3, r3
 8018d62:	18d3      	adds	r3, r2, r3
 8018d64:	b2db      	uxtb	r3, r3
 8018d66:	f1a3 0302 	sub.w	r3, r3, #2
 8018d6a:	b2da      	uxtb	r2, r3
 8018d6c:	687b      	ldr	r3, [r7, #4]
 8018d6e:	b2d9      	uxtb	r1, r3
 8018d70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018d72:	b2db      	uxtb	r3, r3
 8018d74:	18cb      	adds	r3, r1, r3
 8018d76:	b2db      	uxtb	r3, r3
 8018d78:	f103 33ff 	add.w	r3, r3, #4294967295
 8018d7c:	b2db      	uxtb	r3, r3
 8018d7e:	68f8      	ldr	r0, [r7, #12]
 8018d80:	4611      	mov	r1, r2
 8018d82:	461a      	mov	r2, r3
 8018d84:	f7ff fd8c 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
	SetPixel(x+width-3,y+height-1);
 8018d88:	68bb      	ldr	r3, [r7, #8]
 8018d8a:	b2da      	uxtb	r2, r3
 8018d8c:	683b      	ldr	r3, [r7, #0]
 8018d8e:	b2db      	uxtb	r3, r3
 8018d90:	18d3      	adds	r3, r2, r3
 8018d92:	b2db      	uxtb	r3, r3
 8018d94:	f1a3 0303 	sub.w	r3, r3, #3
 8018d98:	b2da      	uxtb	r2, r3
 8018d9a:	687b      	ldr	r3, [r7, #4]
 8018d9c:	b2d9      	uxtb	r1, r3
 8018d9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018da0:	b2db      	uxtb	r3, r3
 8018da2:	18cb      	adds	r3, r1, r3
 8018da4:	b2db      	uxtb	r3, r3
 8018da6:	f103 33ff 	add.w	r3, r3, #4294967295
 8018daa:	b2db      	uxtb	r3, r3
 8018dac:	68f8      	ldr	r0, [r7, #12]
 8018dae:	4611      	mov	r1, r2
 8018db0:	461a      	mov	r2, r3
 8018db2:	f7ff fd75 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>



}
 8018db6:	f107 0718 	add.w	r7, r7, #24
 8018dba:	46bd      	mov	sp, r7
 8018dbc:	bdb0      	pop	{r4, r5, r7, pc}
 8018dbe:	bf00      	nop

08018dc0 <_ZN13CT6963CDriver9RectangleEjjjjb>:
/**
  * @brief  draw an rectangle with upper left corner at (x,y) and specified width and height
  * @param  x1,y1,width,heigth,  true for filled
  * @retval None
  */
void CT6963CDriver::Rectangle(unsigned int x,unsigned int y,unsigned int width,unsigned int height,  bool fill){
 8018dc0:	b580      	push	{r7, lr}
 8018dc2:	b086      	sub	sp, #24
 8018dc4:	af00      	add	r7, sp, #0
 8018dc6:	60f8      	str	r0, [r7, #12]
 8018dc8:	60b9      	str	r1, [r7, #8]
 8018dca:	607a      	str	r2, [r7, #4]
 8018dcc:	603b      	str	r3, [r7, #0]
	unsigned char i;
	unsigned char k;

	if(fill){	// fill rect
 8018dce:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8018dd2:	2b00      	cmp	r3, #0
 8018dd4:	d031      	beq.n	8018e3a <_ZN13CT6963CDriver9RectangleEjjjjb+0x7a>
		//lines
		for (i=0;i<height;i++){
 8018dd6:	f04f 0300 	mov.w	r3, #0
 8018dda:	75fb      	strb	r3, [r7, #23]
 8018ddc:	e023      	b.n	8018e26 <_ZN13CT6963CDriver9RectangleEjjjjb+0x66>
			// columns
			for (k=0;k<width;k++) {
 8018dde:	f04f 0300 	mov.w	r3, #0
 8018de2:	75bb      	strb	r3, [r7, #22]
 8018de4:	e012      	b.n	8018e0c <_ZN13CT6963CDriver9RectangleEjjjjb+0x4c>
				SetPixel(x+k,y+i);
 8018de6:	68bb      	ldr	r3, [r7, #8]
 8018de8:	b2da      	uxtb	r2, r3
 8018dea:	7dbb      	ldrb	r3, [r7, #22]
 8018dec:	18d3      	adds	r3, r2, r3
 8018dee:	b2da      	uxtb	r2, r3
 8018df0:	687b      	ldr	r3, [r7, #4]
 8018df2:	b2d9      	uxtb	r1, r3
 8018df4:	7dfb      	ldrb	r3, [r7, #23]
 8018df6:	18cb      	adds	r3, r1, r3
 8018df8:	b2db      	uxtb	r3, r3
 8018dfa:	68f8      	ldr	r0, [r7, #12]
 8018dfc:	4611      	mov	r1, r2
 8018dfe:	461a      	mov	r2, r3
 8018e00:	f7ff fd4e 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>

	if(fill){	// fill rect
		//lines
		for (i=0;i<height;i++){
			// columns
			for (k=0;k<width;k++) {
 8018e04:	7dbb      	ldrb	r3, [r7, #22]
 8018e06:	f103 0301 	add.w	r3, r3, #1
 8018e0a:	75bb      	strb	r3, [r7, #22]
 8018e0c:	7dba      	ldrb	r2, [r7, #22]
 8018e0e:	683b      	ldr	r3, [r7, #0]
 8018e10:	429a      	cmp	r2, r3
 8018e12:	bf2c      	ite	cs
 8018e14:	2300      	movcs	r3, #0
 8018e16:	2301      	movcc	r3, #1
 8018e18:	b2db      	uxtb	r3, r3
 8018e1a:	2b00      	cmp	r3, #0
 8018e1c:	d1e3      	bne.n	8018de6 <_ZN13CT6963CDriver9RectangleEjjjjb+0x26>
	unsigned char i;
	unsigned char k;

	if(fill){	// fill rect
		//lines
		for (i=0;i<height;i++){
 8018e1e:	7dfb      	ldrb	r3, [r7, #23]
 8018e20:	f103 0301 	add.w	r3, r3, #1
 8018e24:	75fb      	strb	r3, [r7, #23]
 8018e26:	7dfa      	ldrb	r2, [r7, #23]
 8018e28:	6a3b      	ldr	r3, [r7, #32]
 8018e2a:	429a      	cmp	r2, r3
 8018e2c:	bf2c      	ite	cs
 8018e2e:	2300      	movcs	r3, #0
 8018e30:	2301      	movcc	r3, #1
 8018e32:	b2db      	uxtb	r3, r3
 8018e34:	2b00      	cmp	r3, #0
 8018e36:	d1d2      	bne.n	8018dde <_ZN13CT6963CDriver9RectangleEjjjjb+0x1e>
 8018e38:	e05f      	b.n	8018efa <_ZN13CT6963CDriver9RectangleEjjjjb+0x13a>
				SetPixel(x+k,y+i);
			}
		}
	} else {
		//lines vertical
		for (i = 0; i < height; i++) {
 8018e3a:	f04f 0300 	mov.w	r3, #0
 8018e3e:	75fb      	strb	r3, [r7, #23]
 8018e40:	e022      	b.n	8018e88 <_ZN13CT6963CDriver9RectangleEjjjjb+0xc8>
			SetPixel(x, y + i);
 8018e42:	68bb      	ldr	r3, [r7, #8]
 8018e44:	b2da      	uxtb	r2, r3
 8018e46:	687b      	ldr	r3, [r7, #4]
 8018e48:	b2d9      	uxtb	r1, r3
 8018e4a:	7dfb      	ldrb	r3, [r7, #23]
 8018e4c:	18cb      	adds	r3, r1, r3
 8018e4e:	b2db      	uxtb	r3, r3
 8018e50:	68f8      	ldr	r0, [r7, #12]
 8018e52:	4611      	mov	r1, r2
 8018e54:	461a      	mov	r2, r3
 8018e56:	f7ff fd23 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
			SetPixel(x + width - 1, y + i);
 8018e5a:	68bb      	ldr	r3, [r7, #8]
 8018e5c:	b2da      	uxtb	r2, r3
 8018e5e:	683b      	ldr	r3, [r7, #0]
 8018e60:	b2db      	uxtb	r3, r3
 8018e62:	18d3      	adds	r3, r2, r3
 8018e64:	b2db      	uxtb	r3, r3
 8018e66:	f103 33ff 	add.w	r3, r3, #4294967295
 8018e6a:	b2da      	uxtb	r2, r3
 8018e6c:	687b      	ldr	r3, [r7, #4]
 8018e6e:	b2d9      	uxtb	r1, r3
 8018e70:	7dfb      	ldrb	r3, [r7, #23]
 8018e72:	18cb      	adds	r3, r1, r3
 8018e74:	b2db      	uxtb	r3, r3
 8018e76:	68f8      	ldr	r0, [r7, #12]
 8018e78:	4611      	mov	r1, r2
 8018e7a:	461a      	mov	r2, r3
 8018e7c:	f7ff fd10 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
				SetPixel(x+k,y+i);
			}
		}
	} else {
		//lines vertical
		for (i = 0; i < height; i++) {
 8018e80:	7dfb      	ldrb	r3, [r7, #23]
 8018e82:	f103 0301 	add.w	r3, r3, #1
 8018e86:	75fb      	strb	r3, [r7, #23]
 8018e88:	7dfa      	ldrb	r2, [r7, #23]
 8018e8a:	6a3b      	ldr	r3, [r7, #32]
 8018e8c:	429a      	cmp	r2, r3
 8018e8e:	bf2c      	ite	cs
 8018e90:	2300      	movcs	r3, #0
 8018e92:	2301      	movcc	r3, #1
 8018e94:	b2db      	uxtb	r3, r3
 8018e96:	2b00      	cmp	r3, #0
 8018e98:	d1d3      	bne.n	8018e42 <_ZN13CT6963CDriver9RectangleEjjjjb+0x82>
			SetPixel(x, y + i);
			SetPixel(x + width - 1, y + i);
		}
		//lines horizontal
		for (i = 0; i < width; i++)	{
 8018e9a:	f04f 0300 	mov.w	r3, #0
 8018e9e:	75fb      	strb	r3, [r7, #23]
 8018ea0:	e022      	b.n	8018ee8 <_ZN13CT6963CDriver9RectangleEjjjjb+0x128>
			SetPixel(x + i, y);
 8018ea2:	68bb      	ldr	r3, [r7, #8]
 8018ea4:	b2da      	uxtb	r2, r3
 8018ea6:	7dfb      	ldrb	r3, [r7, #23]
 8018ea8:	18d3      	adds	r3, r2, r3
 8018eaa:	b2da      	uxtb	r2, r3
 8018eac:	687b      	ldr	r3, [r7, #4]
 8018eae:	b2db      	uxtb	r3, r3
 8018eb0:	68f8      	ldr	r0, [r7, #12]
 8018eb2:	4611      	mov	r1, r2
 8018eb4:	461a      	mov	r2, r3
 8018eb6:	f7ff fcf3 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
			SetPixel(x + i, y + height - 1);
 8018eba:	68bb      	ldr	r3, [r7, #8]
 8018ebc:	b2da      	uxtb	r2, r3
 8018ebe:	7dfb      	ldrb	r3, [r7, #23]
 8018ec0:	18d3      	adds	r3, r2, r3
 8018ec2:	b2da      	uxtb	r2, r3
 8018ec4:	687b      	ldr	r3, [r7, #4]
 8018ec6:	b2d9      	uxtb	r1, r3
 8018ec8:	6a3b      	ldr	r3, [r7, #32]
 8018eca:	b2db      	uxtb	r3, r3
 8018ecc:	18cb      	adds	r3, r1, r3
 8018ece:	b2db      	uxtb	r3, r3
 8018ed0:	f103 33ff 	add.w	r3, r3, #4294967295
 8018ed4:	b2db      	uxtb	r3, r3
 8018ed6:	68f8      	ldr	r0, [r7, #12]
 8018ed8:	4611      	mov	r1, r2
 8018eda:	461a      	mov	r2, r3
 8018edc:	f7ff fce0 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		for (i = 0; i < height; i++) {
			SetPixel(x, y + i);
			SetPixel(x + width - 1, y + i);
		}
		//lines horizontal
		for (i = 0; i < width; i++)	{
 8018ee0:	7dfb      	ldrb	r3, [r7, #23]
 8018ee2:	f103 0301 	add.w	r3, r3, #1
 8018ee6:	75fb      	strb	r3, [r7, #23]
 8018ee8:	7dfa      	ldrb	r2, [r7, #23]
 8018eea:	683b      	ldr	r3, [r7, #0]
 8018eec:	429a      	cmp	r2, r3
 8018eee:	bf2c      	ite	cs
 8018ef0:	2300      	movcs	r3, #0
 8018ef2:	2301      	movcc	r3, #1
 8018ef4:	b2db      	uxtb	r3, r3
 8018ef6:	2b00      	cmp	r3, #0
 8018ef8:	d1d3      	bne.n	8018ea2 <_ZN13CT6963CDriver9RectangleEjjjjb+0xe2>
			SetPixel(x + i, y);
			SetPixel(x + i, y + height - 1);
		}
	}
}
 8018efa:	f107 0718 	add.w	r7, r7, #24
 8018efe:	46bd      	mov	sp, r7
 8018f00:	bd80      	pop	{r7, pc}
 8018f02:	bf00      	nop

08018f04 <_ZN13CT6963CDriver11SectorClearEjjjj>:
/**
  * @brief  clear sector from upper left (x,y) with specified width and height
  * @param  x1,y1,width, height
  * @retval None
  */
void CT6963CDriver::SectorClear(unsigned int x,unsigned int y,unsigned int width,unsigned int height){
 8018f04:	b590      	push	{r4, r7, lr}
 8018f06:	b089      	sub	sp, #36	; 0x24
 8018f08:	af02      	add	r7, sp, #8
 8018f0a:	60f8      	str	r0, [r7, #12]
 8018f0c:	60b9      	str	r1, [r7, #8]
 8018f0e:	607a      	str	r2, [r7, #4]
 8018f10:	603b      	str	r3, [r7, #0]
	bool oldInverse;

	oldInverse = Inverse();
 8018f12:	68fb      	ldr	r3, [r7, #12]
 8018f14:	4618      	mov	r0, r3
 8018f16:	f7ff fa09 	bl	801832c <_ZN11CGraphicLCD7InverseEv>
 8018f1a:	4603      	mov	r3, r0
 8018f1c:	75fb      	strb	r3, [r7, #23]
	Inverse(!oldInverse);
 8018f1e:	68fa      	ldr	r2, [r7, #12]
 8018f20:	7dfb      	ldrb	r3, [r7, #23]
 8018f22:	f083 0301 	eor.w	r3, r3, #1
 8018f26:	b2db      	uxtb	r3, r3
 8018f28:	4610      	mov	r0, r2
 8018f2a:	4619      	mov	r1, r3
 8018f2c:	f7ff fa0a 	bl	8018344 <_ZN11CGraphicLCD7InverseEb>

	Rectangle(x,y,width,height,true);
 8018f30:	68fb      	ldr	r3, [r7, #12]
 8018f32:	681b      	ldr	r3, [r3, #0]
 8018f34:	f103 030c 	add.w	r3, r3, #12
 8018f38:	681c      	ldr	r4, [r3, #0]
 8018f3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018f3c:	9300      	str	r3, [sp, #0]
 8018f3e:	f04f 0301 	mov.w	r3, #1
 8018f42:	9301      	str	r3, [sp, #4]
 8018f44:	68f8      	ldr	r0, [r7, #12]
 8018f46:	68b9      	ldr	r1, [r7, #8]
 8018f48:	687a      	ldr	r2, [r7, #4]
 8018f4a:	683b      	ldr	r3, [r7, #0]
 8018f4c:	47a0      	blx	r4

	Inverse(oldInverse);
 8018f4e:	68fa      	ldr	r2, [r7, #12]
 8018f50:	7dfb      	ldrb	r3, [r7, #23]
 8018f52:	4610      	mov	r0, r2
 8018f54:	4619      	mov	r1, r3
 8018f56:	f7ff f9f5 	bl	8018344 <_ZN11CGraphicLCD7InverseEb>
}
 8018f5a:	f107 071c 	add.w	r7, r7, #28
 8018f5e:	46bd      	mov	sp, r7
 8018f60:	bd90      	pop	{r4, r7, pc}
 8018f62:	bf00      	nop

08018f64 <_ZN13CT6963CDriver6CircleEhhh>:
  * @brief  draw a circle with center at (cx,cy) and specified radius
  * @param  x1,y1,width,
  * @retval None
  */
void CT6963CDriver::Circle(unsigned char cx, unsigned char cy ,unsigned char radius)
{
 8018f64:	b580      	push	{r7, lr}
 8018f66:	b088      	sub	sp, #32
 8018f68:	af00      	add	r7, sp, #0
 8018f6a:	6078      	str	r0, [r7, #4]
 8018f6c:	70f9      	strb	r1, [r7, #3]
 8018f6e:	70ba      	strb	r2, [r7, #2]
 8018f70:	707b      	strb	r3, [r7, #1]
	int x, y, xchange, ychange, radiusError;
	x = radius;
 8018f72:	787b      	ldrb	r3, [r7, #1]
 8018f74:	61fb      	str	r3, [r7, #28]
	y = 0;
 8018f76:	f04f 0300 	mov.w	r3, #0
 8018f7a:	61bb      	str	r3, [r7, #24]
	xchange = 1 - 2 * radius;
 8018f7c:	787a      	ldrb	r2, [r7, #1]
 8018f7e:	4613      	mov	r3, r2
 8018f80:	ea4f 73c3 	mov.w	r3, r3, lsl #31
 8018f84:	1a9b      	subs	r3, r3, r2
 8018f86:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8018f8a:	f103 0301 	add.w	r3, r3, #1
 8018f8e:	617b      	str	r3, [r7, #20]
	ychange = 1;
 8018f90:	f04f 0301 	mov.w	r3, #1
 8018f94:	613b      	str	r3, [r7, #16]
	radiusError = 0;
 8018f96:	f04f 0300 	mov.w	r3, #0
 8018f9a:	60fb      	str	r3, [r7, #12]
	while(x >= y)
 8018f9c:	e096      	b.n	80190cc <_ZN13CT6963CDriver6CircleEhhh+0x168>
	{
		SetPixel(cx+x, cy+y);
 8018f9e:	69fb      	ldr	r3, [r7, #28]
 8018fa0:	b2da      	uxtb	r2, r3
 8018fa2:	78fb      	ldrb	r3, [r7, #3]
 8018fa4:	18d3      	adds	r3, r2, r3
 8018fa6:	b2da      	uxtb	r2, r3
 8018fa8:	69bb      	ldr	r3, [r7, #24]
 8018faa:	b2d9      	uxtb	r1, r3
 8018fac:	78bb      	ldrb	r3, [r7, #2]
 8018fae:	18cb      	adds	r3, r1, r3
 8018fb0:	b2db      	uxtb	r3, r3
 8018fb2:	6878      	ldr	r0, [r7, #4]
 8018fb4:	4611      	mov	r1, r2
 8018fb6:	461a      	mov	r2, r3
 8018fb8:	f7ff fc72 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		SetPixel(cx-x, cy+y );
 8018fbc:	69fb      	ldr	r3, [r7, #28]
 8018fbe:	b2db      	uxtb	r3, r3
 8018fc0:	78fa      	ldrb	r2, [r7, #3]
 8018fc2:	1ad3      	subs	r3, r2, r3
 8018fc4:	b2da      	uxtb	r2, r3
 8018fc6:	69bb      	ldr	r3, [r7, #24]
 8018fc8:	b2d9      	uxtb	r1, r3
 8018fca:	78bb      	ldrb	r3, [r7, #2]
 8018fcc:	18cb      	adds	r3, r1, r3
 8018fce:	b2db      	uxtb	r3, r3
 8018fd0:	6878      	ldr	r0, [r7, #4]
 8018fd2:	4611      	mov	r1, r2
 8018fd4:	461a      	mov	r2, r3
 8018fd6:	f7ff fc63 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		SetPixel(cx-x, cy-y );
 8018fda:	69fb      	ldr	r3, [r7, #28]
 8018fdc:	b2db      	uxtb	r3, r3
 8018fde:	78fa      	ldrb	r2, [r7, #3]
 8018fe0:	1ad3      	subs	r3, r2, r3
 8018fe2:	b2da      	uxtb	r2, r3
 8018fe4:	69bb      	ldr	r3, [r7, #24]
 8018fe6:	b2db      	uxtb	r3, r3
 8018fe8:	78b9      	ldrb	r1, [r7, #2]
 8018fea:	1acb      	subs	r3, r1, r3
 8018fec:	b2db      	uxtb	r3, r3
 8018fee:	6878      	ldr	r0, [r7, #4]
 8018ff0:	4611      	mov	r1, r2
 8018ff2:	461a      	mov	r2, r3
 8018ff4:	f7ff fc54 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		SetPixel(cx+x, cy-y );
 8018ff8:	69fb      	ldr	r3, [r7, #28]
 8018ffa:	b2da      	uxtb	r2, r3
 8018ffc:	78fb      	ldrb	r3, [r7, #3]
 8018ffe:	18d3      	adds	r3, r2, r3
 8019000:	b2da      	uxtb	r2, r3
 8019002:	69bb      	ldr	r3, [r7, #24]
 8019004:	b2db      	uxtb	r3, r3
 8019006:	78b9      	ldrb	r1, [r7, #2]
 8019008:	1acb      	subs	r3, r1, r3
 801900a:	b2db      	uxtb	r3, r3
 801900c:	6878      	ldr	r0, [r7, #4]
 801900e:	4611      	mov	r1, r2
 8019010:	461a      	mov	r2, r3
 8019012:	f7ff fc45 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		SetPixel(cx+y, cy+x );
 8019016:	69bb      	ldr	r3, [r7, #24]
 8019018:	b2da      	uxtb	r2, r3
 801901a:	78fb      	ldrb	r3, [r7, #3]
 801901c:	18d3      	adds	r3, r2, r3
 801901e:	b2da      	uxtb	r2, r3
 8019020:	69fb      	ldr	r3, [r7, #28]
 8019022:	b2d9      	uxtb	r1, r3
 8019024:	78bb      	ldrb	r3, [r7, #2]
 8019026:	18cb      	adds	r3, r1, r3
 8019028:	b2db      	uxtb	r3, r3
 801902a:	6878      	ldr	r0, [r7, #4]
 801902c:	4611      	mov	r1, r2
 801902e:	461a      	mov	r2, r3
 8019030:	f7ff fc36 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		SetPixel(cx-y, cy+x );
 8019034:	69bb      	ldr	r3, [r7, #24]
 8019036:	b2db      	uxtb	r3, r3
 8019038:	78fa      	ldrb	r2, [r7, #3]
 801903a:	1ad3      	subs	r3, r2, r3
 801903c:	b2da      	uxtb	r2, r3
 801903e:	69fb      	ldr	r3, [r7, #28]
 8019040:	b2d9      	uxtb	r1, r3
 8019042:	78bb      	ldrb	r3, [r7, #2]
 8019044:	18cb      	adds	r3, r1, r3
 8019046:	b2db      	uxtb	r3, r3
 8019048:	6878      	ldr	r0, [r7, #4]
 801904a:	4611      	mov	r1, r2
 801904c:	461a      	mov	r2, r3
 801904e:	f7ff fc27 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		SetPixel(cx-y, cy-x );
 8019052:	69bb      	ldr	r3, [r7, #24]
 8019054:	b2db      	uxtb	r3, r3
 8019056:	78fa      	ldrb	r2, [r7, #3]
 8019058:	1ad3      	subs	r3, r2, r3
 801905a:	b2da      	uxtb	r2, r3
 801905c:	69fb      	ldr	r3, [r7, #28]
 801905e:	b2db      	uxtb	r3, r3
 8019060:	78b9      	ldrb	r1, [r7, #2]
 8019062:	1acb      	subs	r3, r1, r3
 8019064:	b2db      	uxtb	r3, r3
 8019066:	6878      	ldr	r0, [r7, #4]
 8019068:	4611      	mov	r1, r2
 801906a:	461a      	mov	r2, r3
 801906c:	f7ff fc18 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		SetPixel(cx+y, cy-x );
 8019070:	69bb      	ldr	r3, [r7, #24]
 8019072:	b2da      	uxtb	r2, r3
 8019074:	78fb      	ldrb	r3, [r7, #3]
 8019076:	18d3      	adds	r3, r2, r3
 8019078:	b2da      	uxtb	r2, r3
 801907a:	69fb      	ldr	r3, [r7, #28]
 801907c:	b2db      	uxtb	r3, r3
 801907e:	78b9      	ldrb	r1, [r7, #2]
 8019080:	1acb      	subs	r3, r1, r3
 8019082:	b2db      	uxtb	r3, r3
 8019084:	6878      	ldr	r0, [r7, #4]
 8019086:	4611      	mov	r1, r2
 8019088:	461a      	mov	r2, r3
 801908a:	f7ff fc09 	bl	80188a0 <_ZN13CT6963CDriver8SetPixelEhh>
		y++;
 801908e:	69bb      	ldr	r3, [r7, #24]
 8019090:	f103 0301 	add.w	r3, r3, #1
 8019094:	61bb      	str	r3, [r7, #24]
		radiusError += ychange;
 8019096:	68fa      	ldr	r2, [r7, #12]
 8019098:	693b      	ldr	r3, [r7, #16]
 801909a:	18d3      	adds	r3, r2, r3
 801909c:	60fb      	str	r3, [r7, #12]
		ychange += 2;
 801909e:	693b      	ldr	r3, [r7, #16]
 80190a0:	f103 0302 	add.w	r3, r3, #2
 80190a4:	613b      	str	r3, [r7, #16]
		if ( 2*radiusError + xchange > 0 )
 80190a6:	68fb      	ldr	r3, [r7, #12]
 80190a8:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80190ac:	697b      	ldr	r3, [r7, #20]
 80190ae:	18d3      	adds	r3, r2, r3
 80190b0:	2b00      	cmp	r3, #0
 80190b2:	dd0b      	ble.n	80190cc <_ZN13CT6963CDriver6CircleEhhh+0x168>
		{
			x--;
 80190b4:	69fb      	ldr	r3, [r7, #28]
 80190b6:	f103 33ff 	add.w	r3, r3, #4294967295
 80190ba:	61fb      	str	r3, [r7, #28]
			radiusError += xchange;
 80190bc:	68fa      	ldr	r2, [r7, #12]
 80190be:	697b      	ldr	r3, [r7, #20]
 80190c0:	18d3      	adds	r3, r2, r3
 80190c2:	60fb      	str	r3, [r7, #12]
			xchange += 2;
 80190c4:	697b      	ldr	r3, [r7, #20]
 80190c6:	f103 0302 	add.w	r3, r3, #2
 80190ca:	617b      	str	r3, [r7, #20]
	x = radius;
	y = 0;
	xchange = 1 - 2 * radius;
	ychange = 1;
	radiusError = 0;
	while(x >= y)
 80190cc:	69fa      	ldr	r2, [r7, #28]
 80190ce:	69bb      	ldr	r3, [r7, #24]
 80190d0:	429a      	cmp	r2, r3
 80190d2:	bfb4      	ite	lt
 80190d4:	2300      	movlt	r3, #0
 80190d6:	2301      	movge	r3, #1
 80190d8:	b2db      	uxtb	r3, r3
 80190da:	2b00      	cmp	r3, #0
 80190dc:	f47f af5f 	bne.w	8018f9e <_ZN13CT6963CDriver6CircleEhhh+0x3a>
			x--;
			radiusError += xchange;
			xchange += 2;
		}
	}
}
 80190e0:	f107 0720 	add.w	r7, r7, #32
 80190e4:	46bd      	mov	sp, r7
 80190e6:	bd80      	pop	{r7, pc}

080190e8 <_ZN13CT6963CDriver6BitmapEPhhhhh>:
  * @brief  writes a bitmap to graphics ram
  * @param  coordinates, width and heigth
  * @retval None
  */
void CT6963CDriver::Bitmap(unsigned char * bitmap, unsigned char x, unsigned char y, unsigned char width, unsigned char height)
{
 80190e8:	b580      	push	{r7, lr}
 80190ea:	b086      	sub	sp, #24
 80190ec:	af00      	add	r7, sp, #0
 80190ee:	60f8      	str	r0, [r7, #12]
 80190f0:	60b9      	str	r1, [r7, #8]
 80190f2:	71fa      	strb	r2, [r7, #7]
 80190f4:	71bb      	strb	r3, [r7, #6]
	unsigned char i, j;

	for(j = 0; j < height; j++)
 80190f6:	f04f 0300 	mov.w	r3, #0
 80190fa:	75bb      	strb	r3, [r7, #22]
 80190fc:	e04f      	b.n	801919e <_ZN13CT6963CDriver6BitmapEPhhhhh+0xb6>
	{
		GraphicGoTo(x, y + j);
 80190fe:	79ba      	ldrb	r2, [r7, #6]
 8019100:	7dbb      	ldrb	r3, [r7, #22]
 8019102:	18d3      	adds	r3, r2, r3
 8019104:	b2db      	uxtb	r3, r3
 8019106:	79fa      	ldrb	r2, [r7, #7]
 8019108:	68f8      	ldr	r0, [r7, #12]
 801910a:	4611      	mov	r1, r2
 801910c:	461a      	mov	r2, r3
 801910e:	f7ff fa5d 	bl	80185cc <_ZN13CT6963CDriver11GraphicGoToEhh>
		for(i = 0; i < width/GLCD_FONT_WIDTH; i++)
 8019112:	f04f 0300 	mov.w	r3, #0
 8019116:	75fb      	strb	r3, [r7, #23]
 8019118:	e030      	b.n	801917c <_ZN13CT6963CDriver6BitmapEPhhhhh+0x94>
		{
			if(Inverse()){
 801911a:	68fb      	ldr	r3, [r7, #12]
 801911c:	4618      	mov	r0, r3
 801911e:	f7ff f905 	bl	801832c <_ZN11CGraphicLCD7InverseEv>
 8019122:	4603      	mov	r3, r0
 8019124:	2b00      	cmp	r3, #0
 8019126:	d015      	beq.n	8019154 <_ZN13CT6963CDriver6BitmapEPhhhhh+0x6c>
				WriteDisplayData(!bitmap[i + (GLCD_GRAPHIC_AREA * j)]);
 8019128:	7df9      	ldrb	r1, [r7, #23]
 801912a:	7dba      	ldrb	r2, [r7, #22]
 801912c:	4613      	mov	r3, r2
 801912e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8019132:	1a9b      	subs	r3, r3, r2
 8019134:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8019138:	18cb      	adds	r3, r1, r3
 801913a:	68ba      	ldr	r2, [r7, #8]
 801913c:	18d3      	adds	r3, r2, r3
 801913e:	781b      	ldrb	r3, [r3, #0]
 8019140:	2b00      	cmp	r3, #0
 8019142:	bf14      	ite	ne
 8019144:	2300      	movne	r3, #0
 8019146:	2301      	moveq	r3, #1
 8019148:	b2db      	uxtb	r3, r3
 801914a:	68f8      	ldr	r0, [r7, #12]
 801914c:	4619      	mov	r1, r3
 801914e:	f7ff faab 	bl	80186a8 <_ZN13CT6963CDriver16WriteDisplayDataEh>
 8019152:	e00f      	b.n	8019174 <_ZN13CT6963CDriver6BitmapEPhhhhh+0x8c>
			} else {
				WriteDisplayData(bitmap[i + (GLCD_GRAPHIC_AREA * j)]);
 8019154:	7df9      	ldrb	r1, [r7, #23]
 8019156:	7dba      	ldrb	r2, [r7, #22]
 8019158:	4613      	mov	r3, r2
 801915a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 801915e:	1a9b      	subs	r3, r3, r2
 8019160:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8019164:	18cb      	adds	r3, r1, r3
 8019166:	68ba      	ldr	r2, [r7, #8]
 8019168:	18d3      	adds	r3, r2, r3
 801916a:	781b      	ldrb	r3, [r3, #0]
 801916c:	68f8      	ldr	r0, [r7, #12]
 801916e:	4619      	mov	r1, r3
 8019170:	f7ff fa9a 	bl	80186a8 <_ZN13CT6963CDriver16WriteDisplayDataEh>
	unsigned char i, j;

	for(j = 0; j < height; j++)
	{
		GraphicGoTo(x, y + j);
		for(i = 0; i < width/GLCD_FONT_WIDTH; i++)
 8019174:	7dfb      	ldrb	r3, [r7, #23]
 8019176:	f103 0301 	add.w	r3, r3, #1
 801917a:	75fb      	strb	r3, [r7, #23]
 801917c:	f897 3020 	ldrb.w	r3, [r7, #32]
 8019180:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8019184:	b2db      	uxtb	r3, r3
 8019186:	7dfa      	ldrb	r2, [r7, #23]
 8019188:	429a      	cmp	r2, r3
 801918a:	bf2c      	ite	cs
 801918c:	2300      	movcs	r3, #0
 801918e:	2301      	movcc	r3, #1
 8019190:	b2db      	uxtb	r3, r3
 8019192:	2b00      	cmp	r3, #0
 8019194:	d1c1      	bne.n	801911a <_ZN13CT6963CDriver6BitmapEPhhhhh+0x32>
  */
void CT6963CDriver::Bitmap(unsigned char * bitmap, unsigned char x, unsigned char y, unsigned char width, unsigned char height)
{
	unsigned char i, j;

	for(j = 0; j < height; j++)
 8019196:	7dbb      	ldrb	r3, [r7, #22]
 8019198:	f103 0301 	add.w	r3, r3, #1
 801919c:	75bb      	strb	r3, [r7, #22]
 801919e:	7dba      	ldrb	r2, [r7, #22]
 80191a0:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 80191a4:	429a      	cmp	r2, r3
 80191a6:	bf2c      	ite	cs
 80191a8:	2300      	movcs	r3, #0
 80191aa:	2301      	movcc	r3, #1
 80191ac:	b2db      	uxtb	r3, r3
 80191ae:	2b00      	cmp	r3, #0
 80191b0:	d1a5      	bne.n	80190fe <_ZN13CT6963CDriver6BitmapEPhhhhh+0x16>
			} else {
				WriteDisplayData(bitmap[i + (GLCD_GRAPHIC_AREA * j)]);
			}
		}
	}
}
 80191b2:	f107 0718 	add.w	r7, r7, #24
 80191b6:	46bd      	mov	sp, r7
 80191b8:	bd80      	pop	{r7, pc}
 80191ba:	bf00      	nop

080191bc <_ZN21CT6963_GPIO_InterfaceC1Ev>:
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/



CT6963_GPIO_Interface::CT6963_GPIO_Interface() {
 80191bc:	b580      	push	{r7, lr}
 80191be:	b082      	sub	sp, #8
 80191c0:	af00      	add	r7, sp, #0
 80191c2:	6078      	str	r0, [r7, #4]
 80191c4:	687b      	ldr	r3, [r7, #4]
 80191c6:	4618      	mov	r0, r3
 80191c8:	f7ff f8ca 	bl	8018360 <_ZN13CT6963CDriverC1Ev>
 80191cc:	687b      	ldr	r3, [r7, #4]
 80191ce:	4a04      	ldr	r2, [pc, #16]	; (80191e0 <_ZN21CT6963_GPIO_InterfaceC1Ev+0x24>)
 80191d0:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated constructor stub

}
 80191d2:	687b      	ldr	r3, [r7, #4]
 80191d4:	4618      	mov	r0, r3
 80191d6:	f107 0708 	add.w	r7, r7, #8
 80191da:	46bd      	mov	sp, r7
 80191dc:	bd80      	pop	{r7, pc}
 80191de:	bf00      	nop
 80191e0:	0802f0f0 	.word	0x0802f0f0

080191e4 <_ZN21CT6963_GPIO_InterfaceD1Ev>:

CT6963_GPIO_Interface::~CT6963_GPIO_Interface() {
 80191e4:	b580      	push	{r7, lr}
 80191e6:	b082      	sub	sp, #8
 80191e8:	af00      	add	r7, sp, #0
 80191ea:	6078      	str	r0, [r7, #4]
 80191ec:	687b      	ldr	r3, [r7, #4]
 80191ee:	4a0a      	ldr	r2, [pc, #40]	; (8019218 <_ZN21CT6963_GPIO_InterfaceD1Ev+0x34>)
 80191f0:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated destructor stub
}
 80191f2:	6878      	ldr	r0, [r7, #4]
 80191f4:	f7ff f8c8 	bl	8018388 <_ZN13CT6963CDriverD1Ev>
 80191f8:	f04f 0300 	mov.w	r3, #0
 80191fc:	f003 0301 	and.w	r3, r3, #1
 8019200:	b2db      	uxtb	r3, r3
 8019202:	2b00      	cmp	r3, #0
 8019204:	d002      	beq.n	801920c <_ZN21CT6963_GPIO_InterfaceD1Ev+0x28>
 8019206:	6878      	ldr	r0, [r7, #4]
 8019208:	f008 ffe4 	bl	80221d4 <_ZdlPv>
 801920c:	687b      	ldr	r3, [r7, #4]
 801920e:	4618      	mov	r0, r3
 8019210:	f107 0708 	add.w	r7, r7, #8
 8019214:	46bd      	mov	sp, r7
 8019216:	bd80      	pop	{r7, pc}
 8019218:	0802f0f0 	.word	0x0802f0f0

0801921c <_ZN21CT6963_GPIO_InterfaceD0Ev>:
CT6963_GPIO_Interface::CT6963_GPIO_Interface() {
	// TODO Auto-generated constructor stub

}

CT6963_GPIO_Interface::~CT6963_GPIO_Interface() {
 801921c:	b580      	push	{r7, lr}
 801921e:	b082      	sub	sp, #8
 8019220:	af00      	add	r7, sp, #0
 8019222:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated destructor stub
}
 8019224:	6878      	ldr	r0, [r7, #4]
 8019226:	f7ff ffdd 	bl	80191e4 <_ZN21CT6963_GPIO_InterfaceD1Ev>
 801922a:	6878      	ldr	r0, [r7, #4]
 801922c:	f008 ffd2 	bl	80221d4 <_ZdlPv>
 8019230:	687b      	ldr	r3, [r7, #4]
 8019232:	4618      	mov	r0, r3
 8019234:	f107 0708 	add.w	r7, r7, #8
 8019238:	46bd      	mov	sp, r7
 801923a:	bd80      	pop	{r7, pc}

0801923c <_Z11CheckStatusv>:
  * @brief  reads T6963C status byte
  * @param  None
  * @retval true for display ready
  */
bool CheckStatus(void)
{
 801923c:	b580      	push	{r7, lr}
 801923e:	b082      	sub	sp, #8
 8019240:	af00      	add	r7, sp, #0

	uint16_t tmp;
	GLCD_DATA_INPUT;
 8019242:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8019246:	f2c4 0302 	movt	r3, #16386	; 0x4002
 801924a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801924e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8019252:	6812      	ldr	r2, [r2, #0]
 8019254:	ea4f 4202 	mov.w	r2, r2, lsl #16
 8019258:	ea4f 4212 	mov.w	r2, r2, lsr #16
 801925c:	601a      	str	r2, [r3, #0]

	GPIO_ResetBits(GLCD_CTRL_PORT_CD_RD , GLCD_RD);
 801925e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8019262:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019266:	f04f 0120 	mov.w	r1, #32
 801926a:	f7ee fa79 	bl	8007760 <GPIO_ResetBits>
	GPIO_ResetBits(GLCD_CTRL_PORT_WR_CE , GLCD_CE);
 801926e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8019272:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019276:	f04f 0102 	mov.w	r1, #2
 801927a:	f7ee fa71 	bl	8007760 <GPIO_ResetBits>

	delay_us(c_iDelayFore);
 801927e:	f04f 0002 	mov.w	r0, #2
 8019282:	f009 fc3d 	bl	8022b00 <delay_us>

	tmp = ((GPIO_ReadInputData(GLCD_DATA_PORT) & GLCD_DATA_PORT_MASK) >> GLCD_DATA_OFFSET);
 8019286:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 801928a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801928e:	f7ee fa1f 	bl	80076d0 <GPIO_ReadInputData>
 8019292:	4603      	mov	r3, r0
 8019294:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8019298:	80fb      	strh	r3, [r7, #6]

	GPIO_SetBits(GLCD_CTRL_PORT_WR_CE , GLCD_CE);
 801929a:	f44f 6080 	mov.w	r0, #1024	; 0x400
 801929e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80192a2:	f04f 0102 	mov.w	r1, #2
 80192a6:	f7ee fa4d 	bl	8007744 <GPIO_SetBits>
	GPIO_SetBits(GLCD_CTRL_PORT_CD_RD , GLCD_RD);
 80192aa:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80192ae:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80192b2:	f04f 0120 	mov.w	r1, #32
 80192b6:	f7ee fa45 	bl	8007744 <GPIO_SetBits>

	delay_us(c_iDelayAfter);
 80192ba:	f04f 0001 	mov.w	r0, #1
 80192be:	f009 fc1f 	bl	8022b00 <delay_us>

	GLCD_DATA_OUTPUT;
 80192c2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80192c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80192ca:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80192ce:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80192d2:	6812      	ldr	r2, [r2, #0]
 80192d4:	f042 42aa 	orr.w	r2, r2, #1426063360	; 0x55000000
 80192d8:	f442 02aa 	orr.w	r2, r2, #5570560	; 0x550000
 80192dc:	601a      	str	r2, [r3, #0]

	return ((tmp&0x03)==0x03);
 80192de:	88fb      	ldrh	r3, [r7, #6]
 80192e0:	f003 0303 	and.w	r3, r3, #3
 80192e4:	2b03      	cmp	r3, #3
 80192e6:	bf14      	ite	ne
 80192e8:	2300      	movne	r3, #0
 80192ea:	2301      	moveq	r3, #1
 80192ec:	b2db      	uxtb	r3, r3
}
 80192ee:	4618      	mov	r0, r3
 80192f0:	f107 0708 	add.w	r7, r7, #8
 80192f4:	46bd      	mov	sp, r7
 80192f6:	bd80      	pop	{r7, pc}

080192f8 <_ZN21CT6963_GPIO_Interface12HardwareInitEv>:
/**
  * @brief  initialize Hardware to drive the display
  * @param  None
  * @retval None
  */
void CT6963_GPIO_Interface::HardwareInit(void){
 80192f8:	b580      	push	{r7, lr}
 80192fa:	b084      	sub	sp, #16
 80192fc:	af00      	add	r7, sp, #0
 80192fe:	6078      	str	r0, [r7, #4]


	GPIO_InitTypeDef GPIO_InitStructure;
	// activate Clock for Io Ports used
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB , ENABLE);
 8019300:	f04f 0002 	mov.w	r0, #2
 8019304:	f04f 0101 	mov.w	r1, #1
 8019308:	f7ef fcb0 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC , ENABLE);
 801930c:	f04f 0004 	mov.w	r0, #4
 8019310:	f04f 0101 	mov.w	r1, #1
 8019314:	f7ef fcaa 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE , ENABLE);
 8019318:	f04f 0010 	mov.w	r0, #16
 801931c:	f04f 0101 	mov.w	r1, #1
 8019320:	f7ef fca4 	bl	8008c6c <RCC_AHB1PeriphClockCmd>

	// all pins as pp outputs with no pull
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8019324:	f04f 0301 	mov.w	r3, #1
 8019328:	733b      	strb	r3, [r7, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 801932a:	f04f 0300 	mov.w	r3, #0
 801932e:	73bb      	strb	r3, [r7, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8019330:	f04f 0300 	mov.w	r3, #0
 8019334:	73fb      	strb	r3, [r7, #15]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
 8019336:	f04f 0301 	mov.w	r3, #1
 801933a:	737b      	strb	r3, [r7, #13]

	//Control pins CD and RD
	GPIO_InitStructure.GPIO_Pin = GLCD_CD | GLCD_RD;
 801933c:	f04f 0330 	mov.w	r3, #48	; 0x30
 8019340:	60bb      	str	r3, [r7, #8]
	GPIO_Init(GLCD_CTRL_PORT_CD_RD,&GPIO_InitStructure);
 8019342:	f107 0308 	add.w	r3, r7, #8
 8019346:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801934a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801934e:	4619      	mov	r1, r3
 8019350:	f7ee f8b6 	bl	80074c0 <GPIO_Init>
	//Control pins WR, CE and RST
	GPIO_InitStructure.GPIO_Pin = GLCD_WR | GLCD_CE | GLCD_RESET;
 8019354:	f640 0303 	movw	r3, #2051	; 0x803
 8019358:	60bb      	str	r3, [r7, #8]
	GPIO_Init(GLCD_CTRL_PORT_WR_CE,&GPIO_InitStructure);
 801935a:	f107 0308 	add.w	r3, r7, #8
 801935e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8019362:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019366:	4619      	mov	r1, r3
 8019368:	f7ee f8aa 	bl	80074c0 <GPIO_Init>

	// data pins are high byte
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 801936c:	f04f 0302 	mov.w	r3, #2
 8019370:	73fb      	strb	r3, [r7, #15]
	GPIO_InitStructure.GPIO_Pin = GLCD_DATA_PORT_MASK;
 8019372:	f44f 437f 	mov.w	r3, #65280	; 0xff00
 8019376:	60bb      	str	r3, [r7, #8]
	GPIO_Init(GLCD_DATA_PORT,&GPIO_InitStructure);
 8019378:	f107 0308 	add.w	r3, r7, #8
 801937c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8019380:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019384:	4619      	mov	r1, r3
 8019386:	f7ee f89b 	bl	80074c0 <GPIO_Init>

	//Set all Control pins to high level
	GPIO_SetBits(GLCD_CTRL_PORT_CD_RD , GLCD_CD | GLCD_RD);	GPIO_SetBits(GLCD_CTRL_PORT_WR_CE , GLCD_WR | GLCD_CE );
 801938a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801938e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019392:	f04f 0130 	mov.w	r1, #48	; 0x30
 8019396:	f7ee f9d5 	bl	8007744 <GPIO_SetBits>
 801939a:	f44f 6080 	mov.w	r0, #1024	; 0x400
 801939e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80193a2:	f04f 0103 	mov.w	r1, #3
 80193a6:	f7ee f9cd 	bl	8007744 <GPIO_SetBits>

	init_us_timer(); //delay timer init
 80193aa:	f009 fbe7 	bl	8022b7c <init_us_timer>

}
 80193ae:	f107 0710 	add.w	r7, r7, #16
 80193b2:	46bd      	mov	sp, r7
 80193b4:	bd80      	pop	{r7, pc}
 80193b6:	bf00      	nop

080193b8 <_ZN21CT6963_GPIO_Interface5ResetEv>:
/**
  * @brief  Reset the Display
  * @param  None
  * @retval None
  */
void CT6963_GPIO_Interface::Reset(void){
 80193b8:	b580      	push	{r7, lr}
 80193ba:	b082      	sub	sp, #8
 80193bc:	af00      	add	r7, sp, #0
 80193be:	6078      	str	r0, [r7, #4]

	GPIO_ResetBits(GLCD_CTRL_PORT_WR_CE , GLCD_RESET | GLCD_CE );
 80193c0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80193c4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80193c8:	f640 0102 	movw	r1, #2050	; 0x802
 80193cc:	f7ee f9c8 	bl	8007760 <GPIO_ResetBits>

	vTaskDelay(20);  // sleep 20 ms
 80193d0:	f04f 0014 	mov.w	r0, #20
 80193d4:	f001 fad2 	bl	801a97c <vTaskDelay>

	GPIO_SetBits(GLCD_CTRL_PORT_WR_CE , GLCD_RESET | GLCD_CE );
 80193d8:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80193dc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80193e0:	f640 0102 	movw	r1, #2050	; 0x802
 80193e4:	f7ee f9ae 	bl	8007744 <GPIO_SetBits>

}
 80193e8:	f107 0708 	add.w	r7, r7, #8
 80193ec:	46bd      	mov	sp, r7
 80193ee:	bd80      	pop	{r7, pc}

080193f0 <_ZN21CT6963_GPIO_Interface12WriteCommandEh>:
/**
  * @brief  writes a command
  * @param  command
  * @retval None
  */
void CT6963_GPIO_Interface::WriteCommand(const unsigned char command){
 80193f0:	b580      	push	{r7, lr}
 80193f2:	b082      	sub	sp, #8
 80193f4:	af00      	add	r7, sp, #0
 80193f6:	6078      	str	r0, [r7, #4]
 80193f8:	460b      	mov	r3, r1
 80193fa:	70fb      	strb	r3, [r7, #3]

	while(!CheckStatus());
 80193fc:	bf00      	nop
 80193fe:	f7ff ff1d 	bl	801923c <_Z11CheckStatusv>
 8019402:	4603      	mov	r3, r0
 8019404:	f083 0301 	eor.w	r3, r3, #1
 8019408:	b2db      	uxtb	r3, r3
 801940a:	2b00      	cmp	r3, #0
 801940c:	d1f7      	bne.n	80193fe <_ZN21CT6963_GPIO_Interface12WriteCommandEh+0xe>

	GLCD_DATA_PORT->ODR &= ~GLCD_DATA_PORT_MASK;  //Clear Data pins
 801940e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8019412:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8019416:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801941a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 801941e:	6952      	ldr	r2, [r2, #20]
 8019420:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8019424:	615a      	str	r2, [r3, #20]
	GLCD_DATA_PORT->ODR |= (command << (GLCD_DATA_OFFSET)); // lowbyte will stay as is in this write
 8019426:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801942a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 801942e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8019432:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8019436:	6952      	ldr	r2, [r2, #20]
 8019438:	4611      	mov	r1, r2
 801943a:	78fa      	ldrb	r2, [r7, #3]
 801943c:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8019440:	430a      	orrs	r2, r1
 8019442:	615a      	str	r2, [r3, #20]

	GPIO_ResetBits(GLCD_CTRL_PORT_WR_CE , GLCD_WR);
 8019444:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8019448:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801944c:	f04f 0101 	mov.w	r1, #1
 8019450:	f7ee f986 	bl	8007760 <GPIO_ResetBits>
	GPIO_ResetBits(GLCD_CTRL_PORT_WR_CE , GLCD_CE);
 8019454:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8019458:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801945c:	f04f 0102 	mov.w	r1, #2
 8019460:	f7ee f97e 	bl	8007760 <GPIO_ResetBits>

	delay_us(c_iDelayFore);   // time for display to read the data
 8019464:	f04f 0002 	mov.w	r0, #2
 8019468:	f009 fb4a 	bl	8022b00 <delay_us>

	GPIO_SetBits(GLCD_CTRL_PORT_WR_CE , GLCD_CE);
 801946c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8019470:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019474:	f04f 0102 	mov.w	r1, #2
 8019478:	f7ee f964 	bl	8007744 <GPIO_SetBits>
	GPIO_SetBits(GLCD_CTRL_PORT_WR_CE , GLCD_WR);
 801947c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8019480:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019484:	f04f 0101 	mov.w	r1, #1
 8019488:	f7ee f95c 	bl	8007744 <GPIO_SetBits>


	delay_us(c_iDelayAfter);
 801948c:	f04f 0001 	mov.w	r0, #1
 8019490:	f009 fb36 	bl	8022b00 <delay_us>
}
 8019494:	f107 0708 	add.w	r7, r7, #8
 8019498:	46bd      	mov	sp, r7
 801949a:	bd80      	pop	{r7, pc}

0801949c <_ZN21CT6963_GPIO_Interface9WriteDataEh>:
/**
  * @brief  writes a data
  * @param  data
  * @retval None
  */
void CT6963_GPIO_Interface::WriteData(const unsigned char data){
 801949c:	b580      	push	{r7, lr}
 801949e:	b082      	sub	sp, #8
 80194a0:	af00      	add	r7, sp, #0
 80194a2:	6078      	str	r0, [r7, #4]
 80194a4:	460b      	mov	r3, r1
 80194a6:	70fb      	strb	r3, [r7, #3]
	while(!CheckStatus());
 80194a8:	bf00      	nop
 80194aa:	f7ff fec7 	bl	801923c <_Z11CheckStatusv>
 80194ae:	4603      	mov	r3, r0
 80194b0:	f083 0301 	eor.w	r3, r3, #1
 80194b4:	b2db      	uxtb	r3, r3
 80194b6:	2b00      	cmp	r3, #0
 80194b8:	d1f7      	bne.n	80194aa <_ZN21CT6963_GPIO_Interface9WriteDataEh+0xe>

	GLCD_DATA_PORT->ODR &= ~GLCD_DATA_PORT_MASK;  //Clear Data pins
 80194ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80194be:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80194c2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80194c6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80194ca:	6952      	ldr	r2, [r2, #20]
 80194cc:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80194d0:	615a      	str	r2, [r3, #20]
	GLCD_DATA_PORT->ODR |= ((uint16_t)data << GLCD_DATA_OFFSET); // lowbyte will stay as is in this write
 80194d2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80194d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80194da:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80194de:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80194e2:	6952      	ldr	r2, [r2, #20]
 80194e4:	4611      	mov	r1, r2
 80194e6:	78fa      	ldrb	r2, [r7, #3]
 80194e8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80194ec:	430a      	orrs	r2, r1
 80194ee:	615a      	str	r2, [r3, #20]

	GPIO_ResetBits(GLCD_CTRL_PORT_CD_RD , GLCD_CD);
 80194f0:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80194f4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80194f8:	f04f 0110 	mov.w	r1, #16
 80194fc:	f7ee f930 	bl	8007760 <GPIO_ResetBits>
	GPIO_ResetBits(GLCD_CTRL_PORT_WR_CE , GLCD_WR);
 8019500:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8019504:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019508:	f04f 0101 	mov.w	r1, #1
 801950c:	f7ee f928 	bl	8007760 <GPIO_ResetBits>
	GPIO_ResetBits(GLCD_CTRL_PORT_WR_CE , GLCD_CE);
 8019510:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8019514:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019518:	f04f 0102 	mov.w	r1, #2
 801951c:	f7ee f920 	bl	8007760 <GPIO_ResetBits>

	delay_us(c_iDelayFore);
 8019520:	f04f 0002 	mov.w	r0, #2
 8019524:	f009 faec 	bl	8022b00 <delay_us>

	GPIO_SetBits(GLCD_CTRL_PORT_WR_CE , GLCD_CE);
 8019528:	f44f 6080 	mov.w	r0, #1024	; 0x400
 801952c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019530:	f04f 0102 	mov.w	r1, #2
 8019534:	f7ee f906 	bl	8007744 <GPIO_SetBits>
	GPIO_SetBits(GLCD_CTRL_PORT_CD_RD , GLCD_CD);
 8019538:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801953c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019540:	f04f 0110 	mov.w	r1, #16
 8019544:	f7ee f8fe 	bl	8007744 <GPIO_SetBits>
	GPIO_SetBits(GLCD_CTRL_PORT_WR_CE , GLCD_WR);
 8019548:	f44f 6080 	mov.w	r0, #1024	; 0x400
 801954c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019550:	f04f 0101 	mov.w	r1, #1
 8019554:	f7ee f8f6 	bl	8007744 <GPIO_SetBits>

	delay_us(c_iDelayAfter);
 8019558:	f04f 0001 	mov.w	r0, #1
 801955c:	f009 fad0 	bl	8022b00 <delay_us>
}
 8019560:	f107 0708 	add.w	r7, r7, #8
 8019564:	46bd      	mov	sp, r7
 8019566:	bd80      	pop	{r7, pc}

08019568 <_ZN21CT6963_GPIO_Interface8ReadDataEv>:
/**
  * @brief  reads data from display
  * @param  None
  * @retval data from display
  */
unsigned char CT6963_GPIO_Interface::ReadData(){
 8019568:	b580      	push	{r7, lr}
 801956a:	b084      	sub	sp, #16
 801956c:	af00      	add	r7, sp, #0
 801956e:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	while(!CheckStatus());
 8019570:	bf00      	nop
 8019572:	f7ff fe63 	bl	801923c <_Z11CheckStatusv>
 8019576:	4603      	mov	r3, r0
 8019578:	f083 0301 	eor.w	r3, r3, #1
 801957c:	b2db      	uxtb	r3, r3
 801957e:	2b00      	cmp	r3, #0
 8019580:	d1f7      	bne.n	8019572 <_ZN21CT6963_GPIO_Interface8ReadDataEv+0xa>

	GLCD_DATA_INPUT;
 8019582:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8019586:	f2c4 0302 	movt	r3, #16386	; 0x4002
 801958a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801958e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8019592:	6812      	ldr	r2, [r2, #0]
 8019594:	ea4f 4202 	mov.w	r2, r2, lsl #16
 8019598:	ea4f 4212 	mov.w	r2, r2, lsr #16
 801959c:	601a      	str	r2, [r3, #0]

	GPIO_ResetBits(GLCD_CTRL_PORT_CD_RD , GLCD_RD );
 801959e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80195a2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80195a6:	f04f 0120 	mov.w	r1, #32
 80195aa:	f7ee f8d9 	bl	8007760 <GPIO_ResetBits>
	GPIO_ResetBits(GLCD_CTRL_PORT_CD_RD , GLCD_CD );
 80195ae:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80195b2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80195b6:	f04f 0110 	mov.w	r1, #16
 80195ba:	f7ee f8d1 	bl	8007760 <GPIO_ResetBits>
	GPIO_ResetBits(GLCD_CTRL_PORT_WR_CE , GLCD_CE );
 80195be:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80195c2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80195c6:	f04f 0102 	mov.w	r1, #2
 80195ca:	f7ee f8c9 	bl	8007760 <GPIO_ResetBits>

	delay_us(c_iDelayFore);
 80195ce:	f04f 0002 	mov.w	r0, #2
 80195d2:	f009 fa95 	bl	8022b00 <delay_us>

	tmp = ((GPIO_ReadInputData(GLCD_DATA_PORT) & GLCD_DATA_PORT_MASK) >> GLCD_DATA_OFFSET);
 80195d6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80195da:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80195de:	f7ee f877 	bl	80076d0 <GPIO_ReadInputData>
 80195e2:	4603      	mov	r3, r0
 80195e4:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80195e8:	81fb      	strh	r3, [r7, #14]

	GPIO_SetBits(GLCD_CTRL_PORT_WR_CE , GLCD_CE );
 80195ea:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80195ee:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80195f2:	f04f 0102 	mov.w	r1, #2
 80195f6:	f7ee f8a5 	bl	8007744 <GPIO_SetBits>
	GPIO_SetBits(GLCD_CTRL_PORT_CD_RD , GLCD_CD );
 80195fa:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80195fe:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019602:	f04f 0110 	mov.w	r1, #16
 8019606:	f7ee f89d 	bl	8007744 <GPIO_SetBits>
	GPIO_SetBits(GLCD_CTRL_PORT_CD_RD , GLCD_RD );
 801960a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801960e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8019612:	f04f 0120 	mov.w	r1, #32
 8019616:	f7ee f895 	bl	8007744 <GPIO_SetBits>

	delay_us(c_iDelayAfter);
 801961a:	f04f 0001 	mov.w	r0, #1
 801961e:	f009 fa6f 	bl	8022b00 <delay_us>

	GLCD_DATA_OUTPUT;
 8019622:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8019626:	f2c4 0302 	movt	r3, #16386	; 0x4002
 801962a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801962e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8019632:	6812      	ldr	r2, [r2, #0]
 8019634:	f042 42aa 	orr.w	r2, r2, #1426063360	; 0x55000000
 8019638:	f442 02aa 	orr.w	r2, r2, #5570560	; 0x550000
 801963c:	601a      	str	r2, [r3, #0]
	return (unsigned char)tmp;
 801963e:	89fb      	ldrh	r3, [r7, #14]
 8019640:	b2db      	uxtb	r3, r3
}
 8019642:	4618      	mov	r0, r3
 8019644:	f107 0710 	add.w	r7, r7, #16
 8019648:	46bd      	mov	sp, r7
 801964a:	bd80      	pop	{r7, pc}

0801964c <_ZN12AManagedTaskC1Ev>:
#include "AManagedTask.h"
#include "CFreeRTOS.h"

AManagedTask* AManagedTask::s_pManagedTaskListHead = NULL;

AManagedTask::AManagedTask() {
 801964c:	b580      	push	{r7, lr}
 801964e:	b082      	sub	sp, #8
 8019650:	af00      	add	r7, sp, #0
 8019652:	6078      	str	r0, [r7, #4]
 8019654:	687b      	ldr	r3, [r7, #4]
 8019656:	4618      	mov	r0, r3
 8019658:	f000 f940 	bl	80198dc <_ZN5CTaskC1Ev>
 801965c:	687b      	ldr	r3, [r7, #4]
 801965e:	4a08      	ldr	r2, [pc, #32]	; (8019680 <_ZN12AManagedTaskC1Ev+0x34>)
 8019660:	601a      	str	r2, [r3, #0]
	m_pNextManagedTask = NULL;
 8019662:	687b      	ldr	r3, [r7, #4]
 8019664:	f04f 0200 	mov.w	r2, #0
 8019668:	609a      	str	r2, [r3, #8]
	AddToManagedTask(this);
 801966a:	6878      	ldr	r0, [r7, #4]
 801966c:	6879      	ldr	r1, [r7, #4]
 801966e:	f000 f87b 	bl	8019768 <_ZN12AManagedTask16AddToManagedTaskEPS_>
}
 8019672:	687b      	ldr	r3, [r7, #4]
 8019674:	4618      	mov	r0, r3
 8019676:	f107 0708 	add.w	r7, r7, #8
 801967a:	46bd      	mov	sp, r7
 801967c:	bd80      	pop	{r7, pc}
 801967e:	bf00      	nop
 8019680:	08032a68 	.word	0x08032a68

08019684 <_ZN12AManagedTaskD1Ev>:

AManagedTask::~AManagedTask() {
 8019684:	b580      	push	{r7, lr}
 8019686:	b082      	sub	sp, #8
 8019688:	af00      	add	r7, sp, #0
 801968a:	6078      	str	r0, [r7, #4]
 801968c:	687b      	ldr	r3, [r7, #4]
 801968e:	4a0c      	ldr	r2, [pc, #48]	; (80196c0 <_ZN12AManagedTaskD1Ev+0x3c>)
 8019690:	601a      	str	r2, [r3, #0]
	RemoveFromManagedTask(this);
 8019692:	6878      	ldr	r0, [r7, #4]
 8019694:	6879      	ldr	r1, [r7, #4]
 8019696:	f000 f88f 	bl	80197b8 <_ZN12AManagedTask21RemoveFromManagedTaskEPS_>
}
 801969a:	6878      	ldr	r0, [r7, #4]
 801969c:	f000 f94e 	bl	801993c <_ZN5CTaskD1Ev>
 80196a0:	f04f 0300 	mov.w	r3, #0
 80196a4:	f003 0301 	and.w	r3, r3, #1
 80196a8:	b2db      	uxtb	r3, r3
 80196aa:	2b00      	cmp	r3, #0
 80196ac:	d002      	beq.n	80196b4 <_ZN12AManagedTaskD1Ev+0x30>
 80196ae:	6878      	ldr	r0, [r7, #4]
 80196b0:	f008 fd90 	bl	80221d4 <_ZdlPv>
 80196b4:	687b      	ldr	r3, [r7, #4]
 80196b6:	4618      	mov	r0, r3
 80196b8:	f107 0708 	add.w	r7, r7, #8
 80196bc:	46bd      	mov	sp, r7
 80196be:	bd80      	pop	{r7, pc}
 80196c0:	08032a68 	.word	0x08032a68

080196c4 <_ZN12AManagedTaskD0Ev>:
AManagedTask::AManagedTask() {
	m_pNextManagedTask = NULL;
	AddToManagedTask(this);
}

AManagedTask::~AManagedTask() {
 80196c4:	b580      	push	{r7, lr}
 80196c6:	b082      	sub	sp, #8
 80196c8:	af00      	add	r7, sp, #0
 80196ca:	6078      	str	r0, [r7, #4]
	RemoveFromManagedTask(this);
}
 80196cc:	6878      	ldr	r0, [r7, #4]
 80196ce:	f7ff ffd9 	bl	8019684 <_ZN12AManagedTaskD1Ev>
 80196d2:	6878      	ldr	r0, [r7, #4]
 80196d4:	f008 fd7e 	bl	80221d4 <_ZdlPv>
 80196d8:	687b      	ldr	r3, [r7, #4]
 80196da:	4618      	mov	r0, r3
 80196dc:	f107 0708 	add.w	r7, r7, #8
 80196e0:	46bd      	mov	sp, r7
 80196e2:	bd80      	pop	{r7, pc}

080196e4 <_ZN12AManagedTask6CreateEPKctm>:

portBASE_TYPE AManagedTask::Create(const portCHAR * const pcName, unsigned portSHORT usStackDepth, unsigned portBASE_TYPE uxPriority) {
 80196e4:	b590      	push	{r4, r7, lr}
 80196e6:	b087      	sub	sp, #28
 80196e8:	af02      	add	r7, sp, #8
 80196ea:	60f8      	str	r0, [r7, #12]
 80196ec:	60b9      	str	r1, [r7, #8]
 80196ee:	603b      	str	r3, [r7, #0]
 80196f0:	4613      	mov	r3, r2
 80196f2:	80fb      	strh	r3, [r7, #6]
	return OnCreate(pcName, usStackDepth, uxPriority) &&
 80196f4:	68fb      	ldr	r3, [r7, #12]
 80196f6:	681b      	ldr	r3, [r3, #0]
 80196f8:	f103 031c 	add.w	r3, r3, #28
 80196fc:	681c      	ldr	r4, [r3, #0]
 80196fe:	88fb      	ldrh	r3, [r7, #6]
 8019700:	68f8      	ldr	r0, [r7, #12]
 8019702:	68b9      	ldr	r1, [r7, #8]
 8019704:	461a      	mov	r2, r3
 8019706:	683b      	ldr	r3, [r7, #0]
 8019708:	47a0      	blx	r4
 801970a:	4603      	mov	r3, r0
			CTask::Create(AManagedTask::taskControlFunc, pcName, usStackDepth, this, uxPriority);
 801970c:	2b00      	cmp	r3, #0
 801970e:	d013      	beq.n	8019738 <_ZN12AManagedTask6CreateEPKctm+0x54>
 8019710:	68fa      	ldr	r2, [r7, #12]
 8019712:	88fb      	ldrh	r3, [r7, #6]
 8019714:	68f9      	ldr	r1, [r7, #12]
 8019716:	9100      	str	r1, [sp, #0]
 8019718:	6839      	ldr	r1, [r7, #0]
 801971a:	9101      	str	r1, [sp, #4]
 801971c:	4610      	mov	r0, r2
 801971e:	f249 7149 	movw	r1, #38729	; 0x9749
 8019722:	f6c0 0101 	movt	r1, #2049	; 0x801
 8019726:	68ba      	ldr	r2, [r7, #8]
 8019728:	f000 f964 	bl	80199f4 <_ZN5CTask6CreateEPFvPvEPKctS0_m>
 801972c:	4603      	mov	r3, r0
 801972e:	2b00      	cmp	r3, #0
 8019730:	d002      	beq.n	8019738 <_ZN12AManagedTask6CreateEPKctm+0x54>
 8019732:	f04f 0301 	mov.w	r3, #1
 8019736:	e001      	b.n	801973c <_ZN12AManagedTask6CreateEPKctm+0x58>
 8019738:	f04f 0300 	mov.w	r3, #0
}
 801973c:	4618      	mov	r0, r3
 801973e:	f107 0714 	add.w	r7, r7, #20
 8019742:	46bd      	mov	sp, r7
 8019744:	bd90      	pop	{r4, r7, pc}
 8019746:	bf00      	nop

08019748 <_ZN12AManagedTask15taskControlFuncEPv>:

void AManagedTask::taskControlFunc(void *pParams) {
 8019748:	b580      	push	{r7, lr}
 801974a:	b082      	sub	sp, #8
 801974c:	af00      	add	r7, sp, #0
 801974e:	6078      	str	r0, [r7, #4]
	static_cast<AManagedTask *>(pParams)->Run();
 8019750:	687b      	ldr	r3, [r7, #4]
 8019752:	681b      	ldr	r3, [r3, #0]
 8019754:	f103 0318 	add.w	r3, r3, #24
 8019758:	681b      	ldr	r3, [r3, #0]
 801975a:	6878      	ldr	r0, [r7, #4]
 801975c:	4798      	blx	r3
}
 801975e:	f107 0708 	add.w	r7, r7, #8
 8019762:	46bd      	mov	sp, r7
 8019764:	bd80      	pop	{r7, pc}
 8019766:	bf00      	nop

08019768 <_ZN12AManagedTask16AddToManagedTaskEPS_>:

void AManagedTask::AddToManagedTask(AManagedTask *pTaskToAdd) {
 8019768:	b580      	push	{r7, lr}
 801976a:	b082      	sub	sp, #8
 801976c:	af00      	add	r7, sp, #0
 801976e:	6078      	str	r0, [r7, #4]
 8019770:	6039      	str	r1, [r7, #0]
	EnterCritical();
 8019772:	f00b fa17 	bl	8024ba4 <_ZN5CTask13EnterCriticalEv>
	// is the first element?
	if (s_pManagedTaskListHead == NULL) {
 8019776:	f640 2304 	movw	r3, #2564	; 0xa04
 801977a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801977e:	681b      	ldr	r3, [r3, #0]
 8019780:	2b00      	cmp	r3, #0
 8019782:	d106      	bne.n	8019792 <_ZN12AManagedTask16AddToManagedTaskEPS_+0x2a>
		s_pManagedTaskListHead = this;
 8019784:	f640 2304 	movw	r3, #2564	; 0xa04
 8019788:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801978c:	687a      	ldr	r2, [r7, #4]
 801978e:	601a      	str	r2, [r3, #0]
 8019790:	e00c      	b.n	80197ac <_ZN12AManagedTask16AddToManagedTaskEPS_+0x44>
	}
	else {
		// add the task to the head of the managed task list.
		m_pNextManagedTask = s_pManagedTaskListHead;
 8019792:	f640 2304 	movw	r3, #2564	; 0xa04
 8019796:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801979a:	681a      	ldr	r2, [r3, #0]
 801979c:	687b      	ldr	r3, [r7, #4]
 801979e:	609a      	str	r2, [r3, #8]
		s_pManagedTaskListHead = this;
 80197a0:	f640 2304 	movw	r3, #2564	; 0xa04
 80197a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80197a8:	687a      	ldr	r2, [r7, #4]
 80197aa:	601a      	str	r2, [r3, #0]
	}
	ExitCritical();
 80197ac:	f00b fa00 	bl	8024bb0 <_ZN5CTask12ExitCriticalEv>
}
 80197b0:	f107 0708 	add.w	r7, r7, #8
 80197b4:	46bd      	mov	sp, r7
 80197b6:	bd80      	pop	{r7, pc}

080197b8 <_ZN12AManagedTask21RemoveFromManagedTaskEPS_>:

void AManagedTask::RemoveFromManagedTask(AManagedTask *pTaskToRemove) {
 80197b8:	b580      	push	{r7, lr}
 80197ba:	b084      	sub	sp, #16
 80197bc:	af00      	add	r7, sp, #0
 80197be:	6078      	str	r0, [r7, #4]
 80197c0:	6039      	str	r1, [r7, #0]
	// search for the task to remove in the managed task list
	// is it the first element?
	EnterCritical();
 80197c2:	f00b f9ef 	bl	8024ba4 <_ZN5CTask13EnterCriticalEv>
	if (pTaskToRemove == s_pManagedTaskListHead) {
 80197c6:	f640 2304 	movw	r3, #2564	; 0xa04
 80197ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80197ce:	681b      	ldr	r3, [r3, #0]
 80197d0:	683a      	ldr	r2, [r7, #0]
 80197d2:	429a      	cmp	r2, r3
 80197d4:	d109      	bne.n	80197ea <_ZN12AManagedTask21RemoveFromManagedTaskEPS_+0x32>
		s_pManagedTaskListHead = pTaskToRemove->m_pNextManagedTask;
 80197d6:	683b      	ldr	r3, [r7, #0]
 80197d8:	689a      	ldr	r2, [r3, #8]
 80197da:	f640 2304 	movw	r3, #2564	; 0xa04
 80197de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80197e2:	601a      	str	r2, [r3, #0]
		ExitCritical();
 80197e4:	f00b f9e4 	bl	8024bb0 <_ZN5CTask12ExitCriticalEv>
 80197e8:	e025      	b.n	8019836 <_ZN12AManagedTask21RemoveFromManagedTaskEPS_+0x7e>
	}
	else {
		ExitCritical();
 80197ea:	f00b f9e1 	bl	8024bb0 <_ZN5CTask12ExitCriticalEv>
		CFreeRTOS::SuspendAllTasks();
 80197ee:	f00b f9f1 	bl	8024bd4 <_ZN9CFreeRTOS15SuspendAllTasksEv>
		AManagedTask *pTask = s_pManagedTaskListHead;
 80197f2:	f640 2304 	movw	r3, #2564	; 0xa04
 80197f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80197fa:	681b      	ldr	r3, [r3, #0]
 80197fc:	60fb      	str	r3, [r7, #12]
		while (pTask != NULL && pTask->m_pNextManagedTask != pTaskToRemove) {
 80197fe:	e002      	b.n	8019806 <_ZN12AManagedTask21RemoveFromManagedTaskEPS_+0x4e>
			pTask = pTask->m_pNextManagedTask;
 8019800:	68fb      	ldr	r3, [r7, #12]
 8019802:	689b      	ldr	r3, [r3, #8]
 8019804:	60fb      	str	r3, [r7, #12]
	}
	else {
		ExitCritical();
		CFreeRTOS::SuspendAllTasks();
		AManagedTask *pTask = s_pManagedTaskListHead;
		while (pTask != NULL && pTask->m_pNextManagedTask != pTaskToRemove) {
 8019806:	68fb      	ldr	r3, [r7, #12]
 8019808:	2b00      	cmp	r3, #0
 801980a:	d007      	beq.n	801981c <_ZN12AManagedTask21RemoveFromManagedTaskEPS_+0x64>
 801980c:	68fb      	ldr	r3, [r7, #12]
 801980e:	689a      	ldr	r2, [r3, #8]
 8019810:	683b      	ldr	r3, [r7, #0]
 8019812:	429a      	cmp	r2, r3
 8019814:	d002      	beq.n	801981c <_ZN12AManagedTask21RemoveFromManagedTaskEPS_+0x64>
 8019816:	f04f 0301 	mov.w	r3, #1
 801981a:	e001      	b.n	8019820 <_ZN12AManagedTask21RemoveFromManagedTaskEPS_+0x68>
 801981c:	f04f 0300 	mov.w	r3, #0
 8019820:	2b00      	cmp	r3, #0
 8019822:	d1ed      	bne.n	8019800 <_ZN12AManagedTask21RemoveFromManagedTaskEPS_+0x48>
			pTask = pTask->m_pNextManagedTask;
		}
		if (pTask != NULL) { // Check to be sure that the task is in the list
 8019824:	68fb      	ldr	r3, [r7, #12]
 8019826:	2b00      	cmp	r3, #0
 8019828:	d003      	beq.n	8019832 <_ZN12AManagedTask21RemoveFromManagedTaskEPS_+0x7a>
			// remove the thask from the list
			pTask->m_pNextManagedTask = pTaskToRemove->m_pNextManagedTask;
 801982a:	683b      	ldr	r3, [r7, #0]
 801982c:	689a      	ldr	r2, [r3, #8]
 801982e:	68fb      	ldr	r3, [r7, #12]
 8019830:	609a      	str	r2, [r3, #8]
		}
		CFreeRTOS::ResumeAllTasks();
 8019832:	f00b f9d5 	bl	8024be0 <_ZN9CFreeRTOS14ResumeAllTasksEv>
	}
}
 8019836:	f107 0710 	add.w	r7, r7, #16
 801983a:	46bd      	mov	sp, r7
 801983c:	bd80      	pop	{r7, pc}
 801983e:	bf00      	nop

08019840 <_ZN12AManagedTask27InitHardwareForManagedTasksEv>:

bool AManagedTask::InitHardwareForManagedTasks() {
 8019840:	b590      	push	{r4, r7, lr}
 8019842:	b083      	sub	sp, #12
 8019844:	af00      	add	r7, sp, #0
	bool bRes = true;
 8019846:	f04f 0301 	mov.w	r3, #1
 801984a:	71fb      	strb	r3, [r7, #7]
	for (AManagedTask *pTask=s_pManagedTaskListHead; pTask!=NULL; pTask=pTask->m_pNextManagedTask)
 801984c:	f640 2304 	movw	r3, #2564	; 0xa04
 8019850:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019854:	681b      	ldr	r3, [r3, #0]
 8019856:	603b      	str	r3, [r7, #0]
 8019858:	e011      	b.n	801987e <_ZN12AManagedTask27InitHardwareForManagedTasksEv+0x3e>
		bRes &= pTask->HardwareInit();
 801985a:	79fc      	ldrb	r4, [r7, #7]
 801985c:	683b      	ldr	r3, [r7, #0]
 801985e:	681b      	ldr	r3, [r3, #0]
 8019860:	f103 0314 	add.w	r3, r3, #20
 8019864:	681b      	ldr	r3, [r3, #0]
 8019866:	6838      	ldr	r0, [r7, #0]
 8019868:	4798      	blx	r3
 801986a:	4603      	mov	r3, r0
 801986c:	4023      	ands	r3, r4
 801986e:	2b00      	cmp	r3, #0
 8019870:	bf0c      	ite	eq
 8019872:	2300      	moveq	r3, #0
 8019874:	2301      	movne	r3, #1
 8019876:	71fb      	strb	r3, [r7, #7]
	}
}

bool AManagedTask::InitHardwareForManagedTasks() {
	bool bRes = true;
	for (AManagedTask *pTask=s_pManagedTaskListHead; pTask!=NULL; pTask=pTask->m_pNextManagedTask)
 8019878:	683b      	ldr	r3, [r7, #0]
 801987a:	689b      	ldr	r3, [r3, #8]
 801987c:	603b      	str	r3, [r7, #0]
 801987e:	683b      	ldr	r3, [r7, #0]
 8019880:	2b00      	cmp	r3, #0
 8019882:	bf0c      	ite	eq
 8019884:	2300      	moveq	r3, #0
 8019886:	2301      	movne	r3, #1
 8019888:	b2db      	uxtb	r3, r3
 801988a:	2b00      	cmp	r3, #0
 801988c:	d1e5      	bne.n	801985a <_ZN12AManagedTask27InitHardwareForManagedTasksEv+0x1a>
		bRes &= pTask->HardwareInit();

	return bRes;
 801988e:	79fb      	ldrb	r3, [r7, #7]
}
 8019890:	4618      	mov	r0, r3
 8019892:	f107 070c 	add.w	r7, r7, #12
 8019896:	46bd      	mov	sp, r7
 8019898:	bd90      	pop	{r4, r7, pc}
 801989a:	bf00      	nop

0801989c <_ZN9CFreeRTOSC1Ev>:
 */

#include "CFreeRTOS.h"
#include "AManagedTask.h"

CFreeRTOS::CFreeRTOS() {
 801989c:	b480      	push	{r7}
 801989e:	b083      	sub	sp, #12
 80198a0:	af00      	add	r7, sp, #0
 80198a2:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated constructor stub

}
 80198a4:	687b      	ldr	r3, [r7, #4]
 80198a6:	4618      	mov	r0, r3
 80198a8:	f107 070c 	add.w	r7, r7, #12
 80198ac:	46bd      	mov	sp, r7
 80198ae:	bc80      	pop	{r7}
 80198b0:	4770      	bx	lr
 80198b2:	bf00      	nop

080198b4 <_ZN9CFreeRTOSD1Ev>:

CFreeRTOS::~CFreeRTOS() {
 80198b4:	b480      	push	{r7}
 80198b6:	b083      	sub	sp, #12
 80198b8:	af00      	add	r7, sp, #0
 80198ba:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated destructor stub
}
 80198bc:	687b      	ldr	r3, [r7, #4]
 80198be:	4618      	mov	r0, r3
 80198c0:	f107 070c 	add.w	r7, r7, #12
 80198c4:	46bd      	mov	sp, r7
 80198c6:	bc80      	pop	{r7}
 80198c8:	4770      	bx	lr
 80198ca:	bf00      	nop

080198cc <_ZN9CFreeRTOS27InitHardwareForManagedTasksEv>:

bool CFreeRTOS::InitHardwareForManagedTasks() {
 80198cc:	b580      	push	{r7, lr}
 80198ce:	af00      	add	r7, sp, #0
	return AManagedTask::InitHardwareForManagedTasks();
 80198d0:	f7ff ffb6 	bl	8019840 <_ZN12AManagedTask27InitHardwareForManagedTasksEv>
 80198d4:	4603      	mov	r3, r0
}
 80198d6:	4618      	mov	r0, r3
 80198d8:	bd80      	pop	{r7, pc}
 80198da:	bf00      	nop

080198dc <_ZN5CTaskC1Ev>:

#include "CTask.h"
#include <assert.h>


CTask::CTask() {
 80198dc:	b580      	push	{r7, lr}
 80198de:	b082      	sub	sp, #8
 80198e0:	af00      	add	r7, sp, #0
 80198e2:	6078      	str	r0, [r7, #4]
 80198e4:	687b      	ldr	r3, [r7, #4]
 80198e6:	4618      	mov	r0, r3
 80198e8:	f00b f982 	bl	8024bf0 <_ZN12IFreeRTOSObjC1Ev>
 80198ec:	687b      	ldr	r3, [r7, #4]
 80198ee:	4a06      	ldr	r2, [pc, #24]	; (8019908 <_ZN5CTaskC1Ev+0x2c>)
 80198f0:	601a      	str	r2, [r3, #0]
	m_handleTask = NULL;
 80198f2:	687b      	ldr	r3, [r7, #4]
 80198f4:	f04f 0200 	mov.w	r2, #0
 80198f8:	605a      	str	r2, [r3, #4]
}
 80198fa:	687b      	ldr	r3, [r7, #4]
 80198fc:	4618      	mov	r0, r3
 80198fe:	f107 0708 	add.w	r7, r7, #8
 8019902:	46bd      	mov	sp, r7
 8019904:	bd80      	pop	{r7, pc}
 8019906:	bf00      	nop
 8019908:	08032aa8 	.word	0x08032aa8

0801990c <_ZN5CTaskC1EPv>:

CTask::CTask(xTaskHandle handleTask) {
 801990c:	b580      	push	{r7, lr}
 801990e:	b082      	sub	sp, #8
 8019910:	af00      	add	r7, sp, #0
 8019912:	6078      	str	r0, [r7, #4]
 8019914:	6039      	str	r1, [r7, #0]
 8019916:	687b      	ldr	r3, [r7, #4]
 8019918:	4618      	mov	r0, r3
 801991a:	f00b f969 	bl	8024bf0 <_ZN12IFreeRTOSObjC1Ev>
 801991e:	687b      	ldr	r3, [r7, #4]
 8019920:	4a05      	ldr	r2, [pc, #20]	; (8019938 <_ZN5CTaskC1EPv+0x2c>)
 8019922:	601a      	str	r2, [r3, #0]
	Attach(handleTask);
 8019924:	6878      	ldr	r0, [r7, #4]
 8019926:	6839      	ldr	r1, [r7, #0]
 8019928:	f000 f83a 	bl	80199a0 <_ZN5CTask6AttachEPv>
}
 801992c:	687b      	ldr	r3, [r7, #4]
 801992e:	4618      	mov	r0, r3
 8019930:	f107 0708 	add.w	r7, r7, #8
 8019934:	46bd      	mov	sp, r7
 8019936:	bd80      	pop	{r7, pc}
 8019938:	08032aa8 	.word	0x08032aa8

0801993c <_ZN5CTaskD1Ev>:

CTask::~CTask() {
 801993c:	b580      	push	{r7, lr}
 801993e:	b082      	sub	sp, #8
 8019940:	af00      	add	r7, sp, #0
 8019942:	6078      	str	r0, [r7, #4]
 8019944:	687b      	ldr	r3, [r7, #4]
 8019946:	4a0d      	ldr	r2, [pc, #52]	; (801997c <_ZN5CTaskD1Ev+0x40>)
 8019948:	601a      	str	r2, [r3, #0]
	if (IsValid())
 801994a:	6878      	ldr	r0, [r7, #4]
 801994c:	f00b f8f6 	bl	8024b3c <_ZNK5CTask7IsValidEv>
 8019950:	4603      	mov	r3, r0
 8019952:	2b00      	cmp	r3, #0
 8019954:	d002      	beq.n	801995c <_ZN5CTaskD1Ev+0x20>
		Delete();
 8019956:	6878      	ldr	r0, [r7, #4]
 8019958:	f000 f88a 	bl	8019a70 <_ZN5CTask6DeleteEv>
}
 801995c:	f04f 0300 	mov.w	r3, #0
 8019960:	f003 0301 	and.w	r3, r3, #1
 8019964:	b2db      	uxtb	r3, r3
 8019966:	2b00      	cmp	r3, #0
 8019968:	d002      	beq.n	8019970 <_ZN5CTaskD1Ev+0x34>
 801996a:	6878      	ldr	r0, [r7, #4]
 801996c:	f008 fc32 	bl	80221d4 <_ZdlPv>
 8019970:	687b      	ldr	r3, [r7, #4]
 8019972:	4618      	mov	r0, r3
 8019974:	f107 0708 	add.w	r7, r7, #8
 8019978:	46bd      	mov	sp, r7
 801997a:	bd80      	pop	{r7, pc}
 801997c:	08032aa8 	.word	0x08032aa8

08019980 <_ZN5CTaskD0Ev>:

CTask::CTask(xTaskHandle handleTask) {
	Attach(handleTask);
}

CTask::~CTask() {
 8019980:	b580      	push	{r7, lr}
 8019982:	b082      	sub	sp, #8
 8019984:	af00      	add	r7, sp, #0
 8019986:	6078      	str	r0, [r7, #4]
	if (IsValid())
		Delete();
}
 8019988:	6878      	ldr	r0, [r7, #4]
 801998a:	f7ff ffd7 	bl	801993c <_ZN5CTaskD1Ev>
 801998e:	6878      	ldr	r0, [r7, #4]
 8019990:	f008 fc20 	bl	80221d4 <_ZdlPv>
 8019994:	687b      	ldr	r3, [r7, #4]
 8019996:	4618      	mov	r0, r3
 8019998:	f107 0708 	add.w	r7, r7, #8
 801999c:	46bd      	mov	sp, r7
 801999e:	bd80      	pop	{r7, pc}

080199a0 <_ZN5CTask6AttachEPv>:

void CTask::Attach(xGenericHandle handle) {
 80199a0:	b580      	push	{r7, lr}
 80199a2:	b082      	sub	sp, #8
 80199a4:	af00      	add	r7, sp, #0
 80199a6:	6078      	str	r0, [r7, #4]
 80199a8:	6039      	str	r1, [r7, #0]
	assert(handle != NULL);
 80199aa:	683b      	ldr	r3, [r7, #0]
 80199ac:	2b00      	cmp	r3, #0
 80199ae:	d10f      	bne.n	80199d0 <_ZN5CTask6AttachEPv+0x30>
 80199b0:	f64b 20d0 	movw	r0, #47824	; 0xbad0
 80199b4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80199b8:	f04f 011b 	mov.w	r1, #27
 80199bc:	f642 22c0 	movw	r2, #10944	; 0x2ac0
 80199c0:	f6c0 0203 	movt	r2, #2051	; 0x803
 80199c4:	f64b 23f0 	movw	r3, #47856	; 0xbaf0
 80199c8:	f6c0 0302 	movt	r3, #2050	; 0x802
 80199cc:	f00b f96a 	bl	8024ca4 <__assert_func>

	if (IsValid()) {
 80199d0:	687b      	ldr	r3, [r7, #4]
 80199d2:	681b      	ldr	r3, [r3, #0]
 80199d4:	681b      	ldr	r3, [r3, #0]
 80199d6:	6878      	ldr	r0, [r7, #4]
 80199d8:	4798      	blx	r3
 80199da:	4603      	mov	r3, r0
 80199dc:	2b00      	cmp	r3, #0
 80199de:	d002      	beq.n	80199e6 <_ZN5CTask6AttachEPv+0x46>
		Delete();
 80199e0:	6878      	ldr	r0, [r7, #4]
 80199e2:	f000 f845 	bl	8019a70 <_ZN5CTask6DeleteEv>
	}
	m_handleTask = handle;
 80199e6:	687b      	ldr	r3, [r7, #4]
 80199e8:	683a      	ldr	r2, [r7, #0]
 80199ea:	605a      	str	r2, [r3, #4]
}
 80199ec:	f107 0708 	add.w	r7, r7, #8
 80199f0:	46bd      	mov	sp, r7
 80199f2:	bd80      	pop	{r7, pc}

080199f4 <_ZN5CTask6CreateEPFvPvEPKctS0_m>:

portBASE_TYPE CTask::Create(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority)
{
 80199f4:	b580      	push	{r7, lr}
 80199f6:	b08a      	sub	sp, #40	; 0x28
 80199f8:	af04      	add	r7, sp, #16
 80199fa:	60f8      	str	r0, [r7, #12]
 80199fc:	60b9      	str	r1, [r7, #8]
 80199fe:	607a      	str	r2, [r7, #4]
 8019a00:	807b      	strh	r3, [r7, #2]
	portBASE_TYPE res;
	xTaskHandle handle;
	res = xTaskCreate(pvTaskCode, (const signed char*)pcName, usStackDepth, pvParameters, uxPriority, &handle);
 8019a02:	887b      	ldrh	r3, [r7, #2]
 8019a04:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8019a06:	9200      	str	r2, [sp, #0]
 8019a08:	f107 0210 	add.w	r2, r7, #16
 8019a0c:	9201      	str	r2, [sp, #4]
 8019a0e:	f04f 0200 	mov.w	r2, #0
 8019a12:	9202      	str	r2, [sp, #8]
 8019a14:	f04f 0200 	mov.w	r2, #0
 8019a18:	9203      	str	r2, [sp, #12]
 8019a1a:	68b8      	ldr	r0, [r7, #8]
 8019a1c:	6879      	ldr	r1, [r7, #4]
 8019a1e:	461a      	mov	r2, r3
 8019a20:	6a3b      	ldr	r3, [r7, #32]
 8019a22:	f000 fe1b 	bl	801a65c <xTaskGenericCreate>
 8019a26:	4603      	mov	r3, r0
 8019a28:	617b      	str	r3, [r7, #20]
	if (res == pdTRUE)
 8019a2a:	697b      	ldr	r3, [r7, #20]
 8019a2c:	2b01      	cmp	r3, #1
 8019a2e:	d108      	bne.n	8019a42 <_ZN5CTask6CreateEPFvPvEPKctS0_m+0x4e>
		Attach(handle);
 8019a30:	68fb      	ldr	r3, [r7, #12]
 8019a32:	681b      	ldr	r3, [r3, #0]
 8019a34:	f103 0304 	add.w	r3, r3, #4
 8019a38:	681b      	ldr	r3, [r3, #0]
 8019a3a:	693a      	ldr	r2, [r7, #16]
 8019a3c:	68f8      	ldr	r0, [r7, #12]
 8019a3e:	4611      	mov	r1, r2
 8019a40:	4798      	blx	r3

	return res;
 8019a42:	697b      	ldr	r3, [r7, #20]
}
 8019a44:	4618      	mov	r0, r3
 8019a46:	f107 0718 	add.w	r7, r7, #24
 8019a4a:	46bd      	mov	sp, r7
 8019a4c:	bd80      	pop	{r7, pc}
 8019a4e:	bf00      	nop

08019a50 <_ZN5CTask16CreateRestrictedEP15xTASK_PARAMTERS>:

portBASE_TYPE CTask::CreateRestricted(xTaskParameters *pxTaskDefinition)
{
 8019a50:	b480      	push	{r7}
 8019a52:	b085      	sub	sp, #20
 8019a54:	af00      	add	r7, sp, #0
 8019a56:	6078      	str	r0, [r7, #4]
 8019a58:	6039      	str	r1, [r7, #0]
	portBASE_TYPE res = pdFALSE;
 8019a5a:	f04f 0300 	mov.w	r3, #0
 8019a5e:	60fb      	str	r3, [r7, #12]
	res = xTaskCreateRestricted(pxTaskDefinition, &handle);
	if (res == pdTRUE)
		Attach(handle);
#endif

	return res;
 8019a60:	68fb      	ldr	r3, [r7, #12]
}
 8019a62:	4618      	mov	r0, r3
 8019a64:	f107 0714 	add.w	r7, r7, #20
 8019a68:	46bd      	mov	sp, r7
 8019a6a:	bc80      	pop	{r7}
 8019a6c:	4770      	bx	lr
 8019a6e:	bf00      	nop

08019a70 <_ZN5CTask6DeleteEv>:


void CTask::Delete() {
 8019a70:	b580      	push	{r7, lr}
 8019a72:	b082      	sub	sp, #8
 8019a74:	af00      	add	r7, sp, #0
 8019a76:	6078      	str	r0, [r7, #4]
	if (m_handleTask != NULL) {
 8019a78:	687b      	ldr	r3, [r7, #4]
 8019a7a:	685b      	ldr	r3, [r3, #4]
 8019a7c:	2b00      	cmp	r3, #0
 8019a7e:	d008      	beq.n	8019a92 <_ZN5CTask6DeleteEv+0x22>
#if ( INCLUDE_vTaskDelete == 1 )
		vTaskDelete(m_handleTask);
 8019a80:	687b      	ldr	r3, [r7, #4]
 8019a82:	685b      	ldr	r3, [r3, #4]
 8019a84:	4618      	mov	r0, r3
 8019a86:	f000 febf 	bl	801a808 <vTaskDelete>
#else
		vTaskSuspend(m_handleTask);
#endif
		m_handleTask = NULL;
 8019a8a:	687b      	ldr	r3, [r7, #4]
 8019a8c:	f04f 0200 	mov.w	r2, #0
 8019a90:	605a      	str	r2, [r3, #4]
	}
}
 8019a92:	f107 0708 	add.w	r7, r7, #8
 8019a96:	46bd      	mov	sp, r7
 8019a98:	bd80      	pop	{r7, pc}
 8019a9a:	bf00      	nop

08019a9c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 8019a9c:	b480      	push	{r7}
 8019a9e:	b085      	sub	sp, #20
 8019aa0:	af00      	add	r7, sp, #0
 8019aa2:	60f8      	str	r0, [r7, #12]
 8019aa4:	60b9      	str	r1, [r7, #8]
 8019aa6:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8019aa8:	68fb      	ldr	r3, [r7, #12]
 8019aaa:	f1a3 0304 	sub.w	r3, r3, #4
 8019aae:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8019ab0:	68fb      	ldr	r3, [r7, #12]
 8019ab2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8019ab6:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8019ab8:	68fb      	ldr	r3, [r7, #12]
 8019aba:	f1a3 0304 	sub.w	r3, r3, #4
 8019abe:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8019ac0:	68ba      	ldr	r2, [r7, #8]
 8019ac2:	68fb      	ldr	r3, [r7, #12]
 8019ac4:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8019ac6:	68fb      	ldr	r3, [r7, #12]
 8019ac8:	f1a3 0304 	sub.w	r3, r3, #4
 8019acc:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
 8019ace:	68fb      	ldr	r3, [r7, #12]
 8019ad0:	f04f 0200 	mov.w	r2, #0
 8019ad4:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8019ad6:	68fb      	ldr	r3, [r7, #12]
 8019ad8:	f1a3 0314 	sub.w	r3, r3, #20
 8019adc:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8019ade:	687a      	ldr	r2, [r7, #4]
 8019ae0:	68fb      	ldr	r3, [r7, #12]
 8019ae2:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 9;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8019ae4:	68fb      	ldr	r3, [r7, #12]
 8019ae6:	f1a3 0324 	sub.w	r3, r3, #36	; 0x24
 8019aea:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) portINITIAL_EXC_RETURN;
 8019aec:	68fb      	ldr	r3, [r7, #12]
 8019aee:	f06f 0202 	mvn.w	r2, #2
 8019af2:	601a      	str	r2, [r3, #0]
	return pxTopOfStack;
 8019af4:	68fb      	ldr	r3, [r7, #12]
}
 8019af6:	4618      	mov	r0, r3
 8019af8:	f107 0714 	add.w	r7, r7, #20
 8019afc:	46bd      	mov	sp, r7
 8019afe:	bc80      	pop	{r7}
 8019b00:	4770      	bx	lr
 8019b02:	bf00      	nop

08019b04 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8019b04:	4b06      	ldr	r3, [pc, #24]	; (8019b20 <pxCurrentTCBConst2>)
 8019b06:	6819      	ldr	r1, [r3, #0]
 8019b08:	6808      	ldr	r0, [r1, #0]
 8019b0a:	f850 eb04 	ldr.w	lr, [r0], #4
 8019b0e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8019b12:	f380 8809 	msr	PSP, r0
 8019b16:	f04f 0000 	mov.w	r0, #0
 8019b1a:	f380 8811 	msr	BASEPRI, r0
 8019b1e:	4770      	bx	lr

08019b20 <pxCurrentTCBConst2>:
 8019b20:	20000a08 	.word	0x20000a08

08019b24 <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 8019b24:	486e      	ldr	r0, [pc, #440]	; (8019ce0 <prvSetupTimerInterrupt+0x40>)
 8019b26:	6800      	ldr	r0, [r0, #0]
 8019b28:	6800      	ldr	r0, [r0, #0]
 8019b2a:	f380 8808 	msr	MSP, r0
 8019b2e:	b662      	cpsie	i
 8019b30:	df00      	svc	0
 8019b32:	bf00      	nop

08019b34 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8019b34:	b580      	push	{r7, lr}
 8019b36:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8019b38:	f64e 5320 	movw	r3, #60704	; 0xed20
 8019b3c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8019b40:	f64e 5220 	movw	r2, #60704	; 0xed20
 8019b44:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8019b48:	6812      	ldr	r2, [r2, #0]
 8019b4a:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8019b4e:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8019b50:	f64e 5320 	movw	r3, #60704	; 0xed20
 8019b54:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8019b58:	f64e 5220 	movw	r2, #60704	; 0xed20
 8019b5c:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8019b60:	6812      	ldr	r2, [r2, #0]
 8019b62:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8019b66:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 8019b68:	f000 f89a 	bl	8019ca0 <prvSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8019b6c:	f240 0380 	movw	r3, #128	; 0x80
 8019b70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019b74:	f04f 0200 	mov.w	r2, #0
 8019b78:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8019b7a:	f7ff ffd3 	bl	8019b24 <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
 8019b7e:	f04f 0300 	mov.w	r3, #0
}
 8019b82:	4618      	mov	r0, r3
 8019b84:	bd80      	pop	{r7, pc}
 8019b86:	bf00      	nop

08019b88 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 8019b88:	b480      	push	{r7}
 8019b8a:	af00      	add	r7, sp, #0
	/* It is unlikely that the CM4F port will require this function as there
	is nothing to return to.  */
}
 8019b8c:	46bd      	mov	sp, r7
 8019b8e:	bc80      	pop	{r7}
 8019b90:	4770      	bx	lr
 8019b92:	bf00      	nop

08019b94 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 8019b94:	b480      	push	{r7}
 8019b96:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8019b98:	f64e 5304 	movw	r3, #60676	; 0xed04
 8019b9c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8019ba0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8019ba4:	601a      	str	r2, [r3, #0]
}
 8019ba6:	46bd      	mov	sp, r7
 8019ba8:	bc80      	pop	{r7}
 8019baa:	4770      	bx	lr

08019bac <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8019bac:	b480      	push	{r7}
 8019bae:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 8019bb0:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8019bb4:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8019bb8:	f240 0380 	movw	r3, #128	; 0x80
 8019bbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019bc0:	681b      	ldr	r3, [r3, #0]
 8019bc2:	f103 0201 	add.w	r2, r3, #1
 8019bc6:	f240 0380 	movw	r3, #128	; 0x80
 8019bca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019bce:	601a      	str	r2, [r3, #0]
}
 8019bd0:	46bd      	mov	sp, r7
 8019bd2:	bc80      	pop	{r7}
 8019bd4:	4770      	bx	lr
 8019bd6:	bf00      	nop

08019bd8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8019bd8:	b480      	push	{r7}
 8019bda:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
 8019bdc:	f240 0380 	movw	r3, #128	; 0x80
 8019be0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019be4:	681b      	ldr	r3, [r3, #0]
 8019be6:	f103 32ff 	add.w	r2, r3, #4294967295
 8019bea:	f240 0380 	movw	r3, #128	; 0x80
 8019bee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019bf2:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
 8019bf4:	f240 0380 	movw	r3, #128	; 0x80
 8019bf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019bfc:	681b      	ldr	r3, [r3, #0]
 8019bfe:	2b00      	cmp	r3, #0
 8019c00:	d103      	bne.n	8019c0a <vPortExitCritical+0x32>
	{
		portENABLE_INTERRUPTS();
 8019c02:	f04f 0000 	mov.w	r0, #0
 8019c06:	f380 8811 	msr	BASEPRI, r0
	}
}
 8019c0a:	46bd      	mov	sp, r7
 8019c0c:	bc80      	pop	{r7}
 8019c0e:	4770      	bx	lr

08019c10 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8019c10:	f3ef 8009 	mrs	r0, PSP
 8019c14:	4b13      	ldr	r3, [pc, #76]	; (8019c64 <pxCurrentTCBConst>)
 8019c16:	681a      	ldr	r2, [r3, #0]
 8019c18:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8019c1c:	f01e 0f10 	tst.w	lr, #16
 8019c20:	bf08      	it	eq
 8019c22:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8019c26:	f840 ed04 	str.w	lr, [r0, #-4]!
 8019c2a:	6010      	str	r0, [r2, #0]
 8019c2c:	e92d 4008 	stmdb	sp!, {r3, lr}
 8019c30:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8019c34:	f380 8811 	msr	BASEPRI, r0
 8019c38:	f001 fbfc 	bl	801b434 <vTaskSwitchContext>
 8019c3c:	f04f 0000 	mov.w	r0, #0
 8019c40:	f380 8811 	msr	BASEPRI, r0
 8019c44:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8019c48:	6819      	ldr	r1, [r3, #0]
 8019c4a:	6808      	ldr	r0, [r1, #0]
 8019c4c:	f850 eb04 	ldr.w	lr, [r0], #4
 8019c50:	f01e 0f10 	tst.w	lr, #16
 8019c54:	bf08      	it	eq
 8019c56:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8019c5a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8019c5e:	f380 8809 	msr	PSP, r0
 8019c62:	4770      	bx	lr

08019c64 <pxCurrentTCBConst>:
 8019c64:	20000a08 	.word	0x20000a08

08019c68 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8019c68:	b580      	push	{r7, lr}
 8019c6a:	b082      	sub	sp, #8
 8019c6c:	af00      	add	r7, sp, #0
    unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8019c6e:	f64e 5304 	movw	r3, #60676	; 0xed04
 8019c72:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8019c76:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8019c7a:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8019c7c:	f04f 0300 	mov.w	r3, #0
 8019c80:	607b      	str	r3, [r7, #4]
 8019c82:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8019c86:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 8019c8a:	f001 fa97 	bl	801b1bc <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8019c8e:	f04f 0000 	mov.w	r0, #0
 8019c92:	f380 8811 	msr	BASEPRI, r0
}
 8019c96:	f107 0708 	add.w	r7, r7, #8
 8019c9a:	46bd      	mov	sp, r7
 8019c9c:	bd80      	pop	{r7, pc}
 8019c9e:	bf00      	nop

08019ca0 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 8019ca0:	b480      	push	{r7}
 8019ca2:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8019ca4:	f24e 0314 	movw	r3, #57364	; 0xe014
 8019ca8:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8019cac:	f240 02d0 	movw	r2, #208	; 0xd0
 8019cb0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8019cb4:	6811      	ldr	r1, [r2, #0]
 8019cb6:	f248 521f 	movw	r2, #34079	; 0x851f
 8019cba:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
 8019cbe:	fba2 0201 	umull	r0, r2, r2, r1
 8019cc2:	ea4f 1252 	mov.w	r2, r2, lsr #5
 8019cc6:	f102 32ff 	add.w	r2, r2, #4294967295
 8019cca:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8019ccc:	f24e 0310 	movw	r3, #57360	; 0xe010
 8019cd0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8019cd4:	f04f 0207 	mov.w	r2, #7
 8019cd8:	601a      	str	r2, [r3, #0]
}
 8019cda:	46bd      	mov	sp, r7
 8019cdc:	bc80      	pop	{r7}
 8019cde:	4770      	bx	lr
 8019ce0:	e000ed08 	.word	0xe000ed08

08019ce4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 8019ce4:	b480      	push	{r7}
 8019ce6:	b083      	sub	sp, #12
 8019ce8:	af00      	add	r7, sp, #0
 8019cea:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8019cec:	687b      	ldr	r3, [r7, #4]
 8019cee:	f103 0208 	add.w	r2, r3, #8
 8019cf2:	687b      	ldr	r3, [r7, #4]
 8019cf4:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8019cf6:	687b      	ldr	r3, [r7, #4]
 8019cf8:	f04f 32ff 	mov.w	r2, #4294967295
 8019cfc:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8019cfe:	687b      	ldr	r3, [r7, #4]
 8019d00:	f103 0208 	add.w	r2, r3, #8
 8019d04:	687b      	ldr	r3, [r7, #4]
 8019d06:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8019d08:	687b      	ldr	r3, [r7, #4]
 8019d0a:	f103 0208 	add.w	r2, r3, #8
 8019d0e:	687b      	ldr	r3, [r7, #4]
 8019d10:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8019d12:	687b      	ldr	r3, [r7, #4]
 8019d14:	f04f 0200 	mov.w	r2, #0
 8019d18:	601a      	str	r2, [r3, #0]
}
 8019d1a:	f107 070c 	add.w	r7, r7, #12
 8019d1e:	46bd      	mov	sp, r7
 8019d20:	bc80      	pop	{r7}
 8019d22:	4770      	bx	lr

08019d24 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 8019d24:	b480      	push	{r7}
 8019d26:	b083      	sub	sp, #12
 8019d28:	af00      	add	r7, sp, #0
 8019d2a:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8019d2c:	687b      	ldr	r3, [r7, #4]
 8019d2e:	f04f 0200 	mov.w	r2, #0
 8019d32:	611a      	str	r2, [r3, #16]
}
 8019d34:	f107 070c 	add.w	r7, r7, #12
 8019d38:	46bd      	mov	sp, r7
 8019d3a:	bc80      	pop	{r7}
 8019d3c:	4770      	bx	lr
 8019d3e:	bf00      	nop

08019d40 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 8019d40:	b480      	push	{r7}
 8019d42:	b085      	sub	sp, #20
 8019d44:	af00      	add	r7, sp, #0
 8019d46:	6078      	str	r0, [r7, #4]
 8019d48:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8019d4a:	687b      	ldr	r3, [r7, #4]
 8019d4c:	685b      	ldr	r3, [r3, #4]
 8019d4e:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8019d50:	68fb      	ldr	r3, [r7, #12]
 8019d52:	685b      	ldr	r3, [r3, #4]
 8019d54:	461a      	mov	r2, r3
 8019d56:	683b      	ldr	r3, [r7, #0]
 8019d58:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8019d5a:	687b      	ldr	r3, [r7, #4]
 8019d5c:	685a      	ldr	r2, [r3, #4]
 8019d5e:	683b      	ldr	r3, [r7, #0]
 8019d60:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8019d62:	68fb      	ldr	r3, [r7, #12]
 8019d64:	685b      	ldr	r3, [r3, #4]
 8019d66:	683a      	ldr	r2, [r7, #0]
 8019d68:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8019d6a:	68fb      	ldr	r3, [r7, #12]
 8019d6c:	683a      	ldr	r2, [r7, #0]
 8019d6e:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8019d70:	687b      	ldr	r3, [r7, #4]
 8019d72:	683a      	ldr	r2, [r7, #0]
 8019d74:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8019d76:	683b      	ldr	r3, [r7, #0]
 8019d78:	687a      	ldr	r2, [r7, #4]
 8019d7a:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8019d7c:	687b      	ldr	r3, [r7, #4]
 8019d7e:	681b      	ldr	r3, [r3, #0]
 8019d80:	f103 0201 	add.w	r2, r3, #1
 8019d84:	687b      	ldr	r3, [r7, #4]
 8019d86:	601a      	str	r2, [r3, #0]
}
 8019d88:	f107 0714 	add.w	r7, r7, #20
 8019d8c:	46bd      	mov	sp, r7
 8019d8e:	bc80      	pop	{r7}
 8019d90:	4770      	bx	lr
 8019d92:	bf00      	nop

08019d94 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 8019d94:	b480      	push	{r7}
 8019d96:	b085      	sub	sp, #20
 8019d98:	af00      	add	r7, sp, #0
 8019d9a:	6078      	str	r0, [r7, #4]
 8019d9c:	6039      	str	r1, [r7, #0]
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8019d9e:	683b      	ldr	r3, [r7, #0]
 8019da0:	681b      	ldr	r3, [r3, #0]
 8019da2:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8019da4:	68bb      	ldr	r3, [r7, #8]
 8019da6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8019daa:	d103      	bne.n	8019db4 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8019dac:	687b      	ldr	r3, [r7, #4]
 8019dae:	691b      	ldr	r3, [r3, #16]
 8019db0:	60fb      	str	r3, [r7, #12]
 8019db2:	e00e      	b.n	8019dd2 <vListInsert+0x3e>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8019db4:	687b      	ldr	r3, [r7, #4]
 8019db6:	f103 0308 	add.w	r3, r3, #8
 8019dba:	60fb      	str	r3, [r7, #12]
 8019dbc:	e002      	b.n	8019dc4 <vListInsert+0x30>
 8019dbe:	68fb      	ldr	r3, [r7, #12]
 8019dc0:	685b      	ldr	r3, [r3, #4]
 8019dc2:	60fb      	str	r3, [r7, #12]
 8019dc4:	68fb      	ldr	r3, [r7, #12]
 8019dc6:	685b      	ldr	r3, [r3, #4]
 8019dc8:	681b      	ldr	r3, [r3, #0]
 8019dca:	461a      	mov	r2, r3
 8019dcc:	68bb      	ldr	r3, [r7, #8]
 8019dce:	429a      	cmp	r2, r3
 8019dd0:	d9f5      	bls.n	8019dbe <vListInsert+0x2a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8019dd2:	68fb      	ldr	r3, [r7, #12]
 8019dd4:	685b      	ldr	r3, [r3, #4]
 8019dd6:	461a      	mov	r2, r3
 8019dd8:	683b      	ldr	r3, [r7, #0]
 8019dda:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8019ddc:	683b      	ldr	r3, [r7, #0]
 8019dde:	685b      	ldr	r3, [r3, #4]
 8019de0:	683a      	ldr	r2, [r7, #0]
 8019de2:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8019de4:	683b      	ldr	r3, [r7, #0]
 8019de6:	68fa      	ldr	r2, [r7, #12]
 8019de8:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8019dea:	68fb      	ldr	r3, [r7, #12]
 8019dec:	683a      	ldr	r2, [r7, #0]
 8019dee:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8019df0:	683b      	ldr	r3, [r7, #0]
 8019df2:	687a      	ldr	r2, [r7, #4]
 8019df4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8019df6:	687b      	ldr	r3, [r7, #4]
 8019df8:	681b      	ldr	r3, [r3, #0]
 8019dfa:	f103 0201 	add.w	r2, r3, #1
 8019dfe:	687b      	ldr	r3, [r7, #4]
 8019e00:	601a      	str	r2, [r3, #0]
}
 8019e02:	f107 0714 	add.w	r7, r7, #20
 8019e06:	46bd      	mov	sp, r7
 8019e08:	bc80      	pop	{r7}
 8019e0a:	4770      	bx	lr

08019e0c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 8019e0c:	b480      	push	{r7}
 8019e0e:	b085      	sub	sp, #20
 8019e10:	af00      	add	r7, sp, #0
 8019e12:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8019e14:	687b      	ldr	r3, [r7, #4]
 8019e16:	685b      	ldr	r3, [r3, #4]
 8019e18:	687a      	ldr	r2, [r7, #4]
 8019e1a:	6892      	ldr	r2, [r2, #8]
 8019e1c:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8019e1e:	687b      	ldr	r3, [r7, #4]
 8019e20:	689b      	ldr	r3, [r3, #8]
 8019e22:	687a      	ldr	r2, [r7, #4]
 8019e24:	6852      	ldr	r2, [r2, #4]
 8019e26:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8019e28:	687b      	ldr	r3, [r7, #4]
 8019e2a:	691b      	ldr	r3, [r3, #16]
 8019e2c:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8019e2e:	68fb      	ldr	r3, [r7, #12]
 8019e30:	685a      	ldr	r2, [r3, #4]
 8019e32:	687b      	ldr	r3, [r7, #4]
 8019e34:	429a      	cmp	r2, r3
 8019e36:	d103      	bne.n	8019e40 <vListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8019e38:	687b      	ldr	r3, [r7, #4]
 8019e3a:	689a      	ldr	r2, [r3, #8]
 8019e3c:	68fb      	ldr	r3, [r7, #12]
 8019e3e:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8019e40:	687b      	ldr	r3, [r7, #4]
 8019e42:	f04f 0200 	mov.w	r2, #0
 8019e46:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8019e48:	68fb      	ldr	r3, [r7, #12]
 8019e4a:	681b      	ldr	r3, [r3, #0]
 8019e4c:	f103 32ff 	add.w	r2, r3, #4294967295
 8019e50:	68fb      	ldr	r3, [r7, #12]
 8019e52:	601a      	str	r2, [r3, #0]
}
 8019e54:	f107 0714 	add.w	r7, r7, #20
 8019e58:	46bd      	mov	sp, r7
 8019e5a:	bc80      	pop	{r7}
 8019e5c:	4770      	bx	lr
 8019e5e:	bf00      	nop

08019e60 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
 8019e60:	b580      	push	{r7, lr}
 8019e62:	b086      	sub	sp, #24
 8019e64:	af00      	add	r7, sp, #0
 8019e66:	6078      	str	r0, [r7, #4]
 8019e68:	6039      	str	r1, [r7, #0]
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
 8019e6a:	f04f 0300 	mov.w	r3, #0
 8019e6e:	617b      	str	r3, [r7, #20]

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 8019e70:	687b      	ldr	r3, [r7, #4]
 8019e72:	2b00      	cmp	r3, #0
 8019e74:	d056      	beq.n	8019f24 <xQueueCreate+0xc4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8019e76:	f04f 004c 	mov.w	r0, #76	; 0x4c
 8019e7a:	f00a ff9d 	bl	8024db8 <malloc>
 8019e7e:	4603      	mov	r3, r0
 8019e80:	613b      	str	r3, [r7, #16]
		if( pxNewQueue != NULL )
 8019e82:	693b      	ldr	r3, [r7, #16]
 8019e84:	2b00      	cmp	r3, #0
 8019e86:	d04d      	beq.n	8019f24 <xQueueCreate+0xc4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 8019e88:	687b      	ldr	r3, [r7, #4]
 8019e8a:	683a      	ldr	r2, [r7, #0]
 8019e8c:	fb02 f303 	mul.w	r3, r2, r3
 8019e90:	f103 0301 	add.w	r3, r3, #1
 8019e94:	60fb      	str	r3, [r7, #12]

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 8019e96:	68f8      	ldr	r0, [r7, #12]
 8019e98:	f00a ff8e 	bl	8024db8 <malloc>
 8019e9c:	4603      	mov	r3, r0
 8019e9e:	461a      	mov	r2, r3
 8019ea0:	693b      	ldr	r3, [r7, #16]
 8019ea2:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
 8019ea4:	693b      	ldr	r3, [r7, #16]
 8019ea6:	681b      	ldr	r3, [r3, #0]
 8019ea8:	2b00      	cmp	r3, #0
 8019eaa:	d038      	beq.n	8019f1e <xQueueCreate+0xbe>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 8019eac:	693b      	ldr	r3, [r7, #16]
 8019eae:	681a      	ldr	r2, [r3, #0]
 8019eb0:	687b      	ldr	r3, [r7, #4]
 8019eb2:	6839      	ldr	r1, [r7, #0]
 8019eb4:	fb01 f303 	mul.w	r3, r1, r3
 8019eb8:	18d2      	adds	r2, r2, r3
 8019eba:	693b      	ldr	r3, [r7, #16]
 8019ebc:	605a      	str	r2, [r3, #4]
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8019ebe:	693b      	ldr	r3, [r7, #16]
 8019ec0:	f04f 0200 	mov.w	r2, #0
 8019ec4:	639a      	str	r2, [r3, #56]	; 0x38
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 8019ec6:	693b      	ldr	r3, [r7, #16]
 8019ec8:	681a      	ldr	r2, [r3, #0]
 8019eca:	693b      	ldr	r3, [r7, #16]
 8019ecc:	609a      	str	r2, [r3, #8]
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
 8019ece:	693b      	ldr	r3, [r7, #16]
 8019ed0:	681a      	ldr	r2, [r3, #0]
 8019ed2:	687b      	ldr	r3, [r7, #4]
 8019ed4:	f103 33ff 	add.w	r3, r3, #4294967295
 8019ed8:	6839      	ldr	r1, [r7, #0]
 8019eda:	fb01 f303 	mul.w	r3, r1, r3
 8019ede:	18d2      	adds	r2, r2, r3
 8019ee0:	693b      	ldr	r3, [r7, #16]
 8019ee2:	60da      	str	r2, [r3, #12]
				pxNewQueue->uxLength = uxQueueLength;
 8019ee4:	693b      	ldr	r3, [r7, #16]
 8019ee6:	687a      	ldr	r2, [r7, #4]
 8019ee8:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 8019eea:	693b      	ldr	r3, [r7, #16]
 8019eec:	683a      	ldr	r2, [r7, #0]
 8019eee:	641a      	str	r2, [r3, #64]	; 0x40
				pxNewQueue->xRxLock = queueUNLOCKED;
 8019ef0:	693b      	ldr	r3, [r7, #16]
 8019ef2:	f04f 32ff 	mov.w	r2, #4294967295
 8019ef6:	645a      	str	r2, [r3, #68]	; 0x44
				pxNewQueue->xTxLock = queueUNLOCKED;
 8019ef8:	693b      	ldr	r3, [r7, #16]
 8019efa:	f04f 32ff 	mov.w	r2, #4294967295
 8019efe:	649a      	str	r2, [r3, #72]	; 0x48

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 8019f00:	693b      	ldr	r3, [r7, #16]
 8019f02:	f103 0310 	add.w	r3, r3, #16
 8019f06:	4618      	mov	r0, r3
 8019f08:	f7ff feec 	bl	8019ce4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 8019f0c:	693b      	ldr	r3, [r7, #16]
 8019f0e:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8019f12:	4618      	mov	r0, r3
 8019f14:	f7ff fee6 	bl	8019ce4 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
 8019f18:	693b      	ldr	r3, [r7, #16]
 8019f1a:	617b      	str	r3, [r7, #20]
 8019f1c:	e002      	b.n	8019f24 <xQueueCreate+0xc4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
 8019f1e:	6938      	ldr	r0, [r7, #16]
 8019f20:	f00a ff52 	bl	8024dc8 <free>
		}
	}

	configASSERT( xReturn );

	return xReturn;
 8019f24:	697b      	ldr	r3, [r7, #20]
}
 8019f26:	4618      	mov	r0, r3
 8019f28:	f107 0718 	add.w	r7, r7, #24
 8019f2c:	46bd      	mov	sp, r7
 8019f2e:	bd80      	pop	{r7, pc}

08019f30 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
 8019f30:	b580      	push	{r7, lr}
 8019f32:	b082      	sub	sp, #8
 8019f34:	af00      	add	r7, sp, #0
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8019f36:	f04f 004c 	mov.w	r0, #76	; 0x4c
 8019f3a:	f00a ff3d 	bl	8024db8 <malloc>
 8019f3e:	4603      	mov	r3, r0
 8019f40:	607b      	str	r3, [r7, #4]
		if( pxNewQueue != NULL )
 8019f42:	687b      	ldr	r3, [r7, #4]
 8019f44:	2b00      	cmp	r3, #0
 8019f46:	d038      	beq.n	8019fba <xQueueCreateMutex+0x8a>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8019f48:	687b      	ldr	r3, [r7, #4]
 8019f4a:	f04f 0200 	mov.w	r2, #0
 8019f4e:	605a      	str	r2, [r3, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8019f50:	687b      	ldr	r3, [r7, #4]
 8019f52:	f04f 0200 	mov.w	r2, #0
 8019f56:	601a      	str	r2, [r3, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
 8019f58:	687b      	ldr	r3, [r7, #4]
 8019f5a:	f04f 0200 	mov.w	r2, #0
 8019f5e:	609a      	str	r2, [r3, #8]
			pxNewQueue->pcReadFrom = NULL;
 8019f60:	687b      	ldr	r3, [r7, #4]
 8019f62:	f04f 0200 	mov.w	r2, #0
 8019f66:	60da      	str	r2, [r3, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8019f68:	687b      	ldr	r3, [r7, #4]
 8019f6a:	f04f 0200 	mov.w	r2, #0
 8019f6e:	639a      	str	r2, [r3, #56]	; 0x38
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 8019f70:	687b      	ldr	r3, [r7, #4]
 8019f72:	f04f 0201 	mov.w	r2, #1
 8019f76:	63da      	str	r2, [r3, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 8019f78:	687b      	ldr	r3, [r7, #4]
 8019f7a:	f04f 0200 	mov.w	r2, #0
 8019f7e:	641a      	str	r2, [r3, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
 8019f80:	687b      	ldr	r3, [r7, #4]
 8019f82:	f04f 32ff 	mov.w	r2, #4294967295
 8019f86:	645a      	str	r2, [r3, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
 8019f88:	687b      	ldr	r3, [r7, #4]
 8019f8a:	f04f 32ff 	mov.w	r2, #4294967295
 8019f8e:	649a      	str	r2, [r3, #72]	; 0x48

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 8019f90:	687b      	ldr	r3, [r7, #4]
 8019f92:	f103 0310 	add.w	r3, r3, #16
 8019f96:	4618      	mov	r0, r3
 8019f98:	f7ff fea4 	bl	8019ce4 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 8019f9c:	687b      	ldr	r3, [r7, #4]
 8019f9e:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8019fa2:	4618      	mov	r0, r3
 8019fa4:	f7ff fe9e 	bl	8019ce4 <vListInitialise>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 8019fa8:	6878      	ldr	r0, [r7, #4]
 8019faa:	f04f 0100 	mov.w	r1, #0
 8019fae:	f04f 0200 	mov.w	r2, #0
 8019fb2:	f04f 0300 	mov.w	r3, #0
 8019fb6:	f000 f807 	bl	8019fc8 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
 8019fba:	687b      	ldr	r3, [r7, #4]
	}
 8019fbc:	4618      	mov	r0, r3
 8019fbe:	f107 0708 	add.w	r7, r7, #8
 8019fc2:	46bd      	mov	sp, r7
 8019fc4:	bd80      	pop	{r7, pc}
 8019fc6:	bf00      	nop

08019fc8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 8019fc8:	b580      	push	{r7, lr}
 8019fca:	b088      	sub	sp, #32
 8019fcc:	af00      	add	r7, sp, #0
 8019fce:	60f8      	str	r0, [r7, #12]
 8019fd0:	60b9      	str	r1, [r7, #8]
 8019fd2:	607a      	str	r2, [r7, #4]
 8019fd4:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 8019fd6:	f04f 0300 	mov.w	r3, #0
 8019fda:	61fb      	str	r3, [r7, #28]
 8019fdc:	e000      	b.n	8019fe0 <xQueueGenericSend+0x18>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 8019fde:	bf00      	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8019fe0:	f7ff fde4 	bl	8019bac <vPortEnterCritical>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8019fe4:	68fb      	ldr	r3, [r7, #12]
 8019fe6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8019fe8:	461a      	mov	r2, r3
 8019fea:	68fb      	ldr	r3, [r7, #12]
 8019fec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8019fee:	429a      	cmp	r2, r3
 8019ff0:	d218      	bcs.n	801a024 <xQueueGenericSend+0x5c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8019ff2:	68f8      	ldr	r0, [r7, #12]
 8019ff4:	68b9      	ldr	r1, [r7, #8]
 8019ff6:	683a      	ldr	r2, [r7, #0]
 8019ff8:	f000 f9fe 	bl	801a3f8 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8019ffc:	68fb      	ldr	r3, [r7, #12]
 8019ffe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a000:	2b00      	cmp	r3, #0
 801a002:	d00a      	beq.n	801a01a <xQueueGenericSend+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 801a004:	68fb      	ldr	r3, [r7, #12]
 801a006:	f103 0324 	add.w	r3, r3, #36	; 0x24
 801a00a:	4618      	mov	r0, r3
 801a00c:	f001 faee 	bl	801b5ec <xTaskRemoveFromEventList>
 801a010:	4603      	mov	r3, r0
 801a012:	2b01      	cmp	r3, #1
 801a014:	d101      	bne.n	801a01a <xQueueGenericSend+0x52>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
 801a016:	f7ff fdbd 	bl	8019b94 <vPortYieldFromISR>
					}
				}

				taskEXIT_CRITICAL();
 801a01a:	f7ff fddd 	bl	8019bd8 <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 801a01e:	f04f 0301 	mov.w	r3, #1
 801a022:	e05d      	b.n	801a0e0 <xQueueGenericSend+0x118>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 801a024:	687b      	ldr	r3, [r7, #4]
 801a026:	2b00      	cmp	r3, #0
 801a028:	d104      	bne.n	801a034 <xQueueGenericSend+0x6c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 801a02a:	f7ff fdd5 	bl	8019bd8 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 801a02e:	f04f 0300 	mov.w	r3, #0
 801a032:	e055      	b.n	801a0e0 <xQueueGenericSend+0x118>
				}
				else if( xEntryTimeSet == pdFALSE )
 801a034:	69fb      	ldr	r3, [r7, #28]
 801a036:	2b00      	cmp	r3, #0
 801a038:	d107      	bne.n	801a04a <xQueueGenericSend+0x82>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 801a03a:	f107 0314 	add.w	r3, r7, #20
 801a03e:	4618      	mov	r0, r3
 801a040:	f001 fb36 	bl	801b6b0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 801a044:	f04f 0301 	mov.w	r3, #1
 801a048:	61fb      	str	r3, [r7, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 801a04a:	f7ff fdc5 	bl	8019bd8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 801a04e:	f000 ff01 	bl	801ae54 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 801a052:	f7ff fdab 	bl	8019bac <vPortEnterCritical>
 801a056:	68fb      	ldr	r3, [r7, #12]
 801a058:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801a05a:	f1b3 3fff 	cmp.w	r3, #4294967295
 801a05e:	d103      	bne.n	801a068 <xQueueGenericSend+0xa0>
 801a060:	68fb      	ldr	r3, [r7, #12]
 801a062:	f04f 0200 	mov.w	r2, #0
 801a066:	645a      	str	r2, [r3, #68]	; 0x44
 801a068:	68fb      	ldr	r3, [r7, #12]
 801a06a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a06c:	f1b3 3fff 	cmp.w	r3, #4294967295
 801a070:	d103      	bne.n	801a07a <xQueueGenericSend+0xb2>
 801a072:	68fb      	ldr	r3, [r7, #12]
 801a074:	f04f 0200 	mov.w	r2, #0
 801a078:	649a      	str	r2, [r3, #72]	; 0x48
 801a07a:	f7ff fdad 	bl	8019bd8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 801a07e:	f107 0214 	add.w	r2, r7, #20
 801a082:	f107 0304 	add.w	r3, r7, #4
 801a086:	4610      	mov	r0, r2
 801a088:	4619      	mov	r1, r3
 801a08a:	f001 fb29 	bl	801b6e0 <xTaskCheckForTimeOut>
 801a08e:	4603      	mov	r3, r0
 801a090:	2b00      	cmp	r3, #0
 801a092:	d11e      	bne.n	801a0d2 <xQueueGenericSend+0x10a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 801a094:	68f8      	ldr	r0, [r7, #12]
 801a096:	f000 fab3 	bl	801a600 <prvIsQueueFull>
 801a09a:	4603      	mov	r3, r0
 801a09c:	2b00      	cmp	r3, #0
 801a09e:	d012      	beq.n	801a0c6 <xQueueGenericSend+0xfe>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 801a0a0:	68fb      	ldr	r3, [r7, #12]
 801a0a2:	f103 0210 	add.w	r2, r3, #16
 801a0a6:	687b      	ldr	r3, [r7, #4]
 801a0a8:	4610      	mov	r0, r2
 801a0aa:	4619      	mov	r1, r3
 801a0ac:	f001 fa62 	bl	801b574 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 801a0b0:	68f8      	ldr	r0, [r7, #12]
 801a0b2:	f000 fa2d 	bl	801a510 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 801a0b6:	f000 fedf 	bl	801ae78 <xTaskResumeAll>
 801a0ba:	4603      	mov	r3, r0
 801a0bc:	2b00      	cmp	r3, #0
 801a0be:	d18e      	bne.n	8019fde <xQueueGenericSend+0x16>
				{
					portYIELD_WITHIN_API();
 801a0c0:	f7ff fd68 	bl	8019b94 <vPortYieldFromISR>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 801a0c4:	e78b      	b.n	8019fde <xQueueGenericSend+0x16>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 801a0c6:	68f8      	ldr	r0, [r7, #12]
 801a0c8:	f000 fa22 	bl	801a510 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 801a0cc:	f000 fed4 	bl	801ae78 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 801a0d0:	e785      	b.n	8019fde <xQueueGenericSend+0x16>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 801a0d2:	68f8      	ldr	r0, [r7, #12]
 801a0d4:	f000 fa1c 	bl	801a510 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 801a0d8:	f000 fece 	bl	801ae78 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 801a0dc:	f04f 0300 	mov.w	r3, #0
		}
	}
}
 801a0e0:	4618      	mov	r0, r3
 801a0e2:	f107 0720 	add.w	r7, r7, #32
 801a0e6:	46bd      	mov	sp, r7
 801a0e8:	bd80      	pop	{r7, pc}
 801a0ea:	bf00      	nop

0801a0ec <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
 801a0ec:	b580      	push	{r7, lr}
 801a0ee:	b086      	sub	sp, #24
 801a0f0:	af00      	add	r7, sp, #0
 801a0f2:	60f8      	str	r0, [r7, #12]
 801a0f4:	60b9      	str	r1, [r7, #8]
 801a0f6:	607a      	str	r2, [r7, #4]
 801a0f8:	603b      	str	r3, [r7, #0]
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 801a0fa:	f04f 0300 	mov.w	r3, #0
 801a0fe:	613b      	str	r3, [r7, #16]
 801a100:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 801a104:	f380 8811 	msr	BASEPRI, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 801a108:	68fb      	ldr	r3, [r7, #12]
 801a10a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a10c:	461a      	mov	r2, r3
 801a10e:	68fb      	ldr	r3, [r7, #12]
 801a110:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801a112:	429a      	cmp	r2, r3
 801a114:	d225      	bcs.n	801a162 <xQueueGenericSendFromISR+0x76>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 801a116:	68f8      	ldr	r0, [r7, #12]
 801a118:	68b9      	ldr	r1, [r7, #8]
 801a11a:	683a      	ldr	r2, [r7, #0]
 801a11c:	f000 f96c 	bl	801a3f8 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 801a120:	68fb      	ldr	r3, [r7, #12]
 801a122:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a124:	f1b3 3fff 	cmp.w	r3, #4294967295
 801a128:	d111      	bne.n	801a14e <xQueueGenericSendFromISR+0x62>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801a12a:	68fb      	ldr	r3, [r7, #12]
 801a12c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a12e:	2b00      	cmp	r3, #0
 801a130:	d013      	beq.n	801a15a <xQueueGenericSendFromISR+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801a132:	68fb      	ldr	r3, [r7, #12]
 801a134:	f103 0324 	add.w	r3, r3, #36	; 0x24
 801a138:	4618      	mov	r0, r3
 801a13a:	f001 fa57 	bl	801b5ec <xTaskRemoveFromEventList>
 801a13e:	4603      	mov	r3, r0
 801a140:	2b00      	cmp	r3, #0
 801a142:	d00a      	beq.n	801a15a <xQueueGenericSendFromISR+0x6e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
 801a144:	687b      	ldr	r3, [r7, #4]
 801a146:	f04f 0201 	mov.w	r2, #1
 801a14a:	601a      	str	r2, [r3, #0]
 801a14c:	e005      	b.n	801a15a <xQueueGenericSendFromISR+0x6e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 801a14e:	68fb      	ldr	r3, [r7, #12]
 801a150:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a152:	f103 0201 	add.w	r2, r3, #1
 801a156:	68fb      	ldr	r3, [r7, #12]
 801a158:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
 801a15a:	f04f 0301 	mov.w	r3, #1
 801a15e:	617b      	str	r3, [r7, #20]
 801a160:	e002      	b.n	801a168 <xQueueGenericSendFromISR+0x7c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 801a162:	f04f 0300 	mov.w	r3, #0
 801a166:	617b      	str	r3, [r7, #20]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 801a168:	f04f 0000 	mov.w	r0, #0
 801a16c:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
 801a170:	697b      	ldr	r3, [r7, #20]
}
 801a172:	4618      	mov	r0, r3
 801a174:	f107 0718 	add.w	r7, r7, #24
 801a178:	46bd      	mov	sp, r7
 801a17a:	bd80      	pop	{r7, pc}

0801a17c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 801a17c:	b580      	push	{r7, lr}
 801a17e:	b088      	sub	sp, #32
 801a180:	af00      	add	r7, sp, #0
 801a182:	60f8      	str	r0, [r7, #12]
 801a184:	60b9      	str	r1, [r7, #8]
 801a186:	607a      	str	r2, [r7, #4]
 801a188:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 801a18a:	f04f 0300 	mov.w	r3, #0
 801a18e:	61fb      	str	r3, [r7, #28]
 801a190:	e000      	b.n	801a194 <xQueueGenericReceive+0x18>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 801a192:	bf00      	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 801a194:	f7ff fd0a 	bl	8019bac <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 801a198:	68fb      	ldr	r3, [r7, #12]
 801a19a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a19c:	2b00      	cmp	r3, #0
 801a19e:	d03f      	beq.n	801a220 <xQueueGenericReceive+0xa4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
 801a1a0:	68fb      	ldr	r3, [r7, #12]
 801a1a2:	68db      	ldr	r3, [r3, #12]
 801a1a4:	61bb      	str	r3, [r7, #24]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 801a1a6:	68f8      	ldr	r0, [r7, #12]
 801a1a8:	68b9      	ldr	r1, [r7, #8]
 801a1aa:	f000 f989 	bl	801a4c0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 801a1ae:	683b      	ldr	r3, [r7, #0]
 801a1b0:	2b00      	cmp	r3, #0
 801a1b2:	d11e      	bne.n	801a1f2 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
 801a1b4:	68fb      	ldr	r3, [r7, #12]
 801a1b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a1b8:	f103 32ff 	add.w	r2, r3, #4294967295
 801a1bc:	68fb      	ldr	r3, [r7, #12]
 801a1be:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 801a1c0:	68fb      	ldr	r3, [r7, #12]
 801a1c2:	681b      	ldr	r3, [r3, #0]
 801a1c4:	2b00      	cmp	r3, #0
 801a1c6:	d104      	bne.n	801a1d2 <xQueueGenericReceive+0x56>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 801a1c8:	f001 fd64 	bl	801bc94 <xTaskGetCurrentTaskHandle>
 801a1cc:	4602      	mov	r2, r0
 801a1ce:	68fb      	ldr	r3, [r7, #12]
 801a1d0:	605a      	str	r2, [r3, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801a1d2:	68fb      	ldr	r3, [r7, #12]
 801a1d4:	691b      	ldr	r3, [r3, #16]
 801a1d6:	2b00      	cmp	r3, #0
 801a1d8:	d01d      	beq.n	801a216 <xQueueGenericReceive+0x9a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 801a1da:	68fb      	ldr	r3, [r7, #12]
 801a1dc:	f103 0310 	add.w	r3, r3, #16
 801a1e0:	4618      	mov	r0, r3
 801a1e2:	f001 fa03 	bl	801b5ec <xTaskRemoveFromEventList>
 801a1e6:	4603      	mov	r3, r0
 801a1e8:	2b01      	cmp	r3, #1
 801a1ea:	d114      	bne.n	801a216 <xQueueGenericReceive+0x9a>
						{
							portYIELD_WITHIN_API();
 801a1ec:	f7ff fcd2 	bl	8019b94 <vPortYieldFromISR>
 801a1f0:	e011      	b.n	801a216 <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
 801a1f2:	68fb      	ldr	r3, [r7, #12]
 801a1f4:	69ba      	ldr	r2, [r7, #24]
 801a1f6:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801a1f8:	68fb      	ldr	r3, [r7, #12]
 801a1fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a1fc:	2b00      	cmp	r3, #0
 801a1fe:	d00a      	beq.n	801a216 <xQueueGenericReceive+0x9a>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801a200:	68fb      	ldr	r3, [r7, #12]
 801a202:	f103 0324 	add.w	r3, r3, #36	; 0x24
 801a206:	4618      	mov	r0, r3
 801a208:	f001 f9f0 	bl	801b5ec <xTaskRemoveFromEventList>
 801a20c:	4603      	mov	r3, r0
 801a20e:	2b00      	cmp	r3, #0
 801a210:	d001      	beq.n	801a216 <xQueueGenericReceive+0x9a>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
 801a212:	f7ff fcbf 	bl	8019b94 <vPortYieldFromISR>
						}
					}

				}

				taskEXIT_CRITICAL();
 801a216:	f7ff fcdf 	bl	8019bd8 <vPortExitCritical>
				return pdPASS;
 801a21a:	f04f 0301 	mov.w	r3, #1
 801a21e:	e06b      	b.n	801a2f8 <xQueueGenericReceive+0x17c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 801a220:	687b      	ldr	r3, [r7, #4]
 801a222:	2b00      	cmp	r3, #0
 801a224:	d104      	bne.n	801a230 <xQueueGenericReceive+0xb4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 801a226:	f7ff fcd7 	bl	8019bd8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 801a22a:	f04f 0300 	mov.w	r3, #0
 801a22e:	e063      	b.n	801a2f8 <xQueueGenericReceive+0x17c>
				}
				else if( xEntryTimeSet == pdFALSE )
 801a230:	69fb      	ldr	r3, [r7, #28]
 801a232:	2b00      	cmp	r3, #0
 801a234:	d107      	bne.n	801a246 <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 801a236:	f107 0310 	add.w	r3, r7, #16
 801a23a:	4618      	mov	r0, r3
 801a23c:	f001 fa38 	bl	801b6b0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 801a240:	f04f 0301 	mov.w	r3, #1
 801a244:	61fb      	str	r3, [r7, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 801a246:	f7ff fcc7 	bl	8019bd8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 801a24a:	f000 fe03 	bl	801ae54 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 801a24e:	f7ff fcad 	bl	8019bac <vPortEnterCritical>
 801a252:	68fb      	ldr	r3, [r7, #12]
 801a254:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801a256:	f1b3 3fff 	cmp.w	r3, #4294967295
 801a25a:	d103      	bne.n	801a264 <xQueueGenericReceive+0xe8>
 801a25c:	68fb      	ldr	r3, [r7, #12]
 801a25e:	f04f 0200 	mov.w	r2, #0
 801a262:	645a      	str	r2, [r3, #68]	; 0x44
 801a264:	68fb      	ldr	r3, [r7, #12]
 801a266:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a268:	f1b3 3fff 	cmp.w	r3, #4294967295
 801a26c:	d103      	bne.n	801a276 <xQueueGenericReceive+0xfa>
 801a26e:	68fb      	ldr	r3, [r7, #12]
 801a270:	f04f 0200 	mov.w	r2, #0
 801a274:	649a      	str	r2, [r3, #72]	; 0x48
 801a276:	f7ff fcaf 	bl	8019bd8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 801a27a:	f107 0210 	add.w	r2, r7, #16
 801a27e:	f107 0304 	add.w	r3, r7, #4
 801a282:	4610      	mov	r0, r2
 801a284:	4619      	mov	r1, r3
 801a286:	f001 fa2b 	bl	801b6e0 <xTaskCheckForTimeOut>
 801a28a:	4603      	mov	r3, r0
 801a28c:	2b00      	cmp	r3, #0
 801a28e:	d12c      	bne.n	801a2ea <xQueueGenericReceive+0x16e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 801a290:	68f8      	ldr	r0, [r7, #12]
 801a292:	f000 f98d 	bl	801a5b0 <prvIsQueueEmpty>
 801a296:	4603      	mov	r3, r0
 801a298:	2b00      	cmp	r3, #0
 801a29a:	d020      	beq.n	801a2de <xQueueGenericReceive+0x162>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 801a29c:	68fb      	ldr	r3, [r7, #12]
 801a29e:	681b      	ldr	r3, [r3, #0]
 801a2a0:	2b00      	cmp	r3, #0
 801a2a2:	d108      	bne.n	801a2b6 <xQueueGenericReceive+0x13a>
					{
						portENTER_CRITICAL();
 801a2a4:	f7ff fc82 	bl	8019bac <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 801a2a8:	68fb      	ldr	r3, [r7, #12]
 801a2aa:	685b      	ldr	r3, [r3, #4]
 801a2ac:	4618      	mov	r0, r3
 801a2ae:	f001 fd01 	bl	801bcb4 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
 801a2b2:	f7ff fc91 	bl	8019bd8 <vPortExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 801a2b6:	68fb      	ldr	r3, [r7, #12]
 801a2b8:	f103 0224 	add.w	r2, r3, #36	; 0x24
 801a2bc:	687b      	ldr	r3, [r7, #4]
 801a2be:	4610      	mov	r0, r2
 801a2c0:	4619      	mov	r1, r3
 801a2c2:	f001 f957 	bl	801b574 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 801a2c6:	68f8      	ldr	r0, [r7, #12]
 801a2c8:	f000 f922 	bl	801a510 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 801a2cc:	f000 fdd4 	bl	801ae78 <xTaskResumeAll>
 801a2d0:	4603      	mov	r3, r0
 801a2d2:	2b00      	cmp	r3, #0
 801a2d4:	f47f af5d 	bne.w	801a192 <xQueueGenericReceive+0x16>
				{
					portYIELD_WITHIN_API();
 801a2d8:	f7ff fc5c 	bl	8019b94 <vPortYieldFromISR>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 801a2dc:	e759      	b.n	801a192 <xQueueGenericReceive+0x16>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 801a2de:	68f8      	ldr	r0, [r7, #12]
 801a2e0:	f000 f916 	bl	801a510 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 801a2e4:	f000 fdc8 	bl	801ae78 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 801a2e8:	e753      	b.n	801a192 <xQueueGenericReceive+0x16>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 801a2ea:	68f8      	ldr	r0, [r7, #12]
 801a2ec:	f000 f910 	bl	801a510 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 801a2f0:	f000 fdc2 	bl	801ae78 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 801a2f4:	f04f 0300 	mov.w	r3, #0
		}
	}
}
 801a2f8:	4618      	mov	r0, r3
 801a2fa:	f107 0720 	add.w	r7, r7, #32
 801a2fe:	46bd      	mov	sp, r7
 801a300:	bd80      	pop	{r7, pc}
 801a302:	bf00      	nop

0801a304 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
 801a304:	b580      	push	{r7, lr}
 801a306:	b086      	sub	sp, #24
 801a308:	af00      	add	r7, sp, #0
 801a30a:	60f8      	str	r0, [r7, #12]
 801a30c:	60b9      	str	r1, [r7, #8]
 801a30e:	607a      	str	r2, [r7, #4]

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 801a310:	f04f 0300 	mov.w	r3, #0
 801a314:	613b      	str	r3, [r7, #16]
 801a316:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 801a31a:	f380 8811 	msr	BASEPRI, r0
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 801a31e:	68fb      	ldr	r3, [r7, #12]
 801a320:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a322:	2b00      	cmp	r3, #0
 801a324:	d02a      	beq.n	801a37c <xQueueReceiveFromISR+0x78>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 801a326:	68f8      	ldr	r0, [r7, #12]
 801a328:	68b9      	ldr	r1, [r7, #8]
 801a32a:	f000 f8c9 	bl	801a4c0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 801a32e:	68fb      	ldr	r3, [r7, #12]
 801a330:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a332:	f103 32ff 	add.w	r2, r3, #4294967295
 801a336:	68fb      	ldr	r3, [r7, #12]
 801a338:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
 801a33a:	68fb      	ldr	r3, [r7, #12]
 801a33c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801a33e:	f1b3 3fff 	cmp.w	r3, #4294967295
 801a342:	d111      	bne.n	801a368 <xQueueReceiveFromISR+0x64>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801a344:	68fb      	ldr	r3, [r7, #12]
 801a346:	691b      	ldr	r3, [r3, #16]
 801a348:	2b00      	cmp	r3, #0
 801a34a:	d013      	beq.n	801a374 <xQueueReceiveFromISR+0x70>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801a34c:	68fb      	ldr	r3, [r7, #12]
 801a34e:	f103 0310 	add.w	r3, r3, #16
 801a352:	4618      	mov	r0, r3
 801a354:	f001 f94a 	bl	801b5ec <xTaskRemoveFromEventList>
 801a358:	4603      	mov	r3, r0
 801a35a:	2b00      	cmp	r3, #0
 801a35c:	d00a      	beq.n	801a374 <xQueueReceiveFromISR+0x70>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
 801a35e:	687b      	ldr	r3, [r7, #4]
 801a360:	f04f 0201 	mov.w	r2, #1
 801a364:	601a      	str	r2, [r3, #0]
 801a366:	e005      	b.n	801a374 <xQueueReceiveFromISR+0x70>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 801a368:	68fb      	ldr	r3, [r7, #12]
 801a36a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801a36c:	f103 0201 	add.w	r2, r3, #1
 801a370:	68fb      	ldr	r3, [r7, #12]
 801a372:	645a      	str	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
 801a374:	f04f 0301 	mov.w	r3, #1
 801a378:	617b      	str	r3, [r7, #20]
 801a37a:	e002      	b.n	801a382 <xQueueReceiveFromISR+0x7e>
		}
		else
		{
			xReturn = pdFAIL;
 801a37c:	f04f 0300 	mov.w	r3, #0
 801a380:	617b      	str	r3, [r7, #20]
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 801a382:	f04f 0000 	mov.w	r0, #0
 801a386:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
 801a38a:	697b      	ldr	r3, [r7, #20]
}
 801a38c:	4618      	mov	r0, r3
 801a38e:	f107 0718 	add.w	r7, r7, #24
 801a392:	46bd      	mov	sp, r7
 801a394:	bd80      	pop	{r7, pc}
 801a396:	bf00      	nop

0801a398 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
 801a398:	b580      	push	{r7, lr}
 801a39a:	b084      	sub	sp, #16
 801a39c:	af00      	add	r7, sp, #0
 801a39e:	6078      	str	r0, [r7, #4]
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 801a3a0:	f7ff fc04 	bl	8019bac <vPortEnterCritical>
		uxReturn = pxQueue->uxMessagesWaiting;
 801a3a4:	687b      	ldr	r3, [r7, #4]
 801a3a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a3a8:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 801a3aa:	f7ff fc15 	bl	8019bd8 <vPortExitCritical>

	return uxReturn;
 801a3ae:	68fb      	ldr	r3, [r7, #12]
}
 801a3b0:	4618      	mov	r0, r3
 801a3b2:	f107 0710 	add.w	r7, r7, #16
 801a3b6:	46bd      	mov	sp, r7
 801a3b8:	bd80      	pop	{r7, pc}
 801a3ba:	bf00      	nop

0801a3bc <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
 801a3bc:	b480      	push	{r7}
 801a3be:	b085      	sub	sp, #20
 801a3c0:	af00      	add	r7, sp, #0
 801a3c2:	6078      	str	r0, [r7, #4]
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
 801a3c4:	687b      	ldr	r3, [r7, #4]
 801a3c6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a3c8:	60fb      	str	r3, [r7, #12]

	return uxReturn;
 801a3ca:	68fb      	ldr	r3, [r7, #12]
}
 801a3cc:	4618      	mov	r0, r3
 801a3ce:	f107 0714 	add.w	r7, r7, #20
 801a3d2:	46bd      	mov	sp, r7
 801a3d4:	bc80      	pop	{r7}
 801a3d6:	4770      	bx	lr

0801a3d8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
 801a3d8:	b580      	push	{r7, lr}
 801a3da:	b082      	sub	sp, #8
 801a3dc:	af00      	add	r7, sp, #0
 801a3de:	6078      	str	r0, [r7, #4]
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
 801a3e0:	687b      	ldr	r3, [r7, #4]
 801a3e2:	681b      	ldr	r3, [r3, #0]
 801a3e4:	4618      	mov	r0, r3
 801a3e6:	f00a fcef 	bl	8024dc8 <free>
	vPortFree( pxQueue );
 801a3ea:	6878      	ldr	r0, [r7, #4]
 801a3ec:	f00a fcec 	bl	8024dc8 <free>
}
 801a3f0:	f107 0708 	add.w	r7, r7, #8
 801a3f4:	46bd      	mov	sp, r7
 801a3f6:	bd80      	pop	{r7, pc}

0801a3f8 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 801a3f8:	b580      	push	{r7, lr}
 801a3fa:	b084      	sub	sp, #16
 801a3fc:	af00      	add	r7, sp, #0
 801a3fe:	60f8      	str	r0, [r7, #12]
 801a400:	60b9      	str	r1, [r7, #8]
 801a402:	607a      	str	r2, [r7, #4]
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 801a404:	68fb      	ldr	r3, [r7, #12]
 801a406:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a408:	2b00      	cmp	r3, #0
 801a40a:	d10d      	bne.n	801a428 <prvCopyDataToQueue+0x30>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 801a40c:	68fb      	ldr	r3, [r7, #12]
 801a40e:	681b      	ldr	r3, [r3, #0]
 801a410:	2b00      	cmp	r3, #0
 801a412:	d14a      	bne.n	801a4aa <prvCopyDataToQueue+0xb2>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 801a414:	68fb      	ldr	r3, [r7, #12]
 801a416:	685b      	ldr	r3, [r3, #4]
 801a418:	4618      	mov	r0, r3
 801a41a:	f001 fcb7 	bl	801bd8c <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 801a41e:	68fb      	ldr	r3, [r7, #12]
 801a420:	f04f 0200 	mov.w	r2, #0
 801a424:	605a      	str	r2, [r3, #4]
 801a426:	e040      	b.n	801a4aa <prvCopyDataToQueue+0xb2>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
 801a428:	687b      	ldr	r3, [r7, #4]
 801a42a:	2b00      	cmp	r3, #0
 801a42c:	d11b      	bne.n	801a466 <prvCopyDataToQueue+0x6e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 801a42e:	68fb      	ldr	r3, [r7, #12]
 801a430:	6899      	ldr	r1, [r3, #8]
 801a432:	68fb      	ldr	r3, [r7, #12]
 801a434:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a436:	68ba      	ldr	r2, [r7, #8]
 801a438:	4608      	mov	r0, r1
 801a43a:	4611      	mov	r1, r2
 801a43c:	461a      	mov	r2, r3
 801a43e:	f00a ff6b 	bl	8025318 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 801a442:	68fb      	ldr	r3, [r7, #12]
 801a444:	689a      	ldr	r2, [r3, #8]
 801a446:	68fb      	ldr	r3, [r7, #12]
 801a448:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a44a:	18d2      	adds	r2, r2, r3
 801a44c:	68fb      	ldr	r3, [r7, #12]
 801a44e:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 801a450:	68fb      	ldr	r3, [r7, #12]
 801a452:	689a      	ldr	r2, [r3, #8]
 801a454:	68fb      	ldr	r3, [r7, #12]
 801a456:	685b      	ldr	r3, [r3, #4]
 801a458:	429a      	cmp	r2, r3
 801a45a:	d326      	bcc.n	801a4aa <prvCopyDataToQueue+0xb2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 801a45c:	68fb      	ldr	r3, [r7, #12]
 801a45e:	681a      	ldr	r2, [r3, #0]
 801a460:	68fb      	ldr	r3, [r7, #12]
 801a462:	609a      	str	r2, [r3, #8]
 801a464:	e021      	b.n	801a4aa <prvCopyDataToQueue+0xb2>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 801a466:	68fb      	ldr	r3, [r7, #12]
 801a468:	68d9      	ldr	r1, [r3, #12]
 801a46a:	68fb      	ldr	r3, [r7, #12]
 801a46c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a46e:	68ba      	ldr	r2, [r7, #8]
 801a470:	4608      	mov	r0, r1
 801a472:	4611      	mov	r1, r2
 801a474:	461a      	mov	r2, r3
 801a476:	f00a ff4f 	bl	8025318 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 801a47a:	68fb      	ldr	r3, [r7, #12]
 801a47c:	68da      	ldr	r2, [r3, #12]
 801a47e:	68fb      	ldr	r3, [r7, #12]
 801a480:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a482:	f1c3 0300 	rsb	r3, r3, #0
 801a486:	18d2      	adds	r2, r2, r3
 801a488:	68fb      	ldr	r3, [r7, #12]
 801a48a:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 801a48c:	68fb      	ldr	r3, [r7, #12]
 801a48e:	68da      	ldr	r2, [r3, #12]
 801a490:	68fb      	ldr	r3, [r7, #12]
 801a492:	681b      	ldr	r3, [r3, #0]
 801a494:	429a      	cmp	r2, r3
 801a496:	d208      	bcs.n	801a4aa <prvCopyDataToQueue+0xb2>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 801a498:	68fb      	ldr	r3, [r7, #12]
 801a49a:	685a      	ldr	r2, [r3, #4]
 801a49c:	68fb      	ldr	r3, [r7, #12]
 801a49e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a4a0:	f1c3 0300 	rsb	r3, r3, #0
 801a4a4:	18d2      	adds	r2, r2, r3
 801a4a6:	68fb      	ldr	r3, [r7, #12]
 801a4a8:	60da      	str	r2, [r3, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
 801a4aa:	68fb      	ldr	r3, [r7, #12]
 801a4ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a4ae:	f103 0201 	add.w	r2, r3, #1
 801a4b2:	68fb      	ldr	r3, [r7, #12]
 801a4b4:	639a      	str	r2, [r3, #56]	; 0x38
}
 801a4b6:	f107 0710 	add.w	r7, r7, #16
 801a4ba:	46bd      	mov	sp, r7
 801a4bc:	bd80      	pop	{r7, pc}
 801a4be:	bf00      	nop

0801a4c0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
 801a4c0:	b580      	push	{r7, lr}
 801a4c2:	b082      	sub	sp, #8
 801a4c4:	af00      	add	r7, sp, #0
 801a4c6:	6078      	str	r0, [r7, #4]
 801a4c8:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 801a4ca:	687b      	ldr	r3, [r7, #4]
 801a4cc:	681b      	ldr	r3, [r3, #0]
 801a4ce:	2b00      	cmp	r3, #0
 801a4d0:	d01a      	beq.n	801a508 <prvCopyDataFromQueue+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 801a4d2:	687b      	ldr	r3, [r7, #4]
 801a4d4:	68da      	ldr	r2, [r3, #12]
 801a4d6:	687b      	ldr	r3, [r7, #4]
 801a4d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a4da:	18d2      	adds	r2, r2, r3
 801a4dc:	687b      	ldr	r3, [r7, #4]
 801a4de:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 801a4e0:	687b      	ldr	r3, [r7, #4]
 801a4e2:	68da      	ldr	r2, [r3, #12]
 801a4e4:	687b      	ldr	r3, [r7, #4]
 801a4e6:	685b      	ldr	r3, [r3, #4]
 801a4e8:	429a      	cmp	r2, r3
 801a4ea:	d303      	bcc.n	801a4f4 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
 801a4ec:	687b      	ldr	r3, [r7, #4]
 801a4ee:	681a      	ldr	r2, [r3, #0]
 801a4f0:	687b      	ldr	r3, [r7, #4]
 801a4f2:	60da      	str	r2, [r3, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 801a4f4:	687b      	ldr	r3, [r7, #4]
 801a4f6:	68da      	ldr	r2, [r3, #12]
 801a4f8:	687b      	ldr	r3, [r7, #4]
 801a4fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801a4fc:	6839      	ldr	r1, [r7, #0]
 801a4fe:	4608      	mov	r0, r1
 801a500:	4611      	mov	r1, r2
 801a502:	461a      	mov	r2, r3
 801a504:	f00a ff08 	bl	8025318 <memcpy>
	}
}
 801a508:	f107 0708 	add.w	r7, r7, #8
 801a50c:	46bd      	mov	sp, r7
 801a50e:	bd80      	pop	{r7, pc}

0801a510 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
 801a510:	b580      	push	{r7, lr}
 801a512:	b082      	sub	sp, #8
 801a514:	af00      	add	r7, sp, #0
 801a516:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 801a518:	f7ff fb48 	bl	8019bac <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 801a51c:	e014      	b.n	801a548 <prvUnlockQueue+0x38>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801a51e:	687b      	ldr	r3, [r7, #4]
 801a520:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a522:	2b00      	cmp	r3, #0
 801a524:	d015      	beq.n	801a552 <prvUnlockQueue+0x42>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801a526:	687b      	ldr	r3, [r7, #4]
 801a528:	f103 0324 	add.w	r3, r3, #36	; 0x24
 801a52c:	4618      	mov	r0, r3
 801a52e:	f001 f85d 	bl	801b5ec <xTaskRemoveFromEventList>
 801a532:	4603      	mov	r3, r0
 801a534:	2b00      	cmp	r3, #0
 801a536:	d001      	beq.n	801a53c <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
 801a538:	f001 f924 	bl	801b784 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
 801a53c:	687b      	ldr	r3, [r7, #4]
 801a53e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a540:	f103 32ff 	add.w	r2, r3, #4294967295
 801a544:	687b      	ldr	r3, [r7, #4]
 801a546:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 801a548:	687b      	ldr	r3, [r7, #4]
 801a54a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a54c:	2b00      	cmp	r3, #0
 801a54e:	dce6      	bgt.n	801a51e <prvUnlockQueue+0xe>
 801a550:	e000      	b.n	801a554 <prvUnlockQueue+0x44>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
 801a552:	bf00      	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
 801a554:	687b      	ldr	r3, [r7, #4]
 801a556:	f04f 32ff 	mov.w	r2, #4294967295
 801a55a:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 801a55c:	f7ff fb3c 	bl	8019bd8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 801a560:	f7ff fb24 	bl	8019bac <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 801a564:	e014      	b.n	801a590 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801a566:	687b      	ldr	r3, [r7, #4]
 801a568:	691b      	ldr	r3, [r3, #16]
 801a56a:	2b00      	cmp	r3, #0
 801a56c:	d015      	beq.n	801a59a <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801a56e:	687b      	ldr	r3, [r7, #4]
 801a570:	f103 0310 	add.w	r3, r3, #16
 801a574:	4618      	mov	r0, r3
 801a576:	f001 f839 	bl	801b5ec <xTaskRemoveFromEventList>
 801a57a:	4603      	mov	r3, r0
 801a57c:	2b00      	cmp	r3, #0
 801a57e:	d001      	beq.n	801a584 <prvUnlockQueue+0x74>
				{
					vTaskMissedYield();
 801a580:	f001 f900 	bl	801b784 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
 801a584:	687b      	ldr	r3, [r7, #4]
 801a586:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801a588:	f103 32ff 	add.w	r2, r3, #4294967295
 801a58c:	687b      	ldr	r3, [r7, #4]
 801a58e:	645a      	str	r2, [r3, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 801a590:	687b      	ldr	r3, [r7, #4]
 801a592:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801a594:	2b00      	cmp	r3, #0
 801a596:	dce6      	bgt.n	801a566 <prvUnlockQueue+0x56>
 801a598:	e000      	b.n	801a59c <prvUnlockQueue+0x8c>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
 801a59a:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 801a59c:	687b      	ldr	r3, [r7, #4]
 801a59e:	f04f 32ff 	mov.w	r2, #4294967295
 801a5a2:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 801a5a4:	f7ff fb18 	bl	8019bd8 <vPortExitCritical>
}
 801a5a8:	f107 0708 	add.w	r7, r7, #8
 801a5ac:	46bd      	mov	sp, r7
 801a5ae:	bd80      	pop	{r7, pc}

0801a5b0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
 801a5b0:	b580      	push	{r7, lr}
 801a5b2:	b084      	sub	sp, #16
 801a5b4:	af00      	add	r7, sp, #0
 801a5b6:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 801a5b8:	f7ff faf8 	bl	8019bac <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 801a5bc:	687b      	ldr	r3, [r7, #4]
 801a5be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a5c0:	2b00      	cmp	r3, #0
 801a5c2:	bf14      	ite	ne
 801a5c4:	2300      	movne	r3, #0
 801a5c6:	2301      	moveq	r3, #1
 801a5c8:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 801a5ca:	f7ff fb05 	bl	8019bd8 <vPortExitCritical>

	return xReturn;
 801a5ce:	68fb      	ldr	r3, [r7, #12]
}
 801a5d0:	4618      	mov	r0, r3
 801a5d2:	f107 0710 	add.w	r7, r7, #16
 801a5d6:	46bd      	mov	sp, r7
 801a5d8:	bd80      	pop	{r7, pc}
 801a5da:	bf00      	nop

0801a5dc <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
 801a5dc:	b480      	push	{r7}
 801a5de:	b085      	sub	sp, #20
 801a5e0:	af00      	add	r7, sp, #0
 801a5e2:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 801a5e4:	687b      	ldr	r3, [r7, #4]
 801a5e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a5e8:	2b00      	cmp	r3, #0
 801a5ea:	bf14      	ite	ne
 801a5ec:	2300      	movne	r3, #0
 801a5ee:	2301      	moveq	r3, #1
 801a5f0:	60fb      	str	r3, [r7, #12]

	return xReturn;
 801a5f2:	68fb      	ldr	r3, [r7, #12]
}
 801a5f4:	4618      	mov	r0, r3
 801a5f6:	f107 0714 	add.w	r7, r7, #20
 801a5fa:	46bd      	mov	sp, r7
 801a5fc:	bc80      	pop	{r7}
 801a5fe:	4770      	bx	lr

0801a600 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
 801a600:	b580      	push	{r7, lr}
 801a602:	b084      	sub	sp, #16
 801a604:	af00      	add	r7, sp, #0
 801a606:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 801a608:	f7ff fad0 	bl	8019bac <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 801a60c:	687b      	ldr	r3, [r7, #4]
 801a60e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a610:	461a      	mov	r2, r3
 801a612:	687b      	ldr	r3, [r7, #4]
 801a614:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801a616:	429a      	cmp	r2, r3
 801a618:	bf14      	ite	ne
 801a61a:	2300      	movne	r3, #0
 801a61c:	2301      	moveq	r3, #1
 801a61e:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 801a620:	f7ff fada 	bl	8019bd8 <vPortExitCritical>

	return xReturn;
 801a624:	68fb      	ldr	r3, [r7, #12]
}
 801a626:	4618      	mov	r0, r3
 801a628:	f107 0710 	add.w	r7, r7, #16
 801a62c:	46bd      	mov	sp, r7
 801a62e:	bd80      	pop	{r7, pc}

0801a630 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
 801a630:	b480      	push	{r7}
 801a632:	b085      	sub	sp, #20
 801a634:	af00      	add	r7, sp, #0
 801a636:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 801a638:	687b      	ldr	r3, [r7, #4]
 801a63a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801a63c:	461a      	mov	r2, r3
 801a63e:	687b      	ldr	r3, [r7, #4]
 801a640:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801a642:	429a      	cmp	r2, r3
 801a644:	bf14      	ite	ne
 801a646:	2300      	movne	r3, #0
 801a648:	2301      	moveq	r3, #1
 801a64a:	60fb      	str	r3, [r7, #12]

	return xReturn;
 801a64c:	68fb      	ldr	r3, [r7, #12]
}
 801a64e:	4618      	mov	r0, r3
 801a650:	f107 0714 	add.w	r7, r7, #20
 801a654:	46bd      	mov	sp, r7
 801a656:	bc80      	pop	{r7}
 801a658:	4770      	bx	lr
 801a65a:	bf00      	nop

0801a65c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 801a65c:	b580      	push	{r7, lr}
 801a65e:	b08a      	sub	sp, #40	; 0x28
 801a660:	af02      	add	r7, sp, #8
 801a662:	60f8      	str	r0, [r7, #12]
 801a664:	60b9      	str	r1, [r7, #8]
 801a666:	603b      	str	r3, [r7, #0]
 801a668:	4613      	mov	r3, r2
 801a66a:	80fb      	strh	r3, [r7, #6]
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 801a66c:	88fb      	ldrh	r3, [r7, #6]
 801a66e:	4618      	mov	r0, r3
 801a670:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801a672:	f001 f9cd 	bl	801ba10 <prvAllocateTCBAndStack>
 801a676:	4603      	mov	r3, r0
 801a678:	61bb      	str	r3, [r7, #24]

	if( pxNewTCB != NULL )
 801a67a:	69bb      	ldr	r3, [r7, #24]
 801a67c:	2b00      	cmp	r3, #0
 801a67e:	f000 80a5 	beq.w	801a7cc <xTaskGenericCreate+0x170>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 801a682:	69bb      	ldr	r3, [r7, #24]
 801a684:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a686:	88fb      	ldrh	r3, [r7, #6]
 801a688:	f103 33ff 	add.w	r3, r3, #4294967295
 801a68c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a690:	18d3      	adds	r3, r2, r3
 801a692:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
 801a694:	697b      	ldr	r3, [r7, #20]
 801a696:	f023 0307 	bic.w	r3, r3, #7
 801a69a:	617b      	str	r3, [r7, #20]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 801a69c:	88fb      	ldrh	r3, [r7, #6]
 801a69e:	9300      	str	r3, [sp, #0]
 801a6a0:	69b8      	ldr	r0, [r7, #24]
 801a6a2:	68b9      	ldr	r1, [r7, #8]
 801a6a4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801a6a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a6a8:	f001 f88a 	bl	801b7c0 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801a6ac:	6978      	ldr	r0, [r7, #20]
 801a6ae:	68f9      	ldr	r1, [r7, #12]
 801a6b0:	683a      	ldr	r2, [r7, #0]
 801a6b2:	f7ff f9f3 	bl	8019a9c <pxPortInitialiseStack>
 801a6b6:	4602      	mov	r2, r0
 801a6b8:	69bb      	ldr	r3, [r7, #24]
 801a6ba:	601a      	str	r2, [r3, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
 801a6bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a6be:	2b00      	cmp	r3, #0
 801a6c0:	d002      	beq.n	801a6c8 <xTaskGenericCreate+0x6c>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 801a6c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a6c4:	69ba      	ldr	r2, [r7, #24]
 801a6c6:	601a      	str	r2, [r3, #0]
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 801a6c8:	f7ff fa70 	bl	8019bac <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 801a6cc:	f640 3348 	movw	r3, #2888	; 0xb48
 801a6d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a6d4:	681b      	ldr	r3, [r3, #0]
 801a6d6:	f103 0201 	add.w	r2, r3, #1
 801a6da:	f640 3348 	movw	r3, #2888	; 0xb48
 801a6de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a6e2:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
 801a6e4:	f640 2308 	movw	r3, #2568	; 0xa08
 801a6e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a6ec:	681b      	ldr	r3, [r3, #0]
 801a6ee:	2b00      	cmp	r3, #0
 801a6f0:	d10f      	bne.n	801a712 <xTaskGenericCreate+0xb6>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 801a6f2:	f640 2308 	movw	r3, #2568	; 0xa08
 801a6f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a6fa:	69ba      	ldr	r2, [r7, #24]
 801a6fc:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 801a6fe:	f640 3348 	movw	r3, #2888	; 0xb48
 801a702:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a706:	681b      	ldr	r3, [r3, #0]
 801a708:	2b01      	cmp	r3, #1
 801a70a:	d118      	bne.n	801a73e <xTaskGenericCreate+0xe2>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 801a70c:	f001 f89c 	bl	801b848 <prvInitialiseTaskLists>
 801a710:	e015      	b.n	801a73e <xTaskGenericCreate+0xe2>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 801a712:	f640 3358 	movw	r3, #2904	; 0xb58
 801a716:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a71a:	681b      	ldr	r3, [r3, #0]
 801a71c:	2b00      	cmp	r3, #0
 801a71e:	d10e      	bne.n	801a73e <xTaskGenericCreate+0xe2>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 801a720:	f640 2308 	movw	r3, #2568	; 0xa08
 801a724:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a728:	681b      	ldr	r3, [r3, #0]
 801a72a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801a72c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a72e:	429a      	cmp	r2, r3
 801a730:	d805      	bhi.n	801a73e <xTaskGenericCreate+0xe2>
					{
						pxCurrentTCB = pxNewTCB;
 801a732:	f640 2308 	movw	r3, #2568	; 0xa08
 801a736:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a73a:	69ba      	ldr	r2, [r7, #24]
 801a73c:	601a      	str	r2, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 801a73e:	69bb      	ldr	r3, [r7, #24]
 801a740:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801a742:	f640 3350 	movw	r3, #2896	; 0xb50
 801a746:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a74a:	681b      	ldr	r3, [r3, #0]
 801a74c:	429a      	cmp	r2, r3
 801a74e:	d906      	bls.n	801a75e <xTaskGenericCreate+0x102>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 801a750:	69bb      	ldr	r3, [r7, #24]
 801a752:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801a754:	f640 3350 	movw	r3, #2896	; 0xb50
 801a758:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a75c:	601a      	str	r2, [r3, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 801a75e:	f640 336c 	movw	r3, #2924	; 0xb6c
 801a762:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a766:	681b      	ldr	r3, [r3, #0]
 801a768:	f103 0201 	add.w	r2, r3, #1
 801a76c:	f640 336c 	movw	r3, #2924	; 0xb6c
 801a770:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a774:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 801a776:	69bb      	ldr	r3, [r7, #24]
 801a778:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801a77a:	f640 3354 	movw	r3, #2900	; 0xb54
 801a77e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a782:	681b      	ldr	r3, [r3, #0]
 801a784:	429a      	cmp	r2, r3
 801a786:	d906      	bls.n	801a796 <xTaskGenericCreate+0x13a>
 801a788:	69bb      	ldr	r3, [r7, #24]
 801a78a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801a78c:	f640 3354 	movw	r3, #2900	; 0xb54
 801a790:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a794:	601a      	str	r2, [r3, #0]
 801a796:	69bb      	ldr	r3, [r7, #24]
 801a798:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801a79a:	4613      	mov	r3, r2
 801a79c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a7a0:	189b      	adds	r3, r3, r2
 801a7a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a7a6:	461a      	mov	r2, r3
 801a7a8:	f640 230c 	movw	r3, #2572	; 0xa0c
 801a7ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a7b0:	18d2      	adds	r2, r2, r3
 801a7b2:	69bb      	ldr	r3, [r7, #24]
 801a7b4:	f103 0304 	add.w	r3, r3, #4
 801a7b8:	4610      	mov	r0, r2
 801a7ba:	4619      	mov	r1, r3
 801a7bc:	f7ff fac0 	bl	8019d40 <vListInsertEnd>

			xReturn = pdPASS;
 801a7c0:	f04f 0301 	mov.w	r3, #1
 801a7c4:	61fb      	str	r3, [r7, #28]
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 801a7c6:	f7ff fa07 	bl	8019bd8 <vPortExitCritical>
 801a7ca:	e002      	b.n	801a7d2 <xTaskGenericCreate+0x176>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 801a7cc:	f04f 33ff 	mov.w	r3, #4294967295
 801a7d0:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
 801a7d2:	69fb      	ldr	r3, [r7, #28]
 801a7d4:	2b01      	cmp	r3, #1
 801a7d6:	d111      	bne.n	801a7fc <xTaskGenericCreate+0x1a0>
	{
		if( xSchedulerRunning != pdFALSE )
 801a7d8:	f640 3358 	movw	r3, #2904	; 0xb58
 801a7dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a7e0:	681b      	ldr	r3, [r3, #0]
 801a7e2:	2b00      	cmp	r3, #0
 801a7e4:	d00a      	beq.n	801a7fc <xTaskGenericCreate+0x1a0>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 801a7e6:	f640 2308 	movw	r3, #2568	; 0xa08
 801a7ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a7ee:	681b      	ldr	r3, [r3, #0]
 801a7f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801a7f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a7f4:	429a      	cmp	r2, r3
 801a7f6:	d201      	bcs.n	801a7fc <xTaskGenericCreate+0x1a0>
			{
				portYIELD_WITHIN_API();
 801a7f8:	f7ff f9cc 	bl	8019b94 <vPortYieldFromISR>
			}
		}
	}

	return xReturn;
 801a7fc:	69fb      	ldr	r3, [r7, #28]
}
 801a7fe:	4618      	mov	r0, r3
 801a800:	f107 0720 	add.w	r7, r7, #32
 801a804:	46bd      	mov	sp, r7
 801a806:	bd80      	pop	{r7, pc}

0801a808 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
 801a808:	b580      	push	{r7, lr}
 801a80a:	b084      	sub	sp, #16
 801a80c:	af00      	add	r7, sp, #0
 801a80e:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 801a810:	f7ff f9cc 	bl	8019bac <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
 801a814:	f640 2308 	movw	r3, #2568	; 0xa08
 801a818:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a81c:	681b      	ldr	r3, [r3, #0]
 801a81e:	687a      	ldr	r2, [r7, #4]
 801a820:	429a      	cmp	r2, r3
 801a822:	d102      	bne.n	801a82a <vTaskDelete+0x22>
			{
				pxTaskToDelete = NULL;
 801a824:	f04f 0300 	mov.w	r3, #0
 801a828:	607b      	str	r3, [r7, #4]
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 801a82a:	687b      	ldr	r3, [r7, #4]
 801a82c:	2b00      	cmp	r3, #0
 801a82e:	d105      	bne.n	801a83c <vTaskDelete+0x34>
 801a830:	f640 2308 	movw	r3, #2568	; 0xa08
 801a834:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a838:	681b      	ldr	r3, [r3, #0]
 801a83a:	e000      	b.n	801a83e <vTaskDelete+0x36>
 801a83c:	687b      	ldr	r3, [r7, #4]
 801a83e:	60fb      	str	r3, [r7, #12]

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
 801a840:	68fb      	ldr	r3, [r7, #12]
 801a842:	f103 0304 	add.w	r3, r3, #4
 801a846:	4618      	mov	r0, r3
 801a848:	f7ff fae0 	bl	8019e0c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
 801a84c:	68fb      	ldr	r3, [r7, #12]
 801a84e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801a850:	2b00      	cmp	r3, #0
 801a852:	d005      	beq.n	801a860 <vTaskDelete+0x58>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
 801a854:	68fb      	ldr	r3, [r7, #12]
 801a856:	f103 0318 	add.w	r3, r3, #24
 801a85a:	4618      	mov	r0, r3
 801a85c:	f7ff fad6 	bl	8019e0c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 801a860:	68fb      	ldr	r3, [r7, #12]
 801a862:	f103 0304 	add.w	r3, r3, #4
 801a866:	f640 3018 	movw	r0, #2840	; 0xb18
 801a86a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801a86e:	4619      	mov	r1, r3
 801a870:	f7ff fa66 	bl	8019d40 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 801a874:	f640 332c 	movw	r3, #2860	; 0xb2c
 801a878:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a87c:	681b      	ldr	r3, [r3, #0]
 801a87e:	f103 0201 	add.w	r2, r3, #1
 801a882:	f640 332c 	movw	r3, #2860	; 0xb2c
 801a886:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a88a:	601a      	str	r2, [r3, #0]

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 801a88c:	f640 336c 	movw	r3, #2924	; 0xb6c
 801a890:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a894:	681b      	ldr	r3, [r3, #0]
 801a896:	f103 0201 	add.w	r2, r3, #1
 801a89a:	f640 336c 	movw	r3, #2924	; 0xb6c
 801a89e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a8a2:	601a      	str	r2, [r3, #0]

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 801a8a4:	f7ff f998 	bl	8019bd8 <vPortExitCritical>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
 801a8a8:	f640 3358 	movw	r3, #2904	; 0xb58
 801a8ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a8b0:	681b      	ldr	r3, [r3, #0]
 801a8b2:	2b00      	cmp	r3, #0
 801a8b4:	d004      	beq.n	801a8c0 <vTaskDelete+0xb8>
		{
			if( ( void * ) pxTaskToDelete == NULL )
 801a8b6:	687b      	ldr	r3, [r7, #4]
 801a8b8:	2b00      	cmp	r3, #0
 801a8ba:	d101      	bne.n	801a8c0 <vTaskDelete+0xb8>
			{
				portYIELD_WITHIN_API();
 801a8bc:	f7ff f96a 	bl	8019b94 <vPortYieldFromISR>
			}
		}
	}
 801a8c0:	f107 0710 	add.w	r7, r7, #16
 801a8c4:	46bd      	mov	sp, r7
 801a8c6:	bd80      	pop	{r7, pc}

0801a8c8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 801a8c8:	b580      	push	{r7, lr}
 801a8ca:	b086      	sub	sp, #24
 801a8cc:	af00      	add	r7, sp, #0
 801a8ce:	6078      	str	r0, [r7, #4]
 801a8d0:	6039      	str	r1, [r7, #0]
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 801a8d2:	f04f 0300 	mov.w	r3, #0
 801a8d6:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
 801a8d8:	f000 fabc 	bl	801ae54 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 801a8dc:	687b      	ldr	r3, [r7, #4]
 801a8de:	681a      	ldr	r2, [r3, #0]
 801a8e0:	683b      	ldr	r3, [r7, #0]
 801a8e2:	18d3      	adds	r3, r2, r3
 801a8e4:	613b      	str	r3, [r7, #16]

			if( xTickCount < *pxPreviousWakeTime )
 801a8e6:	687b      	ldr	r3, [r7, #4]
 801a8e8:	681a      	ldr	r2, [r3, #0]
 801a8ea:	f640 334c 	movw	r3, #2892	; 0xb4c
 801a8ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a8f2:	681b      	ldr	r3, [r3, #0]
 801a8f4:	429a      	cmp	r2, r3
 801a8f6:	d910      	bls.n	801a91a <vTaskDelayUntil+0x52>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 801a8f8:	687b      	ldr	r3, [r7, #4]
 801a8fa:	681a      	ldr	r2, [r3, #0]
 801a8fc:	693b      	ldr	r3, [r7, #16]
 801a8fe:	429a      	cmp	r2, r3
 801a900:	d91b      	bls.n	801a93a <vTaskDelayUntil+0x72>
 801a902:	f640 334c 	movw	r3, #2892	; 0xb4c
 801a906:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a90a:	681b      	ldr	r3, [r3, #0]
 801a90c:	693a      	ldr	r2, [r7, #16]
 801a90e:	429a      	cmp	r2, r3
 801a910:	d913      	bls.n	801a93a <vTaskDelayUntil+0x72>
				{
					xShouldDelay = pdTRUE;
 801a912:	f04f 0301 	mov.w	r3, #1
 801a916:	617b      	str	r3, [r7, #20]
 801a918:	e00f      	b.n	801a93a <vTaskDelayUntil+0x72>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 801a91a:	687b      	ldr	r3, [r7, #4]
 801a91c:	681a      	ldr	r2, [r3, #0]
 801a91e:	693b      	ldr	r3, [r7, #16]
 801a920:	429a      	cmp	r2, r3
 801a922:	d807      	bhi.n	801a934 <vTaskDelayUntil+0x6c>
 801a924:	f640 334c 	movw	r3, #2892	; 0xb4c
 801a928:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a92c:	681b      	ldr	r3, [r3, #0]
 801a92e:	693a      	ldr	r2, [r7, #16]
 801a930:	429a      	cmp	r2, r3
 801a932:	d902      	bls.n	801a93a <vTaskDelayUntil+0x72>
				{
					xShouldDelay = pdTRUE;
 801a934:	f04f 0301 	mov.w	r3, #1
 801a938:	617b      	str	r3, [r7, #20]
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 801a93a:	687b      	ldr	r3, [r7, #4]
 801a93c:	693a      	ldr	r2, [r7, #16]
 801a93e:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
 801a940:	697b      	ldr	r3, [r7, #20]
 801a942:	2b00      	cmp	r3, #0
 801a944:	d00c      	beq.n	801a960 <vTaskDelayUntil+0x98>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 801a946:	f640 2308 	movw	r3, #2568	; 0xa08
 801a94a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a94e:	681b      	ldr	r3, [r3, #0]
 801a950:	f103 0304 	add.w	r3, r3, #4
 801a954:	4618      	mov	r0, r3
 801a956:	f7ff fa59 	bl	8019e0c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 801a95a:	6938      	ldr	r0, [r7, #16]
 801a95c:	f001 f812 	bl	801b984 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 801a960:	f000 fa8a 	bl	801ae78 <xTaskResumeAll>
 801a964:	4603      	mov	r3, r0
 801a966:	60fb      	str	r3, [r7, #12]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 801a968:	68fb      	ldr	r3, [r7, #12]
 801a96a:	2b00      	cmp	r3, #0
 801a96c:	d101      	bne.n	801a972 <vTaskDelayUntil+0xaa>
		{
			portYIELD_WITHIN_API();
 801a96e:	f7ff f911 	bl	8019b94 <vPortYieldFromISR>
		}
	}
 801a972:	f107 0718 	add.w	r7, r7, #24
 801a976:	46bd      	mov	sp, r7
 801a978:	bd80      	pop	{r7, pc}
 801a97a:	bf00      	nop

0801a97c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 801a97c:	b580      	push	{r7, lr}
 801a97e:	b084      	sub	sp, #16
 801a980:	af00      	add	r7, sp, #0
 801a982:	6078      	str	r0, [r7, #4]
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 801a984:	f04f 0300 	mov.w	r3, #0
 801a988:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 801a98a:	687b      	ldr	r3, [r7, #4]
 801a98c:	2b00      	cmp	r3, #0
 801a98e:	d01a      	beq.n	801a9c6 <vTaskDelay+0x4a>
		{
			vTaskSuspendAll();
 801a990:	f000 fa60 	bl	801ae54 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 801a994:	f640 334c 	movw	r3, #2892	; 0xb4c
 801a998:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a99c:	681a      	ldr	r2, [r3, #0]
 801a99e:	687b      	ldr	r3, [r7, #4]
 801a9a0:	18d3      	adds	r3, r2, r3
 801a9a2:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 801a9a4:	f640 2308 	movw	r3, #2568	; 0xa08
 801a9a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a9ac:	681b      	ldr	r3, [r3, #0]
 801a9ae:	f103 0304 	add.w	r3, r3, #4
 801a9b2:	4618      	mov	r0, r3
 801a9b4:	f7ff fa2a 	bl	8019e0c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 801a9b8:	68b8      	ldr	r0, [r7, #8]
 801a9ba:	f000 ffe3 	bl	801b984 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 801a9be:	f000 fa5b 	bl	801ae78 <xTaskResumeAll>
 801a9c2:	4603      	mov	r3, r0
 801a9c4:	60fb      	str	r3, [r7, #12]
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 801a9c6:	68fb      	ldr	r3, [r7, #12]
 801a9c8:	2b00      	cmp	r3, #0
 801a9ca:	d101      	bne.n	801a9d0 <vTaskDelay+0x54>
		{
			portYIELD_WITHIN_API();
 801a9cc:	f7ff f8e2 	bl	8019b94 <vPortYieldFromISR>
		}
	}
 801a9d0:	f107 0710 	add.w	r7, r7, #16
 801a9d4:	46bd      	mov	sp, r7
 801a9d6:	bd80      	pop	{r7, pc}

0801a9d8 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
 801a9d8:	b580      	push	{r7, lr}
 801a9da:	b084      	sub	sp, #16
 801a9dc:	af00      	add	r7, sp, #0
 801a9de:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
 801a9e0:	f7ff f8e4 	bl	8019bac <vPortEnterCritical>
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
 801a9e4:	687b      	ldr	r3, [r7, #4]
 801a9e6:	2b00      	cmp	r3, #0
 801a9e8:	d105      	bne.n	801a9f6 <uxTaskPriorityGet+0x1e>
 801a9ea:	f640 2308 	movw	r3, #2568	; 0xa08
 801a9ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a9f2:	681b      	ldr	r3, [r3, #0]
 801a9f4:	e000      	b.n	801a9f8 <uxTaskPriorityGet+0x20>
 801a9f6:	687b      	ldr	r3, [r7, #4]
 801a9f8:	60fb      	str	r3, [r7, #12]
			uxReturn = pxTCB->uxPriority;
 801a9fa:	68fb      	ldr	r3, [r7, #12]
 801a9fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a9fe:	60bb      	str	r3, [r7, #8]
		}
		taskEXIT_CRITICAL();
 801aa00:	f7ff f8ea 	bl	8019bd8 <vPortExitCritical>

		return uxReturn;
 801aa04:	68bb      	ldr	r3, [r7, #8]
	}
 801aa06:	4618      	mov	r0, r3
 801aa08:	f107 0710 	add.w	r7, r7, #16
 801aa0c:	46bd      	mov	sp, r7
 801aa0e:	bd80      	pop	{r7, pc}

0801aa10 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
 801aa10:	b580      	push	{r7, lr}
 801aa12:	b086      	sub	sp, #24
 801aa14:	af00      	add	r7, sp, #0
 801aa16:	6078      	str	r0, [r7, #4]
 801aa18:	6039      	str	r1, [r7, #0]
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority;
	portBASE_TYPE xYieldRequired = pdFALSE;
 801aa1a:	f04f 0300 	mov.w	r3, #0
 801aa1e:	617b      	str	r3, [r7, #20]

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
 801aa20:	683b      	ldr	r3, [r7, #0]
 801aa22:	2b09      	cmp	r3, #9
 801aa24:	d902      	bls.n	801aa2c <vTaskPrioritySet+0x1c>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 801aa26:	f04f 0309 	mov.w	r3, #9
 801aa2a:	603b      	str	r3, [r7, #0]
		}

		taskENTER_CRITICAL();
 801aa2c:	f7ff f8be 	bl	8019bac <vPortEnterCritical>
		{
			if( pxTask == pxCurrentTCB )
 801aa30:	f640 2308 	movw	r3, #2568	; 0xa08
 801aa34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aa38:	681b      	ldr	r3, [r3, #0]
 801aa3a:	687a      	ldr	r2, [r7, #4]
 801aa3c:	429a      	cmp	r2, r3
 801aa3e:	d102      	bne.n	801aa46 <vTaskPrioritySet+0x36>
			{
				pxTask = NULL;
 801aa40:	f04f 0300 	mov.w	r3, #0
 801aa44:	607b      	str	r3, [r7, #4]
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
 801aa46:	687b      	ldr	r3, [r7, #4]
 801aa48:	2b00      	cmp	r3, #0
 801aa4a:	d105      	bne.n	801aa58 <vTaskPrioritySet+0x48>
 801aa4c:	f640 2308 	movw	r3, #2568	; 0xa08
 801aa50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aa54:	681b      	ldr	r3, [r3, #0]
 801aa56:	e000      	b.n	801aa5a <vTaskPrioritySet+0x4a>
 801aa58:	687b      	ldr	r3, [r7, #4]
 801aa5a:	613b      	str	r3, [r7, #16]

			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
 801aa5c:	693b      	ldr	r3, [r7, #16]
 801aa5e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801aa60:	60fb      	str	r3, [r7, #12]
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
 801aa62:	68fa      	ldr	r2, [r7, #12]
 801aa64:	683b      	ldr	r3, [r7, #0]
 801aa66:	429a      	cmp	r2, r3
 801aa68:	d062      	beq.n	801ab30 <vTaskPrioritySet+0x120>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
 801aa6a:	683a      	ldr	r2, [r7, #0]
 801aa6c:	68fb      	ldr	r3, [r7, #12]
 801aa6e:	429a      	cmp	r2, r3
 801aa70:	d906      	bls.n	801aa80 <vTaskPrioritySet+0x70>
				{
					if( pxTask != NULL )
 801aa72:	687b      	ldr	r3, [r7, #4]
 801aa74:	2b00      	cmp	r3, #0
 801aa76:	d009      	beq.n	801aa8c <vTaskPrioritySet+0x7c>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
 801aa78:	f04f 0301 	mov.w	r3, #1
 801aa7c:	617b      	str	r3, [r7, #20]
 801aa7e:	e005      	b.n	801aa8c <vTaskPrioritySet+0x7c>
					}
				}
				else if( pxTask == NULL )
 801aa80:	687b      	ldr	r3, [r7, #4]
 801aa82:	2b00      	cmp	r3, #0
 801aa84:	d102      	bne.n	801aa8c <vTaskPrioritySet+0x7c>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
 801aa86:	f04f 0301 	mov.w	r3, #1
 801aa8a:	617b      	str	r3, [r7, #20]

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 801aa8c:	693b      	ldr	r3, [r7, #16]
 801aa8e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801aa90:	693b      	ldr	r3, [r7, #16]
 801aa92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801aa94:	429a      	cmp	r2, r3
 801aa96:	d102      	bne.n	801aa9e <vTaskPrioritySet+0x8e>
					{
						pxTCB->uxPriority = uxNewPriority;
 801aa98:	693b      	ldr	r3, [r7, #16]
 801aa9a:	683a      	ldr	r2, [r7, #0]
 801aa9c:	62da      	str	r2, [r3, #44]	; 0x2c
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 801aa9e:	693b      	ldr	r3, [r7, #16]
 801aaa0:	683a      	ldr	r2, [r7, #0]
 801aaa2:	645a      	str	r2, [r3, #68]	; 0x44
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
 801aaa4:	683b      	ldr	r3, [r7, #0]
 801aaa6:	f1c3 020a 	rsb	r2, r3, #10
 801aaaa:	693b      	ldr	r3, [r7, #16]
 801aaac:	619a      	str	r2, [r3, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
 801aaae:	693b      	ldr	r3, [r7, #16]
 801aab0:	6959      	ldr	r1, [r3, #20]
 801aab2:	68fa      	ldr	r2, [r7, #12]
 801aab4:	4613      	mov	r3, r2
 801aab6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801aaba:	189b      	adds	r3, r3, r2
 801aabc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801aac0:	461a      	mov	r2, r3
 801aac2:	f640 230c 	movw	r3, #2572	; 0xa0c
 801aac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aaca:	18d3      	adds	r3, r2, r3
 801aacc:	4299      	cmp	r1, r3
 801aace:	d12a      	bne.n	801ab26 <vTaskPrioritySet+0x116>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
 801aad0:	693b      	ldr	r3, [r7, #16]
 801aad2:	f103 0304 	add.w	r3, r3, #4
 801aad6:	4618      	mov	r0, r3
 801aad8:	f7ff f998 	bl	8019e0c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 801aadc:	693b      	ldr	r3, [r7, #16]
 801aade:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801aae0:	f640 3354 	movw	r3, #2900	; 0xb54
 801aae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aae8:	681b      	ldr	r3, [r3, #0]
 801aaea:	429a      	cmp	r2, r3
 801aaec:	d906      	bls.n	801aafc <vTaskPrioritySet+0xec>
 801aaee:	693b      	ldr	r3, [r7, #16]
 801aaf0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801aaf2:	f640 3354 	movw	r3, #2900	; 0xb54
 801aaf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aafa:	601a      	str	r2, [r3, #0]
 801aafc:	693b      	ldr	r3, [r7, #16]
 801aafe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801ab00:	4613      	mov	r3, r2
 801ab02:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801ab06:	189b      	adds	r3, r3, r2
 801ab08:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801ab0c:	461a      	mov	r2, r3
 801ab0e:	f640 230c 	movw	r3, #2572	; 0xa0c
 801ab12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ab16:	18d2      	adds	r2, r2, r3
 801ab18:	693b      	ldr	r3, [r7, #16]
 801ab1a:	f103 0304 	add.w	r3, r3, #4
 801ab1e:	4610      	mov	r0, r2
 801ab20:	4619      	mov	r1, r3
 801ab22:	f7ff f90d 	bl	8019d40 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
 801ab26:	697b      	ldr	r3, [r7, #20]
 801ab28:	2b01      	cmp	r3, #1
 801ab2a:	d101      	bne.n	801ab30 <vTaskPrioritySet+0x120>
				{
					portYIELD_WITHIN_API();
 801ab2c:	f7ff f832 	bl	8019b94 <vPortYieldFromISR>
				}
			}
		}
		taskEXIT_CRITICAL();
 801ab30:	f7ff f852 	bl	8019bd8 <vPortExitCritical>
	}
 801ab34:	f107 0718 	add.w	r7, r7, #24
 801ab38:	46bd      	mov	sp, r7
 801ab3a:	bd80      	pop	{r7, pc}

0801ab3c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
 801ab3c:	b580      	push	{r7, lr}
 801ab3e:	b084      	sub	sp, #16
 801ab40:	af00      	add	r7, sp, #0
 801ab42:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 801ab44:	f7ff f832 	bl	8019bac <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
 801ab48:	f640 2308 	movw	r3, #2568	; 0xa08
 801ab4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ab50:	681b      	ldr	r3, [r3, #0]
 801ab52:	687a      	ldr	r2, [r7, #4]
 801ab54:	429a      	cmp	r2, r3
 801ab56:	d102      	bne.n	801ab5e <vTaskSuspend+0x22>
			{
				pxTaskToSuspend = NULL;
 801ab58:	f04f 0300 	mov.w	r3, #0
 801ab5c:	607b      	str	r3, [r7, #4]
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 801ab5e:	687b      	ldr	r3, [r7, #4]
 801ab60:	2b00      	cmp	r3, #0
 801ab62:	d105      	bne.n	801ab70 <vTaskSuspend+0x34>
 801ab64:	f640 2308 	movw	r3, #2568	; 0xa08
 801ab68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ab6c:	681b      	ldr	r3, [r3, #0]
 801ab6e:	e000      	b.n	801ab72 <vTaskSuspend+0x36>
 801ab70:	687b      	ldr	r3, [r7, #4]
 801ab72:	60fb      	str	r3, [r7, #12]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
 801ab74:	68fb      	ldr	r3, [r7, #12]
 801ab76:	f103 0304 	add.w	r3, r3, #4
 801ab7a:	4618      	mov	r0, r3
 801ab7c:	f7ff f946 	bl	8019e0c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
 801ab80:	68fb      	ldr	r3, [r7, #12]
 801ab82:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ab84:	2b00      	cmp	r3, #0
 801ab86:	d005      	beq.n	801ab94 <vTaskSuspend+0x58>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
 801ab88:	68fb      	ldr	r3, [r7, #12]
 801ab8a:	f103 0318 	add.w	r3, r3, #24
 801ab8e:	4618      	mov	r0, r3
 801ab90:	f7ff f93c 	bl	8019e0c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 801ab94:	68fb      	ldr	r3, [r7, #12]
 801ab96:	f103 0304 	add.w	r3, r3, #4
 801ab9a:	f640 3030 	movw	r0, #2864	; 0xb30
 801ab9e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801aba2:	4619      	mov	r1, r3
 801aba4:	f7ff f8cc 	bl	8019d40 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 801aba8:	f7ff f816 	bl	8019bd8 <vPortExitCritical>

		if( ( void * ) pxTaskToSuspend == NULL )
 801abac:	687b      	ldr	r3, [r7, #4]
 801abae:	2b00      	cmp	r3, #0
 801abb0:	d120      	bne.n	801abf4 <vTaskSuspend+0xb8>
		{
			if( xSchedulerRunning != pdFALSE )
 801abb2:	f640 3358 	movw	r3, #2904	; 0xb58
 801abb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801abba:	681b      	ldr	r3, [r3, #0]
 801abbc:	2b00      	cmp	r3, #0
 801abbe:	d002      	beq.n	801abc6 <vTaskSuspend+0x8a>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
 801abc0:	f7fe ffe8 	bl	8019b94 <vPortYieldFromISR>
 801abc4:	e016      	b.n	801abf4 <vTaskSuspend+0xb8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 801abc6:	f640 3330 	movw	r3, #2864	; 0xb30
 801abca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801abce:	681b      	ldr	r3, [r3, #0]
 801abd0:	461a      	mov	r2, r3
 801abd2:	f640 3348 	movw	r3, #2888	; 0xb48
 801abd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801abda:	681b      	ldr	r3, [r3, #0]
 801abdc:	429a      	cmp	r2, r3
 801abde:	d107      	bne.n	801abf0 <vTaskSuspend+0xb4>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 801abe0:	f640 2308 	movw	r3, #2568	; 0xa08
 801abe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801abe8:	f04f 0200 	mov.w	r2, #0
 801abec:	601a      	str	r2, [r3, #0]
 801abee:	e001      	b.n	801abf4 <vTaskSuspend+0xb8>
				}
				else
				{
					vTaskSwitchContext();
 801abf0:	f000 fc20 	bl	801b434 <vTaskSwitchContext>
				}
			}
		}
	}
 801abf4:	f107 0710 	add.w	r7, r7, #16
 801abf8:	46bd      	mov	sp, r7
 801abfa:	bd80      	pop	{r7, pc}

0801abfc <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
 801abfc:	b480      	push	{r7}
 801abfe:	b085      	sub	sp, #20
 801ac00:	af00      	add	r7, sp, #0
 801ac02:	6078      	str	r0, [r7, #4]
	portBASE_TYPE xReturn = pdFALSE;
 801ac04:	f04f 0300 	mov.w	r3, #0
 801ac08:	60fb      	str	r3, [r7, #12]
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 801ac0a:	687b      	ldr	r3, [r7, #4]
 801ac0c:	60bb      	str	r3, [r7, #8]
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 801ac0e:	68bb      	ldr	r3, [r7, #8]
 801ac10:	695a      	ldr	r2, [r3, #20]
 801ac12:	f640 3330 	movw	r3, #2864	; 0xb30
 801ac16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ac1a:	429a      	cmp	r2, r3
 801ac1c:	d10e      	bne.n	801ac3c <xTaskIsTaskSuspended+0x40>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 801ac1e:	68bb      	ldr	r3, [r7, #8]
 801ac20:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801ac22:	f640 3304 	movw	r3, #2820	; 0xb04
 801ac26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ac2a:	429a      	cmp	r2, r3
 801ac2c:	d006      	beq.n	801ac3c <xTaskIsTaskSuspended+0x40>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 801ac2e:	68bb      	ldr	r3, [r7, #8]
 801ac30:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ac32:	2b00      	cmp	r3, #0
 801ac34:	d102      	bne.n	801ac3c <xTaskIsTaskSuspended+0x40>
				{
					xReturn = pdTRUE;
 801ac36:	f04f 0301 	mov.w	r3, #1
 801ac3a:	60fb      	str	r3, [r7, #12]
				}
			}
		}

		return xReturn;
 801ac3c:	68fb      	ldr	r3, [r7, #12]
	}
 801ac3e:	4618      	mov	r0, r3
 801ac40:	f107 0714 	add.w	r7, r7, #20
 801ac44:	46bd      	mov	sp, r7
 801ac46:	bc80      	pop	{r7}
 801ac48:	4770      	bx	lr
 801ac4a:	bf00      	nop

0801ac4c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
 801ac4c:	b580      	push	{r7, lr}
 801ac4e:	b084      	sub	sp, #16
 801ac50:	af00      	add	r7, sp, #0
 801ac52:	6078      	str	r0, [r7, #4]
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
 801ac54:	687b      	ldr	r3, [r7, #4]
 801ac56:	60fb      	str	r3, [r7, #12]

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 801ac58:	68fb      	ldr	r3, [r7, #12]
 801ac5a:	2b00      	cmp	r3, #0
 801ac5c:	d048      	beq.n	801acf0 <vTaskResume+0xa4>
 801ac5e:	f640 2308 	movw	r3, #2568	; 0xa08
 801ac62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ac66:	681b      	ldr	r3, [r3, #0]
 801ac68:	68fa      	ldr	r2, [r7, #12]
 801ac6a:	429a      	cmp	r2, r3
 801ac6c:	d040      	beq.n	801acf0 <vTaskResume+0xa4>
		{
			taskENTER_CRITICAL();
 801ac6e:	f7fe ff9d 	bl	8019bac <vPortEnterCritical>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 801ac72:	68f8      	ldr	r0, [r7, #12]
 801ac74:	f7ff ffc2 	bl	801abfc <xTaskIsTaskSuspended>
 801ac78:	4603      	mov	r3, r0
 801ac7a:	2b01      	cmp	r3, #1
 801ac7c:	d136      	bne.n	801acec <vTaskResume+0xa0>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
 801ac7e:	68fb      	ldr	r3, [r7, #12]
 801ac80:	f103 0304 	add.w	r3, r3, #4
 801ac84:	4618      	mov	r0, r3
 801ac86:	f7ff f8c1 	bl	8019e0c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 801ac8a:	68fb      	ldr	r3, [r7, #12]
 801ac8c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801ac8e:	f640 3354 	movw	r3, #2900	; 0xb54
 801ac92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ac96:	681b      	ldr	r3, [r3, #0]
 801ac98:	429a      	cmp	r2, r3
 801ac9a:	d906      	bls.n	801acaa <vTaskResume+0x5e>
 801ac9c:	68fb      	ldr	r3, [r7, #12]
 801ac9e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801aca0:	f640 3354 	movw	r3, #2900	; 0xb54
 801aca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aca8:	601a      	str	r2, [r3, #0]
 801acaa:	68fb      	ldr	r3, [r7, #12]
 801acac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801acae:	4613      	mov	r3, r2
 801acb0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801acb4:	189b      	adds	r3, r3, r2
 801acb6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801acba:	461a      	mov	r2, r3
 801acbc:	f640 230c 	movw	r3, #2572	; 0xa0c
 801acc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801acc4:	18d2      	adds	r2, r2, r3
 801acc6:	68fb      	ldr	r3, [r7, #12]
 801acc8:	f103 0304 	add.w	r3, r3, #4
 801accc:	4610      	mov	r0, r2
 801acce:	4619      	mov	r1, r3
 801acd0:	f7ff f836 	bl	8019d40 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801acd4:	68fb      	ldr	r3, [r7, #12]
 801acd6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801acd8:	f640 2308 	movw	r3, #2568	; 0xa08
 801acdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ace0:	681b      	ldr	r3, [r3, #0]
 801ace2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ace4:	429a      	cmp	r2, r3
 801ace6:	d301      	bcc.n	801acec <vTaskResume+0xa0>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
 801ace8:	f7fe ff54 	bl	8019b94 <vPortYieldFromISR>
					}
				}
			}
			taskEXIT_CRITICAL();
 801acec:	f7fe ff74 	bl	8019bd8 <vPortExitCritical>
		}
	}
 801acf0:	f107 0710 	add.w	r7, r7, #16
 801acf4:	46bd      	mov	sp, r7
 801acf6:	bd80      	pop	{r7, pc}

0801acf8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
 801acf8:	b580      	push	{r7, lr}
 801acfa:	b084      	sub	sp, #16
 801acfc:	af00      	add	r7, sp, #0
 801acfe:	6078      	str	r0, [r7, #4]
	portBASE_TYPE xYieldRequired = pdFALSE;
 801ad00:	f04f 0300 	mov.w	r3, #0
 801ad04:	60fb      	str	r3, [r7, #12]
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
 801ad06:	687b      	ldr	r3, [r7, #4]
 801ad08:	60bb      	str	r3, [r7, #8]

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 801ad0a:	68b8      	ldr	r0, [r7, #8]
 801ad0c:	f7ff ff76 	bl	801abfc <xTaskIsTaskSuspended>
 801ad10:	4603      	mov	r3, r0
 801ad12:	2b01      	cmp	r3, #1
 801ad14:	d149      	bne.n	801adaa <xTaskResumeFromISR+0xb2>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 801ad16:	f640 335c 	movw	r3, #2908	; 0xb5c
 801ad1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ad1e:	681b      	ldr	r3, [r3, #0]
 801ad20:	2b00      	cmp	r3, #0
 801ad22:	d138      	bne.n	801ad96 <xTaskResumeFromISR+0x9e>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 801ad24:	68bb      	ldr	r3, [r7, #8]
 801ad26:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801ad28:	f640 2308 	movw	r3, #2568	; 0xa08
 801ad2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ad30:	681b      	ldr	r3, [r3, #0]
 801ad32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ad34:	429a      	cmp	r2, r3
 801ad36:	bf34      	ite	cc
 801ad38:	2300      	movcc	r3, #0
 801ad3a:	2301      	movcs	r3, #1
 801ad3c:	60fb      	str	r3, [r7, #12]
				vListRemove(  &( pxTCB->xGenericListItem ) );
 801ad3e:	68bb      	ldr	r3, [r7, #8]
 801ad40:	f103 0304 	add.w	r3, r3, #4
 801ad44:	4618      	mov	r0, r3
 801ad46:	f7ff f861 	bl	8019e0c <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
 801ad4a:	68bb      	ldr	r3, [r7, #8]
 801ad4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801ad4e:	f640 3354 	movw	r3, #2900	; 0xb54
 801ad52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ad56:	681b      	ldr	r3, [r3, #0]
 801ad58:	429a      	cmp	r2, r3
 801ad5a:	d906      	bls.n	801ad6a <xTaskResumeFromISR+0x72>
 801ad5c:	68bb      	ldr	r3, [r7, #8]
 801ad5e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801ad60:	f640 3354 	movw	r3, #2900	; 0xb54
 801ad64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ad68:	601a      	str	r2, [r3, #0]
 801ad6a:	68bb      	ldr	r3, [r7, #8]
 801ad6c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801ad6e:	4613      	mov	r3, r2
 801ad70:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801ad74:	189b      	adds	r3, r3, r2
 801ad76:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801ad7a:	461a      	mov	r2, r3
 801ad7c:	f640 230c 	movw	r3, #2572	; 0xa0c
 801ad80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ad84:	18d2      	adds	r2, r2, r3
 801ad86:	68bb      	ldr	r3, [r7, #8]
 801ad88:	f103 0304 	add.w	r3, r3, #4
 801ad8c:	4610      	mov	r0, r2
 801ad8e:	4619      	mov	r1, r3
 801ad90:	f7fe ffd6 	bl	8019d40 <vListInsertEnd>
 801ad94:	e009      	b.n	801adaa <xTaskResumeFromISR+0xb2>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 801ad96:	68bb      	ldr	r3, [r7, #8]
 801ad98:	f103 0318 	add.w	r3, r3, #24
 801ad9c:	f640 3004 	movw	r0, #2820	; 0xb04
 801ada0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ada4:	4619      	mov	r1, r3
 801ada6:	f7fe ffcb 	bl	8019d40 <vListInsertEnd>
			}
		}

		return xYieldRequired;
 801adaa:	68fb      	ldr	r3, [r7, #12]
	}
 801adac:	4618      	mov	r0, r3
 801adae:	f107 0710 	add.w	r7, r7, #16
 801adb2:	46bd      	mov	sp, r7
 801adb4:	bd80      	pop	{r7, pc}
 801adb6:	bf00      	nop

0801adb8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 801adb8:	b580      	push	{r7, lr}
 801adba:	b086      	sub	sp, #24
 801adbc:	af04      	add	r7, sp, #16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
 801adbe:	f04f 0300 	mov.w	r3, #0
 801adc2:	9300      	str	r3, [sp, #0]
 801adc4:	f640 3344 	movw	r3, #2884	; 0xb44
 801adc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801adcc:	9301      	str	r3, [sp, #4]
 801adce:	f04f 0300 	mov.w	r3, #0
 801add2:	9302      	str	r3, [sp, #8]
 801add4:	f04f 0300 	mov.w	r3, #0
 801add8:	9303      	str	r3, [sp, #12]
 801adda:	f24b 709d 	movw	r0, #47005	; 0xb79d
 801adde:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ade2:	f64b 3100 	movw	r1, #47872	; 0xbb00
 801ade6:	f6c0 0102 	movt	r1, #2050	; 0x802
 801adea:	f44f 7280 	mov.w	r2, #256	; 0x100
 801adee:	f04f 0300 	mov.w	r3, #0
 801adf2:	f7ff fc33 	bl	801a65c <xTaskGenericCreate>
 801adf6:	4603      	mov	r3, r0
 801adf8:	607b      	str	r3, [r7, #4]
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
 801adfa:	687b      	ldr	r3, [r7, #4]
 801adfc:	2b01      	cmp	r3, #1
 801adfe:	d115      	bne.n	801ae2c <vTaskStartScheduler+0x74>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 801ae00:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 801ae04:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 801ae08:	f640 3358 	movw	r3, #2904	; 0xb58
 801ae0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ae10:	f04f 0201 	mov.w	r2, #1
 801ae14:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
 801ae16:	f640 334c 	movw	r3, #2892	; 0xb4c
 801ae1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ae1e:	f04f 0200 	mov.w	r2, #0
 801ae22:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 801ae24:	f007 feaa 	bl	8022b7c <init_us_timer>
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 801ae28:	f7fe fe84 	bl	8019b34 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
 801ae2c:	f107 0708 	add.w	r7, r7, #8
 801ae30:	46bd      	mov	sp, r7
 801ae32:	bd80      	pop	{r7, pc}

0801ae34 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 801ae34:	b580      	push	{r7, lr}
 801ae36:	af00      	add	r7, sp, #0
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 801ae38:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 801ae3c:	f380 8811 	msr	BASEPRI, r0
	xSchedulerRunning = pdFALSE;
 801ae40:	f640 3358 	movw	r3, #2904	; 0xb58
 801ae44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ae48:	f04f 0200 	mov.w	r2, #0
 801ae4c:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
 801ae4e:	f7fe fe9b 	bl	8019b88 <vPortEndScheduler>
}
 801ae52:	bd80      	pop	{r7, pc}

0801ae54 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 801ae54:	b480      	push	{r7}
 801ae56:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 801ae58:	f640 335c 	movw	r3, #2908	; 0xb5c
 801ae5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ae60:	681b      	ldr	r3, [r3, #0]
 801ae62:	f103 0201 	add.w	r2, r3, #1
 801ae66:	f640 335c 	movw	r3, #2908	; 0xb5c
 801ae6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ae6e:	601a      	str	r2, [r3, #0]
}
 801ae70:	46bd      	mov	sp, r7
 801ae72:	bc80      	pop	{r7}
 801ae74:	4770      	bx	lr
 801ae76:	bf00      	nop

0801ae78 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 801ae78:	b590      	push	{r4, r7, lr}
 801ae7a:	b083      	sub	sp, #12
 801ae7c:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 801ae7e:	f04f 0300 	mov.w	r3, #0
 801ae82:	607b      	str	r3, [r7, #4]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 801ae84:	f7fe fe92 	bl	8019bac <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 801ae88:	f640 335c 	movw	r3, #2908	; 0xb5c
 801ae8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ae90:	681b      	ldr	r3, [r3, #0]
 801ae92:	f103 32ff 	add.w	r2, r3, #4294967295
 801ae96:	f640 335c 	movw	r3, #2908	; 0xb5c
 801ae9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ae9e:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 801aea0:	f640 335c 	movw	r3, #2908	; 0xb5c
 801aea4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aea8:	681b      	ldr	r3, [r3, #0]
 801aeaa:	2b00      	cmp	r3, #0
 801aeac:	f040 8086 	bne.w	801afbc <xTaskResumeAll+0x144>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 801aeb0:	f640 3348 	movw	r3, #2888	; 0xb48
 801aeb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aeb8:	681b      	ldr	r3, [r3, #0]
 801aeba:	2b00      	cmp	r3, #0
 801aebc:	d07e      	beq.n	801afbc <xTaskResumeAll+0x144>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 801aebe:	f04f 0300 	mov.w	r3, #0
 801aec2:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 801aec4:	e03d      	b.n	801af42 <xTaskResumeAll+0xca>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 801aec6:	f640 3304 	movw	r3, #2820	; 0xb04
 801aeca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aece:	68db      	ldr	r3, [r3, #12]
 801aed0:	68db      	ldr	r3, [r3, #12]
 801aed2:	461c      	mov	r4, r3
					vListRemove( &( pxTCB->xEventListItem ) );
 801aed4:	f104 0318 	add.w	r3, r4, #24
 801aed8:	4618      	mov	r0, r3
 801aeda:	f7fe ff97 	bl	8019e0c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 801aede:	f104 0304 	add.w	r3, r4, #4
 801aee2:	4618      	mov	r0, r3
 801aee4:	f7fe ff92 	bl	8019e0c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 801aee8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 801aeea:	f640 3354 	movw	r3, #2900	; 0xb54
 801aeee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aef2:	681b      	ldr	r3, [r3, #0]
 801aef4:	429a      	cmp	r2, r3
 801aef6:	d905      	bls.n	801af04 <xTaskResumeAll+0x8c>
 801aef8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 801aefa:	f640 3354 	movw	r3, #2900	; 0xb54
 801aefe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801af02:	601a      	str	r2, [r3, #0]
 801af04:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 801af06:	4613      	mov	r3, r2
 801af08:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801af0c:	189b      	adds	r3, r3, r2
 801af0e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801af12:	461a      	mov	r2, r3
 801af14:	f640 230c 	movw	r3, #2572	; 0xa0c
 801af18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801af1c:	18d2      	adds	r2, r2, r3
 801af1e:	f104 0304 	add.w	r3, r4, #4
 801af22:	4610      	mov	r0, r2
 801af24:	4619      	mov	r1, r3
 801af26:	f7fe ff0b 	bl	8019d40 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801af2a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 801af2c:	f640 2308 	movw	r3, #2568	; 0xa08
 801af30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801af34:	681b      	ldr	r3, [r3, #0]
 801af36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801af38:	429a      	cmp	r2, r3
 801af3a:	d302      	bcc.n	801af42 <xTaskResumeAll+0xca>
					{
						xYieldRequired = pdTRUE;
 801af3c:	f04f 0301 	mov.w	r3, #1
 801af40:	603b      	str	r3, [r7, #0]
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 801af42:	f640 3304 	movw	r3, #2820	; 0xb04
 801af46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801af4a:	681b      	ldr	r3, [r3, #0]
 801af4c:	2b00      	cmp	r3, #0
 801af4e:	d1ba      	bne.n	801aec6 <xTaskResumeAll+0x4e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 801af50:	f640 3360 	movw	r3, #2912	; 0xb60
 801af54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801af58:	681b      	ldr	r3, [r3, #0]
 801af5a:	2b00      	cmp	r3, #0
 801af5c:	d018      	beq.n	801af90 <xTaskResumeAll+0x118>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 801af5e:	e00d      	b.n	801af7c <xTaskResumeAll+0x104>
					{
						vTaskIncrementTick();
 801af60:	f000 f92c 	bl	801b1bc <vTaskIncrementTick>
						--uxMissedTicks;
 801af64:	f640 3360 	movw	r3, #2912	; 0xb60
 801af68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801af6c:	681b      	ldr	r3, [r3, #0]
 801af6e:	f103 32ff 	add.w	r2, r3, #4294967295
 801af72:	f640 3360 	movw	r3, #2912	; 0xb60
 801af76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801af7a:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 801af7c:	f640 3360 	movw	r3, #2912	; 0xb60
 801af80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801af84:	681b      	ldr	r3, [r3, #0]
 801af86:	2b00      	cmp	r3, #0
 801af88:	d1ea      	bne.n	801af60 <xTaskResumeAll+0xe8>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 801af8a:	f04f 0301 	mov.w	r3, #1
 801af8e:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 801af90:	683b      	ldr	r3, [r7, #0]
 801af92:	2b01      	cmp	r3, #1
 801af94:	d006      	beq.n	801afa4 <xTaskResumeAll+0x12c>
 801af96:	f640 3364 	movw	r3, #2916	; 0xb64
 801af9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801af9e:	681b      	ldr	r3, [r3, #0]
 801afa0:	2b01      	cmp	r3, #1
 801afa2:	d10b      	bne.n	801afbc <xTaskResumeAll+0x144>
				{
					xAlreadyYielded = pdTRUE;
 801afa4:	f04f 0301 	mov.w	r3, #1
 801afa8:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
 801afaa:	f640 3364 	movw	r3, #2916	; 0xb64
 801afae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801afb2:	f04f 0200 	mov.w	r2, #0
 801afb6:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 801afb8:	f7fe fdec 	bl	8019b94 <vPortYieldFromISR>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 801afbc:	f7fe fe0c 	bl	8019bd8 <vPortExitCritical>

	return xAlreadyYielded;
 801afc0:	687b      	ldr	r3, [r7, #4]
}
 801afc2:	4618      	mov	r0, r3
 801afc4:	f107 070c 	add.w	r7, r7, #12
 801afc8:	46bd      	mov	sp, r7
 801afca:	bd90      	pop	{r4, r7, pc}

0801afcc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
 801afcc:	b580      	push	{r7, lr}
 801afce:	b082      	sub	sp, #8
 801afd0:	af00      	add	r7, sp, #0
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
 801afd2:	f7fe fdeb 	bl	8019bac <vPortEnterCritical>
	{
		xTicks = xTickCount;
 801afd6:	f640 334c 	movw	r3, #2892	; 0xb4c
 801afda:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801afde:	681b      	ldr	r3, [r3, #0]
 801afe0:	607b      	str	r3, [r7, #4]
	}
	taskEXIT_CRITICAL();
 801afe2:	f7fe fdf9 	bl	8019bd8 <vPortExitCritical>

	return xTicks;
 801afe6:	687b      	ldr	r3, [r7, #4]
}
 801afe8:	4618      	mov	r0, r3
 801afea:	f107 0708 	add.w	r7, r7, #8
 801afee:	46bd      	mov	sp, r7
 801aff0:	bd80      	pop	{r7, pc}
 801aff2:	bf00      	nop

0801aff4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
 801aff4:	b480      	push	{r7}
 801aff6:	b083      	sub	sp, #12
 801aff8:	af00      	add	r7, sp, #0
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 801affa:	f04f 0300 	mov.w	r3, #0
 801affe:	607b      	str	r3, [r7, #4]
 801b000:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 801b004:	f380 8811 	msr	BASEPRI, r0
	xReturn = xTickCount;
 801b008:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b00c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b010:	681b      	ldr	r3, [r3, #0]
 801b012:	603b      	str	r3, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 801b014:	f04f 0000 	mov.w	r0, #0
 801b018:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
 801b01c:	683b      	ldr	r3, [r7, #0]
}
 801b01e:	4618      	mov	r0, r3
 801b020:	f107 070c 	add.w	r7, r7, #12
 801b024:	46bd      	mov	sp, r7
 801b026:	bc80      	pop	{r7}
 801b028:	4770      	bx	lr
 801b02a:	bf00      	nop

0801b02c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
 801b02c:	b480      	push	{r7}
 801b02e:	af00      	add	r7, sp, #0
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
 801b030:	f640 3348 	movw	r3, #2888	; 0xb48
 801b034:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b038:	681b      	ldr	r3, [r3, #0]
}
 801b03a:	4618      	mov	r0, r3
 801b03c:	46bd      	mov	sp, r7
 801b03e:	bc80      	pop	{r7}
 801b040:	4770      	bx	lr
 801b042:	bf00      	nop

0801b044 <vTaskGetRunTimeStats>:
/*----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
	{
 801b044:	b590      	push	{r4, r7, lr}
 801b046:	b085      	sub	sp, #20
 801b048:	af00      	add	r7, sp, #0
 801b04a:	6078      	str	r0, [r7, #4]
	unsigned long ulTotalRunTime;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
 801b04c:	f7ff ff02 	bl	801ae54 <vTaskSuspendAll>
		{
			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
			#else
				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 801b050:	f007 fd10 	bl	8022a74 <get_us_time>
 801b054:	4602      	mov	r2, r0
 801b056:	460b      	mov	r3, r1
 801b058:	4613      	mov	r3, r2
 801b05a:	60bb      	str	r3, [r7, #8]
			#endif

			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
			ulTotalRunTime /= 100UL;
 801b05c:	68ba      	ldr	r2, [r7, #8]
 801b05e:	f248 531f 	movw	r3, #34079	; 0x851f
 801b062:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 801b066:	fba3 1302 	umull	r1, r3, r3, r2
 801b06a:	ea4f 1353 	mov.w	r3, r3, lsr #5
 801b06e:	60bb      	str	r3, [r7, #8]
			
			/* Run through all the lists that could potentially contain a TCB,
			generating a table of run timer percentages in the provided
			buffer. */

			*pcWriteBuffer = ( signed char ) 0x00;
 801b070:	687b      	ldr	r3, [r7, #4]
 801b072:	f04f 0200 	mov.w	r2, #0
 801b076:	701a      	strb	r2, [r3, #0]
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 801b078:	687c      	ldr	r4, [r7, #4]
 801b07a:	4620      	mov	r0, r4
 801b07c:	f00b fe6e 	bl	8026d5c <strlen>
 801b080:	4603      	mov	r3, r0
 801b082:	18e2      	adds	r2, r4, r3
 801b084:	f64b 3308 	movw	r3, #47880	; 0xbb08
 801b088:	f6c0 0302 	movt	r3, #2050	; 0x802
 801b08c:	4611      	mov	r1, r2
 801b08e:	461a      	mov	r2, r3
 801b090:	f04f 0303 	mov.w	r3, #3
 801b094:	4608      	mov	r0, r1
 801b096:	4611      	mov	r1, r2
 801b098:	461a      	mov	r2, r3
 801b09a:	f00a f93d 	bl	8025318 <memcpy>

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 801b09e:	f640 3350 	movw	r3, #2896	; 0xb50
 801b0a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b0a6:	681b      	ldr	r3, [r3, #0]
 801b0a8:	f103 0301 	add.w	r3, r3, #1
 801b0ac:	60fb      	str	r3, [r7, #12]

			do
			{
				uxQueue--;
 801b0ae:	68fb      	ldr	r3, [r7, #12]
 801b0b0:	f103 33ff 	add.w	r3, r3, #4294967295
 801b0b4:	60fb      	str	r3, [r7, #12]

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 801b0b6:	68fa      	ldr	r2, [r7, #12]
 801b0b8:	4613      	mov	r3, r2
 801b0ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b0be:	189b      	adds	r3, r3, r2
 801b0c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b0c4:	461a      	mov	r2, r3
 801b0c6:	f640 230c 	movw	r3, #2572	; 0xa0c
 801b0ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b0ce:	18d3      	adds	r3, r2, r3
 801b0d0:	681b      	ldr	r3, [r3, #0]
 801b0d2:	2b00      	cmp	r3, #0
 801b0d4:	d013      	beq.n	801b0fe <vTaskGetRunTimeStats+0xba>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime, tskREADY_CHAR );
 801b0d6:	68fa      	ldr	r2, [r7, #12]
 801b0d8:	4613      	mov	r3, r2
 801b0da:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b0de:	189b      	adds	r3, r3, r2
 801b0e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b0e4:	461a      	mov	r2, r3
 801b0e6:	f640 230c 	movw	r3, #2572	; 0xa0c
 801b0ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b0ee:	18d3      	adds	r3, r2, r3
 801b0f0:	6878      	ldr	r0, [r7, #4]
 801b0f2:	4619      	mov	r1, r3
 801b0f4:	68ba      	ldr	r2, [r7, #8]
 801b0f6:	f04f 0352 	mov.w	r3, #82	; 0x52
 801b0fa:	f000 fcc3 	bl	801ba84 <prvGenerateRunTimeStatsForTasksInList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 801b0fe:	68fb      	ldr	r3, [r7, #12]
 801b100:	2b00      	cmp	r3, #0
 801b102:	d1d4      	bne.n	801b0ae <vTaskGetRunTimeStats+0x6a>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 801b104:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b108:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b10c:	681b      	ldr	r3, [r3, #0]
 801b10e:	681b      	ldr	r3, [r3, #0]
 801b110:	2b00      	cmp	r3, #0
 801b112:	d00b      	beq.n	801b12c <vTaskGetRunTimeStats+0xe8>
			{
				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRunTime, tskBLOCKED_CHAR );
 801b114:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b118:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b11c:	681b      	ldr	r3, [r3, #0]
 801b11e:	6878      	ldr	r0, [r7, #4]
 801b120:	4619      	mov	r1, r3
 801b122:	68ba      	ldr	r2, [r7, #8]
 801b124:	f04f 0342 	mov.w	r3, #66	; 0x42
 801b128:	f000 fcac 	bl	801ba84 <prvGenerateRunTimeStatsForTasksInList>
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 801b12c:	f640 3300 	movw	r3, #2816	; 0xb00
 801b130:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b134:	681b      	ldr	r3, [r3, #0]
 801b136:	681b      	ldr	r3, [r3, #0]
 801b138:	2b00      	cmp	r3, #0
 801b13a:	d00b      	beq.n	801b154 <vTaskGetRunTimeStats+0x110>
			{
				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ulTotalRunTime, tskBLOCKED_CHAR );
 801b13c:	f640 3300 	movw	r3, #2816	; 0xb00
 801b140:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b144:	681b      	ldr	r3, [r3, #0]
 801b146:	6878      	ldr	r0, [r7, #4]
 801b148:	4619      	mov	r1, r3
 801b14a:	68ba      	ldr	r2, [r7, #8]
 801b14c:	f04f 0342 	mov.w	r3, #66	; 0x42
 801b150:	f000 fc98 	bl	801ba84 <prvGenerateRunTimeStatsForTasksInList>
			}

			#if ( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 801b154:	f640 3318 	movw	r3, #2840	; 0xb18
 801b158:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b15c:	681b      	ldr	r3, [r3, #0]
 801b15e:	2b00      	cmp	r3, #0
 801b160:	d009      	beq.n	801b176 <vTaskGetRunTimeStats+0x132>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTime, tskDELETED_CHAR );
 801b162:	6878      	ldr	r0, [r7, #4]
 801b164:	f640 3118 	movw	r1, #2840	; 0xb18
 801b168:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801b16c:	68ba      	ldr	r2, [r7, #8]
 801b16e:	f04f 0344 	mov.w	r3, #68	; 0x44
 801b172:	f000 fc87 	bl	801ba84 <prvGenerateRunTimeStatsForTasksInList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 801b176:	f640 3330 	movw	r3, #2864	; 0xb30
 801b17a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b17e:	681b      	ldr	r3, [r3, #0]
 801b180:	2b00      	cmp	r3, #0
 801b182:	d009      	beq.n	801b198 <vTaskGetRunTimeStats+0x154>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime, tskSUSPENDED_CHAR );
 801b184:	6878      	ldr	r0, [r7, #4]
 801b186:	f640 3130 	movw	r1, #2864	; 0xb30
 801b18a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801b18e:	68ba      	ldr	r2, [r7, #8]
 801b190:	f04f 0353 	mov.w	r3, #83	; 0x53
 801b194:	f000 fc76 	bl	801ba84 <prvGenerateRunTimeStatsForTasksInList>
				}
			}
			#endif
		}
		xTaskResumeAll();
 801b198:	f7ff fe6e 	bl	801ae78 <xTaskResumeAll>
	}
 801b19c:	f107 0714 	add.w	r7, r7, #20
 801b1a0:	46bd      	mov	sp, r7
 801b1a2:	bd90      	pop	{r4, r7, pc}

0801b1a4 <xTaskGetIdleTaskHandle>:
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )

	xTaskHandle xTaskGetIdleTaskHandle( void )
	{
 801b1a4:	b480      	push	{r7}
 801b1a6:	af00      	add	r7, sp, #0
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
 801b1a8:	f640 3344 	movw	r3, #2884	; 0xb44
 801b1ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b1b0:	681b      	ldr	r3, [r3, #0]
	}
 801b1b2:	4618      	mov	r0, r3
 801b1b4:	46bd      	mov	sp, r7
 801b1b6:	bc80      	pop	{r7}
 801b1b8:	4770      	bx	lr
 801b1ba:	bf00      	nop

0801b1bc <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 801b1bc:	b580      	push	{r7, lr}
 801b1be:	b084      	sub	sp, #16
 801b1c0:	af00      	add	r7, sp, #0
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 801b1c2:	f640 335c 	movw	r3, #2908	; 0xb5c
 801b1c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b1ca:	681b      	ldr	r3, [r3, #0]
 801b1cc:	2b00      	cmp	r3, #0
 801b1ce:	f040 80c0 	bne.w	801b352 <vTaskIncrementTick+0x196>
	{
		++xTickCount;
 801b1d2:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b1d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b1da:	681b      	ldr	r3, [r3, #0]
 801b1dc:	f103 0201 	add.w	r2, r3, #1
 801b1e0:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b1e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b1e8:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
 801b1ea:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b1ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b1f2:	681b      	ldr	r3, [r3, #0]
 801b1f4:	2b00      	cmp	r3, #0
 801b1f6:	d140      	bne.n	801b27a <vTaskIncrementTick+0xbe>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
 801b1f8:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b1fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b200:	681b      	ldr	r3, [r3, #0]
 801b202:	60fb      	str	r3, [r7, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 801b204:	f640 3300 	movw	r3, #2816	; 0xb00
 801b208:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b20c:	681a      	ldr	r2, [r3, #0]
 801b20e:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b212:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b216:	601a      	str	r2, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
 801b218:	f640 3300 	movw	r3, #2816	; 0xb00
 801b21c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b220:	68fa      	ldr	r2, [r7, #12]
 801b222:	601a      	str	r2, [r3, #0]
			xNumOfOverflows++;
 801b224:	f640 3368 	movw	r3, #2920	; 0xb68
 801b228:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b22c:	681b      	ldr	r3, [r3, #0]
 801b22e:	f103 0201 	add.w	r2, r3, #1
 801b232:	f640 3368 	movw	r3, #2920	; 0xb68
 801b236:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b23a:	601a      	str	r2, [r3, #0]
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801b23c:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b240:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b244:	681b      	ldr	r3, [r3, #0]
 801b246:	681b      	ldr	r3, [r3, #0]
 801b248:	2b00      	cmp	r3, #0
 801b24a:	d107      	bne.n	801b25c <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 801b24c:	f240 0384 	movw	r3, #132	; 0x84
 801b250:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b254:	f04f 32ff 	mov.w	r2, #4294967295
 801b258:	601a      	str	r2, [r3, #0]
 801b25a:	e00e      	b.n	801b27a <vTaskIncrementTick+0xbe>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 801b25c:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b260:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b264:	681b      	ldr	r3, [r3, #0]
 801b266:	68db      	ldr	r3, [r3, #12]
 801b268:	68db      	ldr	r3, [r3, #12]
 801b26a:	60bb      	str	r3, [r7, #8]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 801b26c:	68bb      	ldr	r3, [r7, #8]
 801b26e:	685a      	ldr	r2, [r3, #4]
 801b270:	f240 0384 	movw	r3, #132	; 0x84
 801b274:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b278:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 801b27a:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b27e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b282:	681a      	ldr	r2, [r3, #0]
 801b284:	f240 0384 	movw	r3, #132	; 0x84
 801b288:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b28c:	681b      	ldr	r3, [r3, #0]
 801b28e:	429a      	cmp	r2, r3
 801b290:	d36b      	bcc.n	801b36a <vTaskIncrementTick+0x1ae>
 801b292:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b296:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b29a:	681b      	ldr	r3, [r3, #0]
 801b29c:	681b      	ldr	r3, [r3, #0]
 801b29e:	2b00      	cmp	r3, #0
 801b2a0:	d107      	bne.n	801b2b2 <vTaskIncrementTick+0xf6>
 801b2a2:	f240 0384 	movw	r3, #132	; 0x84
 801b2a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b2aa:	f04f 32ff 	mov.w	r2, #4294967295
 801b2ae:	601a      	str	r2, [r3, #0]
 801b2b0:	e05b      	b.n	801b36a <vTaskIncrementTick+0x1ae>
 801b2b2:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b2b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b2ba:	681b      	ldr	r3, [r3, #0]
 801b2bc:	68db      	ldr	r3, [r3, #12]
 801b2be:	68db      	ldr	r3, [r3, #12]
 801b2c0:	60bb      	str	r3, [r7, #8]
 801b2c2:	68bb      	ldr	r3, [r7, #8]
 801b2c4:	685b      	ldr	r3, [r3, #4]
 801b2c6:	607b      	str	r3, [r7, #4]
 801b2c8:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b2cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b2d0:	681a      	ldr	r2, [r3, #0]
 801b2d2:	687b      	ldr	r3, [r7, #4]
 801b2d4:	429a      	cmp	r2, r3
 801b2d6:	d206      	bcs.n	801b2e6 <vTaskIncrementTick+0x12a>
 801b2d8:	f240 0384 	movw	r3, #132	; 0x84
 801b2dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b2e0:	687a      	ldr	r2, [r7, #4]
 801b2e2:	601a      	str	r2, [r3, #0]
 801b2e4:	e041      	b.n	801b36a <vTaskIncrementTick+0x1ae>
 801b2e6:	68bb      	ldr	r3, [r7, #8]
 801b2e8:	f103 0304 	add.w	r3, r3, #4
 801b2ec:	4618      	mov	r0, r3
 801b2ee:	f7fe fd8d 	bl	8019e0c <vListRemove>
 801b2f2:	68bb      	ldr	r3, [r7, #8]
 801b2f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801b2f6:	2b00      	cmp	r3, #0
 801b2f8:	d005      	beq.n	801b306 <vTaskIncrementTick+0x14a>
 801b2fa:	68bb      	ldr	r3, [r7, #8]
 801b2fc:	f103 0318 	add.w	r3, r3, #24
 801b300:	4618      	mov	r0, r3
 801b302:	f7fe fd83 	bl	8019e0c <vListRemove>
 801b306:	68bb      	ldr	r3, [r7, #8]
 801b308:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b30a:	f640 3354 	movw	r3, #2900	; 0xb54
 801b30e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b312:	681b      	ldr	r3, [r3, #0]
 801b314:	429a      	cmp	r2, r3
 801b316:	d906      	bls.n	801b326 <vTaskIncrementTick+0x16a>
 801b318:	68bb      	ldr	r3, [r7, #8]
 801b31a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b31c:	f640 3354 	movw	r3, #2900	; 0xb54
 801b320:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b324:	601a      	str	r2, [r3, #0]
 801b326:	68bb      	ldr	r3, [r7, #8]
 801b328:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b32a:	4613      	mov	r3, r2
 801b32c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b330:	189b      	adds	r3, r3, r2
 801b332:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b336:	461a      	mov	r2, r3
 801b338:	f640 230c 	movw	r3, #2572	; 0xa0c
 801b33c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b340:	18d2      	adds	r2, r2, r3
 801b342:	68bb      	ldr	r3, [r7, #8]
 801b344:	f103 0304 	add.w	r3, r3, #4
 801b348:	4610      	mov	r0, r2
 801b34a:	4619      	mov	r1, r3
 801b34c:	f7fe fcf8 	bl	8019d40 <vListInsertEnd>
 801b350:	e79f      	b.n	801b292 <vTaskIncrementTick+0xd6>
	}
	else
	{
		++uxMissedTicks;
 801b352:	f640 3360 	movw	r3, #2912	; 0xb60
 801b356:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b35a:	681b      	ldr	r3, [r3, #0]
 801b35c:	f103 0201 	add.w	r2, r3, #1
 801b360:	f640 3360 	movw	r3, #2912	; 0xb60
 801b364:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b368:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 801b36a:	f107 0710 	add.w	r7, r7, #16
 801b36e:	46bd      	mov	sp, r7
 801b370:	bd80      	pop	{r7, pc}
 801b372:	bf00      	nop

0801b374 <vTaskSetApplicationTaskTag>:
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG == 1 )

	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
	{
 801b374:	b580      	push	{r7, lr}
 801b376:	b084      	sub	sp, #16
 801b378:	af00      	add	r7, sp, #0
 801b37a:	6078      	str	r0, [r7, #4]
 801b37c:	6039      	str	r1, [r7, #0]
	tskTCB *xTCB;

		/* If xTask is NULL then we are setting our own task hook. */
		if( xTask == NULL )
 801b37e:	687b      	ldr	r3, [r7, #4]
 801b380:	2b00      	cmp	r3, #0
 801b382:	d106      	bne.n	801b392 <vTaskSetApplicationTaskTag+0x1e>
		{
			xTCB = ( tskTCB * ) pxCurrentTCB;
 801b384:	f640 2308 	movw	r3, #2568	; 0xa08
 801b388:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b38c:	681b      	ldr	r3, [r3, #0]
 801b38e:	60fb      	str	r3, [r7, #12]
 801b390:	e001      	b.n	801b396 <vTaskSetApplicationTaskTag+0x22>
		}
		else
		{
			xTCB = ( tskTCB * ) xTask;
 801b392:	687b      	ldr	r3, [r7, #4]
 801b394:	60fb      	str	r3, [r7, #12]
		}

		/* Save the hook function in the TCB.  A critical section is required as
		the value can be accessed from an interrupt. */
		taskENTER_CRITICAL();
 801b396:	f7fe fc09 	bl	8019bac <vPortEnterCritical>
			xTCB->pxTaskTag = pxHookFunction;
 801b39a:	68fb      	ldr	r3, [r7, #12]
 801b39c:	683a      	ldr	r2, [r7, #0]
 801b39e:	649a      	str	r2, [r3, #72]	; 0x48
		taskEXIT_CRITICAL();
 801b3a0:	f7fe fc1a 	bl	8019bd8 <vPortExitCritical>
	}
 801b3a4:	f107 0710 	add.w	r7, r7, #16
 801b3a8:	46bd      	mov	sp, r7
 801b3aa:	bd80      	pop	{r7, pc}

0801b3ac <xTaskGetApplicationTaskTag>:
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG == 1 )

	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
	{
 801b3ac:	b580      	push	{r7, lr}
 801b3ae:	b084      	sub	sp, #16
 801b3b0:	af00      	add	r7, sp, #0
 801b3b2:	6078      	str	r0, [r7, #4]
	tskTCB *xTCB;
	pdTASK_HOOK_CODE xReturn;

		/* If xTask is NULL then we are setting our own task hook. */
		if( xTask == NULL )
 801b3b4:	687b      	ldr	r3, [r7, #4]
 801b3b6:	2b00      	cmp	r3, #0
 801b3b8:	d106      	bne.n	801b3c8 <xTaskGetApplicationTaskTag+0x1c>
		{
			xTCB = ( tskTCB * ) pxCurrentTCB;
 801b3ba:	f640 2308 	movw	r3, #2568	; 0xa08
 801b3be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b3c2:	681b      	ldr	r3, [r3, #0]
 801b3c4:	60fb      	str	r3, [r7, #12]
 801b3c6:	e001      	b.n	801b3cc <xTaskGetApplicationTaskTag+0x20>
		}
		else
		{
			xTCB = ( tskTCB * ) xTask;
 801b3c8:	687b      	ldr	r3, [r7, #4]
 801b3ca:	60fb      	str	r3, [r7, #12]
		}

		/* Save the hook function in the TCB.  A critical section is required as
		the value can be accessed from an interrupt. */
		taskENTER_CRITICAL();
 801b3cc:	f7fe fbee 	bl	8019bac <vPortEnterCritical>
			xReturn = xTCB->pxTaskTag;
 801b3d0:	68fb      	ldr	r3, [r7, #12]
 801b3d2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801b3d4:	60bb      	str	r3, [r7, #8]
		taskEXIT_CRITICAL();
 801b3d6:	f7fe fbff 	bl	8019bd8 <vPortExitCritical>

		return xReturn;
 801b3da:	68bb      	ldr	r3, [r7, #8]
	}
 801b3dc:	4618      	mov	r0, r3
 801b3de:	f107 0710 	add.w	r7, r7, #16
 801b3e2:	46bd      	mov	sp, r7
 801b3e4:	bd80      	pop	{r7, pc}
 801b3e6:	bf00      	nop

0801b3e8 <xTaskCallApplicationTaskHook>:
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG == 1 )

	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
	{
 801b3e8:	b580      	push	{r7, lr}
 801b3ea:	b084      	sub	sp, #16
 801b3ec:	af00      	add	r7, sp, #0
 801b3ee:	6078      	str	r0, [r7, #4]
 801b3f0:	6039      	str	r1, [r7, #0]
	tskTCB *xTCB;
	portBASE_TYPE xReturn;

		/* If xTask is NULL then we are calling our own task hook. */
		if( xTask == NULL )
 801b3f2:	687b      	ldr	r3, [r7, #4]
 801b3f4:	2b00      	cmp	r3, #0
 801b3f6:	d106      	bne.n	801b406 <xTaskCallApplicationTaskHook+0x1e>
		{
			xTCB = ( tskTCB * ) pxCurrentTCB;
 801b3f8:	f640 2308 	movw	r3, #2568	; 0xa08
 801b3fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b400:	681b      	ldr	r3, [r3, #0]
 801b402:	60fb      	str	r3, [r7, #12]
 801b404:	e001      	b.n	801b40a <xTaskCallApplicationTaskHook+0x22>
		}
		else
		{
			xTCB = ( tskTCB * ) xTask;
 801b406:	687b      	ldr	r3, [r7, #4]
 801b408:	60fb      	str	r3, [r7, #12]
		}

		if( xTCB->pxTaskTag != NULL )
 801b40a:	68fb      	ldr	r3, [r7, #12]
 801b40c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801b40e:	2b00      	cmp	r3, #0
 801b410:	d006      	beq.n	801b420 <xTaskCallApplicationTaskHook+0x38>
		{
			xReturn = xTCB->pxTaskTag( pvParameter );
 801b412:	68fb      	ldr	r3, [r7, #12]
 801b414:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801b416:	6838      	ldr	r0, [r7, #0]
 801b418:	4798      	blx	r3
 801b41a:	4603      	mov	r3, r0
 801b41c:	60bb      	str	r3, [r7, #8]
 801b41e:	e002      	b.n	801b426 <xTaskCallApplicationTaskHook+0x3e>
		}
		else
		{
			xReturn = pdFAIL;
 801b420:	f04f 0300 	mov.w	r3, #0
 801b424:	60bb      	str	r3, [r7, #8]
		}

		return xReturn;
 801b426:	68bb      	ldr	r3, [r7, #8]
	}
 801b428:	4618      	mov	r0, r3
 801b42a:	f107 0710 	add.w	r7, r7, #16
 801b42e:	46bd      	mov	sp, r7
 801b430:	bd80      	pop	{r7, pc}
 801b432:	bf00      	nop

0801b434 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 801b434:	b580      	push	{r7, lr}
 801b436:	b082      	sub	sp, #8
 801b438:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 801b43a:	f640 335c 	movw	r3, #2908	; 0xb5c
 801b43e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b442:	681b      	ldr	r3, [r3, #0]
 801b444:	2b00      	cmp	r3, #0
 801b446:	d007      	beq.n	801b458 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 801b448:	f640 3364 	movw	r3, #2916	; 0xb64
 801b44c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b450:	f04f 0201 	mov.w	r2, #1
 801b454:	601a      	str	r2, [r3, #0]
 801b456:	e089      	b.n	801b56c <vTaskSwitchContext+0x138>
			unsigned long ulTempCounter;
			
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 801b458:	f007 fb0c 	bl	8022a74 <get_us_time>
 801b45c:	4602      	mov	r2, r0
 801b45e:	460b      	mov	r3, r1
 801b460:	4613      	mov	r3, r2
 801b462:	607b      	str	r3, [r7, #4]
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 801b464:	f640 2308 	movw	r3, #2568	; 0xa08
 801b468:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b46c:	681a      	ldr	r2, [r3, #0]
 801b46e:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 801b470:	f640 33a4 	movw	r3, #2980	; 0xba4
 801b474:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b478:	681b      	ldr	r3, [r3, #0]
 801b47a:	6878      	ldr	r0, [r7, #4]
 801b47c:	1ac3      	subs	r3, r0, r3
 801b47e:	18cb      	adds	r3, r1, r3
 801b480:	64d3      	str	r3, [r2, #76]	; 0x4c
				ulTaskSwitchedInTime = ulTempCounter;
 801b482:	f640 33a4 	movw	r3, #2980	; 0xba4
 801b486:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b48a:	687a      	ldr	r2, [r7, #4]
 801b48c:	601a      	str	r2, [r3, #0]
		}
		#endif
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 801b48e:	f640 2308 	movw	r3, #2568	; 0xa08
 801b492:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b496:	681b      	ldr	r3, [r3, #0]
 801b498:	681a      	ldr	r2, [r3, #0]
 801b49a:	f640 2308 	movw	r3, #2568	; 0xa08
 801b49e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b4a2:	681b      	ldr	r3, [r3, #0]
 801b4a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801b4a6:	429a      	cmp	r2, r3
 801b4a8:	d81d      	bhi.n	801b4e6 <vTaskSwitchContext+0xb2>
 801b4aa:	f640 2308 	movw	r3, #2568	; 0xa08
 801b4ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b4b2:	681a      	ldr	r2, [r3, #0]
 801b4b4:	f640 2308 	movw	r3, #2568	; 0xa08
 801b4b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b4bc:	681b      	ldr	r3, [r3, #0]
 801b4be:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801b4c2:	4610      	mov	r0, r2
 801b4c4:	4619      	mov	r1, r3
 801b4c6:	f006 ff23 	bl	8022310 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 801b4ca:	e00c      	b.n	801b4e6 <vTaskSwitchContext+0xb2>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 801b4cc:	f640 3354 	movw	r3, #2900	; 0xb54
 801b4d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b4d4:	681b      	ldr	r3, [r3, #0]
 801b4d6:	f103 32ff 	add.w	r2, r3, #4294967295
 801b4da:	f640 3354 	movw	r3, #2900	; 0xb54
 801b4de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b4e2:	601a      	str	r2, [r3, #0]
 801b4e4:	e000      	b.n	801b4e8 <vTaskSwitchContext+0xb4>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 801b4e6:	bf00      	nop
 801b4e8:	f640 3354 	movw	r3, #2900	; 0xb54
 801b4ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b4f0:	681a      	ldr	r2, [r3, #0]
 801b4f2:	4613      	mov	r3, r2
 801b4f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b4f8:	189b      	adds	r3, r3, r2
 801b4fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b4fe:	461a      	mov	r2, r3
 801b500:	f640 230c 	movw	r3, #2572	; 0xa0c
 801b504:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b508:	18d3      	adds	r3, r2, r3
 801b50a:	681b      	ldr	r3, [r3, #0]
 801b50c:	2b00      	cmp	r3, #0
 801b50e:	d0dd      	beq.n	801b4cc <vTaskSwitchContext+0x98>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 801b510:	f640 3354 	movw	r3, #2900	; 0xb54
 801b514:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b518:	681a      	ldr	r2, [r3, #0]
 801b51a:	4613      	mov	r3, r2
 801b51c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b520:	189b      	adds	r3, r3, r2
 801b522:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b526:	461a      	mov	r2, r3
 801b528:	f640 230c 	movw	r3, #2572	; 0xa0c
 801b52c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b530:	18d3      	adds	r3, r2, r3
 801b532:	603b      	str	r3, [r7, #0]
 801b534:	683b      	ldr	r3, [r7, #0]
 801b536:	685b      	ldr	r3, [r3, #4]
 801b538:	685b      	ldr	r3, [r3, #4]
 801b53a:	461a      	mov	r2, r3
 801b53c:	683b      	ldr	r3, [r7, #0]
 801b53e:	605a      	str	r2, [r3, #4]
 801b540:	683b      	ldr	r3, [r7, #0]
 801b542:	685a      	ldr	r2, [r3, #4]
 801b544:	683b      	ldr	r3, [r7, #0]
 801b546:	f103 0308 	add.w	r3, r3, #8
 801b54a:	429a      	cmp	r2, r3
 801b54c:	d105      	bne.n	801b55a <vTaskSwitchContext+0x126>
 801b54e:	683b      	ldr	r3, [r7, #0]
 801b550:	685b      	ldr	r3, [r3, #4]
 801b552:	685b      	ldr	r3, [r3, #4]
 801b554:	461a      	mov	r2, r3
 801b556:	683b      	ldr	r3, [r7, #0]
 801b558:	605a      	str	r2, [r3, #4]
 801b55a:	683b      	ldr	r3, [r7, #0]
 801b55c:	685b      	ldr	r3, [r3, #4]
 801b55e:	68db      	ldr	r3, [r3, #12]
 801b560:	461a      	mov	r2, r3
 801b562:	f640 2308 	movw	r3, #2568	; 0xa08
 801b566:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b56a:	601a      	str	r2, [r3, #0]
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
 801b56c:	f107 0708 	add.w	r7, r7, #8
 801b570:	46bd      	mov	sp, r7
 801b572:	bd80      	pop	{r7, pc}

0801b574 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
 801b574:	b580      	push	{r7, lr}
 801b576:	b084      	sub	sp, #16
 801b578:	af00      	add	r7, sp, #0
 801b57a:	6078      	str	r0, [r7, #4]
 801b57c:	6039      	str	r1, [r7, #0]
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 801b57e:	f640 2308 	movw	r3, #2568	; 0xa08
 801b582:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b586:	681b      	ldr	r3, [r3, #0]
 801b588:	f103 0318 	add.w	r3, r3, #24
 801b58c:	6878      	ldr	r0, [r7, #4]
 801b58e:	4619      	mov	r1, r3
 801b590:	f7fe fc00 	bl	8019d94 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 801b594:	f640 2308 	movw	r3, #2568	; 0xa08
 801b598:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b59c:	681b      	ldr	r3, [r3, #0]
 801b59e:	f103 0304 	add.w	r3, r3, #4
 801b5a2:	4618      	mov	r0, r3
 801b5a4:	f7fe fc32 	bl	8019e0c <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 801b5a8:	683b      	ldr	r3, [r7, #0]
 801b5aa:	f1b3 3fff 	cmp.w	r3, #4294967295
 801b5ae:	d10e      	bne.n	801b5ce <vTaskPlaceOnEventList+0x5a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 801b5b0:	f640 2308 	movw	r3, #2568	; 0xa08
 801b5b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b5b8:	681b      	ldr	r3, [r3, #0]
 801b5ba:	f103 0304 	add.w	r3, r3, #4
 801b5be:	f640 3030 	movw	r0, #2864	; 0xb30
 801b5c2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b5c6:	4619      	mov	r1, r3
 801b5c8:	f7fe fbba 	bl	8019d40 <vListInsertEnd>
 801b5cc:	e00a      	b.n	801b5e4 <vTaskPlaceOnEventList+0x70>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
 801b5ce:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b5d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b5d6:	681a      	ldr	r2, [r3, #0]
 801b5d8:	683b      	ldr	r3, [r7, #0]
 801b5da:	18d3      	adds	r3, r2, r3
 801b5dc:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 801b5de:	68f8      	ldr	r0, [r7, #12]
 801b5e0:	f000 f9d0 	bl	801b984 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
 801b5e4:	f107 0710 	add.w	r7, r7, #16
 801b5e8:	46bd      	mov	sp, r7
 801b5ea:	bd80      	pop	{r7, pc}

0801b5ec <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 801b5ec:	b580      	push	{r7, lr}
 801b5ee:	b084      	sub	sp, #16
 801b5f0:	af00      	add	r7, sp, #0
 801b5f2:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 801b5f4:	687b      	ldr	r3, [r7, #4]
 801b5f6:	68db      	ldr	r3, [r3, #12]
 801b5f8:	68db      	ldr	r3, [r3, #12]
 801b5fa:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 801b5fc:	68bb      	ldr	r3, [r7, #8]
 801b5fe:	f103 0318 	add.w	r3, r3, #24
 801b602:	4618      	mov	r0, r3
 801b604:	f7fe fc02 	bl	8019e0c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 801b608:	f640 335c 	movw	r3, #2908	; 0xb5c
 801b60c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b610:	681b      	ldr	r3, [r3, #0]
 801b612:	2b00      	cmp	r3, #0
 801b614:	d12b      	bne.n	801b66e <xTaskRemoveFromEventList+0x82>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 801b616:	68bb      	ldr	r3, [r7, #8]
 801b618:	f103 0304 	add.w	r3, r3, #4
 801b61c:	4618      	mov	r0, r3
 801b61e:	f7fe fbf5 	bl	8019e0c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
 801b622:	68bb      	ldr	r3, [r7, #8]
 801b624:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b626:	f640 3354 	movw	r3, #2900	; 0xb54
 801b62a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b62e:	681b      	ldr	r3, [r3, #0]
 801b630:	429a      	cmp	r2, r3
 801b632:	d906      	bls.n	801b642 <xTaskRemoveFromEventList+0x56>
 801b634:	68bb      	ldr	r3, [r7, #8]
 801b636:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b638:	f640 3354 	movw	r3, #2900	; 0xb54
 801b63c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b640:	601a      	str	r2, [r3, #0]
 801b642:	68bb      	ldr	r3, [r7, #8]
 801b644:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b646:	4613      	mov	r3, r2
 801b648:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b64c:	189b      	adds	r3, r3, r2
 801b64e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b652:	461a      	mov	r2, r3
 801b654:	f640 230c 	movw	r3, #2572	; 0xa0c
 801b658:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b65c:	18d2      	adds	r2, r2, r3
 801b65e:	68bb      	ldr	r3, [r7, #8]
 801b660:	f103 0304 	add.w	r3, r3, #4
 801b664:	4610      	mov	r0, r2
 801b666:	4619      	mov	r1, r3
 801b668:	f7fe fb6a 	bl	8019d40 <vListInsertEnd>
 801b66c:	e009      	b.n	801b682 <xTaskRemoveFromEventList+0x96>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 801b66e:	68bb      	ldr	r3, [r7, #8]
 801b670:	f103 0318 	add.w	r3, r3, #24
 801b674:	f640 3004 	movw	r0, #2820	; 0xb04
 801b678:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b67c:	4619      	mov	r1, r3
 801b67e:	f7fe fb5f 	bl	8019d40 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801b682:	68bb      	ldr	r3, [r7, #8]
 801b684:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b686:	f640 2308 	movw	r3, #2568	; 0xa08
 801b68a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b68e:	681b      	ldr	r3, [r3, #0]
 801b690:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b692:	429a      	cmp	r2, r3
 801b694:	d303      	bcc.n	801b69e <xTaskRemoveFromEventList+0xb2>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 801b696:	f04f 0301 	mov.w	r3, #1
 801b69a:	60fb      	str	r3, [r7, #12]
 801b69c:	e002      	b.n	801b6a4 <xTaskRemoveFromEventList+0xb8>
	}
	else
	{
		xReturn = pdFALSE;
 801b69e:	f04f 0300 	mov.w	r3, #0
 801b6a2:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
 801b6a4:	68fb      	ldr	r3, [r7, #12]
}
 801b6a6:	4618      	mov	r0, r3
 801b6a8:	f107 0710 	add.w	r7, r7, #16
 801b6ac:	46bd      	mov	sp, r7
 801b6ae:	bd80      	pop	{r7, pc}

0801b6b0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
 801b6b0:	b480      	push	{r7}
 801b6b2:	b083      	sub	sp, #12
 801b6b4:	af00      	add	r7, sp, #0
 801b6b6:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 801b6b8:	f640 3368 	movw	r3, #2920	; 0xb68
 801b6bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b6c0:	681a      	ldr	r2, [r3, #0]
 801b6c2:	687b      	ldr	r3, [r7, #4]
 801b6c4:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 801b6c6:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b6ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b6ce:	681a      	ldr	r2, [r3, #0]
 801b6d0:	687b      	ldr	r3, [r7, #4]
 801b6d2:	605a      	str	r2, [r3, #4]
}
 801b6d4:	f107 070c 	add.w	r7, r7, #12
 801b6d8:	46bd      	mov	sp, r7
 801b6da:	bc80      	pop	{r7}
 801b6dc:	4770      	bx	lr
 801b6de:	bf00      	nop

0801b6e0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 801b6e0:	b580      	push	{r7, lr}
 801b6e2:	b084      	sub	sp, #16
 801b6e4:	af00      	add	r7, sp, #0
 801b6e6:	6078      	str	r0, [r7, #4]
 801b6e8:	6039      	str	r1, [r7, #0]
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 801b6ea:	f7fe fa5f 	bl	8019bac <vPortEnterCritical>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 801b6ee:	683b      	ldr	r3, [r7, #0]
 801b6f0:	681b      	ldr	r3, [r3, #0]
 801b6f2:	f1b3 3fff 	cmp.w	r3, #4294967295
 801b6f6:	d103      	bne.n	801b700 <xTaskCheckForTimeOut+0x20>
			{
				xReturn = pdFALSE;
 801b6f8:	f04f 0300 	mov.w	r3, #0
 801b6fc:	60fb      	str	r3, [r7, #12]
 801b6fe:	e038      	b.n	801b772 <xTaskCheckForTimeOut+0x92>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
 801b700:	687b      	ldr	r3, [r7, #4]
 801b702:	681a      	ldr	r2, [r3, #0]
 801b704:	f640 3368 	movw	r3, #2920	; 0xb68
 801b708:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b70c:	681b      	ldr	r3, [r3, #0]
 801b70e:	429a      	cmp	r2, r3
 801b710:	d00c      	beq.n	801b72c <xTaskCheckForTimeOut+0x4c>
 801b712:	687b      	ldr	r3, [r7, #4]
 801b714:	685a      	ldr	r2, [r3, #4]
 801b716:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b71a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b71e:	681b      	ldr	r3, [r3, #0]
 801b720:	429a      	cmp	r2, r3
 801b722:	d803      	bhi.n	801b72c <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 801b724:	f04f 0301 	mov.w	r3, #1
 801b728:	60fb      	str	r3, [r7, #12]
 801b72a:	e022      	b.n	801b772 <xTaskCheckForTimeOut+0x92>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
 801b72c:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b730:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b734:	681a      	ldr	r2, [r3, #0]
 801b736:	687b      	ldr	r3, [r7, #4]
 801b738:	685b      	ldr	r3, [r3, #4]
 801b73a:	1ad2      	subs	r2, r2, r3
 801b73c:	683b      	ldr	r3, [r7, #0]
 801b73e:	681b      	ldr	r3, [r3, #0]
 801b740:	429a      	cmp	r2, r3
 801b742:	d213      	bcs.n	801b76c <xTaskCheckForTimeOut+0x8c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 801b744:	683b      	ldr	r3, [r7, #0]
 801b746:	681a      	ldr	r2, [r3, #0]
 801b748:	687b      	ldr	r3, [r7, #4]
 801b74a:	6859      	ldr	r1, [r3, #4]
 801b74c:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b750:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b754:	681b      	ldr	r3, [r3, #0]
 801b756:	1acb      	subs	r3, r1, r3
 801b758:	18d2      	adds	r2, r2, r3
 801b75a:	683b      	ldr	r3, [r7, #0]
 801b75c:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
 801b75e:	6878      	ldr	r0, [r7, #4]
 801b760:	f7ff ffa6 	bl	801b6b0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 801b764:	f04f 0300 	mov.w	r3, #0
 801b768:	60fb      	str	r3, [r7, #12]
 801b76a:	e002      	b.n	801b772 <xTaskCheckForTimeOut+0x92>
		}
		else
		{
			xReturn = pdTRUE;
 801b76c:	f04f 0301 	mov.w	r3, #1
 801b770:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 801b772:	f7fe fa31 	bl	8019bd8 <vPortExitCritical>

	return xReturn;
 801b776:	68fb      	ldr	r3, [r7, #12]
}
 801b778:	4618      	mov	r0, r3
 801b77a:	f107 0710 	add.w	r7, r7, #16
 801b77e:	46bd      	mov	sp, r7
 801b780:	bd80      	pop	{r7, pc}
 801b782:	bf00      	nop

0801b784 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 801b784:	b480      	push	{r7}
 801b786:	af00      	add	r7, sp, #0
	xMissedYield = pdTRUE;
 801b788:	f640 3364 	movw	r3, #2916	; 0xb64
 801b78c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b790:	f04f 0201 	mov.w	r2, #1
 801b794:	601a      	str	r2, [r3, #0]
}
 801b796:	46bd      	mov	sp, r7
 801b798:	bc80      	pop	{r7}
 801b79a:	4770      	bx	lr

0801b79c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 801b79c:	b580      	push	{r7, lr}
 801b79e:	b082      	sub	sp, #8
 801b7a0:	af00      	add	r7, sp, #0
 801b7a2:	6078      	str	r0, [r7, #4]
 801b7a4:	e000      	b.n	801b7a8 <prvIdleTask+0xc>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 801b7a6:	bf00      	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 801b7a8:	f000 f8a0 	bl	801b8ec <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 801b7ac:	f640 230c 	movw	r3, #2572	; 0xa0c
 801b7b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b7b4:	681b      	ldr	r3, [r3, #0]
 801b7b6:	2b01      	cmp	r3, #1
 801b7b8:	d9f5      	bls.n	801b7a6 <prvIdleTask+0xa>
			{
				taskYIELD();
 801b7ba:	f7fe f9eb 	bl	8019b94 <vPortYieldFromISR>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 801b7be:	e7f2      	b.n	801b7a6 <prvIdleTask+0xa>

0801b7c0 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 801b7c0:	b580      	push	{r7, lr}
 801b7c2:	b084      	sub	sp, #16
 801b7c4:	af00      	add	r7, sp, #0
 801b7c6:	60f8      	str	r0, [r7, #12]
 801b7c8:	60b9      	str	r1, [r7, #8]
 801b7ca:	607a      	str	r2, [r7, #4]
 801b7cc:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 801b7ce:	68fb      	ldr	r3, [r7, #12]
 801b7d0:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801b7d4:	4618      	mov	r0, r3
 801b7d6:	68b9      	ldr	r1, [r7, #8]
 801b7d8:	f04f 0210 	mov.w	r2, #16
 801b7dc:	f00b faee 	bl	8026dbc <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 801b7e0:	68fb      	ldr	r3, [r7, #12]
 801b7e2:	f04f 0200 	mov.w	r2, #0
 801b7e6:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 801b7ea:	687b      	ldr	r3, [r7, #4]
 801b7ec:	2b09      	cmp	r3, #9
 801b7ee:	d902      	bls.n	801b7f6 <prvInitialiseTCBVariables+0x36>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 801b7f0:	f04f 0309 	mov.w	r3, #9
 801b7f4:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
 801b7f6:	68fb      	ldr	r3, [r7, #12]
 801b7f8:	687a      	ldr	r2, [r7, #4]
 801b7fa:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 801b7fc:	68fb      	ldr	r3, [r7, #12]
 801b7fe:	687a      	ldr	r2, [r7, #4]
 801b800:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 801b802:	68fb      	ldr	r3, [r7, #12]
 801b804:	f103 0304 	add.w	r3, r3, #4
 801b808:	4618      	mov	r0, r3
 801b80a:	f7fe fa8b 	bl	8019d24 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 801b80e:	68fb      	ldr	r3, [r7, #12]
 801b810:	f103 0318 	add.w	r3, r3, #24
 801b814:	4618      	mov	r0, r3
 801b816:	f7fe fa85 	bl	8019d24 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 801b81a:	68fb      	ldr	r3, [r7, #12]
 801b81c:	68fa      	ldr	r2, [r7, #12]
 801b81e:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 801b820:	687b      	ldr	r3, [r7, #4]
 801b822:	f1c3 020a 	rsb	r2, r3, #10
 801b826:	68fb      	ldr	r3, [r7, #12]
 801b828:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 801b82a:	68fb      	ldr	r3, [r7, #12]
 801b82c:	68fa      	ldr	r2, [r7, #12]
 801b82e:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
	{
		pxTCB->pxTaskTag = NULL;
 801b830:	68fb      	ldr	r3, [r7, #12]
 801b832:	f04f 0200 	mov.w	r2, #0
 801b836:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxTCB->ulRunTimeCounter = 0UL;
 801b838:	68fb      	ldr	r3, [r7, #12]
 801b83a:	f04f 0200 	mov.w	r2, #0
 801b83e:	64da      	str	r2, [r3, #76]	; 0x4c
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 801b840:	f107 0710 	add.w	r7, r7, #16
 801b844:	46bd      	mov	sp, r7
 801b846:	bd80      	pop	{r7, pc}

0801b848 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 801b848:	b580      	push	{r7, lr}
 801b84a:	b082      	sub	sp, #8
 801b84c:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 801b84e:	f04f 0300 	mov.w	r3, #0
 801b852:	607b      	str	r3, [r7, #4]
 801b854:	e013      	b.n	801b87e <prvInitialiseTaskLists+0x36>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 801b856:	687a      	ldr	r2, [r7, #4]
 801b858:	4613      	mov	r3, r2
 801b85a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b85e:	189b      	adds	r3, r3, r2
 801b860:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b864:	461a      	mov	r2, r3
 801b866:	f640 230c 	movw	r3, #2572	; 0xa0c
 801b86a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b86e:	18d3      	adds	r3, r2, r3
 801b870:	4618      	mov	r0, r3
 801b872:	f7fe fa37 	bl	8019ce4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 801b876:	687b      	ldr	r3, [r7, #4]
 801b878:	f103 0301 	add.w	r3, r3, #1
 801b87c:	607b      	str	r3, [r7, #4]
 801b87e:	687b      	ldr	r3, [r7, #4]
 801b880:	2b09      	cmp	r3, #9
 801b882:	d9e8      	bls.n	801b856 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 801b884:	f640 20d4 	movw	r0, #2772	; 0xad4
 801b888:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b88c:	f7fe fa2a 	bl	8019ce4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 801b890:	f640 20e8 	movw	r0, #2792	; 0xae8
 801b894:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b898:	f7fe fa24 	bl	8019ce4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 801b89c:	f640 3004 	movw	r0, #2820	; 0xb04
 801b8a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b8a4:	f7fe fa1e 	bl	8019ce4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 801b8a8:	f640 3018 	movw	r0, #2840	; 0xb18
 801b8ac:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b8b0:	f7fe fa18 	bl	8019ce4 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 801b8b4:	f640 3030 	movw	r0, #2864	; 0xb30
 801b8b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b8bc:	f7fe fa12 	bl	8019ce4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 801b8c0:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b8c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b8c8:	f640 22d4 	movw	r2, #2772	; 0xad4
 801b8cc:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801b8d0:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 801b8d2:	f640 3300 	movw	r3, #2816	; 0xb00
 801b8d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b8da:	f640 22e8 	movw	r2, #2792	; 0xae8
 801b8de:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801b8e2:	601a      	str	r2, [r3, #0]
}
 801b8e4:	f107 0708 	add.w	r7, r7, #8
 801b8e8:	46bd      	mov	sp, r7
 801b8ea:	bd80      	pop	{r7, pc}

0801b8ec <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 801b8ec:	b580      	push	{r7, lr}
 801b8ee:	b082      	sub	sp, #8
 801b8f0:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 801b8f2:	f640 332c 	movw	r3, #2860	; 0xb2c
 801b8f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b8fa:	681b      	ldr	r3, [r3, #0]
 801b8fc:	2b00      	cmp	r3, #0
 801b8fe:	d03c      	beq.n	801b97a <prvCheckTasksWaitingTermination+0x8e>
		{
			vTaskSuspendAll();
 801b900:	f7ff faa8 	bl	801ae54 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 801b904:	f640 3318 	movw	r3, #2840	; 0xb18
 801b908:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b90c:	681b      	ldr	r3, [r3, #0]
 801b90e:	2b00      	cmp	r3, #0
 801b910:	bf14      	ite	ne
 801b912:	2300      	movne	r3, #0
 801b914:	2301      	moveq	r3, #1
 801b916:	607b      	str	r3, [r7, #4]
			xTaskResumeAll();
 801b918:	f7ff faae 	bl	801ae78 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 801b91c:	687b      	ldr	r3, [r7, #4]
 801b91e:	2b00      	cmp	r3, #0
 801b920:	d12b      	bne.n	801b97a <prvCheckTasksWaitingTermination+0x8e>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 801b922:	f7fe f943 	bl	8019bac <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 801b926:	f640 3318 	movw	r3, #2840	; 0xb18
 801b92a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b92e:	68db      	ldr	r3, [r3, #12]
 801b930:	68db      	ldr	r3, [r3, #12]
 801b932:	603b      	str	r3, [r7, #0]
					vListRemove( &( pxTCB->xGenericListItem ) );
 801b934:	683b      	ldr	r3, [r7, #0]
 801b936:	f103 0304 	add.w	r3, r3, #4
 801b93a:	4618      	mov	r0, r3
 801b93c:	f7fe fa66 	bl	8019e0c <vListRemove>
					--uxCurrentNumberOfTasks;
 801b940:	f640 3348 	movw	r3, #2888	; 0xb48
 801b944:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b948:	681b      	ldr	r3, [r3, #0]
 801b94a:	f103 32ff 	add.w	r2, r3, #4294967295
 801b94e:	f640 3348 	movw	r3, #2888	; 0xb48
 801b952:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b956:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
 801b958:	f640 332c 	movw	r3, #2860	; 0xb2c
 801b95c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b960:	681b      	ldr	r3, [r3, #0]
 801b962:	f103 32ff 	add.w	r2, r3, #4294967295
 801b966:	f640 332c 	movw	r3, #2860	; 0xb2c
 801b96a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b96e:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
 801b970:	f7fe f932 	bl	8019bd8 <vPortExitCritical>

				prvDeleteTCB( pxTCB );
 801b974:	6838      	ldr	r0, [r7, #0]
 801b976:	f000 f97d 	bl	801bc74 <prvDeleteTCB>
			}
		}
	}
	#endif
}
 801b97a:	f107 0708 	add.w	r7, r7, #8
 801b97e:	46bd      	mov	sp, r7
 801b980:	bd80      	pop	{r7, pc}
 801b982:	bf00      	nop

0801b984 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 801b984:	b580      	push	{r7, lr}
 801b986:	b082      	sub	sp, #8
 801b988:	af00      	add	r7, sp, #0
 801b98a:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 801b98c:	f640 2308 	movw	r3, #2568	; 0xa08
 801b990:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b994:	681b      	ldr	r3, [r3, #0]
 801b996:	687a      	ldr	r2, [r7, #4]
 801b998:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
 801b99a:	f640 334c 	movw	r3, #2892	; 0xb4c
 801b99e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b9a2:	681b      	ldr	r3, [r3, #0]
 801b9a4:	687a      	ldr	r2, [r7, #4]
 801b9a6:	429a      	cmp	r2, r3
 801b9a8:	d210      	bcs.n	801b9cc <prvAddCurrentTaskToDelayedList+0x48>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 801b9aa:	f640 3300 	movw	r3, #2816	; 0xb00
 801b9ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b9b2:	681a      	ldr	r2, [r3, #0]
 801b9b4:	f640 2308 	movw	r3, #2568	; 0xa08
 801b9b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b9bc:	681b      	ldr	r3, [r3, #0]
 801b9be:	f103 0304 	add.w	r3, r3, #4
 801b9c2:	4610      	mov	r0, r2
 801b9c4:	4619      	mov	r1, r3
 801b9c6:	f7fe f9e5 	bl	8019d94 <vListInsert>
 801b9ca:	e01d      	b.n	801ba08 <prvAddCurrentTaskToDelayedList+0x84>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 801b9cc:	f640 23fc 	movw	r3, #2812	; 0xafc
 801b9d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b9d4:	681a      	ldr	r2, [r3, #0]
 801b9d6:	f640 2308 	movw	r3, #2568	; 0xa08
 801b9da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b9de:	681b      	ldr	r3, [r3, #0]
 801b9e0:	f103 0304 	add.w	r3, r3, #4
 801b9e4:	4610      	mov	r0, r2
 801b9e6:	4619      	mov	r1, r3
 801b9e8:	f7fe f9d4 	bl	8019d94 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 801b9ec:	f240 0384 	movw	r3, #132	; 0x84
 801b9f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b9f4:	681b      	ldr	r3, [r3, #0]
 801b9f6:	687a      	ldr	r2, [r7, #4]
 801b9f8:	429a      	cmp	r2, r3
 801b9fa:	d205      	bcs.n	801ba08 <prvAddCurrentTaskToDelayedList+0x84>
		{
			xNextTaskUnblockTime = xTimeToWake;
 801b9fc:	f240 0384 	movw	r3, #132	; 0x84
 801ba00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ba04:	687a      	ldr	r2, [r7, #4]
 801ba06:	601a      	str	r2, [r3, #0]
		}
	}
}
 801ba08:	f107 0708 	add.w	r7, r7, #8
 801ba0c:	46bd      	mov	sp, r7
 801ba0e:	bd80      	pop	{r7, pc}

0801ba10 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 801ba10:	b580      	push	{r7, lr}
 801ba12:	b084      	sub	sp, #16
 801ba14:	af00      	add	r7, sp, #0
 801ba16:	4603      	mov	r3, r0
 801ba18:	6039      	str	r1, [r7, #0]
 801ba1a:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 801ba1c:	f04f 0050 	mov.w	r0, #80	; 0x50
 801ba20:	f009 f9ca 	bl	8024db8 <malloc>
 801ba24:	4603      	mov	r3, r0
 801ba26:	60fb      	str	r3, [r7, #12]

	if( pxNewTCB != NULL )
 801ba28:	68fb      	ldr	r3, [r7, #12]
 801ba2a:	2b00      	cmp	r3, #0
 801ba2c:	d023      	beq.n	801ba76 <prvAllocateTCBAndStack+0x66>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 801ba2e:	683b      	ldr	r3, [r7, #0]
 801ba30:	2b00      	cmp	r3, #0
 801ba32:	d107      	bne.n	801ba44 <prvAllocateTCBAndStack+0x34>
 801ba34:	88fb      	ldrh	r3, [r7, #6]
 801ba36:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801ba3a:	4618      	mov	r0, r3
 801ba3c:	f009 f9bc 	bl	8024db8 <malloc>
 801ba40:	4603      	mov	r3, r0
 801ba42:	e000      	b.n	801ba46 <prvAllocateTCBAndStack+0x36>
 801ba44:	683b      	ldr	r3, [r7, #0]
 801ba46:	68fa      	ldr	r2, [r7, #12]
 801ba48:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 801ba4a:	68fb      	ldr	r3, [r7, #12]
 801ba4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801ba4e:	2b00      	cmp	r3, #0
 801ba50:	d106      	bne.n	801ba60 <prvAllocateTCBAndStack+0x50>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 801ba52:	68f8      	ldr	r0, [r7, #12]
 801ba54:	f009 f9b8 	bl	8024dc8 <free>
			pxNewTCB = NULL;
 801ba58:	f04f 0300 	mov.w	r3, #0
 801ba5c:	60fb      	str	r3, [r7, #12]
 801ba5e:	e00a      	b.n	801ba76 <prvAllocateTCBAndStack+0x66>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 801ba60:	68fb      	ldr	r3, [r7, #12]
 801ba62:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801ba64:	88fb      	ldrh	r3, [r7, #6]
 801ba66:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801ba6a:	4610      	mov	r0, r2
 801ba6c:	f04f 01a5 	mov.w	r1, #165	; 0xa5
 801ba70:	461a      	mov	r2, r3
 801ba72:	f009 fceb 	bl	802544c <memset>
		}
	}

	return pxNewTCB;
 801ba76:	68fb      	ldr	r3, [r7, #12]
}
 801ba78:	4618      	mov	r0, r3
 801ba7a:	f107 0710 	add.w	r7, r7, #16
 801ba7e:	46bd      	mov	sp, r7
 801ba80:	bd80      	pop	{r7, pc}
 801ba82:	bf00      	nop

0801ba84 <prvGenerateRunTimeStatsForTasksInList>:
/*-----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime, signed char cStatus  )
	{
 801ba84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801ba88:	b08e      	sub	sp, #56	; 0x38
 801ba8a:	af04      	add	r7, sp, #16
 801ba8c:	60f8      	str	r0, [r7, #12]
 801ba8e:	60b9      	str	r1, [r7, #8]
 801ba90:	607a      	str	r2, [r7, #4]
 801ba92:	70fb      	strb	r3, [r7, #3]
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned long ulStatsAsPercentage;

		/* Write the run time stats of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 801ba94:	68bb      	ldr	r3, [r7, #8]
 801ba96:	627b      	str	r3, [r7, #36]	; 0x24
 801ba98:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ba9a:	685b      	ldr	r3, [r3, #4]
 801ba9c:	685b      	ldr	r3, [r3, #4]
 801ba9e:	461a      	mov	r2, r3
 801baa0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801baa2:	605a      	str	r2, [r3, #4]
 801baa4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801baa6:	685a      	ldr	r2, [r3, #4]
 801baa8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801baaa:	f103 0308 	add.w	r3, r3, #8
 801baae:	429a      	cmp	r2, r3
 801bab0:	d105      	bne.n	801babe <prvGenerateRunTimeStatsForTasksInList+0x3a>
 801bab2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801bab4:	685b      	ldr	r3, [r3, #4]
 801bab6:	685b      	ldr	r3, [r3, #4]
 801bab8:	461a      	mov	r2, r3
 801baba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801babc:	605a      	str	r2, [r3, #4]
 801babe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801bac0:	685b      	ldr	r3, [r3, #4]
 801bac2:	68db      	ldr	r3, [r3, #12]
 801bac4:	623b      	str	r3, [r7, #32]
		do
		{
			/* Get next TCB in from the list. */
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 801bac6:	68bb      	ldr	r3, [r7, #8]
 801bac8:	61fb      	str	r3, [r7, #28]
 801baca:	69fb      	ldr	r3, [r7, #28]
 801bacc:	685b      	ldr	r3, [r3, #4]
 801bace:	685b      	ldr	r3, [r3, #4]
 801bad0:	461a      	mov	r2, r3
 801bad2:	69fb      	ldr	r3, [r7, #28]
 801bad4:	605a      	str	r2, [r3, #4]
 801bad6:	69fb      	ldr	r3, [r7, #28]
 801bad8:	685a      	ldr	r2, [r3, #4]
 801bada:	69fb      	ldr	r3, [r7, #28]
 801badc:	f103 0308 	add.w	r3, r3, #8
 801bae0:	429a      	cmp	r2, r3
 801bae2:	d105      	bne.n	801baf0 <prvGenerateRunTimeStatsForTasksInList+0x6c>
 801bae4:	69fb      	ldr	r3, [r7, #28]
 801bae6:	685b      	ldr	r3, [r3, #4]
 801bae8:	685b      	ldr	r3, [r3, #4]
 801baea:	461a      	mov	r2, r3
 801baec:	69fb      	ldr	r3, [r7, #28]
 801baee:	605a      	str	r2, [r3, #4]
 801baf0:	69fb      	ldr	r3, [r7, #28]
 801baf2:	685b      	ldr	r3, [r3, #4]
 801baf4:	68db      	ldr	r3, [r3, #12]
 801baf6:	61bb      	str	r3, [r7, #24]

			/* Divide by zero check. */
			if( ulTotalRunTime > 0UL )
 801baf8:	687b      	ldr	r3, [r7, #4]
 801bafa:	2b00      	cmp	r3, #0
 801bafc:	d076      	beq.n	801bbec <prvGenerateRunTimeStatsForTasksInList+0x168>
			{
				/* Has the task run at all? */
				if( pxNextTCB->ulRunTimeCounter == 0UL )
 801bafe:	69bb      	ldr	r3, [r7, #24]
 801bb00:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801bb02:	2b00      	cmp	r3, #0
 801bb04:	d11c      	bne.n	801bb40 <prvGenerateRunTimeStatsForTasksInList+0xbc>
				{
					/* The task has used no CPU time at all. */
					sprintf( pcStatsString, ( char * ) "%u  %c  %-16s          0   0%%  %5u\r\n", (unsigned int) pxNextTCB->uxPriority, cStatus, pxNextTCB->pcTaskName, usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack ));
 801bb06:	69bb      	ldr	r3, [r7, #24]
 801bb08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801bb0a:	461d      	mov	r5, r3
 801bb0c:	f997 4003 	ldrsb.w	r4, [r7, #3]
 801bb10:	69bb      	ldr	r3, [r7, #24]
 801bb12:	f103 0634 	add.w	r6, r3, #52	; 0x34
 801bb16:	69bb      	ldr	r3, [r7, #24]
 801bb18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801bb1a:	4618      	mov	r0, r3
 801bb1c:	f000 f870 	bl	801bc00 <usTaskCheckFreeStackSpace>
 801bb20:	4603      	mov	r3, r0
 801bb22:	9600      	str	r6, [sp, #0]
 801bb24:	9301      	str	r3, [sp, #4]
 801bb26:	f640 3070 	movw	r0, #2928	; 0xb70
 801bb2a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801bb2e:	f64b 310c 	movw	r1, #47884	; 0xbb0c
 801bb32:	f6c0 0102 	movt	r1, #2050	; 0x802
 801bb36:	462a      	mov	r2, r5
 801bb38:	4623      	mov	r3, r4
 801bb3a:	f00a f9e9 	bl	8025f10 <sprintf>
 801bb3e:	e04e      	b.n	801bbde <prvGenerateRunTimeStatsForTasksInList+0x15a>
				else
				{
					/* What percentage of the total run time has the task used?
					This will always be rounded down to the nearest integer.
					ulTotalRunTime has already been divided by 100. */
					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 801bb40:	69bb      	ldr	r3, [r7, #24]
 801bb42:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801bb44:	461a      	mov	r2, r3
 801bb46:	687b      	ldr	r3, [r7, #4]
 801bb48:	fbb2 f3f3 	udiv	r3, r2, r3
 801bb4c:	617b      	str	r3, [r7, #20]

					if( ulStatsAsPercentage > 0UL )
 801bb4e:	697b      	ldr	r3, [r7, #20]
 801bb50:	2b00      	cmp	r3, #0
 801bb52:	d023      	beq.n	801bb9c <prvGenerateRunTimeStatsForTasksInList+0x118>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u %3u%%  %5u\r\n", (unsigned int) pxNextTCB->uxPriority, cStatus, pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage, usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack ));
 801bb54:	69bb      	ldr	r3, [r7, #24]
 801bb56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801bb58:	461d      	mov	r5, r3
 801bb5a:	f997 4003 	ldrsb.w	r4, [r7, #3]
 801bb5e:	69bb      	ldr	r3, [r7, #24]
 801bb60:	f103 0834 	add.w	r8, r3, #52	; 0x34
 801bb64:	69bb      	ldr	r3, [r7, #24]
 801bb66:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801bb68:	461e      	mov	r6, r3
 801bb6a:	69bb      	ldr	r3, [r7, #24]
 801bb6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801bb6e:	4618      	mov	r0, r3
 801bb70:	f000 f846 	bl	801bc00 <usTaskCheckFreeStackSpace>
 801bb74:	4603      	mov	r3, r0
 801bb76:	f8cd 8000 	str.w	r8, [sp]
 801bb7a:	9601      	str	r6, [sp, #4]
 801bb7c:	697a      	ldr	r2, [r7, #20]
 801bb7e:	9202      	str	r2, [sp, #8]
 801bb80:	9303      	str	r3, [sp, #12]
 801bb82:	f640 3070 	movw	r0, #2928	; 0xb70
 801bb86:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801bb8a:	f64b 3134 	movw	r1, #47924	; 0xbb34
 801bb8e:	f6c0 0102 	movt	r1, #2050	; 0x802
 801bb92:	462a      	mov	r2, r5
 801bb94:	4623      	mov	r3, r4
 801bb96:	f00a f9bb 	bl	8025f10 <sprintf>
 801bb9a:	e020      	b.n	801bbde <prvGenerateRunTimeStatsForTasksInList+0x15a>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u  <1%%  %5u\r\n",  (unsigned int) pxNextTCB->uxPriority, cStatus, pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter, usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack ));
 801bb9c:	69bb      	ldr	r3, [r7, #24]
 801bb9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801bba0:	461d      	mov	r5, r3
 801bba2:	f997 4003 	ldrsb.w	r4, [r7, #3]
 801bba6:	69bb      	ldr	r3, [r7, #24]
 801bba8:	f103 0834 	add.w	r8, r3, #52	; 0x34
 801bbac:	69bb      	ldr	r3, [r7, #24]
 801bbae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801bbb0:	461e      	mov	r6, r3
 801bbb2:	69bb      	ldr	r3, [r7, #24]
 801bbb4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801bbb6:	4618      	mov	r0, r3
 801bbb8:	f000 f822 	bl	801bc00 <usTaskCheckFreeStackSpace>
 801bbbc:	4603      	mov	r3, r0
 801bbbe:	f8cd 8000 	str.w	r8, [sp]
 801bbc2:	9601      	str	r6, [sp, #4]
 801bbc4:	9302      	str	r3, [sp, #8]
 801bbc6:	f640 3070 	movw	r0, #2928	; 0xb70
 801bbca:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801bbce:	f64b 3154 	movw	r1, #47956	; 0xbb54
 801bbd2:	f6c0 0102 	movt	r1, #2050	; 0x802
 801bbd6:	462a      	mov	r2, r5
 801bbd8:	4623      	mov	r3, r4
 801bbda:	f00a f999 	bl	8025f10 <sprintf>
						}
						#endif
					}
				}

				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
 801bbde:	68f8      	ldr	r0, [r7, #12]
 801bbe0:	f640 3170 	movw	r1, #2928	; 0xb70
 801bbe4:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801bbe8:	f00a f9ba 	bl	8025f60 <strcat>
			}

		} while( pxNextTCB != pxFirstTCB );
 801bbec:	69ba      	ldr	r2, [r7, #24]
 801bbee:	6a3b      	ldr	r3, [r7, #32]
 801bbf0:	429a      	cmp	r2, r3
 801bbf2:	f47f af68 	bne.w	801bac6 <prvGenerateRunTimeStatsForTasksInList+0x42>
	}
 801bbf6:	f107 0728 	add.w	r7, r7, #40	; 0x28
 801bbfa:	46bd      	mov	sp, r7
 801bbfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801bc00 <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
 801bc00:	b490      	push	{r4, r7}
 801bc02:	b082      	sub	sp, #8
 801bc04:	af00      	add	r7, sp, #0
 801bc06:	6078      	str	r0, [r7, #4]
	register unsigned short usCount = 0U;
 801bc08:	f04f 0400 	mov.w	r4, #0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
 801bc0c:	e006      	b.n	801bc1c <usTaskCheckFreeStackSpace+0x1c>
		{
			pucStackByte -= portSTACK_GROWTH;
 801bc0e:	687b      	ldr	r3, [r7, #4]
 801bc10:	f103 0301 	add.w	r3, r3, #1
 801bc14:	607b      	str	r3, [r7, #4]
			usCount++;
 801bc16:	f104 0301 	add.w	r3, r4, #1
 801bc1a:	b29c      	uxth	r4, r3

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
 801bc1c:	687b      	ldr	r3, [r7, #4]
 801bc1e:	781b      	ldrb	r3, [r3, #0]
 801bc20:	2ba5      	cmp	r3, #165	; 0xa5
 801bc22:	d0f4      	beq.n	801bc0e <usTaskCheckFreeStackSpace+0xe>
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );
 801bc24:	ea4f 0394 	mov.w	r3, r4, lsr #2
 801bc28:	b29c      	uxth	r4, r3

		return usCount;
 801bc2a:	4623      	mov	r3, r4
	}
 801bc2c:	4618      	mov	r0, r3
 801bc2e:	f107 0708 	add.w	r7, r7, #8
 801bc32:	46bd      	mov	sp, r7
 801bc34:	bc90      	pop	{r4, r7}
 801bc36:	4770      	bx	lr

0801bc38 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
 801bc38:	b580      	push	{r7, lr}
 801bc3a:	b086      	sub	sp, #24
 801bc3c:	af00      	add	r7, sp, #0
 801bc3e:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
 801bc40:	687b      	ldr	r3, [r7, #4]
 801bc42:	2b00      	cmp	r3, #0
 801bc44:	d105      	bne.n	801bc52 <uxTaskGetStackHighWaterMark+0x1a>
 801bc46:	f640 2308 	movw	r3, #2568	; 0xa08
 801bc4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bc4e:	681b      	ldr	r3, [r3, #0]
 801bc50:	e000      	b.n	801bc54 <uxTaskGetStackHighWaterMark+0x1c>
 801bc52:	687b      	ldr	r3, [r7, #4]
 801bc54:	617b      	str	r3, [r7, #20]

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 801bc56:	697b      	ldr	r3, [r7, #20]
 801bc58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801bc5a:	613b      	str	r3, [r7, #16]
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 801bc5c:	6938      	ldr	r0, [r7, #16]
 801bc5e:	f7ff ffcf 	bl	801bc00 <usTaskCheckFreeStackSpace>
 801bc62:	4603      	mov	r3, r0
 801bc64:	60fb      	str	r3, [r7, #12]

		return uxReturn;
 801bc66:	68fb      	ldr	r3, [r7, #12]
	}
 801bc68:	4618      	mov	r0, r3
 801bc6a:	f107 0718 	add.w	r7, r7, #24
 801bc6e:	46bd      	mov	sp, r7
 801bc70:	bd80      	pop	{r7, pc}
 801bc72:	bf00      	nop

0801bc74 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
 801bc74:	b580      	push	{r7, lr}
 801bc76:	b082      	sub	sp, #8
 801bc78:	af00      	add	r7, sp, #0
 801bc7a:	6078      	str	r0, [r7, #4]
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 801bc7c:	687b      	ldr	r3, [r7, #4]
 801bc7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801bc80:	4618      	mov	r0, r3
 801bc82:	f009 f8a1 	bl	8024dc8 <free>
		vPortFree( pxTCB );
 801bc86:	6878      	ldr	r0, [r7, #4]
 801bc88:	f009 f89e 	bl	8024dc8 <free>
	}
 801bc8c:	f107 0708 	add.w	r7, r7, #8
 801bc90:	46bd      	mov	sp, r7
 801bc92:	bd80      	pop	{r7, pc}

0801bc94 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
 801bc94:	b480      	push	{r7}
 801bc96:	b083      	sub	sp, #12
 801bc98:	af00      	add	r7, sp, #0
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 801bc9a:	f640 2308 	movw	r3, #2568	; 0xa08
 801bc9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bca2:	681b      	ldr	r3, [r3, #0]
 801bca4:	607b      	str	r3, [r7, #4]

		return xReturn;
 801bca6:	687b      	ldr	r3, [r7, #4]
	}
 801bca8:	4618      	mov	r0, r3
 801bcaa:	f107 070c 	add.w	r7, r7, #12
 801bcae:	46bd      	mov	sp, r7
 801bcb0:	bc80      	pop	{r7}
 801bcb2:	4770      	bx	lr

0801bcb4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
 801bcb4:	b580      	push	{r7, lr}
 801bcb6:	b084      	sub	sp, #16
 801bcb8:	af00      	add	r7, sp, #0
 801bcba:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 801bcbc:	687b      	ldr	r3, [r7, #4]
 801bcbe:	60fb      	str	r3, [r7, #12]

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 801bcc0:	68fb      	ldr	r3, [r7, #12]
 801bcc2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bcc4:	f640 2308 	movw	r3, #2568	; 0xa08
 801bcc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bccc:	681b      	ldr	r3, [r3, #0]
 801bcce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801bcd0:	429a      	cmp	r2, r3
 801bcd2:	d257      	bcs.n	801bd84 <vTaskPriorityInherit+0xd0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
 801bcd4:	f640 2308 	movw	r3, #2568	; 0xa08
 801bcd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bcdc:	681b      	ldr	r3, [r3, #0]
 801bcde:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801bce0:	f1c3 020a 	rsb	r2, r3, #10
 801bce4:	68fb      	ldr	r3, [r7, #12]
 801bce6:	619a      	str	r2, [r3, #24]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 801bce8:	68fb      	ldr	r3, [r7, #12]
 801bcea:	6959      	ldr	r1, [r3, #20]
 801bcec:	68fb      	ldr	r3, [r7, #12]
 801bcee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bcf0:	4613      	mov	r3, r2
 801bcf2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801bcf6:	189b      	adds	r3, r3, r2
 801bcf8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801bcfc:	461a      	mov	r2, r3
 801bcfe:	f640 230c 	movw	r3, #2572	; 0xa0c
 801bd02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bd06:	18d3      	adds	r3, r2, r3
 801bd08:	4299      	cmp	r1, r3
 801bd0a:	d133      	bne.n	801bd74 <vTaskPriorityInherit+0xc0>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
 801bd0c:	68fb      	ldr	r3, [r7, #12]
 801bd0e:	f103 0304 	add.w	r3, r3, #4
 801bd12:	4618      	mov	r0, r3
 801bd14:	f7fe f87a 	bl	8019e0c <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 801bd18:	f640 2308 	movw	r3, #2568	; 0xa08
 801bd1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bd20:	681b      	ldr	r3, [r3, #0]
 801bd22:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bd24:	68fb      	ldr	r3, [r7, #12]
 801bd26:	62da      	str	r2, [r3, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
 801bd28:	68fb      	ldr	r3, [r7, #12]
 801bd2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bd2c:	f640 3354 	movw	r3, #2900	; 0xb54
 801bd30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bd34:	681b      	ldr	r3, [r3, #0]
 801bd36:	429a      	cmp	r2, r3
 801bd38:	d906      	bls.n	801bd48 <vTaskPriorityInherit+0x94>
 801bd3a:	68fb      	ldr	r3, [r7, #12]
 801bd3c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bd3e:	f640 3354 	movw	r3, #2900	; 0xb54
 801bd42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bd46:	601a      	str	r2, [r3, #0]
 801bd48:	68fb      	ldr	r3, [r7, #12]
 801bd4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bd4c:	4613      	mov	r3, r2
 801bd4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801bd52:	189b      	adds	r3, r3, r2
 801bd54:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801bd58:	461a      	mov	r2, r3
 801bd5a:	f640 230c 	movw	r3, #2572	; 0xa0c
 801bd5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bd62:	18d2      	adds	r2, r2, r3
 801bd64:	68fb      	ldr	r3, [r7, #12]
 801bd66:	f103 0304 	add.w	r3, r3, #4
 801bd6a:	4610      	mov	r0, r2
 801bd6c:	4619      	mov	r1, r3
 801bd6e:	f7fd ffe7 	bl	8019d40 <vListInsertEnd>
 801bd72:	e007      	b.n	801bd84 <vTaskPriorityInherit+0xd0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 801bd74:	f640 2308 	movw	r3, #2568	; 0xa08
 801bd78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bd7c:	681b      	ldr	r3, [r3, #0]
 801bd7e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bd80:	68fb      	ldr	r3, [r7, #12]
 801bd82:	62da      	str	r2, [r3, #44]	; 0x2c
			}
		}
	}
 801bd84:	f107 0710 	add.w	r7, r7, #16
 801bd88:	46bd      	mov	sp, r7
 801bd8a:	bd80      	pop	{r7, pc}

0801bd8c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
 801bd8c:	b580      	push	{r7, lr}
 801bd8e:	b084      	sub	sp, #16
 801bd90:	af00      	add	r7, sp, #0
 801bd92:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 801bd94:	687b      	ldr	r3, [r7, #4]
 801bd96:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
 801bd98:	687b      	ldr	r3, [r7, #4]
 801bd9a:	2b00      	cmp	r3, #0
 801bd9c:	d03a      	beq.n	801be14 <vTaskPriorityDisinherit+0x88>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 801bd9e:	68fb      	ldr	r3, [r7, #12]
 801bda0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bda2:	68fb      	ldr	r3, [r7, #12]
 801bda4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801bda6:	429a      	cmp	r2, r3
 801bda8:	d034      	beq.n	801be14 <vTaskPriorityDisinherit+0x88>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
 801bdaa:	68fb      	ldr	r3, [r7, #12]
 801bdac:	f103 0304 	add.w	r3, r3, #4
 801bdb0:	4618      	mov	r0, r3
 801bdb2:	f7fe f82b 	bl	8019e0c <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 801bdb6:	68fb      	ldr	r3, [r7, #12]
 801bdb8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801bdba:	68fb      	ldr	r3, [r7, #12]
 801bdbc:	62da      	str	r2, [r3, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
 801bdbe:	68fb      	ldr	r3, [r7, #12]
 801bdc0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801bdc2:	f1c3 020a 	rsb	r2, r3, #10
 801bdc6:	68fb      	ldr	r3, [r7, #12]
 801bdc8:	619a      	str	r2, [r3, #24]
				prvAddTaskToReadyQueue( pxTCB );
 801bdca:	68fb      	ldr	r3, [r7, #12]
 801bdcc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bdce:	f640 3354 	movw	r3, #2900	; 0xb54
 801bdd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bdd6:	681b      	ldr	r3, [r3, #0]
 801bdd8:	429a      	cmp	r2, r3
 801bdda:	d906      	bls.n	801bdea <vTaskPriorityDisinherit+0x5e>
 801bddc:	68fb      	ldr	r3, [r7, #12]
 801bdde:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bde0:	f640 3354 	movw	r3, #2900	; 0xb54
 801bde4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bde8:	601a      	str	r2, [r3, #0]
 801bdea:	68fb      	ldr	r3, [r7, #12]
 801bdec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801bdee:	4613      	mov	r3, r2
 801bdf0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801bdf4:	189b      	adds	r3, r3, r2
 801bdf6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801bdfa:	461a      	mov	r2, r3
 801bdfc:	f640 230c 	movw	r3, #2572	; 0xa0c
 801be00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801be04:	18d2      	adds	r2, r2, r3
 801be06:	68fb      	ldr	r3, [r7, #12]
 801be08:	f103 0304 	add.w	r3, r3, #4
 801be0c:	4610      	mov	r0, r2
 801be0e:	4619      	mov	r1, r3
 801be10:	f7fd ff96 	bl	8019d40 <vListInsertEnd>
			}
		}
	}
 801be14:	f107 0710 	add.w	r7, r7, #16
 801be18:	46bd      	mov	sp, r7
 801be1a:	bd80      	pop	{r7, pc}

0801be1c <_ZN21rtc_handler_namespace11CRTCHandlerC1Ev>:
uint32_t CaptureNumber;
uint16_t tmpCC4[2] = {0, 0};
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

CRTCHandler::CRTCHandler() {
 801be1c:	b580      	push	{r7, lr}
 801be1e:	b082      	sub	sp, #8
 801be20:	af00      	add	r7, sp, #0
 801be22:	6078      	str	r0, [r7, #4]
 801be24:	687b      	ldr	r3, [r7, #4]
 801be26:	4618      	mov	r0, r3
 801be28:	f7fd fc10 	bl	801964c <_ZN12AManagedTaskC1Ev>
 801be2c:	687b      	ldr	r3, [r7, #4]
 801be2e:	4a04      	ldr	r2, [pc, #16]	; (801be40 <_ZN21rtc_handler_namespace11CRTCHandlerC1Ev+0x24>)
 801be30:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated constructor stub

}
 801be32:	687b      	ldr	r3, [r7, #4]
 801be34:	4618      	mov	r0, r3
 801be36:	f107 0708 	add.w	r7, r7, #8
 801be3a:	46bd      	mov	sp, r7
 801be3c:	bd80      	pop	{r7, pc}
 801be3e:	bf00      	nop
 801be40:	08032af8 	.word	0x08032af8

0801be44 <_ZN21rtc_handler_namespace11CRTCHandlerD1Ev>:

CRTCHandler::~CRTCHandler() {
 801be44:	b580      	push	{r7, lr}
 801be46:	b082      	sub	sp, #8
 801be48:	af00      	add	r7, sp, #0
 801be4a:	6078      	str	r0, [r7, #4]
 801be4c:	687b      	ldr	r3, [r7, #4]
 801be4e:	4a0a      	ldr	r2, [pc, #40]	; (801be78 <_ZN21rtc_handler_namespace11CRTCHandlerD1Ev+0x34>)
 801be50:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated destructor stub
}
 801be52:	6878      	ldr	r0, [r7, #4]
 801be54:	f7fd fc16 	bl	8019684 <_ZN12AManagedTaskD1Ev>
 801be58:	f04f 0300 	mov.w	r3, #0
 801be5c:	f003 0301 	and.w	r3, r3, #1
 801be60:	b2db      	uxtb	r3, r3
 801be62:	2b00      	cmp	r3, #0
 801be64:	d002      	beq.n	801be6c <_ZN21rtc_handler_namespace11CRTCHandlerD1Ev+0x28>
 801be66:	6878      	ldr	r0, [r7, #4]
 801be68:	f006 f9b4 	bl	80221d4 <_ZdlPv>
 801be6c:	687b      	ldr	r3, [r7, #4]
 801be6e:	4618      	mov	r0, r3
 801be70:	f107 0708 	add.w	r7, r7, #8
 801be74:	46bd      	mov	sp, r7
 801be76:	bd80      	pop	{r7, pc}
 801be78:	08032af8 	.word	0x08032af8

0801be7c <_ZN21rtc_handler_namespace11CRTCHandlerD0Ev>:
CRTCHandler::CRTCHandler() {
	// TODO Auto-generated constructor stub

}

CRTCHandler::~CRTCHandler() {
 801be7c:	b580      	push	{r7, lr}
 801be7e:	b082      	sub	sp, #8
 801be80:	af00      	add	r7, sp, #0
 801be82:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated destructor stub
}
 801be84:	6878      	ldr	r0, [r7, #4]
 801be86:	f7ff ffdd 	bl	801be44 <_ZN21rtc_handler_namespace11CRTCHandlerD1Ev>
 801be8a:	6878      	ldr	r0, [r7, #4]
 801be8c:	f006 f9a2 	bl	80221d4 <_ZdlPv>
 801be90:	687b      	ldr	r3, [r7, #4]
 801be92:	4618      	mov	r0, r3
 801be94:	f107 0708 	add.w	r7, r7, #8
 801be98:	46bd      	mov	sp, r7
 801be9a:	bd80      	pop	{r7, pc}

0801be9c <_ZN21rtc_handler_namespace11CRTCHandler13GetTimeStringEv>:
/**
  * @brief  gives time as string
  * @param  None
  * @retval timestring in the format hh:mm:ss
  */
const char* CRTCHandler::GetTimeString(){
 801be9c:	b480      	push	{r7}
 801be9e:	b083      	sub	sp, #12
 801bea0:	af00      	add	r7, sp, #0
 801bea2:	6078      	str	r0, [r7, #4]
	return "";
 801bea4:	f64b 3374 	movw	r3, #47988	; 0xbb74
 801bea8:	f6c0 0302 	movt	r3, #2050	; 0x802
}
 801beac:	4618      	mov	r0, r3
 801beae:	f107 070c 	add.w	r7, r7, #12
 801beb2:	46bd      	mov	sp, r7
 801beb4:	bc80      	pop	{r7}
 801beb6:	4770      	bx	lr

0801beb8 <_ZN21rtc_handler_namespace11CRTCHandler14GetAlarmStringENS_7eAlarmsE>:
/**
  * @brief  gives alarm time as string
  * @param  alarm  select the alarm to set
  * @retval timestring in the format hh:mm:ss
  */
const char* CRTCHandler::GetAlarmString(eAlarms alarm){
 801beb8:	b480      	push	{r7}
 801beba:	b083      	sub	sp, #12
 801bebc:	af00      	add	r7, sp, #0
 801bebe:	6078      	str	r0, [r7, #4]
 801bec0:	460b      	mov	r3, r1
 801bec2:	70fb      	strb	r3, [r7, #3]
	return "";
 801bec4:	f64b 3374 	movw	r3, #47988	; 0xbb74
 801bec8:	f6c0 0302 	movt	r3, #2050	; 0x802
}
 801becc:	4618      	mov	r0, r3
 801bece:	f107 070c 	add.w	r7, r7, #12
 801bed2:	46bd      	mov	sp, r7
 801bed4:	bc80      	pop	{r7}
 801bed6:	4770      	bx	lr

0801bed8 <_ZN21rtc_handler_namespace11CRTCHandler13SetTimeStringEPKc>:
/**
  * @brief  set time by time string
  * @param  timestring in the format hh:mm:ss
  * @retval none
  */
void CRTCHandler::SetTimeString(const char* timeString){
 801bed8:	b480      	push	{r7}
 801beda:	b083      	sub	sp, #12
 801bedc:	af00      	add	r7, sp, #0
 801bede:	6078      	str	r0, [r7, #4]
 801bee0:	6039      	str	r1, [r7, #0]

}
 801bee2:	f107 070c 	add.w	r7, r7, #12
 801bee6:	46bd      	mov	sp, r7
 801bee8:	bc80      	pop	{r7}
 801beea:	4770      	bx	lr

0801beec <_ZN21rtc_handler_namespace11CRTCHandler14SetAlarmStringEPKcNS_7eAlarmsE>:
  * @brief  set alarm by time string
  * @param  timestring in the format hh:mm:ss
  * @param  alarm  select the alarm to set
  * @retval none
  */
void CRTCHandler::SetAlarmString(const char* timeString, eAlarms alarm){
 801beec:	b480      	push	{r7}
 801beee:	b085      	sub	sp, #20
 801bef0:	af00      	add	r7, sp, #0
 801bef2:	60f8      	str	r0, [r7, #12]
 801bef4:	60b9      	str	r1, [r7, #8]
 801bef6:	4613      	mov	r3, r2
 801bef8:	71fb      	strb	r3, [r7, #7]

}
 801befa:	f107 0714 	add.w	r7, r7, #20
 801befe:	46bd      	mov	sp, r7
 801bf00:	bc80      	pop	{r7}
 801bf02:	4770      	bx	lr

0801bf04 <_ZN21rtc_handler_namespace11CRTCHandler12HardwareInitEv>:
/**
  * @brief  HardwareInit called before Scheduler starts
  * @param  None
  * @retval true on succsess
  */
bool CRTCHandler::HardwareInit(){
 801bf04:	b580      	push	{r7, lr}
 801bf06:	b086      	sub	sp, #24
 801bf08:	af00      	add	r7, sp, #0
 801bf0a:	6078      	str	r0, [r7, #4]
	uint32_t LsiFreq;
	RTC_InitTypeDef  RTC_InitStructure;

	/* RTC Configuration -------------------------------------------------------*/
	RTC_Config();
 801bf0c:	6878      	ldr	r0, [r7, #4]
 801bf0e:	f000 f827 	bl	801bf60 <_ZN21rtc_handler_namespace11CRTCHandler10RTC_ConfigEv>

	/* Get the LSI frequency:  TIM5 is used to measure the LSI frequency */
	LsiFreq = GetLSIFrequency();
 801bf12:	6878      	ldr	r0, [r7, #4]
 801bf14:	f000 f898 	bl	801c048 <_ZN21rtc_handler_namespace11CRTCHandler15GetLSIFrequencyEv>
 801bf18:	4603      	mov	r3, r0
 801bf1a:	617b      	str	r3, [r7, #20]

	/* Calendar Configuration */
	RTC_InitStructure.RTC_AsynchPrediv = 0x7F;
 801bf1c:	f04f 037f 	mov.w	r3, #127	; 0x7f
 801bf20:	60fb      	str	r3, [r7, #12]
	RTC_InitStructure.RTC_SynchPrediv	=  (LsiFreq/128) - 1;
 801bf22:	697b      	ldr	r3, [r7, #20]
 801bf24:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 801bf28:	f103 33ff 	add.w	r3, r3, #4294967295
 801bf2c:	613b      	str	r3, [r7, #16]
	RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
 801bf2e:	f04f 0300 	mov.w	r3, #0
 801bf32:	60bb      	str	r3, [r7, #8]
	RTC_Init(&RTC_InitStructure);
 801bf34:	f107 0308 	add.w	r3, r7, #8
 801bf38:	4618      	mov	r0, r3
 801bf3a:	f7ed fa9b 	bl	8009474 <RTC_Init>

	return true;
 801bf3e:	f04f 0301 	mov.w	r3, #1
}
 801bf42:	4618      	mov	r0, r3
 801bf44:	f107 0718 	add.w	r7, r7, #24
 801bf48:	46bd      	mov	sp, r7
 801bf4a:	bd80      	pop	{r7, pc}

0801bf4c <_ZN21rtc_handler_namespace11CRTCHandler3RunEv>:
/**
  * @brief  task function for Rtc handling
  * @param  None
  * @retval None
  */
void CRTCHandler::Run(){
 801bf4c:	b480      	push	{r7}
 801bf4e:	b083      	sub	sp, #12
 801bf50:	af00      	add	r7, sp, #0
 801bf52:	6078      	str	r0, [r7, #4]

}
 801bf54:	f107 070c 	add.w	r7, r7, #12
 801bf58:	46bd      	mov	sp, r7
 801bf5a:	bc80      	pop	{r7}
 801bf5c:	4770      	bx	lr
 801bf5e:	bf00      	nop

0801bf60 <_ZN21rtc_handler_namespace11CRTCHandler10RTC_ConfigEv>:
  * @brief  Configure the RTC peripheral by selecting the clock source.
  * @param  None
  * @retval None
  */
void CRTCHandler::RTC_Config(void)
{
 801bf60:	b580      	push	{r7, lr}
 801bf62:	b088      	sub	sp, #32
 801bf64:	af00      	add	r7, sp, #0
 801bf66:	6078      	str	r0, [r7, #4]
	NVIC_InitTypeDef NVIC_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;
	RTC_InitTypeDef   RTC_InitStructure;

	/* Enable the PWR clock */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
 801bf68:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 801bf6c:	f04f 0101 	mov.w	r1, #1
 801bf70:	f7ec ff00 	bl	8008d74 <RCC_APB1PeriphClockCmd>

	/* Allow access to RTC */
	PWR_BackupAccessCmd(ENABLE);
 801bf74:	f04f 0001 	mov.w	r0, #1
 801bf78:	f7ec f9a6 	bl	80082c8 <PWR_BackupAccessCmd>

	/* LSI used as RTC source clock */
	/* The RTC Clock may varies due to LSI frequency dispersion. */
	/* Enable the LSI OSC */
	RCC_LSICmd(ENABLE);
 801bf7c:	f04f 0001 	mov.w	r0, #1
 801bf80:	f7ec fbca 	bl	8008718 <RCC_LSICmd>

	/* Wait till LSI is ready */
	while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
 801bf84:	bf00      	nop
 801bf86:	f04f 0061 	mov.w	r0, #97	; 0x61
 801bf8a:	f7ed f933 	bl	80091f4 <RCC_GetFlagStatus>
 801bf8e:	4603      	mov	r3, r0
 801bf90:	2b00      	cmp	r3, #0
 801bf92:	bf14      	ite	ne
 801bf94:	2300      	movne	r3, #0
 801bf96:	2301      	moveq	r3, #1
 801bf98:	b2db      	uxtb	r3, r3
 801bf9a:	2b00      	cmp	r3, #0
 801bf9c:	d1f3      	bne.n	801bf86 <_ZN21rtc_handler_namespace11CRTCHandler10RTC_ConfigEv+0x26>
	{
	}

	/* Select the RTC Clock Source */
	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
 801bf9e:	f44f 7000 	mov.w	r0, #512	; 0x200
 801bfa2:	f7ec fdf7 	bl	8008b94 <RCC_RTCCLKConfig>

	/* Enable the RTC Clock */
	RCC_RTCCLKCmd(ENABLE);
 801bfa6:	f04f 0001 	mov.w	r0, #1
 801bfaa:	f7ec fe2f 	bl	8008c0c <RCC_RTCCLKCmd>

	/* Wait for RTC APB registers synchronisation */
	RTC_WaitForSynchro();
 801bfae:	f7ed fb59 	bl	8009664 <RTC_WaitForSynchro>

	/* Calendar Configuration with LSI supposed at 32KHz */
	RTC_InitStructure.RTC_AsynchPrediv = 0x7F;
 801bfb2:	f04f 037f 	mov.w	r3, #127	; 0x7f
 801bfb6:	60fb      	str	r3, [r7, #12]
	RTC_InitStructure.RTC_SynchPrediv	=  0xFF; /* (32KHz / 128) - 1 = 0xFF*/
 801bfb8:	f04f 03ff 	mov.w	r3, #255	; 0xff
 801bfbc:	613b      	str	r3, [r7, #16]
	RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
 801bfbe:	f04f 0300 	mov.w	r3, #0
 801bfc2:	60bb      	str	r3, [r7, #8]
	RTC_Init(&RTC_InitStructure);
 801bfc4:	f107 0308 	add.w	r3, r7, #8
 801bfc8:	4618      	mov	r0, r3
 801bfca:	f7ed fa53 	bl	8009474 <RTC_Init>

	/* EXTI configuration *******************************************************/
	EXTI_ClearITPendingBit(EXTI_Line22);
 801bfce:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 801bfd2:	f7eb f9a9 	bl	8007328 <EXTI_ClearITPendingBit>
	EXTI_InitStructure.EXTI_Line = EXTI_Line22;
 801bfd6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 801bfda:	617b      	str	r3, [r7, #20]
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 801bfdc:	f04f 0300 	mov.w	r3, #0
 801bfe0:	763b      	strb	r3, [r7, #24]
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 801bfe2:	f04f 0308 	mov.w	r3, #8
 801bfe6:	767b      	strb	r3, [r7, #25]
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 801bfe8:	f04f 0301 	mov.w	r3, #1
 801bfec:	76bb      	strb	r3, [r7, #26]
	EXTI_Init(&EXTI_InitStructure);
 801bfee:	f107 0314 	add.w	r3, r7, #20
 801bff2:	4618      	mov	r0, r3
 801bff4:	f7eb f868 	bl	80070c8 <EXTI_Init>

	/* Enable the RTC Wakeup Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = RTC_WKUP_IRQn;
 801bff8:	f04f 0303 	mov.w	r3, #3
 801bffc:	773b      	strb	r3, [r7, #28]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 801bffe:	f04f 0300 	mov.w	r3, #0
 801c002:	777b      	strb	r3, [r7, #29]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 801c004:	f04f 0300 	mov.w	r3, #0
 801c008:	77bb      	strb	r3, [r7, #30]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 801c00a:	f04f 0301 	mov.w	r3, #1
 801c00e:	77fb      	strb	r3, [r7, #31]
	NVIC_Init(&NVIC_InitStructure);
 801c010:	f107 031c 	add.w	r3, r7, #28
 801c014:	4618      	mov	r0, r3
 801c016:	f7ea f8ab 	bl	8006170 <NVIC_Init>

	/* Configure the RTC WakeUp Clock source: CK_SPRE (1Hz) */
	RTC_WakeUpClockConfig(RTC_WakeUpClock_CK_SPRE_16bits);
 801c01a:	f04f 0004 	mov.w	r0, #4
 801c01e:	f7ee f86f 	bl	800a100 <RTC_WakeUpClockConfig>
	RTC_SetWakeUpCounter(0x0);
 801c022:	f04f 0000 	mov.w	r0, #0
 801c026:	f7ee f8a3 	bl	800a170 <RTC_SetWakeUpCounter>

	/* Enable the RTC Wakeup Interrupt */
	RTC_ITConfig(RTC_IT_WUT, ENABLE);
 801c02a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 801c02e:	f04f 0101 	mov.w	r1, #1
 801c032:	f7ee fe19 	bl	800ac68 <RTC_ITConfig>

	/* Enable Wakeup Counter */
	RTC_WakeUpCmd(ENABLE);
 801c036:	f04f 0001 	mov.w	r0, #1
 801c03a:	f7ee f8cd 	bl	800a1d8 <RTC_WakeUpCmd>
}
 801c03e:	f107 0720 	add.w	r7, r7, #32
 801c042:	46bd      	mov	sp, r7
 801c044:	bd80      	pop	{r7, pc}
 801c046:	bf00      	nop

0801c048 <_ZN21rtc_handler_namespace11CRTCHandler15GetLSIFrequencyEv>:
  * @brief  Configures TIM5 to measure the LSI oscillator frequency.
  * @param  None
  * @retval LSI Frequency
  */
uint32_t CRTCHandler::GetLSIFrequency(void)
{
 801c048:	b580      	push	{r7, lr}
 801c04a:	b08a      	sub	sp, #40	; 0x28
 801c04c:	af00      	add	r7, sp, #0
 801c04e:	6078      	str	r0, [r7, #4]
	NVIC_InitTypeDef   NVIC_InitStructure;
	TIM_ICInitTypeDef  TIM_ICInitStructure;
	RCC_ClocksTypeDef  RCC_ClockFreq;

	/* Enable the LSI oscillator ************************************************/
	RCC_LSICmd(ENABLE);
 801c050:	f04f 0001 	mov.w	r0, #1
 801c054:	f7ec fb60 	bl	8008718 <RCC_LSICmd>

	/* Wait till LSI is ready */
	while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
 801c058:	bf00      	nop
 801c05a:	f04f 0061 	mov.w	r0, #97	; 0x61
 801c05e:	f7ed f8c9 	bl	80091f4 <RCC_GetFlagStatus>
 801c062:	4603      	mov	r3, r0
 801c064:	2b00      	cmp	r3, #0
 801c066:	bf14      	ite	ne
 801c068:	2300      	movne	r3, #0
 801c06a:	2301      	moveq	r3, #1
 801c06c:	b2db      	uxtb	r3, r3
 801c06e:	2b00      	cmp	r3, #0
 801c070:	d1f3      	bne.n	801c05a <_ZN21rtc_handler_namespace11CRTCHandler15GetLSIFrequencyEv+0x12>
	{}

	/* TIM5 configuration *******************************************************/
	/* Enable TIM5 clock */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
 801c072:	f04f 0008 	mov.w	r0, #8
 801c076:	f04f 0101 	mov.w	r1, #1
 801c07a:	f7ec fe7b 	bl	8008d74 <RCC_APB1PeriphClockCmd>

	/* Connect internally the TIM5_CH4 Input Capture to the LSI clock output */
	TIM_RemapConfig(TIM5, TIM5_LSI);
 801c07e:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 801c082:	f2c4 0000 	movt	r0, #16384	; 0x4000
 801c086:	f04f 0140 	mov.w	r1, #64	; 0x40
 801c08a:	f7f1 fa09 	bl	800d4a0 <TIM_RemapConfig>

	/* Configure TIM5 presclaer */
	TIM_PrescalerConfig(TIM5, 0, TIM_PSCReloadMode_Immediate);
 801c08e:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 801c092:	f2c4 0000 	movt	r0, #16384	; 0x4000
 801c096:	f04f 0100 	mov.w	r1, #0
 801c09a:	f04f 0201 	mov.w	r2, #1
 801c09e:	f7ef fe2f 	bl	800bd00 <TIM_PrescalerConfig>
	/* TIM5 configuration: Input Capture mode ---------------------
     The LSI oscillator is connected to TIM5 CH4
     The Rising edge is used as active edge,
     The TIM5 CCR4 is used to compute the frequency value
  ------------------------------------------------------------ */
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_4;
 801c0a2:	f04f 030c 	mov.w	r3, #12
 801c0a6:	833b      	strh	r3, [r7, #24]
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
 801c0a8:	f04f 0300 	mov.w	r3, #0
 801c0ac:	837b      	strh	r3, [r7, #26]
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
 801c0ae:	f04f 0301 	mov.w	r3, #1
 801c0b2:	83bb      	strh	r3, [r7, #28]
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV8;
 801c0b4:	f04f 030c 	mov.w	r3, #12
 801c0b8:	83fb      	strh	r3, [r7, #30]
	TIM_ICInitStructure.TIM_ICFilter = 0;
 801c0ba:	f04f 0300 	mov.w	r3, #0
 801c0be:	843b      	strh	r3, [r7, #32]
	TIM_ICInit(TIM5, &TIM_ICInitStructure);
 801c0c0:	f107 0318 	add.w	r3, r7, #24
 801c0c4:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 801c0c8:	f2c4 0000 	movt	r0, #16384	; 0x4000
 801c0cc:	4619      	mov	r1, r3
 801c0ce:	f7f0 fd21 	bl	800cb14 <TIM_ICInit>

	/* Enable TIM5 Interrupt channel */
	NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;
 801c0d2:	f04f 0332 	mov.w	r3, #50	; 0x32
 801c0d6:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 801c0da:	f04f 0300 	mov.w	r3, #0
 801c0de:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 801c0e2:	f04f 0300 	mov.w	r3, #0
 801c0e6:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 801c0ea:	f04f 0301 	mov.w	r3, #1
 801c0ee:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	NVIC_Init(&NVIC_InitStructure);
 801c0f2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c0f6:	4618      	mov	r0, r3
 801c0f8:	f7ea f83a 	bl	8006170 <NVIC_Init>

	/* Enable TIM5 counter */
	TIM_Cmd(TIM5, ENABLE);
 801c0fc:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 801c100:	f2c4 0000 	movt	r0, #16384	; 0x4000
 801c104:	f04f 0101 	mov.w	r1, #1
 801c108:	f7ef fef8 	bl	800befc <TIM_Cmd>

	/* Reset the flags */
	TIM5->SR = 0;
 801c10c:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 801c110:	f2c4 0300 	movt	r3, #16384	; 0x4000
 801c114:	f04f 0200 	mov.w	r2, #0
 801c118:	821a      	strh	r2, [r3, #16]

	/* Enable the CC4 Interrupt Request */
	TIM_ITConfig(TIM5, TIM_IT_CC4, ENABLE);
 801c11a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 801c11e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 801c122:	f04f 0110 	mov.w	r1, #16
 801c126:	f04f 0201 	mov.w	r2, #1
 801c12a:	f7f0 ff21 	bl	800cf70 <TIM_ITConfig>


	/* Wait until the TIM5 get 2 LSI edges (refer to TIM5_IRQHandler() in
    stm32f2xx_it.c file) ******************************************************/
	while(CaptureNumber != 2)
 801c12e:	f640 33ac 	movw	r3, #2988	; 0xbac
 801c132:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c136:	681b      	ldr	r3, [r3, #0]
 801c138:	2b02      	cmp	r3, #2
 801c13a:	bf0c      	ite	eq
 801c13c:	2300      	moveq	r3, #0
 801c13e:	2301      	movne	r3, #1
 801c140:	b2db      	uxtb	r3, r3
 801c142:	2b00      	cmp	r3, #0
 801c144:	d1f3      	bne.n	801c12e <_ZN21rtc_handler_namespace11CRTCHandler15GetLSIFrequencyEv+0xe6>
	{
	}
	/* Deinitialize the TIM5 peripheral registers to their default reset values */
	TIM_DeInit(TIM5);
 801c146:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 801c14a:	f2c4 0000 	movt	r0, #16384	; 0x4000
 801c14e:	f7ef fc23 	bl	800b998 <TIM_DeInit>


	/* Compute the LSI frequency, depending on TIM5 input clock frequency (PCLK1)*/
	/* Get SYSCLK, HCLK and PCLKx frequency */
	RCC_GetClocksFreq(&RCC_ClockFreq);
 801c152:	f107 0308 	add.w	r3, r7, #8
 801c156:	4618      	mov	r0, r3
 801c158:	f7ec fc34 	bl	80089c4 <RCC_GetClocksFreq>

	/* Get PCLK1 prescaler */
	if ((RCC->CFGR & RCC_CFGR_PPRE1) == 0)
 801c15c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 801c160:	f2c4 0302 	movt	r3, #16386	; 0x4002
 801c164:	689b      	ldr	r3, [r3, #8]
 801c166:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 801c16a:	2b00      	cmp	r3, #0
 801c16c:	bf14      	ite	ne
 801c16e:	2300      	movne	r3, #0
 801c170:	2301      	moveq	r3, #1
 801c172:	b2db      	uxtb	r3, r3
 801c174:	2b00      	cmp	r3, #0
 801c176:	d00a      	beq.n	801c18e <_ZN21rtc_handler_namespace11CRTCHandler15GetLSIFrequencyEv+0x146>
	{
		/* PCLK1 prescaler equal to 1 => TIMCLK = PCLK1 */
		return ((RCC_ClockFreq.PCLK1_Frequency / PeriodValue) * 8);
 801c178:	693a      	ldr	r2, [r7, #16]
 801c17a:	f640 33a8 	movw	r3, #2984	; 0xba8
 801c17e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c182:	681b      	ldr	r3, [r3, #0]
 801c184:	fbb2 f3f3 	udiv	r3, r2, r3
 801c188:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801c18c:	e00b      	b.n	801c1a6 <_ZN21rtc_handler_namespace11CRTCHandler15GetLSIFrequencyEv+0x15e>
	}
	else
	{ /* PCLK1 prescaler different from 1 => TIMCLK = 2 * PCLK1 */
		return (((2 * RCC_ClockFreq.PCLK1_Frequency) / PeriodValue) * 8) ;
 801c18e:	693b      	ldr	r3, [r7, #16]
 801c190:	ea4f 0243 	mov.w	r2, r3, lsl #1
 801c194:	f640 33a8 	movw	r3, #2984	; 0xba8
 801c198:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c19c:	681b      	ldr	r3, [r3, #0]
 801c19e:	fbb2 f3f3 	udiv	r3, r2, r3
 801c1a2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
	}
}
 801c1a6:	4618      	mov	r0, r3
 801c1a8:	f107 0728 	add.w	r7, r7, #40	; 0x28
 801c1ac:	46bd      	mov	sp, r7
 801c1ae:	bd80      	pop	{r7, pc}

0801c1b0 <TIM5_IRQHandler>:
	 * @brief  This function handles TIM5 global interrupt request.
	 * @param  None
	 * @retval None
	 */
	void TIM5_IRQHandler(void)
	{
 801c1b0:	b598      	push	{r3, r4, r7, lr}
 801c1b2:	af00      	add	r7, sp, #0
		if (TIM_GetITStatus(TIM5, TIM_IT_CC4) != RESET)
 801c1b4:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 801c1b8:	f2c4 0000 	movt	r0, #16384	; 0x4000
 801c1bc:	f04f 0110 	mov.w	r1, #16
 801c1c0:	f7f0 ff3a 	bl	800d038 <TIM_GetITStatus>
 801c1c4:	4603      	mov	r3, r0
 801c1c6:	2b00      	cmp	r3, #0
 801c1c8:	bf0c      	ite	eq
 801c1ca:	2300      	moveq	r3, #0
 801c1cc:	2301      	movne	r3, #1
 801c1ce:	b2db      	uxtb	r3, r3
 801c1d0:	2b00      	cmp	r3, #0
 801c1d2:	d040      	beq.n	801c256 <TIM5_IRQHandler+0xa6>
		{
			/* Get the Input Capture value */
			tmpCC4[CaptureNumber++] = TIM_GetCapture4(TIM5);
 801c1d4:	f640 33ac 	movw	r3, #2988	; 0xbac
 801c1d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c1dc:	681c      	ldr	r4, [r3, #0]
 801c1de:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 801c1e2:	f2c4 0000 	movt	r0, #16384	; 0x4000
 801c1e6:	f7f0 fd8d 	bl	800cd04 <TIM_GetCapture4>
 801c1ea:	4603      	mov	r3, r0
 801c1ec:	b29a      	uxth	r2, r3
 801c1ee:	f640 33b0 	movw	r3, #2992	; 0xbb0
 801c1f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c1f6:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
 801c1fa:	f104 0201 	add.w	r2, r4, #1
 801c1fe:	f640 33ac 	movw	r3, #2988	; 0xbac
 801c202:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c206:	601a      	str	r2, [r3, #0]

			/* Clear CC4 Interrupt pending bit */
			TIM_ClearITPendingBit(TIM5, TIM_IT_CC4);
 801c208:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 801c20c:	f2c4 0000 	movt	r0, #16384	; 0x4000
 801c210:	f04f 0110 	mov.w	r1, #16
 801c214:	f7f0 ff40 	bl	800d098 <TIM_ClearITPendingBit>

			if (CaptureNumber >= 2)
 801c218:	f640 33ac 	movw	r3, #2988	; 0xbac
 801c21c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c220:	681b      	ldr	r3, [r3, #0]
 801c222:	2b01      	cmp	r3, #1
 801c224:	d917      	bls.n	801c256 <TIM5_IRQHandler+0xa6>
			{
				/* Compute the period length */
				PeriodValue = (uint16_t)(0xFFFF - tmpCC4[0] + tmpCC4[1] + 1);
 801c226:	f640 33b0 	movw	r3, #2992	; 0xbb0
 801c22a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c22e:	881b      	ldrh	r3, [r3, #0]
 801c230:	ea6f 0303 	mvn.w	r3, r3
 801c234:	b29a      	uxth	r2, r3
 801c236:	f640 33b0 	movw	r3, #2992	; 0xbb0
 801c23a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c23e:	885b      	ldrh	r3, [r3, #2]
 801c240:	18d3      	adds	r3, r2, r3
 801c242:	b29b      	uxth	r3, r3
 801c244:	f103 0301 	add.w	r3, r3, #1
 801c248:	b29b      	uxth	r3, r3
 801c24a:	461a      	mov	r2, r3
 801c24c:	f640 33a8 	movw	r3, #2984	; 0xba8
 801c250:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c254:	601a      	str	r2, [r3, #0]
			}
		}
	}
 801c256:	bd98      	pop	{r3, r4, r7, pc}

0801c258 <_ZN4Time5CTimeC1Ev>:


/**
 * @brief baseline constructor
 */
CTime::CTime():_Time(0) {
 801c258:	b480      	push	{r7}
 801c25a:	b083      	sub	sp, #12
 801c25c:	af00      	add	r7, sp, #0
 801c25e:	6078      	str	r0, [r7, #4]
 801c260:	687b      	ldr	r3, [r7, #4]
 801c262:	4a06      	ldr	r2, [pc, #24]	; (801c27c <_ZN4Time5CTimeC1Ev+0x24>)
 801c264:	601a      	str	r2, [r3, #0]
 801c266:	687b      	ldr	r3, [r7, #4]
 801c268:	f04f 0200 	mov.w	r2, #0
 801c26c:	605a      	str	r2, [r3, #4]
}
 801c26e:	687b      	ldr	r3, [r7, #4]
 801c270:	4618      	mov	r0, r3
 801c272:	f107 070c 	add.w	r7, r7, #12
 801c276:	46bd      	mov	sp, r7
 801c278:	bc80      	pop	{r7}
 801c27a:	4770      	bx	lr
 801c27c:	08032b20 	.word	0x08032b20

0801c280 <_ZN4Time5CTimeC1ERKS0_>:

/**
 * @brief copy constructor
 * @param time will be copied
 */
CTime::CTime(CTime const& time):_Time(time._Time){
 801c280:	b480      	push	{r7}
 801c282:	b083      	sub	sp, #12
 801c284:	af00      	add	r7, sp, #0
 801c286:	6078      	str	r0, [r7, #4]
 801c288:	6039      	str	r1, [r7, #0]
 801c28a:	687b      	ldr	r3, [r7, #4]
 801c28c:	4a06      	ldr	r2, [pc, #24]	; (801c2a8 <_ZN4Time5CTimeC1ERKS0_+0x28>)
 801c28e:	601a      	str	r2, [r3, #0]
 801c290:	683b      	ldr	r3, [r7, #0]
 801c292:	685a      	ldr	r2, [r3, #4]
 801c294:	687b      	ldr	r3, [r7, #4]
 801c296:	605a      	str	r2, [r3, #4]
}
 801c298:	687b      	ldr	r3, [r7, #4]
 801c29a:	4618      	mov	r0, r3
 801c29c:	f107 070c 	add.w	r7, r7, #12
 801c2a0:	46bd      	mov	sp, r7
 801c2a2:	bc80      	pop	{r7}
 801c2a4:	4770      	bx	lr
 801c2a6:	bf00      	nop
 801c2a8:	08032b20 	.word	0x08032b20

0801c2ac <_ZN4Time5CTimeC1Ehhhhht>:
 * @param day  day of the month 1-31
 * @param month  months since January 0-11
 * @param year  year in yyyy
 *
 */
CTime::CTime(uint8_t sec, uint8_t min, uint8_t hour, uint8_t day, uint8_t month, uint16_t year):_Time(0){
 801c2ac:	b580      	push	{r7, lr}
 801c2ae:	b084      	sub	sp, #16
 801c2b0:	af00      	add	r7, sp, #0
 801c2b2:	6078      	str	r0, [r7, #4]
 801c2b4:	70f9      	strb	r1, [r7, #3]
 801c2b6:	70ba      	strb	r2, [r7, #2]
 801c2b8:	707b      	strb	r3, [r7, #1]
 801c2ba:	687b      	ldr	r3, [r7, #4]
 801c2bc:	4a13      	ldr	r2, [pc, #76]	; (801c30c <_ZN4Time5CTimeC1Ehhhhht+0x60>)
 801c2be:	601a      	str	r2, [r3, #0]
 801c2c0:	687b      	ldr	r3, [r7, #4]
 801c2c2:	f04f 0200 	mov.w	r2, #0
 801c2c6:	605a      	str	r2, [r3, #4]
	struct std::tm* newTime = 0;
 801c2c8:	f04f 0300 	mov.w	r3, #0
 801c2cc:	60fb      	str	r3, [r7, #12]

	newTime->tm_sec = sec;
 801c2ce:	78fa      	ldrb	r2, [r7, #3]
 801c2d0:	68fb      	ldr	r3, [r7, #12]
 801c2d2:	601a      	str	r2, [r3, #0]
	newTime->tm_min = min;
 801c2d4:	78ba      	ldrb	r2, [r7, #2]
 801c2d6:	68fb      	ldr	r3, [r7, #12]
 801c2d8:	605a      	str	r2, [r3, #4]
	newTime->tm_hour = hour;
 801c2da:	787a      	ldrb	r2, [r7, #1]
 801c2dc:	68fb      	ldr	r3, [r7, #12]
 801c2de:	609a      	str	r2, [r3, #8]
	newTime->tm_mday = day;
 801c2e0:	7e3a      	ldrb	r2, [r7, #24]
 801c2e2:	68fb      	ldr	r3, [r7, #12]
 801c2e4:	60da      	str	r2, [r3, #12]
	newTime->tm_mon = month;
 801c2e6:	7f3a      	ldrb	r2, [r7, #28]
 801c2e8:	68fb      	ldr	r3, [r7, #12]
 801c2ea:	611a      	str	r2, [r3, #16]
	newTime->tm_year = year;
 801c2ec:	8c3a      	ldrh	r2, [r7, #32]
 801c2ee:	68fb      	ldr	r3, [r7, #12]
 801c2f0:	615a      	str	r2, [r3, #20]

	_Time = std::mktime(newTime);
 801c2f2:	68f8      	ldr	r0, [r7, #12]
 801c2f4:	f009 fa02 	bl	80256fc <mktime>
 801c2f8:	4602      	mov	r2, r0
 801c2fa:	687b      	ldr	r3, [r7, #4]
 801c2fc:	605a      	str	r2, [r3, #4]
}
 801c2fe:	687b      	ldr	r3, [r7, #4]
 801c300:	4618      	mov	r0, r3
 801c302:	f107 0710 	add.w	r7, r7, #16
 801c306:	46bd      	mov	sp, r7
 801c308:	bd80      	pop	{r7, pc}
 801c30a:	bf00      	nop
 801c30c:	08032b20 	.word	0x08032b20

0801c310 <_ZN4Time5CTimeD1Ev>:

/**
 * @brief standard destructor
 */
CTime::~CTime() {
 801c310:	b580      	push	{r7, lr}
 801c312:	b082      	sub	sp, #8
 801c314:	af00      	add	r7, sp, #0
 801c316:	6078      	str	r0, [r7, #4]
 801c318:	687b      	ldr	r3, [r7, #4]
 801c31a:	4a09      	ldr	r2, [pc, #36]	; (801c340 <_ZN4Time5CTimeD1Ev+0x30>)
 801c31c:	601a      	str	r2, [r3, #0]
	// nothing dynamically allocated
}
 801c31e:	f04f 0300 	mov.w	r3, #0
 801c322:	f003 0301 	and.w	r3, r3, #1
 801c326:	b2db      	uxtb	r3, r3
 801c328:	2b00      	cmp	r3, #0
 801c32a:	d002      	beq.n	801c332 <_ZN4Time5CTimeD1Ev+0x22>
 801c32c:	6878      	ldr	r0, [r7, #4]
 801c32e:	f005 ff51 	bl	80221d4 <_ZdlPv>
 801c332:	687b      	ldr	r3, [r7, #4]
 801c334:	4618      	mov	r0, r3
 801c336:	f107 0708 	add.w	r7, r7, #8
 801c33a:	46bd      	mov	sp, r7
 801c33c:	bd80      	pop	{r7, pc}
 801c33e:	bf00      	nop
 801c340:	08032b20 	.word	0x08032b20

0801c344 <_ZN4Time5CTimeD0Ev>:
}

/**
 * @brief standard destructor
 */
CTime::~CTime() {
 801c344:	b580      	push	{r7, lr}
 801c346:	b082      	sub	sp, #8
 801c348:	af00      	add	r7, sp, #0
 801c34a:	6078      	str	r0, [r7, #4]
	// nothing dynamically allocated
}
 801c34c:	6878      	ldr	r0, [r7, #4]
 801c34e:	f7ff ffdf 	bl	801c310 <_ZN4Time5CTimeD1Ev>
 801c352:	6878      	ldr	r0, [r7, #4]
 801c354:	f005 ff3e 	bl	80221d4 <_ZdlPv>
 801c358:	687b      	ldr	r3, [r7, #4]
 801c35a:	4618      	mov	r0, r3
 801c35c:	f107 0708 	add.w	r7, r7, #8
 801c360:	46bd      	mov	sp, r7
 801c362:	bd80      	pop	{r7, pc}

0801c364 <_ZN4Time5CTimeaSERKS0_>:
/**
 * assign operator
 * @param rhs object to assign to this instance
 * @return rhs reference on result
 */
const CTime& CTime::operator= (const CTime& rhs){
 801c364:	b480      	push	{r7}
 801c366:	b083      	sub	sp, #12
 801c368:	af00      	add	r7, sp, #0
 801c36a:	6078      	str	r0, [r7, #4]
 801c36c:	6039      	str	r1, [r7, #0]
	_Time = rhs._Time;
 801c36e:	683b      	ldr	r3, [r7, #0]
 801c370:	685a      	ldr	r2, [r3, #4]
 801c372:	687b      	ldr	r3, [r7, #4]
 801c374:	605a      	str	r2, [r3, #4]
	return *this;
 801c376:	687b      	ldr	r3, [r7, #4]
}
 801c378:	4618      	mov	r0, r3
 801c37a:	f107 070c 	add.w	r7, r7, #12
 801c37e:	46bd      	mov	sp, r7
 801c380:	bc80      	pop	{r7}
 801c382:	4770      	bx	lr

0801c384 <_ZN4Time5CTime13getTimeStringEPc>:
/**
 * format time data to hh:mm:ss
 * @param buffer bigger than 9 chars
 * @return chars inserted in buffer, 0 if failed
 */
unsigned int CTime::getTimeString(char* buffer){
 801c384:	b580      	push	{r7, lr}
 801c386:	b082      	sub	sp, #8
 801c388:	af00      	add	r7, sp, #0
 801c38a:	6078      	str	r0, [r7, #4]
 801c38c:	6039      	str	r1, [r7, #0]
	return std::strftime(buffer,sizeof(buffer),"%X",std::gmtime(&_Time));
 801c38e:	687b      	ldr	r3, [r7, #4]
 801c390:	f103 0304 	add.w	r3, r3, #4
 801c394:	4618      	mov	r0, r3
 801c396:	f008 fcdf 	bl	8024d58 <gmtime>
 801c39a:	4603      	mov	r3, r0
 801c39c:	6838      	ldr	r0, [r7, #0]
 801c39e:	f04f 0104 	mov.w	r1, #4
 801c3a2:	f64b 3278 	movw	r2, #47992	; 0xbb78
 801c3a6:	f6c0 0202 	movt	r2, #2050	; 0x802
 801c3aa:	f009 fecd 	bl	8026148 <strftime>
 801c3ae:	4603      	mov	r3, r0
}
 801c3b0:	4618      	mov	r0, r3
 801c3b2:	f107 0708 	add.w	r7, r7, #8
 801c3b6:	46bd      	mov	sp, r7
 801c3b8:	bd80      	pop	{r7, pc}
 801c3ba:	bf00      	nop

0801c3bc <_ZN4Time5CTime13getDateStringEPc>:
/**
 * format date to Thu 21 Aug 2012
 * @param buffer bigger than 16 chars
 * @return chars inserted in buffer, 0 if failed
 */
unsigned int CTime::getDateString(char* buffer){
 801c3bc:	b580      	push	{r7, lr}
 801c3be:	b082      	sub	sp, #8
 801c3c0:	af00      	add	r7, sp, #0
 801c3c2:	6078      	str	r0, [r7, #4]
 801c3c4:	6039      	str	r1, [r7, #0]
	return std::strftime(buffer,sizeof(buffer),"%a %d &b %Y",std::gmtime(&_Time));
 801c3c6:	687b      	ldr	r3, [r7, #4]
 801c3c8:	f103 0304 	add.w	r3, r3, #4
 801c3cc:	4618      	mov	r0, r3
 801c3ce:	f008 fcc3 	bl	8024d58 <gmtime>
 801c3d2:	4603      	mov	r3, r0
 801c3d4:	6838      	ldr	r0, [r7, #0]
 801c3d6:	f04f 0104 	mov.w	r1, #4
 801c3da:	f64b 327c 	movw	r2, #47996	; 0xbb7c
 801c3de:	f6c0 0202 	movt	r2, #2050	; 0x802
 801c3e2:	f009 feb1 	bl	8026148 <strftime>
 801c3e6:	4603      	mov	r3, r0
}
 801c3e8:	4618      	mov	r0, r3
 801c3ea:	f107 0708 	add.w	r7, r7, #8
 801c3ee:	46bd      	mov	sp, r7
 801c3f0:	bd80      	pop	{r7, pc}
 801c3f2:	bf00      	nop

0801c3f4 <_ZN4Time5CTime19getWeekNumberStringEPc>:
/**
 * format weeknumber to "Week 51"
 * @param buffer bigger than 8 chars
 * @return chars inserted in buffer, 0 if failed
 */
unsigned int CTime::getWeekNumberString(char* buffer){
 801c3f4:	b580      	push	{r7, lr}
 801c3f6:	b082      	sub	sp, #8
 801c3f8:	af00      	add	r7, sp, #0
 801c3fa:	6078      	str	r0, [r7, #4]
 801c3fc:	6039      	str	r1, [r7, #0]
	return std::strftime(buffer,sizeof(buffer),"Week: %W",std::gmtime(&_Time));
 801c3fe:	687b      	ldr	r3, [r7, #4]
 801c400:	f103 0304 	add.w	r3, r3, #4
 801c404:	4618      	mov	r0, r3
 801c406:	f008 fca7 	bl	8024d58 <gmtime>
 801c40a:	4603      	mov	r3, r0
 801c40c:	6838      	ldr	r0, [r7, #0]
 801c40e:	f04f 0104 	mov.w	r1, #4
 801c412:	f64b 3288 	movw	r2, #48008	; 0xbb88
 801c416:	f6c0 0202 	movt	r2, #2050	; 0x802
 801c41a:	f009 fe95 	bl	8026148 <strftime>
 801c41e:	4603      	mov	r3, r0
}
 801c420:	4618      	mov	r0, r3
 801c422:	f107 0708 	add.w	r7, r7, #8
 801c426:	46bd      	mov	sp, r7
 801c428:	bd80      	pop	{r7, pc}
 801c42a:	bf00      	nop

0801c42c <_ZN4TimeplERKNS_5CTimeES2_>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left + right
 */
CTime operator+ (const CTime& left, const CTime& right){
 801c42c:	b580      	push	{r7, lr}
 801c42e:	b084      	sub	sp, #16
 801c430:	af00      	add	r7, sp, #0
 801c432:	60f8      	str	r0, [r7, #12]
 801c434:	60b9      	str	r1, [r7, #8]
 801c436:	607a      	str	r2, [r7, #4]
	CTime result;
 801c438:	68f8      	ldr	r0, [r7, #12]
 801c43a:	f7ff ff0d 	bl	801c258 <_ZN4Time5CTimeC1Ev>

	result._Time = left._Time + right._Time;
 801c43e:	68bb      	ldr	r3, [r7, #8]
 801c440:	685a      	ldr	r2, [r3, #4]
 801c442:	687b      	ldr	r3, [r7, #4]
 801c444:	685b      	ldr	r3, [r3, #4]
 801c446:	18d2      	adds	r2, r2, r3
 801c448:	68fb      	ldr	r3, [r7, #12]
 801c44a:	605a      	str	r2, [r3, #4]

	return result;
}
 801c44c:	68f8      	ldr	r0, [r7, #12]
 801c44e:	f107 0710 	add.w	r7, r7, #16
 801c452:	46bd      	mov	sp, r7
 801c454:	bd80      	pop	{r7, pc}
 801c456:	bf00      	nop

0801c458 <_ZN4TimemiERKNS_5CTimeES2_>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left - right
 */
CTime operator- (const CTime& left, const CTime& right){
 801c458:	b580      	push	{r7, lr}
 801c45a:	b084      	sub	sp, #16
 801c45c:	af00      	add	r7, sp, #0
 801c45e:	60f8      	str	r0, [r7, #12]
 801c460:	60b9      	str	r1, [r7, #8]
 801c462:	607a      	str	r2, [r7, #4]
	CTime result;
 801c464:	68f8      	ldr	r0, [r7, #12]
 801c466:	f7ff fef7 	bl	801c258 <_ZN4Time5CTimeC1Ev>

	result._Time = left._Time - right._Time;
 801c46a:	68bb      	ldr	r3, [r7, #8]
 801c46c:	685a      	ldr	r2, [r3, #4]
 801c46e:	687b      	ldr	r3, [r7, #4]
 801c470:	685b      	ldr	r3, [r3, #4]
 801c472:	1ad2      	subs	r2, r2, r3
 801c474:	68fb      	ldr	r3, [r7, #12]
 801c476:	605a      	str	r2, [r3, #4]

	return result;
}
 801c478:	68f8      	ldr	r0, [r7, #12]
 801c47a:	f107 0710 	add.w	r7, r7, #16
 801c47e:	46bd      	mov	sp, r7
 801c480:	bd80      	pop	{r7, pc}
 801c482:	bf00      	nop

0801c484 <_ZN4TimeplERKNS_5CTimeEx>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left + right
 */
CTime operator+ (const CTime& left, int64_t seconds){
 801c484:	b580      	push	{r7, lr}
 801c486:	b084      	sub	sp, #16
 801c488:	af00      	add	r7, sp, #0
 801c48a:	60f8      	str	r0, [r7, #12]
 801c48c:	60b9      	str	r1, [r7, #8]
 801c48e:	e9c7 2300 	strd	r2, r3, [r7]
	CTime result;
 801c492:	68f8      	ldr	r0, [r7, #12]
 801c494:	f7ff fee0 	bl	801c258 <_ZN4Time5CTimeC1Ev>

	result._Time = left._Time + static_cast<time_t>(seconds);
 801c498:	68bb      	ldr	r3, [r7, #8]
 801c49a:	685a      	ldr	r2, [r3, #4]
 801c49c:	683b      	ldr	r3, [r7, #0]
 801c49e:	18d2      	adds	r2, r2, r3
 801c4a0:	68fb      	ldr	r3, [r7, #12]
 801c4a2:	605a      	str	r2, [r3, #4]

	return result;
}
 801c4a4:	68f8      	ldr	r0, [r7, #12]
 801c4a6:	f107 0710 	add.w	r7, r7, #16
 801c4aa:	46bd      	mov	sp, r7
 801c4ac:	bd80      	pop	{r7, pc}
 801c4ae:	bf00      	nop

0801c4b0 <_ZN4TimemiERKNS_5CTimeEx>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left - right
 */
CTime operator- (const CTime& left, int64_t seconds){
 801c4b0:	b580      	push	{r7, lr}
 801c4b2:	b084      	sub	sp, #16
 801c4b4:	af00      	add	r7, sp, #0
 801c4b6:	60f8      	str	r0, [r7, #12]
 801c4b8:	60b9      	str	r1, [r7, #8]
 801c4ba:	e9c7 2300 	strd	r2, r3, [r7]
	CTime result;
 801c4be:	68f8      	ldr	r0, [r7, #12]
 801c4c0:	f7ff feca 	bl	801c258 <_ZN4Time5CTimeC1Ev>

	result._Time = left._Time - static_cast<time_t>(seconds);
 801c4c4:	68bb      	ldr	r3, [r7, #8]
 801c4c6:	685a      	ldr	r2, [r3, #4]
 801c4c8:	683b      	ldr	r3, [r7, #0]
 801c4ca:	1ad2      	subs	r2, r2, r3
 801c4cc:	68fb      	ldr	r3, [r7, #12]
 801c4ce:	605a      	str	r2, [r3, #4]

	return result;
}
 801c4d0:	68f8      	ldr	r0, [r7, #12]
 801c4d2:	f107 0710 	add.w	r7, r7, #16
 801c4d6:	46bd      	mov	sp, r7
 801c4d8:	bd80      	pop	{r7, pc}
 801c4da:	bf00      	nop

0801c4dc <_ZN4TimeplExRKNS_5CTimeE>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left + right
 */
CTime operator+ (int64_t seconds, const CTime& right){
 801c4dc:	b580      	push	{r7, lr}
 801c4de:	b084      	sub	sp, #16
 801c4e0:	af00      	add	r7, sp, #0
 801c4e2:	60f8      	str	r0, [r7, #12]
 801c4e4:	e9c7 2300 	strd	r2, r3, [r7]
	CTime result;
 801c4e8:	68f8      	ldr	r0, [r7, #12]
 801c4ea:	f7ff feb5 	bl	801c258 <_ZN4Time5CTimeC1Ev>

	result._Time = static_cast<time_t>(seconds) + right._Time;
 801c4ee:	683a      	ldr	r2, [r7, #0]
 801c4f0:	69bb      	ldr	r3, [r7, #24]
 801c4f2:	685b      	ldr	r3, [r3, #4]
 801c4f4:	18d2      	adds	r2, r2, r3
 801c4f6:	68fb      	ldr	r3, [r7, #12]
 801c4f8:	605a      	str	r2, [r3, #4]

	return result;
}
 801c4fa:	68f8      	ldr	r0, [r7, #12]
 801c4fc:	f107 0710 	add.w	r7, r7, #16
 801c500:	46bd      	mov	sp, r7
 801c502:	bd80      	pop	{r7, pc}

0801c504 <_ZN4TimemiExRKNS_5CTimeE>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left - right
 */
CTime operator- (int64_t seconds, const CTime& right){
 801c504:	b580      	push	{r7, lr}
 801c506:	b084      	sub	sp, #16
 801c508:	af00      	add	r7, sp, #0
 801c50a:	60f8      	str	r0, [r7, #12]
 801c50c:	e9c7 2300 	strd	r2, r3, [r7]
	CTime result;
 801c510:	68f8      	ldr	r0, [r7, #12]
 801c512:	f7ff fea1 	bl	801c258 <_ZN4Time5CTimeC1Ev>

	result._Time = static_cast<time_t>(seconds) - right._Time;
 801c516:	683a      	ldr	r2, [r7, #0]
 801c518:	69bb      	ldr	r3, [r7, #24]
 801c51a:	685b      	ldr	r3, [r3, #4]
 801c51c:	1ad2      	subs	r2, r2, r3
 801c51e:	68fb      	ldr	r3, [r7, #12]
 801c520:	605a      	str	r2, [r3, #4]

	return result;
}
 801c522:	68f8      	ldr	r0, [r7, #12]
 801c524:	f107 0710 	add.w	r7, r7, #16
 801c528:	46bd      	mov	sp, r7
 801c52a:	bd80      	pop	{r7, pc}

0801c52c <_ZN4TimegtERKNS_5CTimeES2_>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result true when left is higher than right
 */
bool operator> (const CTime& left, const CTime& right){
 801c52c:	b480      	push	{r7}
 801c52e:	b083      	sub	sp, #12
 801c530:	af00      	add	r7, sp, #0
 801c532:	6078      	str	r0, [r7, #4]
 801c534:	6039      	str	r1, [r7, #0]
	return left._Time > right._Time;
 801c536:	687b      	ldr	r3, [r7, #4]
 801c538:	685a      	ldr	r2, [r3, #4]
 801c53a:	683b      	ldr	r3, [r7, #0]
 801c53c:	685b      	ldr	r3, [r3, #4]
 801c53e:	429a      	cmp	r2, r3
 801c540:	bfd4      	ite	le
 801c542:	2300      	movle	r3, #0
 801c544:	2301      	movgt	r3, #1
 801c546:	b2db      	uxtb	r3, r3
}
 801c548:	4618      	mov	r0, r3
 801c54a:	f107 070c 	add.w	r7, r7, #12
 801c54e:	46bd      	mov	sp, r7
 801c550:	bc80      	pop	{r7}
 801c552:	4770      	bx	lr

0801c554 <_ZN4TimeltERKNS_5CTimeES2_>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result true when left is lower then right
 */
bool operator< (const CTime& left, const CTime& right){
 801c554:	b480      	push	{r7}
 801c556:	b083      	sub	sp, #12
 801c558:	af00      	add	r7, sp, #0
 801c55a:	6078      	str	r0, [r7, #4]
 801c55c:	6039      	str	r1, [r7, #0]
	return left._Time < right._Time;
 801c55e:	687b      	ldr	r3, [r7, #4]
 801c560:	685a      	ldr	r2, [r3, #4]
 801c562:	683b      	ldr	r3, [r7, #0]
 801c564:	685b      	ldr	r3, [r3, #4]
 801c566:	429a      	cmp	r2, r3
 801c568:	bfac      	ite	ge
 801c56a:	2300      	movge	r3, #0
 801c56c:	2301      	movlt	r3, #1
 801c56e:	b2db      	uxtb	r3, r3
}
 801c570:	4618      	mov	r0, r3
 801c572:	f107 070c 	add.w	r7, r7, #12
 801c576:	46bd      	mov	sp, r7
 801c578:	bc80      	pop	{r7}
 801c57a:	4770      	bx	lr

0801c57c <_ZN4TimegtERKNS_5CTimeEx>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left + right
 */
bool operator> (const CTime& left,int64_t seconds){
 801c57c:	b480      	push	{r7}
 801c57e:	b085      	sub	sp, #20
 801c580:	af00      	add	r7, sp, #0
 801c582:	60f8      	str	r0, [r7, #12]
 801c584:	e9c7 2300 	strd	r2, r3, [r7]
	return left._Time > static_cast<time_t>(seconds);
 801c588:	68fb      	ldr	r3, [r7, #12]
 801c58a:	685a      	ldr	r2, [r3, #4]
 801c58c:	683b      	ldr	r3, [r7, #0]
 801c58e:	429a      	cmp	r2, r3
 801c590:	bfd4      	ite	le
 801c592:	2300      	movle	r3, #0
 801c594:	2301      	movgt	r3, #1
 801c596:	b2db      	uxtb	r3, r3
}
 801c598:	4618      	mov	r0, r3
 801c59a:	f107 0714 	add.w	r7, r7, #20
 801c59e:	46bd      	mov	sp, r7
 801c5a0:	bc80      	pop	{r7}
 801c5a2:	4770      	bx	lr

0801c5a4 <_ZN4TimeltERKNS_5CTimeEx>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left - right
 */
bool operator< (const CTime& left, int64_t seconds){
 801c5a4:	b480      	push	{r7}
 801c5a6:	b085      	sub	sp, #20
 801c5a8:	af00      	add	r7, sp, #0
 801c5aa:	60f8      	str	r0, [r7, #12]
 801c5ac:	e9c7 2300 	strd	r2, r3, [r7]
	return left._Time < static_cast<time_t>(seconds);
 801c5b0:	68fb      	ldr	r3, [r7, #12]
 801c5b2:	685a      	ldr	r2, [r3, #4]
 801c5b4:	683b      	ldr	r3, [r7, #0]
 801c5b6:	429a      	cmp	r2, r3
 801c5b8:	bfac      	ite	ge
 801c5ba:	2300      	movge	r3, #0
 801c5bc:	2301      	movlt	r3, #1
 801c5be:	b2db      	uxtb	r3, r3
}
 801c5c0:	4618      	mov	r0, r3
 801c5c2:	f107 0714 	add.w	r7, r7, #20
 801c5c6:	46bd      	mov	sp, r7
 801c5c8:	bc80      	pop	{r7}
 801c5ca:	4770      	bx	lr

0801c5cc <_ZN4TimegtExRKNS_5CTimeE>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left + right
 */
bool operator> (int64_t seconds, const CTime& right){
 801c5cc:	b480      	push	{r7}
 801c5ce:	b085      	sub	sp, #20
 801c5d0:	af00      	add	r7, sp, #0
 801c5d2:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801c5d6:	607a      	str	r2, [r7, #4]
	return static_cast<time_t>(seconds) > right._Time;
 801c5d8:	68ba      	ldr	r2, [r7, #8]
 801c5da:	687b      	ldr	r3, [r7, #4]
 801c5dc:	685b      	ldr	r3, [r3, #4]
 801c5de:	429a      	cmp	r2, r3
 801c5e0:	bfd4      	ite	le
 801c5e2:	2300      	movle	r3, #0
 801c5e4:	2301      	movgt	r3, #1
 801c5e6:	b2db      	uxtb	r3, r3
}
 801c5e8:	4618      	mov	r0, r3
 801c5ea:	f107 0714 	add.w	r7, r7, #20
 801c5ee:	46bd      	mov	sp, r7
 801c5f0:	bc80      	pop	{r7}
 801c5f2:	4770      	bx	lr

0801c5f4 <_ZN4TimeltExRKNS_5CTimeE>:
 * Ref: Der-C++-Programmierer S. 321
 * @param left operand left of sign
 * @param right operand right of sign
 * @return result of addition left - right
 */
bool operator< (int64_t seconds, const CTime& right){
 801c5f4:	b480      	push	{r7}
 801c5f6:	b085      	sub	sp, #20
 801c5f8:	af00      	add	r7, sp, #0
 801c5fa:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801c5fe:	607a      	str	r2, [r7, #4]
	return static_cast<time_t>(seconds) > right._Time;
 801c600:	68ba      	ldr	r2, [r7, #8]
 801c602:	687b      	ldr	r3, [r7, #4]
 801c604:	685b      	ldr	r3, [r3, #4]
 801c606:	429a      	cmp	r2, r3
 801c608:	bfd4      	ite	le
 801c60a:	2300      	movle	r3, #0
 801c60c:	2301      	movgt	r3, #1
 801c60e:	b2db      	uxtb	r3, r3
}
 801c610:	4618      	mov	r0, r3
 801c612:	f107 0714 	add.w	r7, r7, #20
 801c616:	46bd      	mov	sp, r7
 801c618:	bc80      	pop	{r7}
 801c61a:	4770      	bx	lr

0801c61c <_ZN4Time13CTimeUnitTestEv>:
namespace Time {

/**
 * Unit Test for CTime class
 */
void CTimeUnitTest(){
 801c61c:	b580      	push	{r7, lr}
 801c61e:	b0a4      	sub	sp, #144	; 0x90
 801c620:	af04      	add	r7, sp, #16
	CTime today(11,28,14,5,7,2012);  // 14:28:11 5.7.12 Thu Week 27
 801c622:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801c626:	f04f 0205 	mov.w	r2, #5
 801c62a:	9200      	str	r2, [sp, #0]
 801c62c:	f04f 0207 	mov.w	r2, #7
 801c630:	9201      	str	r2, [sp, #4]
 801c632:	f240 72dc 	movw	r2, #2012	; 0x7dc
 801c636:	9202      	str	r2, [sp, #8]
 801c638:	4618      	mov	r0, r3
 801c63a:	f04f 010b 	mov.w	r1, #11
 801c63e:	f04f 021c 	mov.w	r2, #28
 801c642:	f04f 030e 	mov.w	r3, #14
 801c646:	f7ff fe31 	bl	801c2ac <_ZN4Time5CTimeC1Ehhhhht>
	CTime nextday(today);
 801c64a:	f107 0248 	add.w	r2, r7, #72	; 0x48
 801c64e:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801c652:	4610      	mov	r0, r2
 801c654:	4619      	mov	r1, r3
 801c656:	f7ff fe13 	bl	801c280 <_ZN4Time5CTimeC1ERKS0_>
	CTime yesterday,diff1,diff2,min30;
 801c65a:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c65e:	4618      	mov	r0, r3
 801c660:	f7ff fdfa 	bl	801c258 <_ZN4Time5CTimeC1Ev>
 801c664:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801c668:	4618      	mov	r0, r3
 801c66a:	f7ff fdf5 	bl	801c258 <_ZN4Time5CTimeC1Ev>
 801c66e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c672:	4618      	mov	r0, r3
 801c674:	f7ff fdf0 	bl	801c258 <_ZN4Time5CTimeC1Ev>
 801c678:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801c67c:	4618      	mov	r0, r3
 801c67e:	f7ff fdeb 	bl	801c258 <_ZN4Time5CTimeC1Ev>
	char buffer[40];

	nextday = today + (3600 * 24); // add 1 day in seconds
 801c682:	f107 0258 	add.w	r2, r7, #88	; 0x58
 801c686:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801c68a:	4610      	mov	r0, r2
 801c68c:	4619      	mov	r1, r3
 801c68e:	f44f 32a8 	mov.w	r2, #86016	; 0x15000
 801c692:	f502 72c0 	add.w	r2, r2, #384	; 0x180
 801c696:	f04f 0300 	mov.w	r3, #0
 801c69a:	f7ff fef3 	bl	801c484 <_ZN4TimeplERKNS_5CTimeEx>
 801c69e:	f107 0248 	add.w	r2, r7, #72	; 0x48
 801c6a2:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801c6a6:	4610      	mov	r0, r2
 801c6a8:	4619      	mov	r1, r3
 801c6aa:	f7ff fe5b 	bl	801c364 <_ZN4Time5CTimeaSERKS0_>
 801c6ae:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801c6b2:	4618      	mov	r0, r3
 801c6b4:	f7ff fe2c 	bl	801c310 <_ZN4Time5CTimeD1Ev>
	yesterday = today - (3600 * 24); // sub 1 day
 801c6b8:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801c6bc:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801c6c0:	4610      	mov	r0, r2
 801c6c2:	4619      	mov	r1, r3
 801c6c4:	f44f 32a8 	mov.w	r2, #86016	; 0x15000
 801c6c8:	f502 72c0 	add.w	r2, r2, #384	; 0x180
 801c6cc:	f04f 0300 	mov.w	r3, #0
 801c6d0:	f7ff feee 	bl	801c4b0 <_ZN4TimemiERKNS_5CTimeEx>
 801c6d4:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801c6d8:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801c6dc:	4610      	mov	r0, r2
 801c6de:	4619      	mov	r1, r3
 801c6e0:	f7ff fe40 	bl	801c364 <_ZN4Time5CTimeaSERKS0_>
 801c6e4:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801c6e8:	4618      	mov	r0, r3
 801c6ea:	f7ff fe11 	bl	801c310 <_ZN4Time5CTimeD1Ev>

	diff1 = today - yesterday;
 801c6ee:	f107 0168 	add.w	r1, r7, #104	; 0x68
 801c6f2:	f107 0250 	add.w	r2, r7, #80	; 0x50
 801c6f6:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c6fa:	4608      	mov	r0, r1
 801c6fc:	4611      	mov	r1, r2
 801c6fe:	461a      	mov	r2, r3
 801c700:	f7ff feaa 	bl	801c458 <_ZN4TimemiERKNS_5CTimeES2_>
 801c704:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801c708:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801c70c:	4610      	mov	r0, r2
 801c70e:	4619      	mov	r1, r3
 801c710:	f7ff fe28 	bl	801c364 <_ZN4Time5CTimeaSERKS0_>
 801c714:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801c718:	4618      	mov	r0, r3
 801c71a:	f7ff fdf9 	bl	801c310 <_ZN4Time5CTimeD1Ev>
	diff2 = nextday - 869000;
 801c71e:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801c722:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801c726:	4610      	mov	r0, r2
 801c728:	4619      	mov	r1, r3
 801c72a:	f44f 2254 	mov.w	r2, #868352	; 0xd4000
 801c72e:	f502 7222 	add.w	r2, r2, #648	; 0x288
 801c732:	f04f 0300 	mov.w	r3, #0
 801c736:	f7ff febb 	bl	801c4b0 <_ZN4TimemiERKNS_5CTimeEx>
 801c73a:	f107 0230 	add.w	r2, r7, #48	; 0x30
 801c73e:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801c742:	4610      	mov	r0, r2
 801c744:	4619      	mov	r1, r3
 801c746:	f7ff fe0d 	bl	801c364 <_ZN4Time5CTimeaSERKS0_>
 801c74a:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801c74e:	4618      	mov	r0, r3
 801c750:	f7ff fdde 	bl	801c310 <_ZN4Time5CTimeD1Ev>
	min30 = 30 * 60 + today;
 801c754:	f107 0378 	add.w	r3, r7, #120	; 0x78
 801c758:	f107 0250 	add.w	r2, r7, #80	; 0x50
 801c75c:	9200      	str	r2, [sp, #0]
 801c75e:	4618      	mov	r0, r3
 801c760:	f44f 62e1 	mov.w	r2, #1800	; 0x708
 801c764:	f04f 0300 	mov.w	r3, #0
 801c768:	f7ff feb8 	bl	801c4dc <_ZN4TimeplExRKNS_5CTimeE>
 801c76c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 801c770:	f107 0378 	add.w	r3, r7, #120	; 0x78
 801c774:	4610      	mov	r0, r2
 801c776:	4619      	mov	r1, r3
 801c778:	f7ff fdf4 	bl	801c364 <_ZN4Time5CTimeaSERKS0_>
 801c77c:	f107 0378 	add.w	r3, r7, #120	; 0x78
 801c780:	4618      	mov	r0, r3
 801c782:	f7ff fdc5 	bl	801c310 <_ZN4Time5CTimeD1Ev>

	today.getTimeString(buffer);
 801c786:	f107 0250 	add.w	r2, r7, #80	; 0x50
 801c78a:	463b      	mov	r3, r7
 801c78c:	4610      	mov	r0, r2
 801c78e:	4619      	mov	r1, r3
 801c790:	f7ff fdf8 	bl	801c384 <_ZN4Time5CTime13getTimeStringEPc>

	diff1.getDateString(buffer);
 801c794:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801c798:	463b      	mov	r3, r7
 801c79a:	4610      	mov	r0, r2
 801c79c:	4619      	mov	r1, r3
 801c79e:	f7ff fe0d 	bl	801c3bc <_ZN4Time5CTime13getDateStringEPc>

	yesterday.getWeekNumberString(buffer);
 801c7a2:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801c7a6:	463b      	mov	r3, r7
 801c7a8:	4610      	mov	r0, r2
 801c7aa:	4619      	mov	r1, r3
 801c7ac:	f7ff fe22 	bl	801c3f4 <_ZN4Time5CTime19getWeekNumberStringEPc>
 * Unit Test for CTime class
 */
void CTimeUnitTest(){
	CTime today(11,28,14,5,7,2012);  // 14:28:11 5.7.12 Thu Week 27
	CTime nextday(today);
	CTime yesterday,diff1,diff2,min30;
 801c7b0:	f107 0328 	add.w	r3, r7, #40	; 0x28

	today.getTimeString(buffer);

	diff1.getDateString(buffer);

	yesterday.getWeekNumberString(buffer);
 801c7b4:	4618      	mov	r0, r3
 801c7b6:	f7ff fdab 	bl	801c310 <_ZN4Time5CTimeD1Ev>
 * Unit Test for CTime class
 */
void CTimeUnitTest(){
	CTime today(11,28,14,5,7,2012);  // 14:28:11 5.7.12 Thu Week 27
	CTime nextday(today);
	CTime yesterday,diff1,diff2,min30;
 801c7ba:	f107 0330 	add.w	r3, r7, #48	; 0x30

	today.getTimeString(buffer);

	diff1.getDateString(buffer);

	yesterday.getWeekNumberString(buffer);
 801c7be:	4618      	mov	r0, r3
 801c7c0:	f7ff fda6 	bl	801c310 <_ZN4Time5CTimeD1Ev>
 * Unit Test for CTime class
 */
void CTimeUnitTest(){
	CTime today(11,28,14,5,7,2012);  // 14:28:11 5.7.12 Thu Week 27
	CTime nextday(today);
	CTime yesterday,diff1,diff2,min30;
 801c7c4:	f107 0338 	add.w	r3, r7, #56	; 0x38

	today.getTimeString(buffer);

	diff1.getDateString(buffer);

	yesterday.getWeekNumberString(buffer);
 801c7c8:	4618      	mov	r0, r3
 801c7ca:	f7ff fda1 	bl	801c310 <_ZN4Time5CTimeD1Ev>
 * Unit Test for CTime class
 */
void CTimeUnitTest(){
	CTime today(11,28,14,5,7,2012);  // 14:28:11 5.7.12 Thu Week 27
	CTime nextday(today);
	CTime yesterday,diff1,diff2,min30;
 801c7ce:	f107 0340 	add.w	r3, r7, #64	; 0x40

	today.getTimeString(buffer);

	diff1.getDateString(buffer);

	yesterday.getWeekNumberString(buffer);
 801c7d2:	4618      	mov	r0, r3
 801c7d4:	f7ff fd9c 	bl	801c310 <_ZN4Time5CTimeD1Ev>
/**
 * Unit Test for CTime class
 */
void CTimeUnitTest(){
	CTime today(11,28,14,5,7,2012);  // 14:28:11 5.7.12 Thu Week 27
	CTime nextday(today);
 801c7d8:	f107 0348 	add.w	r3, r7, #72	; 0x48

	today.getTimeString(buffer);

	diff1.getDateString(buffer);

	yesterday.getWeekNumberString(buffer);
 801c7dc:	4618      	mov	r0, r3
 801c7de:	f7ff fd97 	bl	801c310 <_ZN4Time5CTimeD1Ev>

/**
 * Unit Test for CTime class
 */
void CTimeUnitTest(){
	CTime today(11,28,14,5,7,2012);  // 14:28:11 5.7.12 Thu Week 27
 801c7e2:	f107 0350 	add.w	r3, r7, #80	; 0x50

	today.getTimeString(buffer);

	diff1.getDateString(buffer);

	yesterday.getWeekNumberString(buffer);
 801c7e6:	4618      	mov	r0, r3
 801c7e8:	f7ff fd92 	bl	801c310 <_ZN4Time5CTimeD1Ev>
}
 801c7ec:	f107 0780 	add.w	r7, r7, #128	; 0x80
 801c7f0:	46bd      	mov	sp, r7
 801c7f2:	bd80      	pop	{r7, pc}

0801c7f4 <_ZN16CUSB_MassStorageC1Ev>:
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/



CUSB_MassStorage::CUSB_MassStorage() {
 801c7f4:	b580      	push	{r7, lr}
 801c7f6:	b082      	sub	sp, #8
 801c7f8:	af00      	add	r7, sp, #0
 801c7fa:	6078      	str	r0, [r7, #4]
 801c7fc:	687b      	ldr	r3, [r7, #4]
 801c7fe:	4618      	mov	r0, r3
 801c800:	f7fc ff24 	bl	801964c <_ZN12AManagedTaskC1Ev>
 801c804:	687b      	ldr	r3, [r7, #4]
 801c806:	4a04      	ldr	r2, [pc, #16]	; (801c818 <_ZN16CUSB_MassStorageC1Ev+0x24>)
 801c808:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated constructor stub

}
 801c80a:	687b      	ldr	r3, [r7, #4]
 801c80c:	4618      	mov	r0, r3
 801c80e:	f107 0708 	add.w	r7, r7, #8
 801c812:	46bd      	mov	sp, r7
 801c814:	bd80      	pop	{r7, pc}
 801c816:	bf00      	nop
 801c818:	08032b30 	.word	0x08032b30

0801c81c <_ZN16CUSB_MassStorageD1Ev>:

CUSB_MassStorage::~CUSB_MassStorage() {
 801c81c:	b580      	push	{r7, lr}
 801c81e:	b082      	sub	sp, #8
 801c820:	af00      	add	r7, sp, #0
 801c822:	6078      	str	r0, [r7, #4]
 801c824:	687b      	ldr	r3, [r7, #4]
 801c826:	4a0a      	ldr	r2, [pc, #40]	; (801c850 <_ZN16CUSB_MassStorageD1Ev+0x34>)
 801c828:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated destructor stub
}
 801c82a:	6878      	ldr	r0, [r7, #4]
 801c82c:	f7fc ff2a 	bl	8019684 <_ZN12AManagedTaskD1Ev>
 801c830:	f04f 0300 	mov.w	r3, #0
 801c834:	f003 0301 	and.w	r3, r3, #1
 801c838:	b2db      	uxtb	r3, r3
 801c83a:	2b00      	cmp	r3, #0
 801c83c:	d002      	beq.n	801c844 <_ZN16CUSB_MassStorageD1Ev+0x28>
 801c83e:	6878      	ldr	r0, [r7, #4]
 801c840:	f005 fcc8 	bl	80221d4 <_ZdlPv>
 801c844:	687b      	ldr	r3, [r7, #4]
 801c846:	4618      	mov	r0, r3
 801c848:	f107 0708 	add.w	r7, r7, #8
 801c84c:	46bd      	mov	sp, r7
 801c84e:	bd80      	pop	{r7, pc}
 801c850:	08032b30 	.word	0x08032b30

0801c854 <_ZN16CUSB_MassStorageD0Ev>:
CUSB_MassStorage::CUSB_MassStorage() {
	// TODO Auto-generated constructor stub

}

CUSB_MassStorage::~CUSB_MassStorage() {
 801c854:	b580      	push	{r7, lr}
 801c856:	b082      	sub	sp, #8
 801c858:	af00      	add	r7, sp, #0
 801c85a:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated destructor stub
}
 801c85c:	6878      	ldr	r0, [r7, #4]
 801c85e:	f7ff ffdd 	bl	801c81c <_ZN16CUSB_MassStorageD1Ev>
 801c862:	6878      	ldr	r0, [r7, #4]
 801c864:	f005 fcb6 	bl	80221d4 <_ZdlPv>
 801c868:	687b      	ldr	r3, [r7, #4]
 801c86a:	4618      	mov	r0, r3
 801c86c:	f107 0708 	add.w	r7, r7, #8
 801c870:	46bd      	mov	sp, r7
 801c872:	bd80      	pop	{r7, pc}

0801c874 <_ZN16CUSB_MassStorage12HardwareInitEv>:
  * @brief  HardwareInit called before Scheduler starts
  * 		USB OTG FS will be initialized interface will be initialized
  * @param  None
  * @retval true on succsess
  */
bool CUSB_MassStorage::HardwareInit(void){
 801c874:	b580      	push	{r7, lr}
 801c876:	b084      	sub	sp, #16
 801c878:	af02      	add	r7, sp, #8
 801c87a:	6078      	str	r0, [r7, #4]

	/* Init Host Library */
	USBH_Init(&USB_OTG_Core, USB_OTG_FS_CORE_ID, &USB_Host, &USBH_MSC_cb, &USR_Callbacks);
 801c87c:	f240 0388 	movw	r3, #136	; 0x88
 801c880:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c884:	9300      	str	r3, [sp, #0]
 801c886:	f640 30b4 	movw	r0, #2996	; 0xbb4
 801c88a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801c88e:	f04f 0101 	mov.w	r1, #1
 801c892:	f241 0264 	movw	r2, #4196	; 0x1064
 801c896:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801c89a:	f240 0310 	movw	r3, #16
 801c89e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c8a2:	f7e6 f9c1 	bl	8002c28 <USBH_Init>

	return true;
 801c8a6:	f04f 0301 	mov.w	r3, #1
}
 801c8aa:	4618      	mov	r0, r3
 801c8ac:	f107 0708 	add.w	r7, r7, #8
 801c8b0:	46bd      	mov	sp, r7
 801c8b2:	bd80      	pop	{r7, pc}

0801c8b4 <_ZN16CUSB_MassStorage3RunEv>:
/**
  * @brief  task function for USB handling
  * @param  None
  * @retval None
  */
void CUSB_MassStorage::Run(void){
 801c8b4:	b580      	push	{r7, lr}
 801c8b6:	b082      	sub	sp, #8
 801c8b8:	af00      	add	r7, sp, #0
 801c8ba:	6078      	str	r0, [r7, #4]
	while(1){
	    /* Host Task handler */
	    USBH_Process(&USB_OTG_Core, &USB_Host);
 801c8bc:	f640 30b4 	movw	r0, #2996	; 0xbb4
 801c8c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801c8c4:	f241 0164 	movw	r1, #4196	; 0x1064
 801c8c8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801c8cc:	f7e6 fa24 	bl	8002d18 <USBH_Process>
  * @brief  task function for USB handling
  * @param  None
  * @retval None
  */
void CUSB_MassStorage::Run(void){
	while(1){
 801c8d0:	e7f4      	b.n	801c8bc <_ZN16CUSB_MassStorage3RunEv+0x8>
 801c8d2:	bf00      	nop

0801c8d4 <_ZN16CUSB_MassStorage17IsDeviceConnectedEv>:
/**
  * @brief  Get Connection Status
  * @param  None
  * @retval status of storage device
  */
bool CUSB_MassStorage::IsDeviceConnected(void){
 801c8d4:	b580      	push	{r7, lr}
 801c8d6:	b082      	sub	sp, #8
 801c8d8:	af00      	add	r7, sp, #0
 801c8da:	6078      	str	r0, [r7, #4]
	return HCD_IsDeviceConnected(&USB_OTG_Core);
 801c8dc:	f640 30b4 	movw	r0, #2996	; 0xbb4
 801c8e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801c8e4:	f7e4 fe9e 	bl	8001624 <HCD_IsDeviceConnected>
 801c8e8:	4603      	mov	r3, r0
 801c8ea:	2b00      	cmp	r3, #0
 801c8ec:	bf0c      	ite	eq
 801c8ee:	2300      	moveq	r3, #0
 801c8f0:	2301      	movne	r3, #1
 801c8f2:	b2db      	uxtb	r3, r3
}
 801c8f4:	4618      	mov	r0, r3
 801c8f6:	f107 0708 	add.w	r7, r7, #8
 801c8fa:	46bd      	mov	sp, r7
 801c8fc:	bd80      	pop	{r7, pc}
 801c8fe:	bf00      	nop

0801c900 <BSP_Init>:
  *         board user initializations
  * @param  None
  * @retval None
  */
void BSP_Init(void)
{
 801c900:	b580      	push	{r7, lr}
 801c902:	af00      	add	r7, sp, #0
  /* Configure PA0 pin: User Key pin */
  STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_GPIO);
 801c904:	f04f 0000 	mov.w	r0, #0
 801c908:	f04f 0100 	mov.w	r1, #0
 801c90c:	f7f0 ff8c 	bl	800d828 <STM_EVAL_PBInit>
}
 801c910:	bd80      	pop	{r7, pc}
 801c912:	bf00      	nop

0801c914 <USB_OTG_BSP_Init>:
  *         Initilizes BSP configurations
  * @param  None
  * @retval None
  */
void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
{
 801c914:	b580      	push	{r7, lr}
 801c916:	b084      	sub	sp, #16
 801c918:	af00      	add	r7, sp, #0
 801c91a:	6078      	str	r0, [r7, #4]
 /* Note: On STM32F4-Discovery board only USB OTG FS core is supported. */

  GPIO_InitTypeDef GPIO_InitStructure;
 #ifdef USE_USB_OTG_FS 

  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);  
 801c91c:	f04f 0001 	mov.w	r0, #1
 801c920:	f04f 0101 	mov.w	r1, #1
 801c924:	f7ec f9a2 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
  
  /* Configure SOF VBUS ID DM DP Pins */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9  | 
 801c928:	f44f 53d0 	mov.w	r3, #6656	; 0x1a00
 801c92c:	60bb      	str	r3, [r7, #8]
      GPIO_Pin_11 | 
        GPIO_Pin_12;
  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 801c92e:	f04f 0303 	mov.w	r3, #3
 801c932:	737b      	strb	r3, [r7, #13]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 801c934:	f04f 0302 	mov.w	r3, #2
 801c938:	733b      	strb	r3, [r7, #12]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 801c93a:	f04f 0300 	mov.w	r3, #0
 801c93e:	73bb      	strb	r3, [r7, #14]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 801c940:	f04f 0300 	mov.w	r3, #0
 801c944:	73fb      	strb	r3, [r7, #15]
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 801c946:	f107 0308 	add.w	r3, r7, #8
 801c94a:	f04f 0000 	mov.w	r0, #0
 801c94e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801c952:	4619      	mov	r1, r3
 801c954:	f7ea fdb4 	bl	80074c0 <GPIO_Init>
  
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ; 
 801c958:	f04f 0000 	mov.w	r0, #0
 801c95c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801c960:	f04f 0109 	mov.w	r1, #9
 801c964:	f04f 020a 	mov.w	r2, #10
 801c968:	f7ea ff40 	bl	80077ec <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ; 
 801c96c:	f04f 0000 	mov.w	r0, #0
 801c970:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801c974:	f04f 010b 	mov.w	r1, #11
 801c978:	f04f 020a 	mov.w	r2, #10
 801c97c:	f7ea ff36 	bl	80077ec <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
 801c980:	f04f 0000 	mov.w	r0, #0
 801c984:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801c988:	f04f 010c 	mov.w	r1, #12
 801c98c:	f04f 020a 	mov.w	r2, #10
 801c990:	f7ea ff2c 	bl	80077ec <GPIO_PinAFConfig>
  
  /* this for ID line debug */
  
  
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 801c994:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801c998:	60bb      	str	r3, [r7, #8]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 801c99a:	f04f 0301 	mov.w	r3, #1
 801c99e:	73bb      	strb	r3, [r7, #14]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;  
 801c9a0:	f04f 0301 	mov.w	r3, #1
 801c9a4:	73fb      	strb	r3, [r7, #15]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 801c9a6:	f04f 0303 	mov.w	r3, #3
 801c9aa:	737b      	strb	r3, [r7, #13]
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 801c9ac:	f107 0308 	add.w	r3, r7, #8
 801c9b0:	f04f 0000 	mov.w	r0, #0
 801c9b4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801c9b8:	4619      	mov	r1, r3
 801c9ba:	f7ea fd81 	bl	80074c0 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;   
 801c9be:	f04f 0000 	mov.w	r0, #0
 801c9c2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801c9c6:	f04f 010a 	mov.w	r1, #10
 801c9ca:	f04f 020a 	mov.w	r2, #10
 801c9ce:	f7ea ff0d 	bl	80077ec <GPIO_PinAFConfig>


  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 801c9d2:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 801c9d6:	f04f 0101 	mov.w	r1, #1
 801c9da:	f7ec f9f7 	bl	8008dcc <RCC_APB2PeriphClockCmd>
  RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ; 
 801c9de:	f04f 0080 	mov.w	r0, #128	; 0x80
 801c9e2:	f04f 0101 	mov.w	r1, #1
 801c9e6:	f7ec f96d 	bl	8008cc4 <RCC_AHB2PeriphClockCmd>
  #endif
 #endif //USB_OTG_HS

  /* Intialize Timer for delay function */
  //USB_OTG_BSP_TimeInit();
}
 801c9ea:	f107 0710 	add.w	r7, r7, #16
 801c9ee:	46bd      	mov	sp, r7
 801c9f0:	bd80      	pop	{r7, pc}
 801c9f2:	bf00      	nop

0801c9f4 <USB_OTG_BSP_EnableInterrupt>:
  *         Configures USB Global interrupt
  * @param  None
  * @retval None
  */
void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
{
 801c9f4:	b580      	push	{r7, lr}
 801c9f6:	b084      	sub	sp, #16
 801c9f8:	af00      	add	r7, sp, #0
 801c9fa:	6078      	str	r0, [r7, #4]

  NVIC_InitTypeDef NVIC_InitStructure;
  /* Enable USB Interrupt */
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 801c9fc:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 801ca00:	f7e9 fba2 	bl	8006148 <NVIC_PriorityGroupConfig>

  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
 801ca04:	f04f 0343 	mov.w	r3, #67	; 0x43
 801ca08:	733b      	strb	r3, [r7, #12]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 801ca0a:	f04f 0300 	mov.w	r3, #0
 801ca0e:	737b      	strb	r3, [r7, #13]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 801ca10:	f04f 0301 	mov.w	r3, #1
 801ca14:	73bb      	strb	r3, [r7, #14]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 801ca16:	f04f 0301 	mov.w	r3, #1
 801ca1a:	73fb      	strb	r3, [r7, #15]
  NVIC_Init(&NVIC_InitStructure);
 801ca1c:	f107 030c 	add.w	r3, r7, #12
 801ca20:	4618      	mov	r0, r3
 801ca22:	f7e9 fba5 	bl	8006170 <NVIC_Init>
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

  NVIC_Init(&NVIC_InitStructure);*/
}
 801ca26:	f107 0710 	add.w	r7, r7, #16
 801ca2a:	46bd      	mov	sp, r7
 801ca2c:	bd80      	pop	{r7, pc}
 801ca2e:	bf00      	nop

0801ca30 <USB_OTG_BSP_DriveVBUS>:
  *         Drives the Vbus signal through IO
  * @param  state : VBUS states
  * @retval None
  */
void USB_OTG_BSP_DriveVBUS(USB_OTG_CORE_HANDLE *pdev, uint8_t state)
{
 801ca30:	b580      	push	{r7, lr}
 801ca32:	b082      	sub	sp, #8
 801ca34:	af00      	add	r7, sp, #0
 801ca36:	6078      	str	r0, [r7, #4]
 801ca38:	460b      	mov	r3, r1
 801ca3a:	70fb      	strb	r3, [r7, #3]

  Bit 12 PPWR: Port power
  The application uses this field to control power to this port, and the core 
  clears this bit on an overcurrent condition.
  */
  if (0 == state)
 801ca3c:	78fb      	ldrb	r3, [r7, #3]
 801ca3e:	2b00      	cmp	r3, #0
 801ca40:	d108      	bne.n	801ca54 <USB_OTG_BSP_DriveVBUS+0x24>
  {
    /* DISABLE is needed on output of the Power Switch */
    GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 801ca42:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801ca46:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801ca4a:	f04f 0101 	mov.w	r1, #1
 801ca4e:	f7ea fe79 	bl	8007744 <GPIO_SetBits>
 801ca52:	e007      	b.n	801ca64 <USB_OTG_BSP_DriveVBUS+0x34>
  }
  else
  {
    /*ENABLE the Power Switch by driving the Enable LOW */
    GPIO_ResetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 801ca54:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801ca58:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801ca5c:	f04f 0101 	mov.w	r1, #1
 801ca60:	f7ea fe7e 	bl	8007760 <GPIO_ResetBits>
  }
}
 801ca64:	f107 0708 	add.w	r7, r7, #8
 801ca68:	46bd      	mov	sp, r7
 801ca6a:	bd80      	pop	{r7, pc}

0801ca6c <USB_OTG_BSP_ConfigVBUS>:
  *         Configures the IO for the Vbus and OverCurrent
  * @param  None
  * @retval None
  */
void  USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev)
{
 801ca6c:	b580      	push	{r7, lr}
 801ca6e:	b084      	sub	sp, #16
 801ca70:	af00      	add	r7, sp, #0
 801ca72:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStructure;


  RCC_AHB1PeriphClockCmd(HOST_POWERSW_PORT_RCC, ENABLE);
 801ca74:	f04f 0004 	mov.w	r0, #4
 801ca78:	f04f 0101 	mov.w	r1, #1
 801ca7c:	f7ec f8f6 	bl	8008c6c <RCC_AHB1PeriphClockCmd>


  /* Configure Power Switch Vbus Pin */
  GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
 801ca80:	f04f 0301 	mov.w	r3, #1
 801ca84:	60bb      	str	r3, [r7, #8]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 801ca86:	f04f 0302 	mov.w	r3, #2
 801ca8a:	737b      	strb	r3, [r7, #13]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 801ca8c:	f04f 0301 	mov.w	r3, #1
 801ca90:	733b      	strb	r3, [r7, #12]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 801ca92:	f04f 0300 	mov.w	r3, #0
 801ca96:	73bb      	strb	r3, [r7, #14]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;  
 801ca98:	f04f 0300 	mov.w	r3, #0
 801ca9c:	73fb      	strb	r3, [r7, #15]
  
  GPIO_Init(HOST_POWERSW_PORT, &GPIO_InitStructure);
 801ca9e:	f107 0308 	add.w	r3, r7, #8
 801caa2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801caa6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801caaa:	4619      	mov	r1, r3
 801caac:	f7ea fd08 	bl	80074c0 <GPIO_Init>

  /* By Default, DISABLE is needed on output of the Power Switch */
  GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 801cab0:	f44f 6000 	mov.w	r0, #2048	; 0x800
 801cab4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 801cab8:	f04f 0101 	mov.w	r1, #1
 801cabc:	f7ea fe42 	bl	8007744 <GPIO_SetBits>

  USB_OTG_BSP_mDelay(200);   /* Delay is need for stabilising the Vbus Low
 801cac0:	f04f 00c8 	mov.w	r0, #200	; 0xc8
 801cac4:	f000 f830 	bl	801cb28 <USB_OTG_BSP_mDelay>
      in Reset Condition, when Vbus=1 and Reset-button is pressed by user */

}
 801cac8:	f107 0710 	add.w	r7, r7, #16
 801cacc:	46bd      	mov	sp, r7
 801cace:	bd80      	pop	{r7, pc}

0801cad0 <USB_OTG_BSP_uDelay>:
  *         This function provides delay time in micro sec
  * @param  usec : Value of delay required in micro sec
  * @retval None
  */
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
 801cad0:	b480      	push	{r7}
 801cad2:	b085      	sub	sp, #20
 801cad4:	af00      	add	r7, sp, #0
 801cad6:	6078      	str	r0, [r7, #4]

#ifdef USE_ACCURATE_TIME
  BSP_Delay(usec, TIM_USEC_DELAY);
#else
  __IO uint32_t count = 0;
 801cad8:	f04f 0300 	mov.w	r3, #0
 801cadc:	60bb      	str	r3, [r7, #8]
  const uint32_t utime = (120 * usec / 7);
 801cade:	687a      	ldr	r2, [r7, #4]
 801cae0:	4613      	mov	r3, r2
 801cae2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 801cae6:	1a9b      	subs	r3, r3, r2
 801cae8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801caec:	461a      	mov	r2, r3
 801caee:	f644 1325 	movw	r3, #18725	; 0x4925
 801caf2:	f2c2 4392 	movt	r3, #9362	; 0x2492
 801caf6:	fba3 1302 	umull	r1, r3, r3, r2
 801cafa:	1ad2      	subs	r2, r2, r3
 801cafc:	ea4f 0252 	mov.w	r2, r2, lsr #1
 801cb00:	189b      	adds	r3, r3, r2
 801cb02:	ea4f 0393 	mov.w	r3, r3, lsr #2
 801cb06:	60fb      	str	r3, [r7, #12]
 801cb08:	e000      	b.n	801cb0c <USB_OTG_BSP_uDelay+0x3c>
    if ( ++count > utime )
    {
      return ;
    }
  }
  while (1);
 801cb0a:	bf00      	nop
#else
  __IO uint32_t count = 0;
  const uint32_t utime = (120 * usec / 7);
  do
  {
    if ( ++count > utime )
 801cb0c:	68bb      	ldr	r3, [r7, #8]
 801cb0e:	f103 0301 	add.w	r3, r3, #1
 801cb12:	60bb      	str	r3, [r7, #8]
 801cb14:	68fa      	ldr	r2, [r7, #12]
 801cb16:	4293      	cmp	r3, r2
 801cb18:	d9f7      	bls.n	801cb0a <USB_OTG_BSP_uDelay+0x3a>
    {
      return ;
 801cb1a:	bf00      	nop
    }
  }
  while (1);
#endif

}
 801cb1c:	f107 0714 	add.w	r7, r7, #20
 801cb20:	46bd      	mov	sp, r7
 801cb22:	bc80      	pop	{r7}
 801cb24:	4770      	bx	lr
 801cb26:	bf00      	nop

0801cb28 <USB_OTG_BSP_mDelay>:
  *          This function provides delay time in milli sec
  * @param  msec : Value of delay required in milli sec
  * @retval None
  */
void USB_OTG_BSP_mDelay (const uint32_t msec)
{
 801cb28:	b580      	push	{r7, lr}
 801cb2a:	b082      	sub	sp, #8
 801cb2c:	af00      	add	r7, sp, #0
 801cb2e:	6078      	str	r0, [r7, #4]
#ifdef USE_ACCURATE_TIME
  BSP_Delay(msec, TIM_MSEC_DELAY);
#else
  USB_OTG_BSP_uDelay(msec * 1000);
 801cb30:	687b      	ldr	r3, [r7, #4]
 801cb32:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801cb36:	fb02 f303 	mul.w	r3, r2, r3
 801cb3a:	4618      	mov	r0, r3
 801cb3c:	f7ff ffc8 	bl	801cad0 <USB_OTG_BSP_uDelay>
#endif

}
 801cb40:	f107 0708 	add.w	r7, r7, #8
 801cb44:	46bd      	mov	sp, r7
 801cb46:	bd80      	pop	{r7, pc}

0801cb48 <USB_OTG_BSP_TimerIRQ>:
  *         Time base IRQ
  * @param  None
  * @retval None
  */
void USB_OTG_BSP_TimerIRQ (void)
{
 801cb48:	b480      	push	{r7}
 801cb4a:	af00      	add	r7, sp, #0
    {
      TIM_Cmd(TIM2, DISABLE);
    }
  }
#endif
}
 801cb4c:	46bd      	mov	sp, r7
 801cb4e:	bc80      	pop	{r7}
 801cb50:	4770      	bx	lr
 801cb52:	bf00      	nop

0801cb54 <USBH_USR_Init>:
  * @brief  USBH_USR_Init
  * @param  None
  * @retval None
  */
void USBH_USR_Init(void)
{
 801cb54:	b580      	push	{r7, lr}
 801cb56:	af00      	add	r7, sp, #0
	vSemaphoreCreateBinary(semUSBMounted);
 801cb58:	f04f 0001 	mov.w	r0, #1
 801cb5c:	f04f 0100 	mov.w	r1, #0
 801cb60:	f7fd f97e 	bl	8019e60 <xQueueCreate>
 801cb64:	4602      	mov	r2, r0
 801cb66:	f24a 5340 	movw	r3, #42304	; 0xa540
 801cb6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cb6e:	601a      	str	r2, [r3, #0]
 801cb70:	f24a 5340 	movw	r3, #42304	; 0xa540
 801cb74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cb78:	681b      	ldr	r3, [r3, #0]
 801cb7a:	2b00      	cmp	r3, #0
 801cb7c:	d00d      	beq.n	801cb9a <USBH_USR_Init+0x46>
 801cb7e:	f24a 5340 	movw	r3, #42304	; 0xa540
 801cb82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cb86:	681b      	ldr	r3, [r3, #0]
 801cb88:	4618      	mov	r0, r3
 801cb8a:	f04f 0100 	mov.w	r1, #0
 801cb8e:	f04f 0200 	mov.w	r2, #0
 801cb92:	f04f 0300 	mov.w	r3, #0
 801cb96:	f7fd fa17 	bl	8019fc8 <xQueueGenericSend>
	xSemaphoreTake(semUSBMounted,0); //Ensure sem is not available
 801cb9a:	f24a 5340 	movw	r3, #42304	; 0xa540
 801cb9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cba2:	681b      	ldr	r3, [r3, #0]
 801cba4:	4618      	mov	r0, r3
 801cba6:	f04f 0100 	mov.w	r1, #0
 801cbaa:	f04f 0200 	mov.w	r2, #0
 801cbae:	f04f 0300 	mov.w	r3, #0
 801cbb2:	f7fd fae3 	bl	801a17c <xQueueGenericReceive>

	vSemaphoreCreateBinary(semUSBApplication);
 801cbb6:	f04f 0001 	mov.w	r0, #1
 801cbba:	f04f 0100 	mov.w	r1, #0
 801cbbe:	f7fd f94f 	bl	8019e60 <xQueueCreate>
 801cbc2:	4602      	mov	r2, r0
 801cbc4:	f24a 3308 	movw	r3, #41736	; 0xa308
 801cbc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cbcc:	601a      	str	r2, [r3, #0]
 801cbce:	f24a 3308 	movw	r3, #41736	; 0xa308
 801cbd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cbd6:	681b      	ldr	r3, [r3, #0]
 801cbd8:	2b00      	cmp	r3, #0
 801cbda:	d00d      	beq.n	801cbf8 <USBH_USR_Init+0xa4>
 801cbdc:	f24a 3308 	movw	r3, #41736	; 0xa308
 801cbe0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cbe4:	681b      	ldr	r3, [r3, #0]
 801cbe6:	4618      	mov	r0, r3
 801cbe8:	f04f 0100 	mov.w	r1, #0
 801cbec:	f04f 0200 	mov.w	r2, #0
 801cbf0:	f04f 0300 	mov.w	r3, #0
 801cbf4:	f7fd f9e8 	bl	8019fc8 <xQueueGenericSend>
	xSemaphoreTake(semUSBApplication,0); //Ensure sem is not available
 801cbf8:	f24a 3308 	movw	r3, #41736	; 0xa308
 801cbfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cc00:	681b      	ldr	r3, [r3, #0]
 801cc02:	4618      	mov	r0, r3
 801cc04:	f04f 0100 	mov.w	r1, #0
 801cc08:	f04f 0200 	mov.w	r2, #0
 801cc0c:	f04f 0300 	mov.w	r3, #0
 801cc10:	f7fd fab4 	bl	801a17c <xQueueGenericReceive>

}
 801cc14:	bd80      	pop	{r7, pc}
 801cc16:	bf00      	nop

0801cc18 <USBH_USR_DeviceAttached>:
  * @brief  USBH_USR_DeviceAttached
  * @param  None
  * @retval None
  */
void USBH_USR_DeviceAttached(void)
{
 801cc18:	b480      	push	{r7}
 801cc1a:	af00      	add	r7, sp, #0

}
 801cc1c:	46bd      	mov	sp, r7
 801cc1e:	bc80      	pop	{r7}
 801cc20:	4770      	bx	lr
 801cc22:	bf00      	nop

0801cc24 <USBH_USR_UnrecoveredError>:
  * @brief  USBH_USR_UnrecoveredError
  * @param  None
  * @retval None
  */
void USBH_USR_UnrecoveredError (void)
{
 801cc24:	b480      	push	{r7}
 801cc26:	af00      	add	r7, sp, #0
}
 801cc28:	46bd      	mov	sp, r7
 801cc2a:	bc80      	pop	{r7}
 801cc2c:	4770      	bx	lr
 801cc2e:	bf00      	nop

0801cc30 <USBH_USR_DeviceDisconnected>:
  *         Device disconnect event
  * @param  None
  * @retval Staus
  */
void USBH_USR_DeviceDisconnected (void)
{
 801cc30:	b580      	push	{r7, lr}
 801cc32:	af00      	add	r7, sp, #0
	// do not fully block the Task to signal device disconnected
	xSemaphoreTake(semUSBMounted,1000/portTICK_RATE_MS);
 801cc34:	f24a 5340 	movw	r3, #42304	; 0xa540
 801cc38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cc3c:	681b      	ldr	r3, [r3, #0]
 801cc3e:	4618      	mov	r0, r3
 801cc40:	f04f 0100 	mov.w	r1, #0
 801cc44:	f04f 0264 	mov.w	r2, #100	; 0x64
 801cc48:	f04f 0300 	mov.w	r3, #0
 801cc4c:	f7fd fa96 	bl	801a17c <xQueueGenericReceive>
}
 801cc50:	bd80      	pop	{r7, pc}
 801cc52:	bf00      	nop

0801cc54 <USBH_USR_ResetDevice>:
  * @brief  USBH_USR_ResetUSBDevice
  * @param  None
  * @retval None
  */
void USBH_USR_ResetDevice(void)
{
 801cc54:	b480      	push	{r7}
 801cc56:	af00      	add	r7, sp, #0
  /* callback for USB-Reset */
}
 801cc58:	46bd      	mov	sp, r7
 801cc5a:	bc80      	pop	{r7}
 801cc5c:	4770      	bx	lr
 801cc5e:	bf00      	nop

0801cc60 <USBH_USR_DeviceSpeedDetected>:
  *         Displays the message on LCD for device speed
  * @param  Device speed:
  * @retval None
  */
void USBH_USR_DeviceSpeedDetected(uint8_t DeviceSpeed)
{
 801cc60:	b480      	push	{r7}
 801cc62:	b083      	sub	sp, #12
 801cc64:	af00      	add	r7, sp, #0
 801cc66:	4603      	mov	r3, r0
 801cc68:	71fb      	strb	r3, [r7, #7]
}
 801cc6a:	f107 070c 	add.w	r7, r7, #12
 801cc6e:	46bd      	mov	sp, r7
 801cc70:	bc80      	pop	{r7}
 801cc72:	4770      	bx	lr

0801cc74 <USBH_USR_Device_DescAvailable>:
  * @brief  USBH_USR_Device_DescAvailable
  * @param  device descriptor
  * @retval None
  */
void USBH_USR_Device_DescAvailable(void *DeviceDesc)
{
 801cc74:	b480      	push	{r7}
 801cc76:	b083      	sub	sp, #12
 801cc78:	af00      	add	r7, sp, #0
 801cc7a:	6078      	str	r0, [r7, #4]
  /* callback for device descriptor */
}
 801cc7c:	f107 070c 	add.w	r7, r7, #12
 801cc80:	46bd      	mov	sp, r7
 801cc82:	bc80      	pop	{r7}
 801cc84:	4770      	bx	lr
 801cc86:	bf00      	nop

0801cc88 <USBH_USR_DeviceAddressAssigned>:
  *         USB device is successfully assigned the Address
  * @param  None
  * @retval None
  */
void USBH_USR_DeviceAddressAssigned(void)
{
 801cc88:	b480      	push	{r7}
 801cc8a:	af00      	add	r7, sp, #0
  /* callback for device successfully assigned the Address */
}
 801cc8c:	46bd      	mov	sp, r7
 801cc8e:	bc80      	pop	{r7}
 801cc90:	4770      	bx	lr
 801cc92:	bf00      	nop

0801cc94 <USBH_USR_Configuration_DescAvailable>:
  * @retval None
  */
void USBH_USR_Configuration_DescAvailable(USBH_CfgDesc_TypeDef * cfgDesc,
    USBH_InterfaceDesc_TypeDef *itfDesc,
    USBH_EpDesc_TypeDef *epDesc)
{
 801cc94:	b480      	push	{r7}
 801cc96:	b085      	sub	sp, #20
 801cc98:	af00      	add	r7, sp, #0
 801cc9a:	60f8      	str	r0, [r7, #12]
 801cc9c:	60b9      	str	r1, [r7, #8]
 801cc9e:	607a      	str	r2, [r7, #4]
  /* callback for configuration descriptor */
}
 801cca0:	f107 0714 	add.w	r7, r7, #20
 801cca4:	46bd      	mov	sp, r7
 801cca6:	bc80      	pop	{r7}
 801cca8:	4770      	bx	lr
 801ccaa:	bf00      	nop

0801ccac <USBH_USR_Manufacturer_String>:
  * @brief  USBH_USR_Manufacturer_String
  * @param  Manufacturer String
  * @retval None
  */
void USBH_USR_Manufacturer_String(void *ManufacturerString)
{
 801ccac:	b480      	push	{r7}
 801ccae:	b083      	sub	sp, #12
 801ccb0:	af00      	add	r7, sp, #0
 801ccb2:	6078      	str	r0, [r7, #4]
  /* callback for  Manufacturer String */
}
 801ccb4:	f107 070c 	add.w	r7, r7, #12
 801ccb8:	46bd      	mov	sp, r7
 801ccba:	bc80      	pop	{r7}
 801ccbc:	4770      	bx	lr
 801ccbe:	bf00      	nop

0801ccc0 <USBH_USR_Product_String>:
  * @brief  USBH_USR_Product_String
  * @param  Product String
  * @retval None
  */
void USBH_USR_Product_String(void *ProductString)
{
 801ccc0:	b480      	push	{r7}
 801ccc2:	b083      	sub	sp, #12
 801ccc4:	af00      	add	r7, sp, #0
 801ccc6:	6078      	str	r0, [r7, #4]
  /* callback for Product String */
}
 801ccc8:	f107 070c 	add.w	r7, r7, #12
 801cccc:	46bd      	mov	sp, r7
 801ccce:	bc80      	pop	{r7}
 801ccd0:	4770      	bx	lr
 801ccd2:	bf00      	nop

0801ccd4 <USBH_USR_SerialNum_String>:
  * @brief  USBH_USR_SerialNum_String
  * @param  SerialNum_String
  * @retval None
  */
void USBH_USR_SerialNum_String(void *SerialNumString)
{
 801ccd4:	b480      	push	{r7}
 801ccd6:	b083      	sub	sp, #12
 801ccd8:	af00      	add	r7, sp, #0
 801ccda:	6078      	str	r0, [r7, #4]
  /* callback for SerialNum_String */
}
 801ccdc:	f107 070c 	add.w	r7, r7, #12
 801cce0:	46bd      	mov	sp, r7
 801cce2:	bc80      	pop	{r7}
 801cce4:	4770      	bx	lr
 801cce6:	bf00      	nop

0801cce8 <USBH_USR_EnumerationDone>:
  *         User response request is displayed to ask application jump to class
  * @param  None
  * @retval None
  */
void USBH_USR_EnumerationDone(void)
{
 801cce8:	b580      	push	{r7, lr}
 801ccea:	af00      	add	r7, sp, #0
  vTaskDelay(500/portTICK_RATE_MS);
 801ccec:	f04f 0032 	mov.w	r0, #50	; 0x32
 801ccf0:	f7fd fe44 	bl	801a97c <vTaskDelay>
  
  /* Initialises the File System*/
  if (f_mount( 0, &fatfs ) != FR_OK )
 801ccf4:	f04f 0000 	mov.w	r0, #0
 801ccf8:	f24a 310c 	movw	r1, #41740	; 0xa30c
 801ccfc:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801cd00:	f001 fd80 	bl	801e804 <f_mount>
 801cd04:	4603      	mov	r3, r0
 801cd06:	2b00      	cmp	r3, #0
 801cd08:	d10e      	bne.n	801cd28 <USBH_USR_EnumerationDone+0x40>
	  return;

  // signal a mounted device
  xSemaphoreGive(semUSBMounted);
 801cd0a:	f24a 5340 	movw	r3, #42304	; 0xa540
 801cd0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cd12:	681b      	ldr	r3, [r3, #0]
 801cd14:	4618      	mov	r0, r3
 801cd16:	f04f 0100 	mov.w	r1, #0
 801cd1a:	f04f 0200 	mov.w	r2, #0
 801cd1e:	f04f 0300 	mov.w	r3, #0
 801cd22:	f7fd f951 	bl	8019fc8 <xQueueGenericSend>
 801cd26:	e000      	b.n	801cd2a <USBH_USR_EnumerationDone+0x42>
{
  vTaskDelay(500/portTICK_RATE_MS);
  
  /* Initialises the File System*/
  if (f_mount( 0, &fatfs ) != FR_OK )
	  return;
 801cd28:	bf00      	nop

  // signal a mounted device
  xSemaphoreGive(semUSBMounted);
} 
 801cd2a:	bd80      	pop	{r7, pc}

0801cd2c <USBH_USR_DeviceNotSupported>:
  *         Device is not supported
  * @param  None
  * @retval None
  */
void USBH_USR_DeviceNotSupported(void)
{
 801cd2c:	b480      	push	{r7}
 801cd2e:	af00      	add	r7, sp, #0
}
 801cd30:	46bd      	mov	sp, r7
 801cd32:	bc80      	pop	{r7}
 801cd34:	4770      	bx	lr
 801cd36:	bf00      	nop

0801cd38 <USBH_USR_UserInput>:
  *         User Action for application state entry
  * @param  None
  * @retval USBH_USR_Status : User response for key button
  */
USBH_USR_Status USBH_USR_UserInput(void)
{
 801cd38:	b480      	push	{r7}
 801cd3a:	af00      	add	r7, sp, #0
  /* callback for Key botton: set by software in this case */
  return USBH_USR_RESP_OK;
 801cd3c:	f04f 0301 	mov.w	r3, #1
}
 801cd40:	4618      	mov	r0, r3
 801cd42:	46bd      	mov	sp, r7
 801cd44:	bc80      	pop	{r7}
 801cd46:	4770      	bx	lr

0801cd48 <USBH_USR_OverCurrentDetected>:
  *         Over Current Detected on VBUS
  * @param  None
  * @retval None
  */
void USBH_USR_OverCurrentDetected (void)
{
 801cd48:	b480      	push	{r7}
 801cd4a:	af00      	add	r7, sp, #0
}
 801cd4c:	46bd      	mov	sp, r7
 801cd4e:	bc80      	pop	{r7}
 801cd50:	4770      	bx	lr
 801cd52:	bf00      	nop

0801cd54 <USBH_USR_MSC_Application>:
  * @brief  USBH_USR_MSC_Application
  * @param  None
  * @retval Staus
  */
int USBH_USR_MSC_Application(void)
{
 801cd54:	b580      	push	{r7, lr}
 801cd56:	af00      	add	r7, sp, #0
	/*
	 * to syncronise USB Application Layer and File handler
	 * This Sem is given, so FileHandler is woke, when File Handler
	 * gives the Sem back Usb obtains it and processes
	 */
	xSemaphoreGive(semUSBApplication);
 801cd58:	f24a 3308 	movw	r3, #41736	; 0xa308
 801cd5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cd60:	681b      	ldr	r3, [r3, #0]
 801cd62:	4618      	mov	r0, r3
 801cd64:	f04f 0100 	mov.w	r1, #0
 801cd68:	f04f 0200 	mov.w	r2, #0
 801cd6c:	f04f 0300 	mov.w	r3, #0
 801cd70:	f7fd f92a 	bl	8019fc8 <xQueueGenericSend>
	/*
	 * ensure task yields
	 */
	taskYIELD();
 801cd74:	f7fc ff0e 	bl	8019b94 <vPortYieldFromISR>
	/*
	 * Filehandler Tast is executing
	 */
	xSemaphoreTake(semUSBApplication,portMAX_DELAY);
 801cd78:	f24a 3308 	movw	r3, #41736	; 0xa308
 801cd7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801cd80:	681b      	ldr	r3, [r3, #0]
 801cd82:	4618      	mov	r0, r3
 801cd84:	f04f 0100 	mov.w	r1, #0
 801cd88:	f04f 32ff 	mov.w	r2, #4294967295
 801cd8c:	f04f 0300 	mov.w	r3, #0
 801cd90:	f7fd f9f4 	bl	801a17c <xQueueGenericReceive>
  return(0);
 801cd94:	f04f 0300 	mov.w	r3, #0
}
 801cd98:	4618      	mov	r0, r3
 801cd9a:	bd80      	pop	{r7, pc}

0801cd9c <USBH_USR_DeInit>:
  *         Deint User state and associated variables
  * @param  None
  * @retval None
  */
void USBH_USR_DeInit(void)
{
 801cd9c:	b480      	push	{r7}
 801cd9e:	af00      	add	r7, sp, #0

}
 801cda0:	46bd      	mov	sp, r7
 801cda2:	bc80      	pop	{r7}
 801cda4:	4770      	bx	lr
 801cda6:	bf00      	nop

0801cda8 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, int cnt) {
 801cda8:	b480      	push	{r7}
 801cdaa:	b087      	sub	sp, #28
 801cdac:	af00      	add	r7, sp, #0
 801cdae:	60f8      	str	r0, [r7, #12]
 801cdb0:	60b9      	str	r1, [r7, #8]
 801cdb2:	607a      	str	r2, [r7, #4]
	char *d = (char*)dst;
 801cdb4:	68fb      	ldr	r3, [r7, #12]
 801cdb6:	617b      	str	r3, [r7, #20]
	const char *s = (const char *)src;
 801cdb8:	68bb      	ldr	r3, [r7, #8]
 801cdba:	613b      	str	r3, [r7, #16]
	while (cnt--) *d++ = *s++;
 801cdbc:	e00b      	b.n	801cdd6 <mem_cpy+0x2e>
 801cdbe:	693b      	ldr	r3, [r7, #16]
 801cdc0:	781a      	ldrb	r2, [r3, #0]
 801cdc2:	697b      	ldr	r3, [r7, #20]
 801cdc4:	701a      	strb	r2, [r3, #0]
 801cdc6:	697b      	ldr	r3, [r7, #20]
 801cdc8:	f103 0301 	add.w	r3, r3, #1
 801cdcc:	617b      	str	r3, [r7, #20]
 801cdce:	693b      	ldr	r3, [r7, #16]
 801cdd0:	f103 0301 	add.w	r3, r3, #1
 801cdd4:	613b      	str	r3, [r7, #16]
 801cdd6:	687b      	ldr	r3, [r7, #4]
 801cdd8:	2b00      	cmp	r3, #0
 801cdda:	bf0c      	ite	eq
 801cddc:	2300      	moveq	r3, #0
 801cdde:	2301      	movne	r3, #1
 801cde0:	b2db      	uxtb	r3, r3
 801cde2:	687a      	ldr	r2, [r7, #4]
 801cde4:	f102 32ff 	add.w	r2, r2, #4294967295
 801cde8:	607a      	str	r2, [r7, #4]
 801cdea:	2b00      	cmp	r3, #0
 801cdec:	d1e7      	bne.n	801cdbe <mem_cpy+0x16>
}
 801cdee:	f107 071c 	add.w	r7, r7, #28
 801cdf2:	46bd      	mov	sp, r7
 801cdf4:	bc80      	pop	{r7}
 801cdf6:	4770      	bx	lr

0801cdf8 <mem_set>:

/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
 801cdf8:	b480      	push	{r7}
 801cdfa:	b087      	sub	sp, #28
 801cdfc:	af00      	add	r7, sp, #0
 801cdfe:	60f8      	str	r0, [r7, #12]
 801ce00:	60b9      	str	r1, [r7, #8]
 801ce02:	607a      	str	r2, [r7, #4]
	char *d = (char*)dst;
 801ce04:	68fb      	ldr	r3, [r7, #12]
 801ce06:	617b      	str	r3, [r7, #20]
	while (cnt--) *d++ = (char)val;
 801ce08:	e007      	b.n	801ce1a <mem_set+0x22>
 801ce0a:	68bb      	ldr	r3, [r7, #8]
 801ce0c:	b2da      	uxtb	r2, r3
 801ce0e:	697b      	ldr	r3, [r7, #20]
 801ce10:	701a      	strb	r2, [r3, #0]
 801ce12:	697b      	ldr	r3, [r7, #20]
 801ce14:	f103 0301 	add.w	r3, r3, #1
 801ce18:	617b      	str	r3, [r7, #20]
 801ce1a:	687b      	ldr	r3, [r7, #4]
 801ce1c:	2b00      	cmp	r3, #0
 801ce1e:	bf0c      	ite	eq
 801ce20:	2300      	moveq	r3, #0
 801ce22:	2301      	movne	r3, #1
 801ce24:	b2db      	uxtb	r3, r3
 801ce26:	687a      	ldr	r2, [r7, #4]
 801ce28:	f102 32ff 	add.w	r2, r2, #4294967295
 801ce2c:	607a      	str	r2, [r7, #4]
 801ce2e:	2b00      	cmp	r3, #0
 801ce30:	d1eb      	bne.n	801ce0a <mem_set+0x12>
}
 801ce32:	f107 071c 	add.w	r7, r7, #28
 801ce36:	46bd      	mov	sp, r7
 801ce38:	bc80      	pop	{r7}
 801ce3a:	4770      	bx	lr

0801ce3c <mem_cmp>:

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, int cnt) {
 801ce3c:	b480      	push	{r7}
 801ce3e:	b089      	sub	sp, #36	; 0x24
 801ce40:	af00      	add	r7, sp, #0
 801ce42:	60f8      	str	r0, [r7, #12]
 801ce44:	60b9      	str	r1, [r7, #8]
 801ce46:	607a      	str	r2, [r7, #4]
	const char *d = (const char *)dst, *s = (const char *)src;
 801ce48:	68fb      	ldr	r3, [r7, #12]
 801ce4a:	61fb      	str	r3, [r7, #28]
 801ce4c:	68bb      	ldr	r3, [r7, #8]
 801ce4e:	61bb      	str	r3, [r7, #24]
	int r = 0;
 801ce50:	f04f 0300 	mov.w	r3, #0
 801ce54:	617b      	str	r3, [r7, #20]
	while (cnt-- && (r = *d++ - *s++) == 0) ;
 801ce56:	bf00      	nop
 801ce58:	687b      	ldr	r3, [r7, #4]
 801ce5a:	2b00      	cmp	r3, #0
 801ce5c:	bf0c      	ite	eq
 801ce5e:	2300      	moveq	r3, #0
 801ce60:	2301      	movne	r3, #1
 801ce62:	b2db      	uxtb	r3, r3
 801ce64:	687a      	ldr	r2, [r7, #4]
 801ce66:	f102 32ff 	add.w	r2, r2, #4294967295
 801ce6a:	607a      	str	r2, [r7, #4]
 801ce6c:	2b00      	cmp	r3, #0
 801ce6e:	d016      	beq.n	801ce9e <mem_cmp+0x62>
 801ce70:	69fb      	ldr	r3, [r7, #28]
 801ce72:	781b      	ldrb	r3, [r3, #0]
 801ce74:	461a      	mov	r2, r3
 801ce76:	69bb      	ldr	r3, [r7, #24]
 801ce78:	781b      	ldrb	r3, [r3, #0]
 801ce7a:	1ad3      	subs	r3, r2, r3
 801ce7c:	617b      	str	r3, [r7, #20]
 801ce7e:	697b      	ldr	r3, [r7, #20]
 801ce80:	2b00      	cmp	r3, #0
 801ce82:	bf14      	ite	ne
 801ce84:	2300      	movne	r3, #0
 801ce86:	2301      	moveq	r3, #1
 801ce88:	b2db      	uxtb	r3, r3
 801ce8a:	69fa      	ldr	r2, [r7, #28]
 801ce8c:	f102 0201 	add.w	r2, r2, #1
 801ce90:	61fa      	str	r2, [r7, #28]
 801ce92:	69ba      	ldr	r2, [r7, #24]
 801ce94:	f102 0201 	add.w	r2, r2, #1
 801ce98:	61ba      	str	r2, [r7, #24]
 801ce9a:	2b00      	cmp	r3, #0
 801ce9c:	d1dc      	bne.n	801ce58 <mem_cmp+0x1c>
	return r;
 801ce9e:	697b      	ldr	r3, [r7, #20]
}
 801cea0:	4618      	mov	r0, r3
 801cea2:	f107 0724 	add.w	r7, r7, #36	; 0x24
 801cea6:	46bd      	mov	sp, r7
 801cea8:	bc80      	pop	{r7}
 801ceaa:	4770      	bx	lr

0801ceac <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
 801ceac:	b480      	push	{r7}
 801ceae:	b083      	sub	sp, #12
 801ceb0:	af00      	add	r7, sp, #0
 801ceb2:	6078      	str	r0, [r7, #4]
 801ceb4:	6039      	str	r1, [r7, #0]
	while (*str && *str != chr) str++;
 801ceb6:	e003      	b.n	801cec0 <chk_chr+0x14>
 801ceb8:	687b      	ldr	r3, [r7, #4]
 801ceba:	f103 0301 	add.w	r3, r3, #1
 801cebe:	607b      	str	r3, [r7, #4]
 801cec0:	687b      	ldr	r3, [r7, #4]
 801cec2:	781b      	ldrb	r3, [r3, #0]
 801cec4:	2b00      	cmp	r3, #0
 801cec6:	d005      	beq.n	801ced4 <chk_chr+0x28>
 801cec8:	687b      	ldr	r3, [r7, #4]
 801ceca:	781b      	ldrb	r3, [r3, #0]
 801cecc:	461a      	mov	r2, r3
 801cece:	683b      	ldr	r3, [r7, #0]
 801ced0:	429a      	cmp	r2, r3
 801ced2:	d1f1      	bne.n	801ceb8 <chk_chr+0xc>
	return *str;
 801ced4:	687b      	ldr	r3, [r7, #4]
 801ced6:	781b      	ldrb	r3, [r3, #0]
}
 801ced8:	4618      	mov	r0, r3
 801ceda:	f107 070c 	add.w	r7, r7, #12
 801cede:	46bd      	mov	sp, r7
 801cee0:	bc80      	pop	{r7}
 801cee2:	4770      	bx	lr

0801cee4 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make apperance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
 801cee4:	b580      	push	{r7, lr}
 801cee6:	b084      	sub	sp, #16
 801cee8:	af00      	add	r7, sp, #0
 801ceea:	6078      	str	r0, [r7, #4]
 801ceec:	6039      	str	r1, [r7, #0]
	DWORD wsect;


	wsect = fs->winsect;
 801ceee:	687b      	ldr	r3, [r7, #4]
 801cef0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801cef2:	60fb      	str	r3, [r7, #12]
	if (wsect != sector) {	/* Changed current window */
 801cef4:	68fa      	ldr	r2, [r7, #12]
 801cef6:	683b      	ldr	r3, [r7, #0]
 801cef8:	429a      	cmp	r2, r3
 801cefa:	d055      	beq.n	801cfa8 <move_window+0xc4>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
 801cefc:	687b      	ldr	r3, [r7, #4]
 801cefe:	791b      	ldrb	r3, [r3, #4]
 801cf00:	2b00      	cmp	r3, #0
 801cf02:	d039      	beq.n	801cf78 <move_window+0x94>
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
 801cf04:	687b      	ldr	r3, [r7, #4]
 801cf06:	785a      	ldrb	r2, [r3, #1]
 801cf08:	687b      	ldr	r3, [r7, #4]
 801cf0a:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801cf0e:	4610      	mov	r0, r2
 801cf10:	4619      	mov	r1, r3
 801cf12:	68fa      	ldr	r2, [r7, #12]
 801cf14:	f04f 0301 	mov.w	r3, #1
 801cf18:	f7e8 faf4 	bl	8005504 <disk_write>
 801cf1c:	4603      	mov	r3, r0
 801cf1e:	2b00      	cmp	r3, #0
 801cf20:	d002      	beq.n	801cf28 <move_window+0x44>
				return FR_DISK_ERR;
 801cf22:	f04f 0301 	mov.w	r3, #1
 801cf26:	e041      	b.n	801cfac <move_window+0xc8>
			fs->wflag = 0;
 801cf28:	687b      	ldr	r3, [r7, #4]
 801cf2a:	f04f 0200 	mov.w	r2, #0
 801cf2e:	711a      	strb	r2, [r3, #4]
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
 801cf30:	687b      	ldr	r3, [r7, #4]
 801cf32:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801cf34:	687b      	ldr	r3, [r7, #4]
 801cf36:	69db      	ldr	r3, [r3, #28]
 801cf38:	18d2      	adds	r2, r2, r3
 801cf3a:	68fb      	ldr	r3, [r7, #12]
 801cf3c:	429a      	cmp	r2, r3
 801cf3e:	d91b      	bls.n	801cf78 <move_window+0x94>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Refrect the change to all FAT copies */
 801cf40:	687b      	ldr	r3, [r7, #4]
 801cf42:	78db      	ldrb	r3, [r3, #3]
 801cf44:	72fb      	strb	r3, [r7, #11]
 801cf46:	e014      	b.n	801cf72 <move_window+0x8e>
					wsect += fs->sects_fat;
 801cf48:	687b      	ldr	r3, [r7, #4]
 801cf4a:	69db      	ldr	r3, [r3, #28]
 801cf4c:	68fa      	ldr	r2, [r7, #12]
 801cf4e:	18d3      	adds	r3, r2, r3
 801cf50:	60fb      	str	r3, [r7, #12]
					disk_write(fs->drive, fs->win, wsect, 1);
 801cf52:	687b      	ldr	r3, [r7, #4]
 801cf54:	785a      	ldrb	r2, [r3, #1]
 801cf56:	687b      	ldr	r3, [r7, #4]
 801cf58:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801cf5c:	4610      	mov	r0, r2
 801cf5e:	4619      	mov	r1, r3
 801cf60:	68fa      	ldr	r2, [r7, #12]
 801cf62:	f04f 0301 	mov.w	r3, #1
 801cf66:	f7e8 facd 	bl	8005504 <disk_write>
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Refrect the change to all FAT copies */
 801cf6a:	7afb      	ldrb	r3, [r7, #11]
 801cf6c:	f103 33ff 	add.w	r3, r3, #4294967295
 801cf70:	72fb      	strb	r3, [r7, #11]
 801cf72:	7afb      	ldrb	r3, [r7, #11]
 801cf74:	2b01      	cmp	r3, #1
 801cf76:	d8e7      	bhi.n	801cf48 <move_window+0x64>
					disk_write(fs->drive, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
 801cf78:	683b      	ldr	r3, [r7, #0]
 801cf7a:	2b00      	cmp	r3, #0
 801cf7c:	d014      	beq.n	801cfa8 <move_window+0xc4>
			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
 801cf7e:	687b      	ldr	r3, [r7, #4]
 801cf80:	785a      	ldrb	r2, [r3, #1]
 801cf82:	687b      	ldr	r3, [r7, #4]
 801cf84:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801cf88:	4610      	mov	r0, r2
 801cf8a:	4619      	mov	r1, r3
 801cf8c:	683a      	ldr	r2, [r7, #0]
 801cf8e:	f04f 0301 	mov.w	r3, #1
 801cf92:	f7e8 fa59 	bl	8005448 <disk_read>
 801cf96:	4603      	mov	r3, r0
 801cf98:	2b00      	cmp	r3, #0
 801cf9a:	d002      	beq.n	801cfa2 <move_window+0xbe>
				return FR_DISK_ERR;
 801cf9c:	f04f 0301 	mov.w	r3, #1
 801cfa0:	e004      	b.n	801cfac <move_window+0xc8>
			fs->winsect = sector;
 801cfa2:	687b      	ldr	r3, [r7, #4]
 801cfa4:	683a      	ldr	r2, [r7, #0]
 801cfa6:	631a      	str	r2, [r3, #48]	; 0x30
		}
	}

	return FR_OK;
 801cfa8:	f04f 0300 	mov.w	r3, #0
}
 801cfac:	4618      	mov	r0, r3
 801cfae:	f107 0710 	add.w	r7, r7, #16
 801cfb2:	46bd      	mov	sp, r7
 801cfb4:	bd80      	pop	{r7, pc}
 801cfb6:	bf00      	nop

0801cfb8 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
 801cfb8:	b580      	push	{r7, lr}
 801cfba:	b084      	sub	sp, #16
 801cfbc:	af00      	add	r7, sp, #0
 801cfbe:	6078      	str	r0, [r7, #4]
	FRESULT res;


	res = move_window(fs, 0);
 801cfc0:	6878      	ldr	r0, [r7, #4]
 801cfc2:	f04f 0100 	mov.w	r1, #0
 801cfc6:	f7ff ff8d 	bl	801cee4 <move_window>
 801cfca:	4603      	mov	r3, r0
 801cfcc:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 801cfce:	7bfb      	ldrb	r3, [r7, #15]
 801cfd0:	2b00      	cmp	r3, #0
 801cfd2:	f040 80ab 	bne.w	801d12c <sync+0x174>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 801cfd6:	687b      	ldr	r3, [r7, #4]
 801cfd8:	781b      	ldrb	r3, [r3, #0]
 801cfda:	2b03      	cmp	r3, #3
 801cfdc:	f040 8097 	bne.w	801d10e <sync+0x156>
 801cfe0:	687b      	ldr	r3, [r7, #4]
 801cfe2:	7a9b      	ldrb	r3, [r3, #10]
 801cfe4:	2b00      	cmp	r3, #0
 801cfe6:	f000 8092 	beq.w	801d10e <sync+0x156>
			fs->winsect = 0;
 801cfea:	687b      	ldr	r3, [r7, #4]
 801cfec:	f04f 0200 	mov.w	r2, #0
 801cff0:	631a      	str	r2, [r3, #48]	; 0x30
			mem_set(fs->win, 0, 512);
 801cff2:	687b      	ldr	r3, [r7, #4]
 801cff4:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801cff8:	4618      	mov	r0, r3
 801cffa:	f04f 0100 	mov.w	r1, #0
 801cffe:	f44f 7200 	mov.w	r2, #512	; 0x200
 801d002:	f7ff fef9 	bl	801cdf8 <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 801d006:	687b      	ldr	r3, [r7, #4]
 801d008:	f04f 0255 	mov.w	r2, #85	; 0x55
 801d00c:	f883 2232 	strb.w	r2, [r3, #562]	; 0x232
 801d010:	687b      	ldr	r3, [r7, #4]
 801d012:	f04f 02aa 	mov.w	r2, #170	; 0xaa
 801d016:	f883 2233 	strb.w	r2, [r3, #563]	; 0x233
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 801d01a:	687b      	ldr	r3, [r7, #4]
 801d01c:	f04f 0252 	mov.w	r2, #82	; 0x52
 801d020:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 801d024:	687b      	ldr	r3, [r7, #4]
 801d026:	f04f 0252 	mov.w	r2, #82	; 0x52
 801d02a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 801d02e:	687b      	ldr	r3, [r7, #4]
 801d030:	f04f 0261 	mov.w	r2, #97	; 0x61
 801d034:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
 801d038:	687b      	ldr	r3, [r7, #4]
 801d03a:	f04f 0241 	mov.w	r2, #65	; 0x41
 801d03e:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 801d042:	687b      	ldr	r3, [r7, #4]
 801d044:	f04f 0272 	mov.w	r2, #114	; 0x72
 801d048:	f883 2218 	strb.w	r2, [r3, #536]	; 0x218
 801d04c:	687b      	ldr	r3, [r7, #4]
 801d04e:	f04f 0272 	mov.w	r2, #114	; 0x72
 801d052:	f883 2219 	strb.w	r2, [r3, #537]	; 0x219
 801d056:	687b      	ldr	r3, [r7, #4]
 801d058:	f04f 0241 	mov.w	r2, #65	; 0x41
 801d05c:	f883 221a 	strb.w	r2, [r3, #538]	; 0x21a
 801d060:	687b      	ldr	r3, [r7, #4]
 801d062:	f04f 0261 	mov.w	r2, #97	; 0x61
 801d066:	f883 221b 	strb.w	r2, [r3, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 801d06a:	687b      	ldr	r3, [r7, #4]
 801d06c:	691b      	ldr	r3, [r3, #16]
 801d06e:	b2da      	uxtb	r2, r3
 801d070:	687b      	ldr	r3, [r7, #4]
 801d072:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
 801d076:	687b      	ldr	r3, [r7, #4]
 801d078:	691b      	ldr	r3, [r3, #16]
 801d07a:	b29b      	uxth	r3, r3
 801d07c:	ea4f 2313 	mov.w	r3, r3, lsr #8
 801d080:	b29b      	uxth	r3, r3
 801d082:	b2da      	uxtb	r2, r3
 801d084:	687b      	ldr	r3, [r7, #4]
 801d086:	f883 221d 	strb.w	r2, [r3, #541]	; 0x21d
 801d08a:	687b      	ldr	r3, [r7, #4]
 801d08c:	691b      	ldr	r3, [r3, #16]
 801d08e:	ea4f 4313 	mov.w	r3, r3, lsr #16
 801d092:	b2da      	uxtb	r2, r3
 801d094:	687b      	ldr	r3, [r7, #4]
 801d096:	f883 221e 	strb.w	r2, [r3, #542]	; 0x21e
 801d09a:	687b      	ldr	r3, [r7, #4]
 801d09c:	691b      	ldr	r3, [r3, #16]
 801d09e:	ea4f 6313 	mov.w	r3, r3, lsr #24
 801d0a2:	b2da      	uxtb	r2, r3
 801d0a4:	687b      	ldr	r3, [r7, #4]
 801d0a6:	f883 221f 	strb.w	r2, [r3, #543]	; 0x21f
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 801d0aa:	687b      	ldr	r3, [r7, #4]
 801d0ac:	68db      	ldr	r3, [r3, #12]
 801d0ae:	b2da      	uxtb	r2, r3
 801d0b0:	687b      	ldr	r3, [r7, #4]
 801d0b2:	f883 2220 	strb.w	r2, [r3, #544]	; 0x220
 801d0b6:	687b      	ldr	r3, [r7, #4]
 801d0b8:	68db      	ldr	r3, [r3, #12]
 801d0ba:	b29b      	uxth	r3, r3
 801d0bc:	ea4f 2313 	mov.w	r3, r3, lsr #8
 801d0c0:	b29b      	uxth	r3, r3
 801d0c2:	b2da      	uxtb	r2, r3
 801d0c4:	687b      	ldr	r3, [r7, #4]
 801d0c6:	f883 2221 	strb.w	r2, [r3, #545]	; 0x221
 801d0ca:	687b      	ldr	r3, [r7, #4]
 801d0cc:	68db      	ldr	r3, [r3, #12]
 801d0ce:	ea4f 4313 	mov.w	r3, r3, lsr #16
 801d0d2:	b2da      	uxtb	r2, r3
 801d0d4:	687b      	ldr	r3, [r7, #4]
 801d0d6:	f883 2222 	strb.w	r2, [r3, #546]	; 0x222
 801d0da:	687b      	ldr	r3, [r7, #4]
 801d0dc:	68db      	ldr	r3, [r3, #12]
 801d0de:	ea4f 6313 	mov.w	r3, r3, lsr #24
 801d0e2:	b2da      	uxtb	r2, r3
 801d0e4:	687b      	ldr	r3, [r7, #4]
 801d0e6:	f883 2223 	strb.w	r2, [r3, #547]	; 0x223
			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
 801d0ea:	687b      	ldr	r3, [r7, #4]
 801d0ec:	7859      	ldrb	r1, [r3, #1]
 801d0ee:	687b      	ldr	r3, [r7, #4]
 801d0f0:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d0f4:	687b      	ldr	r3, [r7, #4]
 801d0f6:	695b      	ldr	r3, [r3, #20]
 801d0f8:	4608      	mov	r0, r1
 801d0fa:	4611      	mov	r1, r2
 801d0fc:	461a      	mov	r2, r3
 801d0fe:	f04f 0301 	mov.w	r3, #1
 801d102:	f7e8 f9ff 	bl	8005504 <disk_write>
			fs->fsi_flag = 0;
 801d106:	687b      	ldr	r3, [r7, #4]
 801d108:	f04f 0200 	mov.w	r2, #0
 801d10c:	729a      	strb	r2, [r3, #10]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drive, CTRL_SYNC, (void*)NULL) != RES_OK)
 801d10e:	687b      	ldr	r3, [r7, #4]
 801d110:	785b      	ldrb	r3, [r3, #1]
 801d112:	4618      	mov	r0, r3
 801d114:	f04f 0100 	mov.w	r1, #0
 801d118:	f04f 0200 	mov.w	r2, #0
 801d11c:	f7e8 fa5e 	bl	80055dc <disk_ioctl>
 801d120:	4603      	mov	r3, r0
 801d122:	2b00      	cmp	r3, #0
 801d124:	d002      	beq.n	801d12c <sync+0x174>
			res = FR_DISK_ERR;
 801d126:	f04f 0301 	mov.w	r3, #1
 801d12a:	73fb      	strb	r3, [r7, #15]
	}

	return res;
 801d12c:	7bfb      	ldrb	r3, [r7, #15]
}
 801d12e:	4618      	mov	r0, r3
 801d130:	f107 0710 	add.w	r7, r7, #16
 801d134:	46bd      	mov	sp, r7
 801d136:	bd80      	pop	{r7, pc}

0801d138 <get_fat>:
static
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Interal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
 801d138:	b580      	push	{r7, lr}
 801d13a:	b086      	sub	sp, #24
 801d13c:	af00      	add	r7, sp, #0
 801d13e:	6078      	str	r0, [r7, #4]
 801d140:	6039      	str	r1, [r7, #0]
	UINT wc, bc;
	DWORD fsect;


	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
 801d142:	683b      	ldr	r3, [r7, #0]
 801d144:	2b01      	cmp	r3, #1
 801d146:	d904      	bls.n	801d152 <get_fat+0x1a>
 801d148:	687b      	ldr	r3, [r7, #4]
 801d14a:	6a1a      	ldr	r2, [r3, #32]
 801d14c:	683b      	ldr	r3, [r7, #0]
 801d14e:	429a      	cmp	r2, r3
 801d150:	d802      	bhi.n	801d158 <get_fat+0x20>
		return 1;
 801d152:	f04f 0301 	mov.w	r3, #1
 801d156:	e0e3      	b.n	801d320 <get_fat+0x1e8>

	fsect = fs->fatbase;
 801d158:	687b      	ldr	r3, [r7, #4]
 801d15a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d15c:	617b      	str	r3, [r7, #20]
	switch (fs->fs_type) {
 801d15e:	687b      	ldr	r3, [r7, #4]
 801d160:	781b      	ldrb	r3, [r3, #0]
 801d162:	2b02      	cmp	r3, #2
 801d164:	d052      	beq.n	801d20c <get_fat+0xd4>
 801d166:	2b03      	cmp	r3, #3
 801d168:	d07f      	beq.n	801d26a <get_fat+0x132>
 801d16a:	2b01      	cmp	r3, #1
 801d16c:	f040 80d6 	bne.w	801d31c <get_fat+0x1e4>
	case FS_FAT12 :
		bc = clst; bc += bc / 2;
 801d170:	683b      	ldr	r3, [r7, #0]
 801d172:	613b      	str	r3, [r7, #16]
 801d174:	693b      	ldr	r3, [r7, #16]
 801d176:	ea4f 0353 	mov.w	r3, r3, lsr #1
 801d17a:	693a      	ldr	r2, [r7, #16]
 801d17c:	18d3      	adds	r3, r2, r3
 801d17e:	613b      	str	r3, [r7, #16]
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 801d180:	693b      	ldr	r3, [r7, #16]
 801d182:	ea4f 2253 	mov.w	r2, r3, lsr #9
 801d186:	697b      	ldr	r3, [r7, #20]
 801d188:	18d3      	adds	r3, r2, r3
 801d18a:	6878      	ldr	r0, [r7, #4]
 801d18c:	4619      	mov	r1, r3
 801d18e:	f7ff fea9 	bl	801cee4 <move_window>
 801d192:	4603      	mov	r3, r0
 801d194:	2b00      	cmp	r3, #0
 801d196:	f040 80ba 	bne.w	801d30e <get_fat+0x1d6>
		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
 801d19a:	693b      	ldr	r3, [r7, #16]
 801d19c:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d1a0:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d1a4:	687a      	ldr	r2, [r7, #4]
 801d1a6:	18d3      	adds	r3, r2, r3
 801d1a8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801d1ac:	60fb      	str	r3, [r7, #12]
 801d1ae:	693b      	ldr	r3, [r7, #16]
 801d1b0:	f103 0301 	add.w	r3, r3, #1
 801d1b4:	613b      	str	r3, [r7, #16]
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 801d1b6:	693b      	ldr	r3, [r7, #16]
 801d1b8:	ea4f 2253 	mov.w	r2, r3, lsr #9
 801d1bc:	697b      	ldr	r3, [r7, #20]
 801d1be:	18d3      	adds	r3, r2, r3
 801d1c0:	6878      	ldr	r0, [r7, #4]
 801d1c2:	4619      	mov	r1, r3
 801d1c4:	f7ff fe8e 	bl	801cee4 <move_window>
 801d1c8:	4603      	mov	r3, r0
 801d1ca:	2b00      	cmp	r3, #0
 801d1cc:	f040 80a1 	bne.w	801d312 <get_fat+0x1da>
		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
 801d1d0:	693b      	ldr	r3, [r7, #16]
 801d1d2:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d1d6:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d1da:	687a      	ldr	r2, [r7, #4]
 801d1dc:	18d3      	adds	r3, r2, r3
 801d1de:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801d1e2:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801d1e6:	68fa      	ldr	r2, [r7, #12]
 801d1e8:	4313      	orrs	r3, r2
 801d1ea:	60fb      	str	r3, [r7, #12]
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 801d1ec:	683b      	ldr	r3, [r7, #0]
 801d1ee:	f003 0301 	and.w	r3, r3, #1
 801d1f2:	b2db      	uxtb	r3, r3
 801d1f4:	2b00      	cmp	r3, #0
 801d1f6:	d003      	beq.n	801d200 <get_fat+0xc8>
 801d1f8:	68fb      	ldr	r3, [r7, #12]
 801d1fa:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801d1fe:	e004      	b.n	801d20a <get_fat+0xd2>
 801d200:	68fb      	ldr	r3, [r7, #12]
 801d202:	ea4f 5303 	mov.w	r3, r3, lsl #20
 801d206:	ea4f 5313 	mov.w	r3, r3, lsr #20
 801d20a:	e089      	b.n	801d320 <get_fat+0x1e8>

	case FS_FAT16 :
		if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
 801d20c:	683b      	ldr	r3, [r7, #0]
 801d20e:	ea4f 2213 	mov.w	r2, r3, lsr #8
 801d212:	697b      	ldr	r3, [r7, #20]
 801d214:	18d3      	adds	r3, r2, r3
 801d216:	6878      	ldr	r0, [r7, #4]
 801d218:	4619      	mov	r1, r3
 801d21a:	f7ff fe63 	bl	801cee4 <move_window>
 801d21e:	4603      	mov	r3, r0
 801d220:	2b00      	cmp	r3, #0
 801d222:	d178      	bne.n	801d316 <get_fat+0x1de>
		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
 801d224:	687b      	ldr	r3, [r7, #4]
 801d226:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d22a:	683b      	ldr	r3, [r7, #0]
 801d22c:	b29b      	uxth	r3, r3
 801d22e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801d232:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d236:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d23a:	f103 0301 	add.w	r3, r3, #1
 801d23e:	18d3      	adds	r3, r2, r3
 801d240:	781b      	ldrb	r3, [r3, #0]
 801d242:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801d246:	b29a      	uxth	r2, r3
 801d248:	687b      	ldr	r3, [r7, #4]
 801d24a:	f103 0134 	add.w	r1, r3, #52	; 0x34
 801d24e:	683b      	ldr	r3, [r7, #0]
 801d250:	b29b      	uxth	r3, r3
 801d252:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801d256:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d25a:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d25e:	18cb      	adds	r3, r1, r3
 801d260:	781b      	ldrb	r3, [r3, #0]
 801d262:	4313      	orrs	r3, r2
 801d264:	b29b      	uxth	r3, r3
 801d266:	b29b      	uxth	r3, r3
 801d268:	e05a      	b.n	801d320 <get_fat+0x1e8>

	case FS_FAT32 :
		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
 801d26a:	683b      	ldr	r3, [r7, #0]
 801d26c:	ea4f 12d3 	mov.w	r2, r3, lsr #7
 801d270:	697b      	ldr	r3, [r7, #20]
 801d272:	18d3      	adds	r3, r2, r3
 801d274:	6878      	ldr	r0, [r7, #4]
 801d276:	4619      	mov	r1, r3
 801d278:	f7ff fe34 	bl	801cee4 <move_window>
 801d27c:	4603      	mov	r3, r0
 801d27e:	2b00      	cmp	r3, #0
 801d280:	d14b      	bne.n	801d31a <get_fat+0x1e2>
		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
 801d282:	687b      	ldr	r3, [r7, #4]
 801d284:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d288:	683b      	ldr	r3, [r7, #0]
 801d28a:	b29b      	uxth	r3, r3
 801d28c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d290:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d294:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d298:	f103 0303 	add.w	r3, r3, #3
 801d29c:	18d3      	adds	r3, r2, r3
 801d29e:	781b      	ldrb	r3, [r3, #0]
 801d2a0:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801d2a4:	687b      	ldr	r3, [r7, #4]
 801d2a6:	f103 0134 	add.w	r1, r3, #52	; 0x34
 801d2aa:	683b      	ldr	r3, [r7, #0]
 801d2ac:	b29b      	uxth	r3, r3
 801d2ae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d2b2:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d2b6:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d2ba:	f103 0302 	add.w	r3, r3, #2
 801d2be:	18cb      	adds	r3, r1, r3
 801d2c0:	781b      	ldrb	r3, [r3, #0]
 801d2c2:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801d2c6:	431a      	orrs	r2, r3
 801d2c8:	687b      	ldr	r3, [r7, #4]
 801d2ca:	f103 0134 	add.w	r1, r3, #52	; 0x34
 801d2ce:	683b      	ldr	r3, [r7, #0]
 801d2d0:	b29b      	uxth	r3, r3
 801d2d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d2d6:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d2da:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d2de:	f103 0301 	add.w	r3, r3, #1
 801d2e2:	18cb      	adds	r3, r1, r3
 801d2e4:	781b      	ldrb	r3, [r3, #0]
 801d2e6:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801d2ea:	431a      	orrs	r2, r3
 801d2ec:	687b      	ldr	r3, [r7, #4]
 801d2ee:	f103 0134 	add.w	r1, r3, #52	; 0x34
 801d2f2:	683b      	ldr	r3, [r7, #0]
 801d2f4:	b29b      	uxth	r3, r3
 801d2f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d2fa:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d2fe:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d302:	18cb      	adds	r3, r1, r3
 801d304:	781b      	ldrb	r3, [r3, #0]
 801d306:	4313      	orrs	r3, r2
 801d308:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 801d30c:	e008      	b.n	801d320 <get_fat+0x1e8>

	fsect = fs->fatbase;
	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = clst; bc += bc / 2;
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 801d30e:	bf00      	nop
 801d310:	e004      	b.n	801d31c <get_fat+0x1e4>
		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 801d312:	bf00      	nop
 801d314:	e002      	b.n	801d31c <get_fat+0x1e4>
		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
 801d316:	bf00      	nop
 801d318:	e000      	b.n	801d31c <get_fat+0x1e4>
		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);

	case FS_FAT32 :
		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
 801d31a:	bf00      	nop
		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occured at the disk I/O layer */
 801d31c:	f04f 33ff 	mov.w	r3, #4294967295
}
 801d320:	4618      	mov	r0, r3
 801d322:	f107 0718 	add.w	r7, r7, #24
 801d326:	46bd      	mov	sp, r7
 801d328:	bd80      	pop	{r7, pc}
 801d32a:	bf00      	nop

0801d32c <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->max_clust - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
 801d32c:	b580      	push	{r7, lr}
 801d32e:	b088      	sub	sp, #32
 801d330:	af00      	add	r7, sp, #0
 801d332:	60f8      	str	r0, [r7, #12]
 801d334:	60b9      	str	r1, [r7, #8]
 801d336:	607a      	str	r2, [r7, #4]
	BYTE *p;
	DWORD fsect;
	FRESULT res;


	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
 801d338:	68bb      	ldr	r3, [r7, #8]
 801d33a:	2b01      	cmp	r3, #1
 801d33c:	d904      	bls.n	801d348 <put_fat+0x1c>
 801d33e:	68fb      	ldr	r3, [r7, #12]
 801d340:	6a1a      	ldr	r2, [r3, #32]
 801d342:	68bb      	ldr	r3, [r7, #8]
 801d344:	429a      	cmp	r2, r3
 801d346:	d803      	bhi.n	801d350 <put_fat+0x24>
		res = FR_INT_ERR;
 801d348:	f04f 0302 	mov.w	r3, #2
 801d34c:	77fb      	strb	r3, [r7, #31]
 801d34e:	e121      	b.n	801d594 <put_fat+0x268>

	} else {
		fsect = fs->fatbase;
 801d350:	68fb      	ldr	r3, [r7, #12]
 801d352:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d354:	61bb      	str	r3, [r7, #24]
		switch (fs->fs_type) {
 801d356:	68fb      	ldr	r3, [r7, #12]
 801d358:	781b      	ldrb	r3, [r3, #0]
 801d35a:	2b02      	cmp	r3, #2
 801d35c:	d07e      	beq.n	801d45c <put_fat+0x130>
 801d35e:	2b03      	cmp	r3, #3
 801d360:	f000 80b0 	beq.w	801d4c4 <put_fat+0x198>
 801d364:	2b01      	cmp	r3, #1
 801d366:	f040 8106 	bne.w	801d576 <put_fat+0x24a>
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
 801d36a:	68bb      	ldr	r3, [r7, #8]
 801d36c:	617b      	str	r3, [r7, #20]
 801d36e:	697b      	ldr	r3, [r7, #20]
 801d370:	ea4f 0353 	mov.w	r3, r3, lsr #1
 801d374:	697a      	ldr	r2, [r7, #20]
 801d376:	18d3      	adds	r3, r2, r3
 801d378:	617b      	str	r3, [r7, #20]
			res = move_window(fs, fsect + (bc / SS(fs)));
 801d37a:	697b      	ldr	r3, [r7, #20]
 801d37c:	ea4f 2253 	mov.w	r2, r3, lsr #9
 801d380:	69bb      	ldr	r3, [r7, #24]
 801d382:	18d3      	adds	r3, r2, r3
 801d384:	68f8      	ldr	r0, [r7, #12]
 801d386:	4619      	mov	r1, r3
 801d388:	f7ff fdac 	bl	801cee4 <move_window>
 801d38c:	4603      	mov	r3, r0
 801d38e:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 801d390:	7ffb      	ldrb	r3, [r7, #31]
 801d392:	2b00      	cmp	r3, #0
 801d394:	f040 80f3 	bne.w	801d57e <put_fat+0x252>
			p = &fs->win[bc & (SS(fs) - 1)];
 801d398:	68fb      	ldr	r3, [r7, #12]
 801d39a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d39e:	697b      	ldr	r3, [r7, #20]
 801d3a0:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d3a4:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d3a8:	18d3      	adds	r3, r2, r3
 801d3aa:	613b      	str	r3, [r7, #16]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 801d3ac:	68bb      	ldr	r3, [r7, #8]
 801d3ae:	f003 0301 	and.w	r3, r3, #1
 801d3b2:	b2db      	uxtb	r3, r3
 801d3b4:	2b00      	cmp	r3, #0
 801d3b6:	d00e      	beq.n	801d3d6 <put_fat+0xaa>
 801d3b8:	693b      	ldr	r3, [r7, #16]
 801d3ba:	781b      	ldrb	r3, [r3, #0]
 801d3bc:	b2db      	uxtb	r3, r3
 801d3be:	f003 030f 	and.w	r3, r3, #15
 801d3c2:	b2da      	uxtb	r2, r3
 801d3c4:	687b      	ldr	r3, [r7, #4]
 801d3c6:	b2db      	uxtb	r3, r3
 801d3c8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 801d3cc:	b2db      	uxtb	r3, r3
 801d3ce:	4313      	orrs	r3, r2
 801d3d0:	b2db      	uxtb	r3, r3
 801d3d2:	b2db      	uxtb	r3, r3
 801d3d4:	e001      	b.n	801d3da <put_fat+0xae>
 801d3d6:	687b      	ldr	r3, [r7, #4]
 801d3d8:	b2db      	uxtb	r3, r3
 801d3da:	693a      	ldr	r2, [r7, #16]
 801d3dc:	7013      	strb	r3, [r2, #0]
			bc++;
 801d3de:	697b      	ldr	r3, [r7, #20]
 801d3e0:	f103 0301 	add.w	r3, r3, #1
 801d3e4:	617b      	str	r3, [r7, #20]
			fs->wflag = 1;
 801d3e6:	68fb      	ldr	r3, [r7, #12]
 801d3e8:	f04f 0201 	mov.w	r2, #1
 801d3ec:	711a      	strb	r2, [r3, #4]
			res = move_window(fs, fsect + (bc / SS(fs)));
 801d3ee:	697b      	ldr	r3, [r7, #20]
 801d3f0:	ea4f 2253 	mov.w	r2, r3, lsr #9
 801d3f4:	69bb      	ldr	r3, [r7, #24]
 801d3f6:	18d3      	adds	r3, r2, r3
 801d3f8:	68f8      	ldr	r0, [r7, #12]
 801d3fa:	4619      	mov	r1, r3
 801d3fc:	f7ff fd72 	bl	801cee4 <move_window>
 801d400:	4603      	mov	r3, r0
 801d402:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 801d404:	7ffb      	ldrb	r3, [r7, #31]
 801d406:	2b00      	cmp	r3, #0
 801d408:	f040 80bb 	bne.w	801d582 <put_fat+0x256>
			p = &fs->win[bc & (SS(fs) - 1)];
 801d40c:	68fb      	ldr	r3, [r7, #12]
 801d40e:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d412:	697b      	ldr	r3, [r7, #20]
 801d414:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d418:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d41c:	18d3      	adds	r3, r2, r3
 801d41e:	613b      	str	r3, [r7, #16]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 801d420:	68bb      	ldr	r3, [r7, #8]
 801d422:	f003 0301 	and.w	r3, r3, #1
 801d426:	b2db      	uxtb	r3, r3
 801d428:	2b00      	cmp	r3, #0
 801d42a:	d004      	beq.n	801d436 <put_fat+0x10a>
 801d42c:	687b      	ldr	r3, [r7, #4]
 801d42e:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801d432:	b2db      	uxtb	r3, r3
 801d434:	e00f      	b.n	801d456 <put_fat+0x12a>
 801d436:	693b      	ldr	r3, [r7, #16]
 801d438:	781b      	ldrb	r3, [r3, #0]
 801d43a:	b2db      	uxtb	r3, r3
 801d43c:	f023 030f 	bic.w	r3, r3, #15
 801d440:	b2da      	uxtb	r2, r3
 801d442:	687b      	ldr	r3, [r7, #4]
 801d444:	ea4f 2313 	mov.w	r3, r3, lsr #8
 801d448:	b2db      	uxtb	r3, r3
 801d44a:	f003 030f 	and.w	r3, r3, #15
 801d44e:	b2db      	uxtb	r3, r3
 801d450:	4313      	orrs	r3, r2
 801d452:	b2db      	uxtb	r3, r3
 801d454:	b2db      	uxtb	r3, r3
 801d456:	693a      	ldr	r2, [r7, #16]
 801d458:	7013      	strb	r3, [r2, #0]
			break;
 801d45a:	e097      	b.n	801d58c <put_fat+0x260>

		case FS_FAT16 :
			res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
 801d45c:	68bb      	ldr	r3, [r7, #8]
 801d45e:	ea4f 2213 	mov.w	r2, r3, lsr #8
 801d462:	69bb      	ldr	r3, [r7, #24]
 801d464:	18d3      	adds	r3, r2, r3
 801d466:	68f8      	ldr	r0, [r7, #12]
 801d468:	4619      	mov	r1, r3
 801d46a:	f7ff fd3b 	bl	801cee4 <move_window>
 801d46e:	4603      	mov	r3, r0
 801d470:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 801d472:	7ffb      	ldrb	r3, [r7, #31]
 801d474:	2b00      	cmp	r3, #0
 801d476:	f040 8086 	bne.w	801d586 <put_fat+0x25a>
			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
 801d47a:	68fb      	ldr	r3, [r7, #12]
 801d47c:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d480:	68bb      	ldr	r3, [r7, #8]
 801d482:	b29b      	uxth	r3, r3
 801d484:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801d488:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d48c:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d490:	18d3      	adds	r3, r2, r3
 801d492:	687a      	ldr	r2, [r7, #4]
 801d494:	b2d2      	uxtb	r2, r2
 801d496:	701a      	strb	r2, [r3, #0]
 801d498:	68fb      	ldr	r3, [r7, #12]
 801d49a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d49e:	68bb      	ldr	r3, [r7, #8]
 801d4a0:	b29b      	uxth	r3, r3
 801d4a2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801d4a6:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d4aa:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d4ae:	f103 0301 	add.w	r3, r3, #1
 801d4b2:	18d3      	adds	r3, r2, r3
 801d4b4:	687a      	ldr	r2, [r7, #4]
 801d4b6:	b292      	uxth	r2, r2
 801d4b8:	ea4f 2212 	mov.w	r2, r2, lsr #8
 801d4bc:	b292      	uxth	r2, r2
 801d4be:	b2d2      	uxtb	r2, r2
 801d4c0:	701a      	strb	r2, [r3, #0]
			break;
 801d4c2:	e063      	b.n	801d58c <put_fat+0x260>

		case FS_FAT32 :
			res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
 801d4c4:	68bb      	ldr	r3, [r7, #8]
 801d4c6:	ea4f 12d3 	mov.w	r2, r3, lsr #7
 801d4ca:	69bb      	ldr	r3, [r7, #24]
 801d4cc:	18d3      	adds	r3, r2, r3
 801d4ce:	68f8      	ldr	r0, [r7, #12]
 801d4d0:	4619      	mov	r1, r3
 801d4d2:	f7ff fd07 	bl	801cee4 <move_window>
 801d4d6:	4603      	mov	r3, r0
 801d4d8:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 801d4da:	7ffb      	ldrb	r3, [r7, #31]
 801d4dc:	2b00      	cmp	r3, #0
 801d4de:	d154      	bne.n	801d58a <put_fat+0x25e>
			ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
 801d4e0:	68fb      	ldr	r3, [r7, #12]
 801d4e2:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d4e6:	68bb      	ldr	r3, [r7, #8]
 801d4e8:	b29b      	uxth	r3, r3
 801d4ea:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d4ee:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d4f2:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d4f6:	18d3      	adds	r3, r2, r3
 801d4f8:	687a      	ldr	r2, [r7, #4]
 801d4fa:	b2d2      	uxtb	r2, r2
 801d4fc:	701a      	strb	r2, [r3, #0]
 801d4fe:	68fb      	ldr	r3, [r7, #12]
 801d500:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d504:	68bb      	ldr	r3, [r7, #8]
 801d506:	b29b      	uxth	r3, r3
 801d508:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d50c:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d510:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d514:	f103 0301 	add.w	r3, r3, #1
 801d518:	18d3      	adds	r3, r2, r3
 801d51a:	687a      	ldr	r2, [r7, #4]
 801d51c:	b292      	uxth	r2, r2
 801d51e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 801d522:	b292      	uxth	r2, r2
 801d524:	b2d2      	uxtb	r2, r2
 801d526:	701a      	strb	r2, [r3, #0]
 801d528:	68fb      	ldr	r3, [r7, #12]
 801d52a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d52e:	68bb      	ldr	r3, [r7, #8]
 801d530:	b29b      	uxth	r3, r3
 801d532:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d536:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d53a:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d53e:	f103 0302 	add.w	r3, r3, #2
 801d542:	18d3      	adds	r3, r2, r3
 801d544:	687a      	ldr	r2, [r7, #4]
 801d546:	ea4f 4212 	mov.w	r2, r2, lsr #16
 801d54a:	b2d2      	uxtb	r2, r2
 801d54c:	701a      	strb	r2, [r3, #0]
 801d54e:	68fb      	ldr	r3, [r7, #12]
 801d550:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d554:	68bb      	ldr	r3, [r7, #8]
 801d556:	b29b      	uxth	r3, r3
 801d558:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d55c:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801d560:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801d564:	f103 0303 	add.w	r3, r3, #3
 801d568:	18d3      	adds	r3, r2, r3
 801d56a:	687a      	ldr	r2, [r7, #4]
 801d56c:	ea4f 6212 	mov.w	r2, r2, lsr #24
 801d570:	b2d2      	uxtb	r2, r2
 801d572:	701a      	strb	r2, [r3, #0]
			break;
 801d574:	e00a      	b.n	801d58c <put_fat+0x260>

		default :
			res = FR_INT_ERR;
 801d576:	f04f 0302 	mov.w	r3, #2
 801d57a:	77fb      	strb	r3, [r7, #31]
			break;
 801d57c:	e006      	b.n	801d58c <put_fat+0x260>
		fsect = fs->fatbase;
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fsect + (bc / SS(fs)));
			if (res != FR_OK) break;
 801d57e:	bf00      	nop
 801d580:	e004      	b.n	801d58c <put_fat+0x260>
			p = &fs->win[bc & (SS(fs) - 1)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fsect + (bc / SS(fs)));
			if (res != FR_OK) break;
 801d582:	bf00      	nop
 801d584:	e002      	b.n	801d58c <put_fat+0x260>
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
			break;

		case FS_FAT16 :
			res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
 801d586:	bf00      	nop
 801d588:	e000      	b.n	801d58c <put_fat+0x260>
			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
			break;

		case FS_FAT32 :
			res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
			if (res != FR_OK) break;
 801d58a:	bf00      	nop

		default :
			res = FR_INT_ERR;
			break;
		}
		fs->wflag = 1;
 801d58c:	68fb      	ldr	r3, [r7, #12]
 801d58e:	f04f 0201 	mov.w	r2, #1
 801d592:	711a      	strb	r2, [r3, #4]
	}

	return res;
 801d594:	7ffb      	ldrb	r3, [r7, #31]
}
 801d596:	4618      	mov	r0, r3
 801d598:	f107 0720 	add.w	r7, r7, #32
 801d59c:	46bd      	mov	sp, r7
 801d59e:	bd80      	pop	{r7, pc}

0801d5a0 <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 801d5a0:	b580      	push	{r7, lr}
 801d5a2:	b084      	sub	sp, #16
 801d5a4:	af00      	add	r7, sp, #0
 801d5a6:	6078      	str	r0, [r7, #4]
 801d5a8:	6039      	str	r1, [r7, #0]
	FRESULT res;
	DWORD nxt;


	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
 801d5aa:	683b      	ldr	r3, [r7, #0]
 801d5ac:	2b01      	cmp	r3, #1
 801d5ae:	d904      	bls.n	801d5ba <remove_chain+0x1a>
 801d5b0:	687b      	ldr	r3, [r7, #4]
 801d5b2:	6a1a      	ldr	r2, [r3, #32]
 801d5b4:	683b      	ldr	r3, [r7, #0]
 801d5b6:	429a      	cmp	r2, r3
 801d5b8:	d803      	bhi.n	801d5c2 <remove_chain+0x22>
		res = FR_INT_ERR;
 801d5ba:	f04f 0302 	mov.w	r3, #2
 801d5be:	73fb      	strb	r3, [r7, #15]
 801d5c0:	e040      	b.n	801d644 <remove_chain+0xa4>

	} else {
		res = FR_OK;
 801d5c2:	f04f 0300 	mov.w	r3, #0
 801d5c6:	73fb      	strb	r3, [r7, #15]
		while (clst < fs->max_clust) {			/* Not a last link? */
 801d5c8:	e033      	b.n	801d632 <remove_chain+0x92>
			nxt = get_fat(fs, clst);			/* Get cluster status */
 801d5ca:	6878      	ldr	r0, [r7, #4]
 801d5cc:	6839      	ldr	r1, [r7, #0]
 801d5ce:	f7ff fdb3 	bl	801d138 <get_fat>
 801d5d2:	4603      	mov	r3, r0
 801d5d4:	60bb      	str	r3, [r7, #8]
			if (nxt == 0) break;				/* Empty cluster? */
 801d5d6:	68bb      	ldr	r3, [r7, #8]
 801d5d8:	2b00      	cmp	r3, #0
 801d5da:	d030      	beq.n	801d63e <remove_chain+0x9e>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 801d5dc:	68bb      	ldr	r3, [r7, #8]
 801d5de:	2b01      	cmp	r3, #1
 801d5e0:	d103      	bne.n	801d5ea <remove_chain+0x4a>
 801d5e2:	f04f 0302 	mov.w	r3, #2
 801d5e6:	73fb      	strb	r3, [r7, #15]
 801d5e8:	e02c      	b.n	801d644 <remove_chain+0xa4>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 801d5ea:	68bb      	ldr	r3, [r7, #8]
 801d5ec:	f1b3 3fff 	cmp.w	r3, #4294967295
 801d5f0:	d103      	bne.n	801d5fa <remove_chain+0x5a>
 801d5f2:	f04f 0301 	mov.w	r3, #1
 801d5f6:	73fb      	strb	r3, [r7, #15]
 801d5f8:	e024      	b.n	801d644 <remove_chain+0xa4>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 801d5fa:	6878      	ldr	r0, [r7, #4]
 801d5fc:	6839      	ldr	r1, [r7, #0]
 801d5fe:	f04f 0200 	mov.w	r2, #0
 801d602:	f7ff fe93 	bl	801d32c <put_fat>
 801d606:	4603      	mov	r3, r0
 801d608:	73fb      	strb	r3, [r7, #15]
			if (res != FR_OK) break;
 801d60a:	7bfb      	ldrb	r3, [r7, #15]
 801d60c:	2b00      	cmp	r3, #0
 801d60e:	d118      	bne.n	801d642 <remove_chain+0xa2>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 801d610:	687b      	ldr	r3, [r7, #4]
 801d612:	691b      	ldr	r3, [r3, #16]
 801d614:	f1b3 3fff 	cmp.w	r3, #4294967295
 801d618:	d009      	beq.n	801d62e <remove_chain+0x8e>
				fs->free_clust++;
 801d61a:	687b      	ldr	r3, [r7, #4]
 801d61c:	691b      	ldr	r3, [r3, #16]
 801d61e:	f103 0201 	add.w	r2, r3, #1
 801d622:	687b      	ldr	r3, [r7, #4]
 801d624:	611a      	str	r2, [r3, #16]
				fs->fsi_flag = 1;
 801d626:	687b      	ldr	r3, [r7, #4]
 801d628:	f04f 0201 	mov.w	r2, #1
 801d62c:	729a      	strb	r2, [r3, #10]
			}
			clst = nxt;	/* Next cluster */
 801d62e:	68bb      	ldr	r3, [r7, #8]
 801d630:	603b      	str	r3, [r7, #0]
	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->max_clust) {			/* Not a last link? */
 801d632:	687b      	ldr	r3, [r7, #4]
 801d634:	6a1a      	ldr	r2, [r3, #32]
 801d636:	683b      	ldr	r3, [r7, #0]
 801d638:	429a      	cmp	r2, r3
 801d63a:	d8c6      	bhi.n	801d5ca <remove_chain+0x2a>
 801d63c:	e002      	b.n	801d644 <remove_chain+0xa4>
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
 801d63e:	bf00      	nop
 801d640:	e000      	b.n	801d644 <remove_chain+0xa4>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
 801d642:	bf00      	nop
			}
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
 801d644:	7bfb      	ldrb	r3, [r7, #15]
}
 801d646:	4618      	mov	r0, r3
 801d648:	f107 0710 	add.w	r7, r7, #16
 801d64c:	46bd      	mov	sp, r7
 801d64e:	bd80      	pop	{r7, pc}

0801d650 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
 801d650:	b580      	push	{r7, lr}
 801d652:	b086      	sub	sp, #24
 801d654:	af00      	add	r7, sp, #0
 801d656:	6078      	str	r0, [r7, #4]
 801d658:	6039      	str	r1, [r7, #0]
	DWORD cs, ncl, scl, mcl;


	mcl = fs->max_clust;
 801d65a:	687b      	ldr	r3, [r7, #4]
 801d65c:	6a1b      	ldr	r3, [r3, #32]
 801d65e:	60fb      	str	r3, [r7, #12]
	if (clst == 0) {		/* Create new chain */
 801d660:	683b      	ldr	r3, [r7, #0]
 801d662:	2b00      	cmp	r3, #0
 801d664:	d10d      	bne.n	801d682 <create_chain+0x32>
		scl = fs->last_clust;			/* Get suggested start point */
 801d666:	687b      	ldr	r3, [r7, #4]
 801d668:	68db      	ldr	r3, [r3, #12]
 801d66a:	613b      	str	r3, [r7, #16]
		if (scl == 0 || scl >= mcl) scl = 1;
 801d66c:	693b      	ldr	r3, [r7, #16]
 801d66e:	2b00      	cmp	r3, #0
 801d670:	d003      	beq.n	801d67a <create_chain+0x2a>
 801d672:	693a      	ldr	r2, [r7, #16]
 801d674:	68fb      	ldr	r3, [r7, #12]
 801d676:	429a      	cmp	r2, r3
 801d678:	d317      	bcc.n	801d6aa <create_chain+0x5a>
 801d67a:	f04f 0301 	mov.w	r3, #1
 801d67e:	613b      	str	r3, [r7, #16]
 801d680:	e013      	b.n	801d6aa <create_chain+0x5a>
	}
	else {					/* Stretch existing chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
 801d682:	6878      	ldr	r0, [r7, #4]
 801d684:	6839      	ldr	r1, [r7, #0]
 801d686:	f7ff fd57 	bl	801d138 <get_fat>
 801d68a:	4603      	mov	r3, r0
 801d68c:	60bb      	str	r3, [r7, #8]
		if (cs < 2) return 1;			/* It is an invalid cluster */
 801d68e:	68bb      	ldr	r3, [r7, #8]
 801d690:	2b01      	cmp	r3, #1
 801d692:	d802      	bhi.n	801d69a <create_chain+0x4a>
 801d694:	f04f 0301 	mov.w	r3, #1
 801d698:	e064      	b.n	801d764 <create_chain+0x114>
		if (cs < mcl) return cs;		/* It is already followed by next cluster */
 801d69a:	68ba      	ldr	r2, [r7, #8]
 801d69c:	68fb      	ldr	r3, [r7, #12]
 801d69e:	429a      	cmp	r2, r3
 801d6a0:	d201      	bcs.n	801d6a6 <create_chain+0x56>
 801d6a2:	68bb      	ldr	r3, [r7, #8]
 801d6a4:	e05e      	b.n	801d764 <create_chain+0x114>
		scl = clst;
 801d6a6:	683b      	ldr	r3, [r7, #0]
 801d6a8:	613b      	str	r3, [r7, #16]
	}

	ncl = scl;				/* Start cluster */
 801d6aa:	693b      	ldr	r3, [r7, #16]
 801d6ac:	617b      	str	r3, [r7, #20]
 801d6ae:	e000      	b.n	801d6b2 <create_chain+0x62>
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
			return cs;
		if (ncl == scl) return 0;		/* No free custer */
	}
 801d6b0:	bf00      	nop
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
 801d6b2:	697b      	ldr	r3, [r7, #20]
 801d6b4:	f103 0301 	add.w	r3, r3, #1
 801d6b8:	617b      	str	r3, [r7, #20]
		if (ncl >= mcl) {				/* Wrap around */
 801d6ba:	697a      	ldr	r2, [r7, #20]
 801d6bc:	68fb      	ldr	r3, [r7, #12]
 801d6be:	429a      	cmp	r2, r3
 801d6c0:	d309      	bcc.n	801d6d6 <create_chain+0x86>
			ncl = 2;
 801d6c2:	f04f 0302 	mov.w	r3, #2
 801d6c6:	617b      	str	r3, [r7, #20]
			if (ncl > scl) return 0;	/* No free custer */
 801d6c8:	697a      	ldr	r2, [r7, #20]
 801d6ca:	693b      	ldr	r3, [r7, #16]
 801d6cc:	429a      	cmp	r2, r3
 801d6ce:	d902      	bls.n	801d6d6 <create_chain+0x86>
 801d6d0:	f04f 0300 	mov.w	r3, #0
 801d6d4:	e046      	b.n	801d764 <create_chain+0x114>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
 801d6d6:	6878      	ldr	r0, [r7, #4]
 801d6d8:	6979      	ldr	r1, [r7, #20]
 801d6da:	f7ff fd2d 	bl	801d138 <get_fat>
 801d6de:	4603      	mov	r3, r0
 801d6e0:	60bb      	str	r3, [r7, #8]
		if (cs == 0) break;				/* Found a free cluster */
 801d6e2:	68bb      	ldr	r3, [r7, #8]
 801d6e4:	2b00      	cmp	r3, #0
 801d6e6:	d00f      	beq.n	801d708 <create_chain+0xb8>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
 801d6e8:	68bb      	ldr	r3, [r7, #8]
 801d6ea:	f1b3 3fff 	cmp.w	r3, #4294967295
 801d6ee:	d002      	beq.n	801d6f6 <create_chain+0xa6>
 801d6f0:	68bb      	ldr	r3, [r7, #8]
 801d6f2:	2b01      	cmp	r3, #1
 801d6f4:	d101      	bne.n	801d6fa <create_chain+0xaa>
			return cs;
 801d6f6:	68bb      	ldr	r3, [r7, #8]
 801d6f8:	e034      	b.n	801d764 <create_chain+0x114>
		if (ncl == scl) return 0;		/* No free custer */
 801d6fa:	697a      	ldr	r2, [r7, #20]
 801d6fc:	693b      	ldr	r3, [r7, #16]
 801d6fe:	429a      	cmp	r2, r3
 801d700:	d1d6      	bne.n	801d6b0 <create_chain+0x60>
 801d702:	f04f 0300 	mov.w	r3, #0
 801d706:	e02d      	b.n	801d764 <create_chain+0x114>
		if (ncl >= mcl) {				/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free custer */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
 801d708:	bf00      	nop
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
			return cs;
		if (ncl == scl) return 0;		/* No free custer */
	}

	if (put_fat(fs, ncl, 0x0FFFFFFF))	/* Mark the new cluster "in use" */
 801d70a:	6878      	ldr	r0, [r7, #4]
 801d70c:	6979      	ldr	r1, [r7, #20]
 801d70e:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 801d712:	f7ff fe0b 	bl	801d32c <put_fat>
 801d716:	4603      	mov	r3, r0
 801d718:	2b00      	cmp	r3, #0
 801d71a:	d002      	beq.n	801d722 <create_chain+0xd2>
		return 0xFFFFFFFF;
 801d71c:	f04f 33ff 	mov.w	r3, #4294967295
 801d720:	e020      	b.n	801d764 <create_chain+0x114>
	if (clst != 0) {					/* Link it to the previous one if needed */
 801d722:	683b      	ldr	r3, [r7, #0]
 801d724:	2b00      	cmp	r3, #0
 801d726:	d00a      	beq.n	801d73e <create_chain+0xee>
		if (put_fat(fs, clst, ncl))
 801d728:	6878      	ldr	r0, [r7, #4]
 801d72a:	6839      	ldr	r1, [r7, #0]
 801d72c:	697a      	ldr	r2, [r7, #20]
 801d72e:	f7ff fdfd 	bl	801d32c <put_fat>
 801d732:	4603      	mov	r3, r0
 801d734:	2b00      	cmp	r3, #0
 801d736:	d002      	beq.n	801d73e <create_chain+0xee>
			return 0xFFFFFFFF;
 801d738:	f04f 33ff 	mov.w	r3, #4294967295
 801d73c:	e012      	b.n	801d764 <create_chain+0x114>
	}

	fs->last_clust = ncl;				/* Update FSINFO */
 801d73e:	687b      	ldr	r3, [r7, #4]
 801d740:	697a      	ldr	r2, [r7, #20]
 801d742:	60da      	str	r2, [r3, #12]
	if (fs->free_clust != 0xFFFFFFFF) {
 801d744:	687b      	ldr	r3, [r7, #4]
 801d746:	691b      	ldr	r3, [r3, #16]
 801d748:	f1b3 3fff 	cmp.w	r3, #4294967295
 801d74c:	d009      	beq.n	801d762 <create_chain+0x112>
		fs->free_clust--;
 801d74e:	687b      	ldr	r3, [r7, #4]
 801d750:	691b      	ldr	r3, [r3, #16]
 801d752:	f103 32ff 	add.w	r2, r3, #4294967295
 801d756:	687b      	ldr	r3, [r7, #4]
 801d758:	611a      	str	r2, [r3, #16]
		fs->fsi_flag = 1;
 801d75a:	687b      	ldr	r3, [r7, #4]
 801d75c:	f04f 0201 	mov.w	r2, #1
 801d760:	729a      	strb	r2, [r3, #10]
	}

	return ncl;		/* Return new cluster number */
 801d762:	697b      	ldr	r3, [r7, #20]
}
 801d764:	4618      	mov	r0, r3
 801d766:	f107 0718 	add.w	r7, r7, #24
 801d76a:	46bd      	mov	sp, r7
 801d76c:	bd80      	pop	{r7, pc}
 801d76e:	bf00      	nop

0801d770 <clust2sect>:
static
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
 801d770:	b480      	push	{r7}
 801d772:	b083      	sub	sp, #12
 801d774:	af00      	add	r7, sp, #0
 801d776:	6078      	str	r0, [r7, #4]
 801d778:	6039      	str	r1, [r7, #0]
	clst -= 2;
 801d77a:	683b      	ldr	r3, [r7, #0]
 801d77c:	f1a3 0302 	sub.w	r3, r3, #2
 801d780:	603b      	str	r3, [r7, #0]
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
 801d782:	687b      	ldr	r3, [r7, #4]
 801d784:	6a1b      	ldr	r3, [r3, #32]
 801d786:	f1a3 0202 	sub.w	r2, r3, #2
 801d78a:	683b      	ldr	r3, [r7, #0]
 801d78c:	429a      	cmp	r2, r3
 801d78e:	d802      	bhi.n	801d796 <clust2sect+0x26>
 801d790:	f04f 0300 	mov.w	r3, #0
 801d794:	e007      	b.n	801d7a6 <clust2sect+0x36>
	return clst * fs->csize + fs->database;
 801d796:	687b      	ldr	r3, [r7, #4]
 801d798:	789b      	ldrb	r3, [r3, #2]
 801d79a:	683a      	ldr	r2, [r7, #0]
 801d79c:	fb02 f203 	mul.w	r2, r2, r3
 801d7a0:	687b      	ldr	r3, [r7, #4]
 801d7a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d7a4:	18d3      	adds	r3, r2, r3
}
 801d7a6:	4618      	mov	r0, r3
 801d7a8:	f107 070c 	add.w	r7, r7, #12
 801d7ac:	46bd      	mov	sp, r7
 801d7ae:	bc80      	pop	{r7}
 801d7b0:	4770      	bx	lr
 801d7b2:	bf00      	nop

0801d7b4 <dir_seek>:
static
FRESULT dir_seek (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
 801d7b4:	b580      	push	{r7, lr}
 801d7b6:	b084      	sub	sp, #16
 801d7b8:	af00      	add	r7, sp, #0
 801d7ba:	6078      	str	r0, [r7, #4]
 801d7bc:	460b      	mov	r3, r1
 801d7be:	807b      	strh	r3, [r7, #2]
	DWORD clst;
	WORD ic;


	dj->index = idx;
 801d7c0:	687b      	ldr	r3, [r7, #4]
 801d7c2:	887a      	ldrh	r2, [r7, #2]
 801d7c4:	80da      	strh	r2, [r3, #6]
	clst = dj->sclust;
 801d7c6:	687b      	ldr	r3, [r7, #4]
 801d7c8:	689b      	ldr	r3, [r3, #8]
 801d7ca:	60fb      	str	r3, [r7, #12]
	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
 801d7cc:	68fb      	ldr	r3, [r7, #12]
 801d7ce:	2b01      	cmp	r3, #1
 801d7d0:	d005      	beq.n	801d7de <dir_seek+0x2a>
 801d7d2:	687b      	ldr	r3, [r7, #4]
 801d7d4:	681b      	ldr	r3, [r3, #0]
 801d7d6:	6a1a      	ldr	r2, [r3, #32]
 801d7d8:	68fb      	ldr	r3, [r7, #12]
 801d7da:	429a      	cmp	r2, r3
 801d7dc:	d802      	bhi.n	801d7e4 <dir_seek+0x30>
		return FR_INT_ERR;
 801d7de:	f04f 0302 	mov.w	r3, #2
 801d7e2:	e06e      	b.n	801d8c2 <dir_seek+0x10e>
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 801d7e4:	68fb      	ldr	r3, [r7, #12]
 801d7e6:	2b00      	cmp	r3, #0
 801d7e8:	d108      	bne.n	801d7fc <dir_seek+0x48>
 801d7ea:	687b      	ldr	r3, [r7, #4]
 801d7ec:	681b      	ldr	r3, [r3, #0]
 801d7ee:	781b      	ldrb	r3, [r3, #0]
 801d7f0:	2b03      	cmp	r3, #3
 801d7f2:	d103      	bne.n	801d7fc <dir_seek+0x48>
		clst = dj->fs->dirbase;
 801d7f4:	687b      	ldr	r3, [r7, #4]
 801d7f6:	681b      	ldr	r3, [r3, #0]
 801d7f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801d7fa:	60fb      	str	r3, [r7, #12]

	if (clst == 0) {	/* Static table */
 801d7fc:	68fb      	ldr	r3, [r7, #12]
 801d7fe:	2b00      	cmp	r3, #0
 801d800:	d116      	bne.n	801d830 <dir_seek+0x7c>
		dj->clust = clst;
 801d802:	687b      	ldr	r3, [r7, #4]
 801d804:	68fa      	ldr	r2, [r7, #12]
 801d806:	60da      	str	r2, [r3, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 801d808:	687b      	ldr	r3, [r7, #4]
 801d80a:	681b      	ldr	r3, [r3, #0]
 801d80c:	891b      	ldrh	r3, [r3, #8]
 801d80e:	887a      	ldrh	r2, [r7, #2]
 801d810:	429a      	cmp	r2, r3
 801d812:	d302      	bcc.n	801d81a <dir_seek+0x66>
			return FR_INT_ERR;
 801d814:	f04f 0302 	mov.w	r3, #2
 801d818:	e053      	b.n	801d8c2 <dir_seek+0x10e>
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
 801d81a:	687b      	ldr	r3, [r7, #4]
 801d81c:	681b      	ldr	r3, [r3, #0]
 801d81e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801d820:	887b      	ldrh	r3, [r7, #2]
 801d822:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801d826:	b29b      	uxth	r3, r3
 801d828:	18d2      	adds	r2, r2, r3
 801d82a:	687b      	ldr	r3, [r7, #4]
 801d82c:	611a      	str	r2, [r3, #16]
 801d82e:	e03a      	b.n	801d8a6 <dir_seek+0xf2>
	}
	else {				/* Dynamic table */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
 801d830:	687b      	ldr	r3, [r7, #4]
 801d832:	681b      	ldr	r3, [r3, #0]
 801d834:	789b      	ldrb	r3, [r3, #2]
 801d836:	ea4f 1303 	mov.w	r3, r3, lsl #4
 801d83a:	817b      	strh	r3, [r7, #10]
		while (idx >= ic) {	/* Follow cluster chain */
 801d83c:	e01e      	b.n	801d87c <dir_seek+0xc8>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 801d83e:	687b      	ldr	r3, [r7, #4]
 801d840:	681b      	ldr	r3, [r3, #0]
 801d842:	4618      	mov	r0, r3
 801d844:	68f9      	ldr	r1, [r7, #12]
 801d846:	f7ff fc77 	bl	801d138 <get_fat>
 801d84a:	4603      	mov	r3, r0
 801d84c:	60fb      	str	r3, [r7, #12]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 801d84e:	68fb      	ldr	r3, [r7, #12]
 801d850:	f1b3 3fff 	cmp.w	r3, #4294967295
 801d854:	d102      	bne.n	801d85c <dir_seek+0xa8>
 801d856:	f04f 0301 	mov.w	r3, #1
 801d85a:	e032      	b.n	801d8c2 <dir_seek+0x10e>
			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
 801d85c:	68fb      	ldr	r3, [r7, #12]
 801d85e:	2b01      	cmp	r3, #1
 801d860:	d905      	bls.n	801d86e <dir_seek+0xba>
 801d862:	687b      	ldr	r3, [r7, #4]
 801d864:	681b      	ldr	r3, [r3, #0]
 801d866:	6a1a      	ldr	r2, [r3, #32]
 801d868:	68fb      	ldr	r3, [r7, #12]
 801d86a:	429a      	cmp	r2, r3
 801d86c:	d802      	bhi.n	801d874 <dir_seek+0xc0>
				return FR_INT_ERR;
 801d86e:	f04f 0302 	mov.w	r3, #2
 801d872:	e026      	b.n	801d8c2 <dir_seek+0x10e>
			idx -= ic;
 801d874:	887a      	ldrh	r2, [r7, #2]
 801d876:	897b      	ldrh	r3, [r7, #10]
 801d878:	1ad3      	subs	r3, r2, r3
 801d87a:	807b      	strh	r3, [r7, #2]
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
	}
	else {				/* Dynamic table */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
 801d87c:	887a      	ldrh	r2, [r7, #2]
 801d87e:	897b      	ldrh	r3, [r7, #10]
 801d880:	429a      	cmp	r2, r3
 801d882:	d2dc      	bcs.n	801d83e <dir_seek+0x8a>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
 801d884:	687b      	ldr	r3, [r7, #4]
 801d886:	68fa      	ldr	r2, [r7, #12]
 801d888:	60da      	str	r2, [r3, #12]
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
 801d88a:	687b      	ldr	r3, [r7, #4]
 801d88c:	681b      	ldr	r3, [r3, #0]
 801d88e:	4618      	mov	r0, r3
 801d890:	68f9      	ldr	r1, [r7, #12]
 801d892:	f7ff ff6d 	bl	801d770 <clust2sect>
 801d896:	4602      	mov	r2, r0
 801d898:	887b      	ldrh	r3, [r7, #2]
 801d89a:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801d89e:	b29b      	uxth	r3, r3
 801d8a0:	18d2      	adds	r2, r2, r3
 801d8a2:	687b      	ldr	r3, [r7, #4]
 801d8a4:	611a      	str	r2, [r3, #16]
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */
 801d8a6:	687b      	ldr	r3, [r7, #4]
 801d8a8:	681b      	ldr	r3, [r3, #0]
 801d8aa:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801d8ae:	887b      	ldrh	r3, [r7, #2]
 801d8b0:	f003 030f 	and.w	r3, r3, #15
 801d8b4:	ea4f 1343 	mov.w	r3, r3, lsl #5
 801d8b8:	18d2      	adds	r2, r2, r3
 801d8ba:	687b      	ldr	r3, [r7, #4]
 801d8bc:	615a      	str	r2, [r3, #20]

	return FR_OK;	/* Seek succeeded */
 801d8be:	f04f 0300 	mov.w	r3, #0
}
 801d8c2:	4618      	mov	r0, r3
 801d8c4:	f107 0710 	add.w	r7, r7, #16
 801d8c8:	46bd      	mov	sp, r7
 801d8ca:	bd80      	pop	{r7, pc}

0801d8cc <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
	DIR *dj,		/* Pointer to directory object */
	BOOL streach	/* FALSE: Do not streach table, TRUE: Streach table if needed */
)
{
 801d8cc:	b590      	push	{r4, r7, lr}
 801d8ce:	b085      	sub	sp, #20
 801d8d0:	af00      	add	r7, sp, #0
 801d8d2:	6078      	str	r0, [r7, #4]
 801d8d4:	460b      	mov	r3, r1
 801d8d6:	70fb      	strb	r3, [r7, #3]
	DWORD clst;
	WORD i;


	i = dj->index + 1;
 801d8d8:	687b      	ldr	r3, [r7, #4]
 801d8da:	88db      	ldrh	r3, [r3, #6]
 801d8dc:	f103 0301 	add.w	r3, r3, #1
 801d8e0:	813b      	strh	r3, [r7, #8]
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 801d8e2:	893b      	ldrh	r3, [r7, #8]
 801d8e4:	2b00      	cmp	r3, #0
 801d8e6:	d003      	beq.n	801d8f0 <dir_next+0x24>
 801d8e8:	687b      	ldr	r3, [r7, #4]
 801d8ea:	691b      	ldr	r3, [r3, #16]
 801d8ec:	2b00      	cmp	r3, #0
 801d8ee:	d102      	bne.n	801d8f6 <dir_next+0x2a>
		return FR_NO_FILE;
 801d8f0:	f04f 0304 	mov.w	r3, #4
 801d8f4:	e0d6      	b.n	801daa4 <dir_next+0x1d8>

	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
 801d8f6:	893b      	ldrh	r3, [r7, #8]
 801d8f8:	f003 030f 	and.w	r3, r3, #15
 801d8fc:	b29b      	uxth	r3, r3
 801d8fe:	2b00      	cmp	r3, #0
 801d900:	f040 80bf 	bne.w	801da82 <dir_next+0x1b6>
		dj->sect++;					/* Next sector */
 801d904:	687b      	ldr	r3, [r7, #4]
 801d906:	691b      	ldr	r3, [r3, #16]
 801d908:	f103 0201 	add.w	r2, r3, #1
 801d90c:	687b      	ldr	r3, [r7, #4]
 801d90e:	611a      	str	r2, [r3, #16]

		if (dj->clust == 0) {	/* Static table */
 801d910:	687b      	ldr	r3, [r7, #4]
 801d912:	68db      	ldr	r3, [r3, #12]
 801d914:	2b00      	cmp	r3, #0
 801d916:	d109      	bne.n	801d92c <dir_next+0x60>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 801d918:	687b      	ldr	r3, [r7, #4]
 801d91a:	681b      	ldr	r3, [r3, #0]
 801d91c:	891b      	ldrh	r3, [r3, #8]
 801d91e:	893a      	ldrh	r2, [r7, #8]
 801d920:	429a      	cmp	r2, r3
 801d922:	f0c0 80ae 	bcc.w	801da82 <dir_next+0x1b6>
				return FR_NO_FILE;
 801d926:	f04f 0304 	mov.w	r3, #4
 801d92a:	e0bb      	b.n	801daa4 <dir_next+0x1d8>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 801d92c:	893b      	ldrh	r3, [r7, #8]
 801d92e:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801d932:	b29b      	uxth	r3, r3
 801d934:	461a      	mov	r2, r3
 801d936:	687b      	ldr	r3, [r7, #4]
 801d938:	681b      	ldr	r3, [r3, #0]
 801d93a:	789b      	ldrb	r3, [r3, #2]
 801d93c:	f103 33ff 	add.w	r3, r3, #4294967295
 801d940:	4013      	ands	r3, r2
 801d942:	2b00      	cmp	r3, #0
 801d944:	f040 809d 	bne.w	801da82 <dir_next+0x1b6>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 801d948:	687b      	ldr	r3, [r7, #4]
 801d94a:	681a      	ldr	r2, [r3, #0]
 801d94c:	687b      	ldr	r3, [r7, #4]
 801d94e:	68db      	ldr	r3, [r3, #12]
 801d950:	4610      	mov	r0, r2
 801d952:	4619      	mov	r1, r3
 801d954:	f7ff fbf0 	bl	801d138 <get_fat>
 801d958:	4603      	mov	r3, r0
 801d95a:	60fb      	str	r3, [r7, #12]
				if (clst <= 1) return FR_INT_ERR;
 801d95c:	68fb      	ldr	r3, [r7, #12]
 801d95e:	2b01      	cmp	r3, #1
 801d960:	d802      	bhi.n	801d968 <dir_next+0x9c>
 801d962:	f04f 0302 	mov.w	r3, #2
 801d966:	e09d      	b.n	801daa4 <dir_next+0x1d8>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 801d968:	68fb      	ldr	r3, [r7, #12]
 801d96a:	f1b3 3fff 	cmp.w	r3, #4294967295
 801d96e:	d102      	bne.n	801d976 <dir_next+0xaa>
 801d970:	f04f 0301 	mov.w	r3, #1
 801d974:	e096      	b.n	801daa4 <dir_next+0x1d8>
				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
 801d976:	687b      	ldr	r3, [r7, #4]
 801d978:	681b      	ldr	r3, [r3, #0]
 801d97a:	6a1a      	ldr	r2, [r3, #32]
 801d97c:	68fb      	ldr	r3, [r7, #12]
 801d97e:	429a      	cmp	r2, r3
 801d980:	d873      	bhi.n	801da6a <dir_next+0x19e>
#if !_FS_READONLY
					BYTE c;
					if (!streach) return FR_NO_FILE;			/* When do not streach, report EOT */
 801d982:	f997 3003 	ldrsb.w	r3, [r7, #3]
 801d986:	2b00      	cmp	r3, #0
 801d988:	d102      	bne.n	801d990 <dir_next+0xc4>
 801d98a:	f04f 0304 	mov.w	r3, #4
 801d98e:	e089      	b.n	801daa4 <dir_next+0x1d8>
					clst = create_chain(dj->fs, dj->clust);		/* Streach cluster chain */
 801d990:	687b      	ldr	r3, [r7, #4]
 801d992:	681a      	ldr	r2, [r3, #0]
 801d994:	687b      	ldr	r3, [r7, #4]
 801d996:	68db      	ldr	r3, [r3, #12]
 801d998:	4610      	mov	r0, r2
 801d99a:	4619      	mov	r1, r3
 801d99c:	f7ff fe58 	bl	801d650 <create_chain>
 801d9a0:	4603      	mov	r3, r0
 801d9a2:	60fb      	str	r3, [r7, #12]
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 801d9a4:	68fb      	ldr	r3, [r7, #12]
 801d9a6:	2b00      	cmp	r3, #0
 801d9a8:	d102      	bne.n	801d9b0 <dir_next+0xe4>
 801d9aa:	f04f 0307 	mov.w	r3, #7
 801d9ae:	e079      	b.n	801daa4 <dir_next+0x1d8>
					if (clst == 1) return FR_INT_ERR;
 801d9b0:	68fb      	ldr	r3, [r7, #12]
 801d9b2:	2b01      	cmp	r3, #1
 801d9b4:	d102      	bne.n	801d9bc <dir_next+0xf0>
 801d9b6:	f04f 0302 	mov.w	r3, #2
 801d9ba:	e073      	b.n	801daa4 <dir_next+0x1d8>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 801d9bc:	68fb      	ldr	r3, [r7, #12]
 801d9be:	f1b3 3fff 	cmp.w	r3, #4294967295
 801d9c2:	d102      	bne.n	801d9ca <dir_next+0xfe>
 801d9c4:	f04f 0301 	mov.w	r3, #1
 801d9c8:	e06c      	b.n	801daa4 <dir_next+0x1d8>
					/* Clean-up streached table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
 801d9ca:	687b      	ldr	r3, [r7, #4]
 801d9cc:	681b      	ldr	r3, [r3, #0]
 801d9ce:	4618      	mov	r0, r3
 801d9d0:	f04f 0100 	mov.w	r1, #0
 801d9d4:	f7ff fa86 	bl	801cee4 <move_window>
 801d9d8:	4603      	mov	r3, r0
 801d9da:	2b00      	cmp	r3, #0
 801d9dc:	d002      	beq.n	801d9e4 <dir_next+0x118>
 801d9de:	f04f 0301 	mov.w	r3, #1
 801d9e2:	e05f      	b.n	801daa4 <dir_next+0x1d8>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 801d9e4:	687b      	ldr	r3, [r7, #4]
 801d9e6:	681b      	ldr	r3, [r3, #0]
 801d9e8:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801d9ec:	4618      	mov	r0, r3
 801d9ee:	f04f 0100 	mov.w	r1, #0
 801d9f2:	f44f 7200 	mov.w	r2, #512	; 0x200
 801d9f6:	f7ff f9ff 	bl	801cdf8 <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 801d9fa:	687b      	ldr	r3, [r7, #4]
 801d9fc:	681c      	ldr	r4, [r3, #0]
 801d9fe:	687b      	ldr	r3, [r7, #4]
 801da00:	681b      	ldr	r3, [r3, #0]
 801da02:	4618      	mov	r0, r3
 801da04:	68f9      	ldr	r1, [r7, #12]
 801da06:	f7ff feb3 	bl	801d770 <clust2sect>
 801da0a:	4603      	mov	r3, r0
 801da0c:	6323      	str	r3, [r4, #48]	; 0x30
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 801da0e:	f04f 0300 	mov.w	r3, #0
 801da12:	72fb      	strb	r3, [r7, #11]
 801da14:	e01b      	b.n	801da4e <dir_next+0x182>
						dj->fs->wflag = 1;
 801da16:	687b      	ldr	r3, [r7, #4]
 801da18:	681b      	ldr	r3, [r3, #0]
 801da1a:	f04f 0201 	mov.w	r2, #1
 801da1e:	711a      	strb	r2, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
 801da20:	687b      	ldr	r3, [r7, #4]
 801da22:	681b      	ldr	r3, [r3, #0]
 801da24:	4618      	mov	r0, r3
 801da26:	f04f 0100 	mov.w	r1, #0
 801da2a:	f7ff fa5b 	bl	801cee4 <move_window>
 801da2e:	4603      	mov	r3, r0
 801da30:	2b00      	cmp	r3, #0
 801da32:	d002      	beq.n	801da3a <dir_next+0x16e>
 801da34:	f04f 0301 	mov.w	r3, #1
 801da38:	e034      	b.n	801daa4 <dir_next+0x1d8>
						dj->fs->winsect++;
 801da3a:	687b      	ldr	r3, [r7, #4]
 801da3c:	681b      	ldr	r3, [r3, #0]
 801da3e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801da40:	f102 0201 	add.w	r2, r2, #1
 801da44:	631a      	str	r2, [r3, #48]	; 0x30
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up streached table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 801da46:	7afb      	ldrb	r3, [r7, #11]
 801da48:	f103 0301 	add.w	r3, r3, #1
 801da4c:	72fb      	strb	r3, [r7, #11]
 801da4e:	687b      	ldr	r3, [r7, #4]
 801da50:	681b      	ldr	r3, [r3, #0]
 801da52:	789b      	ldrb	r3, [r3, #2]
 801da54:	7afa      	ldrb	r2, [r7, #11]
 801da56:	429a      	cmp	r2, r3
 801da58:	d3dd      	bcc.n	801da16 <dir_next+0x14a>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
 801da5a:	687b      	ldr	r3, [r7, #4]
 801da5c:	681b      	ldr	r3, [r3, #0]
 801da5e:	687a      	ldr	r2, [r7, #4]
 801da60:	6812      	ldr	r2, [r2, #0]
 801da62:	6b11      	ldr	r1, [r2, #48]	; 0x30
 801da64:	7afa      	ldrb	r2, [r7, #11]
 801da66:	1a8a      	subs	r2, r1, r2
 801da68:	631a      	str	r2, [r3, #48]	; 0x30
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
 801da6a:	687b      	ldr	r3, [r7, #4]
 801da6c:	68fa      	ldr	r2, [r7, #12]
 801da6e:	60da      	str	r2, [r3, #12]
				dj->sect = clust2sect(dj->fs, clst);
 801da70:	687b      	ldr	r3, [r7, #4]
 801da72:	681b      	ldr	r3, [r3, #0]
 801da74:	4618      	mov	r0, r3
 801da76:	68f9      	ldr	r1, [r7, #12]
 801da78:	f7ff fe7a 	bl	801d770 <clust2sect>
 801da7c:	4602      	mov	r2, r0
 801da7e:	687b      	ldr	r3, [r7, #4]
 801da80:	611a      	str	r2, [r3, #16]
			}
		}
	}

	dj->index = i;
 801da82:	687b      	ldr	r3, [r7, #4]
 801da84:	893a      	ldrh	r2, [r7, #8]
 801da86:	80da      	strh	r2, [r3, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
 801da88:	687b      	ldr	r3, [r7, #4]
 801da8a:	681b      	ldr	r3, [r3, #0]
 801da8c:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801da90:	893b      	ldrh	r3, [r7, #8]
 801da92:	f003 030f 	and.w	r3, r3, #15
 801da96:	ea4f 1343 	mov.w	r3, r3, lsl #5
 801da9a:	18d2      	adds	r2, r2, r3
 801da9c:	687b      	ldr	r3, [r7, #4]
 801da9e:	615a      	str	r2, [r3, #20]

	return FR_OK;
 801daa0:	f04f 0300 	mov.w	r3, #0
}
 801daa4:	4618      	mov	r0, r3
 801daa6:	f107 0714 	add.w	r7, r7, #20
 801daaa:	46bd      	mov	sp, r7
 801daac:	bd90      	pop	{r4, r7, pc}
 801daae:	bf00      	nop

0801dab0 <dir_find>:

static
FRESULT dir_find (
	DIR *dj			/* Pointer to the directory object linked to the file name */
)
{
 801dab0:	b580      	push	{r7, lr}
 801dab2:	b086      	sub	sp, #24
 801dab4:	af00      	add	r7, sp, #0
 801dab6:	6078      	str	r0, [r7, #4]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, lfen, ord, sum;
#endif

	res = dir_seek(dj, 0);			/* Rewind directory object */
 801dab8:	6878      	ldr	r0, [r7, #4]
 801daba:	f04f 0100 	mov.w	r1, #0
 801dabe:	f7ff fe79 	bl	801d7b4 <dir_seek>
 801dac2:	4603      	mov	r3, r0
 801dac4:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) return res;
 801dac6:	7dfb      	ldrb	r3, [r7, #23]
 801dac8:	2b00      	cmp	r3, #0
 801daca:	d001      	beq.n	801dad0 <dir_find+0x20>
 801dacc:	7dfb      	ldrb	r3, [r7, #23]
 801dace:	e03b      	b.n	801db48 <dir_find+0x98>

#if _USE_LFN
	ord = sum = 0xFF; lfen = *(dj->fn+11) & NS_LOSS;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
 801dad0:	687b      	ldr	r3, [r7, #4]
 801dad2:	681a      	ldr	r2, [r3, #0]
 801dad4:	687b      	ldr	r3, [r7, #4]
 801dad6:	691b      	ldr	r3, [r3, #16]
 801dad8:	4610      	mov	r0, r2
 801dada:	4619      	mov	r1, r3
 801dadc:	f7ff fa02 	bl	801cee4 <move_window>
 801dae0:	4603      	mov	r3, r0
 801dae2:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 801dae4:	7dfb      	ldrb	r3, [r7, #23]
 801dae6:	2b00      	cmp	r3, #0
 801dae8:	d12a      	bne.n	801db40 <dir_find+0x90>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 801daea:	687b      	ldr	r3, [r7, #4]
 801daec:	695b      	ldr	r3, [r3, #20]
 801daee:	613b      	str	r3, [r7, #16]
		c = dir[DIR_Name];
 801daf0:	693b      	ldr	r3, [r7, #16]
 801daf2:	781b      	ldrb	r3, [r3, #0]
 801daf4:	73fb      	strb	r3, [r7, #15]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 801daf6:	7bfb      	ldrb	r3, [r7, #15]
 801daf8:	2b00      	cmp	r3, #0
 801dafa:	d103      	bne.n	801db04 <dir_find+0x54>
 801dafc:	f04f 0304 	mov.w	r3, #4
 801db00:	75fb      	strb	r3, [r7, #23]
 801db02:	e020      	b.n	801db46 <dir_find+0x96>
				}
				ord = 0xFF;
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 801db04:	693b      	ldr	r3, [r7, #16]
 801db06:	f103 030b 	add.w	r3, r3, #11
 801db0a:	781b      	ldrb	r3, [r3, #0]
 801db0c:	f003 0308 	and.w	r3, r3, #8
 801db10:	2b00      	cmp	r3, #0
 801db12:	d10a      	bne.n	801db2a <dir_find+0x7a>
 801db14:	687b      	ldr	r3, [r7, #4]
 801db16:	699b      	ldr	r3, [r3, #24]
 801db18:	6938      	ldr	r0, [r7, #16]
 801db1a:	4619      	mov	r1, r3
 801db1c:	f04f 020b 	mov.w	r2, #11
 801db20:	f7ff f98c 	bl	801ce3c <mem_cmp>
 801db24:	4603      	mov	r3, r0
 801db26:	2b00      	cmp	r3, #0
 801db28:	d00c      	beq.n	801db44 <dir_find+0x94>
			break;
#endif
		res = dir_next(dj, FALSE);				/* Next entry */
 801db2a:	6878      	ldr	r0, [r7, #4]
 801db2c:	f04f 0100 	mov.w	r1, #0
 801db30:	f7ff fecc 	bl	801d8cc <dir_next>
 801db34:	4603      	mov	r3, r0
 801db36:	75fb      	strb	r3, [r7, #23]
	} while (res == FR_OK);
 801db38:	7dfb      	ldrb	r3, [r7, #23]
 801db3a:	2b00      	cmp	r3, #0
 801db3c:	d0c8      	beq.n	801dad0 <dir_find+0x20>
 801db3e:	e002      	b.n	801db46 <dir_find+0x96>
#if _USE_LFN
	ord = sum = 0xFF; lfen = *(dj->fn+11) & NS_LOSS;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
 801db40:	bf00      	nop
 801db42:	e000      	b.n	801db46 <dir_find+0x96>
				ord = 0xFF;
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
 801db44:	bf00      	nop
#endif
		res = dir_next(dj, FALSE);				/* Next entry */
	} while (res == FR_OK);

	return res;
 801db46:	7dfb      	ldrb	r3, [r7, #23]
}
 801db48:	4618      	mov	r0, r3
 801db4a:	f107 0718 	add.w	r7, r7, #24
 801db4e:	46bd      	mov	sp, r7
 801db50:	bd80      	pop	{r7, pc}
 801db52:	bf00      	nop

0801db54 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
 801db54:	b580      	push	{r7, lr}
 801db56:	b086      	sub	sp, #24
 801db58:	af00      	add	r7, sp, #0
 801db5a:	6078      	str	r0, [r7, #4]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
 801db5c:	f04f 0304 	mov.w	r3, #4
 801db60:	75fb      	strb	r3, [r7, #23]
	while (dj->sect) {
 801db62:	e02e      	b.n	801dbc2 <dir_read+0x6e>
		res = move_window(dj->fs, dj->sect);
 801db64:	687b      	ldr	r3, [r7, #4]
 801db66:	681a      	ldr	r2, [r3, #0]
 801db68:	687b      	ldr	r3, [r7, #4]
 801db6a:	691b      	ldr	r3, [r3, #16]
 801db6c:	4610      	mov	r0, r2
 801db6e:	4619      	mov	r1, r3
 801db70:	f7ff f9b8 	bl	801cee4 <move_window>
 801db74:	4603      	mov	r3, r0
 801db76:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 801db78:	7dfb      	ldrb	r3, [r7, #23]
 801db7a:	2b00      	cmp	r3, #0
 801db7c:	d126      	bne.n	801dbcc <dir_read+0x78>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 801db7e:	687b      	ldr	r3, [r7, #4]
 801db80:	695b      	ldr	r3, [r3, #20]
 801db82:	613b      	str	r3, [r7, #16]
		c = dir[DIR_Name];
 801db84:	693b      	ldr	r3, [r7, #16]
 801db86:	781b      	ldrb	r3, [r3, #0]
 801db88:	73fb      	strb	r3, [r7, #15]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 801db8a:	7bfb      	ldrb	r3, [r7, #15]
 801db8c:	2b00      	cmp	r3, #0
 801db8e:	d103      	bne.n	801db98 <dir_read+0x44>
 801db90:	f04f 0304 	mov.w	r3, #4
 801db94:	75fb      	strb	r3, [r7, #23]
 801db96:	e01e      	b.n	801dbd6 <dir_read+0x82>
					dj->lfn_idx = 0xFFFF;		/* No LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != 0xE5 && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
 801db98:	7bfb      	ldrb	r3, [r7, #15]
 801db9a:	2be5      	cmp	r3, #229	; 0xe5
 801db9c:	d007      	beq.n	801dbae <dir_read+0x5a>
 801db9e:	693b      	ldr	r3, [r7, #16]
 801dba0:	f103 030b 	add.w	r3, r3, #11
 801dba4:	781b      	ldrb	r3, [r3, #0]
 801dba6:	f003 0308 	and.w	r3, r3, #8
 801dbaa:	2b00      	cmp	r3, #0
 801dbac:	d010      	beq.n	801dbd0 <dir_read+0x7c>
			break;
#endif
		res = dir_next(dj, FALSE);				/* Next entry */
 801dbae:	6878      	ldr	r0, [r7, #4]
 801dbb0:	f04f 0100 	mov.w	r1, #0
 801dbb4:	f7ff fe8a 	bl	801d8cc <dir_next>
 801dbb8:	4603      	mov	r3, r0
 801dbba:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 801dbbc:	7dfb      	ldrb	r3, [r7, #23]
 801dbbe:	2b00      	cmp	r3, #0
 801dbc0:	d108      	bne.n	801dbd4 <dir_read+0x80>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
 801dbc2:	687b      	ldr	r3, [r7, #4]
 801dbc4:	691b      	ldr	r3, [r3, #16]
 801dbc6:	2b00      	cmp	r3, #0
 801dbc8:	d1cc      	bne.n	801db64 <dir_read+0x10>
 801dbca:	e004      	b.n	801dbd6 <dir_read+0x82>
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
 801dbcc:	bf00      	nop
 801dbce:	e002      	b.n	801dbd6 <dir_read+0x82>
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != 0xE5 && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
			break;
 801dbd0:	bf00      	nop
 801dbd2:	e000      	b.n	801dbd6 <dir_read+0x82>
#endif
		res = dir_next(dj, FALSE);				/* Next entry */
		if (res != FR_OK) break;
 801dbd4:	bf00      	nop
	}

	if (res != FR_OK) dj->sect = 0;
 801dbd6:	7dfb      	ldrb	r3, [r7, #23]
 801dbd8:	2b00      	cmp	r3, #0
 801dbda:	d003      	beq.n	801dbe4 <dir_read+0x90>
 801dbdc:	687b      	ldr	r3, [r7, #4]
 801dbde:	f04f 0200 	mov.w	r2, #0
 801dbe2:	611a      	str	r2, [r3, #16]

	return res;
 801dbe4:	7dfb      	ldrb	r3, [r7, #23]
}
 801dbe6:	4618      	mov	r0, r3
 801dbe8:	f107 0718 	add.w	r7, r7, #24
 801dbec:	46bd      	mov	sp, r7
 801dbee:	bd80      	pop	{r7, pc}

0801dbf0 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
 801dbf0:	b580      	push	{r7, lr}
 801dbf2:	b084      	sub	sp, #16
 801dbf4:	af00      	add	r7, sp, #0
 801dbf6:	6078      	str	r0, [r7, #4]
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_seek(dj, 0);
 801dbf8:	6878      	ldr	r0, [r7, #4]
 801dbfa:	f04f 0100 	mov.w	r1, #0
 801dbfe:	f7ff fdd9 	bl	801d7b4 <dir_seek>
 801dc02:	4603      	mov	r3, r0
 801dc04:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 801dc06:	7bfb      	ldrb	r3, [r7, #15]
 801dc08:	2b00      	cmp	r3, #0
 801dc0a:	d122      	bne.n	801dc52 <dir_register+0x62>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
 801dc0c:	687b      	ldr	r3, [r7, #4]
 801dc0e:	681a      	ldr	r2, [r3, #0]
 801dc10:	687b      	ldr	r3, [r7, #4]
 801dc12:	691b      	ldr	r3, [r3, #16]
 801dc14:	4610      	mov	r0, r2
 801dc16:	4619      	mov	r1, r3
 801dc18:	f7ff f964 	bl	801cee4 <move_window>
 801dc1c:	4603      	mov	r3, r0
 801dc1e:	73fb      	strb	r3, [r7, #15]
			if (res != FR_OK) break;
 801dc20:	7bfb      	ldrb	r3, [r7, #15]
 801dc22:	2b00      	cmp	r3, #0
 801dc24:	d114      	bne.n	801dc50 <dir_register+0x60>
			c = *dj->dir;
 801dc26:	687b      	ldr	r3, [r7, #4]
 801dc28:	695b      	ldr	r3, [r3, #20]
 801dc2a:	781b      	ldrb	r3, [r3, #0]
 801dc2c:	73bb      	strb	r3, [r7, #14]
			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
 801dc2e:	7bbb      	ldrb	r3, [r7, #14]
 801dc30:	2be5      	cmp	r3, #229	; 0xe5
 801dc32:	d00e      	beq.n	801dc52 <dir_register+0x62>
 801dc34:	7bbb      	ldrb	r3, [r7, #14]
 801dc36:	2b00      	cmp	r3, #0
 801dc38:	d00b      	beq.n	801dc52 <dir_register+0x62>
			res = dir_next(dj, TRUE);		/* Next entry with table streach */
 801dc3a:	6878      	ldr	r0, [r7, #4]
 801dc3c:	f04f 0101 	mov.w	r1, #1
 801dc40:	f7ff fe44 	bl	801d8cc <dir_next>
 801dc44:	4603      	mov	r3, r0
 801dc46:	73fb      	strb	r3, [r7, #15]
		} while (res == FR_OK);
 801dc48:	7bfb      	ldrb	r3, [r7, #15]
 801dc4a:	2b00      	cmp	r3, #0
 801dc4c:	d0de      	beq.n	801dc0c <dir_register+0x1c>
 801dc4e:	e000      	b.n	801dc52 <dir_register+0x62>
#else	/* Non LFN configuration */
	res = dir_seek(dj, 0);
	if (res == FR_OK) {
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
			if (res != FR_OK) break;
 801dc50:	bf00      	nop
			res = dir_next(dj, TRUE);		/* Next entry with table streach */
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
 801dc52:	7bfb      	ldrb	r3, [r7, #15]
 801dc54:	2b00      	cmp	r3, #0
 801dc56:	d12f      	bne.n	801dcb8 <dir_register+0xc8>
		res = move_window(dj->fs, dj->sect);
 801dc58:	687b      	ldr	r3, [r7, #4]
 801dc5a:	681a      	ldr	r2, [r3, #0]
 801dc5c:	687b      	ldr	r3, [r7, #4]
 801dc5e:	691b      	ldr	r3, [r3, #16]
 801dc60:	4610      	mov	r0, r2
 801dc62:	4619      	mov	r1, r3
 801dc64:	f7ff f93e 	bl	801cee4 <move_window>
 801dc68:	4603      	mov	r3, r0
 801dc6a:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 801dc6c:	7bfb      	ldrb	r3, [r7, #15]
 801dc6e:	2b00      	cmp	r3, #0
 801dc70:	d122      	bne.n	801dcb8 <dir_register+0xc8>
			dir = dj->dir;
 801dc72:	687b      	ldr	r3, [r7, #4]
 801dc74:	695b      	ldr	r3, [r3, #20]
 801dc76:	60bb      	str	r3, [r7, #8]
			mem_set(dir, 0, 32);		/* Clean the entry */
 801dc78:	68b8      	ldr	r0, [r7, #8]
 801dc7a:	f04f 0100 	mov.w	r1, #0
 801dc7e:	f04f 0220 	mov.w	r2, #32
 801dc82:	f7ff f8b9 	bl	801cdf8 <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
 801dc86:	687b      	ldr	r3, [r7, #4]
 801dc88:	699b      	ldr	r3, [r3, #24]
 801dc8a:	68b8      	ldr	r0, [r7, #8]
 801dc8c:	4619      	mov	r1, r3
 801dc8e:	f04f 020b 	mov.w	r2, #11
 801dc92:	f7ff f889 	bl	801cda8 <mem_cpy>
			dir[DIR_NTres] = *(dj->fn+11) & 0x18;	/* Put NT flag */
 801dc96:	68bb      	ldr	r3, [r7, #8]
 801dc98:	f103 030c 	add.w	r3, r3, #12
 801dc9c:	687a      	ldr	r2, [r7, #4]
 801dc9e:	6992      	ldr	r2, [r2, #24]
 801dca0:	f102 020b 	add.w	r2, r2, #11
 801dca4:	7812      	ldrb	r2, [r2, #0]
 801dca6:	f002 0218 	and.w	r2, r2, #24
 801dcaa:	b2d2      	uxtb	r2, r2
 801dcac:	701a      	strb	r2, [r3, #0]
			dj->fs->wflag = 1;
 801dcae:	687b      	ldr	r3, [r7, #4]
 801dcb0:	681b      	ldr	r3, [r3, #0]
 801dcb2:	f04f 0201 	mov.w	r2, #1
 801dcb6:	711a      	strb	r2, [r3, #4]
		}
	}

	return res;
 801dcb8:	7bfb      	ldrb	r3, [r7, #15]
}
 801dcba:	4618      	mov	r0, r3
 801dcbc:	f107 0710 	add.w	r7, r7, #16
 801dcc0:	46bd      	mov	sp, r7
 801dcc2:	bd80      	pop	{r7, pc}

0801dcc4 <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
 801dcc4:	b580      	push	{r7, lr}
 801dcc6:	b084      	sub	sp, #16
 801dcc8:	af00      	add	r7, sp, #0
 801dcca:	6078      	str	r0, [r7, #4]
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_seek(dj, dj->index);
 801dccc:	687b      	ldr	r3, [r7, #4]
 801dcce:	88db      	ldrh	r3, [r3, #6]
 801dcd0:	6878      	ldr	r0, [r7, #4]
 801dcd2:	4619      	mov	r1, r3
 801dcd4:	f7ff fd6e 	bl	801d7b4 <dir_seek>
 801dcd8:	4603      	mov	r3, r0
 801dcda:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 801dcdc:	7bfb      	ldrb	r3, [r7, #15]
 801dcde:	2b00      	cmp	r3, #0
 801dce0:	d116      	bne.n	801dd10 <dir_remove+0x4c>
		res = move_window(dj->fs, dj->sect);
 801dce2:	687b      	ldr	r3, [r7, #4]
 801dce4:	681a      	ldr	r2, [r3, #0]
 801dce6:	687b      	ldr	r3, [r7, #4]
 801dce8:	691b      	ldr	r3, [r3, #16]
 801dcea:	4610      	mov	r0, r2
 801dcec:	4619      	mov	r1, r3
 801dcee:	f7ff f8f9 	bl	801cee4 <move_window>
 801dcf2:	4603      	mov	r3, r0
 801dcf4:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 801dcf6:	7bfb      	ldrb	r3, [r7, #15]
 801dcf8:	2b00      	cmp	r3, #0
 801dcfa:	d109      	bne.n	801dd10 <dir_remove+0x4c>
			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
 801dcfc:	687b      	ldr	r3, [r7, #4]
 801dcfe:	695b      	ldr	r3, [r3, #20]
 801dd00:	f04f 02e5 	mov.w	r2, #229	; 0xe5
 801dd04:	701a      	strb	r2, [r3, #0]
			dj->fs->wflag = 1;
 801dd06:	687b      	ldr	r3, [r7, #4]
 801dd08:	681b      	ldr	r3, [r3, #0]
 801dd0a:	f04f 0201 	mov.w	r2, #1
 801dd0e:	711a      	strb	r2, [r3, #4]
		}
	}
#endif

	return res;
 801dd10:	7bfb      	ldrb	r3, [r7, #15]
}
 801dd12:	4618      	mov	r0, r3
 801dd14:	f107 0710 	add.w	r7, r7, #16
 801dd18:	46bd      	mov	sp, r7
 801dd1a:	bd80      	pop	{r7, pc}

0801dd1c <create_name>:
static
FRESULT create_name (
	DIR *dj,			/* Pointer to the directory object */
	const XCHAR **path	/* Pointer to pointer to the segment in the path string */
)
{
 801dd1c:	b580      	push	{r7, lr}
 801dd1e:	b088      	sub	sp, #32
 801dd20:	af00      	add	r7, sp, #0
 801dd22:	6078      	str	r0, [r7, #4]
 801dd24:	6039      	str	r1, [r7, #0]
	BYTE b, c, d, *sfn;
	int ni, si, i;
	const char *p;

	/* Create file name in directory form */
	sfn = dj->fn;
 801dd26:	687b      	ldr	r3, [r7, #4]
 801dd28:	699b      	ldr	r3, [r3, #24]
 801dd2a:	60fb      	str	r3, [r7, #12]
	mem_set(sfn, ' ', 11);
 801dd2c:	68f8      	ldr	r0, [r7, #12]
 801dd2e:	f04f 0120 	mov.w	r1, #32
 801dd32:	f04f 020b 	mov.w	r2, #11
 801dd36:	f7ff f85f 	bl	801cdf8 <mem_set>
	si = i = b = 0; ni = 8;
 801dd3a:	f04f 0300 	mov.w	r3, #0
 801dd3e:	77fb      	strb	r3, [r7, #31]
 801dd40:	f04f 0300 	mov.w	r3, #0
 801dd44:	613b      	str	r3, [r7, #16]
 801dd46:	693b      	ldr	r3, [r7, #16]
 801dd48:	617b      	str	r3, [r7, #20]
 801dd4a:	f04f 0308 	mov.w	r3, #8
 801dd4e:	61bb      	str	r3, [r7, #24]
	p = *path;
 801dd50:	683b      	ldr	r3, [r7, #0]
 801dd52:	681b      	ldr	r3, [r3, #0]
 801dd54:	60bb      	str	r3, [r7, #8]
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
 801dd56:	697b      	ldr	r3, [r7, #20]
 801dd58:	68ba      	ldr	r2, [r7, #8]
 801dd5a:	18d3      	adds	r3, r2, r3
 801dd5c:	781b      	ldrb	r3, [r3, #0]
 801dd5e:	2b2e      	cmp	r3, #46	; 0x2e
 801dd60:	d138      	bne.n	801ddd4 <create_name+0xb8>
		for (;;) {
			c = p[si++];
 801dd62:	697b      	ldr	r3, [r7, #20]
 801dd64:	68ba      	ldr	r2, [r7, #8]
 801dd66:	18d3      	adds	r3, r2, r3
 801dd68:	781b      	ldrb	r3, [r3, #0]
 801dd6a:	77bb      	strb	r3, [r7, #30]
 801dd6c:	697b      	ldr	r3, [r7, #20]
 801dd6e:	f103 0301 	add.w	r3, r3, #1
 801dd72:	617b      	str	r3, [r7, #20]
			if (c != '.' || si >= 3) break;
 801dd74:	7fbb      	ldrb	r3, [r7, #30]
 801dd76:	2b2e      	cmp	r3, #46	; 0x2e
 801dd78:	d10c      	bne.n	801dd94 <create_name+0x78>
 801dd7a:	697b      	ldr	r3, [r7, #20]
 801dd7c:	2b02      	cmp	r3, #2
 801dd7e:	dc09      	bgt.n	801dd94 <create_name+0x78>
			sfn[i++] = c;
 801dd80:	693b      	ldr	r3, [r7, #16]
 801dd82:	68fa      	ldr	r2, [r7, #12]
 801dd84:	18d3      	adds	r3, r2, r3
 801dd86:	7fba      	ldrb	r2, [r7, #30]
 801dd88:	701a      	strb	r2, [r3, #0]
 801dd8a:	693b      	ldr	r3, [r7, #16]
 801dd8c:	f103 0301 	add.w	r3, r3, #1
 801dd90:	613b      	str	r3, [r7, #16]
		}
 801dd92:	e7e6      	b.n	801dd62 <create_name+0x46>
		if (c != '/' && c != '\\' && c >= ' ') return FR_INVALID_NAME;
 801dd94:	7fbb      	ldrb	r3, [r7, #30]
 801dd96:	2b2f      	cmp	r3, #47	; 0x2f
 801dd98:	d008      	beq.n	801ddac <create_name+0x90>
 801dd9a:	7fbb      	ldrb	r3, [r7, #30]
 801dd9c:	2b5c      	cmp	r3, #92	; 0x5c
 801dd9e:	d005      	beq.n	801ddac <create_name+0x90>
 801dda0:	7fbb      	ldrb	r3, [r7, #30]
 801dda2:	2b1f      	cmp	r3, #31
 801dda4:	d902      	bls.n	801ddac <create_name+0x90>
 801dda6:	f04f 0306 	mov.w	r3, #6
 801ddaa:	e0b9      	b.n	801df20 <create_name+0x204>
		*path = &p[si];									/* Rerurn pointer to the next segment */
 801ddac:	697b      	ldr	r3, [r7, #20]
 801ddae:	68ba      	ldr	r2, [r7, #8]
 801ddb0:	18d2      	adds	r2, r2, r3
 801ddb2:	683b      	ldr	r3, [r7, #0]
 801ddb4:	601a      	str	r2, [r3, #0]
		sfn[11] = (c < ' ') ? NS_LAST|NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
 801ddb6:	68fb      	ldr	r3, [r7, #12]
 801ddb8:	f103 020b 	add.w	r2, r3, #11
 801ddbc:	7fbb      	ldrb	r3, [r7, #30]
 801ddbe:	2b1f      	cmp	r3, #31
 801ddc0:	d802      	bhi.n	801ddc8 <create_name+0xac>
 801ddc2:	f04f 0324 	mov.w	r3, #36	; 0x24
 801ddc6:	e001      	b.n	801ddcc <create_name+0xb0>
 801ddc8:	f04f 0320 	mov.w	r3, #32
 801ddcc:	7013      	strb	r3, [r2, #0]
		return FR_OK;
 801ddce:	f04f 0300 	mov.w	r3, #0
 801ddd2:	e0a5      	b.n	801df20 <create_name+0x204>
	}
#endif
	for (;;) {
		c = p[si++];
 801ddd4:	697b      	ldr	r3, [r7, #20]
 801ddd6:	68ba      	ldr	r2, [r7, #8]
 801ddd8:	18d3      	adds	r3, r2, r3
 801ddda:	781b      	ldrb	r3, [r3, #0]
 801dddc:	77bb      	strb	r3, [r7, #30]
 801ddde:	697b      	ldr	r3, [r7, #20]
 801dde0:	f103 0301 	add.w	r3, r3, #1
 801dde4:	617b      	str	r3, [r7, #20]
		if (c < ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 801dde6:	7fbb      	ldrb	r3, [r7, #30]
 801dde8:	2b1f      	cmp	r3, #31
 801ddea:	d95d      	bls.n	801dea8 <create_name+0x18c>
 801ddec:	7fbb      	ldrb	r3, [r7, #30]
 801ddee:	2b2f      	cmp	r3, #47	; 0x2f
 801ddf0:	d05a      	beq.n	801dea8 <create_name+0x18c>
 801ddf2:	7fbb      	ldrb	r3, [r7, #30]
 801ddf4:	2b5c      	cmp	r3, #92	; 0x5c
 801ddf6:	d057      	beq.n	801dea8 <create_name+0x18c>
		if (c == '.' || i >= ni) {
 801ddf8:	7fbb      	ldrb	r3, [r7, #30]
 801ddfa:	2b2e      	cmp	r3, #46	; 0x2e
 801ddfc:	d003      	beq.n	801de06 <create_name+0xea>
 801ddfe:	693a      	ldr	r2, [r7, #16]
 801de00:	69bb      	ldr	r3, [r7, #24]
 801de02:	429a      	cmp	r2, r3
 801de04:	db14      	blt.n	801de30 <create_name+0x114>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 801de06:	69bb      	ldr	r3, [r7, #24]
 801de08:	2b08      	cmp	r3, #8
 801de0a:	d102      	bne.n	801de12 <create_name+0xf6>
 801de0c:	7fbb      	ldrb	r3, [r7, #30]
 801de0e:	2b2e      	cmp	r3, #46	; 0x2e
 801de10:	d002      	beq.n	801de18 <create_name+0xfc>
 801de12:	f04f 0306 	mov.w	r3, #6
 801de16:	e083      	b.n	801df20 <create_name+0x204>
			i = 8; ni = 11;
 801de18:	f04f 0308 	mov.w	r3, #8
 801de1c:	613b      	str	r3, [r7, #16]
 801de1e:	f04f 030b 	mov.w	r3, #11
 801de22:	61bb      	str	r3, [r7, #24]
			b <<= 2; continue;
 801de24:	7ffb      	ldrb	r3, [r7, #31]
 801de26:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801de2a:	77fb      	strb	r3, [r7, #31]
 801de2c:	bf00      	nop
					b |= 1; c -= 0x20;
				}
			}
			sfn[i++] = c;
		}
	}
 801de2e:	e7d1      	b.n	801ddd4 <create_name+0xb8>
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char */
 801de30:	7fbb      	ldrb	r3, [r7, #30]
 801de32:	b25b      	sxtb	r3, r3
 801de34:	2b00      	cmp	r3, #0
 801de36:	da06      	bge.n	801de46 <create_name+0x12a>
#ifdef _EXCVT
			c = cvt[c - 0x80];			/* Convert extend char (SBCS) */
#else
			b |= 3;						/* Eliminate NT flag if ext char is exist */
 801de38:	7ffb      	ldrb	r3, [r7, #31]
 801de3a:	f043 0303 	orr.w	r3, r3, #3
 801de3e:	77fb      	strb	r3, [r7, #31]
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
 801de40:	f04f 0306 	mov.w	r3, #6
 801de44:	e06c      	b.n	801df20 <create_name+0x204>
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
			sfn[i++] = d;
		} else {
			if (chk_chr(" \"*+,[=]|\x7F", c))	/* Reject unallowable chrs for SFN */
 801de46:	7fbb      	ldrb	r3, [r7, #30]
 801de48:	f64b 3094 	movw	r0, #48020	; 0xbb94
 801de4c:	f6c0 0002 	movt	r0, #2050	; 0x802
 801de50:	4619      	mov	r1, r3
 801de52:	f7ff f82b 	bl	801ceac <chk_chr>
 801de56:	4603      	mov	r3, r0
 801de58:	2b00      	cmp	r3, #0
 801de5a:	d002      	beq.n	801de62 <create_name+0x146>
				return FR_INVALID_NAME;
 801de5c:	f04f 0306 	mov.w	r3, #6
 801de60:	e05e      	b.n	801df20 <create_name+0x204>
			if (IsUpper(c)) {
 801de62:	7fbb      	ldrb	r3, [r7, #30]
 801de64:	2b40      	cmp	r3, #64	; 0x40
 801de66:	d907      	bls.n	801de78 <create_name+0x15c>
 801de68:	7fbb      	ldrb	r3, [r7, #30]
 801de6a:	2b5a      	cmp	r3, #90	; 0x5a
 801de6c:	d804      	bhi.n	801de78 <create_name+0x15c>
				b |= 2;
 801de6e:	7ffb      	ldrb	r3, [r7, #31]
 801de70:	f043 0302 	orr.w	r3, r3, #2
 801de74:	77fb      	strb	r3, [r7, #31]
 801de76:	e00d      	b.n	801de94 <create_name+0x178>
			} else {
				if (IsLower(c)) {
 801de78:	7fbb      	ldrb	r3, [r7, #30]
 801de7a:	2b60      	cmp	r3, #96	; 0x60
 801de7c:	d90a      	bls.n	801de94 <create_name+0x178>
 801de7e:	7fbb      	ldrb	r3, [r7, #30]
 801de80:	2b7a      	cmp	r3, #122	; 0x7a
 801de82:	d807      	bhi.n	801de94 <create_name+0x178>
					b |= 1; c -= 0x20;
 801de84:	7ffb      	ldrb	r3, [r7, #31]
 801de86:	f043 0301 	orr.w	r3, r3, #1
 801de8a:	77fb      	strb	r3, [r7, #31]
 801de8c:	7fbb      	ldrb	r3, [r7, #30]
 801de8e:	f1a3 0320 	sub.w	r3, r3, #32
 801de92:	77bb      	strb	r3, [r7, #30]
				}
			}
			sfn[i++] = c;
 801de94:	693b      	ldr	r3, [r7, #16]
 801de96:	68fa      	ldr	r2, [r7, #12]
 801de98:	18d3      	adds	r3, r2, r3
 801de9a:	7fba      	ldrb	r2, [r7, #30]
 801de9c:	701a      	strb	r2, [r3, #0]
 801de9e:	693b      	ldr	r3, [r7, #16]
 801dea0:	f103 0301 	add.w	r3, r3, #1
 801dea4:	613b      	str	r3, [r7, #16]
		}
	}
 801dea6:	e795      	b.n	801ddd4 <create_name+0xb8>
	*path = &p[si];						/* Rerurn pointer to the next segment */
 801dea8:	697b      	ldr	r3, [r7, #20]
 801deaa:	68ba      	ldr	r2, [r7, #8]
 801deac:	18d2      	adds	r2, r2, r3
 801deae:	683b      	ldr	r3, [r7, #0]
 801deb0:	601a      	str	r2, [r3, #0]
	c = (c < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 801deb2:	7fbb      	ldrb	r3, [r7, #30]
 801deb4:	2b1f      	cmp	r3, #31
 801deb6:	d802      	bhi.n	801debe <create_name+0x1a2>
 801deb8:	f04f 0304 	mov.w	r3, #4
 801debc:	e001      	b.n	801dec2 <create_name+0x1a6>
 801debe:	f04f 0300 	mov.w	r3, #0
 801dec2:	77bb      	strb	r3, [r7, #30]

	if (!i) return FR_INVALID_NAME;		/* Reject null string */
 801dec4:	693b      	ldr	r3, [r7, #16]
 801dec6:	2b00      	cmp	r3, #0
 801dec8:	d102      	bne.n	801ded0 <create_name+0x1b4>
 801deca:	f04f 0306 	mov.w	r3, #6
 801dece:	e027      	b.n	801df20 <create_name+0x204>
	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
 801ded0:	68fb      	ldr	r3, [r7, #12]
 801ded2:	781b      	ldrb	r3, [r3, #0]
 801ded4:	2be5      	cmp	r3, #229	; 0xe5
 801ded6:	d103      	bne.n	801dee0 <create_name+0x1c4>
 801ded8:	68fb      	ldr	r3, [r7, #12]
 801deda:	f04f 0205 	mov.w	r2, #5
 801dede:	701a      	strb	r2, [r3, #0]

	if (ni == 8) b <<= 2;
 801dee0:	69bb      	ldr	r3, [r7, #24]
 801dee2:	2b08      	cmp	r3, #8
 801dee4:	d103      	bne.n	801deee <create_name+0x1d2>
 801dee6:	7ffb      	ldrb	r3, [r7, #31]
 801dee8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801deec:	77fb      	strb	r3, [r7, #31]
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
 801deee:	7ffb      	ldrb	r3, [r7, #31]
 801def0:	f003 0303 	and.w	r3, r3, #3
 801def4:	2b01      	cmp	r3, #1
 801def6:	d103      	bne.n	801df00 <create_name+0x1e4>
 801def8:	7fbb      	ldrb	r3, [r7, #30]
 801defa:	f043 0310 	orr.w	r3, r3, #16
 801defe:	77bb      	strb	r3, [r7, #30]
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
 801df00:	7ffb      	ldrb	r3, [r7, #31]
 801df02:	f003 030c 	and.w	r3, r3, #12
 801df06:	2b04      	cmp	r3, #4
 801df08:	d103      	bne.n	801df12 <create_name+0x1f6>
 801df0a:	7fbb      	ldrb	r3, [r7, #30]
 801df0c:	f043 0308 	orr.w	r3, r3, #8
 801df10:	77bb      	strb	r3, [r7, #30]

	sfn[11] = c;		/* Store NT flag, File name is created */
 801df12:	68fb      	ldr	r3, [r7, #12]
 801df14:	f103 030b 	add.w	r3, r3, #11
 801df18:	7fba      	ldrb	r2, [r7, #30]
 801df1a:	701a      	strb	r2, [r3, #0]
#endif

	return FR_OK;
 801df1c:	f04f 0300 	mov.w	r3, #0
}
 801df20:	4618      	mov	r0, r3
 801df22:	f107 0720 	add.w	r7, r7, #32
 801df26:	46bd      	mov	sp, r7
 801df28:	bd80      	pop	{r7, pc}
 801df2a:	bf00      	nop

0801df2c <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to store the file information */
)
{
 801df2c:	b480      	push	{r7}
 801df2e:	b089      	sub	sp, #36	; 0x24
 801df30:	af00      	add	r7, sp, #0
 801df32:	6078      	str	r0, [r7, #4]
 801df34:	6039      	str	r1, [r7, #0]
#if _USE_LFN
	XCHAR *tp;
#endif


	p = fno->fname;
 801df36:	683b      	ldr	r3, [r7, #0]
 801df38:	f103 0309 	add.w	r3, r3, #9
 801df3c:	617b      	str	r3, [r7, #20]
	if (dj->sect) {
 801df3e:	687b      	ldr	r3, [r7, #4]
 801df40:	691b      	ldr	r3, [r3, #16]
 801df42:	2b00      	cmp	r3, #0
 801df44:	f000 80af 	beq.w	801e0a6 <get_fileinfo+0x17a>
		dir = dj->dir;
 801df48:	687b      	ldr	r3, [r7, #4]
 801df4a:	695b      	ldr	r3, [r3, #20]
 801df4c:	613b      	str	r3, [r7, #16]
		nt = dir[DIR_NTres];		/* NT flag */
 801df4e:	693b      	ldr	r3, [r7, #16]
 801df50:	7b1b      	ldrb	r3, [r3, #12]
 801df52:	73fb      	strb	r3, [r7, #15]
		for (i = 0; i < 8; i++) {	/* Copy name body */
 801df54:	f04f 0300 	mov.w	r3, #0
 801df58:	61fb      	str	r3, [r7, #28]
 801df5a:	e027      	b.n	801dfac <get_fileinfo+0x80>
			c = dir[i];
 801df5c:	69fb      	ldr	r3, [r7, #28]
 801df5e:	693a      	ldr	r2, [r7, #16]
 801df60:	18d3      	adds	r3, r2, r3
 801df62:	781b      	ldrb	r3, [r3, #0]
 801df64:	76fb      	strb	r3, [r7, #27]
			if (c == ' ') break;
 801df66:	7efb      	ldrb	r3, [r7, #27]
 801df68:	2b20      	cmp	r3, #32
 801df6a:	d023      	beq.n	801dfb4 <get_fileinfo+0x88>
			if (c == 0x05) c = 0xE5;
 801df6c:	7efb      	ldrb	r3, [r7, #27]
 801df6e:	2b05      	cmp	r3, #5
 801df70:	d102      	bne.n	801df78 <get_fileinfo+0x4c>
 801df72:	f04f 03e5 	mov.w	r3, #229	; 0xe5
 801df76:	76fb      	strb	r3, [r7, #27]
			if ((nt & 0x08) && IsUpper(c)) c += 0x20;
 801df78:	7bfb      	ldrb	r3, [r7, #15]
 801df7a:	f003 0308 	and.w	r3, r3, #8
 801df7e:	2b00      	cmp	r3, #0
 801df80:	d009      	beq.n	801df96 <get_fileinfo+0x6a>
 801df82:	7efb      	ldrb	r3, [r7, #27]
 801df84:	2b40      	cmp	r3, #64	; 0x40
 801df86:	d906      	bls.n	801df96 <get_fileinfo+0x6a>
 801df88:	7efb      	ldrb	r3, [r7, #27]
 801df8a:	2b5a      	cmp	r3, #90	; 0x5a
 801df8c:	d803      	bhi.n	801df96 <get_fileinfo+0x6a>
 801df8e:	7efb      	ldrb	r3, [r7, #27]
 801df90:	f103 0320 	add.w	r3, r3, #32
 801df94:	76fb      	strb	r3, [r7, #27]
			*p++ = c;
 801df96:	697b      	ldr	r3, [r7, #20]
 801df98:	7efa      	ldrb	r2, [r7, #27]
 801df9a:	701a      	strb	r2, [r3, #0]
 801df9c:	697b      	ldr	r3, [r7, #20]
 801df9e:	f103 0301 	add.w	r3, r3, #1
 801dfa2:	617b      	str	r3, [r7, #20]

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
 801dfa4:	69fb      	ldr	r3, [r7, #28]
 801dfa6:	f103 0301 	add.w	r3, r3, #1
 801dfaa:	61fb      	str	r3, [r7, #28]
 801dfac:	69fb      	ldr	r3, [r7, #28]
 801dfae:	2b07      	cmp	r3, #7
 801dfb0:	ddd4      	ble.n	801df5c <get_fileinfo+0x30>
 801dfb2:	e000      	b.n	801dfb6 <get_fileinfo+0x8a>
			c = dir[i];
			if (c == ' ') break;
 801dfb4:	bf00      	nop
			if (c == 0x05) c = 0xE5;
			if ((nt & 0x08) && IsUpper(c)) c += 0x20;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
 801dfb6:	693b      	ldr	r3, [r7, #16]
 801dfb8:	f103 0308 	add.w	r3, r3, #8
 801dfbc:	781b      	ldrb	r3, [r3, #0]
 801dfbe:	2b20      	cmp	r3, #32
 801dfc0:	d032      	beq.n	801e028 <get_fileinfo+0xfc>
			*p++ = '.';
 801dfc2:	697b      	ldr	r3, [r7, #20]
 801dfc4:	f04f 022e 	mov.w	r2, #46	; 0x2e
 801dfc8:	701a      	strb	r2, [r3, #0]
 801dfca:	697b      	ldr	r3, [r7, #20]
 801dfcc:	f103 0301 	add.w	r3, r3, #1
 801dfd0:	617b      	str	r3, [r7, #20]
			for (i = 8; i < 11; i++) {
 801dfd2:	f04f 0308 	mov.w	r3, #8
 801dfd6:	61fb      	str	r3, [r7, #28]
 801dfd8:	e021      	b.n	801e01e <get_fileinfo+0xf2>
				c = dir[i];
 801dfda:	69fb      	ldr	r3, [r7, #28]
 801dfdc:	693a      	ldr	r2, [r7, #16]
 801dfde:	18d3      	adds	r3, r2, r3
 801dfe0:	781b      	ldrb	r3, [r3, #0]
 801dfe2:	76fb      	strb	r3, [r7, #27]
				if (c == ' ') break;
 801dfe4:	7efb      	ldrb	r3, [r7, #27]
 801dfe6:	2b20      	cmp	r3, #32
 801dfe8:	d01d      	beq.n	801e026 <get_fileinfo+0xfa>
				if ((nt & 0x10) && IsUpper(c)) c += 0x20;
 801dfea:	7bfb      	ldrb	r3, [r7, #15]
 801dfec:	f003 0310 	and.w	r3, r3, #16
 801dff0:	2b00      	cmp	r3, #0
 801dff2:	d009      	beq.n	801e008 <get_fileinfo+0xdc>
 801dff4:	7efb      	ldrb	r3, [r7, #27]
 801dff6:	2b40      	cmp	r3, #64	; 0x40
 801dff8:	d906      	bls.n	801e008 <get_fileinfo+0xdc>
 801dffa:	7efb      	ldrb	r3, [r7, #27]
 801dffc:	2b5a      	cmp	r3, #90	; 0x5a
 801dffe:	d803      	bhi.n	801e008 <get_fileinfo+0xdc>
 801e000:	7efb      	ldrb	r3, [r7, #27]
 801e002:	f103 0320 	add.w	r3, r3, #32
 801e006:	76fb      	strb	r3, [r7, #27]
				*p++ = c;
 801e008:	697b      	ldr	r3, [r7, #20]
 801e00a:	7efa      	ldrb	r2, [r7, #27]
 801e00c:	701a      	strb	r2, [r3, #0]
 801e00e:	697b      	ldr	r3, [r7, #20]
 801e010:	f103 0301 	add.w	r3, r3, #1
 801e014:	617b      	str	r3, [r7, #20]
			if ((nt & 0x08) && IsUpper(c)) c += 0x20;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
 801e016:	69fb      	ldr	r3, [r7, #28]
 801e018:	f103 0301 	add.w	r3, r3, #1
 801e01c:	61fb      	str	r3, [r7, #28]
 801e01e:	69fb      	ldr	r3, [r7, #28]
 801e020:	2b0a      	cmp	r3, #10
 801e022:	ddda      	ble.n	801dfda <get_fileinfo+0xae>
 801e024:	e000      	b.n	801e028 <get_fileinfo+0xfc>
				c = dir[i];
				if (c == ' ') break;
 801e026:	bf00      	nop
				if ((nt & 0x10) && IsUpper(c)) c += 0x20;
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 801e028:	693b      	ldr	r3, [r7, #16]
 801e02a:	7ada      	ldrb	r2, [r3, #11]
 801e02c:	683b      	ldr	r3, [r7, #0]
 801e02e:	721a      	strb	r2, [r3, #8]
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
 801e030:	693b      	ldr	r3, [r7, #16]
 801e032:	f103 031f 	add.w	r3, r3, #31
 801e036:	781b      	ldrb	r3, [r3, #0]
 801e038:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801e03c:	693b      	ldr	r3, [r7, #16]
 801e03e:	f103 031e 	add.w	r3, r3, #30
 801e042:	781b      	ldrb	r3, [r3, #0]
 801e044:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801e048:	431a      	orrs	r2, r3
 801e04a:	693b      	ldr	r3, [r7, #16]
 801e04c:	f103 031d 	add.w	r3, r3, #29
 801e050:	781b      	ldrb	r3, [r3, #0]
 801e052:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e056:	431a      	orrs	r2, r3
 801e058:	693b      	ldr	r3, [r7, #16]
 801e05a:	f103 031c 	add.w	r3, r3, #28
 801e05e:	781b      	ldrb	r3, [r3, #0]
 801e060:	431a      	orrs	r2, r3
 801e062:	683b      	ldr	r3, [r7, #0]
 801e064:	601a      	str	r2, [r3, #0]
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
 801e066:	693b      	ldr	r3, [r7, #16]
 801e068:	f103 0319 	add.w	r3, r3, #25
 801e06c:	781b      	ldrb	r3, [r3, #0]
 801e06e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e072:	b29a      	uxth	r2, r3
 801e074:	693b      	ldr	r3, [r7, #16]
 801e076:	f103 0318 	add.w	r3, r3, #24
 801e07a:	781b      	ldrb	r3, [r3, #0]
 801e07c:	4313      	orrs	r3, r2
 801e07e:	b29b      	uxth	r3, r3
 801e080:	b29a      	uxth	r2, r3
 801e082:	683b      	ldr	r3, [r7, #0]
 801e084:	809a      	strh	r2, [r3, #4]
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
 801e086:	693b      	ldr	r3, [r7, #16]
 801e088:	f103 0317 	add.w	r3, r3, #23
 801e08c:	781b      	ldrb	r3, [r3, #0]
 801e08e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e092:	b29a      	uxth	r2, r3
 801e094:	693b      	ldr	r3, [r7, #16]
 801e096:	f103 0316 	add.w	r3, r3, #22
 801e09a:	781b      	ldrb	r3, [r3, #0]
 801e09c:	4313      	orrs	r3, r2
 801e09e:	b29b      	uxth	r3, r3
 801e0a0:	b29a      	uxth	r2, r3
 801e0a2:	683b      	ldr	r3, [r7, #0]
 801e0a4:	80da      	strh	r2, [r3, #6]
	}
	*p = 0;
 801e0a6:	697b      	ldr	r3, [r7, #20]
 801e0a8:	f04f 0200 	mov.w	r2, #0
 801e0ac:	701a      	strb	r2, [r3, #0]
			}
		}
		tp[i] = 0;	/* Terminator */
	}
#endif
}
 801e0ae:	f107 0724 	add.w	r7, r7, #36	; 0x24
 801e0b2:	46bd      	mov	sp, r7
 801e0b4:	bc80      	pop	{r7}
 801e0b6:	4770      	bx	lr

0801e0b8 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const XCHAR *path	/* Full-path string to find a file or directory */
)
{
 801e0b8:	b580      	push	{r7, lr}
 801e0ba:	b084      	sub	sp, #16
 801e0bc:	af00      	add	r7, sp, #0
 801e0be:	6078      	str	r0, [r7, #4]
 801e0c0:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE *dir, last;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
 801e0c2:	683b      	ldr	r3, [r7, #0]
 801e0c4:	781b      	ldrb	r3, [r3, #0]
 801e0c6:	2b2f      	cmp	r3, #47	; 0x2f
 801e0c8:	d003      	beq.n	801e0d2 <follow_path+0x1a>
 801e0ca:	683b      	ldr	r3, [r7, #0]
 801e0cc:	781b      	ldrb	r3, [r3, #0]
 801e0ce:	2b5c      	cmp	r3, #92	; 0x5c
 801e0d0:	d108      	bne.n	801e0e4 <follow_path+0x2c>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 801e0d2:	683b      	ldr	r3, [r7, #0]
 801e0d4:	f103 0301 	add.w	r3, r3, #1
 801e0d8:	603b      	str	r3, [r7, #0]
 801e0da:	687b      	ldr	r3, [r7, #4]
 801e0dc:	f04f 0200 	mov.w	r2, #0
 801e0e0:	609a      	str	r2, [r3, #8]
 801e0e2:	e004      	b.n	801e0ee <follow_path+0x36>
	} else {							/* No heading saparator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
 801e0e4:	687b      	ldr	r3, [r7, #4]
 801e0e6:	681b      	ldr	r3, [r3, #0]
 801e0e8:	699a      	ldr	r2, [r3, #24]
 801e0ea:	687b      	ldr	r3, [r7, #4]
 801e0ec:	609a      	str	r2, [r3, #8]
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Null path means the start directory itself */
 801e0ee:	683b      	ldr	r3, [r7, #0]
 801e0f0:	781b      	ldrb	r3, [r3, #0]
 801e0f2:	2b1f      	cmp	r3, #31
 801e0f4:	d80b      	bhi.n	801e10e <follow_path+0x56>
		res = dir_seek(dj, 0);
 801e0f6:	6878      	ldr	r0, [r7, #4]
 801e0f8:	f04f 0100 	mov.w	r1, #0
 801e0fc:	f7ff fb5a 	bl	801d7b4 <dir_seek>
 801e100:	4603      	mov	r3, r0
 801e102:	73fb      	strb	r3, [r7, #15]
		dj->dir = NULL;
 801e104:	687b      	ldr	r3, [r7, #4]
 801e106:	f04f 0200 	mov.w	r2, #0
 801e10a:	615a      	str	r2, [r3, #20]
 801e10c:	e05c      	b.n	801e1c8 <follow_path+0x110>

	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
 801e10e:	463b      	mov	r3, r7
 801e110:	6878      	ldr	r0, [r7, #4]
 801e112:	4619      	mov	r1, r3
 801e114:	f7ff fe02 	bl	801dd1c <create_name>
 801e118:	4603      	mov	r3, r0
 801e11a:	73fb      	strb	r3, [r7, #15]
			if (res != FR_OK) break;
 801e11c:	7bfb      	ldrb	r3, [r7, #15]
 801e11e:	2b00      	cmp	r3, #0
 801e120:	d14d      	bne.n	801e1be <follow_path+0x106>
			res = dir_find(dj);				/* Find it */
 801e122:	6878      	ldr	r0, [r7, #4]
 801e124:	f7ff fcc4 	bl	801dab0 <dir_find>
 801e128:	4603      	mov	r3, r0
 801e12a:	73fb      	strb	r3, [r7, #15]
			last = *(dj->fn+11) & NS_LAST;
 801e12c:	687b      	ldr	r3, [r7, #4]
 801e12e:	699b      	ldr	r3, [r3, #24]
 801e130:	f103 030b 	add.w	r3, r3, #11
 801e134:	781b      	ldrb	r3, [r3, #0]
 801e136:	f003 0304 	and.w	r3, r3, #4
 801e13a:	73bb      	strb	r3, [r7, #14]
			if (res != FR_OK) {				/* Could not find the object */
 801e13c:	7bfb      	ldrb	r3, [r7, #15]
 801e13e:	2b00      	cmp	r3, #0
 801e140:	d009      	beq.n	801e156 <follow_path+0x9e>
				if (res == FR_NO_FILE && !last)
 801e142:	7bfb      	ldrb	r3, [r7, #15]
 801e144:	2b04      	cmp	r3, #4
 801e146:	d13c      	bne.n	801e1c2 <follow_path+0x10a>
 801e148:	7bbb      	ldrb	r3, [r7, #14]
 801e14a:	2b00      	cmp	r3, #0
 801e14c:	d139      	bne.n	801e1c2 <follow_path+0x10a>
					res = FR_NO_PATH;
 801e14e:	f04f 0305 	mov.w	r3, #5
 801e152:	73fb      	strb	r3, [r7, #15]
				break;
 801e154:	e035      	b.n	801e1c2 <follow_path+0x10a>
			}
			if (last) break;				/* Last segment match. Function completed. */
 801e156:	7bbb      	ldrb	r3, [r7, #14]
 801e158:	2b00      	cmp	r3, #0
 801e15a:	d134      	bne.n	801e1c6 <follow_path+0x10e>
			dir = dj->dir;					/* There is next segment. Follow the sub directory */
 801e15c:	687b      	ldr	r3, [r7, #4]
 801e15e:	695b      	ldr	r3, [r3, #20]
 801e160:	60bb      	str	r3, [r7, #8]
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
 801e162:	68bb      	ldr	r3, [r7, #8]
 801e164:	f103 030b 	add.w	r3, r3, #11
 801e168:	781b      	ldrb	r3, [r3, #0]
 801e16a:	f003 0310 	and.w	r3, r3, #16
 801e16e:	2b00      	cmp	r3, #0
 801e170:	d103      	bne.n	801e17a <follow_path+0xc2>
				res = FR_NO_PATH; break;
 801e172:	f04f 0305 	mov.w	r3, #5
 801e176:	73fb      	strb	r3, [r7, #15]
 801e178:	e026      	b.n	801e1c8 <follow_path+0x110>
			}
			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 801e17a:	68bb      	ldr	r3, [r7, #8]
 801e17c:	f103 0315 	add.w	r3, r3, #21
 801e180:	781b      	ldrb	r3, [r3, #0]
 801e182:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e186:	b29a      	uxth	r2, r3
 801e188:	68bb      	ldr	r3, [r7, #8]
 801e18a:	f103 0314 	add.w	r3, r3, #20
 801e18e:	781b      	ldrb	r3, [r3, #0]
 801e190:	4313      	orrs	r3, r2
 801e192:	b29b      	uxth	r3, r3
 801e194:	b29b      	uxth	r3, r3
 801e196:	ea4f 4203 	mov.w	r2, r3, lsl #16
 801e19a:	68bb      	ldr	r3, [r7, #8]
 801e19c:	f103 031b 	add.w	r3, r3, #27
 801e1a0:	781b      	ldrb	r3, [r3, #0]
 801e1a2:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e1a6:	b299      	uxth	r1, r3
 801e1a8:	68bb      	ldr	r3, [r7, #8]
 801e1aa:	f103 031a 	add.w	r3, r3, #26
 801e1ae:	781b      	ldrb	r3, [r3, #0]
 801e1b0:	430b      	orrs	r3, r1
 801e1b2:	b29b      	uxth	r3, r3
 801e1b4:	b29b      	uxth	r3, r3
 801e1b6:	431a      	orrs	r2, r3
 801e1b8:	687b      	ldr	r3, [r7, #4]
 801e1ba:	609a      	str	r2, [r3, #8]
		}
 801e1bc:	e7a7      	b.n	801e10e <follow_path+0x56>
		dj->dir = NULL;

	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
 801e1be:	bf00      	nop
 801e1c0:	e002      	b.n	801e1c8 <follow_path+0x110>
			res = dir_find(dj);				/* Find it */
			last = *(dj->fn+11) & NS_LAST;
			if (res != FR_OK) {				/* Could not find the object */
				if (res == FR_NO_FILE && !last)
					res = FR_NO_PATH;
				break;
 801e1c2:	bf00      	nop
 801e1c4:	e000      	b.n	801e1c8 <follow_path+0x110>
			}
			if (last) break;				/* Last segment match. Function completed. */
 801e1c6:	bf00      	nop
			}
			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
		}
	}

	return res;
 801e1c8:	7bfb      	ldrb	r3, [r7, #15]
}
 801e1ca:	4618      	mov	r0, r3
 801e1cc:	f107 0710 	add.w	r7, r7, #16
 801e1d0:	46bd      	mov	sp, r7
 801e1d2:	bd80      	pop	{r7, pc}

0801e1d4 <check_fs>:
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 801e1d4:	b580      	push	{r7, lr}
 801e1d6:	b082      	sub	sp, #8
 801e1d8:	af00      	add	r7, sp, #0
 801e1da:	6078      	str	r0, [r7, #4]
 801e1dc:	6039      	str	r1, [r7, #0]
	static const char fatstr[] = "FAT";


	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 801e1de:	687b      	ldr	r3, [r7, #4]
 801e1e0:	785a      	ldrb	r2, [r3, #1]
 801e1e2:	687b      	ldr	r3, [r7, #4]
 801e1e4:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801e1e8:	4610      	mov	r0, r2
 801e1ea:	4619      	mov	r1, r3
 801e1ec:	683a      	ldr	r2, [r7, #0]
 801e1ee:	f04f 0301 	mov.w	r3, #1
 801e1f2:	f7e7 f929 	bl	8005448 <disk_read>
 801e1f6:	4603      	mov	r3, r0
 801e1f8:	2b00      	cmp	r3, #0
 801e1fa:	d002      	beq.n	801e202 <check_fs+0x2e>
		return 3;
 801e1fc:	f04f 0303 	mov.w	r3, #3
 801e200:	e041      	b.n	801e286 <check_fs+0xb2>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 801e202:	687b      	ldr	r3, [r7, #4]
 801e204:	f893 3233 	ldrb.w	r3, [r3, #563]	; 0x233
 801e208:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e20c:	b29a      	uxth	r2, r3
 801e20e:	687b      	ldr	r3, [r7, #4]
 801e210:	f893 3232 	ldrb.w	r3, [r3, #562]	; 0x232
 801e214:	4313      	orrs	r3, r2
 801e216:	b29b      	uxth	r3, r3
 801e218:	b21a      	sxth	r2, r3
 801e21a:	f64a 2355 	movw	r3, #43605	; 0xaa55
 801e21e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 801e222:	429a      	cmp	r2, r3
 801e224:	d002      	beq.n	801e22c <check_fs+0x58>
		return 2;
 801e226:	f04f 0302 	mov.w	r3, #2
 801e22a:	e02c      	b.n	801e286 <check_fs+0xb2>

	if (!mem_cmp(&fs->win[BS_FilSysType], fatstr, 3))	/* Check FAT signature */
 801e22c:	687b      	ldr	r3, [r7, #4]
 801e22e:	f103 036a 	add.w	r3, r3, #106	; 0x6a
 801e232:	4618      	mov	r0, r3
 801e234:	f642 3194 	movw	r1, #11156	; 0x2b94
 801e238:	f6c0 0103 	movt	r1, #2051	; 0x803
 801e23c:	f04f 0203 	mov.w	r2, #3
 801e240:	f7fe fdfc 	bl	801ce3c <mem_cmp>
 801e244:	4603      	mov	r3, r0
 801e246:	2b00      	cmp	r3, #0
 801e248:	d102      	bne.n	801e250 <check_fs+0x7c>
		return 0;
 801e24a:	f04f 0300 	mov.w	r3, #0
 801e24e:	e01a      	b.n	801e286 <check_fs+0xb2>
	if (!mem_cmp(&fs->win[BS_FilSysType32], fatstr, 3) && !(fs->win[BPB_ExtFlags] & 0x80))
 801e250:	687b      	ldr	r3, [r7, #4]
 801e252:	f103 0386 	add.w	r3, r3, #134	; 0x86
 801e256:	4618      	mov	r0, r3
 801e258:	f642 3194 	movw	r1, #11156	; 0x2b94
 801e25c:	f6c0 0103 	movt	r1, #2051	; 0x803
 801e260:	f04f 0203 	mov.w	r2, #3
 801e264:	f7fe fdea 	bl	801ce3c <mem_cmp>
 801e268:	4603      	mov	r3, r0
 801e26a:	2b00      	cmp	r3, #0
 801e26c:	d109      	bne.n	801e282 <check_fs+0xae>
 801e26e:	687b      	ldr	r3, [r7, #4]
 801e270:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 801e274:	b2db      	uxtb	r3, r3
 801e276:	b25b      	sxtb	r3, r3
 801e278:	2b00      	cmp	r3, #0
 801e27a:	db02      	blt.n	801e282 <check_fs+0xae>
		return 0;
 801e27c:	f04f 0300 	mov.w	r3, #0
 801e280:	e001      	b.n	801e286 <check_fs+0xb2>

	return 1;
 801e282:	f04f 0301 	mov.w	r3, #1
}
 801e286:	4618      	mov	r0, r3
 801e288:	f107 0708 	add.w	r7, r7, #8
 801e28c:	46bd      	mov	sp, r7
 801e28e:	bd80      	pop	{r7, pc}

0801e290 <auto_mount>:
FRESULT auto_mount (	/* FR_OK(0): successful, !=0: any error occured */
	const XCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
 801e290:	b580      	push	{r7, lr}
 801e292:	b090      	sub	sp, #64	; 0x40
 801e294:	af00      	add	r7, sp, #0
 801e296:	60f8      	str	r0, [r7, #12]
 801e298:	60b9      	str	r1, [r7, #8]
 801e29a:	4613      	mov	r3, r2
 801e29c:	71fb      	strb	r3, [r7, #7]
	FRESULT res;
	BYTE fmt, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fsize, tsect, mclst;
	const XCHAR *p = *path;
 801e29e:	68fb      	ldr	r3, [r7, #12]
 801e2a0:	681b      	ldr	r3, [r3, #0]
 801e2a2:	62bb      	str	r3, [r7, #40]	; 0x28
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';				/* Is there a drive number? */
 801e2a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e2a6:	781b      	ldrb	r3, [r3, #0]
 801e2a8:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 801e2ac:	63bb      	str	r3, [r7, #56]	; 0x38
	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
 801e2ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e2b0:	2b09      	cmp	r3, #9
 801e2b2:	d80d      	bhi.n	801e2d0 <auto_mount+0x40>
 801e2b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e2b6:	f103 0301 	add.w	r3, r3, #1
 801e2ba:	781b      	ldrb	r3, [r3, #0]
 801e2bc:	2b3a      	cmp	r3, #58	; 0x3a
 801e2be:	d107      	bne.n	801e2d0 <auto_mount+0x40>
		p += 2; *path = p;			/* Return pointer to the path name */
 801e2c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e2c2:	f103 0302 	add.w	r3, r3, #2
 801e2c6:	62bb      	str	r3, [r7, #40]	; 0x28
 801e2c8:	68fb      	ldr	r3, [r7, #12]
 801e2ca:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801e2cc:	601a      	str	r2, [r3, #0]
 801e2ce:	e005      	b.n	801e2dc <auto_mount+0x4c>
	} else {						/* No drive number is given */
#if _FS_RPATH
		vol = Drive;				/* Use current drive */
 801e2d0:	f241 03ee 	movw	r3, #4334	; 0x10ee
 801e2d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e2d8:	781b      	ldrb	r3, [r3, #0]
 801e2da:	63bb      	str	r3, [r7, #56]	; 0x38
		vol = 0;					/* Use drive 0 */
#endif
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _DRIVES) 			/* Is the drive number valid? */
 801e2dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e2de:	2b00      	cmp	r3, #0
 801e2e0:	d002      	beq.n	801e2e8 <auto_mount+0x58>
		return FR_INVALID_DRIVE;
 801e2e2:	f04f 030b 	mov.w	r3, #11
 801e2e6:	e25d      	b.n	801e7a4 <auto_mount+0x514>
	*rfs = fs = FatFs[vol];			/* Returen pointer to the corresponding file system object */
 801e2e8:	f241 03e8 	movw	r3, #4328	; 0x10e8
 801e2ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e2f0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801e2f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801e2f6:	627b      	str	r3, [r7, #36]	; 0x24
 801e2f8:	68bb      	ldr	r3, [r7, #8]
 801e2fa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801e2fc:	601a      	str	r2, [r3, #0]
	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object registered? */
 801e2fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e300:	2b00      	cmp	r3, #0
 801e302:	d102      	bne.n	801e30a <auto_mount+0x7a>
 801e304:	f04f 030c 	mov.w	r3, #12
 801e308:	e24c      	b.n	801e7a4 <auto_mount+0x514>

	ENTER_FF(fs);					/* Lock file system */

	if (fs->fs_type) {				/* If the logical drive has been mounted */
 801e30a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e30c:	781b      	ldrb	r3, [r3, #0]
 801e30e:	2b00      	cmp	r3, #0
 801e310:	d01c      	beq.n	801e34c <auto_mount+0xbc>
		stat = disk_status(fs->drive);
 801e312:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e314:	785b      	ldrb	r3, [r3, #1]
 801e316:	4618      	mov	r0, r3
 801e318:	f7e7 f87e 	bl	8005418 <disk_status>
 801e31c:	4603      	mov	r3, r0
 801e31e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed), */
 801e322:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801e326:	f003 0301 	and.w	r3, r3, #1
 801e32a:	2b00      	cmp	r3, #0
 801e32c:	d10e      	bne.n	801e34c <auto_mount+0xbc>
#if !_FS_READONLY
			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
 801e32e:	79fb      	ldrb	r3, [r7, #7]
 801e330:	2b00      	cmp	r3, #0
 801e332:	d008      	beq.n	801e346 <auto_mount+0xb6>
 801e334:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801e338:	f003 0304 	and.w	r3, r3, #4
 801e33c:	2b00      	cmp	r3, #0
 801e33e:	d002      	beq.n	801e346 <auto_mount+0xb6>
				return FR_WRITE_PROTECTED;
 801e340:	f04f 030a 	mov.w	r3, #10
 801e344:	e22e      	b.n	801e7a4 <auto_mount+0x514>
#endif
			return FR_OK;			/* The file system object is valid */
 801e346:	f04f 0300 	mov.w	r3, #0
 801e34a:	e22b      	b.n	801e7a4 <auto_mount+0x514>
		}
	}

	/* The logical drive must be mounted. Following code attempts to mount the volume */

	fs->fs_type = 0;					/* Clear the file system object */
 801e34c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e34e:	f04f 0200 	mov.w	r2, #0
 801e352:	701a      	strb	r2, [r3, #0]
	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
 801e354:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e356:	b2da      	uxtb	r2, r3
 801e358:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e35a:	705a      	strb	r2, [r3, #1]
	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
 801e35c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e35e:	785b      	ldrb	r3, [r3, #1]
 801e360:	4618      	mov	r0, r3
 801e362:	f7e7 f831 	bl	80053c8 <disk_initialize>
 801e366:	4603      	mov	r3, r0
 801e368:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
	if (stat & STA_NOINIT)				/* Check if the drive is ready */
 801e36c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801e370:	f003 0301 	and.w	r3, r3, #1
 801e374:	b2db      	uxtb	r3, r3
 801e376:	2b00      	cmp	r3, #0
 801e378:	d002      	beq.n	801e380 <auto_mount+0xf0>
		return FR_NOT_READY;
 801e37a:	f04f 0303 	mov.w	r3, #3
 801e37e:	e211      	b.n	801e7a4 <auto_mount+0x514>
#if _MAX_SS != 512						/* Get disk sector size if needed */
	if (disk_ioctl(fs->drive, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
		return FR_NO_FILESYSTEM;
#endif
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 801e380:	79fb      	ldrb	r3, [r7, #7]
 801e382:	2b00      	cmp	r3, #0
 801e384:	d008      	beq.n	801e398 <auto_mount+0x108>
 801e386:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801e38a:	f003 0304 	and.w	r3, r3, #4
 801e38e:	2b00      	cmp	r3, #0
 801e390:	d002      	beq.n	801e398 <auto_mount+0x108>
		return FR_WRITE_PROTECTED;
 801e392:	f04f 030a 	mov.w	r3, #10
 801e396:	e205      	b.n	801e7a4 <auto_mount+0x514>
#endif
	/* Search FAT partition on the drive */
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
 801e398:	f04f 0300 	mov.w	r3, #0
 801e39c:	637b      	str	r3, [r7, #52]	; 0x34
 801e39e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801e3a0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801e3a2:	f7ff ff17 	bl	801e1d4 <check_fs>
 801e3a6:	4603      	mov	r3, r0
 801e3a8:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
 801e3ac:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801e3b0:	2b01      	cmp	r3, #1
 801e3b2:	d12a      	bne.n	801e40a <auto_mount+0x17a>
		/* Check a partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
 801e3b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e3b6:	f503 73f9 	add.w	r3, r3, #498	; 0x1f2
 801e3ba:	61fb      	str	r3, [r7, #28]
		if (tbl[4]) {									/* Is the partition existing? */
 801e3bc:	69fb      	ldr	r3, [r7, #28]
 801e3be:	f103 0304 	add.w	r3, r3, #4
 801e3c2:	781b      	ldrb	r3, [r3, #0]
 801e3c4:	2b00      	cmp	r3, #0
 801e3c6:	d020      	beq.n	801e40a <auto_mount+0x17a>
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
 801e3c8:	69fb      	ldr	r3, [r7, #28]
 801e3ca:	f103 030b 	add.w	r3, r3, #11
 801e3ce:	781b      	ldrb	r3, [r3, #0]
 801e3d0:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801e3d4:	69fb      	ldr	r3, [r7, #28]
 801e3d6:	f103 030a 	add.w	r3, r3, #10
 801e3da:	781b      	ldrb	r3, [r3, #0]
 801e3dc:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801e3e0:	431a      	orrs	r2, r3
 801e3e2:	69fb      	ldr	r3, [r7, #28]
 801e3e4:	f103 0309 	add.w	r3, r3, #9
 801e3e8:	781b      	ldrb	r3, [r3, #0]
 801e3ea:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e3ee:	431a      	orrs	r2, r3
 801e3f0:	69fb      	ldr	r3, [r7, #28]
 801e3f2:	f103 0308 	add.w	r3, r3, #8
 801e3f6:	781b      	ldrb	r3, [r3, #0]
 801e3f8:	4313      	orrs	r3, r2
 801e3fa:	637b      	str	r3, [r7, #52]	; 0x34
			fmt = check_fs(fs, bsect);					/* Check the partition */
 801e3fc:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801e3fe:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801e400:	f7ff fee8 	bl	801e1d4 <check_fs>
 801e404:	4603      	mov	r3, r0
 801e406:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
 801e40a:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801e40e:	2b03      	cmp	r3, #3
 801e410:	d102      	bne.n	801e418 <auto_mount+0x188>
 801e412:	f04f 0301 	mov.w	r3, #1
 801e416:	e1c5      	b.n	801e7a4 <auto_mount+0x514>
	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
 801e418:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801e41c:	2b00      	cmp	r3, #0
 801e41e:	d10e      	bne.n	801e43e <auto_mount+0x1ae>
 801e420:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e422:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801e426:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e42a:	b29a      	uxth	r2, r3
 801e42c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e42e:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 801e432:	4313      	orrs	r3, r2
 801e434:	b29b      	uxth	r3, r3
 801e436:	b21b      	sxth	r3, r3
 801e438:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801e43c:	d002      	beq.n	801e444 <auto_mount+0x1b4>
		return FR_NO_FILESYSTEM;
 801e43e:	f04f 030d 	mov.w	r3, #13
 801e442:	e1af      	b.n	801e7a4 <auto_mount+0x514>

	/* Initialize the file system object */
	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 801e444:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e446:	f893 304b 	ldrb.w	r3, [r3, #75]	; 0x4b
 801e44a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e44e:	b29a      	uxth	r2, r3
 801e450:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e452:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 801e456:	4313      	orrs	r3, r2
 801e458:	b29b      	uxth	r3, r3
 801e45a:	b29b      	uxth	r3, r3
 801e45c:	633b      	str	r3, [r7, #48]	; 0x30
	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
 801e45e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e460:	2b00      	cmp	r3, #0
 801e462:	d115      	bne.n	801e490 <auto_mount+0x200>
 801e464:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e466:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 801e46a:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801e46e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e470:	f893 305a 	ldrb.w	r3, [r3, #90]	; 0x5a
 801e474:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801e478:	431a      	orrs	r2, r3
 801e47a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e47c:	f893 3059 	ldrb.w	r3, [r3, #89]	; 0x59
 801e480:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e484:	431a      	orrs	r2, r3
 801e486:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e488:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 801e48c:	4313      	orrs	r3, r2
 801e48e:	633b      	str	r3, [r7, #48]	; 0x30
	fs->sects_fat = fsize;
 801e490:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e492:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801e494:	61da      	str	r2, [r3, #28]
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 801e496:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e498:	f893 2044 	ldrb.w	r2, [r3, #68]	; 0x44
 801e49c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e49e:	70da      	strb	r2, [r3, #3]
	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
 801e4a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4a2:	78db      	ldrb	r3, [r3, #3]
 801e4a4:	461a      	mov	r2, r3
 801e4a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e4a8:	fb02 f303 	mul.w	r3, r2, r3
 801e4ac:	633b      	str	r3, [r7, #48]	; 0x30
	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
 801e4ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4b0:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 801e4b4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e4b8:	b29a      	uxth	r2, r3
 801e4ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4bc:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 801e4c0:	4313      	orrs	r3, r2
 801e4c2:	b29b      	uxth	r3, r3
 801e4c4:	b29b      	uxth	r3, r3
 801e4c6:	461a      	mov	r2, r3
 801e4c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e4ca:	18d2      	adds	r2, r2, r3
 801e4cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4ce:	625a      	str	r2, [r3, #36]	; 0x24
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 801e4d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4d2:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
 801e4d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4d8:	709a      	strb	r2, [r3, #2]
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
 801e4da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4dc:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 801e4e0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e4e4:	b29a      	uxth	r2, r3
 801e4e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4e8:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 801e4ec:	4313      	orrs	r3, r2
 801e4ee:	b29b      	uxth	r3, r3
 801e4f0:	b29a      	uxth	r2, r3
 801e4f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4f4:	811a      	strh	r2, [r3, #8]
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the file system */
 801e4f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e4f8:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 801e4fc:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e500:	b29a      	uxth	r2, r3
 801e502:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e504:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
 801e508:	4313      	orrs	r3, r2
 801e50a:	b29b      	uxth	r3, r3
 801e50c:	b29b      	uxth	r3, r3
 801e50e:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 801e510:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e512:	2b00      	cmp	r3, #0
 801e514:	d115      	bne.n	801e542 <auto_mount+0x2b2>
 801e516:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e518:	f893 3057 	ldrb.w	r3, [r3, #87]	; 0x57
 801e51c:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801e520:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e522:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 801e526:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801e52a:	431a      	orrs	r2, r3
 801e52c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e52e:	f893 3055 	ldrb.w	r3, [r3, #85]	; 0x55
 801e532:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e536:	431a      	orrs	r2, r3
 801e538:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e53a:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 801e53e:	4313      	orrs	r3, r2
 801e540:	62fb      	str	r3, [r7, #44]	; 0x2c
	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 */
		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
 801e542:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e544:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 801e548:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e54c:	b29a      	uxth	r2, r3
 801e54e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e550:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 801e554:	4313      	orrs	r3, r2
 801e556:	b29b      	uxth	r3, r3
 801e558:	b29b      	uxth	r3, r3
 801e55a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801e55c:	1ad2      	subs	r2, r2, r3
 801e55e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e560:	1ad2      	subs	r2, r2, r3
 801e562:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e564:	891b      	ldrh	r3, [r3, #8]
 801e566:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801e56a:	b29b      	uxth	r3, r3
 801e56c:	1ad2      	subs	r2, r2, r3
		) / fs->csize + 2;
 801e56e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e570:	789b      	ldrb	r3, [r3, #2]
 801e572:	fbb2 f3f3 	udiv	r3, r2, r3
	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the file system */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 */
 801e576:	f103 0302 	add.w	r3, r3, #2
 801e57a:	61bb      	str	r3, [r7, #24]
 801e57c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e57e:	69ba      	ldr	r2, [r7, #24]
 801e580:	621a      	str	r2, [r3, #32]
		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;

	fmt = FS_FAT12;										/* Determine the FAT sub type */
 801e582:	f04f 0301 	mov.w	r3, #1
 801e586:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
 801e58a:	69ba      	ldr	r2, [r7, #24]
 801e58c:	f640 73f6 	movw	r3, #4086	; 0xff6
 801e590:	429a      	cmp	r2, r3
 801e592:	d903      	bls.n	801e59c <auto_mount+0x30c>
 801e594:	f04f 0302 	mov.w	r3, #2
 801e598:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
 801e59c:	69ba      	ldr	r2, [r7, #24]
 801e59e:	f64f 73f6 	movw	r3, #65526	; 0xfff6
 801e5a2:	429a      	cmp	r2, r3
 801e5a4:	d903      	bls.n	801e5ae <auto_mount+0x31e>
 801e5a6:	f04f 0303 	mov.w	r3, #3
 801e5aa:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

	if (fmt == FS_FAT32)
 801e5ae:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801e5b2:	2b03      	cmp	r3, #3
 801e5b4:	d117      	bne.n	801e5e6 <auto_mount+0x356>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 801e5b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5b8:	f893 3063 	ldrb.w	r3, [r3, #99]	; 0x63
 801e5bc:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801e5c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5c2:	f893 3062 	ldrb.w	r3, [r3, #98]	; 0x62
 801e5c6:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801e5ca:	431a      	orrs	r2, r3
 801e5cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5ce:	f893 3061 	ldrb.w	r3, [r3, #97]	; 0x61
 801e5d2:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e5d6:	431a      	orrs	r2, r3
 801e5d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5da:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 801e5de:	431a      	orrs	r2, r3
 801e5e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5e2:	629a      	str	r2, [r3, #40]	; 0x28
 801e5e4:	e005      	b.n	801e5f2 <auto_mount+0x362>
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
 801e5e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801e5ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e5ec:	18d2      	adds	r2, r2, r3
 801e5ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5f0:	629a      	str	r2, [r3, #40]	; 0x28
	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
 801e5f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5f4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801e5f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e5f8:	18d2      	adds	r2, r2, r3
 801e5fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5fc:	891b      	ldrh	r3, [r3, #8]
 801e5fe:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801e602:	b29b      	uxth	r3, r3
 801e604:	18d2      	adds	r2, r2, r3
 801e606:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e608:	62da      	str	r2, [r3, #44]	; 0x2c

#if !_FS_READONLY
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
 801e60a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e60c:	f04f 32ff 	mov.w	r2, #4294967295
 801e610:	611a      	str	r2, [r3, #16]
	fs->wflag = 0;
 801e612:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e614:	f04f 0200 	mov.w	r2, #0
 801e618:	711a      	strb	r2, [r3, #4]
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
 801e61a:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801e61e:	2b03      	cmp	r3, #3
 801e620:	f040 809c 	bne.w	801e75c <auto_mount+0x4cc>
	 	fs->fsi_flag = 0;
 801e624:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e626:	f04f 0200 	mov.w	r2, #0
 801e62a:	729a      	strb	r2, [r3, #10]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 801e62c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e62e:	f893 3065 	ldrb.w	r3, [r3, #101]	; 0x65
 801e632:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e636:	b29a      	uxth	r2, r3
 801e638:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e63a:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 801e63e:	4313      	orrs	r3, r2
 801e640:	b29b      	uxth	r3, r3
 801e642:	b29b      	uxth	r3, r3
 801e644:	461a      	mov	r2, r3
 801e646:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e648:	18d2      	adds	r2, r2, r3
 801e64a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e64c:	615a      	str	r2, [r3, #20]
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 801e64e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e650:	7859      	ldrb	r1, [r3, #1]
 801e652:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e654:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801e658:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e65a:	695b      	ldr	r3, [r3, #20]
 801e65c:	4608      	mov	r0, r1
 801e65e:	4611      	mov	r1, r2
 801e660:	461a      	mov	r2, r3
 801e662:	f04f 0301 	mov.w	r3, #1
 801e666:	f7e6 feef 	bl	8005448 <disk_read>
 801e66a:	4603      	mov	r3, r0
 801e66c:	2b00      	cmp	r3, #0
 801e66e:	d175      	bne.n	801e75c <auto_mount+0x4cc>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 801e670:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e672:	f893 3233 	ldrb.w	r3, [r3, #563]	; 0x233
 801e676:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e67a:	b29a      	uxth	r2, r3
 801e67c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e67e:	f893 3232 	ldrb.w	r3, [r3, #562]	; 0x232
 801e682:	4313      	orrs	r3, r2
 801e684:	b29b      	uxth	r3, r3
	fs->wflag = 0;
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 801e686:	b21a      	sxth	r2, r3
 801e688:	f64a 2355 	movw	r3, #43605	; 0xaa55
 801e68c:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 801e690:	429a      	cmp	r2, r3
 801e692:	d163      	bne.n	801e75c <auto_mount+0x4cc>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 801e694:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e696:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 801e69a:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801e69e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e6a0:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 801e6a4:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801e6a8:	431a      	orrs	r2, r3
 801e6aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e6ac:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801e6b0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e6b4:	431a      	orrs	r2, r3
 801e6b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e6b8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801e6bc:	431a      	orrs	r2, r3
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 801e6be:	f245 2352 	movw	r3, #21074	; 0x5252
 801e6c2:	f2c4 1361 	movt	r3, #16737	; 0x4161
 801e6c6:	429a      	cmp	r2, r3
 801e6c8:	d148      	bne.n	801e75c <auto_mount+0x4cc>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
 801e6ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e6cc:	f893 321b 	ldrb.w	r3, [r3, #539]	; 0x21b
 801e6d0:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801e6d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e6d6:	f893 321a 	ldrb.w	r3, [r3, #538]	; 0x21a
 801e6da:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801e6de:	431a      	orrs	r2, r3
 801e6e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e6e2:	f893 3219 	ldrb.w	r3, [r3, #537]	; 0x219
 801e6e6:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e6ea:	431a      	orrs	r2, r3
 801e6ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e6ee:	f893 3218 	ldrb.w	r3, [r3, #536]	; 0x218
 801e6f2:	431a      	orrs	r2, r3
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 801e6f4:	f247 2372 	movw	r3, #29298	; 0x7272
 801e6f8:	f2c6 1341 	movt	r3, #24897	; 0x6141
 801e6fc:	429a      	cmp	r2, r3
 801e6fe:	d12d      	bne.n	801e75c <auto_mount+0x4cc>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 801e700:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e702:	f893 3223 	ldrb.w	r3, [r3, #547]	; 0x223
 801e706:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801e70a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e70c:	f893 3222 	ldrb.w	r3, [r3, #546]	; 0x222
 801e710:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801e714:	431a      	orrs	r2, r3
 801e716:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e718:	f893 3221 	ldrb.w	r3, [r3, #545]	; 0x221
 801e71c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e720:	431a      	orrs	r2, r3
 801e722:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e724:	f893 3220 	ldrb.w	r3, [r3, #544]	; 0x220
 801e728:	431a      	orrs	r2, r3
 801e72a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e72c:	60da      	str	r2, [r3, #12]
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 801e72e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e730:	f893 321f 	ldrb.w	r3, [r3, #543]	; 0x21f
 801e734:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801e738:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e73a:	f893 321e 	ldrb.w	r3, [r3, #542]	; 0x21e
 801e73e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801e742:	431a      	orrs	r2, r3
 801e744:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e746:	f893 321d 	ldrb.w	r3, [r3, #541]	; 0x21d
 801e74a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e74e:	431a      	orrs	r2, r3
 801e750:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e752:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
 801e756:	431a      	orrs	r2, r3
 801e758:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e75a:	611a      	str	r2, [r3, #16]
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
 801e75c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e75e:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 801e762:	701a      	strb	r2, [r3, #0]
	fs->winsect = 0;		/* Invalidate sector cache */
 801e764:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e766:	f04f 0200 	mov.w	r2, #0
 801e76a:	631a      	str	r2, [r3, #48]	; 0x30
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
 801e76c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e76e:	f04f 0200 	mov.w	r2, #0
 801e772:	619a      	str	r2, [r3, #24]
#endif
	fs->id = ++Fsid;		/* File system mount ID */
 801e774:	f241 03ec 	movw	r3, #4332	; 0x10ec
 801e778:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e77c:	881b      	ldrh	r3, [r3, #0]
 801e77e:	f103 0301 	add.w	r3, r3, #1
 801e782:	b29a      	uxth	r2, r3
 801e784:	f241 03ec 	movw	r3, #4332	; 0x10ec
 801e788:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e78c:	801a      	strh	r2, [r3, #0]
 801e78e:	f241 03ec 	movw	r3, #4332	; 0x10ec
 801e792:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e796:	881a      	ldrh	r2, [r3, #0]
 801e798:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e79a:	80da      	strh	r2, [r3, #6]
	res = FR_OK;
 801e79c:	f04f 0300 	mov.w	r3, #0
 801e7a0:	75fb      	strb	r3, [r7, #23]

	return res;
 801e7a2:	7dfb      	ldrb	r3, [r7, #23]
}
 801e7a4:	4618      	mov	r0, r3
 801e7a6:	f107 0740 	add.w	r7, r7, #64	; 0x40
 801e7aa:	46bd      	mov	sp, r7
 801e7ac:	bd80      	pop	{r7, pc}
 801e7ae:	bf00      	nop

0801e7b0 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
 801e7b0:	b580      	push	{r7, lr}
 801e7b2:	b082      	sub	sp, #8
 801e7b4:	af00      	add	r7, sp, #0
 801e7b6:	6078      	str	r0, [r7, #4]
 801e7b8:	460b      	mov	r3, r1
 801e7ba:	807b      	strh	r3, [r7, #2]
	if (!fs || !fs->fs_type || fs->id != id)
 801e7bc:	687b      	ldr	r3, [r7, #4]
 801e7be:	2b00      	cmp	r3, #0
 801e7c0:	d008      	beq.n	801e7d4 <validate+0x24>
 801e7c2:	687b      	ldr	r3, [r7, #4]
 801e7c4:	781b      	ldrb	r3, [r3, #0]
 801e7c6:	2b00      	cmp	r3, #0
 801e7c8:	d004      	beq.n	801e7d4 <validate+0x24>
 801e7ca:	687b      	ldr	r3, [r7, #4]
 801e7cc:	88db      	ldrh	r3, [r3, #6]
 801e7ce:	887a      	ldrh	r2, [r7, #2]
 801e7d0:	429a      	cmp	r2, r3
 801e7d2:	d002      	beq.n	801e7da <validate+0x2a>
		return FR_INVALID_OBJECT;
 801e7d4:	f04f 0309 	mov.w	r3, #9
 801e7d8:	e00f      	b.n	801e7fa <validate+0x4a>

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drive) & STA_NOINIT)
 801e7da:	687b      	ldr	r3, [r7, #4]
 801e7dc:	785b      	ldrb	r3, [r3, #1]
 801e7de:	4618      	mov	r0, r3
 801e7e0:	f7e6 fe1a 	bl	8005418 <disk_status>
 801e7e4:	4603      	mov	r3, r0
 801e7e6:	f003 0301 	and.w	r3, r3, #1
 801e7ea:	b2db      	uxtb	r3, r3
 801e7ec:	2b00      	cmp	r3, #0
 801e7ee:	d002      	beq.n	801e7f6 <validate+0x46>
		return FR_NOT_READY;
 801e7f0:	f04f 0303 	mov.w	r3, #3
 801e7f4:	e001      	b.n	801e7fa <validate+0x4a>

	return FR_OK;
 801e7f6:	f04f 0300 	mov.w	r3, #0
}
 801e7fa:	4618      	mov	r0, r3
 801e7fc:	f107 0708 	add.w	r7, r7, #8
 801e800:	46bd      	mov	sp, r7
 801e802:	bd80      	pop	{r7, pc}

0801e804 <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
 801e804:	b480      	push	{r7}
 801e806:	b085      	sub	sp, #20
 801e808:	af00      	add	r7, sp, #0
 801e80a:	4603      	mov	r3, r0
 801e80c:	6039      	str	r1, [r7, #0]
 801e80e:	71fb      	strb	r3, [r7, #7]
	FATFS *rfs;


	if (vol >= _DRIVES)				/* Check if the drive number is valid */
 801e810:	79fb      	ldrb	r3, [r7, #7]
 801e812:	2b00      	cmp	r3, #0
 801e814:	d002      	beq.n	801e81c <f_mount+0x18>
		return FR_INVALID_DRIVE;
 801e816:	f04f 030b 	mov.w	r3, #11
 801e81a:	e01f      	b.n	801e85c <f_mount+0x58>
	rfs = FatFs[vol];				/* Get current fs object */
 801e81c:	79fa      	ldrb	r2, [r7, #7]
 801e81e:	f241 03e8 	movw	r3, #4328	; 0x10e8
 801e822:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e826:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801e82a:	60fb      	str	r3, [r7, #12]

	if (rfs) {
 801e82c:	68fb      	ldr	r3, [r7, #12]
 801e82e:	2b00      	cmp	r3, #0
 801e830:	d003      	beq.n	801e83a <f_mount+0x36>
#if _FS_REENTRANT					/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;			/* Clear old fs object */
 801e832:	68fb      	ldr	r3, [r7, #12]
 801e834:	f04f 0200 	mov.w	r2, #0
 801e838:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
 801e83a:	683b      	ldr	r3, [r7, #0]
 801e83c:	2b00      	cmp	r3, #0
 801e83e:	d003      	beq.n	801e848 <f_mount+0x44>
		fs->fs_type = 0;			/* Clear new fs object */
 801e840:	683b      	ldr	r3, [r7, #0]
 801e842:	f04f 0200 	mov.w	r2, #0
 801e846:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT					/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;				/* Register new fs object */
 801e848:	79fa      	ldrb	r2, [r7, #7]
 801e84a:	f241 03e8 	movw	r3, #4328	; 0x10e8
 801e84e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e852:	6839      	ldr	r1, [r7, #0]
 801e854:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	return FR_OK;
 801e858:	f04f 0300 	mov.w	r3, #0
}
 801e85c:	4618      	mov	r0, r3
 801e85e:	f107 0714 	add.w	r7, r7, #20
 801e862:	46bd      	mov	sp, r7
 801e864:	bc80      	pop	{r7}
 801e866:	4770      	bx	lr

0801e868 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const XCHAR *path,	/* Pointer to the file name */
	BYTE mode			/*Access mode and file open mode flags, mcg changed name to modearg */
)
{
 801e868:	b580      	push	{r7, lr}
 801e86a:	b092      	sub	sp, #72	; 0x48
 801e86c:	af00      	add	r7, sp, #0
 801e86e:	60f8      	str	r0, [r7, #12]
 801e870:	60b9      	str	r1, [r7, #8]
 801e872:	4613      	mov	r3, r2
 801e874:	71fb      	strb	r3, [r7, #7]
	BYTE *dir;
//        BYTE mode; //mcg

//      mode = modearg; //mcg using local var to try ad prevent hard fault exception that occurred when using mode arg directly

	fp->fs = NULL;		/* Clear file object */
 801e876:	68fb      	ldr	r3, [r7, #12]
 801e878:	f04f 0200 	mov.w	r2, #0
 801e87c:	601a      	str	r2, [r3, #0]
#if !_FS_READONLY
	mode &= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
 801e87e:	79fb      	ldrb	r3, [r7, #7]
 801e880:	f003 031f 	and.w	r3, r3, #31
 801e884:	71fb      	strb	r3, [r7, #7]
	res = auto_mount(&path, &dj.fs, (BYTE)(mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)));
 801e886:	79fb      	ldrb	r3, [r7, #7]
 801e888:	f003 031e 	and.w	r3, r3, #30
 801e88c:	b2db      	uxtb	r3, r3
 801e88e:	f107 0108 	add.w	r1, r7, #8
 801e892:	f107 021c 	add.w	r2, r7, #28
 801e896:	4608      	mov	r0, r1
 801e898:	4611      	mov	r1, r2
 801e89a:	461a      	mov	r2, r3
 801e89c:	f7ff fcf8 	bl	801e290 <auto_mount>
 801e8a0:	4603      	mov	r3, r0
 801e8a2:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
#else
	mode &= FA_READ;
	res = auto_mount(&path, &dj.fs, 0);
#endif
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 801e8a6:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801e8aa:	2b00      	cmp	r3, #0
 801e8ac:	d002      	beq.n	801e8b4 <f_open+0x4c>
 801e8ae:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801e8b2:	e185      	b.n	801ebc0 <f_open+0x358>
	INITBUF(dj, sfn, lfn);
 801e8b4:	f107 0310 	add.w	r3, r7, #16
 801e8b8:	637b      	str	r3, [r7, #52]	; 0x34
	res = follow_path(&dj, path);	/* Follow the file path */
 801e8ba:	68bb      	ldr	r3, [r7, #8]
 801e8bc:	f107 021c 	add.w	r2, r7, #28
 801e8c0:	4610      	mov	r0, r2
 801e8c2:	4619      	mov	r1, r3
 801e8c4:	f7ff fbf8 	bl	801e0b8 <follow_path>
 801e8c8:	4603      	mov	r3, r0
 801e8ca:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

#if !_FS_READONLY
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 801e8ce:	79fb      	ldrb	r3, [r7, #7]
 801e8d0:	f003 031c 	and.w	r3, r3, #28
 801e8d4:	2b00      	cmp	r3, #0
 801e8d6:	f000 80f0 	beq.w	801eaba <f_open+0x252>
		DWORD ps, cl;

		if (res != FR_OK) {			/* No file, create new */
 801e8da:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801e8de:	2b00      	cmp	r3, #0
 801e8e0:	d019      	beq.n	801e916 <f_open+0xae>
			if (res == FR_NO_FILE)	/* There is no file to open, create a new entry */
 801e8e2:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801e8e6:	2b04      	cmp	r3, #4
 801e8e8:	d107      	bne.n	801e8fa <f_open+0x92>
				res = dir_register(&dj);
 801e8ea:	f107 031c 	add.w	r3, r7, #28
 801e8ee:	4618      	mov	r0, r3
 801e8f0:	f7ff f97e 	bl	801dbf0 <dir_register>
 801e8f4:	4603      	mov	r3, r0
 801e8f6:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			if (res != FR_OK) LEAVE_FF(dj.fs, res);
 801e8fa:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801e8fe:	2b00      	cmp	r3, #0
 801e900:	d002      	beq.n	801e908 <f_open+0xa0>
 801e902:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801e906:	e15b      	b.n	801ebc0 <f_open+0x358>
			mode |= FA_CREATE_ALWAYS;
 801e908:	79fb      	ldrb	r3, [r7, #7]
 801e90a:	f043 0308 	orr.w	r3, r3, #8
 801e90e:	71fb      	strb	r3, [r7, #7]
			dir = dj.dir;			/* Created entry (SFN entry) */
 801e910:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e912:	643b      	str	r3, [r7, #64]	; 0x40
 801e914:	e099      	b.n	801ea4a <f_open+0x1e2>
		}
		else {						/* Any object is already existing */
			if (mode & FA_CREATE_NEW)			/* Cannot create new */
 801e916:	79fb      	ldrb	r3, [r7, #7]
 801e918:	f003 0304 	and.w	r3, r3, #4
 801e91c:	2b00      	cmp	r3, #0
 801e91e:	d002      	beq.n	801e926 <f_open+0xbe>
				LEAVE_FF(dj.fs, FR_EXIST);
 801e920:	f04f 0308 	mov.w	r3, #8
 801e924:	e14c      	b.n	801ebc0 <f_open+0x358>
			dir = dj.dir;
 801e926:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e928:	643b      	str	r3, [r7, #64]	; 0x40
			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
 801e92a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e92c:	2b00      	cmp	r3, #0
 801e92e:	d007      	beq.n	801e940 <f_open+0xd8>
 801e930:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e932:	f103 030b 	add.w	r3, r3, #11
 801e936:	781b      	ldrb	r3, [r3, #0]
 801e938:	f003 0311 	and.w	r3, r3, #17
 801e93c:	2b00      	cmp	r3, #0
 801e93e:	d002      	beq.n	801e946 <f_open+0xde>
				LEAVE_FF(dj.fs, FR_DENIED);
 801e940:	f04f 0307 	mov.w	r3, #7
 801e944:	e13c      	b.n	801ebc0 <f_open+0x358>
			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
 801e946:	79fb      	ldrb	r3, [r7, #7]
 801e948:	f003 0308 	and.w	r3, r3, #8
 801e94c:	2b00      	cmp	r3, #0
 801e94e:	d07c      	beq.n	801ea4a <f_open+0x1e2>
				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start cluster */
 801e950:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e952:	f103 0315 	add.w	r3, r3, #21
 801e956:	781b      	ldrb	r3, [r3, #0]
 801e958:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e95c:	b29a      	uxth	r2, r3
 801e95e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e960:	f103 0314 	add.w	r3, r3, #20
 801e964:	781b      	ldrb	r3, [r3, #0]
 801e966:	4313      	orrs	r3, r2
 801e968:	b29b      	uxth	r3, r3
 801e96a:	b29b      	uxth	r3, r3
 801e96c:	ea4f 4203 	mov.w	r2, r3, lsl #16
 801e970:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e972:	f103 031b 	add.w	r3, r3, #27
 801e976:	781b      	ldrb	r3, [r3, #0]
 801e978:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801e97c:	b299      	uxth	r1, r3
 801e97e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e980:	f103 031a 	add.w	r3, r3, #26
 801e984:	781b      	ldrb	r3, [r3, #0]
 801e986:	430b      	orrs	r3, r1
 801e988:	b29b      	uxth	r3, r3
 801e98a:	b29b      	uxth	r3, r3
 801e98c:	4313      	orrs	r3, r2
 801e98e:	63fb      	str	r3, [r7, #60]	; 0x3c
				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
 801e990:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e992:	f103 0314 	add.w	r3, r3, #20
 801e996:	f04f 0200 	mov.w	r2, #0
 801e99a:	701a      	strb	r2, [r3, #0]
 801e99c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e99e:	f103 0315 	add.w	r3, r3, #21
 801e9a2:	f04f 0200 	mov.w	r2, #0
 801e9a6:	701a      	strb	r2, [r3, #0]
				ST_WORD(dir+DIR_FstClusLO, 0);
 801e9a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e9aa:	f103 031a 	add.w	r3, r3, #26
 801e9ae:	f04f 0200 	mov.w	r2, #0
 801e9b2:	701a      	strb	r2, [r3, #0]
 801e9b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e9b6:	f103 031b 	add.w	r3, r3, #27
 801e9ba:	f04f 0200 	mov.w	r2, #0
 801e9be:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
 801e9c0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e9c2:	f103 031c 	add.w	r3, r3, #28
 801e9c6:	f04f 0200 	mov.w	r2, #0
 801e9ca:	701a      	strb	r2, [r3, #0]
 801e9cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e9ce:	f103 031d 	add.w	r3, r3, #29
 801e9d2:	f04f 0200 	mov.w	r2, #0
 801e9d6:	701a      	strb	r2, [r3, #0]
 801e9d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e9da:	f103 031e 	add.w	r3, r3, #30
 801e9de:	f04f 0200 	mov.w	r2, #0
 801e9e2:	701a      	strb	r2, [r3, #0]
 801e9e4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e9e6:	f103 031f 	add.w	r3, r3, #31
 801e9ea:	f04f 0200 	mov.w	r2, #0
 801e9ee:	701a      	strb	r2, [r3, #0]
				dj.fs->wflag = 1;
 801e9f0:	69fb      	ldr	r3, [r7, #28]
 801e9f2:	f04f 0201 	mov.w	r2, #1
 801e9f6:	711a      	strb	r2, [r3, #4]
				ps = dj.fs->winsect;			/* Remove the cluster chain */
 801e9f8:	69fb      	ldr	r3, [r7, #28]
 801e9fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801e9fc:	63bb      	str	r3, [r7, #56]	; 0x38
				if (cl) {
 801e9fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ea00:	2b00      	cmp	r3, #0
 801ea02:	d013      	beq.n	801ea2c <f_open+0x1c4>
					res = remove_chain(dj.fs, cl);
 801ea04:	69fb      	ldr	r3, [r7, #28]
 801ea06:	4618      	mov	r0, r3
 801ea08:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801ea0a:	f7fe fdc9 	bl	801d5a0 <remove_chain>
 801ea0e:	4603      	mov	r3, r0
 801ea10:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
					if (res) LEAVE_FF(dj.fs, res);
 801ea14:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ea18:	2b00      	cmp	r3, #0
 801ea1a:	d002      	beq.n	801ea22 <f_open+0x1ba>
 801ea1c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ea20:	e0ce      	b.n	801ebc0 <f_open+0x358>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 801ea22:	69fb      	ldr	r3, [r7, #28]
 801ea24:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801ea26:	f102 32ff 	add.w	r2, r2, #4294967295
 801ea2a:	60da      	str	r2, [r3, #12]
				}
				res = move_window(dj.fs, ps);
 801ea2c:	69fb      	ldr	r3, [r7, #28]
 801ea2e:	4618      	mov	r0, r3
 801ea30:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801ea32:	f7fe fa57 	bl	801cee4 <move_window>
 801ea36:	4603      	mov	r3, r0
 801ea38:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
				if (res != FR_OK) LEAVE_FF(dj.fs, res);
 801ea3c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ea40:	2b00      	cmp	r3, #0
 801ea42:	d002      	beq.n	801ea4a <f_open+0x1e2>
 801ea44:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ea48:	e0ba      	b.n	801ebc0 <f_open+0x358>
			}
		}
		if (mode & FA_CREATE_ALWAYS) {
 801ea4a:	79fb      	ldrb	r3, [r7, #7]
 801ea4c:	f003 0308 	and.w	r3, r3, #8
 801ea50:	2b00      	cmp	r3, #0
 801ea52:	d05a      	beq.n	801eb0a <f_open+0x2a2>
			dir[DIR_Attr] = 0;					/* Reset attribute */
 801ea54:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ea56:	f103 030b 	add.w	r3, r3, #11
 801ea5a:	f04f 0200 	mov.w	r2, #0
 801ea5e:	701a      	strb	r2, [r3, #0]
			ps = get_fattime();
 801ea60:	f003 fab4 	bl	8021fcc <get_fattime>
 801ea64:	4603      	mov	r3, r0
 801ea66:	63bb      	str	r3, [r7, #56]	; 0x38
			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 801ea68:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ea6a:	f103 030e 	add.w	r3, r3, #14
 801ea6e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801ea70:	b2d2      	uxtb	r2, r2
 801ea72:	701a      	strb	r2, [r3, #0]
 801ea74:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ea76:	f103 030f 	add.w	r3, r3, #15
 801ea7a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801ea7c:	b292      	uxth	r2, r2
 801ea7e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 801ea82:	b292      	uxth	r2, r2
 801ea84:	b2d2      	uxtb	r2, r2
 801ea86:	701a      	strb	r2, [r3, #0]
 801ea88:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ea8a:	f103 0310 	add.w	r3, r3, #16
 801ea8e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801ea90:	ea4f 4212 	mov.w	r2, r2, lsr #16
 801ea94:	b2d2      	uxtb	r2, r2
 801ea96:	701a      	strb	r2, [r3, #0]
 801ea98:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ea9a:	f103 0311 	add.w	r3, r3, #17
 801ea9e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801eaa0:	ea4f 6212 	mov.w	r2, r2, lsr #24
 801eaa4:	b2d2      	uxtb	r2, r2
 801eaa6:	701a      	strb	r2, [r3, #0]
			dj.fs->wflag = 1;
 801eaa8:	69fb      	ldr	r3, [r7, #28]
 801eaaa:	f04f 0201 	mov.w	r2, #1
 801eaae:	711a      	strb	r2, [r3, #4]
			mode |= FA__WRITTEN;				/* Set file changed flag */
 801eab0:	79fb      	ldrb	r3, [r7, #7]
 801eab2:	f043 0320 	orr.w	r3, r3, #32
 801eab6:	71fb      	strb	r3, [r7, #7]
 801eab8:	e027      	b.n	801eb0a <f_open+0x2a2>
		}
	}
	/* Open an existing file */
	else {
#endif /* !_FS_READONLY */
		if (res != FR_OK) LEAVE_FF(dj.fs, res);	/* Follow failed */
 801eaba:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801eabe:	2b00      	cmp	r3, #0
 801eac0:	d002      	beq.n	801eac8 <f_open+0x260>
 801eac2:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801eac6:	e07b      	b.n	801ebc0 <f_open+0x358>
		dir = dj.dir;
 801eac8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801eaca:	643b      	str	r3, [r7, #64]	; 0x40
		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
 801eacc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eace:	2b00      	cmp	r3, #0
 801ead0:	d007      	beq.n	801eae2 <f_open+0x27a>
 801ead2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ead4:	f103 030b 	add.w	r3, r3, #11
 801ead8:	781b      	ldrb	r3, [r3, #0]
 801eada:	f003 0310 	and.w	r3, r3, #16
 801eade:	2b00      	cmp	r3, #0
 801eae0:	d002      	beq.n	801eae8 <f_open+0x280>
			LEAVE_FF(dj.fs, FR_NO_FILE);
 801eae2:	f04f 0304 	mov.w	r3, #4
 801eae6:	e06b      	b.n	801ebc0 <f_open+0x358>
#if !_FS_READONLY
		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 801eae8:	79fb      	ldrb	r3, [r7, #7]
 801eaea:	f003 0302 	and.w	r3, r3, #2
 801eaee:	2b00      	cmp	r3, #0
 801eaf0:	d00b      	beq.n	801eb0a <f_open+0x2a2>
 801eaf2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eaf4:	f103 030b 	add.w	r3, r3, #11
 801eaf8:	781b      	ldrb	r3, [r3, #0]
 801eafa:	f003 0301 	and.w	r3, r3, #1
 801eafe:	b2db      	uxtb	r3, r3
 801eb00:	2b00      	cmp	r3, #0
 801eb02:	d002      	beq.n	801eb0a <f_open+0x2a2>
			LEAVE_FF(dj.fs, FR_DENIED);
 801eb04:	f04f 0307 	mov.w	r3, #7
 801eb08:	e05a      	b.n	801ebc0 <f_open+0x358>
	}
	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 801eb0a:	69fb      	ldr	r3, [r7, #28]
 801eb0c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801eb0e:	68fb      	ldr	r3, [r7, #12]
 801eb10:	61da      	str	r2, [r3, #28]
	fp->dir_ptr = dj.dir;
 801eb12:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801eb14:	68fb      	ldr	r3, [r7, #12]
 801eb16:	621a      	str	r2, [r3, #32]
#endif
	fp->flag = mode;					/* File access mode */
 801eb18:	68fb      	ldr	r3, [r7, #12]
 801eb1a:	79fa      	ldrb	r2, [r7, #7]
 801eb1c:	719a      	strb	r2, [r3, #6]
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 801eb1e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eb20:	f103 0315 	add.w	r3, r3, #21
 801eb24:	781b      	ldrb	r3, [r3, #0]
 801eb26:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801eb2a:	b29a      	uxth	r2, r3
 801eb2c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eb2e:	f103 0314 	add.w	r3, r3, #20
 801eb32:	781b      	ldrb	r3, [r3, #0]
 801eb34:	4313      	orrs	r3, r2
 801eb36:	b29b      	uxth	r3, r3
 801eb38:	b29b      	uxth	r3, r3
 801eb3a:	ea4f 4203 	mov.w	r2, r3, lsl #16
 801eb3e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eb40:	f103 031b 	add.w	r3, r3, #27
 801eb44:	781b      	ldrb	r3, [r3, #0]
 801eb46:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801eb4a:	b299      	uxth	r1, r3
 801eb4c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eb4e:	f103 031a 	add.w	r3, r3, #26
 801eb52:	781b      	ldrb	r3, [r3, #0]
 801eb54:	430b      	orrs	r3, r1
 801eb56:	b29b      	uxth	r3, r3
 801eb58:	b29b      	uxth	r3, r3
 801eb5a:	431a      	orrs	r2, r3
	}
	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
	fp->dir_ptr = dj.dir;
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
 801eb5c:	68fb      	ldr	r3, [r7, #12]
 801eb5e:	611a      	str	r2, [r3, #16]
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 801eb60:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eb62:	f103 031f 	add.w	r3, r3, #31
 801eb66:	781b      	ldrb	r3, [r3, #0]
 801eb68:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801eb6c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eb6e:	f103 031e 	add.w	r3, r3, #30
 801eb72:	781b      	ldrb	r3, [r3, #0]
 801eb74:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801eb78:	431a      	orrs	r2, r3
 801eb7a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eb7c:	f103 031d 	add.w	r3, r3, #29
 801eb80:	781b      	ldrb	r3, [r3, #0]
 801eb82:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801eb86:	431a      	orrs	r2, r3
 801eb88:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801eb8a:	f103 031c 	add.w	r3, r3, #28
 801eb8e:	781b      	ldrb	r3, [r3, #0]
 801eb90:	431a      	orrs	r2, r3
 801eb92:	68fb      	ldr	r3, [r7, #12]
 801eb94:	60da      	str	r2, [r3, #12]
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
 801eb96:	68fb      	ldr	r3, [r7, #12]
 801eb98:	f04f 0200 	mov.w	r2, #0
 801eb9c:	609a      	str	r2, [r3, #8]
 801eb9e:	68fb      	ldr	r3, [r7, #12]
 801eba0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 801eba4:	71da      	strb	r2, [r3, #7]
	fp->dsect = 0;
 801eba6:	68fb      	ldr	r3, [r7, #12]
 801eba8:	f04f 0200 	mov.w	r2, #0
 801ebac:	619a      	str	r2, [r3, #24]
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
 801ebae:	69fa      	ldr	r2, [r7, #28]
 801ebb0:	68fb      	ldr	r3, [r7, #12]
 801ebb2:	601a      	str	r2, [r3, #0]
 801ebb4:	69fb      	ldr	r3, [r7, #28]
 801ebb6:	88da      	ldrh	r2, [r3, #6]
 801ebb8:	68fb      	ldr	r3, [r7, #12]
 801ebba:	809a      	strh	r2, [r3, #4]

	LEAVE_FF(dj.fs, FR_OK);
 801ebbc:	f04f 0300 	mov.w	r3, #0
}
 801ebc0:	4618      	mov	r0, r3
 801ebc2:	f107 0748 	add.w	r7, r7, #72	; 0x48
 801ebc6:	46bd      	mov	sp, r7
 801ebc8:	bd80      	pop	{r7, pc}
 801ebca:	bf00      	nop

0801ebcc <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
 801ebcc:	b580      	push	{r7, lr}
 801ebce:	b08c      	sub	sp, #48	; 0x30
 801ebd0:	af00      	add	r7, sp, #0
 801ebd2:	60f8      	str	r0, [r7, #12]
 801ebd4:	60b9      	str	r1, [r7, #8]
 801ebd6:	607a      	str	r2, [r7, #4]
 801ebd8:	603b      	str	r3, [r7, #0]
	FRESULT res;
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE *rbuff = buff;
 801ebda:	68bb      	ldr	r3, [r7, #8]
 801ebdc:	627b      	str	r3, [r7, #36]	; 0x24


	*br = 0;
 801ebde:	683b      	ldr	r3, [r7, #0]
 801ebe0:	f04f 0200 	mov.w	r2, #0
 801ebe4:	601a      	str	r2, [r3, #0]

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
 801ebe6:	68fb      	ldr	r3, [r7, #12]
 801ebe8:	681a      	ldr	r2, [r3, #0]
 801ebea:	68fb      	ldr	r3, [r7, #12]
 801ebec:	889b      	ldrh	r3, [r3, #4]
 801ebee:	4610      	mov	r0, r2
 801ebf0:	4619      	mov	r1, r3
 801ebf2:	f7ff fddd 	bl	801e7b0 <validate>
 801ebf6:	4603      	mov	r3, r0
 801ebf8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 801ebfc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801ec00:	2b00      	cmp	r3, #0
 801ec02:	d002      	beq.n	801ec0a <f_read+0x3e>
 801ec04:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801ec08:	e164      	b.n	801eed4 <f_read+0x308>
	if (fp->flag & FA__ERROR)						/* Check abort flag */
 801ec0a:	68fb      	ldr	r3, [r7, #12]
 801ec0c:	799b      	ldrb	r3, [r3, #6]
 801ec0e:	b2db      	uxtb	r3, r3
 801ec10:	b25b      	sxtb	r3, r3
 801ec12:	2b00      	cmp	r3, #0
 801ec14:	da02      	bge.n	801ec1c <f_read+0x50>
		LEAVE_FF(fp->fs, FR_INT_ERR);
 801ec16:	f04f 0302 	mov.w	r3, #2
 801ec1a:	e15b      	b.n	801eed4 <f_read+0x308>
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
 801ec1c:	68fb      	ldr	r3, [r7, #12]
 801ec1e:	799b      	ldrb	r3, [r3, #6]
 801ec20:	f003 0301 	and.w	r3, r3, #1
 801ec24:	2b00      	cmp	r3, #0
 801ec26:	d102      	bne.n	801ec2e <f_read+0x62>
		LEAVE_FF(fp->fs, FR_DENIED);
 801ec28:	f04f 0307 	mov.w	r3, #7
 801ec2c:	e152      	b.n	801eed4 <f_read+0x308>
	remain = fp->fsize - fp->fptr;
 801ec2e:	68fb      	ldr	r3, [r7, #12]
 801ec30:	68da      	ldr	r2, [r3, #12]
 801ec32:	68fb      	ldr	r3, [r7, #12]
 801ec34:	689b      	ldr	r3, [r3, #8]
 801ec36:	1ad3      	subs	r3, r2, r3
 801ec38:	61fb      	str	r3, [r7, #28]
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
 801ec3a:	687a      	ldr	r2, [r7, #4]
 801ec3c:	69fb      	ldr	r3, [r7, #28]
 801ec3e:	429a      	cmp	r2, r3
 801ec40:	f240 8142 	bls.w	801eec8 <f_read+0x2fc>
 801ec44:	69fb      	ldr	r3, [r7, #28]
 801ec46:	607b      	str	r3, [r7, #4]

	for ( ;  btr;									/* Repeat until all data transferred */
 801ec48:	e13e      	b.n	801eec8 <f_read+0x2fc>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 801ec4a:	68fb      	ldr	r3, [r7, #12]
 801ec4c:	689b      	ldr	r3, [r3, #8]
 801ec4e:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801ec52:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801ec56:	2b00      	cmp	r3, #0
 801ec58:	f040 8103 	bne.w	801ee62 <f_read+0x296>
			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 801ec5c:	68fb      	ldr	r3, [r7, #12]
 801ec5e:	79da      	ldrb	r2, [r3, #7]
 801ec60:	68fb      	ldr	r3, [r7, #12]
 801ec62:	681b      	ldr	r3, [r3, #0]
 801ec64:	789b      	ldrb	r3, [r3, #2]
 801ec66:	429a      	cmp	r2, r3
 801ec68:	d332      	bcc.n	801ecd0 <f_read+0x104>
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
 801ec6a:	68fb      	ldr	r3, [r7, #12]
 801ec6c:	689b      	ldr	r3, [r3, #8]
					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
 801ec6e:	2b00      	cmp	r3, #0
 801ec70:	d102      	bne.n	801ec78 <f_read+0xac>
 801ec72:	68fb      	ldr	r3, [r7, #12]
 801ec74:	691b      	ldr	r3, [r3, #16]
 801ec76:	e008      	b.n	801ec8a <f_read+0xbe>
 801ec78:	68fb      	ldr	r3, [r7, #12]
 801ec7a:	681a      	ldr	r2, [r3, #0]
 801ec7c:	68fb      	ldr	r3, [r7, #12]
 801ec7e:	695b      	ldr	r3, [r3, #20]
 801ec80:	4610      	mov	r0, r2
 801ec82:	4619      	mov	r1, r3
 801ec84:	f7fe fa58 	bl	801d138 <get_fat>
 801ec88:	4603      	mov	r3, r0

	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
 801ec8a:	61bb      	str	r3, [r7, #24]
					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
 801ec8c:	69bb      	ldr	r3, [r7, #24]
 801ec8e:	2b01      	cmp	r3, #1
 801ec90:	d809      	bhi.n	801eca6 <f_read+0xda>
 801ec92:	68fb      	ldr	r3, [r7, #12]
 801ec94:	799b      	ldrb	r3, [r3, #6]
 801ec96:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801ec9a:	b2da      	uxtb	r2, r3
 801ec9c:	68fb      	ldr	r3, [r7, #12]
 801ec9e:	719a      	strb	r2, [r3, #6]
 801eca0:	f04f 0302 	mov.w	r3, #2
 801eca4:	e116      	b.n	801eed4 <f_read+0x308>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 801eca6:	69bb      	ldr	r3, [r7, #24]
 801eca8:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ecac:	d109      	bne.n	801ecc2 <f_read+0xf6>
 801ecae:	68fb      	ldr	r3, [r7, #12]
 801ecb0:	799b      	ldrb	r3, [r3, #6]
 801ecb2:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801ecb6:	b2da      	uxtb	r2, r3
 801ecb8:	68fb      	ldr	r3, [r7, #12]
 801ecba:	719a      	strb	r2, [r3, #6]
 801ecbc:	f04f 0301 	mov.w	r3, #1
 801ecc0:	e108      	b.n	801eed4 <f_read+0x308>
				fp->curr_clust = clst;				/* Update current cluster */
 801ecc2:	68fb      	ldr	r3, [r7, #12]
 801ecc4:	69ba      	ldr	r2, [r7, #24]
 801ecc6:	615a      	str	r2, [r3, #20]
				fp->csect = 0;						/* Reset sector offset in the cluster */
 801ecc8:	68fb      	ldr	r3, [r7, #12]
 801ecca:	f04f 0200 	mov.w	r2, #0
 801ecce:	71da      	strb	r2, [r3, #7]
			}
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
 801ecd0:	68fb      	ldr	r3, [r7, #12]
 801ecd2:	681a      	ldr	r2, [r3, #0]
 801ecd4:	68fb      	ldr	r3, [r7, #12]
 801ecd6:	695b      	ldr	r3, [r3, #20]
 801ecd8:	4610      	mov	r0, r2
 801ecda:	4619      	mov	r1, r3
 801ecdc:	f7fe fd48 	bl	801d770 <clust2sect>
 801ece0:	4603      	mov	r3, r0
 801ece2:	617b      	str	r3, [r7, #20]
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 801ece4:	697b      	ldr	r3, [r7, #20]
 801ece6:	2b00      	cmp	r3, #0
 801ece8:	d109      	bne.n	801ecfe <f_read+0x132>
 801ecea:	68fb      	ldr	r3, [r7, #12]
 801ecec:	799b      	ldrb	r3, [r3, #6]
 801ecee:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801ecf2:	b2da      	uxtb	r2, r3
 801ecf4:	68fb      	ldr	r3, [r7, #12]
 801ecf6:	719a      	strb	r2, [r3, #6]
 801ecf8:	f04f 0302 	mov.w	r3, #2
 801ecfc:	e0ea      	b.n	801eed4 <f_read+0x308>
			sect += fp->csect;
 801ecfe:	68fb      	ldr	r3, [r7, #12]
 801ed00:	79db      	ldrb	r3, [r3, #7]
 801ed02:	697a      	ldr	r2, [r7, #20]
 801ed04:	18d3      	adds	r3, r2, r3
 801ed06:	617b      	str	r3, [r7, #20]
			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
 801ed08:	687b      	ldr	r3, [r7, #4]
 801ed0a:	ea4f 2353 	mov.w	r3, r3, lsr #9
 801ed0e:	62bb      	str	r3, [r7, #40]	; 0x28
			if (cc) {								/* Read maximum contiguous sectors directly */
 801ed10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ed12:	2b00      	cmp	r3, #0
 801ed14:	d053      	beq.n	801edbe <f_read+0x1f2>
				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 801ed16:	68fb      	ldr	r3, [r7, #12]
 801ed18:	79db      	ldrb	r3, [r3, #7]
 801ed1a:	461a      	mov	r2, r3
 801ed1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ed1e:	18d2      	adds	r2, r2, r3
 801ed20:	68fb      	ldr	r3, [r7, #12]
 801ed22:	681b      	ldr	r3, [r3, #0]
 801ed24:	789b      	ldrb	r3, [r3, #2]
 801ed26:	429a      	cmp	r2, r3
 801ed28:	d907      	bls.n	801ed3a <f_read+0x16e>
					cc = fp->fs->csize - fp->csect;
 801ed2a:	68fb      	ldr	r3, [r7, #12]
 801ed2c:	681b      	ldr	r3, [r3, #0]
 801ed2e:	789b      	ldrb	r3, [r3, #2]
 801ed30:	461a      	mov	r2, r3
 801ed32:	68fb      	ldr	r3, [r7, #12]
 801ed34:	79db      	ldrb	r3, [r3, #7]
 801ed36:	1ad3      	subs	r3, r2, r3
 801ed38:	62bb      	str	r3, [r7, #40]	; 0x28
				if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
 801ed3a:	68fb      	ldr	r3, [r7, #12]
 801ed3c:	681b      	ldr	r3, [r3, #0]
 801ed3e:	785a      	ldrb	r2, [r3, #1]
 801ed40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ed42:	b2db      	uxtb	r3, r3
 801ed44:	4610      	mov	r0, r2
 801ed46:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801ed48:	697a      	ldr	r2, [r7, #20]
 801ed4a:	f7e6 fb7d 	bl	8005448 <disk_read>
 801ed4e:	4603      	mov	r3, r0
 801ed50:	2b00      	cmp	r3, #0
 801ed52:	d009      	beq.n	801ed68 <f_read+0x19c>
					ABORT(fp->fs, FR_DISK_ERR);
 801ed54:	68fb      	ldr	r3, [r7, #12]
 801ed56:	799b      	ldrb	r3, [r3, #6]
 801ed58:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801ed5c:	b2da      	uxtb	r2, r3
 801ed5e:	68fb      	ldr	r3, [r7, #12]
 801ed60:	719a      	strb	r2, [r3, #6]
 801ed62:	f04f 0301 	mov.w	r3, #1
 801ed66:	e0b5      	b.n	801eed4 <f_read+0x308>
#if !_FS_READONLY && _FS_MINIMIZE <= 2
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)		/* Replace one of the read sectors with cached data if it contains a dirty sector */
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)	/* Replace one of the read sectors with cached data if it contains a dirty sector */
 801ed68:	68fb      	ldr	r3, [r7, #12]
 801ed6a:	799b      	ldrb	r3, [r3, #6]
 801ed6c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801ed70:	2b00      	cmp	r3, #0
 801ed72:	d017      	beq.n	801eda4 <f_read+0x1d8>
 801ed74:	68fb      	ldr	r3, [r7, #12]
 801ed76:	699a      	ldr	r2, [r3, #24]
 801ed78:	697b      	ldr	r3, [r7, #20]
 801ed7a:	1ad2      	subs	r2, r2, r3
 801ed7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ed7e:	429a      	cmp	r2, r3
 801ed80:	d210      	bcs.n	801eda4 <f_read+0x1d8>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 801ed82:	68fb      	ldr	r3, [r7, #12]
 801ed84:	699a      	ldr	r2, [r3, #24]
 801ed86:	697b      	ldr	r3, [r7, #20]
 801ed88:	1ad3      	subs	r3, r2, r3
 801ed8a:	ea4f 2343 	mov.w	r3, r3, lsl #9
 801ed8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801ed90:	18d2      	adds	r2, r2, r3
 801ed92:	68fb      	ldr	r3, [r7, #12]
 801ed94:	f103 0324 	add.w	r3, r3, #36	; 0x24
 801ed98:	4610      	mov	r0, r2
 801ed9a:	4619      	mov	r1, r3
 801ed9c:	f44f 7200 	mov.w	r2, #512	; 0x200
 801eda0:	f7fe f802 	bl	801cda8 <mem_cpy>
#endif
#endif
				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
 801eda4:	68fb      	ldr	r3, [r7, #12]
 801eda6:	79da      	ldrb	r2, [r3, #7]
 801eda8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801edaa:	b2db      	uxtb	r3, r3
 801edac:	18d3      	adds	r3, r2, r3
 801edae:	b2da      	uxtb	r2, r3
 801edb0:	68fb      	ldr	r3, [r7, #12]
 801edb2:	71da      	strb	r2, [r3, #7]
				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 801edb4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801edb6:	ea4f 2343 	mov.w	r3, r3, lsl #9
 801edba:	62fb      	str	r3, [r7, #44]	; 0x2c
				continue;
 801edbc:	e070      	b.n	801eea0 <f_read+0x2d4>
			}
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write sector I/O buffer if needed */
 801edbe:	68fb      	ldr	r3, [r7, #12]
 801edc0:	799b      	ldrb	r3, [r3, #6]
 801edc2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801edc6:	2b00      	cmp	r3, #0
 801edc8:	d022      	beq.n	801ee10 <f_read+0x244>
				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 801edca:	68fb      	ldr	r3, [r7, #12]
 801edcc:	681b      	ldr	r3, [r3, #0]
 801edce:	7859      	ldrb	r1, [r3, #1]
 801edd0:	68fb      	ldr	r3, [r7, #12]
 801edd2:	f103 0224 	add.w	r2, r3, #36	; 0x24
 801edd6:	68fb      	ldr	r3, [r7, #12]
 801edd8:	699b      	ldr	r3, [r3, #24]
 801edda:	4608      	mov	r0, r1
 801eddc:	4611      	mov	r1, r2
 801edde:	461a      	mov	r2, r3
 801ede0:	f04f 0301 	mov.w	r3, #1
 801ede4:	f7e6 fb8e 	bl	8005504 <disk_write>
 801ede8:	4603      	mov	r3, r0
 801edea:	2b00      	cmp	r3, #0
 801edec:	d009      	beq.n	801ee02 <f_read+0x236>
					ABORT(fp->fs, FR_DISK_ERR);
 801edee:	68fb      	ldr	r3, [r7, #12]
 801edf0:	799b      	ldrb	r3, [r3, #6]
 801edf2:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801edf6:	b2da      	uxtb	r2, r3
 801edf8:	68fb      	ldr	r3, [r7, #12]
 801edfa:	719a      	strb	r2, [r3, #6]
 801edfc:	f04f 0301 	mov.w	r3, #1
 801ee00:	e068      	b.n	801eed4 <f_read+0x308>
				fp->flag &= ~FA__DIRTY;
 801ee02:	68fb      	ldr	r3, [r7, #12]
 801ee04:	799b      	ldrb	r3, [r3, #6]
 801ee06:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801ee0a:	b2da      	uxtb	r2, r3
 801ee0c:	68fb      	ldr	r3, [r7, #12]
 801ee0e:	719a      	strb	r2, [r3, #6]
			}
#endif
			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
 801ee10:	68fb      	ldr	r3, [r7, #12]
 801ee12:	699a      	ldr	r2, [r3, #24]
 801ee14:	697b      	ldr	r3, [r7, #20]
 801ee16:	429a      	cmp	r2, r3
 801ee18:	d019      	beq.n	801ee4e <f_read+0x282>
				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 801ee1a:	68fb      	ldr	r3, [r7, #12]
 801ee1c:	681b      	ldr	r3, [r3, #0]
 801ee1e:	785a      	ldrb	r2, [r3, #1]
 801ee20:	68fb      	ldr	r3, [r7, #12]
 801ee22:	f103 0324 	add.w	r3, r3, #36	; 0x24
 801ee26:	4610      	mov	r0, r2
 801ee28:	4619      	mov	r1, r3
 801ee2a:	697a      	ldr	r2, [r7, #20]
 801ee2c:	f04f 0301 	mov.w	r3, #1
 801ee30:	f7e6 fb0a 	bl	8005448 <disk_read>
 801ee34:	4603      	mov	r3, r0
 801ee36:	2b00      	cmp	r3, #0
 801ee38:	d009      	beq.n	801ee4e <f_read+0x282>
					ABORT(fp->fs, FR_DISK_ERR);
 801ee3a:	68fb      	ldr	r3, [r7, #12]
 801ee3c:	799b      	ldrb	r3, [r3, #6]
 801ee3e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801ee42:	b2da      	uxtb	r2, r3
 801ee44:	68fb      	ldr	r3, [r7, #12]
 801ee46:	719a      	strb	r2, [r3, #6]
 801ee48:	f04f 0301 	mov.w	r3, #1
 801ee4c:	e042      	b.n	801eed4 <f_read+0x308>
			}
#endif
			fp->dsect = sect;
 801ee4e:	68fb      	ldr	r3, [r7, #12]
 801ee50:	697a      	ldr	r2, [r7, #20]
 801ee52:	619a      	str	r2, [r3, #24]
			fp->csect++;							/* Next sector address in the cluster */
 801ee54:	68fb      	ldr	r3, [r7, #12]
 801ee56:	79db      	ldrb	r3, [r3, #7]
 801ee58:	f103 0301 	add.w	r3, r3, #1
 801ee5c:	b2da      	uxtb	r2, r3
 801ee5e:	68fb      	ldr	r3, [r7, #12]
 801ee60:	71da      	strb	r2, [r3, #7]
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 801ee62:	68fb      	ldr	r3, [r7, #12]
 801ee64:	689b      	ldr	r3, [r3, #8]
 801ee66:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801ee6a:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801ee6e:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 801ee72:	62fb      	str	r3, [r7, #44]	; 0x2c
		if (rcnt > btr) rcnt = btr;
 801ee74:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801ee76:	687b      	ldr	r3, [r7, #4]
 801ee78:	429a      	cmp	r2, r3
 801ee7a:	d901      	bls.n	801ee80 <f_read+0x2b4>
 801ee7c:	687b      	ldr	r3, [r7, #4]
 801ee7e:	62fb      	str	r3, [r7, #44]	; 0x2c
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 801ee80:	68fb      	ldr	r3, [r7, #12]
 801ee82:	f103 0224 	add.w	r2, r3, #36	; 0x24
 801ee86:	68fb      	ldr	r3, [r7, #12]
 801ee88:	689b      	ldr	r3, [r3, #8]
 801ee8a:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801ee8e:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801ee92:	18d2      	adds	r2, r2, r3
 801ee94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ee96:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801ee98:	4611      	mov	r1, r2
 801ee9a:	461a      	mov	r2, r3
 801ee9c:	f7fd ff84 	bl	801cda8 <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 801eea0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801eea2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801eea4:	18d3      	adds	r3, r2, r3
 801eea6:	627b      	str	r3, [r7, #36]	; 0x24
 801eea8:	68fb      	ldr	r3, [r7, #12]
 801eeaa:	689a      	ldr	r2, [r3, #8]
 801eeac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801eeae:	18d2      	adds	r2, r2, r3
 801eeb0:	68fb      	ldr	r3, [r7, #12]
 801eeb2:	609a      	str	r2, [r3, #8]
 801eeb4:	683b      	ldr	r3, [r7, #0]
 801eeb6:	681a      	ldr	r2, [r3, #0]
 801eeb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801eeba:	18d2      	adds	r2, r2, r3
 801eebc:	683b      	ldr	r3, [r7, #0]
 801eebe:	601a      	str	r2, [r3, #0]
 801eec0:	687a      	ldr	r2, [r7, #4]
 801eec2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801eec4:	1ad3      	subs	r3, r2, r3
 801eec6:	607b      	str	r3, [r7, #4]
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
 801eec8:	687b      	ldr	r3, [r7, #4]
 801eeca:	2b00      	cmp	r3, #0
 801eecc:	f47f aebd 	bne.w	801ec4a <f_read+0x7e>
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
 801eed0:	f04f 0300 	mov.w	r3, #0
}
 801eed4:	4618      	mov	r0, r3
 801eed6:	f107 0730 	add.w	r7, r7, #48	; 0x30
 801eeda:	46bd      	mov	sp, r7
 801eedc:	bd80      	pop	{r7, pc}
 801eede:	bf00      	nop

0801eee0 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
 801eee0:	b580      	push	{r7, lr}
 801eee2:	b08a      	sub	sp, #40	; 0x28
 801eee4:	af00      	add	r7, sp, #0
 801eee6:	60f8      	str	r0, [r7, #12]
 801eee8:	60b9      	str	r1, [r7, #8]
 801eeea:	607a      	str	r2, [r7, #4]
 801eeec:	603b      	str	r3, [r7, #0]
	FRESULT res;
	DWORD clst, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
 801eeee:	68bb      	ldr	r3, [r7, #8]
 801eef0:	61bb      	str	r3, [r7, #24]


	*bw = 0;
 801eef2:	683b      	ldr	r3, [r7, #0]
 801eef4:	f04f 0200 	mov.w	r2, #0
 801eef8:	601a      	str	r2, [r3, #0]

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
 801eefa:	68fb      	ldr	r3, [r7, #12]
 801eefc:	681a      	ldr	r2, [r3, #0]
 801eefe:	68fb      	ldr	r3, [r7, #12]
 801ef00:	889b      	ldrh	r3, [r3, #4]
 801ef02:	4610      	mov	r0, r2
 801ef04:	4619      	mov	r1, r3
 801ef06:	f7ff fc53 	bl	801e7b0 <validate>
 801ef0a:	4603      	mov	r3, r0
 801ef0c:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 801ef0e:	7dfb      	ldrb	r3, [r7, #23]
 801ef10:	2b00      	cmp	r3, #0
 801ef12:	d001      	beq.n	801ef18 <f_write+0x38>
 801ef14:	7dfb      	ldrb	r3, [r7, #23]
 801ef16:	e198      	b.n	801f24a <f_write+0x36a>
	if (fp->flag & FA__ERROR)						/* Check abort flag */
 801ef18:	68fb      	ldr	r3, [r7, #12]
 801ef1a:	799b      	ldrb	r3, [r3, #6]
 801ef1c:	b2db      	uxtb	r3, r3
 801ef1e:	b25b      	sxtb	r3, r3
 801ef20:	2b00      	cmp	r3, #0
 801ef22:	da02      	bge.n	801ef2a <f_write+0x4a>
		LEAVE_FF(fp->fs, FR_INT_ERR);
 801ef24:	f04f 0302 	mov.w	r3, #2
 801ef28:	e18f      	b.n	801f24a <f_write+0x36a>
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
 801ef2a:	68fb      	ldr	r3, [r7, #12]
 801ef2c:	799b      	ldrb	r3, [r3, #6]
 801ef2e:	f003 0302 	and.w	r3, r3, #2
 801ef32:	2b00      	cmp	r3, #0
 801ef34:	d102      	bne.n	801ef3c <f_write+0x5c>
		LEAVE_FF(fp->fs, FR_DENIED);
 801ef36:	f04f 0307 	mov.w	r3, #7
 801ef3a:	e186      	b.n	801f24a <f_write+0x36a>
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
 801ef3c:	68fb      	ldr	r3, [r7, #12]
 801ef3e:	68da      	ldr	r2, [r3, #12]
 801ef40:	687b      	ldr	r3, [r7, #4]
 801ef42:	18d2      	adds	r2, r2, r3
 801ef44:	68fb      	ldr	r3, [r7, #12]
 801ef46:	68db      	ldr	r3, [r3, #12]
 801ef48:	429a      	cmp	r2, r3
 801ef4a:	f080 8165 	bcs.w	801f218 <f_write+0x338>
 801ef4e:	f04f 0300 	mov.w	r3, #0
 801ef52:	607b      	str	r3, [r7, #4]

	for ( ;  btw;									/* Repeat until all data transferred */
 801ef54:	e160      	b.n	801f218 <f_write+0x338>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 801ef56:	68fb      	ldr	r3, [r7, #12]
 801ef58:	689b      	ldr	r3, [r3, #8]
 801ef5a:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801ef5e:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801ef62:	2b00      	cmp	r3, #0
 801ef64:	f040 811e 	bne.w	801f1a4 <f_write+0x2c4>
			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 801ef68:	68fb      	ldr	r3, [r7, #12]
 801ef6a:	79da      	ldrb	r2, [r3, #7]
 801ef6c:	68fb      	ldr	r3, [r7, #12]
 801ef6e:	681b      	ldr	r3, [r3, #0]
 801ef70:	789b      	ldrb	r3, [r3, #2]
 801ef72:	429a      	cmp	r2, r3
 801ef74:	d346      	bcc.n	801f004 <f_write+0x124>
				if (fp->fptr == 0) {				/* On the top of the file? */
 801ef76:	68fb      	ldr	r3, [r7, #12]
 801ef78:	689b      	ldr	r3, [r3, #8]
 801ef7a:	2b00      	cmp	r3, #0
 801ef7c:	d112      	bne.n	801efa4 <f_write+0xc4>
					clst = fp->org_clust;			/* Follow from the origin */
 801ef7e:	68fb      	ldr	r3, [r7, #12]
 801ef80:	691b      	ldr	r3, [r3, #16]
 801ef82:	627b      	str	r3, [r7, #36]	; 0x24
					if (clst == 0)					/* When there is no cluster chain, */
 801ef84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ef86:	2b00      	cmp	r3, #0
 801ef88:	d116      	bne.n	801efb8 <f_write+0xd8>
						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 801ef8a:	68fb      	ldr	r3, [r7, #12]
 801ef8c:	681b      	ldr	r3, [r3, #0]
 801ef8e:	4618      	mov	r0, r3
 801ef90:	f04f 0100 	mov.w	r1, #0
 801ef94:	f7fe fb5c 	bl	801d650 <create_chain>
 801ef98:	4603      	mov	r3, r0
 801ef9a:	627b      	str	r3, [r7, #36]	; 0x24
 801ef9c:	68fb      	ldr	r3, [r7, #12]
 801ef9e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801efa0:	611a      	str	r2, [r3, #16]
 801efa2:	e009      	b.n	801efb8 <f_write+0xd8>
				} else {							/* Middle or end of the file */
					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or streach cluster chain */
 801efa4:	68fb      	ldr	r3, [r7, #12]
 801efa6:	681a      	ldr	r2, [r3, #0]
 801efa8:	68fb      	ldr	r3, [r7, #12]
 801efaa:	695b      	ldr	r3, [r3, #20]
 801efac:	4610      	mov	r0, r2
 801efae:	4619      	mov	r1, r3
 801efb0:	f7fe fb4e 	bl	801d650 <create_chain>
 801efb4:	4603      	mov	r3, r0
 801efb6:	627b      	str	r3, [r7, #36]	; 0x24
				}
				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
 801efb8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801efba:	2b00      	cmp	r3, #0
 801efbc:	f000 8131 	beq.w	801f222 <f_write+0x342>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 801efc0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801efc2:	2b01      	cmp	r3, #1
 801efc4:	d109      	bne.n	801efda <f_write+0xfa>
 801efc6:	68fb      	ldr	r3, [r7, #12]
 801efc8:	799b      	ldrb	r3, [r3, #6]
 801efca:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801efce:	b2da      	uxtb	r2, r3
 801efd0:	68fb      	ldr	r3, [r7, #12]
 801efd2:	719a      	strb	r2, [r3, #6]
 801efd4:	f04f 0302 	mov.w	r3, #2
 801efd8:	e137      	b.n	801f24a <f_write+0x36a>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 801efda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801efdc:	f1b3 3fff 	cmp.w	r3, #4294967295
 801efe0:	d109      	bne.n	801eff6 <f_write+0x116>
 801efe2:	68fb      	ldr	r3, [r7, #12]
 801efe4:	799b      	ldrb	r3, [r3, #6]
 801efe6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801efea:	b2da      	uxtb	r2, r3
 801efec:	68fb      	ldr	r3, [r7, #12]
 801efee:	719a      	strb	r2, [r3, #6]
 801eff0:	f04f 0301 	mov.w	r3, #1
 801eff4:	e129      	b.n	801f24a <f_write+0x36a>
				fp->curr_clust = clst;				/* Update current cluster */
 801eff6:	68fb      	ldr	r3, [r7, #12]
 801eff8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801effa:	615a      	str	r2, [r3, #20]
				fp->csect = 0;						/* Reset sector address in the cluster */
 801effc:	68fb      	ldr	r3, [r7, #12]
 801effe:	f04f 0200 	mov.w	r2, #0
 801f002:	71da      	strb	r2, [r3, #7]
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to following direct transfer */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write back data buffer prior to following direct transfer */
 801f004:	68fb      	ldr	r3, [r7, #12]
 801f006:	799b      	ldrb	r3, [r3, #6]
 801f008:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801f00c:	2b00      	cmp	r3, #0
 801f00e:	d022      	beq.n	801f056 <f_write+0x176>
				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 801f010:	68fb      	ldr	r3, [r7, #12]
 801f012:	681b      	ldr	r3, [r3, #0]
 801f014:	7859      	ldrb	r1, [r3, #1]
 801f016:	68fb      	ldr	r3, [r7, #12]
 801f018:	f103 0224 	add.w	r2, r3, #36	; 0x24
 801f01c:	68fb      	ldr	r3, [r7, #12]
 801f01e:	699b      	ldr	r3, [r3, #24]
 801f020:	4608      	mov	r0, r1
 801f022:	4611      	mov	r1, r2
 801f024:	461a      	mov	r2, r3
 801f026:	f04f 0301 	mov.w	r3, #1
 801f02a:	f7e6 fa6b 	bl	8005504 <disk_write>
 801f02e:	4603      	mov	r3, r0
 801f030:	2b00      	cmp	r3, #0
 801f032:	d009      	beq.n	801f048 <f_write+0x168>
					ABORT(fp->fs, FR_DISK_ERR);
 801f034:	68fb      	ldr	r3, [r7, #12]
 801f036:	799b      	ldrb	r3, [r3, #6]
 801f038:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f03c:	b2da      	uxtb	r2, r3
 801f03e:	68fb      	ldr	r3, [r7, #12]
 801f040:	719a      	strb	r2, [r3, #6]
 801f042:	f04f 0301 	mov.w	r3, #1
 801f046:	e100      	b.n	801f24a <f_write+0x36a>
				fp->flag &= ~FA__DIRTY;
 801f048:	68fb      	ldr	r3, [r7, #12]
 801f04a:	799b      	ldrb	r3, [r3, #6]
 801f04c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801f050:	b2da      	uxtb	r2, r3
 801f052:	68fb      	ldr	r3, [r7, #12]
 801f054:	719a      	strb	r2, [r3, #6]
			}
#endif
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
 801f056:	68fb      	ldr	r3, [r7, #12]
 801f058:	681a      	ldr	r2, [r3, #0]
 801f05a:	68fb      	ldr	r3, [r7, #12]
 801f05c:	695b      	ldr	r3, [r3, #20]
 801f05e:	4610      	mov	r0, r2
 801f060:	4619      	mov	r1, r3
 801f062:	f7fe fb85 	bl	801d770 <clust2sect>
 801f066:	4603      	mov	r3, r0
 801f068:	613b      	str	r3, [r7, #16]
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 801f06a:	693b      	ldr	r3, [r7, #16]
 801f06c:	2b00      	cmp	r3, #0
 801f06e:	d109      	bne.n	801f084 <f_write+0x1a4>
 801f070:	68fb      	ldr	r3, [r7, #12]
 801f072:	799b      	ldrb	r3, [r3, #6]
 801f074:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f078:	b2da      	uxtb	r2, r3
 801f07a:	68fb      	ldr	r3, [r7, #12]
 801f07c:	719a      	strb	r2, [r3, #6]
 801f07e:	f04f 0302 	mov.w	r3, #2
 801f082:	e0e2      	b.n	801f24a <f_write+0x36a>
			sect += fp->csect;
 801f084:	68fb      	ldr	r3, [r7, #12]
 801f086:	79db      	ldrb	r3, [r3, #7]
 801f088:	693a      	ldr	r2, [r7, #16]
 801f08a:	18d3      	adds	r3, r2, r3
 801f08c:	613b      	str	r3, [r7, #16]
			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
 801f08e:	687b      	ldr	r3, [r7, #4]
 801f090:	ea4f 2353 	mov.w	r3, r3, lsr #9
 801f094:	61fb      	str	r3, [r7, #28]
			if (cc) {								/* Write maximum contiguous sectors directly */
 801f096:	69fb      	ldr	r3, [r7, #28]
 801f098:	2b00      	cmp	r3, #0
 801f09a:	d054      	beq.n	801f146 <f_write+0x266>
				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 801f09c:	68fb      	ldr	r3, [r7, #12]
 801f09e:	79db      	ldrb	r3, [r3, #7]
 801f0a0:	461a      	mov	r2, r3
 801f0a2:	69fb      	ldr	r3, [r7, #28]
 801f0a4:	18d2      	adds	r2, r2, r3
 801f0a6:	68fb      	ldr	r3, [r7, #12]
 801f0a8:	681b      	ldr	r3, [r3, #0]
 801f0aa:	789b      	ldrb	r3, [r3, #2]
 801f0ac:	429a      	cmp	r2, r3
 801f0ae:	d907      	bls.n	801f0c0 <f_write+0x1e0>
					cc = fp->fs->csize - fp->csect;
 801f0b0:	68fb      	ldr	r3, [r7, #12]
 801f0b2:	681b      	ldr	r3, [r3, #0]
 801f0b4:	789b      	ldrb	r3, [r3, #2]
 801f0b6:	461a      	mov	r2, r3
 801f0b8:	68fb      	ldr	r3, [r7, #12]
 801f0ba:	79db      	ldrb	r3, [r3, #7]
 801f0bc:	1ad3      	subs	r3, r2, r3
 801f0be:	61fb      	str	r3, [r7, #28]
				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
 801f0c0:	68fb      	ldr	r3, [r7, #12]
 801f0c2:	681b      	ldr	r3, [r3, #0]
 801f0c4:	785a      	ldrb	r2, [r3, #1]
 801f0c6:	69fb      	ldr	r3, [r7, #28]
 801f0c8:	b2db      	uxtb	r3, r3
 801f0ca:	4610      	mov	r0, r2
 801f0cc:	69b9      	ldr	r1, [r7, #24]
 801f0ce:	693a      	ldr	r2, [r7, #16]
 801f0d0:	f7e6 fa18 	bl	8005504 <disk_write>
 801f0d4:	4603      	mov	r3, r0
 801f0d6:	2b00      	cmp	r3, #0
 801f0d8:	d009      	beq.n	801f0ee <f_write+0x20e>
					ABORT(fp->fs, FR_DISK_ERR);
 801f0da:	68fb      	ldr	r3, [r7, #12]
 801f0dc:	799b      	ldrb	r3, [r3, #6]
 801f0de:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f0e2:	b2da      	uxtb	r2, r3
 801f0e4:	68fb      	ldr	r3, [r7, #12]
 801f0e6:	719a      	strb	r2, [r3, #6]
 801f0e8:	f04f 0301 	mov.w	r3, #1
 801f0ec:	e0ad      	b.n	801f24a <f_write+0x36a>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets dirty by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) {		/* Refill sector cache if it gets dirty by the direct write */
 801f0ee:	68fb      	ldr	r3, [r7, #12]
 801f0f0:	699a      	ldr	r2, [r3, #24]
 801f0f2:	693b      	ldr	r3, [r7, #16]
 801f0f4:	1ad2      	subs	r2, r2, r3
 801f0f6:	69fb      	ldr	r3, [r7, #28]
 801f0f8:	429a      	cmp	r2, r3
 801f0fa:	d217      	bcs.n	801f12c <f_write+0x24c>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 801f0fc:	68fb      	ldr	r3, [r7, #12]
 801f0fe:	f103 0224 	add.w	r2, r3, #36	; 0x24
 801f102:	68fb      	ldr	r3, [r7, #12]
 801f104:	6999      	ldr	r1, [r3, #24]
 801f106:	693b      	ldr	r3, [r7, #16]
 801f108:	1acb      	subs	r3, r1, r3
 801f10a:	ea4f 2343 	mov.w	r3, r3, lsl #9
 801f10e:	69b9      	ldr	r1, [r7, #24]
 801f110:	18cb      	adds	r3, r1, r3
 801f112:	4610      	mov	r0, r2
 801f114:	4619      	mov	r1, r3
 801f116:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f11a:	f7fd fe45 	bl	801cda8 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
 801f11e:	68fb      	ldr	r3, [r7, #12]
 801f120:	799b      	ldrb	r3, [r3, #6]
 801f122:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801f126:	b2da      	uxtb	r2, r3
 801f128:	68fb      	ldr	r3, [r7, #12]
 801f12a:	719a      	strb	r2, [r3, #6]
				}
#endif
				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
 801f12c:	68fb      	ldr	r3, [r7, #12]
 801f12e:	79da      	ldrb	r2, [r3, #7]
 801f130:	69fb      	ldr	r3, [r7, #28]
 801f132:	b2db      	uxtb	r3, r3
 801f134:	18d3      	adds	r3, r2, r3
 801f136:	b2da      	uxtb	r2, r3
 801f138:	68fb      	ldr	r3, [r7, #12]
 801f13a:	71da      	strb	r2, [r3, #7]
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 801f13c:	69fb      	ldr	r3, [r7, #28]
 801f13e:	ea4f 2343 	mov.w	r3, r3, lsl #9
 801f142:	623b      	str	r3, [r7, #32]
				continue;
 801f144:	e054      	b.n	801f1f0 <f_write+0x310>
			if (fp->fptr >= fp->fsize) {			/* Avoid silly buffer filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
 801f146:	68fb      	ldr	r3, [r7, #12]
 801f148:	699a      	ldr	r2, [r3, #24]
 801f14a:	693b      	ldr	r3, [r7, #16]
 801f14c:	429a      	cmp	r2, r3
 801f14e:	d01f      	beq.n	801f190 <f_write+0x2b0>
				if (fp->fptr < fp->fsize &&
 801f150:	68fb      	ldr	r3, [r7, #12]
 801f152:	689a      	ldr	r2, [r3, #8]
 801f154:	68fb      	ldr	r3, [r7, #12]
 801f156:	68db      	ldr	r3, [r3, #12]
 801f158:	429a      	cmp	r2, r3
 801f15a:	d219      	bcs.n	801f190 <f_write+0x2b0>
					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 801f15c:	68fb      	ldr	r3, [r7, #12]
 801f15e:	681b      	ldr	r3, [r3, #0]
 801f160:	785a      	ldrb	r2, [r3, #1]
 801f162:	68fb      	ldr	r3, [r7, #12]
 801f164:	f103 0324 	add.w	r3, r3, #36	; 0x24
 801f168:	4610      	mov	r0, r2
 801f16a:	4619      	mov	r1, r3
 801f16c:	693a      	ldr	r2, [r7, #16]
 801f16e:	f04f 0301 	mov.w	r3, #1
 801f172:	f7e6 f969 	bl	8005448 <disk_read>
 801f176:	4603      	mov	r3, r0
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
				if (fp->fptr < fp->fsize &&
 801f178:	2b00      	cmp	r3, #0
 801f17a:	d009      	beq.n	801f190 <f_write+0x2b0>
					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
 801f17c:	68fb      	ldr	r3, [r7, #12]
 801f17e:	799b      	ldrb	r3, [r3, #6]
 801f180:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f184:	b2da      	uxtb	r2, r3
 801f186:	68fb      	ldr	r3, [r7, #12]
 801f188:	719a      	strb	r2, [r3, #6]
 801f18a:	f04f 0301 	mov.w	r3, #1
 801f18e:	e05c      	b.n	801f24a <f_write+0x36a>
			}
#endif
			fp->dsect = sect;
 801f190:	68fb      	ldr	r3, [r7, #12]
 801f192:	693a      	ldr	r2, [r7, #16]
 801f194:	619a      	str	r2, [r3, #24]
			fp->csect++;							/* Next sector address in the cluster */
 801f196:	68fb      	ldr	r3, [r7, #12]
 801f198:	79db      	ldrb	r3, [r3, #7]
 801f19a:	f103 0301 	add.w	r3, r3, #1
 801f19e:	b2da      	uxtb	r2, r3
 801f1a0:	68fb      	ldr	r3, [r7, #12]
 801f1a2:	71da      	strb	r2, [r3, #7]
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
 801f1a4:	68fb      	ldr	r3, [r7, #12]
 801f1a6:	689b      	ldr	r3, [r3, #8]
 801f1a8:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801f1ac:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801f1b0:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 801f1b4:	623b      	str	r3, [r7, #32]
		if (wcnt > btw) wcnt = btw;
 801f1b6:	6a3a      	ldr	r2, [r7, #32]
 801f1b8:	687b      	ldr	r3, [r7, #4]
 801f1ba:	429a      	cmp	r2, r3
 801f1bc:	d901      	bls.n	801f1c2 <f_write+0x2e2>
 801f1be:	687b      	ldr	r3, [r7, #4]
 801f1c0:	623b      	str	r3, [r7, #32]
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 801f1c2:	68fb      	ldr	r3, [r7, #12]
 801f1c4:	f103 0224 	add.w	r2, r3, #36	; 0x24
 801f1c8:	68fb      	ldr	r3, [r7, #12]
 801f1ca:	689b      	ldr	r3, [r3, #8]
 801f1cc:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801f1d0:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801f1d4:	18d2      	adds	r2, r2, r3
 801f1d6:	6a3b      	ldr	r3, [r7, #32]
 801f1d8:	4610      	mov	r0, r2
 801f1da:	69b9      	ldr	r1, [r7, #24]
 801f1dc:	461a      	mov	r2, r3
 801f1de:	f7fd fde3 	bl	801cda8 <mem_cpy>
		fp->flag |= FA__DIRTY;
 801f1e2:	68fb      	ldr	r3, [r7, #12]
 801f1e4:	799b      	ldrb	r3, [r3, #6]
 801f1e6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801f1ea:	b2da      	uxtb	r2, r3
 801f1ec:	68fb      	ldr	r3, [r7, #12]
 801f1ee:	719a      	strb	r2, [r3, #6]
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 801f1f0:	69ba      	ldr	r2, [r7, #24]
 801f1f2:	6a3b      	ldr	r3, [r7, #32]
 801f1f4:	18d3      	adds	r3, r2, r3
 801f1f6:	61bb      	str	r3, [r7, #24]
 801f1f8:	68fb      	ldr	r3, [r7, #12]
 801f1fa:	689a      	ldr	r2, [r3, #8]
 801f1fc:	6a3b      	ldr	r3, [r7, #32]
 801f1fe:	18d2      	adds	r2, r2, r3
 801f200:	68fb      	ldr	r3, [r7, #12]
 801f202:	609a      	str	r2, [r3, #8]
 801f204:	683b      	ldr	r3, [r7, #0]
 801f206:	681a      	ldr	r2, [r3, #0]
 801f208:	6a3b      	ldr	r3, [r7, #32]
 801f20a:	18d2      	adds	r2, r2, r3
 801f20c:	683b      	ldr	r3, [r7, #0]
 801f20e:	601a      	str	r2, [r3, #0]
 801f210:	687a      	ldr	r2, [r7, #4]
 801f212:	6a3b      	ldr	r3, [r7, #32]
 801f214:	1ad3      	subs	r3, r2, r3
 801f216:	607b      	str	r3, [r7, #4]
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
 801f218:	687b      	ldr	r3, [r7, #4]
 801f21a:	2b00      	cmp	r3, #0
 801f21c:	f47f ae9b 	bne.w	801ef56 <f_write+0x76>
 801f220:	e000      	b.n	801f224 <f_write+0x344>
					if (clst == 0)					/* When there is no cluster chain, */
						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
				} else {							/* Middle or end of the file */
					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or streach cluster chain */
				}
				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
 801f222:	bf00      	nop
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 801f224:	68fb      	ldr	r3, [r7, #12]
 801f226:	689a      	ldr	r2, [r3, #8]
 801f228:	68fb      	ldr	r3, [r7, #12]
 801f22a:	68db      	ldr	r3, [r3, #12]
 801f22c:	429a      	cmp	r2, r3
 801f22e:	d903      	bls.n	801f238 <f_write+0x358>
 801f230:	68fb      	ldr	r3, [r7, #12]
 801f232:	689a      	ldr	r2, [r3, #8]
 801f234:	68fb      	ldr	r3, [r7, #12]
 801f236:	60da      	str	r2, [r3, #12]
	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
 801f238:	68fb      	ldr	r3, [r7, #12]
 801f23a:	799b      	ldrb	r3, [r3, #6]
 801f23c:	f043 0320 	orr.w	r3, r3, #32
 801f240:	b2da      	uxtb	r2, r3
 801f242:	68fb      	ldr	r3, [r7, #12]
 801f244:	719a      	strb	r2, [r3, #6]

	LEAVE_FF(fp->fs, FR_OK);
 801f246:	f04f 0300 	mov.w	r3, #0
}
 801f24a:	4618      	mov	r0, r3
 801f24c:	f107 0728 	add.w	r7, r7, #40	; 0x28
 801f250:	46bd      	mov	sp, r7
 801f252:	bd80      	pop	{r7, pc}

0801f254 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
 801f254:	b580      	push	{r7, lr}
 801f256:	b086      	sub	sp, #24
 801f258:	af00      	add	r7, sp, #0
 801f25a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 801f25c:	687b      	ldr	r3, [r7, #4]
 801f25e:	681a      	ldr	r2, [r3, #0]
 801f260:	687b      	ldr	r3, [r7, #4]
 801f262:	889b      	ldrh	r3, [r3, #4]
 801f264:	4610      	mov	r0, r2
 801f266:	4619      	mov	r1, r3
 801f268:	f7ff faa2 	bl	801e7b0 <validate>
 801f26c:	4603      	mov	r3, r0
 801f26e:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 801f270:	7dfb      	ldrb	r3, [r7, #23]
 801f272:	2b00      	cmp	r3, #0
 801f274:	f040 80c8 	bne.w	801f408 <f_sync+0x1b4>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 801f278:	687b      	ldr	r3, [r7, #4]
 801f27a:	799b      	ldrb	r3, [r3, #6]
 801f27c:	f003 0320 	and.w	r3, r3, #32
 801f280:	2b00      	cmp	r3, #0
 801f282:	f000 80c1 	beq.w	801f408 <f_sync+0x1b4>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
 801f286:	687b      	ldr	r3, [r7, #4]
 801f288:	799b      	ldrb	r3, [r3, #6]
 801f28a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801f28e:	2b00      	cmp	r3, #0
 801f290:	d01b      	beq.n	801f2ca <f_sync+0x76>
				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 801f292:	687b      	ldr	r3, [r7, #4]
 801f294:	681b      	ldr	r3, [r3, #0]
 801f296:	7859      	ldrb	r1, [r3, #1]
 801f298:	687b      	ldr	r3, [r7, #4]
 801f29a:	f103 0224 	add.w	r2, r3, #36	; 0x24
 801f29e:	687b      	ldr	r3, [r7, #4]
 801f2a0:	699b      	ldr	r3, [r3, #24]
 801f2a2:	4608      	mov	r0, r1
 801f2a4:	4611      	mov	r1, r2
 801f2a6:	461a      	mov	r2, r3
 801f2a8:	f04f 0301 	mov.w	r3, #1
 801f2ac:	f7e6 f92a 	bl	8005504 <disk_write>
 801f2b0:	4603      	mov	r3, r0
 801f2b2:	2b00      	cmp	r3, #0
 801f2b4:	d002      	beq.n	801f2bc <f_sync+0x68>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 801f2b6:	f04f 0301 	mov.w	r3, #1
 801f2ba:	e0a6      	b.n	801f40a <f_sync+0x1b6>
				fp->flag &= ~FA__DIRTY;
 801f2bc:	687b      	ldr	r3, [r7, #4]
 801f2be:	799b      	ldrb	r3, [r3, #6]
 801f2c0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801f2c4:	b2da      	uxtb	r2, r3
 801f2c6:	687b      	ldr	r3, [r7, #4]
 801f2c8:	719a      	strb	r2, [r3, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 801f2ca:	687b      	ldr	r3, [r7, #4]
 801f2cc:	681a      	ldr	r2, [r3, #0]
 801f2ce:	687b      	ldr	r3, [r7, #4]
 801f2d0:	69db      	ldr	r3, [r3, #28]
 801f2d2:	4610      	mov	r0, r2
 801f2d4:	4619      	mov	r1, r3
 801f2d6:	f7fd fe05 	bl	801cee4 <move_window>
 801f2da:	4603      	mov	r3, r0
 801f2dc:	75fb      	strb	r3, [r7, #23]
			if (res == FR_OK) {
 801f2de:	7dfb      	ldrb	r3, [r7, #23]
 801f2e0:	2b00      	cmp	r3, #0
 801f2e2:	f040 8091 	bne.w	801f408 <f_sync+0x1b4>
				dir = fp->dir_ptr;
 801f2e6:	687b      	ldr	r3, [r7, #4]
 801f2e8:	6a1b      	ldr	r3, [r3, #32]
 801f2ea:	613b      	str	r3, [r7, #16]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 801f2ec:	693b      	ldr	r3, [r7, #16]
 801f2ee:	f103 030b 	add.w	r3, r3, #11
 801f2f2:	693a      	ldr	r2, [r7, #16]
 801f2f4:	f102 020b 	add.w	r2, r2, #11
 801f2f8:	7812      	ldrb	r2, [r2, #0]
 801f2fa:	f042 0220 	orr.w	r2, r2, #32
 801f2fe:	b2d2      	uxtb	r2, r2
 801f300:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 801f302:	693b      	ldr	r3, [r7, #16]
 801f304:	f103 031c 	add.w	r3, r3, #28
 801f308:	687a      	ldr	r2, [r7, #4]
 801f30a:	68d2      	ldr	r2, [r2, #12]
 801f30c:	b2d2      	uxtb	r2, r2
 801f30e:	701a      	strb	r2, [r3, #0]
 801f310:	693b      	ldr	r3, [r7, #16]
 801f312:	f103 031d 	add.w	r3, r3, #29
 801f316:	687a      	ldr	r2, [r7, #4]
 801f318:	68d2      	ldr	r2, [r2, #12]
 801f31a:	b292      	uxth	r2, r2
 801f31c:	ea4f 2212 	mov.w	r2, r2, lsr #8
 801f320:	b292      	uxth	r2, r2
 801f322:	b2d2      	uxtb	r2, r2
 801f324:	701a      	strb	r2, [r3, #0]
 801f326:	693b      	ldr	r3, [r7, #16]
 801f328:	f103 031e 	add.w	r3, r3, #30
 801f32c:	687a      	ldr	r2, [r7, #4]
 801f32e:	68d2      	ldr	r2, [r2, #12]
 801f330:	ea4f 4212 	mov.w	r2, r2, lsr #16
 801f334:	b2d2      	uxtb	r2, r2
 801f336:	701a      	strb	r2, [r3, #0]
 801f338:	693b      	ldr	r3, [r7, #16]
 801f33a:	f103 031f 	add.w	r3, r3, #31
 801f33e:	687a      	ldr	r2, [r7, #4]
 801f340:	68d2      	ldr	r2, [r2, #12]
 801f342:	ea4f 6212 	mov.w	r2, r2, lsr #24
 801f346:	b2d2      	uxtb	r2, r2
 801f348:	701a      	strb	r2, [r3, #0]
				ST_WORD(dir+DIR_FstClusLO, fp->org_clust);	/* Update start cluster */
 801f34a:	693b      	ldr	r3, [r7, #16]
 801f34c:	f103 031a 	add.w	r3, r3, #26
 801f350:	687a      	ldr	r2, [r7, #4]
 801f352:	6912      	ldr	r2, [r2, #16]
 801f354:	b2d2      	uxtb	r2, r2
 801f356:	701a      	strb	r2, [r3, #0]
 801f358:	693b      	ldr	r3, [r7, #16]
 801f35a:	f103 031b 	add.w	r3, r3, #27
 801f35e:	687a      	ldr	r2, [r7, #4]
 801f360:	6912      	ldr	r2, [r2, #16]
 801f362:	b292      	uxth	r2, r2
 801f364:	ea4f 2212 	mov.w	r2, r2, lsr #8
 801f368:	b292      	uxth	r2, r2
 801f36a:	b2d2      	uxtb	r2, r2
 801f36c:	701a      	strb	r2, [r3, #0]
				ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
 801f36e:	693b      	ldr	r3, [r7, #16]
 801f370:	f103 0314 	add.w	r3, r3, #20
 801f374:	687a      	ldr	r2, [r7, #4]
 801f376:	6912      	ldr	r2, [r2, #16]
 801f378:	ea4f 4212 	mov.w	r2, r2, lsr #16
 801f37c:	b2d2      	uxtb	r2, r2
 801f37e:	701a      	strb	r2, [r3, #0]
 801f380:	693b      	ldr	r3, [r7, #16]
 801f382:	f103 0315 	add.w	r3, r3, #21
 801f386:	687a      	ldr	r2, [r7, #4]
 801f388:	6912      	ldr	r2, [r2, #16]
 801f38a:	ea4f 4212 	mov.w	r2, r2, lsr #16
 801f38e:	b292      	uxth	r2, r2
 801f390:	ea4f 2212 	mov.w	r2, r2, lsr #8
 801f394:	b292      	uxth	r2, r2
 801f396:	b2d2      	uxtb	r2, r2
 801f398:	701a      	strb	r2, [r3, #0]
				tim = get_fattime();			/* Updated time */
 801f39a:	f002 fe17 	bl	8021fcc <get_fattime>
 801f39e:	4603      	mov	r3, r0
 801f3a0:	60fb      	str	r3, [r7, #12]
				ST_DWORD(dir+DIR_WrtTime, tim);
 801f3a2:	693b      	ldr	r3, [r7, #16]
 801f3a4:	f103 0316 	add.w	r3, r3, #22
 801f3a8:	68fa      	ldr	r2, [r7, #12]
 801f3aa:	b2d2      	uxtb	r2, r2
 801f3ac:	701a      	strb	r2, [r3, #0]
 801f3ae:	693b      	ldr	r3, [r7, #16]
 801f3b0:	f103 0317 	add.w	r3, r3, #23
 801f3b4:	68fa      	ldr	r2, [r7, #12]
 801f3b6:	b292      	uxth	r2, r2
 801f3b8:	ea4f 2212 	mov.w	r2, r2, lsr #8
 801f3bc:	b292      	uxth	r2, r2
 801f3be:	b2d2      	uxtb	r2, r2
 801f3c0:	701a      	strb	r2, [r3, #0]
 801f3c2:	693b      	ldr	r3, [r7, #16]
 801f3c4:	f103 0318 	add.w	r3, r3, #24
 801f3c8:	68fa      	ldr	r2, [r7, #12]
 801f3ca:	ea4f 4212 	mov.w	r2, r2, lsr #16
 801f3ce:	b2d2      	uxtb	r2, r2
 801f3d0:	701a      	strb	r2, [r3, #0]
 801f3d2:	693b      	ldr	r3, [r7, #16]
 801f3d4:	f103 0319 	add.w	r3, r3, #25
 801f3d8:	68fa      	ldr	r2, [r7, #12]
 801f3da:	ea4f 6212 	mov.w	r2, r2, lsr #24
 801f3de:	b2d2      	uxtb	r2, r2
 801f3e0:	701a      	strb	r2, [r3, #0]
				fp->flag &= ~FA__WRITTEN;
 801f3e2:	687b      	ldr	r3, [r7, #4]
 801f3e4:	799b      	ldrb	r3, [r3, #6]
 801f3e6:	f023 0320 	bic.w	r3, r3, #32
 801f3ea:	b2da      	uxtb	r2, r3
 801f3ec:	687b      	ldr	r3, [r7, #4]
 801f3ee:	719a      	strb	r2, [r3, #6]
				fp->fs->wflag = 1;
 801f3f0:	687b      	ldr	r3, [r7, #4]
 801f3f2:	681b      	ldr	r3, [r3, #0]
 801f3f4:	f04f 0201 	mov.w	r2, #1
 801f3f8:	711a      	strb	r2, [r3, #4]
				res = sync(fp->fs);
 801f3fa:	687b      	ldr	r3, [r7, #4]
 801f3fc:	681b      	ldr	r3, [r3, #0]
 801f3fe:	4618      	mov	r0, r3
 801f400:	f7fd fdda 	bl	801cfb8 <sync>
 801f404:	4603      	mov	r3, r0
 801f406:	75fb      	strb	r3, [r7, #23]
			}
		}
	}

	LEAVE_FF(fp->fs, res);
 801f408:	7dfb      	ldrb	r3, [r7, #23]
}
 801f40a:	4618      	mov	r0, r3
 801f40c:	f107 0718 	add.w	r7, r7, #24
 801f410:	46bd      	mov	sp, r7
 801f412:	bd80      	pop	{r7, pc}

0801f414 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 801f414:	b580      	push	{r7, lr}
 801f416:	b084      	sub	sp, #16
 801f418:	af00      	add	r7, sp, #0
 801f41a:	6078      	str	r0, [r7, #4]
#if _FS_READONLY
	res = validate(fp->fs, fp->id);
	if (res == FR_OK) fp->fs = NULL;
	LEAVE_FF(fp->fs, res);
#else
	res = f_sync(fp);
 801f41c:	6878      	ldr	r0, [r7, #4]
 801f41e:	f7ff ff19 	bl	801f254 <f_sync>
 801f422:	4603      	mov	r3, r0
 801f424:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) fp->fs = NULL;
 801f426:	7bfb      	ldrb	r3, [r7, #15]
 801f428:	2b00      	cmp	r3, #0
 801f42a:	d103      	bne.n	801f434 <f_close+0x20>
 801f42c:	687b      	ldr	r3, [r7, #4]
 801f42e:	f04f 0200 	mov.w	r2, #0
 801f432:	601a      	str	r2, [r3, #0]
	return res;
 801f434:	7bfb      	ldrb	r3, [r7, #15]
#endif
}
 801f436:	4618      	mov	r0, r3
 801f438:	f107 0710 	add.w	r7, r7, #16
 801f43c:	46bd      	mov	sp, r7
 801f43e:	bd80      	pop	{r7, pc}

0801f440 <f_chdrive>:
#if _FS_RPATH

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
 801f440:	b480      	push	{r7}
 801f442:	b083      	sub	sp, #12
 801f444:	af00      	add	r7, sp, #0
 801f446:	4603      	mov	r3, r0
 801f448:	71fb      	strb	r3, [r7, #7]
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
 801f44a:	79fb      	ldrb	r3, [r7, #7]
 801f44c:	2b00      	cmp	r3, #0
 801f44e:	d002      	beq.n	801f456 <f_chdrive+0x16>
 801f450:	f04f 030b 	mov.w	r3, #11
 801f454:	e007      	b.n	801f466 <f_chdrive+0x26>

	Drive = drv;
 801f456:	f241 03ee 	movw	r3, #4334	; 0x10ee
 801f45a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f45e:	79fa      	ldrb	r2, [r7, #7]
 801f460:	701a      	strb	r2, [r3, #0]

	return FR_OK;
 801f462:	f04f 0300 	mov.w	r3, #0
}
 801f466:	4618      	mov	r0, r3
 801f468:	f107 070c 	add.w	r7, r7, #12
 801f46c:	46bd      	mov	sp, r7
 801f46e:	bc80      	pop	{r7}
 801f470:	4770      	bx	lr
 801f472:	bf00      	nop

0801f474 <f_chdir>:


FRESULT f_chdir (
	const XCHAR *path	/* Pointer to the directory path */
)
{
 801f474:	b580      	push	{r7, lr}
 801f476:	b08e      	sub	sp, #56	; 0x38
 801f478:	af00      	add	r7, sp, #0
 801f47a:	6078      	str	r0, [r7, #4]
	DIR dj;
	NAMEBUF(sfn, lfn);
	BYTE *dir;


	res = auto_mount(&path, &dj.fs, 0);
 801f47c:	f107 0204 	add.w	r2, r7, #4
 801f480:	f107 0314 	add.w	r3, r7, #20
 801f484:	4610      	mov	r0, r2
 801f486:	4619      	mov	r1, r3
 801f488:	f04f 0200 	mov.w	r2, #0
 801f48c:	f7fe ff00 	bl	801e290 <auto_mount>
 801f490:	4603      	mov	r3, r0
 801f492:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res == FR_OK) {
 801f496:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801f49a:	2b00      	cmp	r3, #0
 801f49c:	d150      	bne.n	801f540 <f_chdir+0xcc>
		INITBUF(dj, sfn, lfn);
 801f49e:	f107 0308 	add.w	r3, r7, #8
 801f4a2:	62fb      	str	r3, [r7, #44]	; 0x2c
		res = follow_path(&dj, path);		/* Follow the file path */
 801f4a4:	687b      	ldr	r3, [r7, #4]
 801f4a6:	f107 0214 	add.w	r2, r7, #20
 801f4aa:	4610      	mov	r0, r2
 801f4ac:	4619      	mov	r1, r3
 801f4ae:	f7fe fe03 	bl	801e0b8 <follow_path>
 801f4b2:	4603      	mov	r3, r0
 801f4b4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (res == FR_OK) {					/* Follow completed */
 801f4b8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801f4bc:	2b00      	cmp	r3, #0
 801f4be:	d137      	bne.n	801f530 <f_chdir+0xbc>
			dir = dj.dir;					/* Pointer to the entry */
 801f4c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801f4c2:	633b      	str	r3, [r7, #48]	; 0x30
			if (!dir) {
 801f4c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801f4c6:	2b00      	cmp	r3, #0
 801f4c8:	d104      	bne.n	801f4d4 <f_chdir+0x60>
				dj.fs->cdir = 0;			/* No entry (root dir) */
 801f4ca:	697b      	ldr	r3, [r7, #20]
 801f4cc:	f04f 0200 	mov.w	r2, #0
 801f4d0:	619a      	str	r2, [r3, #24]
 801f4d2:	e02d      	b.n	801f530 <f_chdir+0xbc>
			} else {
				if (dir[DIR_Attr] & AM_DIR)	/* Reached to the dir */
 801f4d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801f4d6:	f103 030b 	add.w	r3, r3, #11
 801f4da:	781b      	ldrb	r3, [r3, #0]
 801f4dc:	f003 0310 	and.w	r3, r3, #16
 801f4e0:	2b00      	cmp	r3, #0
 801f4e2:	d021      	beq.n	801f528 <f_chdir+0xb4>
					dj.fs->cdir = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 801f4e4:	697b      	ldr	r3, [r7, #20]
 801f4e6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801f4e8:	f102 0215 	add.w	r2, r2, #21
 801f4ec:	7812      	ldrb	r2, [r2, #0]
 801f4ee:	ea4f 2202 	mov.w	r2, r2, lsl #8
 801f4f2:	b291      	uxth	r1, r2
 801f4f4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801f4f6:	f102 0214 	add.w	r2, r2, #20
 801f4fa:	7812      	ldrb	r2, [r2, #0]
 801f4fc:	430a      	orrs	r2, r1
 801f4fe:	b292      	uxth	r2, r2
 801f500:	b292      	uxth	r2, r2
 801f502:	ea4f 4102 	mov.w	r1, r2, lsl #16
 801f506:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801f508:	f102 021b 	add.w	r2, r2, #27
 801f50c:	7812      	ldrb	r2, [r2, #0]
 801f50e:	ea4f 2202 	mov.w	r2, r2, lsl #8
 801f512:	b290      	uxth	r0, r2
 801f514:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801f516:	f102 021a 	add.w	r2, r2, #26
 801f51a:	7812      	ldrb	r2, [r2, #0]
 801f51c:	4302      	orrs	r2, r0
 801f51e:	b292      	uxth	r2, r2
 801f520:	b292      	uxth	r2, r2
 801f522:	430a      	orrs	r2, r1
 801f524:	619a      	str	r2, [r3, #24]
 801f526:	e003      	b.n	801f530 <f_chdir+0xbc>
				else
					res = FR_NO_PATH;		/* Could not reach the dir (it is a file) */
 801f528:	f04f 0305 	mov.w	r3, #5
 801f52c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 801f530:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801f534:	2b04      	cmp	r3, #4
 801f536:	d103      	bne.n	801f540 <f_chdir+0xcc>
 801f538:	f04f 0305 	mov.w	r3, #5
 801f53c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	}

	LEAVE_FF(dj.fs, res);
 801f540:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 801f544:	4618      	mov	r0, r3
 801f546:	f107 0738 	add.w	r7, r7, #56	; 0x38
 801f54a:	46bd      	mov	sp, r7
 801f54c:	bd80      	pop	{r7, pc}
 801f54e:	bf00      	nop

0801f550 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
 801f550:	b580      	push	{r7, lr}
 801f552:	b088      	sub	sp, #32
 801f554:	af00      	add	r7, sp, #0
 801f556:	6078      	str	r0, [r7, #4]
 801f558:	6039      	str	r1, [r7, #0]
	FRESULT res;
	DWORD clst, bcs, nsect, ifptr;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 801f55a:	687b      	ldr	r3, [r7, #4]
 801f55c:	681a      	ldr	r2, [r3, #0]
 801f55e:	687b      	ldr	r3, [r7, #4]
 801f560:	889b      	ldrh	r3, [r3, #4]
 801f562:	4610      	mov	r0, r2
 801f564:	4619      	mov	r1, r3
 801f566:	f7ff f923 	bl	801e7b0 <validate>
 801f56a:	4603      	mov	r3, r0
 801f56c:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 801f56e:	7dfb      	ldrb	r3, [r7, #23]
 801f570:	2b00      	cmp	r3, #0
 801f572:	d001      	beq.n	801f578 <f_lseek+0x28>
 801f574:	7dfb      	ldrb	r3, [r7, #23]
 801f576:	e16c      	b.n	801f852 <f_lseek+0x302>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
 801f578:	687b      	ldr	r3, [r7, #4]
 801f57a:	799b      	ldrb	r3, [r3, #6]
 801f57c:	b2db      	uxtb	r3, r3
 801f57e:	b25b      	sxtb	r3, r3
 801f580:	2b00      	cmp	r3, #0
 801f582:	da02      	bge.n	801f58a <f_lseek+0x3a>
		LEAVE_FF(fp->fs, FR_INT_ERR);
 801f584:	f04f 0302 	mov.w	r3, #2
 801f588:	e163      	b.n	801f852 <f_lseek+0x302>
	if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 801f58a:	687b      	ldr	r3, [r7, #4]
 801f58c:	68da      	ldr	r2, [r3, #12]
 801f58e:	683b      	ldr	r3, [r7, #0]
 801f590:	429a      	cmp	r2, r3
 801f592:	d208      	bcs.n	801f5a6 <f_lseek+0x56>
#if !_FS_READONLY
		 && !(fp->flag & FA_WRITE)
 801f594:	687b      	ldr	r3, [r7, #4]
 801f596:	799b      	ldrb	r3, [r3, #6]
 801f598:	f003 0302 	and.w	r3, r3, #2
 801f59c:	2b00      	cmp	r3, #0
 801f59e:	d102      	bne.n	801f5a6 <f_lseek+0x56>
#endif
		) ofs = fp->fsize;
 801f5a0:	687b      	ldr	r3, [r7, #4]
 801f5a2:	68db      	ldr	r3, [r3, #12]
 801f5a4:	603b      	str	r3, [r7, #0]

	ifptr = fp->fptr;
 801f5a6:	687b      	ldr	r3, [r7, #4]
 801f5a8:	689b      	ldr	r3, [r3, #8]
 801f5aa:	613b      	str	r3, [r7, #16]
	fp->fptr = nsect = 0; fp->csect = 255;
 801f5ac:	f04f 0300 	mov.w	r3, #0
 801f5b0:	61bb      	str	r3, [r7, #24]
 801f5b2:	687b      	ldr	r3, [r7, #4]
 801f5b4:	69ba      	ldr	r2, [r7, #24]
 801f5b6:	609a      	str	r2, [r3, #8]
 801f5b8:	687b      	ldr	r3, [r7, #4]
 801f5ba:	f04f 02ff 	mov.w	r2, #255	; 0xff
 801f5be:	71da      	strb	r2, [r3, #7]
	if (ofs > 0) {
 801f5c0:	683b      	ldr	r3, [r7, #0]
 801f5c2:	2b00      	cmp	r3, #0
 801f5c4:	f000 80e0 	beq.w	801f788 <f_lseek+0x238>
		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 801f5c8:	687b      	ldr	r3, [r7, #4]
 801f5ca:	681b      	ldr	r3, [r3, #0]
 801f5cc:	789b      	ldrb	r3, [r3, #2]
 801f5ce:	ea4f 2343 	mov.w	r3, r3, lsl #9
 801f5d2:	60fb      	str	r3, [r7, #12]
		if (ifptr > 0 &&
 801f5d4:	693b      	ldr	r3, [r7, #16]
 801f5d6:	2b00      	cmp	r3, #0
 801f5d8:	d01f      	beq.n	801f61a <f_lseek+0xca>
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 801f5da:	683b      	ldr	r3, [r7, #0]
 801f5dc:	f103 32ff 	add.w	r2, r3, #4294967295
 801f5e0:	68fb      	ldr	r3, [r7, #12]
 801f5e2:	fbb2 f2f3 	udiv	r2, r2, r3
 801f5e6:	693b      	ldr	r3, [r7, #16]
 801f5e8:	f103 31ff 	add.w	r1, r3, #4294967295
 801f5ec:	68fb      	ldr	r3, [r7, #12]
 801f5ee:	fbb1 f3f3 	udiv	r3, r1, r3

	ifptr = fp->fptr;
	fp->fptr = nsect = 0; fp->csect = 255;
	if (ofs > 0) {
		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
		if (ifptr > 0 &&
 801f5f2:	429a      	cmp	r2, r3
 801f5f4:	d311      	bcc.n	801f61a <f_lseek+0xca>
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 801f5f6:	693b      	ldr	r3, [r7, #16]
 801f5f8:	f103 32ff 	add.w	r2, r3, #4294967295
 801f5fc:	68fb      	ldr	r3, [r7, #12]
 801f5fe:	f1c3 0300 	rsb	r3, r3, #0
 801f602:	401a      	ands	r2, r3
 801f604:	687b      	ldr	r3, [r7, #4]
 801f606:	609a      	str	r2, [r3, #8]
			ofs -= fp->fptr;
 801f608:	687b      	ldr	r3, [r7, #4]
 801f60a:	689b      	ldr	r3, [r3, #8]
 801f60c:	683a      	ldr	r2, [r7, #0]
 801f60e:	1ad3      	subs	r3, r2, r3
 801f610:	603b      	str	r3, [r7, #0]
			clst = fp->curr_clust;
 801f612:	687b      	ldr	r3, [r7, #4]
 801f614:	695b      	ldr	r3, [r3, #20]
 801f616:	61fb      	str	r3, [r7, #28]
 801f618:	e02f      	b.n	801f67a <f_lseek+0x12a>
		} else {									/* When seek to back cluster, */
			clst = fp->org_clust;					/* start from the first cluster */
 801f61a:	687b      	ldr	r3, [r7, #4]
 801f61c:	691b      	ldr	r3, [r3, #16]
 801f61e:	61fb      	str	r3, [r7, #28]
#if !_FS_READONLY
			if (clst == 0) {						/* If no cluster chain, create a new chain */
 801f620:	69fb      	ldr	r3, [r7, #28]
 801f622:	2b00      	cmp	r3, #0
 801f624:	d126      	bne.n	801f674 <f_lseek+0x124>
				clst = create_chain(fp->fs, 0);
 801f626:	687b      	ldr	r3, [r7, #4]
 801f628:	681b      	ldr	r3, [r3, #0]
 801f62a:	4618      	mov	r0, r3
 801f62c:	f04f 0100 	mov.w	r1, #0
 801f630:	f7fe f80e 	bl	801d650 <create_chain>
 801f634:	4603      	mov	r3, r0
 801f636:	61fb      	str	r3, [r7, #28]
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 801f638:	69fb      	ldr	r3, [r7, #28]
 801f63a:	2b01      	cmp	r3, #1
 801f63c:	d109      	bne.n	801f652 <f_lseek+0x102>
 801f63e:	687b      	ldr	r3, [r7, #4]
 801f640:	799b      	ldrb	r3, [r3, #6]
 801f642:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f646:	b2da      	uxtb	r2, r3
 801f648:	687b      	ldr	r3, [r7, #4]
 801f64a:	719a      	strb	r2, [r3, #6]
 801f64c:	f04f 0302 	mov.w	r3, #2
 801f650:	e0ff      	b.n	801f852 <f_lseek+0x302>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 801f652:	69fb      	ldr	r3, [r7, #28]
 801f654:	f1b3 3fff 	cmp.w	r3, #4294967295
 801f658:	d109      	bne.n	801f66e <f_lseek+0x11e>
 801f65a:	687b      	ldr	r3, [r7, #4]
 801f65c:	799b      	ldrb	r3, [r3, #6]
 801f65e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f662:	b2da      	uxtb	r2, r3
 801f664:	687b      	ldr	r3, [r7, #4]
 801f666:	719a      	strb	r2, [r3, #6]
 801f668:	f04f 0301 	mov.w	r3, #1
 801f66c:	e0f1      	b.n	801f852 <f_lseek+0x302>
				fp->org_clust = clst;
 801f66e:	687b      	ldr	r3, [r7, #4]
 801f670:	69fa      	ldr	r2, [r7, #28]
 801f672:	611a      	str	r2, [r3, #16]
			}
#endif
			fp->curr_clust = clst;
 801f674:	687b      	ldr	r3, [r7, #4]
 801f676:	69fa      	ldr	r2, [r7, #28]
 801f678:	615a      	str	r2, [r3, #20]
		}
		if (clst != 0) {
 801f67a:	69fb      	ldr	r3, [r7, #28]
 801f67c:	2b00      	cmp	r3, #0
 801f67e:	f000 8083 	beq.w	801f788 <f_lseek+0x238>
			while (ofs > bcs) {						/* Cluster following loop */
 801f682:	e049      	b.n	801f718 <f_lseek+0x1c8>
#if !_FS_READONLY
				if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 801f684:	687b      	ldr	r3, [r7, #4]
 801f686:	799b      	ldrb	r3, [r3, #6]
 801f688:	f003 0302 	and.w	r3, r3, #2
 801f68c:	2b00      	cmp	r3, #0
 801f68e:	d00d      	beq.n	801f6ac <f_lseek+0x15c>
					clst = create_chain(fp->fs, clst);	/* Force streached if in write mode */
 801f690:	687b      	ldr	r3, [r7, #4]
 801f692:	681b      	ldr	r3, [r3, #0]
 801f694:	4618      	mov	r0, r3
 801f696:	69f9      	ldr	r1, [r7, #28]
 801f698:	f7fd ffda 	bl	801d650 <create_chain>
 801f69c:	4603      	mov	r3, r0
 801f69e:	61fb      	str	r3, [r7, #28]
					if (clst == 0) {				/* When disk gets full, clip file size */
 801f6a0:	69fb      	ldr	r3, [r7, #28]
 801f6a2:	2b00      	cmp	r3, #0
 801f6a4:	d10a      	bne.n	801f6bc <f_lseek+0x16c>
						ofs = bcs; break;
 801f6a6:	68fb      	ldr	r3, [r7, #12]
 801f6a8:	603b      	str	r3, [r7, #0]
 801f6aa:	e039      	b.n	801f720 <f_lseek+0x1d0>
					}
				} else
#endif
					clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
 801f6ac:	687b      	ldr	r3, [r7, #4]
 801f6ae:	681b      	ldr	r3, [r3, #0]
 801f6b0:	4618      	mov	r0, r3
 801f6b2:	69f9      	ldr	r1, [r7, #28]
 801f6b4:	f7fd fd40 	bl	801d138 <get_fat>
 801f6b8:	4603      	mov	r3, r0
 801f6ba:	61fb      	str	r3, [r7, #28]
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 801f6bc:	69fb      	ldr	r3, [r7, #28]
 801f6be:	f1b3 3fff 	cmp.w	r3, #4294967295
 801f6c2:	d109      	bne.n	801f6d8 <f_lseek+0x188>
 801f6c4:	687b      	ldr	r3, [r7, #4]
 801f6c6:	799b      	ldrb	r3, [r3, #6]
 801f6c8:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f6cc:	b2da      	uxtb	r2, r3
 801f6ce:	687b      	ldr	r3, [r7, #4]
 801f6d0:	719a      	strb	r2, [r3, #6]
 801f6d2:	f04f 0301 	mov.w	r3, #1
 801f6d6:	e0bc      	b.n	801f852 <f_lseek+0x302>
				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
 801f6d8:	69fb      	ldr	r3, [r7, #28]
 801f6da:	2b01      	cmp	r3, #1
 801f6dc:	d905      	bls.n	801f6ea <f_lseek+0x19a>
 801f6de:	687b      	ldr	r3, [r7, #4]
 801f6e0:	681b      	ldr	r3, [r3, #0]
 801f6e2:	6a1a      	ldr	r2, [r3, #32]
 801f6e4:	69fb      	ldr	r3, [r7, #28]
 801f6e6:	429a      	cmp	r2, r3
 801f6e8:	d809      	bhi.n	801f6fe <f_lseek+0x1ae>
 801f6ea:	687b      	ldr	r3, [r7, #4]
 801f6ec:	799b      	ldrb	r3, [r3, #6]
 801f6ee:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f6f2:	b2da      	uxtb	r2, r3
 801f6f4:	687b      	ldr	r3, [r7, #4]
 801f6f6:	719a      	strb	r2, [r3, #6]
 801f6f8:	f04f 0302 	mov.w	r3, #2
 801f6fc:	e0a9      	b.n	801f852 <f_lseek+0x302>
				fp->curr_clust = clst;
 801f6fe:	687b      	ldr	r3, [r7, #4]
 801f700:	69fa      	ldr	r2, [r7, #28]
 801f702:	615a      	str	r2, [r3, #20]
				fp->fptr += bcs;
 801f704:	687b      	ldr	r3, [r7, #4]
 801f706:	689a      	ldr	r2, [r3, #8]
 801f708:	68fb      	ldr	r3, [r7, #12]
 801f70a:	18d2      	adds	r2, r2, r3
 801f70c:	687b      	ldr	r3, [r7, #4]
 801f70e:	609a      	str	r2, [r3, #8]
				ofs -= bcs;
 801f710:	683a      	ldr	r2, [r7, #0]
 801f712:	68fb      	ldr	r3, [r7, #12]
 801f714:	1ad3      	subs	r3, r2, r3
 801f716:	603b      	str	r3, [r7, #0]
			}
#endif
			fp->curr_clust = clst;
		}
		if (clst != 0) {
			while (ofs > bcs) {						/* Cluster following loop */
 801f718:	683a      	ldr	r2, [r7, #0]
 801f71a:	68fb      	ldr	r3, [r7, #12]
 801f71c:	429a      	cmp	r2, r3
 801f71e:	d8b1      	bhi.n	801f684 <f_lseek+0x134>
				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
				fp->curr_clust = clst;
				fp->fptr += bcs;
				ofs -= bcs;
			}
			fp->fptr += ofs;
 801f720:	687b      	ldr	r3, [r7, #4]
 801f722:	689a      	ldr	r2, [r3, #8]
 801f724:	683b      	ldr	r3, [r7, #0]
 801f726:	18d2      	adds	r2, r2, r3
 801f728:	687b      	ldr	r3, [r7, #4]
 801f72a:	609a      	str	r2, [r3, #8]
			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
 801f72c:	683b      	ldr	r3, [r7, #0]
 801f72e:	ea4f 2353 	mov.w	r3, r3, lsr #9
 801f732:	b2da      	uxtb	r2, r3
 801f734:	687b      	ldr	r3, [r7, #4]
 801f736:	71da      	strb	r2, [r3, #7]
			if (ofs % SS(fp->fs)) {
 801f738:	683b      	ldr	r3, [r7, #0]
 801f73a:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801f73e:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801f742:	2b00      	cmp	r3, #0
 801f744:	d020      	beq.n	801f788 <f_lseek+0x238>
				nsect = clust2sect(fp->fs, clst);	/* Current sector */
 801f746:	687b      	ldr	r3, [r7, #4]
 801f748:	681b      	ldr	r3, [r3, #0]
 801f74a:	4618      	mov	r0, r3
 801f74c:	69f9      	ldr	r1, [r7, #28]
 801f74e:	f7fe f80f 	bl	801d770 <clust2sect>
 801f752:	4603      	mov	r3, r0
 801f754:	61bb      	str	r3, [r7, #24]
				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 801f756:	69bb      	ldr	r3, [r7, #24]
 801f758:	2b00      	cmp	r3, #0
 801f75a:	d109      	bne.n	801f770 <f_lseek+0x220>
 801f75c:	687b      	ldr	r3, [r7, #4]
 801f75e:	799b      	ldrb	r3, [r3, #6]
 801f760:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f764:	b2da      	uxtb	r2, r3
 801f766:	687b      	ldr	r3, [r7, #4]
 801f768:	719a      	strb	r2, [r3, #6]
 801f76a:	f04f 0302 	mov.w	r3, #2
 801f76e:	e070      	b.n	801f852 <f_lseek+0x302>
				nsect += fp->csect;
 801f770:	687b      	ldr	r3, [r7, #4]
 801f772:	79db      	ldrb	r3, [r3, #7]
 801f774:	69ba      	ldr	r2, [r7, #24]
 801f776:	18d3      	adds	r3, r2, r3
 801f778:	61bb      	str	r3, [r7, #24]
				fp->csect++;
 801f77a:	687b      	ldr	r3, [r7, #4]
 801f77c:	79db      	ldrb	r3, [r3, #7]
 801f77e:	f103 0301 	add.w	r3, r3, #1
 801f782:	b2da      	uxtb	r2, r3
 801f784:	687b      	ldr	r3, [r7, #4]
 801f786:	71da      	strb	r2, [r3, #7]
			}
		}
	}
	if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {
 801f788:	687b      	ldr	r3, [r7, #4]
 801f78a:	689b      	ldr	r3, [r3, #8]
 801f78c:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 801f790:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 801f794:	2b00      	cmp	r3, #0
 801f796:	d04a      	beq.n	801f82e <f_lseek+0x2de>
 801f798:	687b      	ldr	r3, [r7, #4]
 801f79a:	699a      	ldr	r2, [r3, #24]
 801f79c:	69bb      	ldr	r3, [r7, #24]
 801f79e:	429a      	cmp	r2, r3
 801f7a0:	d045      	beq.n	801f82e <f_lseek+0x2de>
#if !_FS_TINY
#if !_FS_READONLY
		if (fp->flag & FA__DIRTY) {			/* Write-back dirty buffer if needed */
 801f7a2:	687b      	ldr	r3, [r7, #4]
 801f7a4:	799b      	ldrb	r3, [r3, #6]
 801f7a6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801f7aa:	2b00      	cmp	r3, #0
 801f7ac:	d022      	beq.n	801f7f4 <f_lseek+0x2a4>
			if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 801f7ae:	687b      	ldr	r3, [r7, #4]
 801f7b0:	681b      	ldr	r3, [r3, #0]
 801f7b2:	7859      	ldrb	r1, [r3, #1]
 801f7b4:	687b      	ldr	r3, [r7, #4]
 801f7b6:	f103 0224 	add.w	r2, r3, #36	; 0x24
 801f7ba:	687b      	ldr	r3, [r7, #4]
 801f7bc:	699b      	ldr	r3, [r3, #24]
 801f7be:	4608      	mov	r0, r1
 801f7c0:	4611      	mov	r1, r2
 801f7c2:	461a      	mov	r2, r3
 801f7c4:	f04f 0301 	mov.w	r3, #1
 801f7c8:	f7e5 fe9c 	bl	8005504 <disk_write>
 801f7cc:	4603      	mov	r3, r0
 801f7ce:	2b00      	cmp	r3, #0
 801f7d0:	d009      	beq.n	801f7e6 <f_lseek+0x296>
				ABORT(fp->fs, FR_DISK_ERR);
 801f7d2:	687b      	ldr	r3, [r7, #4]
 801f7d4:	799b      	ldrb	r3, [r3, #6]
 801f7d6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f7da:	b2da      	uxtb	r2, r3
 801f7dc:	687b      	ldr	r3, [r7, #4]
 801f7de:	719a      	strb	r2, [r3, #6]
 801f7e0:	f04f 0301 	mov.w	r3, #1
 801f7e4:	e035      	b.n	801f852 <f_lseek+0x302>
			fp->flag &= ~FA__DIRTY;
 801f7e6:	687b      	ldr	r3, [r7, #4]
 801f7e8:	799b      	ldrb	r3, [r3, #6]
 801f7ea:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801f7ee:	b2da      	uxtb	r2, r3
 801f7f0:	687b      	ldr	r3, [r7, #4]
 801f7f2:	719a      	strb	r2, [r3, #6]
		}
#endif
		if (disk_read(fp->fs->drive, fp->buf, nsect, 1) != RES_OK)
 801f7f4:	687b      	ldr	r3, [r7, #4]
 801f7f6:	681b      	ldr	r3, [r3, #0]
 801f7f8:	785a      	ldrb	r2, [r3, #1]
 801f7fa:	687b      	ldr	r3, [r7, #4]
 801f7fc:	f103 0324 	add.w	r3, r3, #36	; 0x24
 801f800:	4610      	mov	r0, r2
 801f802:	4619      	mov	r1, r3
 801f804:	69ba      	ldr	r2, [r7, #24]
 801f806:	f04f 0301 	mov.w	r3, #1
 801f80a:	f7e5 fe1d 	bl	8005448 <disk_read>
 801f80e:	4603      	mov	r3, r0
 801f810:	2b00      	cmp	r3, #0
 801f812:	d009      	beq.n	801f828 <f_lseek+0x2d8>
			ABORT(fp->fs, FR_DISK_ERR);
 801f814:	687b      	ldr	r3, [r7, #4]
 801f816:	799b      	ldrb	r3, [r3, #6]
 801f818:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f81c:	b2da      	uxtb	r2, r3
 801f81e:	687b      	ldr	r3, [r7, #4]
 801f820:	719a      	strb	r2, [r3, #6]
 801f822:	f04f 0301 	mov.w	r3, #1
 801f826:	e014      	b.n	801f852 <f_lseek+0x302>
#endif
		fp->dsect = nsect;
 801f828:	687b      	ldr	r3, [r7, #4]
 801f82a:	69ba      	ldr	r2, [r7, #24]
 801f82c:	619a      	str	r2, [r3, #24]
	}
#if !_FS_READONLY
	if (fp->fptr > fp->fsize) {			/* Set changed flag if the file size is extended */
 801f82e:	687b      	ldr	r3, [r7, #4]
 801f830:	689a      	ldr	r2, [r3, #8]
 801f832:	687b      	ldr	r3, [r7, #4]
 801f834:	68db      	ldr	r3, [r3, #12]
 801f836:	429a      	cmp	r2, r3
 801f838:	d90a      	bls.n	801f850 <f_lseek+0x300>
		fp->fsize = fp->fptr;
 801f83a:	687b      	ldr	r3, [r7, #4]
 801f83c:	689a      	ldr	r2, [r3, #8]
 801f83e:	687b      	ldr	r3, [r7, #4]
 801f840:	60da      	str	r2, [r3, #12]
		fp->flag |= FA__WRITTEN;
 801f842:	687b      	ldr	r3, [r7, #4]
 801f844:	799b      	ldrb	r3, [r3, #6]
 801f846:	f043 0320 	orr.w	r3, r3, #32
 801f84a:	b2da      	uxtb	r2, r3
 801f84c:	687b      	ldr	r3, [r7, #4]
 801f84e:	719a      	strb	r2, [r3, #6]
	}
#endif

	LEAVE_FF(fp->fs, res);
 801f850:	7dfb      	ldrb	r3, [r7, #23]
}
 801f852:	4618      	mov	r0, r3
 801f854:	f107 0720 	add.w	r7, r7, #32
 801f858:	46bd      	mov	sp, r7
 801f85a:	bd80      	pop	{r7, pc}

0801f85c <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const XCHAR *path	/* Pointer to the directory path */
)
{
 801f85c:	b580      	push	{r7, lr}
 801f85e:	b088      	sub	sp, #32
 801f860:	af00      	add	r7, sp, #0
 801f862:	6078      	str	r0, [r7, #4]
 801f864:	6039      	str	r1, [r7, #0]
	FRESULT res;
	NAMEBUF(sfn, lfn);
	BYTE *dir;


	res = auto_mount(&path, &dj->fs, 0);
 801f866:	687b      	ldr	r3, [r7, #4]
 801f868:	463a      	mov	r2, r7
 801f86a:	4610      	mov	r0, r2
 801f86c:	4619      	mov	r1, r3
 801f86e:	f04f 0200 	mov.w	r2, #0
 801f872:	f7fe fd0d 	bl	801e290 <auto_mount>
 801f876:	4603      	mov	r3, r0
 801f878:	77fb      	strb	r3, [r7, #31]
	if (res == FR_OK) {
 801f87a:	7ffb      	ldrb	r3, [r7, #31]
 801f87c:	2b00      	cmp	r3, #0
 801f87e:	d155      	bne.n	801f92c <f_opendir+0xd0>
		INITBUF((*dj), sfn, lfn);
 801f880:	687b      	ldr	r3, [r7, #4]
 801f882:	f107 020c 	add.w	r2, r7, #12
 801f886:	619a      	str	r2, [r3, #24]
		res = follow_path(dj, path);			/* Follow the path to the directory */
 801f888:	683b      	ldr	r3, [r7, #0]
 801f88a:	6878      	ldr	r0, [r7, #4]
 801f88c:	4619      	mov	r1, r3
 801f88e:	f7fe fc13 	bl	801e0b8 <follow_path>
 801f892:	4603      	mov	r3, r0
 801f894:	77fb      	strb	r3, [r7, #31]
		if (res == FR_OK) {						/* Follow completed */
 801f896:	7ffb      	ldrb	r3, [r7, #31]
 801f898:	2b00      	cmp	r3, #0
 801f89a:	d141      	bne.n	801f920 <f_opendir+0xc4>
			dir = dj->dir;
 801f89c:	687b      	ldr	r3, [r7, #4]
 801f89e:	695b      	ldr	r3, [r3, #20]
 801f8a0:	61bb      	str	r3, [r7, #24]
			if (dir) {							/* It is not the root dir */
 801f8a2:	69bb      	ldr	r3, [r7, #24]
 801f8a4:	2b00      	cmp	r3, #0
 801f8a6:	d02c      	beq.n	801f902 <f_opendir+0xa6>
				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
 801f8a8:	69bb      	ldr	r3, [r7, #24]
 801f8aa:	f103 030b 	add.w	r3, r3, #11
 801f8ae:	781b      	ldrb	r3, [r3, #0]
 801f8b0:	f003 0310 	and.w	r3, r3, #16
 801f8b4:	2b00      	cmp	r3, #0
 801f8b6:	d021      	beq.n	801f8fc <f_opendir+0xa0>
					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 801f8b8:	69bb      	ldr	r3, [r7, #24]
 801f8ba:	f103 0315 	add.w	r3, r3, #21
 801f8be:	781b      	ldrb	r3, [r3, #0]
 801f8c0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801f8c4:	b29a      	uxth	r2, r3
 801f8c6:	69bb      	ldr	r3, [r7, #24]
 801f8c8:	f103 0314 	add.w	r3, r3, #20
 801f8cc:	781b      	ldrb	r3, [r3, #0]
 801f8ce:	4313      	orrs	r3, r2
 801f8d0:	b29b      	uxth	r3, r3
 801f8d2:	b29b      	uxth	r3, r3
 801f8d4:	ea4f 4203 	mov.w	r2, r3, lsl #16
 801f8d8:	69bb      	ldr	r3, [r7, #24]
 801f8da:	f103 031b 	add.w	r3, r3, #27
 801f8de:	781b      	ldrb	r3, [r3, #0]
 801f8e0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801f8e4:	b299      	uxth	r1, r3
 801f8e6:	69bb      	ldr	r3, [r7, #24]
 801f8e8:	f103 031a 	add.w	r3, r3, #26
 801f8ec:	781b      	ldrb	r3, [r3, #0]
 801f8ee:	430b      	orrs	r3, r1
 801f8f0:	b29b      	uxth	r3, r3
 801f8f2:	b29b      	uxth	r3, r3
 801f8f4:	431a      	orrs	r2, r3
 801f8f6:	687b      	ldr	r3, [r7, #4]
 801f8f8:	609a      	str	r2, [r3, #8]
 801f8fa:	e002      	b.n	801f902 <f_opendir+0xa6>
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
 801f8fc:	f04f 0305 	mov.w	r3, #5
 801f900:	77fb      	strb	r3, [r7, #31]
				}
			}
			if (res == FR_OK) {
 801f902:	7ffb      	ldrb	r3, [r7, #31]
 801f904:	2b00      	cmp	r3, #0
 801f906:	d10b      	bne.n	801f920 <f_opendir+0xc4>
				dj->id = dj->fs->id;
 801f908:	687b      	ldr	r3, [r7, #4]
 801f90a:	681b      	ldr	r3, [r3, #0]
 801f90c:	88da      	ldrh	r2, [r3, #6]
 801f90e:	687b      	ldr	r3, [r7, #4]
 801f910:	809a      	strh	r2, [r3, #4]
				res = dir_seek(dj, 0);			/* Rewind dir */
 801f912:	6878      	ldr	r0, [r7, #4]
 801f914:	f04f 0100 	mov.w	r1, #0
 801f918:	f7fd ff4c 	bl	801d7b4 <dir_seek>
 801f91c:	4603      	mov	r3, r0
 801f91e:	77fb      	strb	r3, [r7, #31]
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 801f920:	7ffb      	ldrb	r3, [r7, #31]
 801f922:	2b04      	cmp	r3, #4
 801f924:	d102      	bne.n	801f92c <f_opendir+0xd0>
 801f926:	f04f 0305 	mov.w	r3, #5
 801f92a:	77fb      	strb	r3, [r7, #31]
	}

	LEAVE_FF(dj->fs, res);
 801f92c:	7ffb      	ldrb	r3, [r7, #31]
}
 801f92e:	4618      	mov	r0, r3
 801f930:	f107 0720 	add.w	r7, r7, #32
 801f934:	46bd      	mov	sp, r7
 801f936:	bd80      	pop	{r7, pc}

0801f938 <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
 801f938:	b580      	push	{r7, lr}
 801f93a:	b086      	sub	sp, #24
 801f93c:	af00      	add	r7, sp, #0
 801f93e:	6078      	str	r0, [r7, #4]
 801f940:	6039      	str	r1, [r7, #0]
	FRESULT res;
	NAMEBUF(sfn, lfn);


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
 801f942:	687b      	ldr	r3, [r7, #4]
 801f944:	681a      	ldr	r2, [r3, #0]
 801f946:	687b      	ldr	r3, [r7, #4]
 801f948:	889b      	ldrh	r3, [r3, #4]
 801f94a:	4610      	mov	r0, r2
 801f94c:	4619      	mov	r1, r3
 801f94e:	f7fe ff2f 	bl	801e7b0 <validate>
 801f952:	4603      	mov	r3, r0
 801f954:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 801f956:	7dfb      	ldrb	r3, [r7, #23]
 801f958:	2b00      	cmp	r3, #0
 801f95a:	d135      	bne.n	801f9c8 <f_readdir+0x90>
		INITBUF((*dj), sfn, lfn);
 801f95c:	687b      	ldr	r3, [r7, #4]
 801f95e:	f107 0208 	add.w	r2, r7, #8
 801f962:	619a      	str	r2, [r3, #24]
		if (!fno) {
 801f964:	683b      	ldr	r3, [r7, #0]
 801f966:	2b00      	cmp	r3, #0
 801f968:	d107      	bne.n	801f97a <f_readdir+0x42>
			res = dir_seek(dj, 0);
 801f96a:	6878      	ldr	r0, [r7, #4]
 801f96c:	f04f 0100 	mov.w	r1, #0
 801f970:	f7fd ff20 	bl	801d7b4 <dir_seek>
 801f974:	4603      	mov	r3, r0
 801f976:	75fb      	strb	r3, [r7, #23]
 801f978:	e026      	b.n	801f9c8 <f_readdir+0x90>
		} else {
			res = dir_read(dj);
 801f97a:	6878      	ldr	r0, [r7, #4]
 801f97c:	f7fe f8ea 	bl	801db54 <dir_read>
 801f980:	4603      	mov	r3, r0
 801f982:	75fb      	strb	r3, [r7, #23]
			if (res == FR_NO_FILE) {
 801f984:	7dfb      	ldrb	r3, [r7, #23]
 801f986:	2b04      	cmp	r3, #4
 801f988:	d106      	bne.n	801f998 <f_readdir+0x60>
				dj->sect = 0;
 801f98a:	687b      	ldr	r3, [r7, #4]
 801f98c:	f04f 0200 	mov.w	r2, #0
 801f990:	611a      	str	r2, [r3, #16]
				res = FR_OK;
 801f992:	f04f 0300 	mov.w	r3, #0
 801f996:	75fb      	strb	r3, [r7, #23]
			}
			if (res == FR_OK) {				/* A valid entry is found */
 801f998:	7dfb      	ldrb	r3, [r7, #23]
 801f99a:	2b00      	cmp	r3, #0
 801f99c:	d114      	bne.n	801f9c8 <f_readdir+0x90>
				get_fileinfo(dj, fno);		/* Get the object information */
 801f99e:	6878      	ldr	r0, [r7, #4]
 801f9a0:	6839      	ldr	r1, [r7, #0]
 801f9a2:	f7fe fac3 	bl	801df2c <get_fileinfo>
				res = dir_next(dj, FALSE);	/* Increment index for next */
 801f9a6:	6878      	ldr	r0, [r7, #4]
 801f9a8:	f04f 0100 	mov.w	r1, #0
 801f9ac:	f7fd ff8e 	bl	801d8cc <dir_next>
 801f9b0:	4603      	mov	r3, r0
 801f9b2:	75fb      	strb	r3, [r7, #23]
				if (res == FR_NO_FILE) {
 801f9b4:	7dfb      	ldrb	r3, [r7, #23]
 801f9b6:	2b04      	cmp	r3, #4
 801f9b8:	d106      	bne.n	801f9c8 <f_readdir+0x90>
					dj->sect = 0;
 801f9ba:	687b      	ldr	r3, [r7, #4]
 801f9bc:	f04f 0200 	mov.w	r2, #0
 801f9c0:	611a      	str	r2, [r3, #16]
					res = FR_OK;
 801f9c2:	f04f 0300 	mov.w	r3, #0
 801f9c6:	75fb      	strb	r3, [r7, #23]
				}
			}
		}
	}

	LEAVE_FF(dj->fs, res);
 801f9c8:	7dfb      	ldrb	r3, [r7, #23]
}
 801f9ca:	4618      	mov	r0, r3
 801f9cc:	f107 0718 	add.w	r7, r7, #24
 801f9d0:	46bd      	mov	sp, r7
 801f9d2:	bd80      	pop	{r7, pc}

0801f9d4 <f_stat>:

FRESULT f_stat (
	const XCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
 801f9d4:	b580      	push	{r7, lr}
 801f9d6:	b08e      	sub	sp, #56	; 0x38
 801f9d8:	af00      	add	r7, sp, #0
 801f9da:	6078      	str	r0, [r7, #4]
 801f9dc:	6039      	str	r1, [r7, #0]
	FRESULT res;
	DIR dj;
	NAMEBUF(sfn, lfn);


	res = auto_mount(&path, &dj.fs, 0);
 801f9de:	f107 0204 	add.w	r2, r7, #4
 801f9e2:	f107 0318 	add.w	r3, r7, #24
 801f9e6:	4610      	mov	r0, r2
 801f9e8:	4619      	mov	r1, r3
 801f9ea:	f04f 0200 	mov.w	r2, #0
 801f9ee:	f7fe fc4f 	bl	801e290 <auto_mount>
 801f9f2:	4603      	mov	r3, r0
 801f9f4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res == FR_OK) {
 801f9f8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801f9fc:	2b00      	cmp	r3, #0
 801f9fe:	d11e      	bne.n	801fa3e <f_stat+0x6a>
		INITBUF(dj, sfn, lfn);
 801fa00:	f107 030c 	add.w	r3, r7, #12
 801fa04:	633b      	str	r3, [r7, #48]	; 0x30
		res = follow_path(&dj, path);	/* Follow the file path */
 801fa06:	687b      	ldr	r3, [r7, #4]
 801fa08:	f107 0218 	add.w	r2, r7, #24
 801fa0c:	4610      	mov	r0, r2
 801fa0e:	4619      	mov	r1, r3
 801fa10:	f7fe fb52 	bl	801e0b8 <follow_path>
 801fa14:	4603      	mov	r3, r0
 801fa16:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (res == FR_OK) {				/* Follwo completed */
 801fa1a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801fa1e:	2b00      	cmp	r3, #0
 801fa20:	d10d      	bne.n	801fa3e <f_stat+0x6a>
			if (dj.dir)	/* Found an object */
 801fa22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801fa24:	2b00      	cmp	r3, #0
 801fa26:	d006      	beq.n	801fa36 <f_stat+0x62>
				get_fileinfo(&dj, fno);
 801fa28:	f107 0318 	add.w	r3, r7, #24
 801fa2c:	4618      	mov	r0, r3
 801fa2e:	6839      	ldr	r1, [r7, #0]
 801fa30:	f7fe fa7c 	bl	801df2c <get_fileinfo>
 801fa34:	e003      	b.n	801fa3e <f_stat+0x6a>
			else		/* It is root dir */
				res = FR_INVALID_NAME;
 801fa36:	f04f 0306 	mov.w	r3, #6
 801fa3a:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		}
	}

	LEAVE_FF(dj.fs, res);
 801fa3e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 801fa42:	4618      	mov	r0, r3
 801fa44:	f107 0738 	add.w	r7, r7, #56	; 0x38
 801fa48:	46bd      	mov	sp, r7
 801fa4a:	bd80      	pop	{r7, pc}

0801fa4c <f_getfree>:
FRESULT f_getfree (
	const XCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
 801fa4c:	b580      	push	{r7, lr}
 801fa4e:	b08c      	sub	sp, #48	; 0x30
 801fa50:	af00      	add	r7, sp, #0
 801fa52:	60f8      	str	r0, [r7, #12]
 801fa54:	60b9      	str	r1, [r7, #8]
 801fa56:	607a      	str	r2, [r7, #4]
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = auto_mount(&path, fatfs, 0);
 801fa58:	f107 030c 	add.w	r3, r7, #12
 801fa5c:	4618      	mov	r0, r3
 801fa5e:	6879      	ldr	r1, [r7, #4]
 801fa60:	f04f 0200 	mov.w	r2, #0
 801fa64:	f7fe fc14 	bl	801e290 <auto_mount>
 801fa68:	4603      	mov	r3, r0
 801fa6a:	76fb      	strb	r3, [r7, #27]
	if (res != FR_OK) LEAVE_FF(*fatfs, res);
 801fa6c:	7efb      	ldrb	r3, [r7, #27]
 801fa6e:	2b00      	cmp	r3, #0
 801fa70:	d001      	beq.n	801fa76 <f_getfree+0x2a>
 801fa72:	7efb      	ldrb	r3, [r7, #27]
 801fa74:	e0ca      	b.n	801fc0c <f_getfree+0x1c0>

	/* If number of free cluster is valid, return it without cluster scan. */
	if ((*fatfs)->free_clust <= (*fatfs)->max_clust - 2) {
 801fa76:	687b      	ldr	r3, [r7, #4]
 801fa78:	681b      	ldr	r3, [r3, #0]
 801fa7a:	691a      	ldr	r2, [r3, #16]
 801fa7c:	687b      	ldr	r3, [r7, #4]
 801fa7e:	681b      	ldr	r3, [r3, #0]
 801fa80:	6a1b      	ldr	r3, [r3, #32]
 801fa82:	f1a3 0302 	sub.w	r3, r3, #2
 801fa86:	429a      	cmp	r2, r3
 801fa88:	d807      	bhi.n	801fa9a <f_getfree+0x4e>
		*nclst = (*fatfs)->free_clust;
 801fa8a:	687b      	ldr	r3, [r7, #4]
 801fa8c:	681b      	ldr	r3, [r3, #0]
 801fa8e:	691a      	ldr	r2, [r3, #16]
 801fa90:	68bb      	ldr	r3, [r7, #8]
 801fa92:	601a      	str	r2, [r3, #0]
		LEAVE_FF(*fatfs, FR_OK);
 801fa94:	f04f 0300 	mov.w	r3, #0
 801fa98:	e0b8      	b.n	801fc0c <f_getfree+0x1c0>
	}

	/* Get number of free clusters */
	fat = (*fatfs)->fs_type;
 801fa9a:	687b      	ldr	r3, [r7, #4]
 801fa9c:	681b      	ldr	r3, [r3, #0]
 801fa9e:	781b      	ldrb	r3, [r3, #0]
 801faa0:	76bb      	strb	r3, [r7, #26]
	n = 0;
 801faa2:	f04f 0300 	mov.w	r3, #0
 801faa6:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (fat == FS_FAT12) {
 801faa8:	7ebb      	ldrb	r3, [r7, #26]
 801faaa:	2b01      	cmp	r3, #1
 801faac:	d129      	bne.n	801fb02 <f_getfree+0xb6>
		clst = 2;
 801faae:	f04f 0302 	mov.w	r3, #2
 801fab2:	62bb      	str	r3, [r7, #40]	; 0x28
		do {
			stat = get_fat(*fatfs, clst);
 801fab4:	687b      	ldr	r3, [r7, #4]
 801fab6:	681b      	ldr	r3, [r3, #0]
 801fab8:	4618      	mov	r0, r3
 801faba:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801fabc:	f7fd fb3c 	bl	801d138 <get_fat>
 801fac0:	4603      	mov	r3, r0
 801fac2:	617b      	str	r3, [r7, #20]
			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
 801fac4:	697b      	ldr	r3, [r7, #20]
 801fac6:	f1b3 3fff 	cmp.w	r3, #4294967295
 801faca:	d102      	bne.n	801fad2 <f_getfree+0x86>
 801facc:	f04f 0301 	mov.w	r3, #1
 801fad0:	e09c      	b.n	801fc0c <f_getfree+0x1c0>
			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
 801fad2:	697b      	ldr	r3, [r7, #20]
 801fad4:	2b01      	cmp	r3, #1
 801fad6:	d102      	bne.n	801fade <f_getfree+0x92>
 801fad8:	f04f 0302 	mov.w	r3, #2
 801fadc:	e096      	b.n	801fc0c <f_getfree+0x1c0>
			if (stat == 0) n++;
 801fade:	697b      	ldr	r3, [r7, #20]
 801fae0:	2b00      	cmp	r3, #0
 801fae2:	d103      	bne.n	801faec <f_getfree+0xa0>
 801fae4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801fae6:	f103 0301 	add.w	r3, r3, #1
 801faea:	62fb      	str	r3, [r7, #44]	; 0x2c
		} while (++clst < (*fatfs)->max_clust);
 801faec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801faee:	f103 0301 	add.w	r3, r3, #1
 801faf2:	62bb      	str	r3, [r7, #40]	; 0x28
 801faf4:	687b      	ldr	r3, [r7, #4]
 801faf6:	681b      	ldr	r3, [r3, #0]
 801faf8:	6a1b      	ldr	r3, [r3, #32]
 801fafa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801fafc:	429a      	cmp	r2, r3
 801fafe:	d3d9      	bcc.n	801fab4 <f_getfree+0x68>
 801fb00:	e073      	b.n	801fbea <f_getfree+0x19e>
	} else {
		clst = (*fatfs)->max_clust;
 801fb02:	687b      	ldr	r3, [r7, #4]
 801fb04:	681b      	ldr	r3, [r3, #0]
 801fb06:	6a1b      	ldr	r3, [r3, #32]
 801fb08:	62bb      	str	r3, [r7, #40]	; 0x28
		sect = (*fatfs)->fatbase;
 801fb0a:	687b      	ldr	r3, [r7, #4]
 801fb0c:	681b      	ldr	r3, [r3, #0]
 801fb0e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801fb10:	627b      	str	r3, [r7, #36]	; 0x24
		i = 0; p = 0;
 801fb12:	f04f 0300 	mov.w	r3, #0
 801fb16:	623b      	str	r3, [r7, #32]
 801fb18:	f04f 0300 	mov.w	r3, #0
 801fb1c:	61fb      	str	r3, [r7, #28]
		do {
			if (!i) {
 801fb1e:	6a3b      	ldr	r3, [r7, #32]
 801fb20:	2b00      	cmp	r3, #0
 801fb22:	d119      	bne.n	801fb58 <f_getfree+0x10c>
				res = move_window(*fatfs, sect++);
 801fb24:	687b      	ldr	r3, [r7, #4]
 801fb26:	681a      	ldr	r2, [r3, #0]
 801fb28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801fb2a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801fb2c:	f101 0101 	add.w	r1, r1, #1
 801fb30:	6279      	str	r1, [r7, #36]	; 0x24
 801fb32:	4610      	mov	r0, r2
 801fb34:	4619      	mov	r1, r3
 801fb36:	f7fd f9d5 	bl	801cee4 <move_window>
 801fb3a:	4603      	mov	r3, r0
 801fb3c:	76fb      	strb	r3, [r7, #27]
				if (res != FR_OK)
 801fb3e:	7efb      	ldrb	r3, [r7, #27]
 801fb40:	2b00      	cmp	r3, #0
 801fb42:	d001      	beq.n	801fb48 <f_getfree+0xfc>
					LEAVE_FF(*fatfs, res);
 801fb44:	7efb      	ldrb	r3, [r7, #27]
 801fb46:	e061      	b.n	801fc0c <f_getfree+0x1c0>
				p = (*fatfs)->win;
 801fb48:	687b      	ldr	r3, [r7, #4]
 801fb4a:	681b      	ldr	r3, [r3, #0]
 801fb4c:	f103 0334 	add.w	r3, r3, #52	; 0x34
 801fb50:	61fb      	str	r3, [r7, #28]
				i = SS(*fatfs);
 801fb52:	f44f 7300 	mov.w	r3, #512	; 0x200
 801fb56:	623b      	str	r3, [r7, #32]
			}
			if (fat == FS_FAT16) {
 801fb58:	7ebb      	ldrb	r3, [r7, #26]
 801fb5a:	2b02      	cmp	r3, #2
 801fb5c:	d119      	bne.n	801fb92 <f_getfree+0x146>
				if (LD_WORD(p) == 0) n++;
 801fb5e:	69fb      	ldr	r3, [r7, #28]
 801fb60:	f103 0301 	add.w	r3, r3, #1
 801fb64:	781b      	ldrb	r3, [r3, #0]
 801fb66:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801fb6a:	b29a      	uxth	r2, r3
 801fb6c:	69fb      	ldr	r3, [r7, #28]
 801fb6e:	781b      	ldrb	r3, [r3, #0]
 801fb70:	4313      	orrs	r3, r2
 801fb72:	b29b      	uxth	r3, r3
 801fb74:	2b00      	cmp	r3, #0
 801fb76:	d103      	bne.n	801fb80 <f_getfree+0x134>
 801fb78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801fb7a:	f103 0301 	add.w	r3, r3, #1
 801fb7e:	62fb      	str	r3, [r7, #44]	; 0x2c
				p += 2; i -= 2;
 801fb80:	69fb      	ldr	r3, [r7, #28]
 801fb82:	f103 0302 	add.w	r3, r3, #2
 801fb86:	61fb      	str	r3, [r7, #28]
 801fb88:	6a3b      	ldr	r3, [r7, #32]
 801fb8a:	f1a3 0302 	sub.w	r3, r3, #2
 801fb8e:	623b      	str	r3, [r7, #32]
 801fb90:	e024      	b.n	801fbdc <f_getfree+0x190>
			} else {
				if (LD_DWORD(p) == 0) n++;
 801fb92:	69fb      	ldr	r3, [r7, #28]
 801fb94:	f103 0303 	add.w	r3, r3, #3
 801fb98:	781b      	ldrb	r3, [r3, #0]
 801fb9a:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801fb9e:	69fb      	ldr	r3, [r7, #28]
 801fba0:	f103 0302 	add.w	r3, r3, #2
 801fba4:	781b      	ldrb	r3, [r3, #0]
 801fba6:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801fbaa:	431a      	orrs	r2, r3
 801fbac:	69fb      	ldr	r3, [r7, #28]
 801fbae:	f103 0301 	add.w	r3, r3, #1
 801fbb2:	781b      	ldrb	r3, [r3, #0]
 801fbb4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801fbb8:	431a      	orrs	r2, r3
 801fbba:	69fb      	ldr	r3, [r7, #28]
 801fbbc:	781b      	ldrb	r3, [r3, #0]
 801fbbe:	4313      	orrs	r3, r2
 801fbc0:	2b00      	cmp	r3, #0
 801fbc2:	d103      	bne.n	801fbcc <f_getfree+0x180>
 801fbc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801fbc6:	f103 0301 	add.w	r3, r3, #1
 801fbca:	62fb      	str	r3, [r7, #44]	; 0x2c
				p += 4; i -= 4;
 801fbcc:	69fb      	ldr	r3, [r7, #28]
 801fbce:	f103 0304 	add.w	r3, r3, #4
 801fbd2:	61fb      	str	r3, [r7, #28]
 801fbd4:	6a3b      	ldr	r3, [r7, #32]
 801fbd6:	f1a3 0304 	sub.w	r3, r3, #4
 801fbda:	623b      	str	r3, [r7, #32]
			}
		} while (--clst);
 801fbdc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801fbde:	f103 33ff 	add.w	r3, r3, #4294967295
 801fbe2:	62bb      	str	r3, [r7, #40]	; 0x28
 801fbe4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801fbe6:	2b00      	cmp	r3, #0
 801fbe8:	d199      	bne.n	801fb1e <f_getfree+0xd2>
	}
	(*fatfs)->free_clust = n;
 801fbea:	687b      	ldr	r3, [r7, #4]
 801fbec:	681b      	ldr	r3, [r3, #0]
 801fbee:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801fbf0:	611a      	str	r2, [r3, #16]
	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
 801fbf2:	7ebb      	ldrb	r3, [r7, #26]
 801fbf4:	2b03      	cmp	r3, #3
 801fbf6:	d104      	bne.n	801fc02 <f_getfree+0x1b6>
 801fbf8:	687b      	ldr	r3, [r7, #4]
 801fbfa:	681b      	ldr	r3, [r3, #0]
 801fbfc:	f04f 0201 	mov.w	r2, #1
 801fc00:	729a      	strb	r2, [r3, #10]
	*nclst = n;
 801fc02:	68bb      	ldr	r3, [r7, #8]
 801fc04:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801fc06:	601a      	str	r2, [r3, #0]

	LEAVE_FF(*fatfs, FR_OK);
 801fc08:	f04f 0300 	mov.w	r3, #0
}
 801fc0c:	4618      	mov	r0, r3
 801fc0e:	f107 0730 	add.w	r7, r7, #48	; 0x30
 801fc12:	46bd      	mov	sp, r7
 801fc14:	bd80      	pop	{r7, pc}
 801fc16:	bf00      	nop

0801fc18 <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
 801fc18:	b580      	push	{r7, lr}
 801fc1a:	b084      	sub	sp, #16
 801fc1c:	af00      	add	r7, sp, #0
 801fc1e:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DWORD ncl;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 801fc20:	687b      	ldr	r3, [r7, #4]
 801fc22:	681a      	ldr	r2, [r3, #0]
 801fc24:	687b      	ldr	r3, [r7, #4]
 801fc26:	889b      	ldrh	r3, [r3, #4]
 801fc28:	4610      	mov	r0, r2
 801fc2a:	4619      	mov	r1, r3
 801fc2c:	f7fe fdc0 	bl	801e7b0 <validate>
 801fc30:	4603      	mov	r3, r0
 801fc32:	73fb      	strb	r3, [r7, #15]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 801fc34:	7bfb      	ldrb	r3, [r7, #15]
 801fc36:	2b00      	cmp	r3, #0
 801fc38:	d001      	beq.n	801fc3e <f_truncate+0x26>
 801fc3a:	7bfb      	ldrb	r3, [r7, #15]
 801fc3c:	e07a      	b.n	801fd34 <f_truncate+0x11c>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
 801fc3e:	687b      	ldr	r3, [r7, #4]
 801fc40:	799b      	ldrb	r3, [r3, #6]
 801fc42:	b2db      	uxtb	r3, r3
 801fc44:	b25b      	sxtb	r3, r3
 801fc46:	2b00      	cmp	r3, #0
 801fc48:	da02      	bge.n	801fc50 <f_truncate+0x38>
		LEAVE_FF(fp->fs, FR_INT_ERR);
 801fc4a:	f04f 0302 	mov.w	r3, #2
 801fc4e:	e071      	b.n	801fd34 <f_truncate+0x11c>
	if (!(fp->flag & FA_WRITE))			/* Check access mode */
 801fc50:	687b      	ldr	r3, [r7, #4]
 801fc52:	799b      	ldrb	r3, [r3, #6]
 801fc54:	f003 0302 	and.w	r3, r3, #2
 801fc58:	2b00      	cmp	r3, #0
 801fc5a:	d102      	bne.n	801fc62 <f_truncate+0x4a>
		LEAVE_FF(fp->fs, FR_DENIED);
 801fc5c:	f04f 0307 	mov.w	r3, #7
 801fc60:	e068      	b.n	801fd34 <f_truncate+0x11c>

	if (fp->fsize > fp->fptr) {
 801fc62:	687b      	ldr	r3, [r7, #4]
 801fc64:	68da      	ldr	r2, [r3, #12]
 801fc66:	687b      	ldr	r3, [r7, #4]
 801fc68:	689b      	ldr	r3, [r3, #8]
 801fc6a:	429a      	cmp	r2, r3
 801fc6c:	d957      	bls.n	801fd1e <f_truncate+0x106>
		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
 801fc6e:	687b      	ldr	r3, [r7, #4]
 801fc70:	689a      	ldr	r2, [r3, #8]
 801fc72:	687b      	ldr	r3, [r7, #4]
 801fc74:	60da      	str	r2, [r3, #12]
		fp->flag |= FA__WRITTEN;
 801fc76:	687b      	ldr	r3, [r7, #4]
 801fc78:	799b      	ldrb	r3, [r3, #6]
 801fc7a:	f043 0320 	orr.w	r3, r3, #32
 801fc7e:	b2da      	uxtb	r2, r3
 801fc80:	687b      	ldr	r3, [r7, #4]
 801fc82:	719a      	strb	r2, [r3, #6]
		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 801fc84:	687b      	ldr	r3, [r7, #4]
 801fc86:	689b      	ldr	r3, [r3, #8]
 801fc88:	2b00      	cmp	r3, #0
 801fc8a:	d10e      	bne.n	801fcaa <f_truncate+0x92>
			res = remove_chain(fp->fs, fp->org_clust);
 801fc8c:	687b      	ldr	r3, [r7, #4]
 801fc8e:	681a      	ldr	r2, [r3, #0]
 801fc90:	687b      	ldr	r3, [r7, #4]
 801fc92:	691b      	ldr	r3, [r3, #16]
 801fc94:	4610      	mov	r0, r2
 801fc96:	4619      	mov	r1, r3
 801fc98:	f7fd fc82 	bl	801d5a0 <remove_chain>
 801fc9c:	4603      	mov	r3, r0
 801fc9e:	73fb      	strb	r3, [r7, #15]
			fp->org_clust = 0;
 801fca0:	687b      	ldr	r3, [r7, #4]
 801fca2:	f04f 0200 	mov.w	r2, #0
 801fca6:	611a      	str	r2, [r3, #16]
 801fca8:	e039      	b.n	801fd1e <f_truncate+0x106>
		} else {				/* When truncate a part of the file, remove remaining clusters */
			ncl = get_fat(fp->fs, fp->curr_clust);
 801fcaa:	687b      	ldr	r3, [r7, #4]
 801fcac:	681a      	ldr	r2, [r3, #0]
 801fcae:	687b      	ldr	r3, [r7, #4]
 801fcb0:	695b      	ldr	r3, [r3, #20]
 801fcb2:	4610      	mov	r0, r2
 801fcb4:	4619      	mov	r1, r3
 801fcb6:	f7fd fa3f 	bl	801d138 <get_fat>
 801fcba:	4603      	mov	r3, r0
 801fcbc:	60bb      	str	r3, [r7, #8]
			res = FR_OK;
 801fcbe:	f04f 0300 	mov.w	r3, #0
 801fcc2:	73fb      	strb	r3, [r7, #15]
			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 801fcc4:	68bb      	ldr	r3, [r7, #8]
 801fcc6:	f1b3 3fff 	cmp.w	r3, #4294967295
 801fcca:	d102      	bne.n	801fcd2 <f_truncate+0xba>
 801fccc:	f04f 0301 	mov.w	r3, #1
 801fcd0:	73fb      	strb	r3, [r7, #15]
			if (ncl == 1) res = FR_INT_ERR;
 801fcd2:	68bb      	ldr	r3, [r7, #8]
 801fcd4:	2b01      	cmp	r3, #1
 801fcd6:	d102      	bne.n	801fcde <f_truncate+0xc6>
 801fcd8:	f04f 0302 	mov.w	r3, #2
 801fcdc:	73fb      	strb	r3, [r7, #15]
			if (res == FR_OK && ncl < fp->fs->max_clust) {
 801fcde:	7bfb      	ldrb	r3, [r7, #15]
 801fce0:	2b00      	cmp	r3, #0
 801fce2:	d11c      	bne.n	801fd1e <f_truncate+0x106>
 801fce4:	687b      	ldr	r3, [r7, #4]
 801fce6:	681b      	ldr	r3, [r3, #0]
 801fce8:	6a1a      	ldr	r2, [r3, #32]
 801fcea:	68bb      	ldr	r3, [r7, #8]
 801fcec:	429a      	cmp	r2, r3
 801fcee:	d916      	bls.n	801fd1e <f_truncate+0x106>
				res = put_fat(fp->fs, fp->curr_clust, 0x0FFFFFFF);
 801fcf0:	687b      	ldr	r3, [r7, #4]
 801fcf2:	681a      	ldr	r2, [r3, #0]
 801fcf4:	687b      	ldr	r3, [r7, #4]
 801fcf6:	695b      	ldr	r3, [r3, #20]
 801fcf8:	4610      	mov	r0, r2
 801fcfa:	4619      	mov	r1, r3
 801fcfc:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 801fd00:	f7fd fb14 	bl	801d32c <put_fat>
 801fd04:	4603      	mov	r3, r0
 801fd06:	73fb      	strb	r3, [r7, #15]
				if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 801fd08:	7bfb      	ldrb	r3, [r7, #15]
 801fd0a:	2b00      	cmp	r3, #0
 801fd0c:	d107      	bne.n	801fd1e <f_truncate+0x106>
 801fd0e:	687b      	ldr	r3, [r7, #4]
 801fd10:	681b      	ldr	r3, [r3, #0]
 801fd12:	4618      	mov	r0, r3
 801fd14:	68b9      	ldr	r1, [r7, #8]
 801fd16:	f7fd fc43 	bl	801d5a0 <remove_chain>
 801fd1a:	4603      	mov	r3, r0
 801fd1c:	73fb      	strb	r3, [r7, #15]
			}
		}
	}
	if (res != FR_OK) fp->flag |= FA__ERROR;
 801fd1e:	7bfb      	ldrb	r3, [r7, #15]
 801fd20:	2b00      	cmp	r3, #0
 801fd22:	d006      	beq.n	801fd32 <f_truncate+0x11a>
 801fd24:	687b      	ldr	r3, [r7, #4]
 801fd26:	799b      	ldrb	r3, [r3, #6]
 801fd28:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801fd2c:	b2da      	uxtb	r2, r3
 801fd2e:	687b      	ldr	r3, [r7, #4]
 801fd30:	719a      	strb	r2, [r3, #6]

	LEAVE_FF(fp->fs, res);
 801fd32:	7bfb      	ldrb	r3, [r7, #15]
}
 801fd34:	4618      	mov	r0, r3
 801fd36:	f107 0710 	add.w	r7, r7, #16
 801fd3a:	46bd      	mov	sp, r7
 801fd3c:	bd80      	pop	{r7, pc}
 801fd3e:	bf00      	nop

0801fd40 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const XCHAR *path		/* Pointer to the file or directory path */
)
{
 801fd40:	b580      	push	{r7, lr}
 801fd42:	b096      	sub	sp, #88	; 0x58
 801fd44:	af00      	add	r7, sp, #0
 801fd46:	6078      	str	r0, [r7, #4]
	NAMEBUF(sfn, lfn);
	BYTE *dir;
	DWORD dclst;


	res = auto_mount(&path, &dj.fs, 1);
 801fd48:	f107 0204 	add.w	r2, r7, #4
 801fd4c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801fd50:	4610      	mov	r0, r2
 801fd52:	4619      	mov	r1, r3
 801fd54:	f04f 0201 	mov.w	r2, #1
 801fd58:	f7fe fa9a 	bl	801e290 <auto_mount>
 801fd5c:	4603      	mov	r3, r0
 801fd5e:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 801fd62:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fd66:	2b00      	cmp	r3, #0
 801fd68:	d002      	beq.n	801fd70 <f_unlink+0x30>
 801fd6a:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fd6e:	e0bd      	b.n	801feec <f_unlink+0x1ac>

	INITBUF(dj, sfn, lfn);
 801fd70:	f107 0308 	add.w	r3, r7, #8
 801fd74:	64bb      	str	r3, [r7, #72]	; 0x48
	res = follow_path(&dj, path);			/* Follow the file path */
 801fd76:	687b      	ldr	r3, [r7, #4]
 801fd78:	f107 0230 	add.w	r2, r7, #48	; 0x30
 801fd7c:	4610      	mov	r0, r2
 801fd7e:	4619      	mov	r1, r3
 801fd80:	f7fe f99a 	bl	801e0b8 <follow_path>
 801fd84:	4603      	mov	r3, r0
 801fd86:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	if (_FS_RPATH && res == FR_OK && (dj.fn[11] & NS_DOT))
 801fd8a:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fd8e:	2b00      	cmp	r3, #0
 801fd90:	d10b      	bne.n	801fdaa <f_unlink+0x6a>
 801fd92:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801fd94:	f103 030b 	add.w	r3, r3, #11
 801fd98:	781b      	ldrb	r3, [r3, #0]
 801fd9a:	f003 0320 	and.w	r3, r3, #32
 801fd9e:	2b00      	cmp	r3, #0
 801fda0:	d003      	beq.n	801fdaa <f_unlink+0x6a>
		res = FR_INVALID_NAME;
 801fda2:	f04f 0306 	mov.w	r3, #6
 801fda6:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
 801fdaa:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fdae:	2b00      	cmp	r3, #0
 801fdb0:	d002      	beq.n	801fdb8 <f_unlink+0x78>
 801fdb2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fdb6:	e099      	b.n	801feec <f_unlink+0x1ac>

	dir = dj.dir;
 801fdb8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801fdba:	653b      	str	r3, [r7, #80]	; 0x50
	if (!dir)								/* Is it the root directory? */
 801fdbc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801fdbe:	2b00      	cmp	r3, #0
 801fdc0:	d102      	bne.n	801fdc8 <f_unlink+0x88>
		LEAVE_FF(dj.fs, FR_INVALID_NAME);
 801fdc2:	f04f 0306 	mov.w	r3, #6
 801fdc6:	e091      	b.n	801feec <f_unlink+0x1ac>
	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
 801fdc8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801fdca:	f103 030b 	add.w	r3, r3, #11
 801fdce:	781b      	ldrb	r3, [r3, #0]
 801fdd0:	f003 0301 	and.w	r3, r3, #1
 801fdd4:	b2db      	uxtb	r3, r3
 801fdd6:	2b00      	cmp	r3, #0
 801fdd8:	d002      	beq.n	801fde0 <f_unlink+0xa0>
		LEAVE_FF(dj.fs, FR_DENIED);
 801fdda:	f04f 0307 	mov.w	r3, #7
 801fdde:	e085      	b.n	801feec <f_unlink+0x1ac>
	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 801fde0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801fde2:	f103 0315 	add.w	r3, r3, #21
 801fde6:	781b      	ldrb	r3, [r3, #0]
 801fde8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801fdec:	b29a      	uxth	r2, r3
 801fdee:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801fdf0:	f103 0314 	add.w	r3, r3, #20
 801fdf4:	781b      	ldrb	r3, [r3, #0]
 801fdf6:	4313      	orrs	r3, r2
 801fdf8:	b29b      	uxth	r3, r3
 801fdfa:	b29b      	uxth	r3, r3
 801fdfc:	ea4f 4203 	mov.w	r2, r3, lsl #16
 801fe00:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801fe02:	f103 031b 	add.w	r3, r3, #27
 801fe06:	781b      	ldrb	r3, [r3, #0]
 801fe08:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801fe0c:	b299      	uxth	r1, r3
 801fe0e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801fe10:	f103 031a 	add.w	r3, r3, #26
 801fe14:	781b      	ldrb	r3, [r3, #0]
 801fe16:	430b      	orrs	r3, r1
 801fe18:	b29b      	uxth	r3, r3
 801fe1a:	b29b      	uxth	r3, r3
 801fe1c:	4313      	orrs	r3, r2
 801fe1e:	64fb      	str	r3, [r7, #76]	; 0x4c

	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
 801fe20:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801fe22:	f103 030b 	add.w	r3, r3, #11
 801fe26:	781b      	ldrb	r3, [r3, #0]
 801fe28:	f003 0310 	and.w	r3, r3, #16
 801fe2c:	2b00      	cmp	r3, #0
 801fe2e:	d039      	beq.n	801fea4 <f_unlink+0x164>
		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
 801fe30:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801fe32:	2b01      	cmp	r3, #1
 801fe34:	d802      	bhi.n	801fe3c <f_unlink+0xfc>
 801fe36:	f04f 0302 	mov.w	r3, #2
 801fe3a:	e057      	b.n	801feec <f_unlink+0x1ac>
		mem_cpy(&sdj, &dj, sizeof(DIR));		/* Check if the sub-dir is empty or not */
 801fe3c:	f107 0214 	add.w	r2, r7, #20
 801fe40:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801fe44:	4610      	mov	r0, r2
 801fe46:	4619      	mov	r1, r3
 801fe48:	f04f 021c 	mov.w	r2, #28
 801fe4c:	f7fc ffac 	bl	801cda8 <mem_cpy>
		sdj.sclust = dclst;
 801fe50:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801fe52:	61fb      	str	r3, [r7, #28]
		res = dir_seek(&sdj, 0);
 801fe54:	f107 0314 	add.w	r3, r7, #20
 801fe58:	4618      	mov	r0, r3
 801fe5a:	f04f 0100 	mov.w	r1, #0
 801fe5e:	f7fd fca9 	bl	801d7b4 <dir_seek>
 801fe62:	4603      	mov	r3, r0
 801fe64:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		if (res != FR_OK) LEAVE_FF(dj.fs, res);
 801fe68:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fe6c:	2b00      	cmp	r3, #0
 801fe6e:	d002      	beq.n	801fe76 <f_unlink+0x136>
 801fe70:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fe74:	e03a      	b.n	801feec <f_unlink+0x1ac>
		res = dir_read(&sdj);
 801fe76:	f107 0314 	add.w	r3, r7, #20
 801fe7a:	4618      	mov	r0, r3
 801fe7c:	f7fd fe6a 	bl	801db54 <dir_read>
 801fe80:	4603      	mov	r3, r0
 801fe82:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
 801fe86:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fe8a:	2b00      	cmp	r3, #0
 801fe8c:	d103      	bne.n	801fe96 <f_unlink+0x156>
 801fe8e:	f04f 0307 	mov.w	r3, #7
 801fe92:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
 801fe96:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fe9a:	2b04      	cmp	r3, #4
 801fe9c:	d002      	beq.n	801fea4 <f_unlink+0x164>
 801fe9e:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fea2:	e023      	b.n	801feec <f_unlink+0x1ac>
	}

	res = dir_remove(&dj);					/* Remove directory entry */
 801fea4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801fea8:	4618      	mov	r0, r3
 801feaa:	f7fd ff0b 	bl	801dcc4 <dir_remove>
 801feae:	4603      	mov	r3, r0
 801feb0:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	if (res == FR_OK) {
 801feb4:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801feb8:	2b00      	cmp	r3, #0
 801feba:	d115      	bne.n	801fee8 <f_unlink+0x1a8>
		if (dclst)
 801febc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801febe:	2b00      	cmp	r3, #0
 801fec0:	d007      	beq.n	801fed2 <f_unlink+0x192>
			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
 801fec2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801fec4:	4618      	mov	r0, r3
 801fec6:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801fec8:	f7fd fb6a 	bl	801d5a0 <remove_chain>
 801fecc:	4603      	mov	r3, r0
 801fece:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		if (res == FR_OK) res = sync(dj.fs);
 801fed2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801fed6:	2b00      	cmp	r3, #0
 801fed8:	d106      	bne.n	801fee8 <f_unlink+0x1a8>
 801feda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801fedc:	4618      	mov	r0, r3
 801fede:	f7fd f86b 	bl	801cfb8 <sync>
 801fee2:	4603      	mov	r3, r0
 801fee4:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	}

	LEAVE_FF(dj.fs, res);
 801fee8:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
}
 801feec:	4618      	mov	r0, r3
 801feee:	f107 0758 	add.w	r7, r7, #88	; 0x58
 801fef2:	46bd      	mov	sp, r7
 801fef4:	bd80      	pop	{r7, pc}
 801fef6:	bf00      	nop

0801fef8 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const XCHAR *path		/* Pointer to the directory path */
)
{
 801fef8:	b580      	push	{r7, lr}
 801fefa:	b092      	sub	sp, #72	; 0x48
 801fefc:	af00      	add	r7, sp, #0
 801fefe:	6078      	str	r0, [r7, #4]
	NAMEBUF(sfn, lfn);
	BYTE *dir, n;
	DWORD dsect, dclst, pclst, tim;


	res = auto_mount(&path, &dj.fs, 1);
 801ff00:	f107 0204 	add.w	r2, r7, #4
 801ff04:	f107 0314 	add.w	r3, r7, #20
 801ff08:	4610      	mov	r0, r2
 801ff0a:	4619      	mov	r1, r3
 801ff0c:	f04f 0201 	mov.w	r2, #1
 801ff10:	f7fe f9be 	bl	801e290 <auto_mount>
 801ff14:	4603      	mov	r3, r0
 801ff16:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 801ff1a:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ff1e:	2b00      	cmp	r3, #0
 801ff20:	d002      	beq.n	801ff28 <f_mkdir+0x30>
 801ff22:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ff26:	e1ab      	b.n	8020280 <f_mkdir+0x388>

	INITBUF(dj, sfn, lfn);
 801ff28:	f107 0308 	add.w	r3, r7, #8
 801ff2c:	62fb      	str	r3, [r7, #44]	; 0x2c
	res = follow_path(&dj, path);			/* Follow the file path */
 801ff2e:	687b      	ldr	r3, [r7, #4]
 801ff30:	f107 0214 	add.w	r2, r7, #20
 801ff34:	4610      	mov	r0, r2
 801ff36:	4619      	mov	r1, r3
 801ff38:	f7fe f8be 	bl	801e0b8 <follow_path>
 801ff3c:	4603      	mov	r3, r0
 801ff3e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (res == FR_OK) res = FR_EXIST;		/* Any file or directory is already existing */
 801ff42:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ff46:	2b00      	cmp	r3, #0
 801ff48:	d103      	bne.n	801ff52 <f_mkdir+0x5a>
 801ff4a:	f04f 0308 	mov.w	r3, #8
 801ff4e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[11] & NS_DOT))
 801ff52:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ff56:	2b04      	cmp	r3, #4
 801ff58:	d10b      	bne.n	801ff72 <f_mkdir+0x7a>
 801ff5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ff5c:	f103 030b 	add.w	r3, r3, #11
 801ff60:	781b      	ldrb	r3, [r3, #0]
 801ff62:	f003 0320 	and.w	r3, r3, #32
 801ff66:	2b00      	cmp	r3, #0
 801ff68:	d003      	beq.n	801ff72 <f_mkdir+0x7a>
		res = FR_INVALID_NAME;
 801ff6a:	f04f 0306 	mov.w	r3, #6
 801ff6e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (res != FR_NO_FILE)					/* Any error occured */
 801ff72:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ff76:	2b04      	cmp	r3, #4
 801ff78:	d002      	beq.n	801ff80 <f_mkdir+0x88>
		LEAVE_FF(dj.fs, res);
 801ff7a:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ff7e:	e17f      	b.n	8020280 <f_mkdir+0x388>

	dclst = create_chain(dj.fs, 0);			/* Allocate a new cluster for new directory table */
 801ff80:	697b      	ldr	r3, [r7, #20]
 801ff82:	4618      	mov	r0, r3
 801ff84:	f04f 0100 	mov.w	r1, #0
 801ff88:	f7fd fb62 	bl	801d650 <create_chain>
 801ff8c:	4603      	mov	r3, r0
 801ff8e:	63bb      	str	r3, [r7, #56]	; 0x38
	res = FR_OK;
 801ff90:	f04f 0300 	mov.w	r3, #0
 801ff94:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (dclst == 0) res = FR_DENIED;
 801ff98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ff9a:	2b00      	cmp	r3, #0
 801ff9c:	d103      	bne.n	801ffa6 <f_mkdir+0xae>
 801ff9e:	f04f 0307 	mov.w	r3, #7
 801ffa2:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (dclst == 1) res = FR_INT_ERR;
 801ffa6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ffa8:	2b01      	cmp	r3, #1
 801ffaa:	d103      	bne.n	801ffb4 <f_mkdir+0xbc>
 801ffac:	f04f 0302 	mov.w	r3, #2
 801ffb0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
 801ffb4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ffb6:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ffba:	d103      	bne.n	801ffc4 <f_mkdir+0xcc>
 801ffbc:	f04f 0301 	mov.w	r3, #1
 801ffc0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (res == FR_OK)
 801ffc4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ffc8:	2b00      	cmp	r3, #0
 801ffca:	d108      	bne.n	801ffde <f_mkdir+0xe6>
		res = move_window(dj.fs, 0);
 801ffcc:	697b      	ldr	r3, [r7, #20]
 801ffce:	4618      	mov	r0, r3
 801ffd0:	f04f 0100 	mov.w	r1, #0
 801ffd4:	f7fc ff86 	bl	801cee4 <move_window>
 801ffd8:	4603      	mov	r3, r0
 801ffda:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 801ffde:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ffe2:	2b00      	cmp	r3, #0
 801ffe4:	d002      	beq.n	801ffec <f_mkdir+0xf4>
 801ffe6:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ffea:	e149      	b.n	8020280 <f_mkdir+0x388>
	dsect = clust2sect(dj.fs, dclst);
 801ffec:	697b      	ldr	r3, [r7, #20]
 801ffee:	4618      	mov	r0, r3
 801fff0:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801fff2:	f7fd fbbd 	bl	801d770 <clust2sect>
 801fff6:	4603      	mov	r3, r0
 801fff8:	643b      	str	r3, [r7, #64]	; 0x40

	dir = dj.fs->win;						/* Initialize the new directory table */
 801fffa:	697b      	ldr	r3, [r7, #20]
 801fffc:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8020000:	637b      	str	r3, [r7, #52]	; 0x34
	mem_set(dir, 0, SS(dj.fs));
 8020002:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8020004:	f04f 0100 	mov.w	r1, #0
 8020008:	f44f 7200 	mov.w	r2, #512	; 0x200
 802000c:	f7fc fef4 	bl	801cdf8 <mem_set>
	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
 8020010:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8020012:	f04f 0120 	mov.w	r1, #32
 8020016:	f04f 020b 	mov.w	r2, #11
 802001a:	f7fc feed 	bl	801cdf8 <mem_set>
	dir[DIR_Name] = '.';
 802001e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020020:	f04f 022e 	mov.w	r2, #46	; 0x2e
 8020024:	701a      	strb	r2, [r3, #0]
	dir[DIR_Attr] = AM_DIR;
 8020026:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020028:	f103 030b 	add.w	r3, r3, #11
 802002c:	f04f 0210 	mov.w	r2, #16
 8020030:	701a      	strb	r2, [r3, #0]
	tim = get_fattime();
 8020032:	f001 ffcb 	bl	8021fcc <get_fattime>
 8020036:	4603      	mov	r3, r0
 8020038:	633b      	str	r3, [r7, #48]	; 0x30
	ST_DWORD(dir+DIR_WrtTime, tim);
 802003a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802003c:	f103 0316 	add.w	r3, r3, #22
 8020040:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8020042:	b2d2      	uxtb	r2, r2
 8020044:	701a      	strb	r2, [r3, #0]
 8020046:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020048:	f103 0317 	add.w	r3, r3, #23
 802004c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802004e:	b292      	uxth	r2, r2
 8020050:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020054:	b292      	uxth	r2, r2
 8020056:	b2d2      	uxtb	r2, r2
 8020058:	701a      	strb	r2, [r3, #0]
 802005a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802005c:	f103 0318 	add.w	r3, r3, #24
 8020060:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8020062:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020066:	b2d2      	uxtb	r2, r2
 8020068:	701a      	strb	r2, [r3, #0]
 802006a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802006c:	f103 0319 	add.w	r3, r3, #25
 8020070:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8020072:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8020076:	b2d2      	uxtb	r2, r2
 8020078:	701a      	strb	r2, [r3, #0]
	ST_WORD(dir+DIR_FstClusLO, dclst);
 802007a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802007c:	f103 031a 	add.w	r3, r3, #26
 8020080:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8020082:	b2d2      	uxtb	r2, r2
 8020084:	701a      	strb	r2, [r3, #0]
 8020086:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020088:	f103 031b 	add.w	r3, r3, #27
 802008c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 802008e:	b292      	uxth	r2, r2
 8020090:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020094:	b292      	uxth	r2, r2
 8020096:	b2d2      	uxtb	r2, r2
 8020098:	701a      	strb	r2, [r3, #0]
	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 802009a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802009c:	f103 0314 	add.w	r3, r3, #20
 80200a0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80200a2:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80200a6:	b2d2      	uxtb	r2, r2
 80200a8:	701a      	strb	r2, [r3, #0]
 80200aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80200ac:	f103 0315 	add.w	r3, r3, #21
 80200b0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80200b2:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80200b6:	b292      	uxth	r2, r2
 80200b8:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80200bc:	b292      	uxth	r2, r2
 80200be:	b2d2      	uxtb	r2, r2
 80200c0:	701a      	strb	r2, [r3, #0]
	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
 80200c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80200c4:	f103 0320 	add.w	r3, r3, #32
 80200c8:	4618      	mov	r0, r3
 80200ca:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80200cc:	f04f 0220 	mov.w	r2, #32
 80200d0:	f7fc fe6a 	bl	801cda8 <mem_cpy>
	dir[33] = '.';
 80200d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80200d6:	f103 0321 	add.w	r3, r3, #33	; 0x21
 80200da:	f04f 022e 	mov.w	r2, #46	; 0x2e
 80200de:	701a      	strb	r2, [r3, #0]
	pclst = dj.sclust;
 80200e0:	69fb      	ldr	r3, [r7, #28]
 80200e2:	63fb      	str	r3, [r7, #60]	; 0x3c
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
 80200e4:	697b      	ldr	r3, [r7, #20]
 80200e6:	781b      	ldrb	r3, [r3, #0]
 80200e8:	2b03      	cmp	r3, #3
 80200ea:	d107      	bne.n	80200fc <f_mkdir+0x204>
 80200ec:	697b      	ldr	r3, [r7, #20]
 80200ee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80200f0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80200f2:	429a      	cmp	r2, r3
 80200f4:	d102      	bne.n	80200fc <f_mkdir+0x204>
		pclst = 0;
 80200f6:	f04f 0300 	mov.w	r3, #0
 80200fa:	63fb      	str	r3, [r7, #60]	; 0x3c
	ST_WORD(dir+32+DIR_FstClusLO, pclst);
 80200fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80200fe:	f103 033a 	add.w	r3, r3, #58	; 0x3a
 8020102:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020104:	b2d2      	uxtb	r2, r2
 8020106:	701a      	strb	r2, [r3, #0]
 8020108:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802010a:	f103 033b 	add.w	r3, r3, #59	; 0x3b
 802010e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020110:	b292      	uxth	r2, r2
 8020112:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020116:	b292      	uxth	r2, r2
 8020118:	b2d2      	uxtb	r2, r2
 802011a:	701a      	strb	r2, [r3, #0]
	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
 802011c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802011e:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8020122:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020124:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020128:	b2d2      	uxtb	r2, r2
 802012a:	701a      	strb	r2, [r3, #0]
 802012c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802012e:	f103 0335 	add.w	r3, r3, #53	; 0x35
 8020132:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020134:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020138:	b292      	uxth	r2, r2
 802013a:	ea4f 2212 	mov.w	r2, r2, lsr #8
 802013e:	b292      	uxth	r2, r2
 8020140:	b2d2      	uxtb	r2, r2
 8020142:	701a      	strb	r2, [r3, #0]
	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
 8020144:	f04f 0300 	mov.w	r3, #0
 8020148:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 802014c:	e027      	b.n	802019e <f_mkdir+0x2a6>
		dj.fs->winsect = dsect++;
 802014e:	697b      	ldr	r3, [r7, #20]
 8020150:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020152:	631a      	str	r2, [r3, #48]	; 0x30
 8020154:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8020156:	f103 0301 	add.w	r3, r3, #1
 802015a:	643b      	str	r3, [r7, #64]	; 0x40
		dj.fs->wflag = 1;
 802015c:	697b      	ldr	r3, [r7, #20]
 802015e:	f04f 0201 	mov.w	r2, #1
 8020162:	711a      	strb	r2, [r3, #4]
		res = move_window(dj.fs, 0);
 8020164:	697b      	ldr	r3, [r7, #20]
 8020166:	4618      	mov	r0, r3
 8020168:	f04f 0100 	mov.w	r1, #0
 802016c:	f7fc feba 	bl	801cee4 <move_window>
 8020170:	4603      	mov	r3, r0
 8020172:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		if (res) LEAVE_FF(dj.fs, res);
 8020176:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802017a:	2b00      	cmp	r3, #0
 802017c:	d002      	beq.n	8020184 <f_mkdir+0x28c>
 802017e:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8020182:	e07d      	b.n	8020280 <f_mkdir+0x388>
		mem_set(dir, 0, SS(dj.fs));
 8020184:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8020186:	f04f 0100 	mov.w	r1, #0
 802018a:	f44f 7200 	mov.w	r2, #512	; 0x200
 802018e:	f7fc fe33 	bl	801cdf8 <mem_set>
	pclst = dj.sclust;
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
		pclst = 0;
	ST_WORD(dir+32+DIR_FstClusLO, pclst);
	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
 8020192:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 8020196:	f103 0301 	add.w	r3, r3, #1
 802019a:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 802019e:	697b      	ldr	r3, [r7, #20]
 80201a0:	789b      	ldrb	r3, [r3, #2]
 80201a2:	f897 2046 	ldrb.w	r2, [r7, #70]	; 0x46
 80201a6:	429a      	cmp	r2, r3
 80201a8:	d3d1      	bcc.n	802014e <f_mkdir+0x256>
		res = move_window(dj.fs, 0);
		if (res) LEAVE_FF(dj.fs, res);
		mem_set(dir, 0, SS(dj.fs));
	}

	res = dir_register(&dj);
 80201aa:	f107 0314 	add.w	r3, r7, #20
 80201ae:	4618      	mov	r0, r3
 80201b0:	f7fd fd1e 	bl	801dbf0 <dir_register>
 80201b4:	4603      	mov	r3, r0
 80201b6:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (res != FR_OK) {
 80201ba:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80201be:	2b00      	cmp	r3, #0
 80201c0:	d005      	beq.n	80201ce <f_mkdir+0x2d6>
		remove_chain(dj.fs, dclst);
 80201c2:	697b      	ldr	r3, [r7, #20]
 80201c4:	4618      	mov	r0, r3
 80201c6:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80201c8:	f7fd f9ea 	bl	801d5a0 <remove_chain>
 80201cc:	e056      	b.n	802027c <f_mkdir+0x384>
	} else {
		dir = dj.dir;
 80201ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80201d0:	637b      	str	r3, [r7, #52]	; 0x34
		dir[DIR_Attr] = AM_DIR;					/* Attribute */
 80201d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80201d4:	f103 030b 	add.w	r3, r3, #11
 80201d8:	f04f 0210 	mov.w	r2, #16
 80201dc:	701a      	strb	r2, [r3, #0]
		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
 80201de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80201e0:	f103 0316 	add.w	r3, r3, #22
 80201e4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80201e6:	b2d2      	uxtb	r2, r2
 80201e8:	701a      	strb	r2, [r3, #0]
 80201ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80201ec:	f103 0317 	add.w	r3, r3, #23
 80201f0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80201f2:	b292      	uxth	r2, r2
 80201f4:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80201f8:	b292      	uxth	r2, r2
 80201fa:	b2d2      	uxtb	r2, r2
 80201fc:	701a      	strb	r2, [r3, #0]
 80201fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020200:	f103 0318 	add.w	r3, r3, #24
 8020204:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8020206:	ea4f 4212 	mov.w	r2, r2, lsr #16
 802020a:	b2d2      	uxtb	r2, r2
 802020c:	701a      	strb	r2, [r3, #0]
 802020e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020210:	f103 0319 	add.w	r3, r3, #25
 8020214:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8020216:	ea4f 6212 	mov.w	r2, r2, lsr #24
 802021a:	b2d2      	uxtb	r2, r2
 802021c:	701a      	strb	r2, [r3, #0]
		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 802021e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020220:	f103 031a 	add.w	r3, r3, #26
 8020224:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8020226:	b2d2      	uxtb	r2, r2
 8020228:	701a      	strb	r2, [r3, #0]
 802022a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802022c:	f103 031b 	add.w	r3, r3, #27
 8020230:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8020232:	b292      	uxth	r2, r2
 8020234:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020238:	b292      	uxth	r2, r2
 802023a:	b2d2      	uxtb	r2, r2
 802023c:	701a      	strb	r2, [r3, #0]
		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 802023e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020240:	f103 0314 	add.w	r3, r3, #20
 8020244:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8020246:	ea4f 4212 	mov.w	r2, r2, lsr #16
 802024a:	b2d2      	uxtb	r2, r2
 802024c:	701a      	strb	r2, [r3, #0]
 802024e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020250:	f103 0315 	add.w	r3, r3, #21
 8020254:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8020256:	ea4f 4212 	mov.w	r2, r2, lsr #16
 802025a:	b292      	uxth	r2, r2
 802025c:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020260:	b292      	uxth	r2, r2
 8020262:	b2d2      	uxtb	r2, r2
 8020264:	701a      	strb	r2, [r3, #0]
		dj.fs->wflag = 1;
 8020266:	697b      	ldr	r3, [r7, #20]
 8020268:	f04f 0201 	mov.w	r2, #1
 802026c:	711a      	strb	r2, [r3, #4]
		res = sync(dj.fs);
 802026e:	697b      	ldr	r3, [r7, #20]
 8020270:	4618      	mov	r0, r3
 8020272:	f7fc fea1 	bl	801cfb8 <sync>
 8020276:	4603      	mov	r3, r0
 8020278:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	}

	LEAVE_FF(dj.fs, res);
 802027c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
}
 8020280:	4618      	mov	r0, r3
 8020282:	f107 0748 	add.w	r7, r7, #72	; 0x48
 8020286:	46bd      	mov	sp, r7
 8020288:	bd80      	pop	{r7, pc}
 802028a:	bf00      	nop

0802028c <f_chmod>:
FRESULT f_chmod (
	const XCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
 802028c:	b580      	push	{r7, lr}
 802028e:	b08e      	sub	sp, #56	; 0x38
 8020290:	af00      	add	r7, sp, #0
 8020292:	6078      	str	r0, [r7, #4]
 8020294:	4613      	mov	r3, r2
 8020296:	460a      	mov	r2, r1
 8020298:	70fa      	strb	r2, [r7, #3]
 802029a:	70bb      	strb	r3, [r7, #2]
	DIR dj;
	NAMEBUF(sfn, lfn);
	BYTE *dir;


	res = auto_mount(&path, &dj.fs, 1);
 802029c:	f107 0204 	add.w	r2, r7, #4
 80202a0:	f107 0314 	add.w	r3, r7, #20
 80202a4:	4610      	mov	r0, r2
 80202a6:	4619      	mov	r1, r3
 80202a8:	f04f 0201 	mov.w	r2, #1
 80202ac:	f7fd fff0 	bl	801e290 <auto_mount>
 80202b0:	4603      	mov	r3, r0
 80202b2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res == FR_OK) {
 80202b6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80202ba:	2b00      	cmp	r3, #0
 80202bc:	d14d      	bne.n	802035a <f_chmod+0xce>
		INITBUF(dj, sfn, lfn);
 80202be:	f107 0308 	add.w	r3, r7, #8
 80202c2:	62fb      	str	r3, [r7, #44]	; 0x2c
		res = follow_path(&dj, path);		/* Follow the file path */
 80202c4:	687b      	ldr	r3, [r7, #4]
 80202c6:	f107 0214 	add.w	r2, r7, #20
 80202ca:	4610      	mov	r0, r2
 80202cc:	4619      	mov	r1, r3
 80202ce:	f7fd fef3 	bl	801e0b8 <follow_path>
 80202d2:	4603      	mov	r3, r0
 80202d4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (_FS_RPATH && res == FR_OK && (dj.fn[11] & NS_DOT))
 80202d8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80202dc:	2b00      	cmp	r3, #0
 80202de:	d10b      	bne.n	80202f8 <f_chmod+0x6c>
 80202e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80202e2:	f103 030b 	add.w	r3, r3, #11
 80202e6:	781b      	ldrb	r3, [r3, #0]
 80202e8:	f003 0320 	and.w	r3, r3, #32
 80202ec:	2b00      	cmp	r3, #0
 80202ee:	d003      	beq.n	80202f8 <f_chmod+0x6c>
			res = FR_INVALID_NAME;
 80202f0:	f04f 0306 	mov.w	r3, #6
 80202f4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (res == FR_OK) {
 80202f8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80202fc:	2b00      	cmp	r3, #0
 80202fe:	d12c      	bne.n	802035a <f_chmod+0xce>
			dir = dj.dir;
 8020300:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020302:	633b      	str	r3, [r7, #48]	; 0x30
			if (!dir) {						/* Is it a root directory? */
 8020304:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020306:	2b00      	cmp	r3, #0
 8020308:	d104      	bne.n	8020314 <f_chmod+0x88>
				res = FR_INVALID_NAME;
 802030a:	f04f 0306 	mov.w	r3, #6
 802030e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8020312:	e022      	b.n	802035a <f_chmod+0xce>
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
 8020314:	78bb      	ldrb	r3, [r7, #2]
 8020316:	f003 0327 	and.w	r3, r3, #39	; 0x27
 802031a:	70bb      	strb	r3, [r7, #2]
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 802031c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802031e:	f103 030b 	add.w	r3, r3, #11
 8020322:	78f9      	ldrb	r1, [r7, #3]
 8020324:	78ba      	ldrb	r2, [r7, #2]
 8020326:	400a      	ands	r2, r1
 8020328:	b2d1      	uxtb	r1, r2
 802032a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802032c:	f102 020b 	add.w	r2, r2, #11
 8020330:	7810      	ldrb	r0, [r2, #0]
 8020332:	78ba      	ldrb	r2, [r7, #2]
 8020334:	ea6f 0202 	mvn.w	r2, r2
 8020338:	b2d2      	uxtb	r2, r2
 802033a:	4002      	ands	r2, r0
 802033c:	b2d2      	uxtb	r2, r2
 802033e:	430a      	orrs	r2, r1
 8020340:	b2d2      	uxtb	r2, r2
 8020342:	701a      	strb	r2, [r3, #0]
				dj.fs->wflag = 1;
 8020344:	697b      	ldr	r3, [r7, #20]
 8020346:	f04f 0201 	mov.w	r2, #1
 802034a:	711a      	strb	r2, [r3, #4]
				res = sync(dj.fs);
 802034c:	697b      	ldr	r3, [r7, #20]
 802034e:	4618      	mov	r0, r3
 8020350:	f7fc fe32 	bl	801cfb8 <sync>
 8020354:	4603      	mov	r3, r0
 8020356:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
			}
		}
	}

	LEAVE_FF(dj.fs, res);
 802035a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 802035e:	4618      	mov	r0, r3
 8020360:	f107 0738 	add.w	r7, r7, #56	; 0x38
 8020364:	46bd      	mov	sp, r7
 8020366:	bd80      	pop	{r7, pc}

08020368 <f_utime>:

FRESULT f_utime (
	const XCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the timestamp to be set */
)
{
 8020368:	b580      	push	{r7, lr}
 802036a:	b08e      	sub	sp, #56	; 0x38
 802036c:	af00      	add	r7, sp, #0
 802036e:	6078      	str	r0, [r7, #4]
 8020370:	6039      	str	r1, [r7, #0]
	DIR dj;
	NAMEBUF(sfn, lfn);
	BYTE *dir;


	res = auto_mount(&path, &dj.fs, 1);
 8020372:	f107 0204 	add.w	r2, r7, #4
 8020376:	f107 0314 	add.w	r3, r7, #20
 802037a:	4610      	mov	r0, r2
 802037c:	4619      	mov	r1, r3
 802037e:	f04f 0201 	mov.w	r2, #1
 8020382:	f7fd ff85 	bl	801e290 <auto_mount>
 8020386:	4603      	mov	r3, r0
 8020388:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res == FR_OK) {
 802038c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8020390:	2b00      	cmp	r3, #0
 8020392:	d157      	bne.n	8020444 <f_utime+0xdc>
		INITBUF(dj, sfn, lfn);
 8020394:	f107 0308 	add.w	r3, r7, #8
 8020398:	62fb      	str	r3, [r7, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
 802039a:	687b      	ldr	r3, [r7, #4]
 802039c:	f107 0214 	add.w	r2, r7, #20
 80203a0:	4610      	mov	r0, r2
 80203a2:	4619      	mov	r1, r3
 80203a4:	f7fd fe88 	bl	801e0b8 <follow_path>
 80203a8:	4603      	mov	r3, r0
 80203aa:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (_FS_RPATH && res == FR_OK && (dj.fn[11] & NS_DOT))
 80203ae:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80203b2:	2b00      	cmp	r3, #0
 80203b4:	d10b      	bne.n	80203ce <f_utime+0x66>
 80203b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80203b8:	f103 030b 	add.w	r3, r3, #11
 80203bc:	781b      	ldrb	r3, [r3, #0]
 80203be:	f003 0320 	and.w	r3, r3, #32
 80203c2:	2b00      	cmp	r3, #0
 80203c4:	d003      	beq.n	80203ce <f_utime+0x66>
			res = FR_INVALID_NAME;
 80203c6:	f04f 0306 	mov.w	r3, #6
 80203ca:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (res == FR_OK) {
 80203ce:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80203d2:	2b00      	cmp	r3, #0
 80203d4:	d136      	bne.n	8020444 <f_utime+0xdc>
			dir = dj.dir;
 80203d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80203d8:	633b      	str	r3, [r7, #48]	; 0x30
			if (!dir) {				/* Root directory */
 80203da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80203dc:	2b00      	cmp	r3, #0
 80203de:	d104      	bne.n	80203ea <f_utime+0x82>
				res = FR_INVALID_NAME;
 80203e0:	f04f 0306 	mov.w	r3, #6
 80203e4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 80203e8:	e02c      	b.n	8020444 <f_utime+0xdc>
			} else {				/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
 80203ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80203ec:	f103 0316 	add.w	r3, r3, #22
 80203f0:	683a      	ldr	r2, [r7, #0]
 80203f2:	88d2      	ldrh	r2, [r2, #6]
 80203f4:	b2d2      	uxtb	r2, r2
 80203f6:	701a      	strb	r2, [r3, #0]
 80203f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80203fa:	f103 0317 	add.w	r3, r3, #23
 80203fe:	683a      	ldr	r2, [r7, #0]
 8020400:	88d2      	ldrh	r2, [r2, #6]
 8020402:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020406:	b292      	uxth	r2, r2
 8020408:	b2d2      	uxtb	r2, r2
 802040a:	701a      	strb	r2, [r3, #0]
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 802040c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802040e:	f103 0318 	add.w	r3, r3, #24
 8020412:	683a      	ldr	r2, [r7, #0]
 8020414:	8892      	ldrh	r2, [r2, #4]
 8020416:	b2d2      	uxtb	r2, r2
 8020418:	701a      	strb	r2, [r3, #0]
 802041a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802041c:	f103 0319 	add.w	r3, r3, #25
 8020420:	683a      	ldr	r2, [r7, #0]
 8020422:	8892      	ldrh	r2, [r2, #4]
 8020424:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020428:	b292      	uxth	r2, r2
 802042a:	b2d2      	uxtb	r2, r2
 802042c:	701a      	strb	r2, [r3, #0]
				dj.fs->wflag = 1;
 802042e:	697b      	ldr	r3, [r7, #20]
 8020430:	f04f 0201 	mov.w	r2, #1
 8020434:	711a      	strb	r2, [r3, #4]
				res = sync(dj.fs);
 8020436:	697b      	ldr	r3, [r7, #20]
 8020438:	4618      	mov	r0, r3
 802043a:	f7fc fdbd 	bl	801cfb8 <sync>
 802043e:	4603      	mov	r3, r0
 8020440:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
			}
		}
	}

	LEAVE_FF(dj.fs, res);
 8020444:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 8020448:	4618      	mov	r0, r3
 802044a:	f107 0738 	add.w	r7, r7, #56	; 0x38
 802044e:	46bd      	mov	sp, r7
 8020450:	bd80      	pop	{r7, pc}
 8020452:	bf00      	nop

08020454 <f_rename>:

FRESULT f_rename (
	const XCHAR *path_old,	/* Pointer to the old name */
	const XCHAR *path_new	/* Pointer to the new name */
)
{
 8020454:	b580      	push	{r7, lr}
 8020456:	b09c      	sub	sp, #112	; 0x70
 8020458:	af00      	add	r7, sp, #0
 802045a:	6078      	str	r0, [r7, #4]
 802045c:	6039      	str	r1, [r7, #0]
	NAMEBUF(sfn, lfn);
	BYTE buf[21], *dir;
	DWORD dw;


	INITBUF(dj_old, sfn, lfn);
 802045e:	f107 0320 	add.w	r3, r7, #32
 8020462:	663b      	str	r3, [r7, #96]	; 0x60
	res = auto_mount(&path_old, &dj_old.fs, 1);
 8020464:	f107 0204 	add.w	r2, r7, #4
 8020468:	f107 0348 	add.w	r3, r7, #72	; 0x48
 802046c:	4610      	mov	r0, r2
 802046e:	4619      	mov	r1, r3
 8020470:	f04f 0201 	mov.w	r2, #1
 8020474:	f7fd ff0c 	bl	801e290 <auto_mount>
 8020478:	4603      	mov	r3, r0
 802047a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
	if (res == FR_OK) {
 802047e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8020482:	2b00      	cmp	r3, #0
 8020484:	d11b      	bne.n	80204be <f_rename+0x6a>
		dj_new.fs = dj_old.fs;
 8020486:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020488:	62fb      	str	r3, [r7, #44]	; 0x2c
		res = follow_path(&dj_old, path_old);	/* Check old object */
 802048a:	687b      	ldr	r3, [r7, #4]
 802048c:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8020490:	4610      	mov	r0, r2
 8020492:	4619      	mov	r1, r3
 8020494:	f7fd fe10 	bl	801e0b8 <follow_path>
 8020498:	4603      	mov	r3, r0
 802049a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
		if (_FS_RPATH && res == FR_OK && (dj_old.fn[11] & NS_DOT))
 802049e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80204a2:	2b00      	cmp	r3, #0
 80204a4:	d10b      	bne.n	80204be <f_rename+0x6a>
 80204a6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80204a8:	f103 030b 	add.w	r3, r3, #11
 80204ac:	781b      	ldrb	r3, [r3, #0]
 80204ae:	f003 0320 	and.w	r3, r3, #32
 80204b2:	2b00      	cmp	r3, #0
 80204b4:	d003      	beq.n	80204be <f_rename+0x6a>
			res = FR_INVALID_NAME;
 80204b6:	f04f 0306 	mov.w	r3, #6
 80204ba:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
	}
	if (res != FR_OK) LEAVE_FF(dj_old.fs, res);	/* The old object is not found */
 80204be:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80204c2:	2b00      	cmp	r3, #0
 80204c4:	d002      	beq.n	80204cc <f_rename+0x78>
 80204c6:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80204ca:	e0f2      	b.n	80206b2 <f_rename+0x25e>

	if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);	/* Is root dir? */
 80204cc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80204ce:	2b00      	cmp	r3, #0
 80204d0:	d102      	bne.n	80204d8 <f_rename+0x84>
 80204d2:	f04f 0304 	mov.w	r3, #4
 80204d6:	e0ec      	b.n	80206b2 <f_rename+0x25e>
	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */
 80204d8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80204da:	f103 030b 	add.w	r3, r3, #11
 80204de:	f107 0208 	add.w	r2, r7, #8
 80204e2:	4610      	mov	r0, r2
 80204e4:	4619      	mov	r1, r3
 80204e6:	f04f 0215 	mov.w	r2, #21
 80204ea:	f7fc fc5d 	bl	801cda8 <mem_cpy>

	mem_cpy(&dj_new, &dj_old, sizeof(DIR));
 80204ee:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 80204f2:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80204f6:	4610      	mov	r0, r2
 80204f8:	4619      	mov	r1, r3
 80204fa:	f04f 021c 	mov.w	r2, #28
 80204fe:	f7fc fc53 	bl	801cda8 <mem_cpy>
	res = follow_path(&dj_new, path_new);		/* Check new object */
 8020502:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8020506:	4618      	mov	r0, r3
 8020508:	6839      	ldr	r1, [r7, #0]
 802050a:	f7fd fdd5 	bl	801e0b8 <follow_path>
 802050e:	4603      	mov	r3, r0
 8020510:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
	if (res == FR_OK) res = FR_EXIST;			/* The new object name is already existing */
 8020514:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8020518:	2b00      	cmp	r3, #0
 802051a:	d103      	bne.n	8020524 <f_rename+0xd0>
 802051c:	f04f 0308 	mov.w	r3, #8
 8020520:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
 8020524:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8020528:	2b04      	cmp	r3, #4
 802052a:	f040 80c0 	bne.w	80206ae <f_rename+0x25a>
		res = dir_register(&dj_new);			/* Register the new object */
 802052e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8020532:	4618      	mov	r0, r3
 8020534:	f7fd fb5c 	bl	801dbf0 <dir_register>
 8020538:	4603      	mov	r3, r0
 802053a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
		if (res == FR_OK) {
 802053e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8020542:	2b00      	cmp	r3, #0
 8020544:	f040 80b3 	bne.w	80206ae <f_rename+0x25a>
			dir = dj_new.dir;					/* Copy object information into new entry */
 8020548:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802054a:	66bb      	str	r3, [r7, #104]	; 0x68
			mem_cpy(dir+13, buf+2, 19);
 802054c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 802054e:	f103 020d 	add.w	r2, r3, #13
 8020552:	f107 0308 	add.w	r3, r7, #8
 8020556:	f103 0302 	add.w	r3, r3, #2
 802055a:	4610      	mov	r0, r2
 802055c:	4619      	mov	r1, r3
 802055e:	f04f 0213 	mov.w	r2, #19
 8020562:	f7fc fc21 	bl	801cda8 <mem_cpy>
			dir[DIR_Attr] = buf[0] | AM_ARC;
 8020566:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8020568:	f103 030b 	add.w	r3, r3, #11
 802056c:	7a3a      	ldrb	r2, [r7, #8]
 802056e:	f042 0220 	orr.w	r2, r2, #32
 8020572:	b2d2      	uxtb	r2, r2
 8020574:	701a      	strb	r2, [r3, #0]
			dj_old.fs->wflag = 1;
 8020576:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020578:	f04f 0201 	mov.w	r2, #1
 802057c:	711a      	strb	r2, [r3, #4]
			if (dir[DIR_Attr] & AM_DIR) {		/* Update .. entry in the directory if needed */
 802057e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8020580:	f103 030b 	add.w	r3, r3, #11
 8020584:	781b      	ldrb	r3, [r3, #0]
 8020586:	f003 0310 	and.w	r3, r3, #16
 802058a:	2b00      	cmp	r3, #0
 802058c:	d078      	beq.n	8020680 <f_rename+0x22c>
				dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
 802058e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8020590:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8020592:	f103 0315 	add.w	r3, r3, #21
 8020596:	781b      	ldrb	r3, [r3, #0]
 8020598:	ea4f 2303 	mov.w	r3, r3, lsl #8
 802059c:	b299      	uxth	r1, r3
 802059e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80205a0:	f103 0314 	add.w	r3, r3, #20
 80205a4:	781b      	ldrb	r3, [r3, #0]
 80205a6:	430b      	orrs	r3, r1
 80205a8:	b29b      	uxth	r3, r3
 80205aa:	b299      	uxth	r1, r3
 80205ac:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80205ae:	f103 031b 	add.w	r3, r3, #27
 80205b2:	781b      	ldrb	r3, [r3, #0]
 80205b4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80205b8:	b298      	uxth	r0, r3
 80205ba:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80205bc:	f103 031a 	add.w	r3, r3, #26
 80205c0:	781b      	ldrb	r3, [r3, #0]
 80205c2:	4303      	orrs	r3, r0
 80205c4:	b29b      	uxth	r3, r3
 80205c6:	b29b      	uxth	r3, r3
 80205c8:	430b      	orrs	r3, r1
 80205ca:	b29b      	uxth	r3, r3
 80205cc:	4610      	mov	r0, r2
 80205ce:	4619      	mov	r1, r3
 80205d0:	f7fd f8ce 	bl	801d770 <clust2sect>
 80205d4:	4603      	mov	r3, r0
 80205d6:	667b      	str	r3, [r7, #100]	; 0x64
				if (!dw) {
 80205d8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80205da:	2b00      	cmp	r3, #0
 80205dc:	d104      	bne.n	80205e8 <f_rename+0x194>
					res = FR_INT_ERR;
 80205de:	f04f 0302 	mov.w	r3, #2
 80205e2:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
 80205e6:	e04b      	b.n	8020680 <f_rename+0x22c>
				} else {
					res = move_window(dj_new.fs, dw);
 80205e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80205ea:	4618      	mov	r0, r3
 80205ec:	6e79      	ldr	r1, [r7, #100]	; 0x64
 80205ee:	f7fc fc79 	bl	801cee4 <move_window>
 80205f2:	4603      	mov	r3, r0
 80205f4:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
					dir = dj_new.fs->win+32;
 80205f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80205fa:	f103 0354 	add.w	r3, r3, #84	; 0x54
 80205fe:	66bb      	str	r3, [r7, #104]	; 0x68
					if (res == FR_OK && dir[1] == '.') {
 8020600:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8020604:	2b00      	cmp	r3, #0
 8020606:	d13b      	bne.n	8020680 <f_rename+0x22c>
 8020608:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 802060a:	f103 0301 	add.w	r3, r3, #1
 802060e:	781b      	ldrb	r3, [r3, #0]
 8020610:	2b2e      	cmp	r3, #46	; 0x2e
 8020612:	d135      	bne.n	8020680 <f_rename+0x22c>
						dw = (dj_new.fs->fs_type == FS_FAT32 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.sclust;
 8020614:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020616:	781b      	ldrb	r3, [r3, #0]
 8020618:	2b03      	cmp	r3, #3
 802061a:	d104      	bne.n	8020626 <f_rename+0x1d2>
 802061c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 802061e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020620:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8020622:	429a      	cmp	r2, r3
 8020624:	d001      	beq.n	802062a <f_rename+0x1d6>
 8020626:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8020628:	e001      	b.n	802062e <f_rename+0x1da>
 802062a:	f04f 0300 	mov.w	r3, #0
 802062e:	667b      	str	r3, [r7, #100]	; 0x64
						ST_WORD(dir+DIR_FstClusLO, dw);
 8020630:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8020632:	f103 031a 	add.w	r3, r3, #26
 8020636:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8020638:	b2d2      	uxtb	r2, r2
 802063a:	701a      	strb	r2, [r3, #0]
 802063c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 802063e:	f103 031b 	add.w	r3, r3, #27
 8020642:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8020644:	b292      	uxth	r2, r2
 8020646:	ea4f 2212 	mov.w	r2, r2, lsr #8
 802064a:	b292      	uxth	r2, r2
 802064c:	b2d2      	uxtb	r2, r2
 802064e:	701a      	strb	r2, [r3, #0]
						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
 8020650:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8020652:	f103 0314 	add.w	r3, r3, #20
 8020656:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8020658:	ea4f 4212 	mov.w	r2, r2, lsr #16
 802065c:	b2d2      	uxtb	r2, r2
 802065e:	701a      	strb	r2, [r3, #0]
 8020660:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8020662:	f103 0315 	add.w	r3, r3, #21
 8020666:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8020668:	ea4f 4212 	mov.w	r2, r2, lsr #16
 802066c:	b292      	uxth	r2, r2
 802066e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020672:	b292      	uxth	r2, r2
 8020674:	b2d2      	uxtb	r2, r2
 8020676:	701a      	strb	r2, [r3, #0]
						dj_new.fs->wflag = 1;
 8020678:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802067a:	f04f 0201 	mov.w	r2, #1
 802067e:	711a      	strb	r2, [r3, #4]
					}
				}
			}
			if (res == FR_OK) {
 8020680:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8020684:	2b00      	cmp	r3, #0
 8020686:	d112      	bne.n	80206ae <f_rename+0x25a>
				res = dir_remove(&dj_old);			/* Remove old entry */
 8020688:	f107 0348 	add.w	r3, r7, #72	; 0x48
 802068c:	4618      	mov	r0, r3
 802068e:	f7fd fb19 	bl	801dcc4 <dir_remove>
 8020692:	4603      	mov	r3, r0
 8020694:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
				if (res == FR_OK)
 8020698:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 802069c:	2b00      	cmp	r3, #0
 802069e:	d106      	bne.n	80206ae <f_rename+0x25a>
					res = sync(dj_old.fs);
 80206a0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80206a2:	4618      	mov	r0, r3
 80206a4:	f7fc fc88 	bl	801cfb8 <sync>
 80206a8:	4603      	mov	r3, r0
 80206aa:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
			}
		}
	}

	LEAVE_FF(dj_old.fs, res);
 80206ae:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
}
 80206b2:	4618      	mov	r0, r3
 80206b4:	f107 0770 	add.w	r7, r7, #112	; 0x70
 80206b8:	46bd      	mov	sp, r7
 80206ba:	bd80      	pop	{r7, pc}

080206bc <f_mkfs>:
FRESULT f_mkfs (
	BYTE drv,			/* Logical drive number */
	BYTE partition,		/* Partitioning rule 0:FDISK, 1:SFD */
	WORD allocsize		/* Allocation unit size [bytes] */
)
{
 80206bc:	b580      	push	{r7, lr}
 80206be:	b094      	sub	sp, #80	; 0x50
 80206c0:	af00      	add	r7, sp, #0
 80206c2:	4613      	mov	r3, r2
 80206c4:	4602      	mov	r2, r0
 80206c6:	71fa      	strb	r2, [r7, #7]
 80206c8:	460a      	mov	r2, r1
 80206ca:	71ba      	strb	r2, [r7, #6]
 80206cc:	80bb      	strh	r3, [r7, #4]
	FATFS *fs;
	DSTATUS stat;


	/* Check validity of the parameters */
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
 80206ce:	79fb      	ldrb	r3, [r7, #7]
 80206d0:	2b00      	cmp	r3, #0
 80206d2:	d003      	beq.n	80206dc <f_mkfs+0x20>
 80206d4:	f04f 030b 	mov.w	r3, #11
 80206d8:	f000 bdb1 	b.w	802123e <f_mkfs+0xb82>
	if (partition >= 2) return FR_MKFS_ABORTED;
 80206dc:	79bb      	ldrb	r3, [r7, #6]
 80206de:	2b01      	cmp	r3, #1
 80206e0:	d903      	bls.n	80206ea <f_mkfs+0x2e>
 80206e2:	f04f 030e 	mov.w	r3, #14
 80206e6:	f000 bdaa 	b.w	802123e <f_mkfs+0xb82>

	/* Check mounted drive and clear work area */
	fs = FatFs[drv];
 80206ea:	79fa      	ldrb	r2, [r7, #7]
 80206ec:	f241 03e8 	movw	r3, #4328	; 0x10e8
 80206f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80206f4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80206f8:	633b      	str	r3, [r7, #48]	; 0x30
	if (!fs) return FR_NOT_ENABLED;
 80206fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80206fc:	2b00      	cmp	r3, #0
 80206fe:	d103      	bne.n	8020708 <f_mkfs+0x4c>
 8020700:	f04f 030c 	mov.w	r3, #12
 8020704:	f000 bd9b 	b.w	802123e <f_mkfs+0xb82>
	fs->fs_type = 0;
 8020708:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802070a:	f04f 0200 	mov.w	r2, #0
 802070e:	701a      	strb	r2, [r3, #0]
	drv = LD2PD(drv);

	/* Get disk statics */
	stat = disk_initialize(drv);
 8020710:	79fb      	ldrb	r3, [r7, #7]
 8020712:	4618      	mov	r0, r3
 8020714:	f7e4 fe58 	bl	80053c8 <disk_initialize>
 8020718:	4603      	mov	r3, r0
 802071a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if (stat & STA_NOINIT) return FR_NOT_READY;
 802071e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8020722:	f003 0301 	and.w	r3, r3, #1
 8020726:	b2db      	uxtb	r3, r3
 8020728:	2b00      	cmp	r3, #0
 802072a:	d003      	beq.n	8020734 <f_mkfs+0x78>
 802072c:	f04f 0303 	mov.w	r3, #3
 8020730:	f000 bd85 	b.w	802123e <f_mkfs+0xb82>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 8020734:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8020738:	f003 0304 	and.w	r3, r3, #4
 802073c:	2b00      	cmp	r3, #0
 802073e:	d003      	beq.n	8020748 <f_mkfs+0x8c>
 8020740:	f04f 030a 	mov.w	r3, #10
 8020744:	f000 bd7b 	b.w	802123e <f_mkfs+0xb82>
#if _MAX_SS != 512						/* Get disk sector size */
	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) > _MAX_SS)
		return FR_MKFS_ABORTED;
#endif
	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
 8020748:	79fa      	ldrb	r2, [r7, #7]
 802074a:	f107 0310 	add.w	r3, r7, #16
 802074e:	4610      	mov	r0, r2
 8020750:	f04f 0101 	mov.w	r1, #1
 8020754:	461a      	mov	r2, r3
 8020756:	f7e4 ff41 	bl	80055dc <disk_ioctl>
 802075a:	4603      	mov	r3, r0
 802075c:	2b00      	cmp	r3, #0
 802075e:	d104      	bne.n	802076a <f_mkfs+0xae>
 8020760:	693a      	ldr	r2, [r7, #16]
 8020762:	f240 73cf 	movw	r3, #1999	; 0x7cf
 8020766:	429a      	cmp	r2, r3
 8020768:	d803      	bhi.n	8020772 <f_mkfs+0xb6>
		return FR_MKFS_ABORTED;
 802076a:	f04f 030e 	mov.w	r3, #14
 802076e:	f000 bd66 	b.w	802123e <f_mkfs+0xb82>
	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
 8020772:	693b      	ldr	r3, [r7, #16]
 8020774:	f1b3 6ffa 	cmp.w	r3, #131072000	; 0x7d00000
 8020778:	d902      	bls.n	8020780 <f_mkfs+0xc4>
 802077a:	f04f 63fa 	mov.w	r3, #131072000	; 0x7d00000
 802077e:	613b      	str	r3, [r7, #16]
	b_part = (!partition) ? 63 : 0;		/* Boot sector */
 8020780:	79bb      	ldrb	r3, [r7, #6]
 8020782:	2b00      	cmp	r3, #0
 8020784:	d102      	bne.n	802078c <f_mkfs+0xd0>
 8020786:	f04f 033f 	mov.w	r3, #63	; 0x3f
 802078a:	e001      	b.n	8020790 <f_mkfs+0xd4>
 802078c:	f04f 0300 	mov.w	r3, #0
 8020790:	62bb      	str	r3, [r7, #40]	; 0x28
	n_part -= b_part;
 8020792:	693a      	ldr	r2, [r7, #16]
 8020794:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020796:	1ad3      	subs	r3, r2, r3
 8020798:	613b      	str	r3, [r7, #16]
	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit size */
 802079a:	f44f 7300 	mov.w	r3, #512	; 0x200
 802079e:	63bb      	str	r3, [r7, #56]	; 0x38
 80207a0:	e003      	b.n	80207aa <f_mkfs+0xee>
 80207a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80207a4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80207a8:	63bb      	str	r3, [r7, #56]	; 0x38
 80207aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80207ac:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80207b0:	d803      	bhi.n	80207ba <f_mkfs+0xfe>
 80207b2:	88ba      	ldrh	r2, [r7, #4]
 80207b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80207b6:	429a      	cmp	r2, r3
 80207b8:	d1f3      	bne.n	80207a2 <f_mkfs+0xe6>
	if (d != allocsize) allocsize = 0;
 80207ba:	88ba      	ldrh	r2, [r7, #4]
 80207bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80207be:	429a      	cmp	r2, r3
 80207c0:	d002      	beq.n	80207c8 <f_mkfs+0x10c>
 80207c2:	f04f 0300 	mov.w	r3, #0
 80207c6:	80bb      	strh	r3, [r7, #4]
	if (!allocsize) {					/* Auto selection of cluster size */
 80207c8:	88bb      	ldrh	r3, [r7, #4]
 80207ca:	2b00      	cmp	r3, #0
 80207cc:	d12b      	bne.n	8020826 <f_mkfs+0x16a>
		d = n_part;
 80207ce:	693b      	ldr	r3, [r7, #16]
 80207d0:	63bb      	str	r3, [r7, #56]	; 0x38
		for (as = SS(fs); as > 512U; as >>= 1) d >>= 1;
 80207d2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80207d6:	86fb      	strh	r3, [r7, #54]	; 0x36
 80207d8:	e007      	b.n	80207ea <f_mkfs+0x12e>
 80207da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80207dc:	ea4f 0353 	mov.w	r3, r3, lsr #1
 80207e0:	63bb      	str	r3, [r7, #56]	; 0x38
 80207e2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80207e4:	ea4f 0353 	mov.w	r3, r3, lsr #1
 80207e8:	86fb      	strh	r3, [r7, #54]	; 0x36
 80207ea:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80207ec:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80207f0:	d8f3      	bhi.n	80207da <f_mkfs+0x11e>
		for (n = 0; d < sstbl[n]; n++) ;
 80207f2:	f04f 0300 	mov.w	r3, #0
 80207f6:	60fb      	str	r3, [r7, #12]
 80207f8:	e003      	b.n	8020802 <f_mkfs+0x146>
 80207fa:	68fb      	ldr	r3, [r7, #12]
 80207fc:	f103 0301 	add.w	r3, r3, #1
 8020800:	60fb      	str	r3, [r7, #12]
 8020802:	68fa      	ldr	r2, [r7, #12]
 8020804:	f642 3350 	movw	r3, #11088	; 0x2b50
 8020808:	f6c0 0303 	movt	r3, #2051	; 0x803
 802080c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8020810:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020812:	429a      	cmp	r2, r3
 8020814:	d8f1      	bhi.n	80207fa <f_mkfs+0x13e>
		allocsize = cstbl[n];
 8020816:	68fa      	ldr	r2, [r7, #12]
 8020818:	f642 337c 	movw	r3, #11132	; 0x2b7c
 802081c:	f6c0 0303 	movt	r3, #2051	; 0x803
 8020820:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8020824:	80bb      	strh	r3, [r7, #4]
	}
	if (allocsize < SS(fs)) allocsize = SS(fs); 
 8020826:	88ba      	ldrh	r2, [r7, #4]
 8020828:	f240 13ff 	movw	r3, #511	; 0x1ff
 802082c:	429a      	cmp	r2, r3
 802082e:	d802      	bhi.n	8020836 <f_mkfs+0x17a>
 8020830:	f44f 7300 	mov.w	r3, #512	; 0x200
 8020834:	80bb      	strh	r3, [r7, #4]
            
	allocsize /= SS(fs);		/* Number of sectors per cluster */
 8020836:	88bb      	ldrh	r3, [r7, #4]
 8020838:	ea4f 2353 	mov.w	r3, r3, lsr #9
 802083c:	80bb      	strh	r3, [r7, #4]

	/* Pre-compute number of clusters and FAT type */
	n_clst = n_part / allocsize;
 802083e:	693a      	ldr	r2, [r7, #16]
 8020840:	88bb      	ldrh	r3, [r7, #4]
 8020842:	fbb2 f3f3 	udiv	r3, r2, r3
 8020846:	627b      	str	r3, [r7, #36]	; 0x24
	fmt = FS_FAT12;
 8020848:	f04f 0301 	mov.w	r3, #1
 802084c:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
	if (n_clst >= 0xFF5) 
 8020850:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8020852:	f640 73f4 	movw	r3, #4084	; 0xff4
 8020856:	429a      	cmp	r2, r3
 8020858:	d903      	bls.n	8020862 <f_mkfs+0x1a6>
          fmt = FS_FAT16;
 802085a:	f04f 0302 	mov.w	r3, #2
 802085e:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
	if (n_clst >= 0xFFF5) 
 8020862:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8020864:	f64f 73f4 	movw	r3, #65524	; 0xfff4
 8020868:	429a      	cmp	r2, r3
 802086a:	d903      	bls.n	8020874 <f_mkfs+0x1b8>
          fmt = FS_FAT32;
 802086c:	f04f 0303 	mov.w	r3, #3
 8020870:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f

	/* Determine offset and size of FAT structure */
	switch (fmt) {
 8020874:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8020878:	2b01      	cmp	r3, #1
 802087a:	d002      	beq.n	8020882 <f_mkfs+0x1c6>
 802087c:	2b02      	cmp	r3, #2
 802087e:	d018      	beq.n	80208b2 <f_mkfs+0x1f6>
 8020880:	e029      	b.n	80208d6 <f_mkfs+0x21a>
	case FS_FAT12:
		n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
 8020882:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8020884:	4613      	mov	r3, r2
 8020886:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802088a:	189b      	adds	r3, r3, r2
 802088c:	f103 0301 	add.w	r3, r3, #1
 8020890:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8020894:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8020898:	f103 0302 	add.w	r3, r3, #2
 802089c:	ea4f 2353 	mov.w	r3, r3, lsr #9
 80208a0:	643b      	str	r3, [r7, #64]	; 0x40
		n_rsv = 1 + partition;
 80208a2:	79bb      	ldrb	r3, [r7, #6]
 80208a4:	f103 0301 	add.w	r3, r3, #1
 80208a8:	647b      	str	r3, [r7, #68]	; 0x44
		n_dir = N_ROOTDIR * 32 / SS(fs);
 80208aa:	f04f 0320 	mov.w	r3, #32
 80208ae:	63fb      	str	r3, [r7, #60]	; 0x3c
		break;
 80208b0:	e023      	b.n	80208fa <f_mkfs+0x23e>
	case FS_FAT16:
		n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
 80208b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80208b4:	f503 7381 	add.w	r3, r3, #258	; 0x102
 80208b8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80208bc:	f103 33ff 	add.w	r3, r3, #4294967295
 80208c0:	ea4f 2353 	mov.w	r3, r3, lsr #9
 80208c4:	643b      	str	r3, [r7, #64]	; 0x40
		n_rsv = 1 + partition;
 80208c6:	79bb      	ldrb	r3, [r7, #6]
 80208c8:	f103 0301 	add.w	r3, r3, #1
 80208cc:	647b      	str	r3, [r7, #68]	; 0x44
		n_dir = N_ROOTDIR * 32 / SS(fs);
 80208ce:	f04f 0320 	mov.w	r3, #32
 80208d2:	63fb      	str	r3, [r7, #60]	; 0x3c
		break;
 80208d4:	e011      	b.n	80208fa <f_mkfs+0x23e>
	default:
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
 80208d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80208d8:	f103 0382 	add.w	r3, r3, #130	; 0x82
 80208dc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80208e0:	f103 33ff 	add.w	r3, r3, #4294967295
 80208e4:	ea4f 2353 	mov.w	r3, r3, lsr #9
 80208e8:	643b      	str	r3, [r7, #64]	; 0x40
		n_rsv = 33 - partition;
 80208ea:	79bb      	ldrb	r3, [r7, #6]
 80208ec:	f1c3 0321 	rsb	r3, r3, #33	; 0x21
 80208f0:	647b      	str	r3, [r7, #68]	; 0x44
		n_dir = 0;
 80208f2:	f04f 0300 	mov.w	r3, #0
 80208f6:	63fb      	str	r3, [r7, #60]	; 0x3c
		break;
 80208f8:	bf00      	nop
	}
	b_fat = b_part + n_rsv;			/* FATs start sector */
 80208fa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80208fc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80208fe:	18d3      	adds	r3, r2, r3
 8020900:	64bb      	str	r3, [r7, #72]	; 0x48
	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
 8020902:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8020904:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8020906:	18d3      	adds	r3, r2, r3
 8020908:	623b      	str	r3, [r7, #32]
	b_data = b_dir + n_dir;			/* Data start sector */
 802090a:	6a3a      	ldr	r2, [r7, #32]
 802090c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802090e:	18d3      	adds	r3, r2, r3
 8020910:	61fb      	str	r3, [r7, #28]

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
 8020912:	79fa      	ldrb	r2, [r7, #7]
 8020914:	f107 030c 	add.w	r3, r7, #12
 8020918:	4610      	mov	r0, r2
 802091a:	f04f 0103 	mov.w	r1, #3
 802091e:	461a      	mov	r2, r3
 8020920:	f7e4 fe5c 	bl	80055dc <disk_ioctl>
 8020924:	4603      	mov	r3, r0
 8020926:	2b00      	cmp	r3, #0
 8020928:	d003      	beq.n	8020932 <f_mkfs+0x276>
 802092a:	f04f 030e 	mov.w	r3, #14
 802092e:	f000 bc86 	b.w	802123e <f_mkfs+0xb82>
	n = (b_data + n - 1) & ~(n - 1);
 8020932:	68fa      	ldr	r2, [r7, #12]
 8020934:	69fb      	ldr	r3, [r7, #28]
 8020936:	18d3      	adds	r3, r2, r3
 8020938:	f103 32ff 	add.w	r2, r3, #4294967295
 802093c:	68fb      	ldr	r3, [r7, #12]
 802093e:	f1c3 0300 	rsb	r3, r3, #0
 8020942:	4013      	ands	r3, r2
 8020944:	60fb      	str	r3, [r7, #12]
	n_fat += (n - b_data) / N_FATS;
 8020946:	68fa      	ldr	r2, [r7, #12]
 8020948:	69fb      	ldr	r3, [r7, #28]
 802094a:	1ad3      	subs	r3, r2, r3
 802094c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 802094e:	18d3      	adds	r3, r2, r3
 8020950:	643b      	str	r3, [r7, #64]	; 0x40
	/* b_dir and b_data are no longer used below */

	/* Determine number of cluster and final check of validity of the FAT type */
	n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
 8020952:	693a      	ldr	r2, [r7, #16]
 8020954:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8020956:	1ad2      	subs	r2, r2, r3
 8020958:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802095a:	1ad2      	subs	r2, r2, r3
 802095c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802095e:	1ad2      	subs	r2, r2, r3
 8020960:	88bb      	ldrh	r3, [r7, #4]
 8020962:	fbb2 f3f3 	udiv	r3, r2, r3
 8020966:	627b      	str	r3, [r7, #36]	; 0x24
	if (   (fmt == FS_FAT16 && n_clst < 0xFF5)
 8020968:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 802096c:	2b02      	cmp	r3, #2
 802096e:	d104      	bne.n	802097a <f_mkfs+0x2be>
 8020970:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8020972:	f640 73f4 	movw	r3, #4084	; 0xff4
 8020976:	429a      	cmp	r2, r3
 8020978:	d908      	bls.n	802098c <f_mkfs+0x2d0>
		|| (fmt == FS_FAT32 && n_clst < 0xFFF5))
 802097a:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 802097e:	2b03      	cmp	r3, #3
 8020980:	d108      	bne.n	8020994 <f_mkfs+0x2d8>
 8020982:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8020984:	f64f 73f4 	movw	r3, #65524	; 0xfff4
 8020988:	429a      	cmp	r2, r3
 802098a:	d803      	bhi.n	8020994 <f_mkfs+0x2d8>
		return FR_MKFS_ABORTED;
 802098c:	f04f 030e 	mov.w	r3, #14
 8020990:	f000 bc55 	b.w	802123e <f_mkfs+0xb82>

	/* Create partition table if needed */
	if (!partition) {
 8020994:	79bb      	ldrb	r3, [r7, #6]
 8020996:	2b00      	cmp	r3, #0
 8020998:	f040 80d4 	bne.w	8020b44 <f_mkfs+0x488>
		DWORD n_disk = b_part + n_part;
 802099c:	693b      	ldr	r3, [r7, #16]
 802099e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80209a0:	18d3      	adds	r3, r2, r3
 80209a2:	61bb      	str	r3, [r7, #24]

		mem_set(fs->win, 0, SS(fs));
 80209a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80209a6:	f103 0334 	add.w	r3, r3, #52	; 0x34
 80209aa:	4618      	mov	r0, r3
 80209ac:	f04f 0100 	mov.w	r1, #0
 80209b0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80209b4:	f7fc fa20 	bl	801cdf8 <mem_set>
		tbl = fs->win+MBR_Table;
 80209b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80209ba:	f503 73f9 	add.w	r3, r3, #498	; 0x1f2
 80209be:	617b      	str	r3, [r7, #20]
		ST_DWORD(tbl, 0x00010180);		/* Partition start in CHS */
 80209c0:	697b      	ldr	r3, [r7, #20]
 80209c2:	f04f 0280 	mov.w	r2, #128	; 0x80
 80209c6:	701a      	strb	r2, [r3, #0]
 80209c8:	697b      	ldr	r3, [r7, #20]
 80209ca:	f103 0301 	add.w	r3, r3, #1
 80209ce:	f04f 0201 	mov.w	r2, #1
 80209d2:	701a      	strb	r2, [r3, #0]
 80209d4:	697b      	ldr	r3, [r7, #20]
 80209d6:	f103 0302 	add.w	r3, r3, #2
 80209da:	f04f 0201 	mov.w	r2, #1
 80209de:	701a      	strb	r2, [r3, #0]
 80209e0:	697b      	ldr	r3, [r7, #20]
 80209e2:	f103 0303 	add.w	r3, r3, #3
 80209e6:	f04f 0200 	mov.w	r2, #0
 80209ea:	701a      	strb	r2, [r3, #0]
		if (n_disk < 63UL * 255 * 1024) {	/* Partition end in CHS */
 80209ec:	69ba      	ldr	r2, [r7, #24]
 80209ee:	f240 33ff 	movw	r3, #1023	; 0x3ff
 80209f2:	f2c0 03fb 	movt	r3, #251	; 0xfb
 80209f6:	429a      	cmp	r2, r3
 80209f8:	d81f      	bhi.n	8020a3a <f_mkfs+0x37e>
			n_disk = n_disk / 63 / 255;
 80209fa:	69ba      	ldr	r2, [r7, #24]
 80209fc:	f245 635b 	movw	r3, #22107	; 0x565b
 8020a00:	f2c0 5315 	movt	r3, #1301	; 0x515
 8020a04:	fba3 1302 	umull	r1, r3, r3, r2
 8020a08:	1ad2      	subs	r2, r2, r3
 8020a0a:	ea4f 0252 	mov.w	r2, r2, lsr #1
 8020a0e:	189b      	adds	r3, r3, r2
 8020a10:	ea4f 3353 	mov.w	r3, r3, lsr #13
 8020a14:	61bb      	str	r3, [r7, #24]
			tbl[7] = (BYTE)n_disk;
 8020a16:	697b      	ldr	r3, [r7, #20]
 8020a18:	f103 0307 	add.w	r3, r3, #7
 8020a1c:	69ba      	ldr	r2, [r7, #24]
 8020a1e:	b2d2      	uxtb	r2, r2
 8020a20:	701a      	strb	r2, [r3, #0]
			tbl[6] = (BYTE)((n_disk >> 2) | 63);
 8020a22:	697b      	ldr	r3, [r7, #20]
 8020a24:	f103 0306 	add.w	r3, r3, #6
 8020a28:	69ba      	ldr	r2, [r7, #24]
 8020a2a:	ea4f 0292 	mov.w	r2, r2, lsr #2
 8020a2e:	b2d2      	uxtb	r2, r2
 8020a30:	f042 023f 	orr.w	r2, r2, #63	; 0x3f
 8020a34:	b2d2      	uxtb	r2, r2
 8020a36:	701a      	strb	r2, [r3, #0]
 8020a38:	e00b      	b.n	8020a52 <f_mkfs+0x396>
		} else {
			ST_WORD(&tbl[6], 0xFFFF);
 8020a3a:	697b      	ldr	r3, [r7, #20]
 8020a3c:	f103 0306 	add.w	r3, r3, #6
 8020a40:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020a44:	701a      	strb	r2, [r3, #0]
 8020a46:	697b      	ldr	r3, [r7, #20]
 8020a48:	f103 0307 	add.w	r3, r3, #7
 8020a4c:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020a50:	701a      	strb	r2, [r3, #0]
		}
		tbl[5] = 254;
 8020a52:	697b      	ldr	r3, [r7, #20]
 8020a54:	f103 0305 	add.w	r3, r3, #5
 8020a58:	f04f 02fe 	mov.w	r2, #254	; 0xfe
 8020a5c:	701a      	strb	r2, [r3, #0]
		if (fmt != FS_FAT32)			/* System ID */
 8020a5e:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8020a62:	2b03      	cmp	r3, #3
 8020a64:	d00e      	beq.n	8020a84 <f_mkfs+0x3c8>
			tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
 8020a66:	697b      	ldr	r3, [r7, #20]
 8020a68:	f103 0204 	add.w	r2, r3, #4
 8020a6c:	6939      	ldr	r1, [r7, #16]
 8020a6e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8020a72:	4299      	cmp	r1, r3
 8020a74:	d802      	bhi.n	8020a7c <f_mkfs+0x3c0>
 8020a76:	f04f 0304 	mov.w	r3, #4
 8020a7a:	e001      	b.n	8020a80 <f_mkfs+0x3c4>
 8020a7c:	f04f 0306 	mov.w	r3, #6
 8020a80:	7013      	strb	r3, [r2, #0]
 8020a82:	e005      	b.n	8020a90 <f_mkfs+0x3d4>
		else
			tbl[4] = 0x0c;
 8020a84:	697b      	ldr	r3, [r7, #20]
 8020a86:	f103 0304 	add.w	r3, r3, #4
 8020a8a:	f04f 020c 	mov.w	r2, #12
 8020a8e:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
 8020a90:	697b      	ldr	r3, [r7, #20]
 8020a92:	f103 0308 	add.w	r3, r3, #8
 8020a96:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8020a9a:	701a      	strb	r2, [r3, #0]
 8020a9c:	697b      	ldr	r3, [r7, #20]
 8020a9e:	f103 0309 	add.w	r3, r3, #9
 8020aa2:	f04f 0200 	mov.w	r2, #0
 8020aa6:	701a      	strb	r2, [r3, #0]
 8020aa8:	697b      	ldr	r3, [r7, #20]
 8020aaa:	f103 030a 	add.w	r3, r3, #10
 8020aae:	f04f 0200 	mov.w	r2, #0
 8020ab2:	701a      	strb	r2, [r3, #0]
 8020ab4:	697b      	ldr	r3, [r7, #20]
 8020ab6:	f103 030b 	add.w	r3, r3, #11
 8020aba:	f04f 0200 	mov.w	r2, #0
 8020abe:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
 8020ac0:	697b      	ldr	r3, [r7, #20]
 8020ac2:	f103 030c 	add.w	r3, r3, #12
 8020ac6:	693a      	ldr	r2, [r7, #16]
 8020ac8:	b2d2      	uxtb	r2, r2
 8020aca:	701a      	strb	r2, [r3, #0]
 8020acc:	697b      	ldr	r3, [r7, #20]
 8020ace:	f103 030d 	add.w	r3, r3, #13
 8020ad2:	693a      	ldr	r2, [r7, #16]
 8020ad4:	b292      	uxth	r2, r2
 8020ad6:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020ada:	b292      	uxth	r2, r2
 8020adc:	b2d2      	uxtb	r2, r2
 8020ade:	701a      	strb	r2, [r3, #0]
 8020ae0:	697b      	ldr	r3, [r7, #20]
 8020ae2:	f103 030e 	add.w	r3, r3, #14
 8020ae6:	693a      	ldr	r2, [r7, #16]
 8020ae8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020aec:	b2d2      	uxtb	r2, r2
 8020aee:	701a      	strb	r2, [r3, #0]
 8020af0:	697b      	ldr	r3, [r7, #20]
 8020af2:	f103 030f 	add.w	r3, r3, #15
 8020af6:	693a      	ldr	r2, [r7, #16]
 8020af8:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8020afc:	b2d2      	uxtb	r2, r2
 8020afe:	701a      	strb	r2, [r3, #0]
		ST_WORD(tbl+64, 0xAA55);		/* Signature */
 8020b00:	697b      	ldr	r3, [r7, #20]
 8020b02:	f103 0340 	add.w	r3, r3, #64	; 0x40
 8020b06:	f04f 0255 	mov.w	r2, #85	; 0x55
 8020b0a:	701a      	strb	r2, [r3, #0]
 8020b0c:	697b      	ldr	r3, [r7, #20]
 8020b0e:	f103 0341 	add.w	r3, r3, #65	; 0x41
 8020b12:	f04f 02aa 	mov.w	r2, #170	; 0xaa
 8020b16:	701a      	strb	r2, [r3, #0]
		if (disk_write(drv, fs->win, 0, 1) != RES_OK)
 8020b18:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020b1a:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8020b1e:	79fa      	ldrb	r2, [r7, #7]
 8020b20:	4610      	mov	r0, r2
 8020b22:	4619      	mov	r1, r3
 8020b24:	f04f 0200 	mov.w	r2, #0
 8020b28:	f04f 0301 	mov.w	r3, #1
 8020b2c:	f7e4 fcea 	bl	8005504 <disk_write>
 8020b30:	4603      	mov	r3, r0
 8020b32:	2b00      	cmp	r3, #0
 8020b34:	d002      	beq.n	8020b3c <f_mkfs+0x480>
			return FR_DISK_ERR;
 8020b36:	f04f 0301 	mov.w	r3, #1
 8020b3a:	e380      	b.n	802123e <f_mkfs+0xb82>
		partition = 0xF8;
 8020b3c:	f04f 03f8 	mov.w	r3, #248	; 0xf8
 8020b40:	71bb      	strb	r3, [r7, #6]
 8020b42:	e002      	b.n	8020b4a <f_mkfs+0x48e>
	} else {
		partition = 0xF0;
 8020b44:	f04f 03f0 	mov.w	r3, #240	; 0xf0
 8020b48:	71bb      	strb	r3, [r7, #6]
	}

	/* Create boot record */
	tbl = fs->win;								/* Clear buffer */
 8020b4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020b4c:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8020b50:	617b      	str	r3, [r7, #20]
	mem_set(tbl, 0, SS(fs));
 8020b52:	6978      	ldr	r0, [r7, #20]
 8020b54:	f04f 0100 	mov.w	r1, #0
 8020b58:	f44f 7200 	mov.w	r2, #512	; 0x200
 8020b5c:	f7fc f94c 	bl	801cdf8 <mem_set>
	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
 8020b60:	697b      	ldr	r3, [r7, #20]
 8020b62:	f04f 02eb 	mov.w	r2, #235	; 0xeb
 8020b66:	701a      	strb	r2, [r3, #0]
 8020b68:	697b      	ldr	r3, [r7, #20]
 8020b6a:	f103 0301 	add.w	r3, r3, #1
 8020b6e:	f04f 02fe 	mov.w	r2, #254	; 0xfe
 8020b72:	701a      	strb	r2, [r3, #0]
 8020b74:	697b      	ldr	r3, [r7, #20]
 8020b76:	f103 0302 	add.w	r3, r3, #2
 8020b7a:	f04f 0290 	mov.w	r2, #144	; 0x90
 8020b7e:	701a      	strb	r2, [r3, #0]
 8020b80:	697b      	ldr	r3, [r7, #20]
 8020b82:	f103 0303 	add.w	r3, r3, #3
 8020b86:	f04f 0200 	mov.w	r2, #0
 8020b8a:	701a      	strb	r2, [r3, #0]
	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
 8020b8c:	697b      	ldr	r3, [r7, #20]
 8020b8e:	f103 030b 	add.w	r3, r3, #11
 8020b92:	f04f 0200 	mov.w	r2, #0
 8020b96:	701a      	strb	r2, [r3, #0]
 8020b98:	697b      	ldr	r3, [r7, #20]
 8020b9a:	f103 030c 	add.w	r3, r3, #12
 8020b9e:	f04f 0202 	mov.w	r2, #2
 8020ba2:	701a      	strb	r2, [r3, #0]
	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
 8020ba4:	697b      	ldr	r3, [r7, #20]
 8020ba6:	f103 030d 	add.w	r3, r3, #13
 8020baa:	88ba      	ldrh	r2, [r7, #4]
 8020bac:	b2d2      	uxtb	r2, r2
 8020bae:	701a      	strb	r2, [r3, #0]
	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
 8020bb0:	697b      	ldr	r3, [r7, #20]
 8020bb2:	f103 030e 	add.w	r3, r3, #14
 8020bb6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8020bb8:	b2d2      	uxtb	r2, r2
 8020bba:	701a      	strb	r2, [r3, #0]
 8020bbc:	697b      	ldr	r3, [r7, #20]
 8020bbe:	f103 030f 	add.w	r3, r3, #15
 8020bc2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8020bc4:	b292      	uxth	r2, r2
 8020bc6:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020bca:	b292      	uxth	r2, r2
 8020bcc:	b2d2      	uxtb	r2, r2
 8020bce:	701a      	strb	r2, [r3, #0]
	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
 8020bd0:	697b      	ldr	r3, [r7, #20]
 8020bd2:	f103 0310 	add.w	r3, r3, #16
 8020bd6:	f04f 0201 	mov.w	r2, #1
 8020bda:	701a      	strb	r2, [r3, #0]
	ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
 8020bdc:	697b      	ldr	r3, [r7, #20]
 8020bde:	f103 0311 	add.w	r3, r3, #17
 8020be2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020be4:	b2d2      	uxtb	r2, r2
 8020be6:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8020bea:	b2d2      	uxtb	r2, r2
 8020bec:	701a      	strb	r2, [r3, #0]
 8020bee:	697b      	ldr	r3, [r7, #20]
 8020bf0:	f103 0312 	add.w	r3, r3, #18
 8020bf4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020bf6:	b292      	uxth	r2, r2
 8020bf8:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8020bfc:	b292      	uxth	r2, r2
 8020bfe:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020c02:	b292      	uxth	r2, r2
 8020c04:	b2d2      	uxtb	r2, r2
 8020c06:	701a      	strb	r2, [r3, #0]
	if (n_part < 0x10000) {						/* Number of total sectors */
 8020c08:	693a      	ldr	r2, [r7, #16]
 8020c0a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8020c0e:	429a      	cmp	r2, r3
 8020c10:	d810      	bhi.n	8020c34 <f_mkfs+0x578>
		ST_WORD(tbl+BPB_TotSec16, n_part);
 8020c12:	697b      	ldr	r3, [r7, #20]
 8020c14:	f103 0313 	add.w	r3, r3, #19
 8020c18:	693a      	ldr	r2, [r7, #16]
 8020c1a:	b2d2      	uxtb	r2, r2
 8020c1c:	701a      	strb	r2, [r3, #0]
 8020c1e:	697b      	ldr	r3, [r7, #20]
 8020c20:	f103 0314 	add.w	r3, r3, #20
 8020c24:	693a      	ldr	r2, [r7, #16]
 8020c26:	b292      	uxth	r2, r2
 8020c28:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020c2c:	b292      	uxth	r2, r2
 8020c2e:	b2d2      	uxtb	r2, r2
 8020c30:	701a      	strb	r2, [r3, #0]
 8020c32:	e01f      	b.n	8020c74 <f_mkfs+0x5b8>
	} else {
		ST_DWORD(tbl+BPB_TotSec32, n_part);
 8020c34:	697b      	ldr	r3, [r7, #20]
 8020c36:	f103 0320 	add.w	r3, r3, #32
 8020c3a:	693a      	ldr	r2, [r7, #16]
 8020c3c:	b2d2      	uxtb	r2, r2
 8020c3e:	701a      	strb	r2, [r3, #0]
 8020c40:	697b      	ldr	r3, [r7, #20]
 8020c42:	f103 0321 	add.w	r3, r3, #33	; 0x21
 8020c46:	693a      	ldr	r2, [r7, #16]
 8020c48:	b292      	uxth	r2, r2
 8020c4a:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020c4e:	b292      	uxth	r2, r2
 8020c50:	b2d2      	uxtb	r2, r2
 8020c52:	701a      	strb	r2, [r3, #0]
 8020c54:	697b      	ldr	r3, [r7, #20]
 8020c56:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8020c5a:	693a      	ldr	r2, [r7, #16]
 8020c5c:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020c60:	b2d2      	uxtb	r2, r2
 8020c62:	701a      	strb	r2, [r3, #0]
 8020c64:	697b      	ldr	r3, [r7, #20]
 8020c66:	f103 0323 	add.w	r3, r3, #35	; 0x23
 8020c6a:	693a      	ldr	r2, [r7, #16]
 8020c6c:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8020c70:	b2d2      	uxtb	r2, r2
 8020c72:	701a      	strb	r2, [r3, #0]
	}
	tbl[BPB_Media] = partition;					/* Media descripter */
 8020c74:	697b      	ldr	r3, [r7, #20]
 8020c76:	f103 0315 	add.w	r3, r3, #21
 8020c7a:	79ba      	ldrb	r2, [r7, #6]
 8020c7c:	701a      	strb	r2, [r3, #0]
	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
 8020c7e:	697b      	ldr	r3, [r7, #20]
 8020c80:	f103 0318 	add.w	r3, r3, #24
 8020c84:	f04f 023f 	mov.w	r2, #63	; 0x3f
 8020c88:	701a      	strb	r2, [r3, #0]
 8020c8a:	697b      	ldr	r3, [r7, #20]
 8020c8c:	f103 0319 	add.w	r3, r3, #25
 8020c90:	f04f 0200 	mov.w	r2, #0
 8020c94:	701a      	strb	r2, [r3, #0]
	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
 8020c96:	697b      	ldr	r3, [r7, #20]
 8020c98:	f103 031a 	add.w	r3, r3, #26
 8020c9c:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020ca0:	701a      	strb	r2, [r3, #0]
 8020ca2:	697b      	ldr	r3, [r7, #20]
 8020ca4:	f103 031b 	add.w	r3, r3, #27
 8020ca8:	f04f 0200 	mov.w	r2, #0
 8020cac:	701a      	strb	r2, [r3, #0]
	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
 8020cae:	697b      	ldr	r3, [r7, #20]
 8020cb0:	f103 031c 	add.w	r3, r3, #28
 8020cb4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020cb6:	b2d2      	uxtb	r2, r2
 8020cb8:	701a      	strb	r2, [r3, #0]
 8020cba:	697b      	ldr	r3, [r7, #20]
 8020cbc:	f103 031d 	add.w	r3, r3, #29
 8020cc0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020cc2:	b292      	uxth	r2, r2
 8020cc4:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020cc8:	b292      	uxth	r2, r2
 8020cca:	b2d2      	uxtb	r2, r2
 8020ccc:	701a      	strb	r2, [r3, #0]
 8020cce:	697b      	ldr	r3, [r7, #20]
 8020cd0:	f103 031e 	add.w	r3, r3, #30
 8020cd4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020cd6:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020cda:	b2d2      	uxtb	r2, r2
 8020cdc:	701a      	strb	r2, [r3, #0]
 8020cde:	697b      	ldr	r3, [r7, #20]
 8020ce0:	f103 031f 	add.w	r3, r3, #31
 8020ce4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020ce6:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8020cea:	b2d2      	uxtb	r2, r2
 8020cec:	701a      	strb	r2, [r3, #0]
	n = get_fattime();							/* Use current time as a VSN */
 8020cee:	f001 f96d 	bl	8021fcc <get_fattime>
 8020cf2:	4603      	mov	r3, r0
 8020cf4:	60fb      	str	r3, [r7, #12]
	if (fmt != FS_FAT32) {
 8020cf6:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8020cfa:	2b03      	cmp	r3, #3
 8020cfc:	d048      	beq.n	8020d90 <f_mkfs+0x6d4>
		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
 8020cfe:	697b      	ldr	r3, [r7, #20]
 8020d00:	f103 0327 	add.w	r3, r3, #39	; 0x27
 8020d04:	68fa      	ldr	r2, [r7, #12]
 8020d06:	b2d2      	uxtb	r2, r2
 8020d08:	701a      	strb	r2, [r3, #0]
 8020d0a:	697b      	ldr	r3, [r7, #20]
 8020d0c:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8020d10:	68fa      	ldr	r2, [r7, #12]
 8020d12:	b292      	uxth	r2, r2
 8020d14:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020d18:	b292      	uxth	r2, r2
 8020d1a:	b2d2      	uxtb	r2, r2
 8020d1c:	701a      	strb	r2, [r3, #0]
 8020d1e:	697b      	ldr	r3, [r7, #20]
 8020d20:	f103 0329 	add.w	r3, r3, #41	; 0x29
 8020d24:	68fa      	ldr	r2, [r7, #12]
 8020d26:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020d2a:	b2d2      	uxtb	r2, r2
 8020d2c:	701a      	strb	r2, [r3, #0]
 8020d2e:	697b      	ldr	r3, [r7, #20]
 8020d30:	f103 032a 	add.w	r3, r3, #42	; 0x2a
 8020d34:	68fa      	ldr	r2, [r7, #12]
 8020d36:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8020d3a:	b2d2      	uxtb	r2, r2
 8020d3c:	701a      	strb	r2, [r3, #0]
		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of secters per FAT */
 8020d3e:	697b      	ldr	r3, [r7, #20]
 8020d40:	f103 0316 	add.w	r3, r3, #22
 8020d44:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020d46:	b2d2      	uxtb	r2, r2
 8020d48:	701a      	strb	r2, [r3, #0]
 8020d4a:	697b      	ldr	r3, [r7, #20]
 8020d4c:	f103 0317 	add.w	r3, r3, #23
 8020d50:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020d52:	b292      	uxth	r2, r2
 8020d54:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020d58:	b292      	uxth	r2, r2
 8020d5a:	b2d2      	uxtb	r2, r2
 8020d5c:	701a      	strb	r2, [r3, #0]
		tbl[BS_DrvNum] = 0x80;					/* Drive number */
 8020d5e:	697b      	ldr	r3, [r7, #20]
 8020d60:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8020d64:	f04f 0280 	mov.w	r2, #128	; 0x80
 8020d68:	701a      	strb	r2, [r3, #0]
		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
 8020d6a:	697b      	ldr	r3, [r7, #20]
 8020d6c:	f103 0326 	add.w	r3, r3, #38	; 0x26
 8020d70:	f04f 0229 	mov.w	r2, #41	; 0x29
 8020d74:	701a      	strb	r2, [r3, #0]
		mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);	/* Volume lavel, FAT signature */
 8020d76:	697b      	ldr	r3, [r7, #20]
 8020d78:	f103 032b 	add.w	r3, r3, #43	; 0x2b
 8020d7c:	4618      	mov	r0, r3
 8020d7e:	f64b 31a0 	movw	r1, #48032	; 0xbba0
 8020d82:	f6c0 0102 	movt	r1, #2050	; 0x802
 8020d86:	f04f 0213 	mov.w	r2, #19
 8020d8a:	f7fc f80d 	bl	801cda8 <mem_cpy>
 8020d8e:	e087      	b.n	8020ea0 <f_mkfs+0x7e4>
	} else {
		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
 8020d90:	697b      	ldr	r3, [r7, #20]
 8020d92:	f103 0343 	add.w	r3, r3, #67	; 0x43
 8020d96:	68fa      	ldr	r2, [r7, #12]
 8020d98:	b2d2      	uxtb	r2, r2
 8020d9a:	701a      	strb	r2, [r3, #0]
 8020d9c:	697b      	ldr	r3, [r7, #20]
 8020d9e:	f103 0344 	add.w	r3, r3, #68	; 0x44
 8020da2:	68fa      	ldr	r2, [r7, #12]
 8020da4:	b292      	uxth	r2, r2
 8020da6:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020daa:	b292      	uxth	r2, r2
 8020dac:	b2d2      	uxtb	r2, r2
 8020dae:	701a      	strb	r2, [r3, #0]
 8020db0:	697b      	ldr	r3, [r7, #20]
 8020db2:	f103 0345 	add.w	r3, r3, #69	; 0x45
 8020db6:	68fa      	ldr	r2, [r7, #12]
 8020db8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020dbc:	b2d2      	uxtb	r2, r2
 8020dbe:	701a      	strb	r2, [r3, #0]
 8020dc0:	697b      	ldr	r3, [r7, #20]
 8020dc2:	f103 0346 	add.w	r3, r3, #70	; 0x46
 8020dc6:	68fa      	ldr	r2, [r7, #12]
 8020dc8:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8020dcc:	b2d2      	uxtb	r2, r2
 8020dce:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of secters per FAT */
 8020dd0:	697b      	ldr	r3, [r7, #20]
 8020dd2:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8020dd6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020dd8:	b2d2      	uxtb	r2, r2
 8020dda:	701a      	strb	r2, [r3, #0]
 8020ddc:	697b      	ldr	r3, [r7, #20]
 8020dde:	f103 0325 	add.w	r3, r3, #37	; 0x25
 8020de2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020de4:	b292      	uxth	r2, r2
 8020de6:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020dea:	b292      	uxth	r2, r2
 8020dec:	b2d2      	uxtb	r2, r2
 8020dee:	701a      	strb	r2, [r3, #0]
 8020df0:	697b      	ldr	r3, [r7, #20]
 8020df2:	f103 0326 	add.w	r3, r3, #38	; 0x26
 8020df6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020df8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020dfc:	b2d2      	uxtb	r2, r2
 8020dfe:	701a      	strb	r2, [r3, #0]
 8020e00:	697b      	ldr	r3, [r7, #20]
 8020e02:	f103 0327 	add.w	r3, r3, #39	; 0x27
 8020e06:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020e08:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8020e0c:	b2d2      	uxtb	r2, r2
 8020e0e:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
 8020e10:	697b      	ldr	r3, [r7, #20]
 8020e12:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8020e16:	f04f 0202 	mov.w	r2, #2
 8020e1a:	701a      	strb	r2, [r3, #0]
 8020e1c:	697b      	ldr	r3, [r7, #20]
 8020e1e:	f103 032d 	add.w	r3, r3, #45	; 0x2d
 8020e22:	f04f 0200 	mov.w	r2, #0
 8020e26:	701a      	strb	r2, [r3, #0]
 8020e28:	697b      	ldr	r3, [r7, #20]
 8020e2a:	f103 032e 	add.w	r3, r3, #46	; 0x2e
 8020e2e:	f04f 0200 	mov.w	r2, #0
 8020e32:	701a      	strb	r2, [r3, #0]
 8020e34:	697b      	ldr	r3, [r7, #20]
 8020e36:	f103 032f 	add.w	r3, r3, #47	; 0x2f
 8020e3a:	f04f 0200 	mov.w	r2, #0
 8020e3e:	701a      	strb	r2, [r3, #0]
		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
 8020e40:	697b      	ldr	r3, [r7, #20]
 8020e42:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8020e46:	f04f 0201 	mov.w	r2, #1
 8020e4a:	701a      	strb	r2, [r3, #0]
 8020e4c:	697b      	ldr	r3, [r7, #20]
 8020e4e:	f103 0331 	add.w	r3, r3, #49	; 0x31
 8020e52:	f04f 0200 	mov.w	r2, #0
 8020e56:	701a      	strb	r2, [r3, #0]
		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
 8020e58:	697b      	ldr	r3, [r7, #20]
 8020e5a:	f103 0332 	add.w	r3, r3, #50	; 0x32
 8020e5e:	f04f 0206 	mov.w	r2, #6
 8020e62:	701a      	strb	r2, [r3, #0]
 8020e64:	697b      	ldr	r3, [r7, #20]
 8020e66:	f103 0333 	add.w	r3, r3, #51	; 0x33
 8020e6a:	f04f 0200 	mov.w	r2, #0
 8020e6e:	701a      	strb	r2, [r3, #0]
		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
 8020e70:	697b      	ldr	r3, [r7, #20]
 8020e72:	f103 0340 	add.w	r3, r3, #64	; 0x40
 8020e76:	f04f 0280 	mov.w	r2, #128	; 0x80
 8020e7a:	701a      	strb	r2, [r3, #0]
		tbl[BS_BootSig32] = 0x29;				/* Extended boot signature */
 8020e7c:	697b      	ldr	r3, [r7, #20]
 8020e7e:	f103 0342 	add.w	r3, r3, #66	; 0x42
 8020e82:	f04f 0229 	mov.w	r2, #41	; 0x29
 8020e86:	701a      	strb	r2, [r3, #0]
		mem_cpy(tbl+BS_VolLab32, "NO NAME    FAT32   ", 19);	/* Volume lavel, FAT signature */
 8020e88:	697b      	ldr	r3, [r7, #20]
 8020e8a:	f103 0347 	add.w	r3, r3, #71	; 0x47
 8020e8e:	4618      	mov	r0, r3
 8020e90:	f64b 31b4 	movw	r1, #48052	; 0xbbb4
 8020e94:	f6c0 0102 	movt	r1, #2050	; 0x802
 8020e98:	f04f 0213 	mov.w	r2, #19
 8020e9c:	f7fb ff84 	bl	801cda8 <mem_cpy>
	}
	ST_WORD(tbl+BS_55AA, 0xAA55);				/* Signature */
 8020ea0:	697b      	ldr	r3, [r7, #20]
 8020ea2:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 8020ea6:	f04f 0255 	mov.w	r2, #85	; 0x55
 8020eaa:	701a      	strb	r2, [r3, #0]
 8020eac:	697b      	ldr	r3, [r7, #20]
 8020eae:	f503 73fe 	add.w	r3, r3, #508	; 0x1fc
 8020eb2:	f103 0303 	add.w	r3, r3, #3
 8020eb6:	f04f 02aa 	mov.w	r2, #170	; 0xaa
 8020eba:	701a      	strb	r2, [r3, #0]
	if (SS(fs) > 512U) {
		ST_WORD(tbl+SS(fs)-2, 0xAA55);
	}
	if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
 8020ebc:	79fb      	ldrb	r3, [r7, #7]
 8020ebe:	4618      	mov	r0, r3
 8020ec0:	6979      	ldr	r1, [r7, #20]
 8020ec2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020ec4:	f04f 0301 	mov.w	r3, #1
 8020ec8:	f7e4 fb1c 	bl	8005504 <disk_write>
 8020ecc:	4603      	mov	r3, r0
 8020ece:	2b00      	cmp	r3, #0
 8020ed0:	d002      	beq.n	8020ed8 <f_mkfs+0x81c>
		return FR_DISK_ERR;
 8020ed2:	f04f 0301 	mov.w	r3, #1
 8020ed6:	e1b2      	b.n	802123e <f_mkfs+0xb82>
	if (fmt == FS_FAT32)
 8020ed8:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8020edc:	2b03      	cmp	r3, #3
 8020ede:	d10a      	bne.n	8020ef6 <f_mkfs+0x83a>
		disk_write(drv, tbl, b_part+6, 1);
 8020ee0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020ee2:	f103 0306 	add.w	r3, r3, #6
 8020ee6:	79fa      	ldrb	r2, [r7, #7]
 8020ee8:	4610      	mov	r0, r2
 8020eea:	6979      	ldr	r1, [r7, #20]
 8020eec:	461a      	mov	r2, r3
 8020eee:	f04f 0301 	mov.w	r3, #1
 8020ef2:	f7e4 fb07 	bl	8005504 <disk_write>

	/* Initialize FAT area */
	for (m = 0; m < N_FATS; m++) {
 8020ef6:	f04f 0300 	mov.w	r3, #0
 8020efa:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
 8020efe:	e0be      	b.n	802107e <f_mkfs+0x9c2>
		mem_set(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
 8020f00:	6978      	ldr	r0, [r7, #20]
 8020f02:	f04f 0100 	mov.w	r1, #0
 8020f06:	f44f 7200 	mov.w	r2, #512	; 0x200
 8020f0a:	f7fb ff75 	bl	801cdf8 <mem_set>
		if (fmt != FS_FAT32) {
 8020f0e:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8020f12:	2b03      	cmp	r3, #3
 8020f14:	d02e      	beq.n	8020f74 <f_mkfs+0x8b8>
			n = (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
 8020f16:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 8020f1a:	2b01      	cmp	r3, #1
 8020f1c:	d104      	bne.n	8020f28 <f_mkfs+0x86c>
 8020f1e:	f44f 437f 	mov.w	r3, #65280	; 0xff00
 8020f22:	f2c0 03ff 	movt	r3, #255	; 0xff
 8020f26:	e001      	b.n	8020f2c <f_mkfs+0x870>
 8020f28:	f06f 03ff 	mvn.w	r3, #255	; 0xff
 8020f2c:	60fb      	str	r3, [r7, #12]
			n |= partition;
 8020f2e:	79ba      	ldrb	r2, [r7, #6]
 8020f30:	68fb      	ldr	r3, [r7, #12]
 8020f32:	4313      	orrs	r3, r2
 8020f34:	60fb      	str	r3, [r7, #12]
			ST_DWORD(tbl, n);				/* Reserve cluster #0-1 (FAT12/16) */
 8020f36:	68fb      	ldr	r3, [r7, #12]
 8020f38:	b2da      	uxtb	r2, r3
 8020f3a:	697b      	ldr	r3, [r7, #20]
 8020f3c:	701a      	strb	r2, [r3, #0]
 8020f3e:	697b      	ldr	r3, [r7, #20]
 8020f40:	f103 0301 	add.w	r3, r3, #1
 8020f44:	68fa      	ldr	r2, [r7, #12]
 8020f46:	b292      	uxth	r2, r2
 8020f48:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8020f4c:	b292      	uxth	r2, r2
 8020f4e:	b2d2      	uxtb	r2, r2
 8020f50:	701a      	strb	r2, [r3, #0]
 8020f52:	697b      	ldr	r3, [r7, #20]
 8020f54:	f103 0302 	add.w	r3, r3, #2
 8020f58:	68fa      	ldr	r2, [r7, #12]
 8020f5a:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8020f5e:	b2d2      	uxtb	r2, r2
 8020f60:	701a      	strb	r2, [r3, #0]
 8020f62:	697b      	ldr	r3, [r7, #20]
 8020f64:	f103 0303 	add.w	r3, r3, #3
 8020f68:	68fa      	ldr	r2, [r7, #12]
 8020f6a:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8020f6e:	b2d2      	uxtb	r2, r2
 8020f70:	701a      	strb	r2, [r3, #0]
 8020f72:	e045      	b.n	8021000 <f_mkfs+0x944>
		} else {
			ST_DWORD(tbl+0, 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
 8020f74:	697b      	ldr	r3, [r7, #20]
 8020f76:	f04f 02f8 	mov.w	r2, #248	; 0xf8
 8020f7a:	701a      	strb	r2, [r3, #0]
 8020f7c:	697b      	ldr	r3, [r7, #20]
 8020f7e:	f103 0301 	add.w	r3, r3, #1
 8020f82:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020f86:	701a      	strb	r2, [r3, #0]
 8020f88:	697b      	ldr	r3, [r7, #20]
 8020f8a:	f103 0302 	add.w	r3, r3, #2
 8020f8e:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020f92:	701a      	strb	r2, [r3, #0]
 8020f94:	697b      	ldr	r3, [r7, #20]
 8020f96:	f103 0303 	add.w	r3, r3, #3
 8020f9a:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020f9e:	701a      	strb	r2, [r3, #0]
			ST_DWORD(tbl+4, 0xFFFFFFFF);
 8020fa0:	697b      	ldr	r3, [r7, #20]
 8020fa2:	f103 0304 	add.w	r3, r3, #4
 8020fa6:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020faa:	701a      	strb	r2, [r3, #0]
 8020fac:	697b      	ldr	r3, [r7, #20]
 8020fae:	f103 0305 	add.w	r3, r3, #5
 8020fb2:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020fb6:	701a      	strb	r2, [r3, #0]
 8020fb8:	697b      	ldr	r3, [r7, #20]
 8020fba:	f103 0306 	add.w	r3, r3, #6
 8020fbe:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020fc2:	701a      	strb	r2, [r3, #0]
 8020fc4:	697b      	ldr	r3, [r7, #20]
 8020fc6:	f103 0307 	add.w	r3, r3, #7
 8020fca:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020fce:	701a      	strb	r2, [r3, #0]
			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
 8020fd0:	697b      	ldr	r3, [r7, #20]
 8020fd2:	f103 0308 	add.w	r3, r3, #8
 8020fd6:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020fda:	701a      	strb	r2, [r3, #0]
 8020fdc:	697b      	ldr	r3, [r7, #20]
 8020fde:	f103 0309 	add.w	r3, r3, #9
 8020fe2:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020fe6:	701a      	strb	r2, [r3, #0]
 8020fe8:	697b      	ldr	r3, [r7, #20]
 8020fea:	f103 030a 	add.w	r3, r3, #10
 8020fee:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8020ff2:	701a      	strb	r2, [r3, #0]
 8020ff4:	697b      	ldr	r3, [r7, #20]
 8020ff6:	f103 030b 	add.w	r3, r3, #11
 8020ffa:	f04f 020f 	mov.w	r2, #15
 8020ffe:	701a      	strb	r2, [r3, #0]
		}
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
 8021000:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8021002:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8021004:	f102 0201 	add.w	r2, r2, #1
 8021008:	64ba      	str	r2, [r7, #72]	; 0x48
 802100a:	79fa      	ldrb	r2, [r7, #7]
 802100c:	4610      	mov	r0, r2
 802100e:	6979      	ldr	r1, [r7, #20]
 8021010:	461a      	mov	r2, r3
 8021012:	f04f 0301 	mov.w	r3, #1
 8021016:	f7e4 fa75 	bl	8005504 <disk_write>
 802101a:	4603      	mov	r3, r0
 802101c:	2b00      	cmp	r3, #0
 802101e:	d002      	beq.n	8021026 <f_mkfs+0x96a>
			return FR_DISK_ERR;
 8021020:	f04f 0301 	mov.w	r3, #1
 8021024:	e10b      	b.n	802123e <f_mkfs+0xb82>
		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
 8021026:	6978      	ldr	r0, [r7, #20]
 8021028:	f04f 0100 	mov.w	r1, #0
 802102c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8021030:	f7fb fee2 	bl	801cdf8 <mem_set>
		for (n = 1; n < n_fat; n++) {
 8021034:	f04f 0301 	mov.w	r3, #1
 8021038:	60fb      	str	r3, [r7, #12]
 802103a:	e016      	b.n	802106a <f_mkfs+0x9ae>
			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
 802103c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802103e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8021040:	f102 0201 	add.w	r2, r2, #1
 8021044:	64ba      	str	r2, [r7, #72]	; 0x48
 8021046:	79fa      	ldrb	r2, [r7, #7]
 8021048:	4610      	mov	r0, r2
 802104a:	6979      	ldr	r1, [r7, #20]
 802104c:	461a      	mov	r2, r3
 802104e:	f04f 0301 	mov.w	r3, #1
 8021052:	f7e4 fa57 	bl	8005504 <disk_write>
 8021056:	4603      	mov	r3, r0
 8021058:	2b00      	cmp	r3, #0
 802105a:	d002      	beq.n	8021062 <f_mkfs+0x9a6>
				return FR_DISK_ERR;
 802105c:	f04f 0301 	mov.w	r3, #1
 8021060:	e0ed      	b.n	802123e <f_mkfs+0xb82>
			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
		}
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
		for (n = 1; n < n_fat; n++) {
 8021062:	68fb      	ldr	r3, [r7, #12]
 8021064:	f103 0301 	add.w	r3, r3, #1
 8021068:	60fb      	str	r3, [r7, #12]
 802106a:	68fa      	ldr	r2, [r7, #12]
 802106c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802106e:	429a      	cmp	r2, r3
 8021070:	d3e4      	bcc.n	802103c <f_mkfs+0x980>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)
		disk_write(drv, tbl, b_part+6, 1);

	/* Initialize FAT area */
	for (m = 0; m < N_FATS; m++) {
 8021072:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 8021076:	f103 0301 	add.w	r3, r3, #1
 802107a:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
 802107e:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 8021082:	2b00      	cmp	r3, #0
 8021084:	f43f af3c 	beq.w	8020f00 <f_mkfs+0x844>
				return FR_DISK_ERR;
		}
	}

	/* Initialize Root directory */
	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
 8021088:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 802108c:	2b03      	cmp	r3, #3
 802108e:	d102      	bne.n	8021096 <f_mkfs+0x9da>
 8021090:	88bb      	ldrh	r3, [r7, #4]
 8021092:	b2db      	uxtb	r3, r3
 8021094:	e001      	b.n	802109a <f_mkfs+0x9de>
 8021096:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021098:	b2db      	uxtb	r3, r3
 802109a:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
	do {
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
 802109e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80210a0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80210a2:	f102 0201 	add.w	r2, r2, #1
 80210a6:	64ba      	str	r2, [r7, #72]	; 0x48
 80210a8:	79fa      	ldrb	r2, [r7, #7]
 80210aa:	4610      	mov	r0, r2
 80210ac:	6979      	ldr	r1, [r7, #20]
 80210ae:	461a      	mov	r2, r3
 80210b0:	f04f 0301 	mov.w	r3, #1
 80210b4:	f7e4 fa26 	bl	8005504 <disk_write>
 80210b8:	4603      	mov	r3, r0
 80210ba:	2b00      	cmp	r3, #0
 80210bc:	d002      	beq.n	80210c4 <f_mkfs+0xa08>
			return FR_DISK_ERR;
 80210be:	f04f 0301 	mov.w	r3, #1
 80210c2:	e0bc      	b.n	802123e <f_mkfs+0xb82>
	} while (--m);
 80210c4:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 80210c8:	f103 33ff 	add.w	r3, r3, #4294967295
 80210cc:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
 80210d0:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 80210d4:	2b00      	cmp	r3, #0
 80210d6:	d1e2      	bne.n	802109e <f_mkfs+0x9e2>

	/* Create FSInfo record if needed */
	if (fmt == FS_FAT32) {
 80210d8:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 80210dc:	2b03      	cmp	r3, #3
 80210de:	f040 80a0 	bne.w	8021222 <f_mkfs+0xb66>
		ST_WORD(tbl+BS_55AA, 0xAA55);
 80210e2:	697b      	ldr	r3, [r7, #20]
 80210e4:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 80210e8:	f04f 0255 	mov.w	r2, #85	; 0x55
 80210ec:	701a      	strb	r2, [r3, #0]
 80210ee:	697b      	ldr	r3, [r7, #20]
 80210f0:	f503 73fe 	add.w	r3, r3, #508	; 0x1fc
 80210f4:	f103 0303 	add.w	r3, r3, #3
 80210f8:	f04f 02aa 	mov.w	r2, #170	; 0xaa
 80210fc:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
 80210fe:	697b      	ldr	r3, [r7, #20]
 8021100:	f04f 0252 	mov.w	r2, #82	; 0x52
 8021104:	701a      	strb	r2, [r3, #0]
 8021106:	697b      	ldr	r3, [r7, #20]
 8021108:	f103 0301 	add.w	r3, r3, #1
 802110c:	f04f 0252 	mov.w	r2, #82	; 0x52
 8021110:	701a      	strb	r2, [r3, #0]
 8021112:	697b      	ldr	r3, [r7, #20]
 8021114:	f103 0302 	add.w	r3, r3, #2
 8021118:	f04f 0261 	mov.w	r2, #97	; 0x61
 802111c:	701a      	strb	r2, [r3, #0]
 802111e:	697b      	ldr	r3, [r7, #20]
 8021120:	f103 0303 	add.w	r3, r3, #3
 8021124:	f04f 0241 	mov.w	r2, #65	; 0x41
 8021128:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
 802112a:	697b      	ldr	r3, [r7, #20]
 802112c:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 8021130:	f04f 0272 	mov.w	r2, #114	; 0x72
 8021134:	701a      	strb	r2, [r3, #0]
 8021136:	697b      	ldr	r3, [r7, #20]
 8021138:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 802113c:	f103 0301 	add.w	r3, r3, #1
 8021140:	f04f 0272 	mov.w	r2, #114	; 0x72
 8021144:	701a      	strb	r2, [r3, #0]
 8021146:	697b      	ldr	r3, [r7, #20]
 8021148:	f503 73f3 	add.w	r3, r3, #486	; 0x1e6
 802114c:	f04f 0241 	mov.w	r2, #65	; 0x41
 8021150:	701a      	strb	r2, [r3, #0]
 8021152:	697b      	ldr	r3, [r7, #20]
 8021154:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 8021158:	f103 0303 	add.w	r3, r3, #3
 802115c:	f04f 0261 	mov.w	r2, #97	; 0x61
 8021160:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
 8021162:	697b      	ldr	r3, [r7, #20]
 8021164:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 8021168:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 802116a:	b2d2      	uxtb	r2, r2
 802116c:	f102 32ff 	add.w	r2, r2, #4294967295
 8021170:	b2d2      	uxtb	r2, r2
 8021172:	701a      	strb	r2, [r3, #0]
 8021174:	697b      	ldr	r3, [r7, #20]
 8021176:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 802117a:	f103 0301 	add.w	r3, r3, #1
 802117e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8021180:	b292      	uxth	r2, r2
 8021182:	f102 32ff 	add.w	r2, r2, #4294967295
 8021186:	b292      	uxth	r2, r2
 8021188:	ea4f 2212 	mov.w	r2, r2, lsr #8
 802118c:	b292      	uxth	r2, r2
 802118e:	b2d2      	uxtb	r2, r2
 8021190:	701a      	strb	r2, [r3, #0]
 8021192:	697b      	ldr	r3, [r7, #20]
 8021194:	f503 73f5 	add.w	r3, r3, #490	; 0x1ea
 8021198:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 802119a:	f102 32ff 	add.w	r2, r2, #4294967295
 802119e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80211a2:	b2d2      	uxtb	r2, r2
 80211a4:	701a      	strb	r2, [r3, #0]
 80211a6:	697b      	ldr	r3, [r7, #20]
 80211a8:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 80211ac:	f103 0303 	add.w	r3, r3, #3
 80211b0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80211b2:	f102 32ff 	add.w	r2, r2, #4294967295
 80211b6:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80211ba:	b2d2      	uxtb	r2, r2
 80211bc:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
 80211be:	697b      	ldr	r3, [r7, #20]
 80211c0:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
 80211c4:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80211c8:	701a      	strb	r2, [r3, #0]
 80211ca:	697b      	ldr	r3, [r7, #20]
 80211cc:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
 80211d0:	f103 0301 	add.w	r3, r3, #1
 80211d4:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80211d8:	701a      	strb	r2, [r3, #0]
 80211da:	697b      	ldr	r3, [r7, #20]
 80211dc:	f503 73f7 	add.w	r3, r3, #494	; 0x1ee
 80211e0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80211e4:	701a      	strb	r2, [r3, #0]
 80211e6:	697b      	ldr	r3, [r7, #20]
 80211e8:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
 80211ec:	f103 0303 	add.w	r3, r3, #3
 80211f0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80211f4:	701a      	strb	r2, [r3, #0]
		disk_write(drv, tbl, b_part+1, 1);
 80211f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80211f8:	f103 0301 	add.w	r3, r3, #1
 80211fc:	79fa      	ldrb	r2, [r7, #7]
 80211fe:	4610      	mov	r0, r2
 8021200:	6979      	ldr	r1, [r7, #20]
 8021202:	461a      	mov	r2, r3
 8021204:	f04f 0301 	mov.w	r3, #1
 8021208:	f7e4 f97c 	bl	8005504 <disk_write>
		disk_write(drv, tbl, b_part+7, 1);
 802120c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802120e:	f103 0307 	add.w	r3, r3, #7
 8021212:	79fa      	ldrb	r2, [r7, #7]
 8021214:	4610      	mov	r0, r2
 8021216:	6979      	ldr	r1, [r7, #20]
 8021218:	461a      	mov	r2, r3
 802121a:	f04f 0301 	mov.w	r3, #1
 802121e:	f7e4 f971 	bl	8005504 <disk_write>
	}

	return (disk_ioctl(drv, CTRL_SYNC, (void*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
 8021222:	79fb      	ldrb	r3, [r7, #7]
 8021224:	4618      	mov	r0, r3
 8021226:	f04f 0100 	mov.w	r1, #0
 802122a:	f04f 0200 	mov.w	r2, #0
 802122e:	f7e4 f9d5 	bl	80055dc <disk_ioctl>
 8021232:	4603      	mov	r3, r0
 8021234:	2b00      	cmp	r3, #0
 8021236:	bf0c      	ite	eq
 8021238:	2300      	moveq	r3, #0
 802123a:	2301      	movne	r3, #1
 802123c:	b2db      	uxtb	r3, r3
}
 802123e:	4618      	mov	r0, r3
 8021240:	f107 0750 	add.w	r7, r7, #80	; 0x50
 8021244:	46bd      	mov	sp, r7
 8021246:	bd80      	pop	{r7, pc}

08021248 <_ZN12CFileHandlerC1Ev>:
static int16_t  iPCMBuffer2[PCM_OUT_SIZE] = {0x0000}; //double Buffering
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/


CFileHandler::CFileHandler() {
 8021248:	b580      	push	{r7, lr}
 802124a:	b082      	sub	sp, #8
 802124c:	af00      	add	r7, sp, #0
 802124e:	6078      	str	r0, [r7, #4]
 8021250:	687b      	ldr	r3, [r7, #4]
 8021252:	4618      	mov	r0, r3
 8021254:	f7f8 f9fa 	bl	801964c <_ZN12AManagedTaskC1Ev>
 8021258:	687b      	ldr	r3, [r7, #4]
 802125a:	4a20      	ldr	r2, [pc, #128]	; (80212dc <_ZN12CFileHandlerC1Ev+0x94>)
 802125c:	601a      	str	r2, [r3, #0]
	fsresult = FR_OK;
 802125e:	687b      	ldr	r3, [r7, #4]
 8021260:	f04f 0200 	mov.w	r2, #0
 8021264:	731a      	strb	r2, [r3, #12]
	uiBytesLeft = 0;
 8021266:	687b      	ldr	r3, [r7, #4]
 8021268:	f04f 0200 	mov.w	r2, #0
 802126c:	f8a3 229a 	strh.w	r2, [r3, #666]	; 0x29a
	ptrReadPosition = uiReadBuffer;
 8021270:	687a      	ldr	r2, [r7, #4]
 8021272:	f241 03fc 	movw	r3, #4348	; 0x10fc
 8021276:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802127a:	f8c2 329c 	str.w	r3, [r2, #668]	; 0x29c
	eMP3State = OPEN_FILE;
 802127e:	687b      	ldr	r3, [r7, #4]
 8021280:	f04f 0201 	mov.w	r2, #1
 8021284:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
	eBuffer = BUFFER_1;
 8021288:	687b      	ldr	r3, [r7, #4]
 802128a:	f04f 0200 	mov.w	r2, #0
 802128e:	f883 2291 	strb.w	r2, [r3, #657]	; 0x291
	uiVolume = 80;
 8021292:	687b      	ldr	r3, [r7, #4]
 8021294:	f04f 0250 	mov.w	r2, #80	; 0x50
 8021298:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
	uiLastSamplerate = 48000;
 802129c:	687b      	ldr	r3, [r7, #4]
 802129e:	f64b 3280 	movw	r2, #48000	; 0xbb80
 80212a2:	f8a3 2298 	strh.w	r2, [r3, #664]	; 0x298
	bPlaying  = true;
 80212a6:	687b      	ldr	r3, [r7, #4]
 80212a8:	f04f 0201 	mov.w	r2, #1
 80212ac:	f883 2294 	strb.w	r2, [r3, #660]	; 0x294
	bPlay = false;
 80212b0:	687b      	ldr	r3, [r7, #4]
 80212b2:	f04f 0200 	mov.w	r2, #0
 80212b6:	f883 2295 	strb.w	r2, [r3, #661]	; 0x295
	bNext = false;
 80212ba:	687b      	ldr	r3, [r7, #4]
 80212bc:	f04f 0200 	mov.w	r2, #0
 80212c0:	f883 2296 	strb.w	r2, [r3, #662]	; 0x296
	bStop = false;
 80212c4:	687b      	ldr	r3, [r7, #4]
 80212c6:	f04f 0200 	mov.w	r2, #0
 80212ca:	f883 2297 	strb.w	r2, [r3, #663]	; 0x297
}
 80212ce:	687b      	ldr	r3, [r7, #4]
 80212d0:	4618      	mov	r0, r3
 80212d2:	f107 0708 	add.w	r7, r7, #8
 80212d6:	46bd      	mov	sp, r7
 80212d8:	bd80      	pop	{r7, pc}
 80212da:	bf00      	nop
 80212dc:	08032ba0 	.word	0x08032ba0

080212e0 <_ZN12CFileHandlerD1Ev>:

CFileHandler::~CFileHandler() {
 80212e0:	b580      	push	{r7, lr}
 80212e2:	b082      	sub	sp, #8
 80212e4:	af00      	add	r7, sp, #0
 80212e6:	6078      	str	r0, [r7, #4]
 80212e8:	687b      	ldr	r3, [r7, #4]
 80212ea:	4a0a      	ldr	r2, [pc, #40]	; (8021314 <_ZN12CFileHandlerD1Ev+0x34>)
 80212ec:	601a      	str	r2, [r3, #0]
	// TODO Auto-generated destructor stub
}
 80212ee:	6878      	ldr	r0, [r7, #4]
 80212f0:	f7f8 f9c8 	bl	8019684 <_ZN12AManagedTaskD1Ev>
 80212f4:	f04f 0300 	mov.w	r3, #0
 80212f8:	f003 0301 	and.w	r3, r3, #1
 80212fc:	b2db      	uxtb	r3, r3
 80212fe:	2b00      	cmp	r3, #0
 8021300:	d002      	beq.n	8021308 <_ZN12CFileHandlerD1Ev+0x28>
 8021302:	6878      	ldr	r0, [r7, #4]
 8021304:	f000 ff66 	bl	80221d4 <_ZdlPv>
 8021308:	687b      	ldr	r3, [r7, #4]
 802130a:	4618      	mov	r0, r3
 802130c:	f107 0708 	add.w	r7, r7, #8
 8021310:	46bd      	mov	sp, r7
 8021312:	bd80      	pop	{r7, pc}
 8021314:	08032ba0 	.word	0x08032ba0

08021318 <_ZN12CFileHandlerD0Ev>:
	bPlay = false;
	bNext = false;
	bStop = false;
}

CFileHandler::~CFileHandler() {
 8021318:	b580      	push	{r7, lr}
 802131a:	b082      	sub	sp, #8
 802131c:	af00      	add	r7, sp, #0
 802131e:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated destructor stub
}
 8021320:	6878      	ldr	r0, [r7, #4]
 8021322:	f7ff ffdd 	bl	80212e0 <_ZN12CFileHandlerD1Ev>
 8021326:	6878      	ldr	r0, [r7, #4]
 8021328:	f000 ff54 	bl	80221d4 <_ZdlPv>
 802132c:	687b      	ldr	r3, [r7, #4]
 802132e:	4618      	mov	r0, r3
 8021330:	f107 0708 	add.w	r7, r7, #8
 8021334:	46bd      	mov	sp, r7
 8021336:	bd80      	pop	{r7, pc}

08021338 <_ZN12CFileHandler12HardwareInitEv>:
  * @brief  HardwareInit called before Scheduler starts
  * 		SD Card interface will be initialized
  * @param  None
  * @retval true on succsess
  */
bool CFileHandler::HardwareInit(){
 8021338:	b580      	push	{r7, lr}
 802133a:	b082      	sub	sp, #8
 802133c:	af00      	add	r7, sp, #0
 802133e:	6078      	str	r0, [r7, #4]
	vSemaphoreCreateBinary(semShock);
 8021340:	f04f 0001 	mov.w	r0, #1
 8021344:	f04f 0100 	mov.w	r1, #0
 8021348:	f7f8 fd8a 	bl	8019e60 <xQueueCreate>
 802134c:	4602      	mov	r2, r0
 802134e:	f241 03f8 	movw	r3, #4344	; 0x10f8
 8021352:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021356:	601a      	str	r2, [r3, #0]
 8021358:	f241 03f8 	movw	r3, #4344	; 0x10f8
 802135c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021360:	681b      	ldr	r3, [r3, #0]
 8021362:	2b00      	cmp	r3, #0
 8021364:	d00d      	beq.n	8021382 <_ZN12CFileHandler12HardwareInitEv+0x4a>
 8021366:	f241 03f8 	movw	r3, #4344	; 0x10f8
 802136a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802136e:	681b      	ldr	r3, [r3, #0]
 8021370:	4618      	mov	r0, r3
 8021372:	f04f 0100 	mov.w	r1, #0
 8021376:	f04f 0200 	mov.w	r2, #0
 802137a:	f04f 0300 	mov.w	r3, #0
 802137e:	f7f8 fe23 	bl	8019fc8 <xQueueGenericSend>
	vSemaphoreCreateBinary(semUserButton);
 8021382:	f04f 0001 	mov.w	r0, #1
 8021386:	f04f 0100 	mov.w	r1, #0
 802138a:	f7f8 fd69 	bl	8019e60 <xQueueCreate>
 802138e:	4602      	mov	r2, r0
 8021390:	f241 03f4 	movw	r3, #4340	; 0x10f4
 8021394:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021398:	601a      	str	r2, [r3, #0]
 802139a:	f241 03f4 	movw	r3, #4340	; 0x10f4
 802139e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80213a2:	681b      	ldr	r3, [r3, #0]
 80213a4:	2b00      	cmp	r3, #0
 80213a6:	d00d      	beq.n	80213c4 <_ZN12CFileHandler12HardwareInitEv+0x8c>
 80213a8:	f241 03f4 	movw	r3, #4340	; 0x10f4
 80213ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80213b0:	681b      	ldr	r3, [r3, #0]
 80213b2:	4618      	mov	r0, r3
 80213b4:	f04f 0100 	mov.w	r1, #0
 80213b8:	f04f 0200 	mov.w	r2, #0
 80213bc:	f04f 0300 	mov.w	r3, #0
 80213c0:	f7f8 fe02 	bl	8019fc8 <xQueueGenericSend>
	// ensure that the semaphores are taken
	xSemaphoreTake(semShock,0);
 80213c4:	f241 03f8 	movw	r3, #4344	; 0x10f8
 80213c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80213cc:	681b      	ldr	r3, [r3, #0]
 80213ce:	4618      	mov	r0, r3
 80213d0:	f04f 0100 	mov.w	r1, #0
 80213d4:	f04f 0200 	mov.w	r2, #0
 80213d8:	f04f 0300 	mov.w	r3, #0
 80213dc:	f7f8 fece 	bl	801a17c <xQueueGenericReceive>
	xSemaphoreTake(semUserButton,0);
 80213e0:	f241 03f4 	movw	r3, #4340	; 0x10f4
 80213e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80213e8:	681b      	ldr	r3, [r3, #0]
 80213ea:	4618      	mov	r0, r3
 80213ec:	f04f 0100 	mov.w	r1, #0
 80213f0:	f04f 0200 	mov.w	r2, #0
 80213f4:	f04f 0300 	mov.w	r3, #0
 80213f8:	f7f8 fec0 	bl	801a17c <xQueueGenericReceive>
	/*
	 * configure Interrupt for UserButton
	 */
	//EXTILine_Config();

	hMP3Decoder = MP3InitDecoder();
 80213fc:	f7f6 fb8e 	bl	8017b1c <MP3InitDecoder>
 8021400:	4602      	mov	r2, r0
 8021402:	687b      	ldr	r3, [r7, #4]
 8021404:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
	/*
	 * first Codec init with standard samplerate
	 */
	EVAL_AUDIO_Init(OUTPUT_DEVICE_AUTO,uiVolume,uiLastSamplerate);
 8021408:	687b      	ldr	r3, [r7, #4]
 802140a:	f893 22a0 	ldrb.w	r2, [r3, #672]	; 0x2a0
 802140e:	687b      	ldr	r3, [r7, #4]
 8021410:	f8b3 3298 	ldrh.w	r3, [r3, #664]	; 0x298
 8021414:	f04f 0004 	mov.w	r0, #4
 8021418:	4611      	mov	r1, r2
 802141a:	461a      	mov	r2, r3
 802141c:	f7ec fb78 	bl	800db10 <EVAL_AUDIO_Init>

	return true;
 8021420:	f04f 0301 	mov.w	r3, #1
}
 8021424:	4618      	mov	r0, r3
 8021426:	f107 0708 	add.w	r7, r7, #8
 802142a:	46bd      	mov	sp, r7
 802142c:	bd80      	pop	{r7, pc}
 802142e:	bf00      	nop

08021430 <_ZN12CFileHandler3RunEv>:
/**
  * @brief  task function for file handling
  * @param  None
  * @retval None
  */
void CFileHandler::Run(){
 8021430:	b580      	push	{r7, lr}
 8021432:	b082      	sub	sp, #8
 8021434:	af00      	add	r7, sp, #0
 8021436:	6078      	str	r0, [r7, #4]
	vSemaphoreCreateBinary(semI2SDMAFinished);
 8021438:	f04f 0001 	mov.w	r0, #1
 802143c:	f04f 0100 	mov.w	r1, #0
 8021440:	f7f8 fd0e 	bl	8019e60 <xQueueCreate>
 8021444:	4602      	mov	r2, r0
 8021446:	f241 03f0 	movw	r3, #4336	; 0x10f0
 802144a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802144e:	601a      	str	r2, [r3, #0]
 8021450:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8021454:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021458:	681b      	ldr	r3, [r3, #0]
 802145a:	2b00      	cmp	r3, #0
 802145c:	d00d      	beq.n	802147a <_ZN12CFileHandler3RunEv+0x4a>
 802145e:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8021462:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021466:	681b      	ldr	r3, [r3, #0]
 8021468:	4618      	mov	r0, r3
 802146a:	f04f 0100 	mov.w	r1, #0
 802146e:	f04f 0200 	mov.w	r2, #0
 8021472:	f04f 0300 	mov.w	r3, #0
 8021476:	f7f8 fda7 	bl	8019fc8 <xQueueGenericSend>

	/*
	 * Read configuration from file on startup
	 */
	ReadConfig();
 802147a:	6878      	ldr	r0, [r7, #4]
 802147c:	f000 f872 	bl	8021564 <_ZN12CFileHandler10ReadConfigEv>

	/*
	 * start mp3 player, will not leave this function
	 */
	MP3Player();
 8021480:	6878      	ldr	r0, [r7, #4]
 8021482:	f000 f883 	bl	802158c <_ZN12CFileHandler9MP3PlayerEv>

}
 8021486:	f107 0708 	add.w	r7, r7, #8
 802148a:	46bd      	mov	sp, r7
 802148c:	bd80      	pop	{r7, pc}
 802148e:	bf00      	nop

08021490 <_ZN12CFileHandler12RefillBufferEv>:
/**
  * @brief  Refills the Decoder Buffer
  *
  * @retval true for success and false for fault
  */
bool CFileHandler::RefillBuffer(void){
 8021490:	b580      	push	{r7, lr}
 8021492:	b084      	sub	sp, #16
 8021494:	af00      	add	r7, sp, #0
 8021496:	6078      	str	r0, [r7, #4]
	UINT uiBytesToRead=0;
 8021498:	f04f 0300 	mov.w	r3, #0
 802149c:	60fb      	str	r3, [r7, #12]
	UINT uiBytesRead=0;
 802149e:	f04f 0300 	mov.w	r3, #0
 80214a2:	60bb      	str	r3, [r7, #8]

	if(uiBytesLeft > 0) {
 80214a4:	687b      	ldr	r3, [r7, #4]
 80214a6:	f8b3 329a 	ldrh.w	r3, [r3, #666]	; 0x29a
 80214aa:	2b00      	cmp	r3, #0
 80214ac:	d01b      	beq.n	80214e6 <_ZN12CFileHandler12RefillBufferEv+0x56>
		//
		// Fat reading with offset is too slow
		// memmove is faster
		//
		// enshure there is no overlap
		if(uiBytesLeft > READBUF_THRESHOLD )
 80214ae:	687b      	ldr	r3, [r7, #4]
 80214b0:	f8b3 229a 	ldrh.w	r2, [r3, #666]	; 0x29a
 80214b4:	f240 33c9 	movw	r3, #969	; 0x3c9
 80214b8:	429a      	cmp	r2, r3
 80214ba:	d902      	bls.n	80214c2 <_ZN12CFileHandler12RefillBufferEv+0x32>
			return false; // illegal call of RefillBuffer
 80214bc:	f04f 0300 	mov.w	r3, #0
 80214c0:	e04a      	b.n	8021558 <_ZN12CFileHandler12RefillBufferEv+0xc8>

		portENTER_CRITICAL();	// prevent RTOS from scheduling
 80214c2:	f7f8 fb73 	bl	8019bac <vPortEnterCritical>
		memmove(uiReadBuffer,ptrReadPosition,uiBytesLeft);
 80214c6:	687b      	ldr	r3, [r7, #4]
 80214c8:	f8d3 229c 	ldr.w	r2, [r3, #668]	; 0x29c
 80214cc:	687b      	ldr	r3, [r7, #4]
 80214ce:	f8b3 329a 	ldrh.w	r3, [r3, #666]	; 0x29a
 80214d2:	f241 00fc 	movw	r0, #4348	; 0x10fc
 80214d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80214da:	4611      	mov	r1, r2
 80214dc:	461a      	mov	r2, r3
 80214de:	f003 ff5d 	bl	802539c <memmove>
		portEXIT_CRITICAL();
 80214e2:	f7f8 fb79 	bl	8019bd8 <vPortExitCritical>
	}

	uiBytesToRead = READBUF_SIZE - uiBytesLeft;
 80214e6:	687b      	ldr	r3, [r7, #4]
 80214e8:	f8b3 329a 	ldrh.w	r3, [r3, #666]	; 0x29a
 80214ec:	f5c3 63f2 	rsb	r3, r3, #1936	; 0x790
 80214f0:	f103 0304 	add.w	r3, r3, #4
 80214f4:	60fb      	str	r3, [r7, #12]

	fsresult = f_read(&file,uiReadBuffer+uiBytesLeft,uiBytesToRead,&uiBytesRead);
 80214f6:	687b      	ldr	r3, [r7, #4]
 80214f8:	f103 0110 	add.w	r1, r3, #16
 80214fc:	687b      	ldr	r3, [r7, #4]
 80214fe:	f8b3 329a 	ldrh.w	r3, [r3, #666]	; 0x29a
 8021502:	461a      	mov	r2, r3
 8021504:	f241 03fc 	movw	r3, #4348	; 0x10fc
 8021508:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802150c:	18d2      	adds	r2, r2, r3
 802150e:	f107 0308 	add.w	r3, r7, #8
 8021512:	4608      	mov	r0, r1
 8021514:	4611      	mov	r1, r2
 8021516:	68fa      	ldr	r2, [r7, #12]
 8021518:	f7fd fb58 	bl	801ebcc <f_read>
 802151c:	4603      	mov	r3, r0
 802151e:	461a      	mov	r2, r3
 8021520:	687b      	ldr	r3, [r7, #4]
 8021522:	731a      	strb	r2, [r3, #12]
	if(fsresult != FR_OK)
 8021524:	687b      	ldr	r3, [r7, #4]
 8021526:	7b1b      	ldrb	r3, [r3, #12]
 8021528:	2b00      	cmp	r3, #0
 802152a:	d002      	beq.n	8021532 <_ZN12CFileHandler12RefillBufferEv+0xa2>
		return false; // Readerror
 802152c:	f04f 0300 	mov.w	r3, #0
 8021530:	e012      	b.n	8021558 <_ZN12CFileHandler12RefillBufferEv+0xc8>

	uiBytesLeft += uiBytesRead; // add newly read bytes
 8021532:	687b      	ldr	r3, [r7, #4]
 8021534:	f8b3 229a 	ldrh.w	r2, [r3, #666]	; 0x29a
 8021538:	68bb      	ldr	r3, [r7, #8]
 802153a:	b29b      	uxth	r3, r3
 802153c:	18d3      	adds	r3, r2, r3
 802153e:	b29a      	uxth	r2, r3
 8021540:	687b      	ldr	r3, [r7, #4]
 8021542:	f8a3 229a 	strh.w	r2, [r3, #666]	; 0x29a
	ptrReadPosition = uiReadBuffer; // set read position to beginning of buffer
 8021546:	687a      	ldr	r2, [r7, #4]
 8021548:	f241 03fc 	movw	r3, #4348	; 0x10fc
 802154c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021550:	f8c2 329c 	str.w	r3, [r2, #668]	; 0x29c

	return true;
 8021554:	f04f 0301 	mov.w	r3, #1
}
 8021558:	4618      	mov	r0, r3
 802155a:	f107 0710 	add.w	r7, r7, #16
 802155e:	46bd      	mov	sp, r7
 8021560:	bd80      	pop	{r7, pc}
 8021562:	bf00      	nop

08021564 <_ZN12CFileHandler10ReadConfigEv>:

/**
  * @brief  reads configuration from filesystem
  *
  */
void CFileHandler::ReadConfig(){
 8021564:	b480      	push	{r7}
 8021566:	b083      	sub	sp, #12
 8021568:	af00      	add	r7, sp, #0
 802156a:	6078      	str	r0, [r7, #4]

}
 802156c:	f107 070c 	add.w	r7, r7, #12
 8021570:	46bd      	mov	sp, r7
 8021572:	bc80      	pop	{r7}
 8021574:	4770      	bx	lr
 8021576:	bf00      	nop

08021578 <_ZN12CFileHandler11WriteConfigEv>:

/**
  * @brief  writes configuration to filesystem
  *
  */
void CFileHandler::WriteConfig(){
 8021578:	b480      	push	{r7}
 802157a:	b083      	sub	sp, #12
 802157c:	af00      	add	r7, sp, #0
 802157e:	6078      	str	r0, [r7, #4]
}
 8021580:	f107 070c 	add.w	r7, r7, #12
 8021584:	46bd      	mov	sp, r7
 8021586:	bc80      	pop	{r7}
 8021588:	4770      	bx	lr
 802158a:	bf00      	nop

0802158c <_ZN12CFileHandler9MP3PlayerEv>:

/**
  * @brief  MP3 player application
  * 		Playes MP3 from he whole device
  */
void CFileHandler::MP3Player(){
 802158c:	b580      	push	{r7, lr}
 802158e:	b084      	sub	sp, #16
 8021590:	af00      	add	r7, sp, #0
 8021592:	6078      	str	r0, [r7, #4]
	int i;
	bool bFileIsMP3 = false;
 8021594:	f04f 0300 	mov.w	r3, #0
 8021598:	72fb      	strb	r3, [r7, #11]

	// get release from USB stack
	GetUSBRelease(portMAX_DELAY);
 802159a:	6878      	ldr	r0, [r7, #4]
 802159c:	f04f 31ff 	mov.w	r1, #4294967295
 80215a0:	f000 f97a 	bl	8021898 <_ZN12CFileHandler13GetUSBReleaseEm>

	//operate files only when device connected
	while(GetUSBConnected()){
 80215a4:	e16a      	b.n	802187c <_ZN12CFileHandler9MP3PlayerEv+0x2f0>

		switch(ePlayerState){
 80215a6:	687b      	ldr	r3, [r7, #4]
 80215a8:	f893 3292 	ldrb.w	r3, [r3, #658]	; 0x292
 80215ac:	2b03      	cmp	r3, #3
 80215ae:	f200 8150 	bhi.w	8021852 <_ZN12CFileHandler9MP3PlayerEv+0x2c6>
 80215b2:	a201      	add	r2, pc, #4	; (adr r2, 80215b8 <_ZN12CFileHandler9MP3PlayerEv+0x2c>)
 80215b4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80215b8:	080215c9 	.word	0x080215c9
 80215bc:	08021627 	.word	0x08021627
 80215c0:	080217cb 	.word	0x080217cb
 80215c4:	08021813 	.word	0x08021813
/*------------------------------------------------------------------------------*/
		case OPEN_DIR:

			/* Open the directory */
			fsresult = f_opendir(&dir, path);
 80215c8:	687b      	ldr	r3, [r7, #4]
 80215ca:	f503 720d 	add.w	r2, r3, #564	; 0x234
 80215ce:	687b      	ldr	r3, [r7, #4]
 80215d0:	f503 731a 	add.w	r3, r3, #616	; 0x268
 80215d4:	4610      	mov	r0, r2
 80215d6:	4619      	mov	r1, r3
 80215d8:	f7fe f940 	bl	801f85c <f_opendir>
 80215dc:	4603      	mov	r3, r0
 80215de:	461a      	mov	r2, r3
 80215e0:	687b      	ldr	r3, [r7, #4]
 80215e2:	731a      	strb	r2, [r3, #12]
			if (fsresult == FR_OK) {
 80215e4:	687b      	ldr	r3, [r7, #4]
 80215e6:	7b1b      	ldrb	r3, [r3, #12]
 80215e8:	2b00      	cmp	r3, #0
 80215ea:	f040 813e 	bne.w	802186a <_ZN12CFileHandler9MP3PlayerEv+0x2de>
				/* get new file on success */
				ePlayerStatePrev = ePlayerState;
 80215ee:	687b      	ldr	r3, [r7, #4]
 80215f0:	f893 2292 	ldrb.w	r2, [r3, #658]	; 0x292
 80215f4:	687b      	ldr	r3, [r7, #4]
 80215f6:	f883 2293 	strb.w	r2, [r3, #659]	; 0x293
				ePlayerState = GET_FILE;
 80215fa:	687b      	ldr	r3, [r7, #4]
 80215fc:	f04f 0201 	mov.w	r2, #1
 8021600:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292

				if(bStop){
 8021604:	687b      	ldr	r3, [r7, #4]
 8021606:	f893 3297 	ldrb.w	r3, [r3, #663]	; 0x297
 802160a:	2b00      	cmp	r3, #0
 802160c:	f000 812d 	beq.w	802186a <_ZN12CFileHandler9MP3PlayerEv+0x2de>
					ePlayerState = STOP;
 8021610:	687b      	ldr	r3, [r7, #4]
 8021612:	f04f 0203 	mov.w	r2, #3
 8021616:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292
					bStop = false;
 802161a:	687b      	ldr	r3, [r7, #4]
 802161c:	f04f 0200 	mov.w	r2, #0
 8021620:	f883 2297 	strb.w	r2, [r3, #663]	; 0x297
				}
			}
			break;
 8021624:	e121      	b.n	802186a <_ZN12CFileHandler9MP3PlayerEv+0x2de>
/*------------------------------------------------------------------------------*/
		case GET_FILE:
			/* Read a directory item */
			fsresult = f_readdir(&dir, &fileInfo);
 8021626:	687b      	ldr	r3, [r7, #4]
 8021628:	f503 720d 	add.w	r2, r3, #564	; 0x234
 802162c:	687b      	ldr	r3, [r7, #4]
 802162e:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8021632:	4610      	mov	r0, r2
 8021634:	4619      	mov	r1, r3
 8021636:	f7fe f97f 	bl	801f938 <f_readdir>
 802163a:	4603      	mov	r3, r0
 802163c:	461a      	mov	r2, r3
 802163e:	687b      	ldr	r3, [r7, #4]
 8021640:	731a      	strb	r2, [r3, #12]
			if (fsresult != FR_OK || fileInfo.fname[0] == 0){
 8021642:	687b      	ldr	r3, [r7, #4]
 8021644:	7b1b      	ldrb	r3, [r3, #12]
 8021646:	2b00      	cmp	r3, #0
 8021648:	f040 8111 	bne.w	802186e <_ZN12CFileHandler9MP3PlayerEv+0x2e2>
 802164c:	687b      	ldr	r3, [r7, #4]
 802164e:	f893 3259 	ldrb.w	r3, [r3, #601]	; 0x259
 8021652:	2b00      	cmp	r3, #0
 8021654:	f000 810b 	beq.w	802186e <_ZN12CFileHandler9MP3PlayerEv+0x2e2>
				break;  /* Break on error or end of dir */
			}
			if (fileInfo.fname[0] == '.'){
 8021658:	687b      	ldr	r3, [r7, #4]
 802165a:	f893 3259 	ldrb.w	r3, [r3, #601]	; 0x259
 802165e:	2b2e      	cmp	r3, #46	; 0x2e
 8021660:	f000 8107 	beq.w	8021872 <_ZN12CFileHandler9MP3PlayerEv+0x2e6>
				continue;             /* Ignore dot entry */
			}
			if (fileInfo.fattrib & AM_DIR) {
 8021664:	687b      	ldr	r3, [r7, #4]
 8021666:	f893 3258 	ldrb.w	r3, [r3, #600]	; 0x258
 802166a:	f003 0310 	and.w	r3, r3, #16
 802166e:	2b00      	cmp	r3, #0
 8021670:	d036      	beq.n	80216e0 <_ZN12CFileHandler9MP3PlayerEv+0x154>
				/* It is a directory */
				/* copy dir Path in Path var */
				strcpy(path,fileInfo.fname);
 8021672:	687b      	ldr	r3, [r7, #4]
 8021674:	f503 721a 	add.w	r2, r3, #616	; 0x268
 8021678:	687b      	ldr	r3, [r7, #4]
 802167a:	f503 7316 	add.w	r3, r3, #600	; 0x258
 802167e:	f103 0301 	add.w	r3, r3, #1
 8021682:	4610      	mov	r0, r2
 8021684:	4619      	mov	r1, r3
 8021686:	f004 fc91 	bl	8025fac <strcpy>
				/* open the new Folder */
				ePlayerStatePrev = ePlayerState;
 802168a:	687b      	ldr	r3, [r7, #4]
 802168c:	f893 2292 	ldrb.w	r2, [r3, #658]	; 0x292
 8021690:	687b      	ldr	r3, [r7, #4]
 8021692:	f883 2293 	strb.w	r2, [r3, #659]	; 0x293
				ePlayerState = OPEN_DIR;
 8021696:	687b      	ldr	r3, [r7, #4]
 8021698:	f04f 0200 	mov.w	r2, #0
 802169c:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292

				/* get next file on next flag */
				if(bNext) {
 80216a0:	687b      	ldr	r3, [r7, #4]
 80216a2:	f893 3296 	ldrb.w	r3, [r3, #662]	; 0x296
 80216a6:	2b00      	cmp	r3, #0
 80216a8:	d009      	beq.n	80216be <_ZN12CFileHandler9MP3PlayerEv+0x132>
					ePlayerState = GET_FILE;
 80216aa:	687b      	ldr	r3, [r7, #4]
 80216ac:	f04f 0201 	mov.w	r2, #1
 80216b0:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292
					bNext = false;
 80216b4:	687b      	ldr	r3, [r7, #4]
 80216b6:	f04f 0200 	mov.w	r2, #0
 80216ba:	f883 2296 	strb.w	r2, [r3, #662]	; 0x296
				}

				if(bStop){
 80216be:	687b      	ldr	r3, [r7, #4]
 80216c0:	f893 3297 	ldrb.w	r3, [r3, #663]	; 0x297
 80216c4:	2b00      	cmp	r3, #0
 80216c6:	f000 80d6 	beq.w	8021876 <_ZN12CFileHandler9MP3PlayerEv+0x2ea>
					ePlayerState = STOP;
 80216ca:	687b      	ldr	r3, [r7, #4]
 80216cc:	f04f 0203 	mov.w	r2, #3
 80216d0:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292
					bStop = false;
 80216d4:	687b      	ldr	r3, [r7, #4]
 80216d6:	f04f 0200 	mov.w	r2, #0
 80216da:	f883 2297 	strb.w	r2, [r3, #663]	; 0x297
					}

				}
			}

			break;
 80216de:	e0ca      	b.n	8021876 <_ZN12CFileHandler9MP3PlayerEv+0x2ea>
					ePlayerState = STOP;
					bStop = false;
				}
			} else {
				/* It is a file. */
				bFileIsMP3 = false;
 80216e0:	f04f 0300 	mov.w	r3, #0
 80216e4:	72fb      	strb	r3, [r7, #11]
				/* check filetype */
				for(i=sizeof(fileInfo.fname)-4;i>=0;i--){
 80216e6:	f04f 0309 	mov.w	r3, #9
 80216ea:	60fb      	str	r3, [r7, #12]
 80216ec:	e032      	b.n	8021754 <_ZN12CFileHandler9MP3PlayerEv+0x1c8>
					if(fileInfo.fname[i] == '.'){
 80216ee:	687a      	ldr	r2, [r7, #4]
 80216f0:	68fb      	ldr	r3, [r7, #12]
 80216f2:	18d3      	adds	r3, r2, r3
 80216f4:	f503 7316 	add.w	r3, r3, #600	; 0x258
 80216f8:	785b      	ldrb	r3, [r3, #1]
 80216fa:	2b2e      	cmp	r3, #46	; 0x2e
 80216fc:	d126      	bne.n	802174c <_ZN12CFileHandler9MP3PlayerEv+0x1c0>
						if((toupper(fileInfo.fname[i+1]) == 'M') &&
 80216fe:	68fb      	ldr	r3, [r7, #12]
 8021700:	f103 0301 	add.w	r3, r3, #1
 8021704:	687a      	ldr	r2, [r7, #4]
 8021706:	18d3      	adds	r3, r2, r3
 8021708:	f893 3259 	ldrb.w	r3, [r3, #601]	; 0x259
 802170c:	4618      	mov	r0, r3
 802170e:	f006 fe4f 	bl	80283b0 <toupper>
 8021712:	4603      	mov	r3, r0
 8021714:	2b4d      	cmp	r3, #77	; 0x4d
 8021716:	d119      	bne.n	802174c <_ZN12CFileHandler9MP3PlayerEv+0x1c0>
							(toupper(fileInfo.fname[i+2]) == 'P') &&
 8021718:	68fb      	ldr	r3, [r7, #12]
 802171a:	f103 0302 	add.w	r3, r3, #2
 802171e:	687a      	ldr	r2, [r7, #4]
 8021720:	18d3      	adds	r3, r2, r3
 8021722:	f893 3259 	ldrb.w	r3, [r3, #601]	; 0x259
 8021726:	4618      	mov	r0, r3
 8021728:	f006 fe42 	bl	80283b0 <toupper>
 802172c:	4603      	mov	r3, r0
				/* It is a file. */
				bFileIsMP3 = false;
				/* check filetype */
				for(i=sizeof(fileInfo.fname)-4;i>=0;i--){
					if(fileInfo.fname[i] == '.'){
						if((toupper(fileInfo.fname[i+1]) == 'M') &&
 802172e:	2b50      	cmp	r3, #80	; 0x50
 8021730:	d10c      	bne.n	802174c <_ZN12CFileHandler9MP3PlayerEv+0x1c0>
 8021732:	68fb      	ldr	r3, [r7, #12]
 8021734:	f103 0303 	add.w	r3, r3, #3
 8021738:	687a      	ldr	r2, [r7, #4]
							(toupper(fileInfo.fname[i+2]) == 'P') &&
							((fileInfo.fname[i+3]) == '3')){
 802173a:	18d3      	adds	r3, r2, r3
 802173c:	f893 3259 	ldrb.w	r3, [r3, #601]	; 0x259
				/* It is a file. */
				bFileIsMP3 = false;
				/* check filetype */
				for(i=sizeof(fileInfo.fname)-4;i>=0;i--){
					if(fileInfo.fname[i] == '.'){
						if((toupper(fileInfo.fname[i+1]) == 'M') &&
 8021740:	2b33      	cmp	r3, #51	; 0x33
 8021742:	d103      	bne.n	802174c <_ZN12CFileHandler9MP3PlayerEv+0x1c0>
							(toupper(fileInfo.fname[i+2]) == 'P') &&
							((fileInfo.fname[i+3]) == '3')){
							/* Fileending is .MP3, so play it */
							bFileIsMP3 = true;
 8021744:	f04f 0301 	mov.w	r3, #1
 8021748:	72fb      	strb	r3, [r7, #11]
							break;
 802174a:	e00b      	b.n	8021764 <_ZN12CFileHandler9MP3PlayerEv+0x1d8>
				}
			} else {
				/* It is a file. */
				bFileIsMP3 = false;
				/* check filetype */
				for(i=sizeof(fileInfo.fname)-4;i>=0;i--){
 802174c:	68fb      	ldr	r3, [r7, #12]
 802174e:	f103 33ff 	add.w	r3, r3, #4294967295
 8021752:	60fb      	str	r3, [r7, #12]
 8021754:	68fb      	ldr	r3, [r7, #12]
 8021756:	ea6f 0303 	mvn.w	r3, r3
 802175a:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 802175e:	b2db      	uxtb	r3, r3
 8021760:	2b00      	cmp	r3, #0
 8021762:	d1c4      	bne.n	80216ee <_ZN12CFileHandler9MP3PlayerEv+0x162>
							bFileIsMP3 = true;
							break;
						}
					}
				}
				ePlayerStatePrev = ePlayerState;
 8021764:	687b      	ldr	r3, [r7, #4]
 8021766:	f893 2292 	ldrb.w	r2, [r3, #658]	; 0x292
 802176a:	687b      	ldr	r3, [r7, #4]
 802176c:	f883 2293 	strb.w	r2, [r3, #659]	; 0x293
				/* check if its an MP3 */
				if(bFileIsMP3){
 8021770:	7afb      	ldrb	r3, [r7, #11]
 8021772:	2b00      	cmp	r3, #0
 8021774:	d014      	beq.n	80217a0 <_ZN12CFileHandler9MP3PlayerEv+0x214>
					/* play MP3 */
					ePlayerState = PLAY_FILE;
 8021776:	687b      	ldr	r3, [r7, #4]
 8021778:	f04f 0202 	mov.w	r2, #2
 802177c:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292

					/* get next file on next flag */
					if(bNext) {
 8021780:	687b      	ldr	r3, [r7, #4]
 8021782:	f893 3296 	ldrb.w	r3, [r3, #662]	; 0x296
 8021786:	2b00      	cmp	r3, #0
 8021788:	d075      	beq.n	8021876 <_ZN12CFileHandler9MP3PlayerEv+0x2ea>
						ePlayerState = GET_FILE;
 802178a:	687b      	ldr	r3, [r7, #4]
 802178c:	f04f 0201 	mov.w	r2, #1
 8021790:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292
						bNext = false;
 8021794:	687b      	ldr	r3, [r7, #4]
 8021796:	f04f 0200 	mov.w	r2, #0
 802179a:	f883 2296 	strb.w	r2, [r3, #662]	; 0x296
					}

				}
			}

			break;
 802179e:	e06a      	b.n	8021876 <_ZN12CFileHandler9MP3PlayerEv+0x2ea>
						bNext = false;
					}

				} else {
					/*get next file*/
					ePlayerState = GET_FILE;
 80217a0:	687b      	ldr	r3, [r7, #4]
 80217a2:	f04f 0201 	mov.w	r2, #1
 80217a6:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292

					if(bStop){
 80217aa:	687b      	ldr	r3, [r7, #4]
 80217ac:	f893 3297 	ldrb.w	r3, [r3, #663]	; 0x297
 80217b0:	2b00      	cmp	r3, #0
 80217b2:	d060      	beq.n	8021876 <_ZN12CFileHandler9MP3PlayerEv+0x2ea>
						ePlayerState = STOP;
 80217b4:	687b      	ldr	r3, [r7, #4]
 80217b6:	f04f 0203 	mov.w	r2, #3
 80217ba:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292
						bStop = false;
 80217be:	687b      	ldr	r3, [r7, #4]
 80217c0:	f04f 0200 	mov.w	r2, #0
 80217c4:	f883 2297 	strb.w	r2, [r3, #663]	; 0x297
					}

				}
			}

			break;
 80217c8:	e055      	b.n	8021876 <_ZN12CFileHandler9MP3PlayerEv+0x2ea>
/*------------------------------------------------------------------------------*/
		case PLAY_FILE:

			PlayMP3(fileInfo.fname);
 80217ca:	687b      	ldr	r3, [r7, #4]
 80217cc:	f503 7316 	add.w	r3, r3, #600	; 0x258
 80217d0:	f103 0301 	add.w	r3, r3, #1
 80217d4:	6878      	ldr	r0, [r7, #4]
 80217d6:	4619      	mov	r1, r3
 80217d8:	f000 f89a 	bl	8021910 <_ZN12CFileHandler7PlayMP3EPKc>

			ePlayerStatePrev = ePlayerState;
 80217dc:	687b      	ldr	r3, [r7, #4]
 80217de:	f893 2292 	ldrb.w	r2, [r3, #658]	; 0x292
 80217e2:	687b      	ldr	r3, [r7, #4]
 80217e4:	f883 2293 	strb.w	r2, [r3, #659]	; 0x293

			if(bStop){
 80217e8:	687b      	ldr	r3, [r7, #4]
 80217ea:	f893 3297 	ldrb.w	r3, [r3, #663]	; 0x297
 80217ee:	2b00      	cmp	r3, #0
 80217f0:	d009      	beq.n	8021806 <_ZN12CFileHandler9MP3PlayerEv+0x27a>
				ePlayerState = STOP;
 80217f2:	687b      	ldr	r3, [r7, #4]
 80217f4:	f04f 0203 	mov.w	r2, #3
 80217f8:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292
				bStop = false;
 80217fc:	687b      	ldr	r3, [r7, #4]
 80217fe:	f04f 0200 	mov.w	r2, #0
 8021802:	f883 2297 	strb.w	r2, [r3, #663]	; 0x297
			}

			/*get next file*/
			ePlayerState = GET_FILE;
 8021806:	687b      	ldr	r3, [r7, #4]
 8021808:	f04f 0201 	mov.w	r2, #1
 802180c:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292

			break;
 8021810:	e034      	b.n	802187c <_ZN12CFileHandler9MP3PlayerEv+0x2f0>
/*------------------------------------------------------------------------------*/
		case STOP:
			/* start playing again */
			if(bPlay){
 8021812:	687b      	ldr	r3, [r7, #4]
 8021814:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
 8021818:	2b00      	cmp	r3, #0
 802181a:	d02e      	beq.n	802187a <_ZN12CFileHandler9MP3PlayerEv+0x2ee>
				/*check for stop loop */
				if(ePlayerStatePrev == STOP)
 802181c:	687b      	ldr	r3, [r7, #4]
 802181e:	f893 3293 	ldrb.w	r3, [r3, #659]	; 0x293
 8021822:	2b03      	cmp	r3, #3
 8021824:	d104      	bne.n	8021830 <_ZN12CFileHandler9MP3PlayerEv+0x2a4>
					ePlayerStatePrev = OPEN_DIR;
 8021826:	687b      	ldr	r3, [r7, #4]
 8021828:	f04f 0200 	mov.w	r2, #0
 802182c:	f883 2293 	strb.w	r2, [r3, #659]	; 0x293
				/* go back to previous state */
				ePlayerState = ePlayerStatePrev;
 8021830:	687b      	ldr	r3, [r7, #4]
 8021832:	f893 2293 	ldrb.w	r2, [r3, #659]	; 0x293
 8021836:	687b      	ldr	r3, [r7, #4]
 8021838:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292
				ePlayerStatePrev = STOP;
 802183c:	687b      	ldr	r3, [r7, #4]
 802183e:	f04f 0203 	mov.w	r2, #3
 8021842:	f883 2293 	strb.w	r2, [r3, #659]	; 0x293
				/*clear Flag*/
				bPlay = false;
 8021846:	687b      	ldr	r3, [r7, #4]
 8021848:	f04f 0200 	mov.w	r2, #0
 802184c:	f883 2295 	strb.w	r2, [r3, #661]	; 0x295
			}
			break;
 8021850:	e013      	b.n	802187a <_ZN12CFileHandler9MP3PlayerEv+0x2ee>
/*------------------------------------------------------------------------------*/
		default:
			ePlayerStatePrev = ePlayerState;
 8021852:	687b      	ldr	r3, [r7, #4]
 8021854:	f893 2292 	ldrb.w	r2, [r3, #658]	; 0x292
 8021858:	687b      	ldr	r3, [r7, #4]
 802185a:	f883 2293 	strb.w	r2, [r3, #659]	; 0x293
			ePlayerState = OPEN_DIR;
 802185e:	687b      	ldr	r3, [r7, #4]
 8021860:	f04f 0200 	mov.w	r2, #0
 8021864:	f883 2292 	strb.w	r2, [r3, #658]	; 0x292
			break;
 8021868:	e008      	b.n	802187c <_ZN12CFileHandler9MP3PlayerEv+0x2f0>
				if(bStop){
					ePlayerState = STOP;
					bStop = false;
				}
			}
			break;
 802186a:	bf00      	nop
 802186c:	e006      	b.n	802187c <_ZN12CFileHandler9MP3PlayerEv+0x2f0>
/*------------------------------------------------------------------------------*/
		case GET_FILE:
			/* Read a directory item */
			fsresult = f_readdir(&dir, &fileInfo);
			if (fsresult != FR_OK || fileInfo.fname[0] == 0){
				break;  /* Break on error or end of dir */
 802186e:	bf00      	nop
 8021870:	e004      	b.n	802187c <_ZN12CFileHandler9MP3PlayerEv+0x2f0>
			}
			if (fileInfo.fname[0] == '.'){
				continue;             /* Ignore dot entry */
 8021872:	bf00      	nop
 8021874:	e002      	b.n	802187c <_ZN12CFileHandler9MP3PlayerEv+0x2f0>
					}

				}
			}

			break;
 8021876:	bf00      	nop
 8021878:	e000      	b.n	802187c <_ZN12CFileHandler9MP3PlayerEv+0x2f0>
				ePlayerState = ePlayerStatePrev;
				ePlayerStatePrev = STOP;
				/*clear Flag*/
				bPlay = false;
			}
			break;
 802187a:	bf00      	nop

	// get release from USB stack
	GetUSBRelease(portMAX_DELAY);

	//operate files only when device connected
	while(GetUSBConnected()){
 802187c:	6878      	ldr	r0, [r7, #4]
 802187e:	f003 f9c7 	bl	8024c10 <_ZN12CFileHandler15GetUSBConnectedEv>
 8021882:	4603      	mov	r3, r0
 8021884:	2b00      	cmp	r3, #0
 8021886:	f47f ae8e 	bne.w	80215a6 <_ZN12CFileHandler9MP3PlayerEv+0x1a>
			break;
		}
	}

	// give control back to USB stack
	ReleaseUSB();
 802188a:	6878      	ldr	r0, [r7, #4]
 802188c:	f000 f82a 	bl	80218e4 <_ZN12CFileHandler10ReleaseUSBEv>
}
 8021890:	f107 0710 	add.w	r7, r7, #16
 8021894:	46bd      	mov	sp, r7
 8021896:	bd80      	pop	{r7, pc}

08021898 <_ZN12CFileHandler13GetUSBReleaseEm>:
/**
  * @brief  gets sem from USB handling layer
  *
  * @retval true for success and false for fault
  */
bool CFileHandler::GetUSBRelease(portTickType delay){
 8021898:	b580      	push	{r7, lr}
 802189a:	b082      	sub	sp, #8
 802189c:	af00      	add	r7, sp, #0
 802189e:	6078      	str	r0, [r7, #4]
 80218a0:	6039      	str	r1, [r7, #0]
	/*
	 * get sem from USB Application layer
	 * to process without disturbing USB handling
	 */
	xSemaphoreTake(semUSBApplication,delay);
 80218a2:	f24a 3308 	movw	r3, #41736	; 0xa308
 80218a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80218aa:	681b      	ldr	r3, [r3, #0]
 80218ac:	4618      	mov	r0, r3
 80218ae:	f04f 0100 	mov.w	r1, #0
 80218b2:	683a      	ldr	r2, [r7, #0]
 80218b4:	f04f 0300 	mov.w	r3, #0
 80218b8:	f7f8 fc60 	bl	801a17c <xQueueGenericReceive>

	/*
	 * check if Device is Connected
	 */
	if(GetUSBConnected()){
 80218bc:	6878      	ldr	r0, [r7, #4]
 80218be:	f003 f9a7 	bl	8024c10 <_ZN12CFileHandler15GetUSBConnectedEv>
 80218c2:	4603      	mov	r3, r0
 80218c4:	2b00      	cmp	r3, #0
 80218c6:	d002      	beq.n	80218ce <_ZN12CFileHandler13GetUSBReleaseEm+0x36>
		return true;
 80218c8:	f04f 0301 	mov.w	r3, #1
 80218cc:	e004      	b.n	80218d8 <_ZN12CFileHandler13GetUSBReleaseEm+0x40>
	} else {
		/*
		 * Release Sem from USB
		 */
		ReleaseUSB();
 80218ce:	6878      	ldr	r0, [r7, #4]
 80218d0:	f000 f808 	bl	80218e4 <_ZN12CFileHandler10ReleaseUSBEv>
		return false;
 80218d4:	f04f 0300 	mov.w	r3, #0
	}

}
 80218d8:	4618      	mov	r0, r3
 80218da:	f107 0708 	add.w	r7, r7, #8
 80218de:	46bd      	mov	sp, r7
 80218e0:	bd80      	pop	{r7, pc}
 80218e2:	bf00      	nop

080218e4 <_ZN12CFileHandler10ReleaseUSBEv>:


/**
  * @brief  give USB sem Back to USB handling Layer
  */
void CFileHandler::ReleaseUSB(){
 80218e4:	b580      	push	{r7, lr}
 80218e6:	b082      	sub	sp, #8
 80218e8:	af00      	add	r7, sp, #0
 80218ea:	6078      	str	r0, [r7, #4]
	/*
	 * Application layer needs to give back the sem when ever possible
	 */
	xSemaphoreGive(semUSBApplication);
 80218ec:	f24a 3308 	movw	r3, #41736	; 0xa308
 80218f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80218f4:	681b      	ldr	r3, [r3, #0]
 80218f6:	4618      	mov	r0, r3
 80218f8:	f04f 0100 	mov.w	r1, #0
 80218fc:	f04f 0200 	mov.w	r2, #0
 8021900:	f04f 0300 	mov.w	r3, #0
 8021904:	f7f8 fb60 	bl	8019fc8 <xQueueGenericSend>
}
 8021908:	f107 0708 	add.w	r7, r7, #8
 802190c:	46bd      	mov	sp, r7
 802190e:	bd80      	pop	{r7, pc}

08021910 <_ZN12CFileHandler7PlayMP3EPKc>:
/**
  * @brief  plays mp3 file
  *
  * @retval true for success and false for fault
  */
bool CFileHandler::PlayMP3(const char* filename){
 8021910:	b580      	push	{r7, lr}
 8021912:	b084      	sub	sp, #16
 8021914:	af02      	add	r7, sp, #8
 8021916:	6078      	str	r0, [r7, #4]
 8021918:	6039      	str	r1, [r7, #0]
	static int offset = 0;
	static int err = 0;

	//operate files only when device connected
	while(GetUSBConnected()){
 802191a:	e1f9      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>

		/* check if file is skipped */
		if(bNext) {
 802191c:	687b      	ldr	r3, [r7, #4]
 802191e:	f893 3296 	ldrb.w	r3, [r3, #662]	; 0x296
 8021922:	2b00      	cmp	r3, #0
 8021924:	d002      	beq.n	802192c <_ZN12CFileHandler7PlayMP3EPKc+0x1c>
			/* file is to be skiped */
			return false;
 8021926:	f04f 0300 	mov.w	r3, #0
 802192a:	e1ff      	b.n	8021d2c <_ZN12CFileHandler7PlayMP3EPKc+0x41c>
		}

		switch(eMP3State){
 802192c:	687b      	ldr	r3, [r7, #4]
 802192e:	f893 3290 	ldrb.w	r3, [r3, #656]	; 0x290
 8021932:	f103 33ff 	add.w	r3, r3, #4294967295
 8021936:	2b03      	cmp	r3, #3
 8021938:	f200 81be 	bhi.w	8021cb8 <_ZN12CFileHandler7PlayMP3EPKc+0x3a8>
 802193c:	a101      	add	r1, pc, #4	; (adr r1, 8021944 <_ZN12CFileHandler7PlayMP3EPKc+0x34>)
 802193e:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8021942:	bf00      	nop
 8021944:	08021955 	.word	0x08021955
 8021948:	080219a5 	.word	0x080219a5
 802194c:	08021af9 	.word	0x08021af9
 8021950:	08021c41 	.word	0x08021c41
/*------------------------------------------------------------------------------*/
		case OPEN_FILE:

			fsresult = f_open(&file,filename,FA_OPEN_EXISTING | FA_READ);
 8021954:	687b      	ldr	r3, [r7, #4]
 8021956:	f103 0310 	add.w	r3, r3, #16
 802195a:	4618      	mov	r0, r3
 802195c:	6839      	ldr	r1, [r7, #0]
 802195e:	f04f 0201 	mov.w	r2, #1
 8021962:	f7fc ff81 	bl	801e868 <f_open>
 8021966:	4603      	mov	r3, r0
 8021968:	461a      	mov	r2, r3
 802196a:	687b      	ldr	r3, [r7, #4]
 802196c:	731a      	strb	r2, [r3, #12]
			if(fsresult != FR_OK)
 802196e:	687b      	ldr	r3, [r7, #4]
 8021970:	7b1b      	ldrb	r3, [r3, #12]
 8021972:	2b00      	cmp	r3, #0
 8021974:	f040 81c7 	bne.w	8021d06 <_ZN12CFileHandler7PlayMP3EPKc+0x3f6>
				break;

			f_sync(&file); //see app note from chan
 8021978:	687b      	ldr	r3, [r7, #4]
 802197a:	f103 0310 	add.w	r3, r3, #16
 802197e:	4618      	mov	r0, r3
 8021980:	f7fd fc68 	bl	801f254 <f_sync>

			if(!RefillBuffer()) // read data from file
 8021984:	6878      	ldr	r0, [r7, #4]
 8021986:	f7ff fd83 	bl	8021490 <_ZN12CFileHandler12RefillBufferEv>
 802198a:	4603      	mov	r3, r0
 802198c:	f083 0301 	eor.w	r3, r3, #1
 8021990:	b2db      	uxtb	r3, r3
 8021992:	2b00      	cmp	r3, #0
 8021994:	f040 81b9 	bne.w	8021d0a <_ZN12CFileHandler7PlayMP3EPKc+0x3fa>
				break;

			eMP3State = FIND_SYNC;
 8021998:	687b      	ldr	r3, [r7, #4]
 802199a:	f04f 0202 	mov.w	r2, #2
 802199e:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290

			break;
 80219a2:	e1b5      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>
/*------------------------------------------------------------------------------*/
		case FIND_SYNC:
			// search beginning of MP3 data
			offset = MP3FindSyncWord(ptrReadPosition, uiBytesLeft);
 80219a4:	687b      	ldr	r3, [r7, #4]
 80219a6:	f8d3 229c 	ldr.w	r2, [r3, #668]	; 0x29c
 80219aa:	687b      	ldr	r3, [r7, #4]
 80219ac:	f8b3 329a 	ldrh.w	r3, [r3, #666]	; 0x29a
 80219b0:	4610      	mov	r0, r2
 80219b2:	4619      	mov	r1, r3
 80219b4:	f7f6 f8d2 	bl	8017b5c <MP3FindSyncWord>
 80219b8:	4602      	mov	r2, r0
 80219ba:	f643 4390 	movw	r3, #15504	; 0x3c90
 80219be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80219c2:	601a      	str	r2, [r3, #0]
			if (offset < 0) {
 80219c4:	f643 4390 	movw	r3, #15504	; 0x3c90
 80219c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80219cc:	681b      	ldr	r3, [r3, #0]
 80219ce:	2b00      	cmp	r3, #0
 80219d0:	da08      	bge.n	80219e4 <_ZN12CFileHandler7PlayMP3EPKc+0xd4>
				// no Sync found in Buffer
				uiBytesLeft = 0; // discard all data
 80219d2:	687b      	ldr	r3, [r7, #4]
 80219d4:	f04f 0200 	mov.w	r2, #0
 80219d8:	f8a3 229a 	strh.w	r2, [r3, #666]	; 0x29a
				RefillBuffer(); // read data from file
 80219dc:	6878      	ldr	r0, [r7, #4]
 80219de:	f7ff fd57 	bl	8021490 <_ZN12CFileHandler12RefillBufferEv>
				break;
 80219e2:	e195      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>
			}
			// move read ptr to Frame position
			ptrReadPosition += offset;
 80219e4:	687b      	ldr	r3, [r7, #4]
 80219e6:	f8d3 229c 	ldr.w	r2, [r3, #668]	; 0x29c
 80219ea:	f643 4390 	movw	r3, #15504	; 0x3c90
 80219ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80219f2:	681b      	ldr	r3, [r3, #0]
 80219f4:	18d2      	adds	r2, r2, r3
 80219f6:	687b      	ldr	r3, [r7, #4]
 80219f8:	f8c3 229c 	str.w	r2, [r3, #668]	; 0x29c
			uiBytesLeft -= offset;
 80219fc:	687b      	ldr	r3, [r7, #4]
 80219fe:	f8b3 229a 	ldrh.w	r2, [r3, #666]	; 0x29a
 8021a02:	f643 4390 	movw	r3, #15504	; 0x3c90
 8021a06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021a0a:	681b      	ldr	r3, [r3, #0]
 8021a0c:	b29b      	uxth	r3, r3
 8021a0e:	1ad3      	subs	r3, r2, r3
 8021a10:	b29a      	uxth	r2, r3
 8021a12:	687b      	ldr	r3, [r7, #4]
 8021a14:	f8a3 229a 	strh.w	r2, [r3, #666]	; 0x29a

			/*
			 * ensure that the found Frame is a valid frame and
			 * not some weird ID3 tag
			 */
			err = MP3GetNextFrameInfo(hMP3Decoder,&mp3FrameInfo,ptrReadPosition);
 8021a18:	687b      	ldr	r3, [r7, #4]
 8021a1a:	f8d3 12a4 	ldr.w	r1, [r3, #676]	; 0x2a4
 8021a1e:	687b      	ldr	r3, [r7, #4]
 8021a20:	f503 722a 	add.w	r2, r3, #680	; 0x2a8
 8021a24:	687b      	ldr	r3, [r7, #4]
 8021a26:	f8d3 329c 	ldr.w	r3, [r3, #668]	; 0x29c
 8021a2a:	4608      	mov	r0, r1
 8021a2c:	4611      	mov	r1, r2
 8021a2e:	461a      	mov	r2, r3
 8021a30:	f7f6 f98e 	bl	8017d50 <MP3GetNextFrameInfo>
 8021a34:	4602      	mov	r2, r0
 8021a36:	f643 4394 	movw	r3, #15508	; 0x3c94
 8021a3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021a3e:	601a      	str	r2, [r3, #0]
			if(err == 0 && mp3FrameInfo.nChans == 2 && mp3FrameInfo.version == 0){
 8021a40:	f643 4394 	movw	r3, #15508	; 0x3c94
 8021a44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021a48:	681b      	ldr	r3, [r3, #0]
 8021a4a:	2b00      	cmp	r3, #0
 8021a4c:	d14e      	bne.n	8021aec <_ZN12CFileHandler7PlayMP3EPKc+0x1dc>
 8021a4e:	687b      	ldr	r3, [r7, #4]
 8021a50:	f8d3 32ac 	ldr.w	r3, [r3, #684]	; 0x2ac
 8021a54:	2b02      	cmp	r3, #2
 8021a56:	d149      	bne.n	8021aec <_ZN12CFileHandler7PlayMP3EPKc+0x1dc>
 8021a58:	687b      	ldr	r3, [r7, #4]
 8021a5a:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 8021a5e:	2b00      	cmp	r3, #0
 8021a60:	d144      	bne.n	8021aec <_ZN12CFileHandler7PlayMP3EPKc+0x1dc>

				if(uiLastSamplerate != mp3FrameInfo.samprate) {
 8021a62:	687b      	ldr	r3, [r7, #4]
 8021a64:	f8b3 3298 	ldrh.w	r3, [r3, #664]	; 0x298
 8021a68:	461a      	mov	r2, r3
 8021a6a:	687b      	ldr	r3, [r7, #4]
 8021a6c:	f8d3 32b0 	ldr.w	r3, [r3, #688]	; 0x2b0
 8021a70:	429a      	cmp	r2, r3
 8021a72:	d035      	beq.n	8021ae0 <_ZN12CFileHandler7PlayMP3EPKc+0x1d0>

					/*
					 * compensate clock error in i2s
					 */
					uiLastSamplerate = (mp3FrameInfo.samprate/237)*250;
 8021a74:	687b      	ldr	r3, [r7, #4]
 8021a76:	f8d3 32b0 	ldr.w	r3, [r3, #688]	; 0x2b0
 8021a7a:	f64f 0271 	movw	r2, #63601	; 0xf871
 8021a7e:	f6c8 2242 	movt	r2, #35394	; 0x8a42
 8021a82:	fb82 1203 	smull	r1, r2, r2, r3
 8021a86:	18d2      	adds	r2, r2, r3
 8021a88:	ea4f 12e2 	mov.w	r2, r2, asr #7
 8021a8c:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8021a90:	1ad3      	subs	r3, r2, r3
 8021a92:	b29b      	uxth	r3, r3
 8021a94:	461a      	mov	r2, r3
 8021a96:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8021a9a:	1ad2      	subs	r2, r2, r3
 8021a9c:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8021aa0:	18d3      	adds	r3, r2, r3
 8021aa2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8021aa6:	b29a      	uxth	r2, r3
 8021aa8:	687b      	ldr	r3, [r7, #4]
 8021aaa:	f8a3 2298 	strh.w	r2, [r3, #664]	; 0x298
					/*
					 * initialize Codec with sample freq.
					 */
					portENTER_CRITICAL();
 8021aae:	f7f8 f87d 	bl	8019bac <vPortEnterCritical>
					EVAL_AUDIO_DeInit();
 8021ab2:	f7ec f861 	bl	800db78 <EVAL_AUDIO_DeInit>
					EVAL_AUDIO_Init(OUTPUT_DEVICE_AUTO,uiVolume,uiLastSamplerate);
 8021ab6:	687b      	ldr	r3, [r7, #4]
 8021ab8:	f893 22a0 	ldrb.w	r2, [r3, #672]	; 0x2a0
 8021abc:	687b      	ldr	r3, [r7, #4]
 8021abe:	f8b3 3298 	ldrh.w	r3, [r3, #664]	; 0x298
 8021ac2:	f04f 0004 	mov.w	r0, #4
 8021ac6:	4611      	mov	r1, r2
 8021ac8:	461a      	mov	r2, r3
 8021aca:	f7ec f821 	bl	800db10 <EVAL_AUDIO_Init>
					portEXIT_CRITICAL();
 8021ace:	f7f8 f883 	bl	8019bd8 <vPortExitCritical>
					uiLastSamplerate = mp3FrameInfo.samprate;
 8021ad2:	687b      	ldr	r3, [r7, #4]
 8021ad4:	f8d3 32b0 	ldr.w	r3, [r3, #688]	; 0x2b0
 8021ad8:	b29a      	uxth	r2, r3
 8021ada:	687b      	ldr	r3, [r7, #4]
 8021adc:	f8a3 2298 	strh.w	r2, [r3, #664]	; 0x298
				}
				/*
				 * Frame is valid initialize Codec is initialized with samperate
				 * so lets go playing mp3
				 */
				eMP3State = DECODE;
 8021ae0:	687b      	ldr	r3, [r7, #4]
 8021ae2:	f04f 0203 	mov.w	r2, #3
 8021ae6:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
				 * valid frame but not compatible with the codec
				 */
				eMP3State = CLOSE_FILE;
			}

			break;
 8021aea:	e111      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>
				eMP3State = DECODE;
			}else{
				/*
				 * valid frame but not compatible with the codec
				 */
				eMP3State = CLOSE_FILE;
 8021aec:	687b      	ldr	r3, [r7, #4]
 8021aee:	f04f 0205 	mov.w	r2, #5
 8021af2:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
			}

			break;
 8021af6:	e10b      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>
/*------------------------------------------------------------------------------*/
		case DECODE:

			if(uiBytesLeft < READBUF_THRESHOLD) {
 8021af8:	687b      	ldr	r3, [r7, #4]
 8021afa:	f8b3 329a 	ldrh.w	r3, [r3, #666]	; 0x29a
 8021afe:	f5b3 7f72 	cmp.w	r3, #968	; 0x3c8
 8021b02:	d80d      	bhi.n	8021b20 <_ZN12CFileHandler7PlayMP3EPKc+0x210>
				if(!RefillBuffer()) // end of file
 8021b04:	6878      	ldr	r0, [r7, #4]
 8021b06:	f7ff fcc3 	bl	8021490 <_ZN12CFileHandler12RefillBufferEv>
 8021b0a:	4603      	mov	r3, r0
 8021b0c:	f083 0301 	eor.w	r3, r3, #1
 8021b10:	b2db      	uxtb	r3, r3
 8021b12:	2b00      	cmp	r3, #0
 8021b14:	d004      	beq.n	8021b20 <_ZN12CFileHandler7PlayMP3EPKc+0x210>
					eMP3State = CLOSE_FILE;
 8021b16:	687b      	ldr	r3, [r7, #4]
 8021b18:	f04f 0205 	mov.w	r2, #5
 8021b1c:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
			}

			if(eBuffer == BUFFER_1){
 8021b20:	687b      	ldr	r3, [r7, #4]
 8021b22:	f893 3291 	ldrb.w	r3, [r3, #657]	; 0x291
 8021b26:	2b00      	cmp	r3, #0
 8021b28:	d11d      	bne.n	8021b66 <_ZN12CFileHandler7PlayMP3EPKc+0x256>
				err = MP3Decode(hMP3Decoder,&ptrReadPosition,(int*)&uiBytesLeft,iPCMBuffer1,0);
 8021b2a:	687b      	ldr	r3, [r7, #4]
 8021b2c:	f8d3 12a4 	ldr.w	r1, [r3, #676]	; 0x2a4
 8021b30:	687b      	ldr	r3, [r7, #4]
 8021b32:	f503 7227 	add.w	r2, r3, #668	; 0x29c
 8021b36:	687b      	ldr	r3, [r7, #4]
 8021b38:	f503 7326 	add.w	r3, r3, #664	; 0x298
 8021b3c:	f103 0302 	add.w	r3, r3, #2
 8021b40:	f04f 0000 	mov.w	r0, #0
 8021b44:	9000      	str	r0, [sp, #0]
 8021b46:	4608      	mov	r0, r1
 8021b48:	4611      	mov	r1, r2
 8021b4a:	461a      	mov	r2, r3
 8021b4c:	f641 0390 	movw	r3, #6288	; 0x1890
 8021b50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021b54:	f7f6 f956 	bl	8017e04 <MP3Decode>
 8021b58:	4602      	mov	r2, r0
 8021b5a:	f643 4394 	movw	r3, #15508	; 0x3c94
 8021b5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021b62:	601a      	str	r2, [r3, #0]
 8021b64:	e01c      	b.n	8021ba0 <_ZN12CFileHandler7PlayMP3EPKc+0x290>
			}else{
				err = MP3Decode(hMP3Decoder,&ptrReadPosition,(int*)&uiBytesLeft,iPCMBuffer2,0);
 8021b66:	687b      	ldr	r3, [r7, #4]
 8021b68:	f8d3 12a4 	ldr.w	r1, [r3, #676]	; 0x2a4
 8021b6c:	687b      	ldr	r3, [r7, #4]
 8021b6e:	f503 7227 	add.w	r2, r3, #668	; 0x29c
 8021b72:	687b      	ldr	r3, [r7, #4]
 8021b74:	f503 7326 	add.w	r3, r3, #664	; 0x298
 8021b78:	f103 0302 	add.w	r3, r3, #2
 8021b7c:	f04f 0000 	mov.w	r0, #0
 8021b80:	9000      	str	r0, [sp, #0]
 8021b82:	4608      	mov	r0, r1
 8021b84:	4611      	mov	r1, r2
 8021b86:	461a      	mov	r2, r3
 8021b88:	f642 2390 	movw	r3, #10896	; 0x2a90
 8021b8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021b90:	f7f6 f938 	bl	8017e04 <MP3Decode>
 8021b94:	4602      	mov	r2, r0
 8021b96:	f643 4394 	movw	r3, #15508	; 0x3c94
 8021b9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021b9e:	601a      	str	r2, [r3, #0]
			}

			if (err)
 8021ba0:	f643 4394 	movw	r3, #15508	; 0x3c94
 8021ba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021ba8:	681b      	ldr	r3, [r3, #0]
 8021baa:	2b00      	cmp	r3, #0
 8021bac:	d042      	beq.n	8021c34 <_ZN12CFileHandler7PlayMP3EPKc+0x324>
			{
				/* error occurred */
				switch (err)
 8021bae:	f643 4394 	movw	r3, #15508	; 0x3c94
 8021bb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021bb6:	681b      	ldr	r3, [r3, #0]
 8021bb8:	f103 0306 	add.w	r3, r3, #6
 8021bbc:	2b05      	cmp	r3, #5
 8021bbe:	d830      	bhi.n	8021c22 <_ZN12CFileHandler7PlayMP3EPKc+0x312>
 8021bc0:	a201      	add	r2, pc, #4	; (adr r2, 8021bc8 <_ZN12CFileHandler7PlayMP3EPKc+0x2b8>)
 8021bc2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021bc6:	bf00      	nop
 8021bc8:	08021c17 	.word	0x08021c17
 8021bcc:	08021c23 	.word	0x08021c23
 8021bd0:	08021c23 	.word	0x08021c23
 8021bd4:	08021c0b 	.word	0x08021c0b
 8021bd8:	08021bff 	.word	0x08021bff
 8021bdc:	08021be1 	.word	0x08021be1
				{
				case ERR_MP3_INDATA_UNDERFLOW:
					if(!RefillBuffer()){ // end of file
 8021be0:	6878      	ldr	r0, [r7, #4]
 8021be2:	f7ff fc55 	bl	8021490 <_ZN12CFileHandler12RefillBufferEv>
 8021be6:	4603      	mov	r3, r0
 8021be8:	f083 0301 	eor.w	r3, r3, #1
 8021bec:	b2db      	uxtb	r3, r3
 8021bee:	2b00      	cmp	r3, #0
 8021bf0:	d01e      	beq.n	8021c30 <_ZN12CFileHandler7PlayMP3EPKc+0x320>
						eMP3State = CLOSE_FILE;
 8021bf2:	687b      	ldr	r3, [r7, #4]
 8021bf4:	f04f 0205 	mov.w	r2, #5
 8021bf8:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
					}
					break;
 8021bfc:	e018      	b.n	8021c30 <_ZN12CFileHandler7PlayMP3EPKc+0x320>
				case ERR_MP3_MAINDATA_UNDERFLOW:
					eMP3State = DECODE; // more data needed
 8021bfe:	687b      	ldr	r3, [r7, #4]
 8021c00:	f04f 0203 	mov.w	r2, #3
 8021c04:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
					break;
 8021c08:	e013      	b.n	8021c32 <_ZN12CFileHandler7PlayMP3EPKc+0x322>
				case ERR_MP3_FREE_BITRATE_SYNC:
					eMP3State = CLOSE_FILE;
 8021c0a:	687b      	ldr	r3, [r7, #4]
 8021c0c:	f04f 0205 	mov.w	r2, #5
 8021c10:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
					break;
 8021c14:	e00d      	b.n	8021c32 <_ZN12CFileHandler7PlayMP3EPKc+0x322>
				case ERR_MP3_INVALID_FRAMEHEADER:
					eMP3State = FIND_SYNC;
 8021c16:	687b      	ldr	r3, [r7, #4]
 8021c18:	f04f 0202 	mov.w	r2, #2
 8021c1c:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
					break;
 8021c20:	e007      	b.n	8021c32 <_ZN12CFileHandler7PlayMP3EPKc+0x322>
				default:
					eMP3State = CLOSE_FILE;
 8021c22:	687b      	ldr	r3, [r7, #4]
 8021c24:	f04f 0205 	mov.w	r2, #5
 8021c28:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
					break;
 8021c2c:	bf00      	nop
				}
			} else {
				eMP3State = PLAYBACK;
			}

			break;
 8021c2e:	e06f      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>
				{
				case ERR_MP3_INDATA_UNDERFLOW:
					if(!RefillBuffer()){ // end of file
						eMP3State = CLOSE_FILE;
					}
					break;
 8021c30:	bf00      	nop
				}
			} else {
				eMP3State = PLAYBACK;
			}

			break;
 8021c32:	e06d      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>
				default:
					eMP3State = CLOSE_FILE;
					break;
				}
			} else {
				eMP3State = PLAYBACK;
 8021c34:	687b      	ldr	r3, [r7, #4]
 8021c36:	f04f 0204 	mov.w	r2, #4
 8021c3a:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
			}

			break;
 8021c3e:	e067      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>

/*------------------------------------------------------------------------------*/
		case PLAYBACK:
			if(xSemaphoreTake(semI2SDMAFinished , portMAX_DELAY ) == pdTRUE){
 8021c40:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8021c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021c48:	681b      	ldr	r3, [r3, #0]
 8021c4a:	4618      	mov	r0, r3
 8021c4c:	f04f 0100 	mov.w	r1, #0
 8021c50:	f04f 32ff 	mov.w	r2, #4294967295
 8021c54:	f04f 0300 	mov.w	r3, #0
 8021c58:	f7f8 fa90 	bl	801a17c <xQueueGenericReceive>
 8021c5c:	4603      	mov	r3, r0
 8021c5e:	2b01      	cmp	r3, #1
 8021c60:	bf14      	ite	ne
 8021c62:	2300      	movne	r3, #0
 8021c64:	2301      	moveq	r3, #1
 8021c66:	b2db      	uxtb	r3, r3
 8021c68:	2b00      	cmp	r3, #0
 8021c6a:	d050      	beq.n	8021d0e <_ZN12CFileHandler7PlayMP3EPKc+0x3fe>
				/*
				 * start playing the samples
				 */
				if(eBuffer == BUFFER_1) {
 8021c6c:	687b      	ldr	r3, [r7, #4]
 8021c6e:	f893 3291 	ldrb.w	r3, [r3, #657]	; 0x291
 8021c72:	2b00      	cmp	r3, #0
 8021c74:	d10d      	bne.n	8021c92 <_ZN12CFileHandler7PlayMP3EPKc+0x382>
					EVAL_AUDIO_Play(iPCMBuffer1,sizeof(iPCMBuffer1));
 8021c76:	f641 0090 	movw	r0, #6288	; 0x1890
 8021c7a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8021c7e:	f44f 5190 	mov.w	r1, #4608	; 0x1200
 8021c82:	f7eb ff83 	bl	800db8c <EVAL_AUDIO_Play>
					eBuffer = BUFFER_2;
 8021c86:	687b      	ldr	r3, [r7, #4]
 8021c88:	f04f 0201 	mov.w	r2, #1
 8021c8c:	f883 2291 	strb.w	r2, [r3, #657]	; 0x291
 8021c90:	e00c      	b.n	8021cac <_ZN12CFileHandler7PlayMP3EPKc+0x39c>
				}else{
					EVAL_AUDIO_Play(iPCMBuffer2,sizeof(iPCMBuffer2));
 8021c92:	f642 2090 	movw	r0, #10896	; 0x2a90
 8021c96:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8021c9a:	f44f 5190 	mov.w	r1, #4608	; 0x1200
 8021c9e:	f7eb ff75 	bl	800db8c <EVAL_AUDIO_Play>
					eBuffer = BUFFER_1; //switch Buffers
 8021ca2:	687b      	ldr	r3, [r7, #4]
 8021ca4:	f04f 0200 	mov.w	r2, #0
 8021ca8:	f883 2291 	strb.w	r2, [r3, #657]	; 0x291
				}
				eMP3State = DECODE;
 8021cac:	687b      	ldr	r3, [r7, #4]
 8021cae:	f04f 0203 	mov.w	r2, #3
 8021cb2:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
			}

			break;
 8021cb6:	e02a      	b.n	8021d0e <_ZN12CFileHandler7PlayMP3EPKc+0x3fe>

		default:
			// stop I2S to prevent noise
			EVAL_AUDIO_Stop(CODEC_PDWN_SW);
 8021cb8:	f04f 0002 	mov.w	r0, #2
 8021cbc:	f7eb ffbe 	bl	800dc3c <EVAL_AUDIO_Stop>
			fsresult = FR_OK;
 8021cc0:	687b      	ldr	r3, [r7, #4]
 8021cc2:	f04f 0200 	mov.w	r2, #0
 8021cc6:	731a      	strb	r2, [r3, #12]
			uiBytesLeft = 0;
 8021cc8:	687b      	ldr	r3, [r7, #4]
 8021cca:	f04f 0200 	mov.w	r2, #0
 8021cce:	f8a3 229a 	strh.w	r2, [r3, #666]	; 0x29a
			ptrReadPosition = uiReadBuffer;
 8021cd2:	687a      	ldr	r2, [r7, #4]
 8021cd4:	f241 03fc 	movw	r3, #4348	; 0x10fc
 8021cd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021cdc:	f8c2 329c 	str.w	r3, [r2, #668]	; 0x29c
			eBuffer = BUFFER_1;
 8021ce0:	687b      	ldr	r3, [r7, #4]
 8021ce2:	f04f 0200 	mov.w	r2, #0
 8021ce6:	f883 2291 	strb.w	r2, [r3, #657]	; 0x291
			/*
			 * Close-File State not implemented,
			 * all unknown states result in file close
			 */
			f_close(&file);
 8021cea:	687b      	ldr	r3, [r7, #4]
 8021cec:	f103 0310 	add.w	r3, r3, #16
 8021cf0:	4618      	mov	r0, r3
 8021cf2:	f7fd fb8f 	bl	801f414 <f_close>
			eMP3State = OPEN_FILE;
 8021cf6:	687b      	ldr	r3, [r7, #4]
 8021cf8:	f04f 0201 	mov.w	r2, #1
 8021cfc:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
			return true;
 8021d00:	f04f 0301 	mov.w	r3, #1
 8021d04:	e012      	b.n	8021d2c <_ZN12CFileHandler7PlayMP3EPKc+0x41c>
/*------------------------------------------------------------------------------*/
		case OPEN_FILE:

			fsresult = f_open(&file,filename,FA_OPEN_EXISTING | FA_READ);
			if(fsresult != FR_OK)
				break;
 8021d06:	bf00      	nop
 8021d08:	e002      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>

			f_sync(&file); //see app note from chan

			if(!RefillBuffer()) // read data from file
				break;
 8021d0a:	bf00      	nop
 8021d0c:	e000      	b.n	8021d10 <_ZN12CFileHandler7PlayMP3EPKc+0x400>
					eBuffer = BUFFER_1; //switch Buffers
				}
				eMP3State = DECODE;
			}

			break;
 8021d0e:	bf00      	nop
bool CFileHandler::PlayMP3(const char* filename){
	static int offset = 0;
	static int err = 0;

	//operate files only when device connected
	while(GetUSBConnected()){
 8021d10:	6878      	ldr	r0, [r7, #4]
 8021d12:	f002 ff7d 	bl	8024c10 <_ZN12CFileHandler15GetUSBConnectedEv>
 8021d16:	4603      	mov	r3, r0
 8021d18:	2b00      	cmp	r3, #0
 8021d1a:	f47f adff 	bne.w	802191c <_ZN12CFileHandler7PlayMP3EPKc+0xc>
			eMP3State = OPEN_FILE;
			return true;
			break;
		}
	}
	eMP3State = OPEN_FILE;
 8021d1e:	687b      	ldr	r3, [r7, #4]
 8021d20:	f04f 0201 	mov.w	r2, #1
 8021d24:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
	return false; //Device disconnected
 8021d28:	f04f 0300 	mov.w	r3, #0
}
 8021d2c:	4618      	mov	r0, r3
 8021d2e:	f107 0708 	add.w	r7, r7, #8
 8021d32:	46bd      	mov	sp, r7
 8021d34:	bd80      	pop	{r7, pc}
 8021d36:	bf00      	nop

08021d38 <_ZN12CFileHandler7GetSongEv>:

/**
 * @brief get the actual filename of the song played
 * @return filename of played song
 */
const char* CFileHandler::GetSong(){
 8021d38:	b480      	push	{r7}
 8021d3a:	b083      	sub	sp, #12
 8021d3c:	af00      	add	r7, sp, #0
 8021d3e:	6078      	str	r0, [r7, #4]
	return fileInfo.fname;
 8021d40:	687b      	ldr	r3, [r7, #4]
 8021d42:	f503 7316 	add.w	r3, r3, #600	; 0x258
 8021d46:	f103 0301 	add.w	r3, r3, #1
}
 8021d4a:	4618      	mov	r0, r3
 8021d4c:	f107 070c 	add.w	r7, r7, #12
 8021d50:	46bd      	mov	sp, r7
 8021d52:	bc80      	pop	{r7}
 8021d54:	4770      	bx	lr
 8021d56:	bf00      	nop

08021d58 <_ZN12CFileHandler9PlayPauseEv>:

/**
  * @brief  toggles play, pause state
  *
  */
void CFileHandler::PlayPause(){
 8021d58:	b580      	push	{r7, lr}
 8021d5a:	b082      	sub	sp, #8
 8021d5c:	af00      	add	r7, sp, #0
 8021d5e:	6078      	str	r0, [r7, #4]
	if(bPlaying) {
 8021d60:	687b      	ldr	r3, [r7, #4]
 8021d62:	f893 3294 	ldrb.w	r3, [r3, #660]	; 0x294
 8021d66:	2b00      	cmp	r3, #0
 8021d68:	d009      	beq.n	8021d7e <_ZN12CFileHandler9PlayPauseEv+0x26>
		EVAL_AUDIO_PauseResume(AUDIO_PAUSE);
 8021d6a:	f04f 0000 	mov.w	r0, #0
 8021d6e:	f7eb ff4b 	bl	800dc08 <EVAL_AUDIO_PauseResume>
		bPlaying = false;
 8021d72:	687b      	ldr	r3, [r7, #4]
 8021d74:	f04f 0200 	mov.w	r2, #0
 8021d78:	f883 2294 	strb.w	r2, [r3, #660]	; 0x294
 8021d7c:	e008      	b.n	8021d90 <_ZN12CFileHandler9PlayPauseEv+0x38>
	} else {
		EVAL_AUDIO_PauseResume(AUDIO_RESUME);
 8021d7e:	f04f 0001 	mov.w	r0, #1
 8021d82:	f7eb ff41 	bl	800dc08 <EVAL_AUDIO_PauseResume>
		bPlaying = true;
 8021d86:	687b      	ldr	r3, [r7, #4]
 8021d88:	f04f 0201 	mov.w	r2, #1
 8021d8c:	f883 2294 	strb.w	r2, [r3, #660]	; 0x294
	}
}
 8021d90:	f107 0708 	add.w	r7, r7, #8
 8021d94:	46bd      	mov	sp, r7
 8021d96:	bd80      	pop	{r7, pc}

08021d98 <_ZN12CFileHandler9SetVolumeEh>:

/**
  * @brief  set actual DAC volume in %
  *
  */
void CFileHandler::SetVolume(uint8_t newVolume){
 8021d98:	b580      	push	{r7, lr}
 8021d9a:	b082      	sub	sp, #8
 8021d9c:	af00      	add	r7, sp, #0
 8021d9e:	6078      	str	r0, [r7, #4]
 8021da0:	460b      	mov	r3, r1
 8021da2:	70fb      	strb	r3, [r7, #3]
	uiVolume = newVolume;
 8021da4:	687b      	ldr	r3, [r7, #4]
 8021da6:	78fa      	ldrb	r2, [r7, #3]
 8021da8:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
	EVAL_AUDIO_VolumeCtl(newVolume);
 8021dac:	78fb      	ldrb	r3, [r7, #3]
 8021dae:	4618      	mov	r0, r3
 8021db0:	f7eb ff64 	bl	800dc7c <EVAL_AUDIO_VolumeCtl>
}
 8021db4:	f107 0708 	add.w	r7, r7, #8
 8021db8:	46bd      	mov	sp, r7
 8021dba:	bd80      	pop	{r7, pc}

08021dbc <_ZN12CFileHandler11Mems_ConfigEv>:
 * @brief  configure the mems accelometer
 * @param  None
 * @retval None
 */
void CFileHandler::Mems_Config(void)
{
 8021dbc:	b580      	push	{r7, lr}
 8021dbe:	b086      	sub	sp, #24
 8021dc0:	af00      	add	r7, sp, #0
 8021dc2:	6078      	str	r0, [r7, #4]
	uint8_t ctrl = 0;
 8021dc4:	f04f 0300 	mov.w	r3, #0
 8021dc8:	75fb      	strb	r3, [r7, #23]

	LIS302DL_InitTypeDef  LIS302DL_InitStruct;
	LIS302DL_InterruptConfigTypeDef LIS302DL_InterruptStruct;

	/* Set configuration of LIS302DL*/
	LIS302DL_InitStruct.Power_Mode = LIS302DL_LOWPOWERMODE_ACTIVE;
 8021dca:	f04f 0340 	mov.w	r3, #64	; 0x40
 8021dce:	743b      	strb	r3, [r7, #16]
	LIS302DL_InitStruct.Output_DataRate = LIS302DL_DATARATE_100;
 8021dd0:	f04f 0300 	mov.w	r3, #0
 8021dd4:	747b      	strb	r3, [r7, #17]
	LIS302DL_InitStruct.Axes_Enable = LIS302DL_X_ENABLE | LIS302DL_Y_ENABLE | LIS302DL_Z_ENABLE;
 8021dd6:	f04f 0307 	mov.w	r3, #7
 8021dda:	74bb      	strb	r3, [r7, #18]
	LIS302DL_InitStruct.Full_Scale = LIS302DL_FULLSCALE_2_3;
 8021ddc:	f04f 0300 	mov.w	r3, #0
 8021de0:	74fb      	strb	r3, [r7, #19]
	LIS302DL_InitStruct.Self_Test = LIS302DL_SELFTEST_NORMAL;
 8021de2:	f04f 0300 	mov.w	r3, #0
 8021de6:	753b      	strb	r3, [r7, #20]
	LIS302DL_Init(&LIS302DL_InitStruct);
 8021de8:	f107 0310 	add.w	r3, r7, #16
 8021dec:	4618      	mov	r0, r3
 8021dee:	f7ec ffbd 	bl	800ed6c <LIS302DL_Init>

	/* Set configuration of Internal High Pass Filter of LIS302DL*/
	LIS302DL_InterruptStruct.Latch_Request = LIS302DL_INTERRUPTREQUEST_LATCHED;
 8021df2:	f04f 0340 	mov.w	r3, #64	; 0x40
 8021df6:	733b      	strb	r3, [r7, #12]
	LIS302DL_InterruptStruct.SingleClick_Axes = LIS302DL_CLICKINTERRUPT_Z_ENABLE;
 8021df8:	f04f 0310 	mov.w	r3, #16
 8021dfc:	737b      	strb	r3, [r7, #13]
	LIS302DL_InterruptStruct.DoubleClick_Axes = LIS302DL_DOUBLECLICKINTERRUPT_Z_ENABLE;
 8021dfe:	f04f 0320 	mov.w	r3, #32
 8021e02:	73bb      	strb	r3, [r7, #14]
	LIS302DL_InterruptConfig(&LIS302DL_InterruptStruct);
 8021e04:	f107 030c 	add.w	r3, r7, #12
 8021e08:	4618      	mov	r0, r3
 8021e0a:	f7ed f809 	bl	800ee20 <LIS302DL_InterruptConfig>

	/* Configure Interrupt control register: enable Click interrupt on INT1 and
     INT2 on Z axis high event */
	ctrl = 0x3F;
 8021e0e:	f04f 033f 	mov.w	r3, #63	; 0x3f
 8021e12:	75fb      	strb	r3, [r7, #23]
	LIS302DL_Write(&ctrl, LIS302DL_CTRL_REG3_ADDR, 1);
 8021e14:	f107 0317 	add.w	r3, r7, #23
 8021e18:	4618      	mov	r0, r3
 8021e1a:	f04f 0122 	mov.w	r1, #34	; 0x22
 8021e1e:	f04f 0201 	mov.w	r2, #1
 8021e22:	f7ed f8b5 	bl	800ef90 <LIS302DL_Write>

	/* Enable Interrupt generation on click on Z axis */
	ctrl = 0x50;
 8021e26:	f04f 0350 	mov.w	r3, #80	; 0x50
 8021e2a:	75fb      	strb	r3, [r7, #23]
	LIS302DL_Write(&ctrl, LIS302DL_CLICK_CFG_REG_ADDR, 1);
 8021e2c:	f107 0317 	add.w	r3, r7, #23
 8021e30:	4618      	mov	r0, r3
 8021e32:	f04f 0138 	mov.w	r1, #56	; 0x38
 8021e36:	f04f 0201 	mov.w	r2, #1
 8021e3a:	f7ed f8a9 	bl	800ef90 <LIS302DL_Write>

	/* Configure Click Threshold on X/Y axis (10 x 0.5g) */
	ctrl = 0xAA;
 8021e3e:	f04f 03aa 	mov.w	r3, #170	; 0xaa
 8021e42:	75fb      	strb	r3, [r7, #23]
	LIS302DL_Write(&ctrl, LIS302DL_CLICK_THSY_X_REG_ADDR, 1);
 8021e44:	f107 0317 	add.w	r3, r7, #23
 8021e48:	4618      	mov	r0, r3
 8021e4a:	f04f 013b 	mov.w	r1, #59	; 0x3b
 8021e4e:	f04f 0201 	mov.w	r2, #1
 8021e52:	f7ed f89d 	bl	800ef90 <LIS302DL_Write>

	/* Configure Click Threshold on Z axis (10 x 0.5g) */
	ctrl = 0x0A;
 8021e56:	f04f 030a 	mov.w	r3, #10
 8021e5a:	75fb      	strb	r3, [r7, #23]
	LIS302DL_Write(&ctrl, LIS302DL_CLICK_THSZ_REG_ADDR, 1);
 8021e5c:	f107 0317 	add.w	r3, r7, #23
 8021e60:	4618      	mov	r0, r3
 8021e62:	f04f 013c 	mov.w	r1, #60	; 0x3c
 8021e66:	f04f 0201 	mov.w	r2, #1
 8021e6a:	f7ed f891 	bl	800ef90 <LIS302DL_Write>

	/* Enable interrupt on Y axis high event */
	ctrl = 0x4C;
 8021e6e:	f04f 034c 	mov.w	r3, #76	; 0x4c
 8021e72:	75fb      	strb	r3, [r7, #23]
	LIS302DL_Write(&ctrl, LIS302DL_FF_WU_CFG1_REG_ADDR, 1);
 8021e74:	f107 0317 	add.w	r3, r7, #23
 8021e78:	4618      	mov	r0, r3
 8021e7a:	f04f 0130 	mov.w	r1, #48	; 0x30
 8021e7e:	f04f 0201 	mov.w	r2, #1
 8021e82:	f7ed f885 	bl	800ef90 <LIS302DL_Write>

	/* Configure Time Limit */
	ctrl = 0x03;
 8021e86:	f04f 0303 	mov.w	r3, #3
 8021e8a:	75fb      	strb	r3, [r7, #23]
	LIS302DL_Write(&ctrl, LIS302DL_CLICK_TIMELIMIT_REG_ADDR, 1);
 8021e8c:	f107 0317 	add.w	r3, r7, #23
 8021e90:	4618      	mov	r0, r3
 8021e92:	f04f 013d 	mov.w	r1, #61	; 0x3d
 8021e96:	f04f 0201 	mov.w	r2, #1
 8021e9a:	f7ed f879 	bl	800ef90 <LIS302DL_Write>

	/* Configure Latency */
	ctrl = 0x7F;
 8021e9e:	f04f 037f 	mov.w	r3, #127	; 0x7f
 8021ea2:	75fb      	strb	r3, [r7, #23]
	LIS302DL_Write(&ctrl, LIS302DL_CLICK_LATENCY_REG_ADDR, 1);
 8021ea4:	f107 0317 	add.w	r3, r7, #23
 8021ea8:	4618      	mov	r0, r3
 8021eaa:	f04f 013e 	mov.w	r1, #62	; 0x3e
 8021eae:	f04f 0201 	mov.w	r2, #1
 8021eb2:	f7ed f86d 	bl	800ef90 <LIS302DL_Write>

	/* Configure Click Window */
	ctrl = 0x7F;
 8021eb6:	f04f 037f 	mov.w	r3, #127	; 0x7f
 8021eba:	75fb      	strb	r3, [r7, #23]
	LIS302DL_Write(&ctrl, LIS302DL_CLICK_WINDOW_REG_ADDR, 1);
 8021ebc:	f107 0317 	add.w	r3, r7, #23
 8021ec0:	4618      	mov	r0, r3
 8021ec2:	f04f 013f 	mov.w	r1, #63	; 0x3f
 8021ec6:	f04f 0201 	mov.w	r2, #1
 8021eca:	f7ed f861 	bl	800ef90 <LIS302DL_Write>

}
 8021ece:	f107 0718 	add.w	r7, r7, #24
 8021ed2:	46bd      	mov	sp, r7
 8021ed4:	bd80      	pop	{r7, pc}
 8021ed6:	bf00      	nop

08021ed8 <_ZN12CFileHandler15EXTILine_ConfigEv>:
 * @brief  Configures EXTI Line0 (connected to PA0 pin) in interrupt mode
 * @param  None
 * @retval None
 */
void CFileHandler::EXTILine_Config(void)
{
 8021ed8:	b580      	push	{r7, lr}
 8021eda:	b088      	sub	sp, #32
 8021edc:	af00      	add	r7, sp, #0
 8021ede:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef   GPIO_InitStructure;
	NVIC_InitTypeDef   NVIC_InitStructure;
	EXTI_InitTypeDef   EXTI_InitStructure;
	/* Enable GPIOA clock */
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 8021ee0:	f04f 0010 	mov.w	r0, #16
 8021ee4:	f04f 0101 	mov.w	r1, #1
 8021ee8:	f7e6 fec0 	bl	8008c6c <RCC_AHB1PeriphClockCmd>
	/* Enable SYSCFG clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8021eec:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8021ef0:	f04f 0101 	mov.w	r1, #1
 8021ef4:	f7e6 ff6a 	bl	8008dcc <RCC_APB2PeriphClockCmd>
	/* Configure PE0 and PE1 pins as input floating */
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8021ef8:	f04f 0300 	mov.w	r3, #0
 8021efc:	773b      	strb	r3, [r7, #28]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8021efe:	f04f 0300 	mov.w	r3, #0
 8021f02:	77fb      	strb	r3, [r7, #31]
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1;
 8021f04:	f04f 0303 	mov.w	r3, #3
 8021f08:	61bb      	str	r3, [r7, #24]
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 8021f0a:	f107 0318 	add.w	r3, r7, #24
 8021f0e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8021f12:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8021f16:	4619      	mov	r1, r3
 8021f18:	f7e5 fad2 	bl	80074c0 <GPIO_Init>

	/* Connect EXTI Line to PE1 pins */
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource1);
 8021f1c:	f04f 0004 	mov.w	r0, #4
 8021f20:	f04f 0101 	mov.w	r1, #1
 8021f24:	f7e9 fca0 	bl	800b868 <SYSCFG_EXTILineConfig>

	/* Configure EXTI Line1 */
	EXTI_InitStructure.EXTI_Line = EXTI_Line1;
 8021f28:	f04f 0302 	mov.w	r3, #2
 8021f2c:	60fb      	str	r3, [r7, #12]
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8021f2e:	f04f 0300 	mov.w	r3, #0
 8021f32:	743b      	strb	r3, [r7, #16]
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 8021f34:	f04f 0308 	mov.w	r3, #8
 8021f38:	747b      	strb	r3, [r7, #17]
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8021f3a:	f04f 0301 	mov.w	r3, #1
 8021f3e:	74bb      	strb	r3, [r7, #18]
	EXTI_Init(&EXTI_InitStructure);
 8021f40:	f107 030c 	add.w	r3, r7, #12
 8021f44:	4618      	mov	r0, r3
 8021f46:	f7e5 f8bf 	bl	80070c8 <EXTI_Init>

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
 8021f4a:	f44f 7040 	mov.w	r0, #768	; 0x300
 8021f4e:	f7e4 f8fb 	bl	8006148 <NVIC_PriorityGroupConfig>

	/* Enable and set EXTI Line0 Interrupt to the priority 1 higher than RTOS Kern */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
 8021f52:	f04f 0307 	mov.w	r3, #7
 8021f56:	753b      	strb	r3, [r7, #20]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = configLIBRARY_KERNEL_INTERRUPT_PRIORITY-1;
 8021f58:	f04f 030e 	mov.w	r3, #14
 8021f5c:	757b      	strb	r3, [r7, #21]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
 8021f5e:	f04f 0300 	mov.w	r3, #0
 8021f62:	75bb      	strb	r3, [r7, #22]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8021f64:	f04f 0301 	mov.w	r3, #1
 8021f68:	75fb      	strb	r3, [r7, #23]
	NVIC_Init(&NVIC_InitStructure);
 8021f6a:	f107 0314 	add.w	r3, r7, #20
 8021f6e:	4618      	mov	r0, r3
 8021f70:	f7e4 f8fe 	bl	8006170 <NVIC_Init>
}
 8021f74:	f107 0720 	add.w	r7, r7, #32
 8021f78:	46bd      	mov	sp, r7
 8021f7a:	bd80      	pop	{r7, pc}

08021f7c <EVAL_AUDIO_TransferComplete_CallBack>:
 * @brief  Calculates the remaining file size and new position of the pointer.
 * @param  None
 * @retval None
 */
void EVAL_AUDIO_TransferComplete_CallBack(uint32_t pBuffer, uint32_t Size)
{
 8021f7c:	b580      	push	{r7, lr}
 8021f7e:	b084      	sub	sp, #16
 8021f80:	af00      	add	r7, sp, #0
 8021f82:	6078      	str	r0, [r7, #4]
 8021f84:	6039      	str	r1, [r7, #0]
  for the DMA transfer. If the Audio files size is less than the DMA max
  data transfer size, so there is no calculation to be done, just restart
  from the beginning of the file ... */
	/* Check if the end of file has been reached */

	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 8021f86:	f04f 0300 	mov.w	r3, #0
 8021f8a:	60fb      	str	r3, [r7, #12]

	xSemaphoreGiveFromISR(semI2SDMAFinished,&xHigherPriorityTaskWoken);
 8021f8c:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8021f90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021f94:	681a      	ldr	r2, [r3, #0]
 8021f96:	f107 030c 	add.w	r3, r7, #12
 8021f9a:	4610      	mov	r0, r2
 8021f9c:	f04f 0100 	mov.w	r1, #0
 8021fa0:	461a      	mov	r2, r3
 8021fa2:	f04f 0300 	mov.w	r3, #0
 8021fa6:	f7f8 f8a1 	bl	801a0ec <xQueueGenericSendFromISR>
	/*
	 * triggers PendSV handler for context switch
	 * but when DMA Handler has higher Priority
	 * this has no effect until ISR is finished
	 */
	portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
 8021faa:	68fb      	ldr	r3, [r7, #12]
 8021fac:	2b00      	cmp	r3, #0
 8021fae:	d001      	beq.n	8021fb4 <EVAL_AUDIO_TransferComplete_CallBack+0x38>
 8021fb0:	f7f7 fdf0 	bl	8019b94 <vPortYieldFromISR>
}
 8021fb4:	f107 0710 	add.w	r7, r7, #16
 8021fb8:	46bd      	mov	sp, r7
 8021fba:	bd80      	pop	{r7, pc}

08021fbc <EVAL_AUDIO_GetSampleCallBack>:
 * @brief  Get next data sample callback
 * @param  None
 * @retval Next data sample to be sent
 */
uint16_t EVAL_AUDIO_GetSampleCallBack(void)
{
 8021fbc:	b480      	push	{r7}
 8021fbe:	af00      	add	r7, sp, #0
	return 0;
 8021fc0:	f04f 0300 	mov.w	r3, #0
}
 8021fc4:	4618      	mov	r0, r3
 8021fc6:	46bd      	mov	sp, r7
 8021fc8:	bc80      	pop	{r7}
 8021fca:	4770      	bx	lr

08021fcc <get_fattime>:
 * 			bit 4:0
 * 				 Second / 2 (0..29)
 *
 */
DWORD get_fattime (void)
{
 8021fcc:	b480      	push	{r7}
 8021fce:	af00      	add	r7, sp, #0


  return 0;
 8021fd0:	f04f 0300 	mov.w	r3, #0
}
 8021fd4:	4618      	mov	r0, r3
 8021fd6:	46bd      	mov	sp, r7
 8021fd8:	bc80      	pop	{r7}
 8021fda:	4770      	bx	lr

08021fdc <_ZN24CLedHeartBeatSTM32F4DiscC1Em>:
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/


CLedHeartBeatSTM32F4Disc::CLedHeartBeatSTM32F4Disc(portTickType newRate) {
 8021fdc:	b580      	push	{r7, lr}
 8021fde:	b082      	sub	sp, #8
 8021fe0:	af00      	add	r7, sp, #0
 8021fe2:	6078      	str	r0, [r7, #4]
 8021fe4:	6039      	str	r1, [r7, #0]
 8021fe6:	687b      	ldr	r3, [r7, #4]
 8021fe8:	4618      	mov	r0, r3
 8021fea:	f7f7 fb2f 	bl	801964c <_ZN12AManagedTaskC1Ev>
 8021fee:	687b      	ldr	r3, [r7, #4]
 8021ff0:	4a07      	ldr	r2, [pc, #28]	; (8022010 <_ZN24CLedHeartBeatSTM32F4DiscC1Em+0x34>)
 8021ff2:	601a      	str	r2, [r3, #0]
	ledState = LED_Up;
 8021ff4:	687b      	ldr	r3, [r7, #4]
 8021ff6:	f04f 0200 	mov.w	r2, #0
 8021ffa:	731a      	strb	r2, [r3, #12]
	ledRate = newRate;
 8021ffc:	687b      	ldr	r3, [r7, #4]
 8021ffe:	683a      	ldr	r2, [r7, #0]
 8022000:	611a      	str	r2, [r3, #16]
}
 8022002:	687b      	ldr	r3, [r7, #4]
 8022004:	4618      	mov	r0, r3
 8022006:	f107 0708 	add.w	r7, r7, #8
 802200a:	46bd      	mov	sp, r7
 802200c:	bd80      	pop	{r7, pc}
 802200e:	bf00      	nop
 8022010:	08032bc8 	.word	0x08032bc8

08022014 <_ZN24CLedHeartBeatSTM32F4DiscD1Ev>:

CLedHeartBeatSTM32F4Disc::~CLedHeartBeatSTM32F4Disc() {
 8022014:	b580      	push	{r7, lr}
 8022016:	b082      	sub	sp, #8
 8022018:	af00      	add	r7, sp, #0
 802201a:	6078      	str	r0, [r7, #4]
 802201c:	687b      	ldr	r3, [r7, #4]
 802201e:	4a0a      	ldr	r2, [pc, #40]	; (8022048 <_ZN24CLedHeartBeatSTM32F4DiscD1Ev+0x34>)
 8022020:	601a      	str	r2, [r3, #0]
	// nothing to destroy
}
 8022022:	6878      	ldr	r0, [r7, #4]
 8022024:	f7f7 fb2e 	bl	8019684 <_ZN12AManagedTaskD1Ev>
 8022028:	f04f 0300 	mov.w	r3, #0
 802202c:	f003 0301 	and.w	r3, r3, #1
 8022030:	b2db      	uxtb	r3, r3
 8022032:	2b00      	cmp	r3, #0
 8022034:	d002      	beq.n	802203c <_ZN24CLedHeartBeatSTM32F4DiscD1Ev+0x28>
 8022036:	6878      	ldr	r0, [r7, #4]
 8022038:	f000 f8cc 	bl	80221d4 <_ZdlPv>
 802203c:	687b      	ldr	r3, [r7, #4]
 802203e:	4618      	mov	r0, r3
 8022040:	f107 0708 	add.w	r7, r7, #8
 8022044:	46bd      	mov	sp, r7
 8022046:	bd80      	pop	{r7, pc}
 8022048:	08032bc8 	.word	0x08032bc8

0802204c <_ZN24CLedHeartBeatSTM32F4DiscD0Ev>:
CLedHeartBeatSTM32F4Disc::CLedHeartBeatSTM32F4Disc(portTickType newRate) {
	ledState = LED_Up;
	ledRate = newRate;
}

CLedHeartBeatSTM32F4Disc::~CLedHeartBeatSTM32F4Disc() {
 802204c:	b580      	push	{r7, lr}
 802204e:	b082      	sub	sp, #8
 8022050:	af00      	add	r7, sp, #0
 8022052:	6078      	str	r0, [r7, #4]
	// nothing to destroy
}
 8022054:	6878      	ldr	r0, [r7, #4]
 8022056:	f7ff ffdd 	bl	8022014 <_ZN24CLedHeartBeatSTM32F4DiscD1Ev>
 802205a:	6878      	ldr	r0, [r7, #4]
 802205c:	f000 f8ba 	bl	80221d4 <_ZdlPv>
 8022060:	687b      	ldr	r3, [r7, #4]
 8022062:	4618      	mov	r0, r3
 8022064:	f107 0708 	add.w	r7, r7, #8
 8022068:	46bd      	mov	sp, r7
 802206a:	bd80      	pop	{r7, pc}

0802206c <_ZN24CLedHeartBeatSTM32F4Disc12HardwareInitEv>:
/**
  * @brief  HardwareInit called before Scheduler starts
  * @param  None
  * @retval true on succsess
  */
bool CLedHeartBeatSTM32F4Disc::HardwareInit(){
 802206c:	b580      	push	{r7, lr}
 802206e:	b082      	sub	sp, #8
 8022070:	af00      	add	r7, sp, #0
 8022072:	6078      	str	r0, [r7, #4]

	STM_EVAL_LEDInit(LED3);
 8022074:	f04f 0001 	mov.w	r0, #1
 8022078:	f7eb fb48 	bl	800d70c <STM_EVAL_LEDInit>
	STM_EVAL_LEDInit(LED4);
 802207c:	f04f 0000 	mov.w	r0, #0
 8022080:	f7eb fb44 	bl	800d70c <STM_EVAL_LEDInit>
	STM_EVAL_LEDInit(LED5);
 8022084:	f04f 0002 	mov.w	r0, #2
 8022088:	f7eb fb40 	bl	800d70c <STM_EVAL_LEDInit>
	STM_EVAL_LEDInit(LED6);
 802208c:	f04f 0003 	mov.w	r0, #3
 8022090:	f7eb fb3c 	bl	800d70c <STM_EVAL_LEDInit>
	return true;
 8022094:	f04f 0301 	mov.w	r3, #1
}
 8022098:	4618      	mov	r0, r3
 802209a:	f107 0708 	add.w	r7, r7, #8
 802209e:	46bd      	mov	sp, r7
 80220a0:	bd80      	pop	{r7, pc}
 80220a2:	bf00      	nop

080220a4 <_ZN24CLedHeartBeatSTM32F4Disc3RunEv>:
/**
  * @brief  task function for Led Heartbeat
  * @param  None
  * @retval None
  */
void CLedHeartBeatSTM32F4Disc::Run(){
 80220a4:	b580      	push	{r7, lr}
 80220a6:	b082      	sub	sp, #8
 80220a8:	af00      	add	r7, sp, #0
 80220aa:	6078      	str	r0, [r7, #4]
	while(1){
		switch(ledState){
 80220ac:	687b      	ldr	r3, [r7, #4]
 80220ae:	7b1b      	ldrb	r3, [r3, #12]
 80220b0:	2b03      	cmp	r3, #3
 80220b2:	d85f      	bhi.n	8022174 <_ZN24CLedHeartBeatSTM32F4Disc3RunEv+0xd0>
 80220b4:	a201      	add	r2, pc, #4	; (adr r2, 80220bc <_ZN24CLedHeartBeatSTM32F4Disc3RunEv+0x18>)
 80220b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80220ba:	bf00      	nop
 80220bc:	080220cd 	.word	0x080220cd
 80220c0:	080220f7 	.word	0x080220f7
 80220c4:	08022121 	.word	0x08022121
 80220c8:	0802214b 	.word	0x0802214b
		case LED_Up:
			STM_EVAL_LEDOn(LED3);
 80220cc:	f04f 0001 	mov.w	r0, #1
 80220d0:	f7eb fb52 	bl	800d778 <STM_EVAL_LEDOn>
			STM_EVAL_LEDOff(LED5);
 80220d4:	f04f 0002 	mov.w	r0, #2
 80220d8:	f7eb fb68 	bl	800d7ac <STM_EVAL_LEDOff>
			STM_EVAL_LEDOff(LED6);
 80220dc:	f04f 0003 	mov.w	r0, #3
 80220e0:	f7eb fb64 	bl	800d7ac <STM_EVAL_LEDOff>
			STM_EVAL_LEDOff(LED4);
 80220e4:	f04f 0000 	mov.w	r0, #0
 80220e8:	f7eb fb60 	bl	800d7ac <STM_EVAL_LEDOff>
			ledState = LED_Right;
 80220ec:	687b      	ldr	r3, [r7, #4]
 80220ee:	f04f 0201 	mov.w	r2, #1
 80220f2:	731a      	strb	r2, [r3, #12]
			break;
 80220f4:	e043      	b.n	802217e <_ZN24CLedHeartBeatSTM32F4Disc3RunEv+0xda>
		case LED_Right:
			STM_EVAL_LEDOff(LED3);
 80220f6:	f04f 0001 	mov.w	r0, #1
 80220fa:	f7eb fb57 	bl	800d7ac <STM_EVAL_LEDOff>
			STM_EVAL_LEDOn(LED5);
 80220fe:	f04f 0002 	mov.w	r0, #2
 8022102:	f7eb fb39 	bl	800d778 <STM_EVAL_LEDOn>
			STM_EVAL_LEDOff(LED6);
 8022106:	f04f 0003 	mov.w	r0, #3
 802210a:	f7eb fb4f 	bl	800d7ac <STM_EVAL_LEDOff>
			STM_EVAL_LEDOff(LED4);
 802210e:	f04f 0000 	mov.w	r0, #0
 8022112:	f7eb fb4b 	bl	800d7ac <STM_EVAL_LEDOff>
			ledState = LED_Down;
 8022116:	687b      	ldr	r3, [r7, #4]
 8022118:	f04f 0202 	mov.w	r2, #2
 802211c:	731a      	strb	r2, [r3, #12]
			break;
 802211e:	e02e      	b.n	802217e <_ZN24CLedHeartBeatSTM32F4Disc3RunEv+0xda>
		case LED_Down:
			STM_EVAL_LEDOff(LED3);
 8022120:	f04f 0001 	mov.w	r0, #1
 8022124:	f7eb fb42 	bl	800d7ac <STM_EVAL_LEDOff>
			STM_EVAL_LEDOff(LED5);
 8022128:	f04f 0002 	mov.w	r0, #2
 802212c:	f7eb fb3e 	bl	800d7ac <STM_EVAL_LEDOff>
			STM_EVAL_LEDOn(LED6);
 8022130:	f04f 0003 	mov.w	r0, #3
 8022134:	f7eb fb20 	bl	800d778 <STM_EVAL_LEDOn>
			STM_EVAL_LEDOff(LED4);
 8022138:	f04f 0000 	mov.w	r0, #0
 802213c:	f7eb fb36 	bl	800d7ac <STM_EVAL_LEDOff>
			ledState = LED_Left;
 8022140:	687b      	ldr	r3, [r7, #4]
 8022142:	f04f 0203 	mov.w	r2, #3
 8022146:	731a      	strb	r2, [r3, #12]
			break;
 8022148:	e019      	b.n	802217e <_ZN24CLedHeartBeatSTM32F4Disc3RunEv+0xda>
		case LED_Left:
			STM_EVAL_LEDOff(LED3);
 802214a:	f04f 0001 	mov.w	r0, #1
 802214e:	f7eb fb2d 	bl	800d7ac <STM_EVAL_LEDOff>
			STM_EVAL_LEDOff(LED5);
 8022152:	f04f 0002 	mov.w	r0, #2
 8022156:	f7eb fb29 	bl	800d7ac <STM_EVAL_LEDOff>
			STM_EVAL_LEDOff(LED6);
 802215a:	f04f 0003 	mov.w	r0, #3
 802215e:	f7eb fb25 	bl	800d7ac <STM_EVAL_LEDOff>
			STM_EVAL_LEDOn(LED4);
 8022162:	f04f 0000 	mov.w	r0, #0
 8022166:	f7eb fb07 	bl	800d778 <STM_EVAL_LEDOn>
			ledState = LED_Up;
 802216a:	687b      	ldr	r3, [r7, #4]
 802216c:	f04f 0200 	mov.w	r2, #0
 8022170:	731a      	strb	r2, [r3, #12]
			break;
 8022172:	e004      	b.n	802217e <_ZN24CLedHeartBeatSTM32F4Disc3RunEv+0xda>
		default:
			ledState = LED_Up;
 8022174:	687b      	ldr	r3, [r7, #4]
 8022176:	f04f 0200 	mov.w	r2, #0
 802217a:	731a      	strb	r2, [r3, #12]
			break;
 802217c:	bf00      	nop
		}
		vTaskDelay(ledRate); // 500ms delay
 802217e:	687b      	ldr	r3, [r7, #4]
 8022180:	691b      	ldr	r3, [r3, #16]
 8022182:	4618      	mov	r0, r3
 8022184:	f7f8 fbfa 	bl	801a97c <vTaskDelay>
  * @brief  task function for Led Heartbeat
  * @param  None
  * @retval None
  */
void CLedHeartBeatSTM32F4Disc::Run(){
	while(1){
 8022188:	e790      	b.n	80220ac <_ZN24CLedHeartBeatSTM32F4Disc3RunEv+0x8>
 802218a:	bf00      	nop

0802218c <_ZN9__gnu_cxx27__verbose_terminate_handlerEv>:

/*
 * The default pulls in 70K of garbage
 */
namespace __gnu_cxx {
void __verbose_terminate_handler() {
 802218c:	b480      	push	{r7}
 802218e:	af00      	add	r7, sp, #0
	for(;;);
 8022190:	e7fe      	b.n	8022190 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x4>
 8022192:	bf00      	nop

08022194 <__cxa_pure_virtual>:
}

/*
 * The default pulls in about 12K of garbage
 */
extern "C" void __cxa_pure_virtual() {
 8022194:	b480      	push	{r7}
 8022196:	af00      	add	r7, sp, #0
	for(;;);
 8022198:	e7fe      	b.n	8022198 <__cxa_pure_virtual+0x4>
 802219a:	bf00      	nop

0802219c <_Znwj>:
}

/*
 * Implement C++ new/delete operators using the heap
 */
void *operator new(size_t size) {
 802219c:	b580      	push	{r7, lr}
 802219e:	b082      	sub	sp, #8
 80221a0:	af00      	add	r7, sp, #0
 80221a2:	6078      	str	r0, [r7, #4]
	return malloc(size);
 80221a4:	6878      	ldr	r0, [r7, #4]
 80221a6:	f002 fe07 	bl	8024db8 <malloc>
 80221aa:	4603      	mov	r3, r0
}
 80221ac:	4618      	mov	r0, r3
 80221ae:	f107 0708 	add.w	r7, r7, #8
 80221b2:	46bd      	mov	sp, r7
 80221b4:	bd80      	pop	{r7, pc}
 80221b6:	bf00      	nop

080221b8 <_Znaj>:

void *operator new[](size_t size) {
 80221b8:	b580      	push	{r7, lr}
 80221ba:	b082      	sub	sp, #8
 80221bc:	af00      	add	r7, sp, #0
 80221be:	6078      	str	r0, [r7, #4]
	return malloc(size);
 80221c0:	6878      	ldr	r0, [r7, #4]
 80221c2:	f002 fdf9 	bl	8024db8 <malloc>
 80221c6:	4603      	mov	r3, r0
}
 80221c8:	4618      	mov	r0, r3
 80221ca:	f107 0708 	add.w	r7, r7, #8
 80221ce:	46bd      	mov	sp, r7
 80221d0:	bd80      	pop	{r7, pc}
 80221d2:	bf00      	nop

080221d4 <_ZdlPv>:

void operator delete(void *p) {
 80221d4:	b580      	push	{r7, lr}
 80221d6:	b082      	sub	sp, #8
 80221d8:	af00      	add	r7, sp, #0
 80221da:	6078      	str	r0, [r7, #4]
	free(p);
 80221dc:	6878      	ldr	r0, [r7, #4]
 80221de:	f002 fdf3 	bl	8024dc8 <free>
}
 80221e2:	f107 0708 	add.w	r7, r7, #8
 80221e6:	46bd      	mov	sp, r7
 80221e8:	bd80      	pop	{r7, pc}
 80221ea:	bf00      	nop

080221ec <_ZdaPv>:

void operator delete[](void *p) {
 80221ec:	b580      	push	{r7, lr}
 80221ee:	b082      	sub	sp, #8
 80221f0:	af00      	add	r7, sp, #0
 80221f2:	6078      	str	r0, [r7, #4]
	free(p);
 80221f4:	6878      	ldr	r0, [r7, #4]
 80221f6:	f002 fde7 	bl	8024dc8 <free>
}
 80221fa:	f107 0708 	add.w	r7, r7, #8
 80221fe:	46bd      	mov	sp, r7
 8022200:	bd80      	pop	{r7, pc}
 8022202:	bf00      	nop

08022204 <_sbrk>:
 * sbrk function for getting space for malloc and friends
 */
extern int  _end;

extern "C" {
caddr_t _sbrk ( int incr ) {
 8022204:	b480      	push	{r7}
 8022206:	b085      	sub	sp, #20
 8022208:	af00      	add	r7, sp, #0
 802220a:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
 802220c:	f643 4398 	movw	r3, #15512	; 0x3c98
 8022210:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022214:	681b      	ldr	r3, [r3, #0]
 8022216:	2b00      	cmp	r3, #0
 8022218:	d108      	bne.n	802222c <_sbrk+0x28>
		heap = (unsigned char *)&_end;
 802221a:	f643 4398 	movw	r3, #15512	; 0x3c98
 802221e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022222:	f24a 5248 	movw	r2, #42312	; 0xa548
 8022226:	f2c2 0200 	movt	r2, #8192	; 0x2000
 802222a:	601a      	str	r2, [r3, #0]
	}     prev_heap = heap;
 802222c:	f643 4398 	movw	r3, #15512	; 0x3c98
 8022230:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022234:	681b      	ldr	r3, [r3, #0]
 8022236:	60fb      	str	r3, [r7, #12]

	/* check removed to show basic approach */
	heap += incr;
 8022238:	f643 4398 	movw	r3, #15512	; 0x3c98
 802223c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022240:	681a      	ldr	r2, [r3, #0]
 8022242:	687b      	ldr	r3, [r7, #4]
 8022244:	18d2      	adds	r2, r2, r3
 8022246:	f643 4398 	movw	r3, #15512	; 0x3c98
 802224a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802224e:	601a      	str	r2, [r3, #0]
	return (caddr_t) prev_heap;
 8022250:	68fb      	ldr	r3, [r7, #12]
}
 8022252:	4618      	mov	r0, r3
 8022254:	f107 0714 	add.w	r7, r7, #20
 8022258:	46bd      	mov	sp, r7
 802225a:	bc80      	pop	{r7}
 802225c:	4770      	bx	lr
 802225e:	bf00      	nop

08022260 <main>:
/**
  * @brief  main function
  * @param  None
  * @retval None
  */
int main(void){
 8022260:	b580      	push	{r7, lr}
 8022262:	b082      	sub	sp, #8
 8022264:	af00      	add	r7, sp, #0
	unsigned int u;

	/**
	 * Unit Tests
	 */
	Time::CTimeUnitTest();
 8022266:	f7fa f9d9 	bl	801c61c <_ZN4Time13CTimeUnitTestEv>

	/**
	 * create Led Heartbeat task with minimal stack size and priority
	 * 1 higher than idle task
	 */
	g_LedTast.Create("Led Heartbeat",configMINIMAL_STACK_SIZE,tskIDLE_PRIORITY+3);
 802226a:	f643 409c 	movw	r0, #15516	; 0x3c9c
 802226e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8022272:	f64b 31c8 	movw	r1, #48072	; 0xbbc8
 8022276:	f6c0 0102 	movt	r1, #2050	; 0x802
 802227a:	f44f 7280 	mov.w	r2, #256	; 0x100
 802227e:	f04f 0303 	mov.w	r3, #3
 8022282:	f7f7 fa2f 	bl	80196e4 <_ZN12AManagedTask6CreateEPKctm>
	g_MSC.Create("USB Massstorage", configMINIMAL_STACK_SIZE * 10, tskIDLE_PRIORITY +1);
 8022286:	f643 708c 	movw	r0, #16268	; 0x3f8c
 802228a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 802228e:	f64b 31d8 	movw	r1, #48088	; 0xbbd8
 8022292:	f6c0 0102 	movt	r1, #2050	; 0x802
 8022296:	f44f 6220 	mov.w	r2, #2560	; 0xa00
 802229a:	f04f 0301 	mov.w	r3, #1
 802229e:	f7f7 fa21 	bl	80196e4 <_ZN12AManagedTask6CreateEPKctm>
	g_Menue.Create("Menue",configMINIMAL_STACK_SIZE * 2,tskIDLE_PRIORITY+3);
 80222a2:	f643 40b8 	movw	r0, #15544	; 0x3cb8
 80222a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80222aa:	f64b 31e8 	movw	r1, #48104	; 0xbbe8
 80222ae:	f6c0 0102 	movt	r1, #2050	; 0x802
 80222b2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80222b6:	f04f 0303 	mov.w	r3, #3
 80222ba:	f7f7 fa13 	bl	80196e4 <_ZN12AManagedTask6CreateEPKctm>
	g_FileHandler.Create("FileHandler",configMINIMAL_STACK_SIZE * 20,tskIDLE_PRIORITY+1);
 80222be:	f643 40c8 	movw	r0, #15560	; 0x3cc8
 80222c2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80222c6:	f64b 31f0 	movw	r1, #48112	; 0xbbf0
 80222ca:	f6c0 0102 	movt	r1, #2050	; 0x802
 80222ce:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
 80222d2:	f04f 0301 	mov.w	r3, #1
 80222d6:	f7f7 fa05 	bl	80196e4 <_ZN12AManagedTask6CreateEPKctm>

	/**
	 * Initialize the hardware for all Tasks and
	 * then FreeRTOS takes control of execution
	 */
	CFreeRTOS::InitHardwareForManagedTasks();
 80222da:	f7f7 faf7 	bl	80198cc <_ZN9CFreeRTOS27InitHardwareForManagedTasksEv>
	CFreeRTOS::StartScheduler();
 80222de:	f002 fca7 	bl	8024c30 <_ZN9CFreeRTOS14StartSchedulerEv>

	while(1){
		u++;
 80222e2:	687b      	ldr	r3, [r7, #4]
 80222e4:	f103 0301 	add.w	r3, r3, #1
 80222e8:	607b      	str	r3, [r7, #4]
	 * then FreeRTOS takes control of execution
	 */
	CFreeRTOS::InitHardwareForManagedTasks();
	CFreeRTOS::StartScheduler();

	while(1){
 80222ea:	e7fa      	b.n	80222e2 <main+0x82>

080222ec <vApplicationTickHook>:

extern "C" {

	// This FreeRTOS callback function gets called once per tick (default = 1000Hz).
	// ----------------------------------------------------------------------------
	void vApplicationTickHook( void ) {
 80222ec:	b480      	push	{r7}
 80222ee:	af00      	add	r7, sp, #0

	}
 80222f0:	46bd      	mov	sp, r7
 80222f2:	bc80      	pop	{r7}
 80222f4:	4770      	bx	lr
 80222f6:	bf00      	nop

080222f8 <vApplicationIdleHook>:

	// This FreeRTOS call-back function gets when no other task is ready to execute.
	// On a completely unloaded system this is getting called at over 2.5MHz!
	// ----------------------------------------------------------------------------
	void vApplicationIdleHook( void ) {
 80222f8:	b480      	push	{r7}
 80222fa:	af00      	add	r7, sp, #0

	}
 80222fc:	46bd      	mov	sp, r7
 80222fe:	bc80      	pop	{r7}
 8022300:	4770      	bx	lr
 8022302:	bf00      	nop

08022304 <vApplicationMallocFailedHook>:

	// A required FreeRTOS function.
	// ----------------------------------------------------------------------------
	void vApplicationMallocFailedHook( void ) {
 8022304:	b480      	push	{r7}
 8022306:	af00      	add	r7, sp, #0
		configASSERT( 0 );  // Latch on any failure / error.
	}
 8022308:	46bd      	mov	sp, r7
 802230a:	bc80      	pop	{r7}
 802230c:	4770      	bx	lr
 802230e:	bf00      	nop

08022310 <vApplicationStackOverflowHook>:

	// A required FreeRTOS function. gets called on stack overflow
	// ----------------------------------------------------------------------------
	void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName ){
 8022310:	b480      	push	{r7}
 8022312:	b083      	sub	sp, #12
 8022314:	af00      	add	r7, sp, #0
 8022316:	6078      	str	r0, [r7, #4]
 8022318:	6039      	str	r1, [r7, #0]
		/* TODO, implement your code here */
		while(1);
 802231a:	e7fe      	b.n	802231a <vApplicationStackOverflowHook+0xa>

0802231c <_Z41__static_initialization_and_destruction_0ii>:
	}
} // extern "C"

}//Somewhere is a { open i think i left one #ifdef __cplusplus  closing brance
 802231c:	b580      	push	{r7, lr}
 802231e:	b082      	sub	sp, #8
 8022320:	af00      	add	r7, sp, #0
 8022322:	6078      	str	r0, [r7, #4]
 8022324:	6039      	str	r1, [r7, #0]
 8022326:	687b      	ldr	r3, [r7, #4]
 8022328:	2b01      	cmp	r3, #1
 802232a:	d173      	bne.n	8022414 <_Z41__static_initialization_and_destruction_0ii+0xf8>
 802232c:	683a      	ldr	r2, [r7, #0]
 802232e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8022332:	429a      	cmp	r2, r3
 8022334:	d16e      	bne.n	8022414 <_Z41__static_initialization_and_destruction_0ii+0xf8>

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
CLedHeartBeatSTM32F4Disc g_LedTast(200/portTICK_RATE_MS);
 8022336:	f643 409c 	movw	r0, #15516	; 0x3c9c
 802233a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 802233e:	f04f 0114 	mov.w	r1, #20
 8022342:	f7ff fe4b 	bl	8021fdc <_ZN24CLedHeartBeatSTM32F4DiscC1Em>
 8022346:	f242 0315 	movw	r3, #8213	; 0x2015
 802234a:	f6c0 0302 	movt	r3, #2050	; 0x802
 802234e:	f643 409c 	movw	r0, #15516	; 0x3c9c
 8022352:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8022356:	4619      	mov	r1, r3
 8022358:	f240 0200 	movw	r2, #0
 802235c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8022360:	f002 fc9a 	bl	8024c98 <__aeabi_atexit>
CT6963_GPIO_Interface g_Display;
 8022364:	f643 40b0 	movw	r0, #15536	; 0x3cb0
 8022368:	f2c2 0000 	movt	r0, #8192	; 0x2000
 802236c:	f7f6 ff26 	bl	80191bc <_ZN21CT6963_GPIO_InterfaceC1Ev>
 8022370:	f249 13e5 	movw	r3, #37349	; 0x91e5
 8022374:	f6c0 0301 	movt	r3, #2049	; 0x801
 8022378:	f643 40b0 	movw	r0, #15536	; 0x3cb0
 802237c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8022380:	4619      	mov	r1, r3
 8022382:	f240 0200 	movw	r2, #0
 8022386:	f2c2 0200 	movt	r2, #8192	; 0x2000
 802238a:	f002 fc85 	bl	8024c98 <__aeabi_atexit>
CMenue	g_Menue(&g_Display);
 802238e:	f643 40b8 	movw	r0, #15544	; 0x3cb8
 8022392:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8022396:	f643 41b0 	movw	r1, #15536	; 0x3cb0
 802239a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 802239e:	f7ed f837 	bl	800f410 <_ZN6CMenueC1EP11CGraphicLCD>
 80223a2:	f24f 4341 	movw	r3, #62529	; 0xf441
 80223a6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80223aa:	f643 40b8 	movw	r0, #15544	; 0x3cb8
 80223ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80223b2:	4619      	mov	r1, r3
 80223b4:	f240 0200 	movw	r2, #0
 80223b8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80223bc:	f002 fc6c 	bl	8024c98 <__aeabi_atexit>
CFileHandler g_FileHandler;
 80223c0:	f643 40c8 	movw	r0, #15560	; 0x3cc8
 80223c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80223c8:	f7fe ff3e 	bl	8021248 <_ZN12CFileHandlerC1Ev>
 80223cc:	f241 23e1 	movw	r3, #4833	; 0x12e1
 80223d0:	f6c0 0302 	movt	r3, #2050	; 0x802
 80223d4:	f643 40c8 	movw	r0, #15560	; 0x3cc8
 80223d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80223dc:	4619      	mov	r1, r3
 80223de:	f240 0200 	movw	r2, #0
 80223e2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80223e6:	f002 fc57 	bl	8024c98 <__aeabi_atexit>
CUSB_MassStorage g_MSC;
 80223ea:	f643 708c 	movw	r0, #16268	; 0x3f8c
 80223ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80223f2:	f7fa f9ff 	bl	801c7f4 <_ZN16CUSB_MassStorageC1Ev>
 80223f6:	f64c 031d 	movw	r3, #51229	; 0xc81d
 80223fa:	f6c0 0301 	movt	r3, #2049	; 0x801
 80223fe:	f643 708c 	movw	r0, #16268	; 0x3f8c
 8022402:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8022406:	4619      	mov	r1, r3
 8022408:	f240 0200 	movw	r2, #0
 802240c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8022410:	f002 fc42 	bl	8024c98 <__aeabi_atexit>
		/* TODO, implement your code here */
		while(1);
	}
} // extern "C"

}//Somewhere is a { open i think i left one #ifdef __cplusplus  closing brance
 8022414:	f107 0708 	add.w	r7, r7, #8
 8022418:	46bd      	mov	sp, r7
 802241a:	bd80      	pop	{r7, pc}

0802241c <_GLOBAL__sub_I_g_LedTast>:
 802241c:	b580      	push	{r7, lr}
 802241e:	af00      	add	r7, sp, #0
 8022420:	f04f 0001 	mov.w	r0, #1
 8022424:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8022428:	f7ff ff78 	bl	802231c <_Z41__static_initialization_and_destruction_0ii>
 802242c:	bd80      	pop	{r7, pc}
 802242e:	bf00      	nop

08022430 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8022430:	b480      	push	{r7}
 8022432:	af00      	add	r7, sp, #0
}
 8022434:	46bd      	mov	sp, r7
 8022436:	bc80      	pop	{r7}
 8022438:	4770      	bx	lr
 802243a:	bf00      	nop

0802243c <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 802243c:	b480      	push	{r7}
 802243e:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {}
 8022440:	e7fe      	b.n	8022440 <HardFault_Handler+0x4>
 8022442:	bf00      	nop

08022444 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8022444:	b480      	push	{r7}
 8022446:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {}
 8022448:	e7fe      	b.n	8022448 <MemManage_Handler+0x4>
 802244a:	bf00      	nop

0802244c <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 802244c:	b480      	push	{r7}
 802244e:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {}
 8022450:	e7fe      	b.n	8022450 <BusFault_Handler+0x4>
 8022452:	bf00      	nop

08022454 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8022454:	b480      	push	{r7}
 8022456:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {}
 8022458:	e7fe      	b.n	8022458 <UsageFault_Handler+0x4>
 802245a:	bf00      	nop

0802245c <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{}
 802245c:	b480      	push	{r7}
 802245e:	af00      	add	r7, sp, #0
 8022460:	46bd      	mov	sp, r7
 8022462:	bc80      	pop	{r7}
 8022464:	4770      	bx	lr
 8022466:	bf00      	nop

08022468 <EXTI1_IRQHandler>:
 * 			Triggers Event on mechanical shock, good as "Snoozze" Button :D
 * @param  None
 * @retval None
 */
void EXTI1_IRQHandler(void)
{
 8022468:	b580      	push	{r7, lr}
 802246a:	b082      	sub	sp, #8
 802246c:	af00      	add	r7, sp, #0
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 802246e:	f04f 0300 	mov.w	r3, #0
 8022472:	607b      	str	r3, [r7, #4]

	/* Check the click on the accelerometer to Pause/Resume Playing */
	if(EXTI_GetITStatus(EXTI_Line1) != RESET)
 8022474:	f04f 0002 	mov.w	r0, #2
 8022478:	f7e4 ff28 	bl	80072cc <EXTI_GetITStatus>
 802247c:	4603      	mov	r3, r0
 802247e:	2b00      	cmp	r3, #0
 8022480:	d017      	beq.n	80224b2 <EXTI1_IRQHandler+0x4a>
	{
		/*give sem in FreeRTOS */
		xSemaphoreGiveFromISR(semShock,&xHigherPriorityTaskWoken);
 8022482:	f241 03f8 	movw	r3, #4344	; 0x10f8
 8022486:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802248a:	681a      	ldr	r2, [r3, #0]
 802248c:	f107 0304 	add.w	r3, r7, #4
 8022490:	4610      	mov	r0, r2
 8022492:	f04f 0100 	mov.w	r1, #0
 8022496:	461a      	mov	r2, r3
 8022498:	f04f 0300 	mov.w	r3, #0
 802249c:	f7f7 fe26 	bl	801a0ec <xQueueGenericSendFromISR>

		/* Clear the EXTI line 1 pending bit */
		EXTI_ClearITPendingBit(EXTI_Line1);
 80224a0:	f04f 0002 	mov.w	r0, #2
 80224a4:	f7e4 ff40 	bl	8007328 <EXTI_ClearITPendingBit>
		/*
		 * triggers PendSV handler for context switch
		 * but when DMA Handler has higher Priority
		 * this has no effect until ISR is finished
		 */
		portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
 80224a8:	687b      	ldr	r3, [r7, #4]
 80224aa:	2b00      	cmp	r3, #0
 80224ac:	d001      	beq.n	80224b2 <EXTI1_IRQHandler+0x4a>
 80224ae:	f7f7 fb71 	bl	8019b94 <vPortYieldFromISR>
	}
}
 80224b2:	f107 0708 	add.w	r7, r7, #8
 80224b6:	46bd      	mov	sp, r7
 80224b8:	bd80      	pop	{r7, pc}
 80224ba:	bf00      	nop

080224bc <EXTI0_IRQHandler>:
 *         This function handles External line 0 interrupt request.
 * @param  None
 * @retval None
 */
void EXTI0_IRQHandler(void)
{
 80224bc:	b580      	push	{r7, lr}
 80224be:	b082      	sub	sp, #8
 80224c0:	af00      	add	r7, sp, #0
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 80224c2:	f04f 0300 	mov.w	r3, #0
 80224c6:	607b      	str	r3, [r7, #4]

	/* Checks whether the User Button EXTI line is asserted*/
	if (EXTI_GetITStatus(EXTI_Line0) != RESET)
 80224c8:	f04f 0001 	mov.w	r0, #1
 80224cc:	f7e4 fefe 	bl	80072cc <EXTI_GetITStatus>
 80224d0:	4603      	mov	r3, r0
 80224d2:	2b00      	cmp	r3, #0
 80224d4:	d017      	beq.n	8022506 <EXTI0_IRQHandler+0x4a>
	{
		/*give sem in FreeRTOS */
		xSemaphoreGiveFromISR(semUserButton,&xHigherPriorityTaskWoken);
 80224d6:	f241 03f4 	movw	r3, #4340	; 0x10f4
 80224da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80224de:	681a      	ldr	r2, [r3, #0]
 80224e0:	f107 0304 	add.w	r3, r7, #4
 80224e4:	4610      	mov	r0, r2
 80224e6:	f04f 0100 	mov.w	r1, #0
 80224ea:	461a      	mov	r2, r3
 80224ec:	f04f 0300 	mov.w	r3, #0
 80224f0:	f7f7 fdfc 	bl	801a0ec <xQueueGenericSendFromISR>

		/* Clear the EXTI line 1 pending bit */
		EXTI_ClearITPendingBit(EXTI_Line1);
 80224f4:	f04f 0002 	mov.w	r0, #2
 80224f8:	f7e4 ff16 	bl	8007328 <EXTI_ClearITPendingBit>
		/*
		 * triggers PendSV handler for context switch
		 * but when DMA Handler has higher Priority
		 * this has no effect until ISR is finished
		 */
		portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
 80224fc:	687b      	ldr	r3, [r7, #4]
 80224fe:	2b00      	cmp	r3, #0
 8022500:	d001      	beq.n	8022506 <EXTI0_IRQHandler+0x4a>
 8022502:	f7f7 fb47 	bl	8019b94 <vPortYieldFromISR>
	}

	/* Clears the EXTI's line pending bit.*/
	EXTI_ClearITPendingBit(EXTI_Line0);
 8022506:	f04f 0001 	mov.w	r0, #1
 802250a:	f7e4 ff0d 	bl	8007328 <EXTI_ClearITPendingBit>
}
 802250e:	f107 0708 	add.w	r7, r7, #8
 8022512:	46bd      	mov	sp, r7
 8022514:	bd80      	pop	{r7, pc}
 8022516:	bf00      	nop

08022518 <OTG_FS_IRQHandler>:
 * @brief  This function handles USB-On-The-Go FS global interrupt request.
 * @param  None
 * @retval None
 */
void OTG_FS_IRQHandler(void)
{
 8022518:	b580      	push	{r7, lr}
 802251a:	af00      	add	r7, sp, #0
	USBH_OTG_ISR_Handler(&USB_OTG_Core);
 802251c:	f640 30b4 	movw	r0, #2996	; 0xbb4
 8022520:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8022524:	f7df f908 	bl	8001738 <USBH_OTG_ISR_Handler>
}
 8022528:	bd80      	pop	{r7, pc}
 802252a:	bf00      	nop

0802252c <_exit>:

size_t   __malloc_margin = 256;
char    *__brkval;

void _exit(int code)
{
 802252c:	b480      	push	{r7}
 802252e:	b083      	sub	sp, #12
 8022530:	af00      	add	r7, sp, #0
 8022532:	6078      	str	r0, [r7, #4]
    for (;;);
 8022534:	e7fe      	b.n	8022534 <_exit+0x8>
 8022536:	bf00      	nop

08022538 <_read_r>:
}


ssize_t _read_r(struct _reent *r, int fd, void *ptr, size_t len)
{
 8022538:	b480      	push	{r7}
 802253a:	b085      	sub	sp, #20
 802253c:	af00      	add	r7, sp, #0
 802253e:	60f8      	str	r0, [r7, #12]
 8022540:	60b9      	str	r1, [r7, #8]
 8022542:	607a      	str	r2, [r7, #4]
 8022544:	603b      	str	r3, [r7, #0]
    //return uart_read_r(r, fd, ptr, len);
	/**
	 * printf mapping function
	 */
	return 0;
 8022546:	f04f 0300 	mov.w	r3, #0
}
 802254a:	4618      	mov	r0, r3
 802254c:	f107 0714 	add.w	r7, r7, #20
 8022550:	46bd      	mov	sp, r7
 8022552:	bc80      	pop	{r7}
 8022554:	4770      	bx	lr
 8022556:	bf00      	nop

08022558 <_write_r>:


ssize_t _write_r(struct _reent *r, int fd, const void *ptr, size_t len)
{
 8022558:	b480      	push	{r7}
 802255a:	b085      	sub	sp, #20
 802255c:	af00      	add	r7, sp, #0
 802255e:	60f8      	str	r0, [r7, #12]
 8022560:	60b9      	str	r1, [r7, #8]
 8022562:	607a      	str	r2, [r7, #4]
 8022564:	603b      	str	r3, [r7, #0]
    //return uart_write_r(r, fd, ptr, len);
	/**
	 * printf maping function
	 */
	return 0;
 8022566:	f04f 0300 	mov.w	r3, #0
}
 802256a:	4618      	mov	r0, r3
 802256c:	f107 0714 	add.w	r7, r7, #20
 8022570:	46bd      	mov	sp, r7
 8022572:	bc80      	pop	{r7}
 8022574:	4770      	bx	lr
 8022576:	bf00      	nop

08022578 <_lseek_r>:


off_t _lseek_r(struct _reent *r, int fd, _off_t ptr, int dir)
{
 8022578:	b480      	push	{r7}
 802257a:	b085      	sub	sp, #20
 802257c:	af00      	add	r7, sp, #0
 802257e:	60f8      	str	r0, [r7, #12]
 8022580:	60b9      	str	r1, [r7, #8]
 8022582:	607a      	str	r2, [r7, #4]
 8022584:	603b      	str	r3, [r7, #0]

    r->_errno = ENOSYS;
 8022586:	68fb      	ldr	r3, [r7, #12]
 8022588:	f04f 0258 	mov.w	r2, #88	; 0x58
 802258c:	601a      	str	r2, [r3, #0]
    return -1;
 802258e:	f04f 33ff 	mov.w	r3, #4294967295
}
 8022592:	4618      	mov	r0, r3
 8022594:	f107 0714 	add.w	r7, r7, #20
 8022598:	46bd      	mov	sp, r7
 802259a:	bc80      	pop	{r7}
 802259c:	4770      	bx	lr
 802259e:	bf00      	nop

080225a0 <_close_r>:


int _close_r(struct _reent *r, int fd)
{
 80225a0:	b480      	push	{r7}
 80225a2:	b083      	sub	sp, #12
 80225a4:	af00      	add	r7, sp, #0
 80225a6:	6078      	str	r0, [r7, #4]
 80225a8:	6039      	str	r1, [r7, #0]
    r->_errno = ENOSYS;
 80225aa:	687b      	ldr	r3, [r7, #4]
 80225ac:	f04f 0258 	mov.w	r2, #88	; 0x58
 80225b0:	601a      	str	r2, [r3, #0]
    return -1;
 80225b2:	f04f 33ff 	mov.w	r3, #4294967295
}
 80225b6:	4618      	mov	r0, r3
 80225b8:	f107 070c 	add.w	r7, r7, #12
 80225bc:	46bd      	mov	sp, r7
 80225be:	bc80      	pop	{r7}
 80225c0:	4770      	bx	lr
 80225c2:	bf00      	nop

080225c4 <_fstat_r>:


int _fstat_r(struct _reent *r, int fd, struct stat *st)
{
 80225c4:	b480      	push	{r7}
 80225c6:	b085      	sub	sp, #20
 80225c8:	af00      	add	r7, sp, #0
 80225ca:	60f8      	str	r0, [r7, #12]
 80225cc:	60b9      	str	r1, [r7, #8]
 80225ce:	607a      	str	r2, [r7, #4]
    if ((fd >= STDIN_FILENO) && (fd <= STDERR_FILENO)) {
 80225d0:	68bb      	ldr	r3, [r7, #8]
 80225d2:	2b00      	cmp	r3, #0
 80225d4:	db09      	blt.n	80225ea <_fstat_r+0x26>
 80225d6:	68bb      	ldr	r3, [r7, #8]
 80225d8:	2b02      	cmp	r3, #2
 80225da:	dc06      	bgt.n	80225ea <_fstat_r+0x26>
      st->st_mode = S_IFCHR;
 80225dc:	687b      	ldr	r3, [r7, #4]
 80225de:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80225e2:	605a      	str	r2, [r3, #4]
      return 0;
 80225e4:	f04f 0300 	mov.w	r3, #0
 80225e8:	e005      	b.n	80225f6 <_fstat_r+0x32>
    }

    r->_errno = ENOSYS;
 80225ea:	68fb      	ldr	r3, [r7, #12]
 80225ec:	f04f 0258 	mov.w	r2, #88	; 0x58
 80225f0:	601a      	str	r2, [r3, #0]
    return -1;
 80225f2:	f04f 33ff 	mov.w	r3, #4294967295
}
 80225f6:	4618      	mov	r0, r3
 80225f8:	f107 0714 	add.w	r7, r7, #20
 80225fc:	46bd      	mov	sp, r7
 80225fe:	bc80      	pop	{r7}
 8022600:	4770      	bx	lr
 8022602:	bf00      	nop

08022604 <_isatty_r>:


int _isatty_r(struct _reent *r, int fd)
{
 8022604:	b480      	push	{r7}
 8022606:	b083      	sub	sp, #12
 8022608:	af00      	add	r7, sp, #0
 802260a:	6078      	str	r0, [r7, #4]
 802260c:	6039      	str	r1, [r7, #0]
    return 1;
 802260e:	f04f 0301 	mov.w	r3, #1
}
 8022612:	4618      	mov	r0, r3
 8022614:	f107 070c 	add.w	r7, r7, #12
 8022618:	46bd      	mov	sp, r7
 802261a:	bc80      	pop	{r7}
 802261c:	4770      	bx	lr
 802261e:	bf00      	nop

08022620 <_kill_r>:
    return ret;
}*/


int _kill_r(struct _reent *r, int pid, int signal)
{
 8022620:	b480      	push	{r7}
 8022622:	b085      	sub	sp, #20
 8022624:	af00      	add	r7, sp, #0
 8022626:	60f8      	str	r0, [r7, #12]
 8022628:	60b9      	str	r1, [r7, #8]
 802262a:	607a      	str	r2, [r7, #4]
    r->_errno = ENOSYS;
 802262c:	68fb      	ldr	r3, [r7, #12]
 802262e:	f04f 0258 	mov.w	r2, #88	; 0x58
 8022632:	601a      	str	r2, [r3, #0]
    return -1;
 8022634:	f04f 33ff 	mov.w	r3, #4294967295
}
 8022638:	4618      	mov	r0, r3
 802263a:	f107 0714 	add.w	r7, r7, #20
 802263e:	46bd      	mov	sp, r7
 8022640:	bc80      	pop	{r7}
 8022642:	4770      	bx	lr

08022644 <_getpid_r>:


int _getpid_r(struct _reent *r)
{
 8022644:	b480      	push	{r7}
 8022646:	b083      	sub	sp, #12
 8022648:	af00      	add	r7, sp, #0
 802264a:	6078      	str	r0, [r7, #4]
    r->_errno = ENOSYS;
 802264c:	687b      	ldr	r3, [r7, #4]
 802264e:	f04f 0258 	mov.w	r2, #88	; 0x58
 8022652:	601a      	str	r2, [r3, #0]
    return -1;
 8022654:	f04f 33ff 	mov.w	r3, #4294967295
}
 8022658:	4618      	mov	r0, r3
 802265a:	f107 070c 	add.w	r7, r7, #12
 802265e:	46bd      	mov	sp, r7
 8022660:	bc80      	pop	{r7}
 8022662:	4770      	bx	lr

08022664 <__malloc_lock>:


void __malloc_lock(struct _reent *r)
{
 8022664:	b580      	push	{r7, lr}
 8022666:	b082      	sub	sp, #8
 8022668:	af00      	add	r7, sp, #0
 802266a:	6078      	str	r0, [r7, #4]
    vPortEnterCritical();
 802266c:	f7f7 fa9e 	bl	8019bac <vPortEnterCritical>
}
 8022670:	f107 0708 	add.w	r7, r7, #8
 8022674:	46bd      	mov	sp, r7
 8022676:	bd80      	pop	{r7, pc}

08022678 <__malloc_unlock>:


void __malloc_unlock(struct _reent *r)
{
 8022678:	b580      	push	{r7, lr}
 802267a:	b082      	sub	sp, #8
 802267c:	af00      	add	r7, sp, #0
 802267e:	6078      	str	r0, [r7, #4]
    vPortExitCritical();
 8022680:	f7f7 faaa 	bl	8019bd8 <vPortExitCritical>
}
 8022684:	f107 0708 	add.w	r7, r7, #8
 8022688:	46bd      	mov	sp, r7
 802268a:	bd80      	pop	{r7, pc}

0802268c <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 802268c:	b580      	push	{r7, lr}
 802268e:	af00      	add	r7, sp, #0
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8022690:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022694:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022698:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 802269c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80226a0:	6812      	ldr	r2, [r2, #0]
 80226a2:	f042 0201 	orr.w	r2, r2, #1
 80226a6:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80226a8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80226ac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80226b0:	f04f 0200 	mov.w	r2, #0
 80226b4:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80226b6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80226ba:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80226be:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80226c2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80226c6:	6812      	ldr	r2, [r2, #0]
 80226c8:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80226cc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80226d0:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80226d2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80226d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80226da:	f243 0210 	movw	r2, #12304	; 0x3010
 80226de:	f2c2 4200 	movt	r2, #9216	; 0x2400
 80226e2:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80226e4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80226e8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80226ec:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80226f0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80226f4:	6812      	ldr	r2, [r2, #0]
 80226f6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80226fa:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80226fc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022700:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022704:	f04f 0200 	mov.w	r2, #0
 8022708:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 802270a:	f000 f8c3 	bl	8022894 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 802270e:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8022712:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8022716:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 802271a:	609a      	str	r2, [r3, #8]
#endif
}
 802271c:	bd80      	pop	{r7, pc}
 802271e:	bf00      	nop

08022720 <SystemCoreClockUpdate>:
  *     
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 8022720:	b480      	push	{r7}
 8022722:	b087      	sub	sp, #28
 8022724:	af00      	add	r7, sp, #0
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 8022726:	f04f 0300 	mov.w	r3, #0
 802272a:	613b      	str	r3, [r7, #16]
 802272c:	f04f 0300 	mov.w	r3, #0
 8022730:	617b      	str	r3, [r7, #20]
 8022732:	f04f 0302 	mov.w	r3, #2
 8022736:	60fb      	str	r3, [r7, #12]
 8022738:	f04f 0300 	mov.w	r3, #0
 802273c:	60bb      	str	r3, [r7, #8]
 802273e:	f04f 0302 	mov.w	r3, #2
 8022742:	607b      	str	r3, [r7, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8022744:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022748:	f2c4 0302 	movt	r3, #16386	; 0x4002
 802274c:	689b      	ldr	r3, [r3, #8]
 802274e:	f003 030c 	and.w	r3, r3, #12
 8022752:	613b      	str	r3, [r7, #16]

  switch (tmp)
 8022754:	693b      	ldr	r3, [r7, #16]
 8022756:	2b04      	cmp	r3, #4
 8022758:	d00d      	beq.n	8022776 <SystemCoreClockUpdate+0x56>
 802275a:	2b08      	cmp	r3, #8
 802275c:	d015      	beq.n	802278a <SystemCoreClockUpdate+0x6a>
 802275e:	2b00      	cmp	r3, #0
 8022760:	d16b      	bne.n	802283a <SystemCoreClockUpdate+0x11a>
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 8022762:	f240 03d0 	movw	r3, #208	; 0xd0
 8022766:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802276a:	f44f 5210 	mov.w	r2, #9216	; 0x2400
 802276e:	f2c0 02f4 	movt	r2, #244	; 0xf4
 8022772:	601a      	str	r2, [r3, #0]
      break;
 8022774:	e06b      	b.n	802284e <SystemCoreClockUpdate+0x12e>
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 8022776:	f240 03d0 	movw	r3, #208	; 0xd0
 802277a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802277e:	f44f 5290 	mov.w	r2, #4608	; 0x1200
 8022782:	f2c0 027a 	movt	r2, #122	; 0x7a
 8022786:	601a      	str	r2, [r3, #0]
      break;
 8022788:	e061      	b.n	802284e <SystemCoreClockUpdate+0x12e>
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 802278a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 802278e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022792:	685b      	ldr	r3, [r3, #4]
 8022794:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8022798:	ea4f 5393 	mov.w	r3, r3, lsr #22
 802279c:	60bb      	str	r3, [r7, #8]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 802279e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80227a2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80227a6:	685b      	ldr	r3, [r3, #4]
 80227a8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80227ac:	607b      	str	r3, [r7, #4]
      
      if (pllsource != 0)
 80227ae:	68bb      	ldr	r3, [r7, #8]
 80227b0:	2b00      	cmp	r3, #0
 80227b2:	d015      	beq.n	80227e0 <SystemCoreClockUpdate+0xc0>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 80227b4:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 80227b8:	f2c0 037a 	movt	r3, #122	; 0x7a
 80227bc:	687a      	ldr	r2, [r7, #4]
 80227be:	fbb3 f2f2 	udiv	r2, r3, r2
 80227c2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80227c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80227ca:	685b      	ldr	r3, [r3, #4]
 80227cc:	4619      	mov	r1, r3
 80227ce:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80227d2:	400b      	ands	r3, r1
 80227d4:	ea4f 1393 	mov.w	r3, r3, lsr #6
 80227d8:	fb03 f302 	mul.w	r3, r3, r2
 80227dc:	617b      	str	r3, [r7, #20]
 80227de:	e014      	b.n	802280a <SystemCoreClockUpdate+0xea>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 80227e0:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 80227e4:	f2c0 03f4 	movt	r3, #244	; 0xf4
 80227e8:	687a      	ldr	r2, [r7, #4]
 80227ea:	fbb3 f2f2 	udiv	r2, r3, r2
 80227ee:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80227f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80227f6:	685b      	ldr	r3, [r3, #4]
 80227f8:	4619      	mov	r1, r3
 80227fa:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80227fe:	400b      	ands	r3, r1
 8022800:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8022804:	fb03 f302 	mul.w	r3, r3, r2
 8022808:	617b      	str	r3, [r7, #20]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 802280a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 802280e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022812:	685b      	ldr	r3, [r3, #4]
 8022814:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8022818:	ea4f 4313 	mov.w	r3, r3, lsr #16
 802281c:	f103 0301 	add.w	r3, r3, #1
 8022820:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8022824:	60fb      	str	r3, [r7, #12]
      SystemCoreClock = pllvco/pllp;
 8022826:	697a      	ldr	r2, [r7, #20]
 8022828:	68fb      	ldr	r3, [r7, #12]
 802282a:	fbb2 f2f3 	udiv	r2, r2, r3
 802282e:	f240 03d0 	movw	r3, #208	; 0xd0
 8022832:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022836:	601a      	str	r2, [r3, #0]
      break;
 8022838:	e009      	b.n	802284e <SystemCoreClockUpdate+0x12e>
    default:
      SystemCoreClock = HSI_VALUE;
 802283a:	f240 03d0 	movw	r3, #208	; 0xd0
 802283e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022842:	f44f 5210 	mov.w	r2, #9216	; 0x2400
 8022846:	f2c0 02f4 	movt	r2, #244	; 0xf4
 802284a:	601a      	str	r2, [r3, #0]
      break;
 802284c:	bf00      	nop
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 802284e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022852:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022856:	689b      	ldr	r3, [r3, #8]
 8022858:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 802285c:	ea4f 1213 	mov.w	r2, r3, lsr #4
 8022860:	f240 03d4 	movw	r3, #212	; 0xd4
 8022864:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022868:	5c9b      	ldrb	r3, [r3, r2]
 802286a:	b2db      	uxtb	r3, r3
 802286c:	613b      	str	r3, [r7, #16]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 802286e:	f240 03d0 	movw	r3, #208	; 0xd0
 8022872:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022876:	681a      	ldr	r2, [r3, #0]
 8022878:	693b      	ldr	r3, [r7, #16]
 802287a:	fa22 f203 	lsr.w	r2, r2, r3
 802287e:	f240 03d0 	movw	r3, #208	; 0xd0
 8022882:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022886:	601a      	str	r2, [r3, #0]
}
 8022888:	f107 071c 	add.w	r7, r7, #28
 802288c:	46bd      	mov	sp, r7
 802288e:	bc80      	pop	{r7}
 8022890:	4770      	bx	lr
 8022892:	bf00      	nop

08022894 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8022894:	b480      	push	{r7}
 8022896:	b083      	sub	sp, #12
 8022898:	af00      	add	r7, sp, #0
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 802289a:	f04f 0300 	mov.w	r3, #0
 802289e:	607b      	str	r3, [r7, #4]
 80228a0:	f04f 0300 	mov.w	r3, #0
 80228a4:	603b      	str	r3, [r7, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 80228a6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80228aa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80228ae:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80228b2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80228b6:	6812      	ldr	r2, [r2, #0]
 80228b8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80228bc:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80228be:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80228c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80228c6:	681b      	ldr	r3, [r3, #0]
 80228c8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80228cc:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 80228ce:	687b      	ldr	r3, [r7, #4]
 80228d0:	f103 0301 	add.w	r3, r3, #1
 80228d4:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80228d6:	683b      	ldr	r3, [r7, #0]
 80228d8:	2b00      	cmp	r3, #0
 80228da:	d103      	bne.n	80228e4 <SetSysClock+0x50>
 80228dc:	687b      	ldr	r3, [r7, #4]
 80228de:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80228e2:	d1ec      	bne.n	80228be <SetSysClock+0x2a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80228e4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80228e8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80228ec:	681b      	ldr	r3, [r3, #0]
 80228ee:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80228f2:	2b00      	cmp	r3, #0
 80228f4:	d003      	beq.n	80228fe <SetSysClock+0x6a>
  {
    HSEStatus = (uint32_t)0x01;
 80228f6:	f04f 0301 	mov.w	r3, #1
 80228fa:	603b      	str	r3, [r7, #0]
 80228fc:	e002      	b.n	8022904 <SetSysClock+0x70>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80228fe:	f04f 0300 	mov.w	r3, #0
 8022902:	603b      	str	r3, [r7, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 8022904:	683b      	ldr	r3, [r7, #0]
 8022906:	2b01      	cmp	r3, #1
 8022908:	f040 8082 	bne.w	8022a10 <SetSysClock+0x17c>
  {
    /* Enable high performance mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 802290c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022910:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022914:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8022918:	f2c4 0202 	movt	r2, #16386	; 0x4002
 802291c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 802291e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8022922:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_PMODE;  
 8022924:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8022928:	f2c4 0300 	movt	r3, #16384	; 0x4000
 802292c:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8022930:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8022934:	6812      	ldr	r2, [r2, #0]
 8022936:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 802293a:	601a      	str	r2, [r3, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 802293c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022940:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022944:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8022948:	f2c4 0202 	movt	r2, #16386	; 0x4002
 802294c:	6892      	ldr	r2, [r2, #8]
 802294e:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8022950:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022954:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022958:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 802295c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8022960:	6892      	ldr	r2, [r2, #8]
 8022962:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8022966:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8022968:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 802296c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022970:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8022974:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8022978:	6892      	ldr	r2, [r2, #8]
 802297a:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 802297e:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8022980:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022984:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022988:	f245 4208 	movw	r2, #21512	; 0x5408
 802298c:	f2c0 7240 	movt	r2, #1856	; 0x740
 8022990:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 8022992:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022996:	f2c4 0302 	movt	r3, #16386	; 0x4002
 802299a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 802299e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80229a2:	6812      	ldr	r2, [r2, #0]
 80229a4:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80229a8:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 80229aa:	bf00      	nop
 80229ac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80229b0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80229b4:	681b      	ldr	r3, [r3, #0]
 80229b6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80229ba:	2b00      	cmp	r3, #0
 80229bc:	d0f6      	beq.n	80229ac <SetSysClock+0x118>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 80229be:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80229c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80229c6:	f240 6205 	movw	r2, #1541	; 0x605
 80229ca:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80229cc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80229d0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80229d4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80229d8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80229dc:	6892      	ldr	r2, [r2, #8]
 80229de:	f022 0203 	bic.w	r2, r2, #3
 80229e2:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 80229e4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80229e8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80229ec:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80229f0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80229f4:	6892      	ldr	r2, [r2, #8]
 80229f6:	f042 0202 	orr.w	r2, r2, #2
 80229fa:	609a      	str	r2, [r3, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 80229fc:	bf00      	nop
 80229fe:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022a02:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022a06:	689b      	ldr	r3, [r3, #8]
 8022a08:	f003 030c 	and.w	r3, r3, #12
 8022a0c:	2b08      	cmp	r3, #8
 8022a0e:	d1f6      	bne.n	80229fe <SetSysClock+0x16a>

/******************************************************************************/
/*                        I2S clock configuration                             */
/******************************************************************************/
  /* PLLI2S clock used as I2S clock source */
  RCC->CFGR &= ~RCC_CFGR_I2SSRC;
 8022a10:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022a14:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022a18:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8022a1c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8022a20:	6892      	ldr	r2, [r2, #8]
 8022a22:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8022a26:	609a      	str	r2, [r3, #8]

  /* Configure PLLI2S */
  RCC->PLLI2SCFGR = (PLLI2S_N << 6) | (PLLI2S_R << 28);
 8022a28:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022a2c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022a30:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8022a34:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8022a38:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Enable PLLI2S */
  RCC->CR |= ((uint32_t)RCC_CR_PLLI2SON);
 8022a3c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022a40:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022a44:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8022a48:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8022a4c:	6812      	ldr	r2, [r2, #0]
 8022a4e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8022a52:	601a      	str	r2, [r3, #0]

  /* Wait till PLLI2S is ready */
  while((RCC->CR & RCC_CR_PLLI2SRDY) == 0)
 8022a54:	bf00      	nop
 8022a56:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022a5a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022a5e:	681b      	ldr	r3, [r3, #0]
 8022a60:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8022a64:	2b00      	cmp	r3, #0
 8022a66:	d0f6      	beq.n	8022a56 <SetSysClock+0x1c2>
  {
  }
}
 8022a68:	f107 070c 	add.w	r7, r7, #12
 8022a6c:	46bd      	mov	sp, r7
 8022a6e:	bc80      	pop	{r7}
 8022a70:	4770      	bx	lr
 8022a72:	bf00      	nop

08022a74 <get_us_time>:
 *   this function must be called at least
 *   once every 65ms to work correctly.
 *
 */
uint64_t get_us_time()
{
 8022a74:	b580      	push	{r7, lr}
 8022a76:	b082      	sub	sp, #8
 8022a78:	af00      	add	r7, sp, #0
    static uint16_t t0;
    static uint64_t tickcount;

    vPortEnterCritical();
 8022a7a:	f7f7 f897 	bl	8019bac <vPortEnterCritical>

    int t = TIM7->CNT;
 8022a7e:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8022a82:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8022a86:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022a88:	607b      	str	r3, [r7, #4]
    if (t < t0)
 8022a8a:	f643 7398 	movw	r3, #16280	; 0x3f98
 8022a8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022a92:	881b      	ldrh	r3, [r3, #0]
 8022a94:	461a      	mov	r2, r3
 8022a96:	687b      	ldr	r3, [r7, #4]
 8022a98:	429a      	cmp	r2, r3
 8022a9a:	dd03      	ble.n	8022aa4 <get_us_time+0x30>
        t += 0x10000;
 8022a9c:	687b      	ldr	r3, [r7, #4]
 8022a9e:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8022aa2:	607b      	str	r3, [r7, #4]

    tickcount += t - t0;
 8022aa4:	f643 7398 	movw	r3, #16280	; 0x3f98
 8022aa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022aac:	881b      	ldrh	r3, [r3, #0]
 8022aae:	687a      	ldr	r2, [r7, #4]
 8022ab0:	1ad1      	subs	r1, r2, r3
 8022ab2:	460a      	mov	r2, r1
 8022ab4:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8022ab8:	f643 71a0 	movw	r1, #16288	; 0x3fa0
 8022abc:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8022ac0:	e9d1 0100 	ldrd	r0, r1, [r1]
 8022ac4:	1880      	adds	r0, r0, r2
 8022ac6:	eb41 0103 	adc.w	r1, r1, r3
 8022aca:	f643 73a0 	movw	r3, #16288	; 0x3fa0
 8022ace:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022ad2:	e9c3 0100 	strd	r0, r1, [r3]
    t0 = t;
 8022ad6:	687b      	ldr	r3, [r7, #4]
 8022ad8:	b29a      	uxth	r2, r3
 8022ada:	f643 7398 	movw	r3, #16280	; 0x3f98
 8022ade:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022ae2:	801a      	strh	r2, [r3, #0]

    vPortExitCritical();
 8022ae4:	f7f7 f878 	bl	8019bd8 <vPortExitCritical>

    return tickcount;
 8022ae8:	f643 73a0 	movw	r3, #16288	; 0x3fa0
 8022aec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022af0:	e9d3 2300 	ldrd	r2, r3, [r3]
}
 8022af4:	4610      	mov	r0, r2
 8022af6:	4619      	mov	r1, r3
 8022af8:	f107 0708 	add.w	r7, r7, #8
 8022afc:	46bd      	mov	sp, r7
 8022afe:	bd80      	pop	{r7, pc}

08022b00 <delay_us>:
 * \param  us  number of microseconds to wait.
 * \note   The actual delay will last between us and (us-1) microseconds.
 *         To wait _at_least_ 1 us, you should use delay_us(2).
 */
void delay_us(unsigned long us)
{
 8022b00:	b480      	push	{r7}
 8022b02:	b085      	sub	sp, #20
 8022b04:	af00      	add	r7, sp, #0
 8022b06:	6078      	str	r0, [r7, #4]
    uint16_t  t0 = TIM7->CNT;
 8022b08:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8022b0c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8022b10:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022b12:	81fb      	strh	r3, [r7, #14]
    for (;;) {
        int  t = TIM7->CNT;
 8022b14:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8022b18:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8022b1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022b1e:	60bb      	str	r3, [r7, #8]
        if (t < t0)
 8022b20:	89fa      	ldrh	r2, [r7, #14]
 8022b22:	68bb      	ldr	r3, [r7, #8]
 8022b24:	429a      	cmp	r2, r3
 8022b26:	dd03      	ble.n	8022b30 <delay_us+0x30>
            t += 0x10000;
 8022b28:	68bb      	ldr	r3, [r7, #8]
 8022b2a:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8022b2e:	60bb      	str	r3, [r7, #8]

        if (us < t - t0)
 8022b30:	89fb      	ldrh	r3, [r7, #14]
 8022b32:	68ba      	ldr	r2, [r7, #8]
 8022b34:	1ad3      	subs	r3, r2, r3
 8022b36:	461a      	mov	r2, r3
 8022b38:	687b      	ldr	r3, [r7, #4]
 8022b3a:	429a      	cmp	r2, r3
 8022b3c:	d808      	bhi.n	8022b50 <delay_us+0x50>
            return;

        us -= t - t0;
 8022b3e:	89fa      	ldrh	r2, [r7, #14]
 8022b40:	68bb      	ldr	r3, [r7, #8]
 8022b42:	1ad3      	subs	r3, r2, r3
 8022b44:	687a      	ldr	r2, [r7, #4]
 8022b46:	18d3      	adds	r3, r2, r3
 8022b48:	607b      	str	r3, [r7, #4]
        t0  = t;
 8022b4a:	68bb      	ldr	r3, [r7, #8]
 8022b4c:	81fb      	strh	r3, [r7, #14]
    }
 8022b4e:	e7e1      	b.n	8022b14 <delay_us+0x14>
        int  t = TIM7->CNT;
        if (t < t0)
            t += 0x10000;

        if (us < t - t0)
            return;
 8022b50:	bf00      	nop

        us -= t - t0;
        t0  = t;
    }
}
 8022b52:	f107 0714 	add.w	r7, r7, #20
 8022b56:	46bd      	mov	sp, r7
 8022b58:	bc80      	pop	{r7}
 8022b5a:	4770      	bx	lr

08022b5c <delay_ms>:
 * Perform a millisecond delay
 *
 * \param  ms  number of milliseconds to wait.
 */
void delay_ms(unsigned long ms)
{
 8022b5c:	b580      	push	{r7, lr}
 8022b5e:	b082      	sub	sp, #8
 8022b60:	af00      	add	r7, sp, #0
 8022b62:	6078      	str	r0, [r7, #4]
    delay_us(ms * 1000);
 8022b64:	687b      	ldr	r3, [r7, #4]
 8022b66:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8022b6a:	fb02 f303 	mul.w	r3, r2, r3
 8022b6e:	4618      	mov	r0, r3
 8022b70:	f7ff ffc6 	bl	8022b00 <delay_us>
}
 8022b74:	f107 0708 	add.w	r7, r7, #8
 8022b78:	46bd      	mov	sp, r7
 8022b7a:	bd80      	pop	{r7, pc}

08022b7c <init_us_timer>:
/**
 * Set up TIM7 as a 16bit, microsecond-timer.
 *
 */
void init_us_timer()
{
 8022b7c:	b580      	push	{r7, lr}
 8022b7e:	b084      	sub	sp, #16
 8022b80:	af00      	add	r7, sp, #0
    RCC_ClocksTypeDef RCC_Clocks;
    RCC_GetClocksFreq(&RCC_Clocks);
 8022b82:	463b      	mov	r3, r7
 8022b84:	4618      	mov	r0, r3
 8022b86:	f7e5 ff1d 	bl	80089c4 <RCC_GetClocksFreq>

    RCC->APB1ENR |= RCC_APB1Periph_TIM7;
 8022b8a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8022b8e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8022b92:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8022b96:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8022b9a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8022b9c:	f042 0220 	orr.w	r2, r2, #32
 8022ba0:	641a      	str	r2, [r3, #64]	; 0x40
    TIM7->PSC = (RCC_Clocks.PCLK2_Frequency / 1000000) - 1;
 8022ba2:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8022ba6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8022baa:	68f9      	ldr	r1, [r7, #12]
 8022bac:	f64d 6283 	movw	r2, #56963	; 0xde83
 8022bb0:	f2c4 321b 	movt	r2, #17179	; 0x431b
 8022bb4:	fba2 0201 	umull	r0, r2, r2, r1
 8022bb8:	ea4f 4292 	mov.w	r2, r2, lsr #18
 8022bbc:	b292      	uxth	r2, r2
 8022bbe:	f102 32ff 	add.w	r2, r2, #4294967295
 8022bc2:	b292      	uxth	r2, r2
 8022bc4:	851a      	strh	r2, [r3, #40]	; 0x28
    TIM7->ARR = 0xFFFF;
 8022bc6:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8022bca:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8022bce:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8022bd2:	62da      	str	r2, [r3, #44]	; 0x2c
    TIM7->CR1 = TIM_CR1_CEN;
 8022bd4:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8022bd8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8022bdc:	f04f 0201 	mov.w	r2, #1
 8022be0:	801a      	strh	r2, [r3, #0]
}
 8022be2:	f107 0710 	add.w	r7, r7, #16
 8022be6:	46bd      	mov	sp, r7
 8022be8:	bd80      	pop	{r7, pc}
 8022bea:	bf00      	nop

08022bec <__aeabi_drsub>:
 8022bec:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8022bf0:	e002      	b.n	8022bf8 <__adddf3>
 8022bf2:	bf00      	nop

08022bf4 <__aeabi_dsub>:
 8022bf4:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08022bf8 <__adddf3>:
 8022bf8:	b530      	push	{r4, r5, lr}
 8022bfa:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8022bfe:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8022c02:	ea94 0f05 	teq	r4, r5
 8022c06:	bf08      	it	eq
 8022c08:	ea90 0f02 	teqeq	r0, r2
 8022c0c:	bf1f      	itttt	ne
 8022c0e:	ea54 0c00 	orrsne.w	ip, r4, r0
 8022c12:	ea55 0c02 	orrsne.w	ip, r5, r2
 8022c16:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8022c1a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8022c1e:	f000 80e2 	beq.w	8022de6 <__adddf3+0x1ee>
 8022c22:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8022c26:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8022c2a:	bfb8      	it	lt
 8022c2c:	426d      	neglt	r5, r5
 8022c2e:	dd0c      	ble.n	8022c4a <__adddf3+0x52>
 8022c30:	442c      	add	r4, r5
 8022c32:	ea80 0202 	eor.w	r2, r0, r2
 8022c36:	ea81 0303 	eor.w	r3, r1, r3
 8022c3a:	ea82 0000 	eor.w	r0, r2, r0
 8022c3e:	ea83 0101 	eor.w	r1, r3, r1
 8022c42:	ea80 0202 	eor.w	r2, r0, r2
 8022c46:	ea81 0303 	eor.w	r3, r1, r3
 8022c4a:	2d36      	cmp	r5, #54	; 0x36
 8022c4c:	bf88      	it	hi
 8022c4e:	bd30      	pophi	{r4, r5, pc}
 8022c50:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8022c54:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8022c58:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8022c5c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8022c60:	d002      	beq.n	8022c68 <__adddf3+0x70>
 8022c62:	4240      	negs	r0, r0
 8022c64:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8022c68:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8022c6c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8022c70:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8022c74:	d002      	beq.n	8022c7c <__adddf3+0x84>
 8022c76:	4252      	negs	r2, r2
 8022c78:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8022c7c:	ea94 0f05 	teq	r4, r5
 8022c80:	f000 80a7 	beq.w	8022dd2 <__adddf3+0x1da>
 8022c84:	f1a4 0401 	sub.w	r4, r4, #1
 8022c88:	f1d5 0e20 	rsbs	lr, r5, #32
 8022c8c:	db0d      	blt.n	8022caa <__adddf3+0xb2>
 8022c8e:	fa02 fc0e 	lsl.w	ip, r2, lr
 8022c92:	fa22 f205 	lsr.w	r2, r2, r5
 8022c96:	1880      	adds	r0, r0, r2
 8022c98:	f141 0100 	adc.w	r1, r1, #0
 8022c9c:	fa03 f20e 	lsl.w	r2, r3, lr
 8022ca0:	1880      	adds	r0, r0, r2
 8022ca2:	fa43 f305 	asr.w	r3, r3, r5
 8022ca6:	4159      	adcs	r1, r3
 8022ca8:	e00e      	b.n	8022cc8 <__adddf3+0xd0>
 8022caa:	f1a5 0520 	sub.w	r5, r5, #32
 8022cae:	f10e 0e20 	add.w	lr, lr, #32
 8022cb2:	2a01      	cmp	r2, #1
 8022cb4:	fa03 fc0e 	lsl.w	ip, r3, lr
 8022cb8:	bf28      	it	cs
 8022cba:	f04c 0c02 	orrcs.w	ip, ip, #2
 8022cbe:	fa43 f305 	asr.w	r3, r3, r5
 8022cc2:	18c0      	adds	r0, r0, r3
 8022cc4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8022cc8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8022ccc:	d507      	bpl.n	8022cde <__adddf3+0xe6>
 8022cce:	f04f 0e00 	mov.w	lr, #0
 8022cd2:	f1dc 0c00 	rsbs	ip, ip, #0
 8022cd6:	eb7e 0000 	sbcs.w	r0, lr, r0
 8022cda:	eb6e 0101 	sbc.w	r1, lr, r1
 8022cde:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8022ce2:	d31b      	bcc.n	8022d1c <__adddf3+0x124>
 8022ce4:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8022ce8:	d30c      	bcc.n	8022d04 <__adddf3+0x10c>
 8022cea:	0849      	lsrs	r1, r1, #1
 8022cec:	ea5f 0030 	movs.w	r0, r0, rrx
 8022cf0:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8022cf4:	f104 0401 	add.w	r4, r4, #1
 8022cf8:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8022cfc:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8022d00:	f080 809a 	bcs.w	8022e38 <__adddf3+0x240>
 8022d04:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8022d08:	bf08      	it	eq
 8022d0a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8022d0e:	f150 0000 	adcs.w	r0, r0, #0
 8022d12:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8022d16:	ea41 0105 	orr.w	r1, r1, r5
 8022d1a:	bd30      	pop	{r4, r5, pc}
 8022d1c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8022d20:	4140      	adcs	r0, r0
 8022d22:	eb41 0101 	adc.w	r1, r1, r1
 8022d26:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8022d2a:	f1a4 0401 	sub.w	r4, r4, #1
 8022d2e:	d1e9      	bne.n	8022d04 <__adddf3+0x10c>
 8022d30:	f091 0f00 	teq	r1, #0
 8022d34:	bf04      	itt	eq
 8022d36:	4601      	moveq	r1, r0
 8022d38:	2000      	moveq	r0, #0
 8022d3a:	fab1 f381 	clz	r3, r1
 8022d3e:	bf08      	it	eq
 8022d40:	3320      	addeq	r3, #32
 8022d42:	f1a3 030b 	sub.w	r3, r3, #11
 8022d46:	f1b3 0220 	subs.w	r2, r3, #32
 8022d4a:	da0c      	bge.n	8022d66 <__adddf3+0x16e>
 8022d4c:	320c      	adds	r2, #12
 8022d4e:	dd08      	ble.n	8022d62 <__adddf3+0x16a>
 8022d50:	f102 0c14 	add.w	ip, r2, #20
 8022d54:	f1c2 020c 	rsb	r2, r2, #12
 8022d58:	fa01 f00c 	lsl.w	r0, r1, ip
 8022d5c:	fa21 f102 	lsr.w	r1, r1, r2
 8022d60:	e00c      	b.n	8022d7c <__adddf3+0x184>
 8022d62:	f102 0214 	add.w	r2, r2, #20
 8022d66:	bfd8      	it	le
 8022d68:	f1c2 0c20 	rsble	ip, r2, #32
 8022d6c:	fa01 f102 	lsl.w	r1, r1, r2
 8022d70:	fa20 fc0c 	lsr.w	ip, r0, ip
 8022d74:	bfdc      	itt	le
 8022d76:	ea41 010c 	orrle.w	r1, r1, ip
 8022d7a:	4090      	lslle	r0, r2
 8022d7c:	1ae4      	subs	r4, r4, r3
 8022d7e:	bfa2      	ittt	ge
 8022d80:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8022d84:	4329      	orrge	r1, r5
 8022d86:	bd30      	popge	{r4, r5, pc}
 8022d88:	ea6f 0404 	mvn.w	r4, r4
 8022d8c:	3c1f      	subs	r4, #31
 8022d8e:	da1c      	bge.n	8022dca <__adddf3+0x1d2>
 8022d90:	340c      	adds	r4, #12
 8022d92:	dc0e      	bgt.n	8022db2 <__adddf3+0x1ba>
 8022d94:	f104 0414 	add.w	r4, r4, #20
 8022d98:	f1c4 0220 	rsb	r2, r4, #32
 8022d9c:	fa20 f004 	lsr.w	r0, r0, r4
 8022da0:	fa01 f302 	lsl.w	r3, r1, r2
 8022da4:	ea40 0003 	orr.w	r0, r0, r3
 8022da8:	fa21 f304 	lsr.w	r3, r1, r4
 8022dac:	ea45 0103 	orr.w	r1, r5, r3
 8022db0:	bd30      	pop	{r4, r5, pc}
 8022db2:	f1c4 040c 	rsb	r4, r4, #12
 8022db6:	f1c4 0220 	rsb	r2, r4, #32
 8022dba:	fa20 f002 	lsr.w	r0, r0, r2
 8022dbe:	fa01 f304 	lsl.w	r3, r1, r4
 8022dc2:	ea40 0003 	orr.w	r0, r0, r3
 8022dc6:	4629      	mov	r1, r5
 8022dc8:	bd30      	pop	{r4, r5, pc}
 8022dca:	fa21 f004 	lsr.w	r0, r1, r4
 8022dce:	4629      	mov	r1, r5
 8022dd0:	bd30      	pop	{r4, r5, pc}
 8022dd2:	f094 0f00 	teq	r4, #0
 8022dd6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8022dda:	bf06      	itte	eq
 8022ddc:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8022de0:	3401      	addeq	r4, #1
 8022de2:	3d01      	subne	r5, #1
 8022de4:	e74e      	b.n	8022c84 <__adddf3+0x8c>
 8022de6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8022dea:	bf18      	it	ne
 8022dec:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8022df0:	d029      	beq.n	8022e46 <__adddf3+0x24e>
 8022df2:	ea94 0f05 	teq	r4, r5
 8022df6:	bf08      	it	eq
 8022df8:	ea90 0f02 	teqeq	r0, r2
 8022dfc:	d005      	beq.n	8022e0a <__adddf3+0x212>
 8022dfe:	ea54 0c00 	orrs.w	ip, r4, r0
 8022e02:	bf04      	itt	eq
 8022e04:	4619      	moveq	r1, r3
 8022e06:	4610      	moveq	r0, r2
 8022e08:	bd30      	pop	{r4, r5, pc}
 8022e0a:	ea91 0f03 	teq	r1, r3
 8022e0e:	bf1e      	ittt	ne
 8022e10:	2100      	movne	r1, #0
 8022e12:	2000      	movne	r0, #0
 8022e14:	bd30      	popne	{r4, r5, pc}
 8022e16:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8022e1a:	d105      	bne.n	8022e28 <__adddf3+0x230>
 8022e1c:	0040      	lsls	r0, r0, #1
 8022e1e:	4149      	adcs	r1, r1
 8022e20:	bf28      	it	cs
 8022e22:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8022e26:	bd30      	pop	{r4, r5, pc}
 8022e28:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8022e2c:	bf3c      	itt	cc
 8022e2e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8022e32:	bd30      	popcc	{r4, r5, pc}
 8022e34:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8022e38:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8022e3c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8022e40:	f04f 0000 	mov.w	r0, #0
 8022e44:	bd30      	pop	{r4, r5, pc}
 8022e46:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8022e4a:	bf1a      	itte	ne
 8022e4c:	4619      	movne	r1, r3
 8022e4e:	4610      	movne	r0, r2
 8022e50:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8022e54:	bf1c      	itt	ne
 8022e56:	460b      	movne	r3, r1
 8022e58:	4602      	movne	r2, r0
 8022e5a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8022e5e:	bf06      	itte	eq
 8022e60:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8022e64:	ea91 0f03 	teqeq	r1, r3
 8022e68:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8022e6c:	bd30      	pop	{r4, r5, pc}
 8022e6e:	bf00      	nop

08022e70 <__aeabi_ui2d>:
 8022e70:	f090 0f00 	teq	r0, #0
 8022e74:	bf04      	itt	eq
 8022e76:	2100      	moveq	r1, #0
 8022e78:	4770      	bxeq	lr
 8022e7a:	b530      	push	{r4, r5, lr}
 8022e7c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8022e80:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8022e84:	f04f 0500 	mov.w	r5, #0
 8022e88:	f04f 0100 	mov.w	r1, #0
 8022e8c:	e750      	b.n	8022d30 <__adddf3+0x138>
 8022e8e:	bf00      	nop

08022e90 <__aeabi_i2d>:
 8022e90:	f090 0f00 	teq	r0, #0
 8022e94:	bf04      	itt	eq
 8022e96:	2100      	moveq	r1, #0
 8022e98:	4770      	bxeq	lr
 8022e9a:	b530      	push	{r4, r5, lr}
 8022e9c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8022ea0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8022ea4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8022ea8:	bf48      	it	mi
 8022eaa:	4240      	negmi	r0, r0
 8022eac:	f04f 0100 	mov.w	r1, #0
 8022eb0:	e73e      	b.n	8022d30 <__adddf3+0x138>
 8022eb2:	bf00      	nop

08022eb4 <__aeabi_f2d>:
 8022eb4:	0042      	lsls	r2, r0, #1
 8022eb6:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8022eba:	ea4f 0131 	mov.w	r1, r1, rrx
 8022ebe:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8022ec2:	bf1f      	itttt	ne
 8022ec4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8022ec8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8022ecc:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8022ed0:	4770      	bxne	lr
 8022ed2:	f092 0f00 	teq	r2, #0
 8022ed6:	bf14      	ite	ne
 8022ed8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8022edc:	4770      	bxeq	lr
 8022ede:	b530      	push	{r4, r5, lr}
 8022ee0:	f44f 7460 	mov.w	r4, #896	; 0x380
 8022ee4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8022ee8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8022eec:	e720      	b.n	8022d30 <__adddf3+0x138>
 8022eee:	bf00      	nop

08022ef0 <__aeabi_ul2d>:
 8022ef0:	ea50 0201 	orrs.w	r2, r0, r1
 8022ef4:	bf08      	it	eq
 8022ef6:	4770      	bxeq	lr
 8022ef8:	b530      	push	{r4, r5, lr}
 8022efa:	f04f 0500 	mov.w	r5, #0
 8022efe:	e00a      	b.n	8022f16 <__aeabi_l2d+0x16>

08022f00 <__aeabi_l2d>:
 8022f00:	ea50 0201 	orrs.w	r2, r0, r1
 8022f04:	bf08      	it	eq
 8022f06:	4770      	bxeq	lr
 8022f08:	b530      	push	{r4, r5, lr}
 8022f0a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8022f0e:	d502      	bpl.n	8022f16 <__aeabi_l2d+0x16>
 8022f10:	4240      	negs	r0, r0
 8022f12:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8022f16:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8022f1a:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8022f1e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8022f22:	f43f aedc 	beq.w	8022cde <__adddf3+0xe6>
 8022f26:	f04f 0203 	mov.w	r2, #3
 8022f2a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8022f2e:	bf18      	it	ne
 8022f30:	3203      	addne	r2, #3
 8022f32:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8022f36:	bf18      	it	ne
 8022f38:	3203      	addne	r2, #3
 8022f3a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8022f3e:	f1c2 0320 	rsb	r3, r2, #32
 8022f42:	fa00 fc03 	lsl.w	ip, r0, r3
 8022f46:	fa20 f002 	lsr.w	r0, r0, r2
 8022f4a:	fa01 fe03 	lsl.w	lr, r1, r3
 8022f4e:	ea40 000e 	orr.w	r0, r0, lr
 8022f52:	fa21 f102 	lsr.w	r1, r1, r2
 8022f56:	4414      	add	r4, r2
 8022f58:	e6c1      	b.n	8022cde <__adddf3+0xe6>
 8022f5a:	bf00      	nop

08022f5c <__aeabi_dmul>:
 8022f5c:	b570      	push	{r4, r5, r6, lr}
 8022f5e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8022f62:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8022f66:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8022f6a:	bf1d      	ittte	ne
 8022f6c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8022f70:	ea94 0f0c 	teqne	r4, ip
 8022f74:	ea95 0f0c 	teqne	r5, ip
 8022f78:	f000 f8de 	bleq	8023138 <__aeabi_dmul+0x1dc>
 8022f7c:	442c      	add	r4, r5
 8022f7e:	ea81 0603 	eor.w	r6, r1, r3
 8022f82:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8022f86:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8022f8a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8022f8e:	bf18      	it	ne
 8022f90:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8022f94:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8022f98:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8022f9c:	d038      	beq.n	8023010 <__aeabi_dmul+0xb4>
 8022f9e:	fba0 ce02 	umull	ip, lr, r0, r2
 8022fa2:	f04f 0500 	mov.w	r5, #0
 8022fa6:	fbe1 e502 	umlal	lr, r5, r1, r2
 8022faa:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8022fae:	fbe0 e503 	umlal	lr, r5, r0, r3
 8022fb2:	f04f 0600 	mov.w	r6, #0
 8022fb6:	fbe1 5603 	umlal	r5, r6, r1, r3
 8022fba:	f09c 0f00 	teq	ip, #0
 8022fbe:	bf18      	it	ne
 8022fc0:	f04e 0e01 	orrne.w	lr, lr, #1
 8022fc4:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8022fc8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8022fcc:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8022fd0:	d204      	bcs.n	8022fdc <__aeabi_dmul+0x80>
 8022fd2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8022fd6:	416d      	adcs	r5, r5
 8022fd8:	eb46 0606 	adc.w	r6, r6, r6
 8022fdc:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8022fe0:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8022fe4:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8022fe8:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8022fec:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8022ff0:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8022ff4:	bf88      	it	hi
 8022ff6:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8022ffa:	d81e      	bhi.n	802303a <__aeabi_dmul+0xde>
 8022ffc:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8023000:	bf08      	it	eq
 8023002:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8023006:	f150 0000 	adcs.w	r0, r0, #0
 802300a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802300e:	bd70      	pop	{r4, r5, r6, pc}
 8023010:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8023014:	ea46 0101 	orr.w	r1, r6, r1
 8023018:	ea40 0002 	orr.w	r0, r0, r2
 802301c:	ea81 0103 	eor.w	r1, r1, r3
 8023020:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8023024:	bfc2      	ittt	gt
 8023026:	ebd4 050c 	rsbsgt	r5, r4, ip
 802302a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 802302e:	bd70      	popgt	{r4, r5, r6, pc}
 8023030:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8023034:	f04f 0e00 	mov.w	lr, #0
 8023038:	3c01      	subs	r4, #1
 802303a:	f300 80ab 	bgt.w	8023194 <__aeabi_dmul+0x238>
 802303e:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8023042:	bfde      	ittt	le
 8023044:	2000      	movle	r0, #0
 8023046:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 802304a:	bd70      	pople	{r4, r5, r6, pc}
 802304c:	f1c4 0400 	rsb	r4, r4, #0
 8023050:	3c20      	subs	r4, #32
 8023052:	da35      	bge.n	80230c0 <__aeabi_dmul+0x164>
 8023054:	340c      	adds	r4, #12
 8023056:	dc1b      	bgt.n	8023090 <__aeabi_dmul+0x134>
 8023058:	f104 0414 	add.w	r4, r4, #20
 802305c:	f1c4 0520 	rsb	r5, r4, #32
 8023060:	fa00 f305 	lsl.w	r3, r0, r5
 8023064:	fa20 f004 	lsr.w	r0, r0, r4
 8023068:	fa01 f205 	lsl.w	r2, r1, r5
 802306c:	ea40 0002 	orr.w	r0, r0, r2
 8023070:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8023074:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8023078:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 802307c:	fa21 f604 	lsr.w	r6, r1, r4
 8023080:	eb42 0106 	adc.w	r1, r2, r6
 8023084:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8023088:	bf08      	it	eq
 802308a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802308e:	bd70      	pop	{r4, r5, r6, pc}
 8023090:	f1c4 040c 	rsb	r4, r4, #12
 8023094:	f1c4 0520 	rsb	r5, r4, #32
 8023098:	fa00 f304 	lsl.w	r3, r0, r4
 802309c:	fa20 f005 	lsr.w	r0, r0, r5
 80230a0:	fa01 f204 	lsl.w	r2, r1, r4
 80230a4:	ea40 0002 	orr.w	r0, r0, r2
 80230a8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80230ac:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80230b0:	f141 0100 	adc.w	r1, r1, #0
 80230b4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80230b8:	bf08      	it	eq
 80230ba:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80230be:	bd70      	pop	{r4, r5, r6, pc}
 80230c0:	f1c4 0520 	rsb	r5, r4, #32
 80230c4:	fa00 f205 	lsl.w	r2, r0, r5
 80230c8:	ea4e 0e02 	orr.w	lr, lr, r2
 80230cc:	fa20 f304 	lsr.w	r3, r0, r4
 80230d0:	fa01 f205 	lsl.w	r2, r1, r5
 80230d4:	ea43 0302 	orr.w	r3, r3, r2
 80230d8:	fa21 f004 	lsr.w	r0, r1, r4
 80230dc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80230e0:	fa21 f204 	lsr.w	r2, r1, r4
 80230e4:	ea20 0002 	bic.w	r0, r0, r2
 80230e8:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80230ec:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80230f0:	bf08      	it	eq
 80230f2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80230f6:	bd70      	pop	{r4, r5, r6, pc}
 80230f8:	f094 0f00 	teq	r4, #0
 80230fc:	d10f      	bne.n	802311e <__aeabi_dmul+0x1c2>
 80230fe:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8023102:	0040      	lsls	r0, r0, #1
 8023104:	eb41 0101 	adc.w	r1, r1, r1
 8023108:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802310c:	bf08      	it	eq
 802310e:	3c01      	subeq	r4, #1
 8023110:	d0f7      	beq.n	8023102 <__aeabi_dmul+0x1a6>
 8023112:	ea41 0106 	orr.w	r1, r1, r6
 8023116:	f095 0f00 	teq	r5, #0
 802311a:	bf18      	it	ne
 802311c:	4770      	bxne	lr
 802311e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8023122:	0052      	lsls	r2, r2, #1
 8023124:	eb43 0303 	adc.w	r3, r3, r3
 8023128:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 802312c:	bf08      	it	eq
 802312e:	3d01      	subeq	r5, #1
 8023130:	d0f7      	beq.n	8023122 <__aeabi_dmul+0x1c6>
 8023132:	ea43 0306 	orr.w	r3, r3, r6
 8023136:	4770      	bx	lr
 8023138:	ea94 0f0c 	teq	r4, ip
 802313c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8023140:	bf18      	it	ne
 8023142:	ea95 0f0c 	teqne	r5, ip
 8023146:	d00c      	beq.n	8023162 <__aeabi_dmul+0x206>
 8023148:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802314c:	bf18      	it	ne
 802314e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8023152:	d1d1      	bne.n	80230f8 <__aeabi_dmul+0x19c>
 8023154:	ea81 0103 	eor.w	r1, r1, r3
 8023158:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802315c:	f04f 0000 	mov.w	r0, #0
 8023160:	bd70      	pop	{r4, r5, r6, pc}
 8023162:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8023166:	bf06      	itte	eq
 8023168:	4610      	moveq	r0, r2
 802316a:	4619      	moveq	r1, r3
 802316c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8023170:	d019      	beq.n	80231a6 <__aeabi_dmul+0x24a>
 8023172:	ea94 0f0c 	teq	r4, ip
 8023176:	d102      	bne.n	802317e <__aeabi_dmul+0x222>
 8023178:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 802317c:	d113      	bne.n	80231a6 <__aeabi_dmul+0x24a>
 802317e:	ea95 0f0c 	teq	r5, ip
 8023182:	d105      	bne.n	8023190 <__aeabi_dmul+0x234>
 8023184:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8023188:	bf1c      	itt	ne
 802318a:	4610      	movne	r0, r2
 802318c:	4619      	movne	r1, r3
 802318e:	d10a      	bne.n	80231a6 <__aeabi_dmul+0x24a>
 8023190:	ea81 0103 	eor.w	r1, r1, r3
 8023194:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8023198:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 802319c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80231a0:	f04f 0000 	mov.w	r0, #0
 80231a4:	bd70      	pop	{r4, r5, r6, pc}
 80231a6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80231aa:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80231ae:	bd70      	pop	{r4, r5, r6, pc}

080231b0 <__aeabi_ddiv>:
 80231b0:	b570      	push	{r4, r5, r6, lr}
 80231b2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80231b6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80231ba:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80231be:	bf1d      	ittte	ne
 80231c0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80231c4:	ea94 0f0c 	teqne	r4, ip
 80231c8:	ea95 0f0c 	teqne	r5, ip
 80231cc:	f000 f8a7 	bleq	802331e <__aeabi_ddiv+0x16e>
 80231d0:	eba4 0405 	sub.w	r4, r4, r5
 80231d4:	ea81 0e03 	eor.w	lr, r1, r3
 80231d8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80231dc:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80231e0:	f000 8088 	beq.w	80232f4 <__aeabi_ddiv+0x144>
 80231e4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80231e8:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80231ec:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80231f0:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80231f4:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80231f8:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80231fc:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8023200:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8023204:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8023208:	429d      	cmp	r5, r3
 802320a:	bf08      	it	eq
 802320c:	4296      	cmpeq	r6, r2
 802320e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8023212:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8023216:	d202      	bcs.n	802321e <__aeabi_ddiv+0x6e>
 8023218:	085b      	lsrs	r3, r3, #1
 802321a:	ea4f 0232 	mov.w	r2, r2, rrx
 802321e:	1ab6      	subs	r6, r6, r2
 8023220:	eb65 0503 	sbc.w	r5, r5, r3
 8023224:	085b      	lsrs	r3, r3, #1
 8023226:	ea4f 0232 	mov.w	r2, r2, rrx
 802322a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 802322e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8023232:	ebb6 0e02 	subs.w	lr, r6, r2
 8023236:	eb75 0e03 	sbcs.w	lr, r5, r3
 802323a:	bf22      	ittt	cs
 802323c:	1ab6      	subcs	r6, r6, r2
 802323e:	4675      	movcs	r5, lr
 8023240:	ea40 000c 	orrcs.w	r0, r0, ip
 8023244:	085b      	lsrs	r3, r3, #1
 8023246:	ea4f 0232 	mov.w	r2, r2, rrx
 802324a:	ebb6 0e02 	subs.w	lr, r6, r2
 802324e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8023252:	bf22      	ittt	cs
 8023254:	1ab6      	subcs	r6, r6, r2
 8023256:	4675      	movcs	r5, lr
 8023258:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 802325c:	085b      	lsrs	r3, r3, #1
 802325e:	ea4f 0232 	mov.w	r2, r2, rrx
 8023262:	ebb6 0e02 	subs.w	lr, r6, r2
 8023266:	eb75 0e03 	sbcs.w	lr, r5, r3
 802326a:	bf22      	ittt	cs
 802326c:	1ab6      	subcs	r6, r6, r2
 802326e:	4675      	movcs	r5, lr
 8023270:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8023274:	085b      	lsrs	r3, r3, #1
 8023276:	ea4f 0232 	mov.w	r2, r2, rrx
 802327a:	ebb6 0e02 	subs.w	lr, r6, r2
 802327e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8023282:	bf22      	ittt	cs
 8023284:	1ab6      	subcs	r6, r6, r2
 8023286:	4675      	movcs	r5, lr
 8023288:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 802328c:	ea55 0e06 	orrs.w	lr, r5, r6
 8023290:	d018      	beq.n	80232c4 <__aeabi_ddiv+0x114>
 8023292:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8023296:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 802329a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 802329e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80232a2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80232a6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80232aa:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80232ae:	d1c0      	bne.n	8023232 <__aeabi_ddiv+0x82>
 80232b0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80232b4:	d10b      	bne.n	80232ce <__aeabi_ddiv+0x11e>
 80232b6:	ea41 0100 	orr.w	r1, r1, r0
 80232ba:	f04f 0000 	mov.w	r0, #0
 80232be:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80232c2:	e7b6      	b.n	8023232 <__aeabi_ddiv+0x82>
 80232c4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80232c8:	bf04      	itt	eq
 80232ca:	4301      	orreq	r1, r0
 80232cc:	2000      	moveq	r0, #0
 80232ce:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80232d2:	bf88      	it	hi
 80232d4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80232d8:	f63f aeaf 	bhi.w	802303a <__aeabi_dmul+0xde>
 80232dc:	ebb5 0c03 	subs.w	ip, r5, r3
 80232e0:	bf04      	itt	eq
 80232e2:	ebb6 0c02 	subseq.w	ip, r6, r2
 80232e6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80232ea:	f150 0000 	adcs.w	r0, r0, #0
 80232ee:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80232f2:	bd70      	pop	{r4, r5, r6, pc}
 80232f4:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80232f8:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80232fc:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8023300:	bfc2      	ittt	gt
 8023302:	ebd4 050c 	rsbsgt	r5, r4, ip
 8023306:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 802330a:	bd70      	popgt	{r4, r5, r6, pc}
 802330c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8023310:	f04f 0e00 	mov.w	lr, #0
 8023314:	3c01      	subs	r4, #1
 8023316:	e690      	b.n	802303a <__aeabi_dmul+0xde>
 8023318:	ea45 0e06 	orr.w	lr, r5, r6
 802331c:	e68d      	b.n	802303a <__aeabi_dmul+0xde>
 802331e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8023322:	ea94 0f0c 	teq	r4, ip
 8023326:	bf08      	it	eq
 8023328:	ea95 0f0c 	teqeq	r5, ip
 802332c:	f43f af3b 	beq.w	80231a6 <__aeabi_dmul+0x24a>
 8023330:	ea94 0f0c 	teq	r4, ip
 8023334:	d10a      	bne.n	802334c <__aeabi_ddiv+0x19c>
 8023336:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802333a:	f47f af34 	bne.w	80231a6 <__aeabi_dmul+0x24a>
 802333e:	ea95 0f0c 	teq	r5, ip
 8023342:	f47f af25 	bne.w	8023190 <__aeabi_dmul+0x234>
 8023346:	4610      	mov	r0, r2
 8023348:	4619      	mov	r1, r3
 802334a:	e72c      	b.n	80231a6 <__aeabi_dmul+0x24a>
 802334c:	ea95 0f0c 	teq	r5, ip
 8023350:	d106      	bne.n	8023360 <__aeabi_ddiv+0x1b0>
 8023352:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8023356:	f43f aefd 	beq.w	8023154 <__aeabi_dmul+0x1f8>
 802335a:	4610      	mov	r0, r2
 802335c:	4619      	mov	r1, r3
 802335e:	e722      	b.n	80231a6 <__aeabi_dmul+0x24a>
 8023360:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8023364:	bf18      	it	ne
 8023366:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802336a:	f47f aec5 	bne.w	80230f8 <__aeabi_dmul+0x19c>
 802336e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8023372:	f47f af0d 	bne.w	8023190 <__aeabi_dmul+0x234>
 8023376:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 802337a:	f47f aeeb 	bne.w	8023154 <__aeabi_dmul+0x1f8>
 802337e:	e712      	b.n	80231a6 <__aeabi_dmul+0x24a>

08023380 <__gedf2>:
 8023380:	f04f 3cff 	mov.w	ip, #4294967295
 8023384:	e006      	b.n	8023394 <__cmpdf2+0x4>
 8023386:	bf00      	nop

08023388 <__ledf2>:
 8023388:	f04f 0c01 	mov.w	ip, #1
 802338c:	e002      	b.n	8023394 <__cmpdf2+0x4>
 802338e:	bf00      	nop

08023390 <__cmpdf2>:
 8023390:	f04f 0c01 	mov.w	ip, #1
 8023394:	f84d cd04 	str.w	ip, [sp, #-4]!
 8023398:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802339c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80233a0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80233a4:	bf18      	it	ne
 80233a6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80233aa:	d01b      	beq.n	80233e4 <__cmpdf2+0x54>
 80233ac:	b001      	add	sp, #4
 80233ae:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80233b2:	bf0c      	ite	eq
 80233b4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80233b8:	ea91 0f03 	teqne	r1, r3
 80233bc:	bf02      	ittt	eq
 80233be:	ea90 0f02 	teqeq	r0, r2
 80233c2:	2000      	moveq	r0, #0
 80233c4:	4770      	bxeq	lr
 80233c6:	f110 0f00 	cmn.w	r0, #0
 80233ca:	ea91 0f03 	teq	r1, r3
 80233ce:	bf58      	it	pl
 80233d0:	4299      	cmppl	r1, r3
 80233d2:	bf08      	it	eq
 80233d4:	4290      	cmpeq	r0, r2
 80233d6:	bf2c      	ite	cs
 80233d8:	17d8      	asrcs	r0, r3, #31
 80233da:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80233de:	f040 0001 	orr.w	r0, r0, #1
 80233e2:	4770      	bx	lr
 80233e4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80233e8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80233ec:	d102      	bne.n	80233f4 <__cmpdf2+0x64>
 80233ee:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80233f2:	d107      	bne.n	8023404 <__cmpdf2+0x74>
 80233f4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80233f8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80233fc:	d1d6      	bne.n	80233ac <__cmpdf2+0x1c>
 80233fe:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8023402:	d0d3      	beq.n	80233ac <__cmpdf2+0x1c>
 8023404:	f85d 0b04 	ldr.w	r0, [sp], #4
 8023408:	4770      	bx	lr
 802340a:	bf00      	nop

0802340c <__aeabi_cdrcmple>:
 802340c:	4684      	mov	ip, r0
 802340e:	4610      	mov	r0, r2
 8023410:	4662      	mov	r2, ip
 8023412:	468c      	mov	ip, r1
 8023414:	4619      	mov	r1, r3
 8023416:	4663      	mov	r3, ip
 8023418:	e000      	b.n	802341c <__aeabi_cdcmpeq>
 802341a:	bf00      	nop

0802341c <__aeabi_cdcmpeq>:
 802341c:	b501      	push	{r0, lr}
 802341e:	f7ff ffb7 	bl	8023390 <__cmpdf2>
 8023422:	2800      	cmp	r0, #0
 8023424:	bf48      	it	mi
 8023426:	f110 0f00 	cmnmi.w	r0, #0
 802342a:	bd01      	pop	{r0, pc}

0802342c <__aeabi_dcmpeq>:
 802342c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8023430:	f7ff fff4 	bl	802341c <__aeabi_cdcmpeq>
 8023434:	bf0c      	ite	eq
 8023436:	2001      	moveq	r0, #1
 8023438:	2000      	movne	r0, #0
 802343a:	f85d fb08 	ldr.w	pc, [sp], #8
 802343e:	bf00      	nop

08023440 <__aeabi_dcmplt>:
 8023440:	f84d ed08 	str.w	lr, [sp, #-8]!
 8023444:	f7ff ffea 	bl	802341c <__aeabi_cdcmpeq>
 8023448:	bf34      	ite	cc
 802344a:	2001      	movcc	r0, #1
 802344c:	2000      	movcs	r0, #0
 802344e:	f85d fb08 	ldr.w	pc, [sp], #8
 8023452:	bf00      	nop

08023454 <__aeabi_dcmple>:
 8023454:	f84d ed08 	str.w	lr, [sp, #-8]!
 8023458:	f7ff ffe0 	bl	802341c <__aeabi_cdcmpeq>
 802345c:	bf94      	ite	ls
 802345e:	2001      	movls	r0, #1
 8023460:	2000      	movhi	r0, #0
 8023462:	f85d fb08 	ldr.w	pc, [sp], #8
 8023466:	bf00      	nop

08023468 <__aeabi_dcmpge>:
 8023468:	f84d ed08 	str.w	lr, [sp, #-8]!
 802346c:	f7ff ffce 	bl	802340c <__aeabi_cdrcmple>
 8023470:	bf94      	ite	ls
 8023472:	2001      	movls	r0, #1
 8023474:	2000      	movhi	r0, #0
 8023476:	f85d fb08 	ldr.w	pc, [sp], #8
 802347a:	bf00      	nop

0802347c <__aeabi_dcmpgt>:
 802347c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8023480:	f7ff ffc4 	bl	802340c <__aeabi_cdrcmple>
 8023484:	bf34      	ite	cc
 8023486:	2001      	movcc	r0, #1
 8023488:	2000      	movcs	r0, #0
 802348a:	f85d fb08 	ldr.w	pc, [sp], #8
 802348e:	bf00      	nop

08023490 <__aeabi_d2iz>:
 8023490:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8023494:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8023498:	d215      	bcs.n	80234c6 <__aeabi_d2iz+0x36>
 802349a:	d511      	bpl.n	80234c0 <__aeabi_d2iz+0x30>
 802349c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80234a0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80234a4:	d912      	bls.n	80234cc <__aeabi_d2iz+0x3c>
 80234a6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80234aa:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80234ae:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80234b2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80234b6:	fa23 f002 	lsr.w	r0, r3, r2
 80234ba:	bf18      	it	ne
 80234bc:	4240      	negne	r0, r0
 80234be:	4770      	bx	lr
 80234c0:	f04f 0000 	mov.w	r0, #0
 80234c4:	4770      	bx	lr
 80234c6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80234ca:	d105      	bne.n	80234d8 <__aeabi_d2iz+0x48>
 80234cc:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80234d0:	bf08      	it	eq
 80234d2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80234d6:	4770      	bx	lr
 80234d8:	f04f 0000 	mov.w	r0, #0
 80234dc:	4770      	bx	lr
 80234de:	bf00      	nop

080234e0 <__aeabi_uldivmod>:
 80234e0:	b94b      	cbnz	r3, 80234f6 <__aeabi_uldivmod+0x16>
 80234e2:	b942      	cbnz	r2, 80234f6 <__aeabi_uldivmod+0x16>
 80234e4:	2900      	cmp	r1, #0
 80234e6:	bf08      	it	eq
 80234e8:	2800      	cmpeq	r0, #0
 80234ea:	d002      	beq.n	80234f2 <__aeabi_uldivmod+0x12>
 80234ec:	f04f 31ff 	mov.w	r1, #4294967295
 80234f0:	4608      	mov	r0, r1
 80234f2:	f001 b871 	b.w	80245d8 <__aeabi_idiv0>
 80234f6:	b082      	sub	sp, #8
 80234f8:	46ec      	mov	ip, sp
 80234fa:	e92d 5000 	stmdb	sp!, {ip, lr}
 80234fe:	f000 f81b 	bl	8023538 <__gnu_uldivmod_helper>
 8023502:	f8dd e004 	ldr.w	lr, [sp, #4]
 8023506:	b002      	add	sp, #8
 8023508:	bc0c      	pop	{r2, r3}
 802350a:	4770      	bx	lr

0802350c <__gnu_ldivmod_helper>:
 802350c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802350e:	4614      	mov	r4, r2
 8023510:	4606      	mov	r6, r0
 8023512:	460f      	mov	r7, r1
 8023514:	461d      	mov	r5, r3
 8023516:	f001 f861 	bl	80245dc <__divdi3>
 802351a:	fb04 f301 	mul.w	r3, r4, r1
 802351e:	fb00 3505 	mla	r5, r0, r5, r3
 8023522:	fba4 2300 	umull	r2, r3, r4, r0
 8023526:	18eb      	adds	r3, r5, r3
 8023528:	9c06      	ldr	r4, [sp, #24]
 802352a:	1ab2      	subs	r2, r6, r2
 802352c:	eb67 0303 	sbc.w	r3, r7, r3
 8023530:	e9c4 2300 	strd	r2, r3, [r4]
 8023534:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8023536:	bf00      	nop

08023538 <__gnu_uldivmod_helper>:
 8023538:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802353a:	4614      	mov	r4, r2
 802353c:	4606      	mov	r6, r0
 802353e:	460f      	mov	r7, r1
 8023540:	461d      	mov	r5, r3
 8023542:	f001 f9af 	bl	80248a4 <__udivdi3>
 8023546:	fb00 f505 	mul.w	r5, r0, r5
 802354a:	fba0 2304 	umull	r2, r3, r0, r4
 802354e:	fb04 5501 	mla	r5, r4, r1, r5
 8023552:	18eb      	adds	r3, r5, r3
 8023554:	9c06      	ldr	r4, [sp, #24]
 8023556:	1ab2      	subs	r2, r6, r2
 8023558:	eb67 0303 	sbc.w	r3, r7, r3
 802355c:	e9c4 2300 	strd	r2, r3, [r4]
 8023560:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8023562:	bf00      	nop

08023564 <_Unwind_decode_target2>:
 8023564:	6803      	ldr	r3, [r0, #0]
 8023566:	b103      	cbz	r3, 802356a <_Unwind_decode_target2+0x6>
 8023568:	181b      	adds	r3, r3, r0
 802356a:	4618      	mov	r0, r3
 802356c:	4770      	bx	lr
 802356e:	bf00      	nop

08023570 <selfrel_offset31>:
 8023570:	6803      	ldr	r3, [r0, #0]
 8023572:	005a      	lsls	r2, r3, #1
 8023574:	bf4c      	ite	mi
 8023576:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
 802357a:	f023 4300 	bicpl.w	r3, r3, #2147483648	; 0x80000000
 802357e:	18c0      	adds	r0, r0, r3
 8023580:	4770      	bx	lr
 8023582:	bf00      	nop

08023584 <search_EIT_table>:
 8023584:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023588:	4604      	mov	r4, r0
 802358a:	4691      	mov	r9, r2
 802358c:	b341      	cbz	r1, 80235e0 <search_EIT_table+0x5c>
 802358e:	f101 3bff 	add.w	fp, r1, #4294967295
 8023592:	46da      	mov	sl, fp
 8023594:	2700      	movs	r7, #0
 8023596:	eb07 010a 	add.w	r1, r7, sl
 802359a:	eb01 75d1 	add.w	r5, r1, r1, lsr #31
 802359e:	106d      	asrs	r5, r5, #1
 80235a0:	eb04 06c5 	add.w	r6, r4, r5, lsl #3
 80235a4:	4630      	mov	r0, r6
 80235a6:	f7ff ffe3 	bl	8023570 <selfrel_offset31>
 80235aa:	4680      	mov	r8, r0
 80235ac:	1c68      	adds	r0, r5, #1
 80235ae:	45ab      	cmp	fp, r5
 80235b0:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
 80235b4:	d00d      	beq.n	80235d2 <search_EIT_table+0x4e>
 80235b6:	f7ff ffdb 	bl	8023570 <selfrel_offset31>
 80235ba:	3801      	subs	r0, #1
 80235bc:	45c8      	cmp	r8, r9
 80235be:	d904      	bls.n	80235ca <search_EIT_table+0x46>
 80235c0:	42bd      	cmp	r5, r7
 80235c2:	d009      	beq.n	80235d8 <search_EIT_table+0x54>
 80235c4:	f105 3aff 	add.w	sl, r5, #4294967295
 80235c8:	e7e5      	b.n	8023596 <search_EIT_table+0x12>
 80235ca:	4548      	cmp	r0, r9
 80235cc:	d205      	bcs.n	80235da <search_EIT_table+0x56>
 80235ce:	1c6f      	adds	r7, r5, #1
 80235d0:	e7e1      	b.n	8023596 <search_EIT_table+0x12>
 80235d2:	f04f 30ff 	mov.w	r0, #4294967295
 80235d6:	e7f1      	b.n	80235bc <search_EIT_table+0x38>
 80235d8:	2600      	movs	r6, #0
 80235da:	4630      	mov	r0, r6
 80235dc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80235e0:	460e      	mov	r6, r1
 80235e2:	4630      	mov	r0, r6
 80235e4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080235e8 <get_eit_entry>:
 80235e8:	b530      	push	{r4, r5, lr}
 80235ea:	4b2b      	ldr	r3, [pc, #172]	; (8023698 <get_eit_entry+0xb0>)
 80235ec:	b083      	sub	sp, #12
 80235ee:	4604      	mov	r4, r0
 80235f0:	1e8d      	subs	r5, r1, #2
 80235f2:	2b00      	cmp	r3, #0
 80235f4:	d049      	beq.n	802368a <get_eit_entry+0xa2>
 80235f6:	4628      	mov	r0, r5
 80235f8:	a901      	add	r1, sp, #4
 80235fa:	f3af 8000 	nop.w
 80235fe:	4603      	mov	r3, r0
 8023600:	2800      	cmp	r0, #0
 8023602:	d022      	beq.n	802364a <get_eit_entry+0x62>
 8023604:	462a      	mov	r2, r5
 8023606:	4618      	mov	r0, r3
 8023608:	9901      	ldr	r1, [sp, #4]
 802360a:	f7ff ffbb 	bl	8023584 <search_EIT_table>
 802360e:	4605      	mov	r5, r0
 8023610:	2800      	cmp	r0, #0
 8023612:	d01d      	beq.n	8023650 <get_eit_entry+0x68>
 8023614:	f7ff ffac 	bl	8023570 <selfrel_offset31>
 8023618:	686b      	ldr	r3, [r5, #4]
 802361a:	64a0      	str	r0, [r4, #72]	; 0x48
 802361c:	2b01      	cmp	r3, #1
 802361e:	d010      	beq.n	8023642 <get_eit_entry+0x5a>
 8023620:	1d28      	adds	r0, r5, #4
 8023622:	2b00      	cmp	r3, #0
 8023624:	db22      	blt.n	802366c <get_eit_entry+0x84>
 8023626:	f7ff ffa3 	bl	8023570 <selfrel_offset31>
 802362a:	2100      	movs	r1, #0
 802362c:	64e0      	str	r0, [r4, #76]	; 0x4c
 802362e:	6521      	str	r1, [r4, #80]	; 0x50
 8023630:	6803      	ldr	r3, [r0, #0]
 8023632:	2b00      	cmp	r3, #0
 8023634:	db0f      	blt.n	8023656 <get_eit_entry+0x6e>
 8023636:	f7ff ff9b 	bl	8023570 <selfrel_offset31>
 802363a:	6120      	str	r0, [r4, #16]
 802363c:	2000      	movs	r0, #0
 802363e:	b003      	add	sp, #12
 8023640:	bd30      	pop	{r4, r5, pc}
 8023642:	2300      	movs	r3, #0
 8023644:	6123      	str	r3, [r4, #16]
 8023646:	2005      	movs	r0, #5
 8023648:	e7f9      	b.n	802363e <get_eit_entry+0x56>
 802364a:	6120      	str	r0, [r4, #16]
 802364c:	2009      	movs	r0, #9
 802364e:	e7f6      	b.n	802363e <get_eit_entry+0x56>
 8023650:	6120      	str	r0, [r4, #16]
 8023652:	2009      	movs	r0, #9
 8023654:	e7f3      	b.n	802363e <get_eit_entry+0x56>
 8023656:	f3c3 6003 	ubfx	r0, r3, #24, #4
 802365a:	b158      	cbz	r0, 8023674 <get_eit_entry+0x8c>
 802365c:	2801      	cmp	r0, #1
 802365e:	d00c      	beq.n	802367a <get_eit_entry+0x92>
 8023660:	2802      	cmp	r0, #2
 8023662:	d00e      	beq.n	8023682 <get_eit_entry+0x9a>
 8023664:	2000      	movs	r0, #0
 8023666:	6120      	str	r0, [r4, #16]
 8023668:	2009      	movs	r0, #9
 802366a:	e7e8      	b.n	802363e <get_eit_entry+0x56>
 802366c:	2201      	movs	r2, #1
 802366e:	64e0      	str	r0, [r4, #76]	; 0x4c
 8023670:	6522      	str	r2, [r4, #80]	; 0x50
 8023672:	e7dd      	b.n	8023630 <get_eit_entry+0x48>
 8023674:	4b09      	ldr	r3, [pc, #36]	; (802369c <get_eit_entry+0xb4>)
 8023676:	6123      	str	r3, [r4, #16]
 8023678:	e7e1      	b.n	802363e <get_eit_entry+0x56>
 802367a:	4a09      	ldr	r2, [pc, #36]	; (80236a0 <get_eit_entry+0xb8>)
 802367c:	2000      	movs	r0, #0
 802367e:	6122      	str	r2, [r4, #16]
 8023680:	e7dd      	b.n	802363e <get_eit_entry+0x56>
 8023682:	4908      	ldr	r1, [pc, #32]	; (80236a4 <get_eit_entry+0xbc>)
 8023684:	2000      	movs	r0, #0
 8023686:	6121      	str	r1, [r4, #16]
 8023688:	e7d9      	b.n	802363e <get_eit_entry+0x56>
 802368a:	4b07      	ldr	r3, [pc, #28]	; (80236a8 <get_eit_entry+0xc0>)
 802368c:	4907      	ldr	r1, [pc, #28]	; (80236ac <get_eit_entry+0xc4>)
 802368e:	1ac8      	subs	r0, r1, r3
 8023690:	10c2      	asrs	r2, r0, #3
 8023692:	9201      	str	r2, [sp, #4]
 8023694:	e7b6      	b.n	8023604 <get_eit_entry+0x1c>
 8023696:	bf00      	nop
 8023698:	00000000 	.word	0x00000000
 802369c:	08023bb5 	.word	0x08023bb5
 80236a0:	08023bb1 	.word	0x08023bb1
 80236a4:	08023bad 	.word	0x08023bad
 80236a8:	080332b4 	.word	0x080332b4
 80236ac:	08033394 	.word	0x08033394

080236b0 <restore_non_core_regs>:
 80236b0:	6803      	ldr	r3, [r0, #0]
 80236b2:	b510      	push	{r4, lr}
 80236b4:	4604      	mov	r4, r0
 80236b6:	07d8      	lsls	r0, r3, #31
 80236b8:	d406      	bmi.n	80236c8 <restore_non_core_regs+0x18>
 80236ba:	0799      	lsls	r1, r3, #30
 80236bc:	f104 0048 	add.w	r0, r4, #72	; 0x48
 80236c0:	d509      	bpl.n	80236d6 <restore_non_core_regs+0x26>
 80236c2:	f000 fd0d 	bl	80240e0 <__gnu_Unwind_Restore_VFP_D>
 80236c6:	6823      	ldr	r3, [r4, #0]
 80236c8:	075a      	lsls	r2, r3, #29
 80236ca:	d509      	bpl.n	80236e0 <restore_non_core_regs+0x30>
 80236cc:	0718      	lsls	r0, r3, #28
 80236ce:	d50e      	bpl.n	80236ee <restore_non_core_regs+0x3e>
 80236d0:	06d9      	lsls	r1, r3, #27
 80236d2:	d513      	bpl.n	80236fc <restore_non_core_regs+0x4c>
 80236d4:	bd10      	pop	{r4, pc}
 80236d6:	f000 fcfb 	bl	80240d0 <__gnu_Unwind_Restore_VFP>
 80236da:	6823      	ldr	r3, [r4, #0]
 80236dc:	075a      	lsls	r2, r3, #29
 80236de:	d4f5      	bmi.n	80236cc <restore_non_core_regs+0x1c>
 80236e0:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 80236e4:	f000 fd04 	bl	80240f0 <__gnu_Unwind_Restore_VFP_D_16_to_31>
 80236e8:	6823      	ldr	r3, [r4, #0]
 80236ea:	0718      	lsls	r0, r3, #28
 80236ec:	d4f0      	bmi.n	80236d0 <restore_non_core_regs+0x20>
 80236ee:	f504 70d8 	add.w	r0, r4, #432	; 0x1b0
 80236f2:	f000 fd05 	bl	8024100 <__gnu_Unwind_Restore_WMMXD>
 80236f6:	6823      	ldr	r3, [r4, #0]
 80236f8:	06d9      	lsls	r1, r3, #27
 80236fa:	d4eb      	bmi.n	80236d4 <restore_non_core_regs+0x24>
 80236fc:	f504 700c 	add.w	r0, r4, #560	; 0x230
 8023700:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023704:	f000 bd40 	b.w	8024188 <__gnu_Unwind_Restore_WMMXC>

08023708 <unwind_phase2_forced>:
 8023708:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802370c:	1d0f      	adds	r7, r1, #4
 802370e:	4605      	mov	r5, r0
 8023710:	4691      	mov	r9, r2
 8023712:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8023714:	f5ad 6d91 	sub.w	sp, sp, #1160	; 0x488
 8023718:	ac02      	add	r4, sp, #8
 802371a:	1d26      	adds	r6, r4, #4
 802371c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 802371e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8023720:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8023722:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8023724:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8023726:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 802372a:	f8d5 800c 	ldr.w	r8, [r5, #12]
 802372e:	f8d5 a018 	ldr.w	sl, [r5, #24]
 8023732:	2700      	movs	r7, #0
 8023734:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
 8023738:	6c21      	ldr	r1, [r4, #64]	; 0x40
 802373a:	6027      	str	r7, [r4, #0]
 802373c:	4628      	mov	r0, r5
 802373e:	f7ff ff53 	bl	80235e8 <get_eit_entry>
 8023742:	4606      	mov	r6, r0
 8023744:	45b9      	cmp	r9, r7
 8023746:	bf14      	ite	ne
 8023748:	f04f 090a 	movne.w	r9, #10
 802374c:	f04f 0909 	moveq.w	r9, #9
 8023750:	b1fe      	cbz	r6, 8023792 <unwind_phase2_forced+0x8a>
 8023752:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8023754:	f049 0910 	orr.w	r9, r9, #16
 8023758:	6461      	str	r1, [r4, #68]	; 0x44
 802375a:	2001      	movs	r0, #1
 802375c:	e88d 0410 	stmia.w	sp, {r4, sl}
 8023760:	4649      	mov	r1, r9
 8023762:	462a      	mov	r2, r5
 8023764:	462b      	mov	r3, r5
 8023766:	47c0      	blx	r8
 8023768:	2800      	cmp	r0, #0
 802376a:	d12b      	bne.n	80237c4 <unwind_phase2_forced+0xbc>
 802376c:	2e00      	cmp	r6, #0
 802376e:	d12a      	bne.n	80237c6 <unwind_phase2_forced+0xbe>
 8023770:	4620      	mov	r0, r4
 8023772:	a992      	add	r1, sp, #584	; 0x248
 8023774:	f44f 7210 	mov.w	r2, #576	; 0x240
 8023778:	f001 fdce 	bl	8025318 <memcpy>
 802377c:	2f08      	cmp	r7, #8
 802377e:	d128      	bne.n	80237d2 <unwind_phase2_forced+0xca>
 8023780:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8023782:	4628      	mov	r0, r5
 8023784:	f7ff ff30 	bl	80235e8 <get_eit_entry>
 8023788:	4606      	mov	r6, r0
 802378a:	f04f 0909 	mov.w	r9, #9
 802378e:	2e00      	cmp	r6, #0
 8023790:	d1df      	bne.n	8023752 <unwind_phase2_forced+0x4a>
 8023792:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8023794:	4621      	mov	r1, r4
 8023796:	f44f 7210 	mov.w	r2, #576	; 0x240
 802379a:	6168      	str	r0, [r5, #20]
 802379c:	a892      	add	r0, sp, #584	; 0x248
 802379e:	f001 fdbb 	bl	8025318 <memcpy>
 80237a2:	692f      	ldr	r7, [r5, #16]
 80237a4:	4629      	mov	r1, r5
 80237a6:	aa92      	add	r2, sp, #584	; 0x248
 80237a8:	4648      	mov	r0, r9
 80237aa:	47b8      	blx	r7
 80237ac:	9ba0      	ldr	r3, [sp, #640]	; 0x280
 80237ae:	4607      	mov	r7, r0
 80237b0:	6463      	str	r3, [r4, #68]	; 0x44
 80237b2:	2001      	movs	r0, #1
 80237b4:	e88d 0410 	stmia.w	sp, {r4, sl}
 80237b8:	4649      	mov	r1, r9
 80237ba:	462a      	mov	r2, r5
 80237bc:	462b      	mov	r3, r5
 80237be:	47c0      	blx	r8
 80237c0:	2800      	cmp	r0, #0
 80237c2:	d0d3      	beq.n	802376c <unwind_phase2_forced+0x64>
 80237c4:	2609      	movs	r6, #9
 80237c6:	4630      	mov	r0, r6
 80237c8:	b022      	add	sp, #136	; 0x88
 80237ca:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
 80237ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80237d2:	2f07      	cmp	r7, #7
 80237d4:	d1f6      	bne.n	80237c4 <unwind_phase2_forced+0xbc>
 80237d6:	1d20      	adds	r0, r4, #4
 80237d8:	f000 fc6e 	bl	80240b8 <__restore_core_regs>

080237dc <unwind_phase2>:
 80237dc:	b538      	push	{r3, r4, r5, lr}
 80237de:	4604      	mov	r4, r0
 80237e0:	460d      	mov	r5, r1
 80237e2:	6c29      	ldr	r1, [r5, #64]	; 0x40
 80237e4:	4620      	mov	r0, r4
 80237e6:	f7ff feff 	bl	80235e8 <get_eit_entry>
 80237ea:	b950      	cbnz	r0, 8023802 <unwind_phase2+0x26>
 80237ec:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 80237ee:	6923      	ldr	r3, [r4, #16]
 80237f0:	6162      	str	r2, [r4, #20]
 80237f2:	2001      	movs	r0, #1
 80237f4:	4621      	mov	r1, r4
 80237f6:	462a      	mov	r2, r5
 80237f8:	4798      	blx	r3
 80237fa:	2808      	cmp	r0, #8
 80237fc:	d0f1      	beq.n	80237e2 <unwind_phase2+0x6>
 80237fe:	2807      	cmp	r0, #7
 8023800:	d001      	beq.n	8023806 <unwind_phase2+0x2a>
 8023802:	f005 fccf 	bl	80291a4 <abort>
 8023806:	1d28      	adds	r0, r5, #4
 8023808:	f000 fc56 	bl	80240b8 <__restore_core_regs>

0802380c <_Unwind_VRS_Get>:
 802380c:	b911      	cbnz	r1, 8023814 <_Unwind_VRS_Get+0x8>
 802380e:	b133      	cbz	r3, 802381e <_Unwind_VRS_Get+0x12>
 8023810:	2002      	movs	r0, #2
 8023812:	4770      	bx	lr
 8023814:	2904      	cmp	r1, #4
 8023816:	bf8c      	ite	hi
 8023818:	2002      	movhi	r0, #2
 802381a:	2001      	movls	r0, #1
 802381c:	4770      	bx	lr
 802381e:	2a0f      	cmp	r2, #15
 8023820:	d901      	bls.n	8023826 <_Unwind_VRS_Get+0x1a>
 8023822:	2002      	movs	r0, #2
 8023824:	4770      	bx	lr
 8023826:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 802382a:	4618      	mov	r0, r3
 802382c:	684a      	ldr	r2, [r1, #4]
 802382e:	9b00      	ldr	r3, [sp, #0]
 8023830:	601a      	str	r2, [r3, #0]
 8023832:	4770      	bx	lr

08023834 <_Unwind_GetGR>:
 8023834:	b510      	push	{r4, lr}
 8023836:	460a      	mov	r2, r1
 8023838:	b084      	sub	sp, #16
 802383a:	2100      	movs	r1, #0
 802383c:	460b      	mov	r3, r1
 802383e:	ac03      	add	r4, sp, #12
 8023840:	9400      	str	r4, [sp, #0]
 8023842:	f7ff ffe3 	bl	802380c <_Unwind_VRS_Get>
 8023846:	9803      	ldr	r0, [sp, #12]
 8023848:	b004      	add	sp, #16
 802384a:	bd10      	pop	{r4, pc}

0802384c <_Unwind_VRS_Set>:
 802384c:	b911      	cbnz	r1, 8023854 <_Unwind_VRS_Set+0x8>
 802384e:	b133      	cbz	r3, 802385e <_Unwind_VRS_Set+0x12>
 8023850:	2002      	movs	r0, #2
 8023852:	4770      	bx	lr
 8023854:	2904      	cmp	r1, #4
 8023856:	bf8c      	ite	hi
 8023858:	2002      	movhi	r0, #2
 802385a:	2001      	movls	r0, #1
 802385c:	4770      	bx	lr
 802385e:	2a0f      	cmp	r2, #15
 8023860:	d901      	bls.n	8023866 <_Unwind_VRS_Set+0x1a>
 8023862:	2002      	movs	r0, #2
 8023864:	4770      	bx	lr
 8023866:	9900      	ldr	r1, [sp, #0]
 8023868:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 802386c:	6809      	ldr	r1, [r1, #0]
 802386e:	4618      	mov	r0, r3
 8023870:	6051      	str	r1, [r2, #4]
 8023872:	4770      	bx	lr

08023874 <_Unwind_SetGR>:
 8023874:	b510      	push	{r4, lr}
 8023876:	b084      	sub	sp, #16
 8023878:	ab04      	add	r3, sp, #16
 802387a:	460c      	mov	r4, r1
 802387c:	f843 2d04 	str.w	r2, [r3, #-4]!
 8023880:	2100      	movs	r1, #0
 8023882:	9300      	str	r3, [sp, #0]
 8023884:	4622      	mov	r2, r4
 8023886:	460b      	mov	r3, r1
 8023888:	f7ff ffe0 	bl	802384c <_Unwind_VRS_Set>
 802388c:	b004      	add	sp, #16
 802388e:	bd10      	pop	{r4, pc}

08023890 <__gnu_unwind_pr_common>:
 8023890:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023894:	6ccd      	ldr	r5, [r1, #76]	; 0x4c
 8023896:	b08b      	sub	sp, #44	; 0x2c
 8023898:	460c      	mov	r4, r1
 802389a:	f855 1b04 	ldr.w	r1, [r5], #4
 802389e:	4617      	mov	r7, r2
 80238a0:	f000 0208 	and.w	r2, r0, #8
 80238a4:	461e      	mov	r6, r3
 80238a6:	9203      	str	r2, [sp, #12]
 80238a8:	f000 0803 	and.w	r8, r0, #3
 80238ac:	9507      	str	r5, [sp, #28]
 80238ae:	2b00      	cmp	r3, #0
 80238b0:	f040 80cf 	bne.w	8023a52 <__gnu_unwind_pr_common+0x1c2>
 80238b4:	0209      	lsls	r1, r1, #8
 80238b6:	9106      	str	r1, [sp, #24]
 80238b8:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80238ba:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
 80238be:	2303      	movs	r3, #3
 80238c0:	f1b8 0f02 	cmp.w	r8, #2
 80238c4:	f88d 3020 	strb.w	r3, [sp, #32]
 80238c8:	bf08      	it	eq
 80238ca:	6ba5      	ldreq	r5, [r4, #56]	; 0x38
 80238cc:	f011 0301 	ands.w	r3, r1, #1
 80238d0:	f040 80d3 	bne.w	8023a7a <__gnu_unwind_pr_common+0x1ea>
 80238d4:	9301      	str	r3, [sp, #4]
 80238d6:	f104 0358 	add.w	r3, r4, #88	; 0x58
 80238da:	9302      	str	r3, [sp, #8]
 80238dc:	f8d5 9000 	ldr.w	r9, [r5]
 80238e0:	f1b9 0f00 	cmp.w	r9, #0
 80238e4:	f000 80cb 	beq.w	8023a7e <__gnu_unwind_pr_common+0x1ee>
 80238e8:	2e02      	cmp	r6, #2
 80238ea:	f000 80ae 	beq.w	8023a4a <__gnu_unwind_pr_common+0x1ba>
 80238ee:	f8b5 9000 	ldrh.w	r9, [r5]
 80238f2:	f8b5 a002 	ldrh.w	sl, [r5, #2]
 80238f6:	3504      	adds	r5, #4
 80238f8:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80238fa:	210f      	movs	r1, #15
 80238fc:	f02a 0b01 	bic.w	fp, sl, #1
 8023900:	4638      	mov	r0, r7
 8023902:	4493      	add	fp, r2
 8023904:	f7ff ff96 	bl	8023834 <_Unwind_GetGR>
 8023908:	4583      	cmp	fp, r0
 802390a:	d818      	bhi.n	802393e <__gnu_unwind_pr_common+0xae>
 802390c:	f029 0c01 	bic.w	ip, r9, #1
 8023910:	44e3      	add	fp, ip
 8023912:	f00a 0a01 	and.w	sl, sl, #1
 8023916:	f009 0301 	and.w	r3, r9, #1
 802391a:	4558      	cmp	r0, fp
 802391c:	ea43 094a 	orr.w	r9, r3, sl, lsl #1
 8023920:	bf2c      	ite	cs
 8023922:	2000      	movcs	r0, #0
 8023924:	2001      	movcc	r0, #1
 8023926:	f1b9 0f01 	cmp.w	r9, #1
 802392a:	d012      	beq.n	8023952 <__gnu_unwind_pr_common+0xc2>
 802392c:	d232      	bcs.n	8023994 <__gnu_unwind_pr_common+0x104>
 802392e:	f1b8 0f00 	cmp.w	r8, #0
 8023932:	d002      	beq.n	802393a <__gnu_unwind_pr_common+0xaa>
 8023934:	2800      	cmp	r0, #0
 8023936:	f040 811d 	bne.w	8023b74 <__gnu_unwind_pr_common+0x2e4>
 802393a:	3504      	adds	r5, #4
 802393c:	e7ce      	b.n	80238dc <__gnu_unwind_pr_common+0x4c>
 802393e:	f00a 0a01 	and.w	sl, sl, #1
 8023942:	f009 0301 	and.w	r3, r9, #1
 8023946:	ea43 094a 	orr.w	r9, r3, sl, lsl #1
 802394a:	2000      	movs	r0, #0
 802394c:	f1b9 0f01 	cmp.w	r9, #1
 8023950:	d1ec      	bne.n	802392c <__gnu_unwind_pr_common+0x9c>
 8023952:	f1b8 0f00 	cmp.w	r8, #0
 8023956:	f040 80b6 	bne.w	8023ac6 <__gnu_unwind_pr_common+0x236>
 802395a:	b1c8      	cbz	r0, 8023990 <__gnu_unwind_pr_common+0x100>
 802395c:	686b      	ldr	r3, [r5, #4]
 802395e:	f8d5 9000 	ldr.w	r9, [r5]
 8023962:	1c9a      	adds	r2, r3, #2
 8023964:	d019      	beq.n	802399a <__gnu_unwind_pr_common+0x10a>
 8023966:	9a02      	ldr	r2, [sp, #8]
 8023968:	3301      	adds	r3, #1
 802396a:	9209      	str	r2, [sp, #36]	; 0x24
 802396c:	d00d      	beq.n	802398a <__gnu_unwind_pr_common+0xfa>
 802396e:	1d28      	adds	r0, r5, #4
 8023970:	f7ff fdf8 	bl	8023564 <_Unwind_decode_target2>
 8023974:	ea4f 72d9 	mov.w	r2, r9, lsr #31
 8023978:	4601      	mov	r1, r0
 802397a:	ab09      	add	r3, sp, #36	; 0x24
 802397c:	4620      	mov	r0, r4
 802397e:	f3af 8000 	nop.w
 8023982:	2800      	cmp	r0, #0
 8023984:	f000 80f2 	beq.w	8023b6c <__gnu_unwind_pr_common+0x2dc>
 8023988:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802398a:	2a00      	cmp	r2, #0
 802398c:	f040 80ba 	bne.w	8023b04 <__gnu_unwind_pr_common+0x274>
 8023990:	3508      	adds	r5, #8
 8023992:	e7a3      	b.n	80238dc <__gnu_unwind_pr_common+0x4c>
 8023994:	f1b9 0f02 	cmp.w	r9, #2
 8023998:	d003      	beq.n	80239a2 <__gnu_unwind_pr_common+0x112>
 802399a:	2009      	movs	r0, #9
 802399c:	b00b      	add	sp, #44	; 0x2c
 802399e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80239a2:	682b      	ldr	r3, [r5, #0]
 80239a4:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 80239a8:	9200      	str	r2, [sp, #0]
 80239aa:	f1b8 0f00 	cmp.w	r8, #0
 80239ae:	d171      	bne.n	8023a94 <__gnu_unwind_pr_common+0x204>
 80239b0:	2800      	cmp	r0, #0
 80239b2:	d043      	beq.n	8023a3c <__gnu_unwind_pr_common+0x1ac>
 80239b4:	9803      	ldr	r0, [sp, #12]
 80239b6:	2800      	cmp	r0, #0
 80239b8:	f040 80a1 	bne.w	8023afe <__gnu_unwind_pr_common+0x26e>
 80239bc:	9800      	ldr	r0, [sp, #0]
 80239be:	2800      	cmp	r0, #0
 80239c0:	f000 80a0 	beq.w	8023b04 <__gnu_unwind_pr_common+0x274>
 80239c4:	9b00      	ldr	r3, [sp, #0]
 80239c6:	f8dd 900c 	ldr.w	r9, [sp, #12]
 80239ca:	07db      	lsls	r3, r3, #31
 80239cc:	f105 0a04 	add.w	sl, r5, #4
 80239d0:	f140 80b4 	bpl.w	8023b3c <__gnu_unwind_pr_common+0x2ac>
 80239d4:	f8cd 8010 	str.w	r8, [sp, #16]
 80239d8:	9605      	str	r6, [sp, #20]
 80239da:	46a8      	mov	r8, r5
 80239dc:	9e02      	ldr	r6, [sp, #8]
 80239de:	e012      	b.n	8023a06 <__gnu_unwind_pr_common+0x176>
 80239e0:	9900      	ldr	r1, [sp, #0]
 80239e2:	428d      	cmp	r5, r1
 80239e4:	f000 80d9 	beq.w	8023b9a <__gnu_unwind_pr_common+0x30a>
 80239e8:	9609      	str	r6, [sp, #36]	; 0x24
 80239ea:	f7ff fdbb 	bl	8023564 <_Unwind_decode_target2>
 80239ee:	465a      	mov	r2, fp
 80239f0:	4601      	mov	r1, r0
 80239f2:	ab09      	add	r3, sp, #36	; 0x24
 80239f4:	4620      	mov	r0, r4
 80239f6:	f3af 8000 	nop.w
 80239fa:	46a9      	mov	r9, r5
 80239fc:	b9b0      	cbnz	r0, 8023a2c <__gnu_unwind_pr_common+0x19c>
 80239fe:	f10a 0a04 	add.w	sl, sl, #4
 8023a02:	f105 0901 	add.w	r9, r5, #1
 8023a06:	4650      	mov	r0, sl
 8023a08:	9609      	str	r6, [sp, #36]	; 0x24
 8023a0a:	f7ff fdab 	bl	8023564 <_Unwind_decode_target2>
 8023a0e:	ab09      	add	r3, sp, #36	; 0x24
 8023a10:	4601      	mov	r1, r0
 8023a12:	2200      	movs	r2, #0
 8023a14:	4620      	mov	r0, r4
 8023a16:	f3af 8000 	nop.w
 8023a1a:	f10a 0a04 	add.w	sl, sl, #4
 8023a1e:	4683      	mov	fp, r0
 8023a20:	f109 0501 	add.w	r5, r9, #1
 8023a24:	4650      	mov	r0, sl
 8023a26:	f1bb 0f00 	cmp.w	fp, #0
 8023a2a:	d0d9      	beq.n	80239e0 <__gnu_unwind_pr_common+0x150>
 8023a2c:	4645      	mov	r5, r8
 8023a2e:	9e05      	ldr	r6, [sp, #20]
 8023a30:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8023a34:	9a00      	ldr	r2, [sp, #0]
 8023a36:	454a      	cmp	r2, r9
 8023a38:	d064      	beq.n	8023b04 <__gnu_unwind_pr_common+0x274>
 8023a3a:	682b      	ldr	r3, [r5, #0]
 8023a3c:	2b00      	cmp	r3, #0
 8023a3e:	db7b      	blt.n	8023b38 <__gnu_unwind_pr_common+0x2a8>
 8023a40:	9900      	ldr	r1, [sp, #0]
 8023a42:	1c48      	adds	r0, r1, #1
 8023a44:	eb05 0580 	add.w	r5, r5, r0, lsl #2
 8023a48:	e748      	b.n	80238dc <__gnu_unwind_pr_common+0x4c>
 8023a4a:	f8d5 a004 	ldr.w	sl, [r5, #4]
 8023a4e:	3508      	adds	r5, #8
 8023a50:	e752      	b.n	80238f8 <__gnu_unwind_pr_common+0x68>
 8023a52:	040b      	lsls	r3, r1, #16
 8023a54:	f3c1 4007 	ubfx	r0, r1, #16, #8
 8023a58:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8023a5a:	9306      	str	r3, [sp, #24]
 8023a5c:	2202      	movs	r2, #2
 8023a5e:	f1b8 0f02 	cmp.w	r8, #2
 8023a62:	eb05 0580 	add.w	r5, r5, r0, lsl #2
 8023a66:	bf08      	it	eq
 8023a68:	6ba5      	ldreq	r5, [r4, #56]	; 0x38
 8023a6a:	f88d 0021 	strb.w	r0, [sp, #33]	; 0x21
 8023a6e:	f011 0301 	ands.w	r3, r1, #1
 8023a72:	f88d 2020 	strb.w	r2, [sp, #32]
 8023a76:	f43f af2d 	beq.w	80238d4 <__gnu_unwind_pr_common+0x44>
 8023a7a:	2000      	movs	r0, #0
 8023a7c:	9001      	str	r0, [sp, #4]
 8023a7e:	4638      	mov	r0, r7
 8023a80:	a906      	add	r1, sp, #24
 8023a82:	f000 fc19 	bl	80242b8 <__gnu_unwind_execute>
 8023a86:	2800      	cmp	r0, #0
 8023a88:	d187      	bne.n	802399a <__gnu_unwind_pr_common+0x10a>
 8023a8a:	9a01      	ldr	r2, [sp, #4]
 8023a8c:	2a00      	cmp	r2, #0
 8023a8e:	d143      	bne.n	8023b18 <__gnu_unwind_pr_common+0x288>
 8023a90:	2008      	movs	r0, #8
 8023a92:	e783      	b.n	802399c <__gnu_unwind_pr_common+0x10c>
 8023a94:	210d      	movs	r1, #13
 8023a96:	4638      	mov	r0, r7
 8023a98:	f8d4 9020 	ldr.w	r9, [r4, #32]
 8023a9c:	f7ff feca 	bl	8023834 <_Unwind_GetGR>
 8023aa0:	4581      	cmp	r9, r0
 8023aa2:	d1ca      	bne.n	8023a3a <__gnu_unwind_pr_common+0x1aa>
 8023aa4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8023aa6:	4295      	cmp	r5, r2
 8023aa8:	d1c7      	bne.n	8023a3a <__gnu_unwind_pr_common+0x1aa>
 8023aaa:	9800      	ldr	r0, [sp, #0]
 8023aac:	1d29      	adds	r1, r5, #4
 8023aae:	2200      	movs	r2, #0
 8023ab0:	2304      	movs	r3, #4
 8023ab2:	62a0      	str	r0, [r4, #40]	; 0x28
 8023ab4:	62e2      	str	r2, [r4, #44]	; 0x2c
 8023ab6:	6323      	str	r3, [r4, #48]	; 0x30
 8023ab8:	6361      	str	r1, [r4, #52]	; 0x34
 8023aba:	6828      	ldr	r0, [r5, #0]
 8023abc:	2800      	cmp	r0, #0
 8023abe:	db6e      	blt.n	8023b9e <__gnu_unwind_pr_common+0x30e>
 8023ac0:	2201      	movs	r2, #1
 8023ac2:	9201      	str	r2, [sp, #4]
 8023ac4:	e7bc      	b.n	8023a40 <__gnu_unwind_pr_common+0x1b0>
 8023ac6:	210d      	movs	r1, #13
 8023ac8:	4638      	mov	r0, r7
 8023aca:	f8d4 9020 	ldr.w	r9, [r4, #32]
 8023ace:	f7ff feb1 	bl	8023834 <_Unwind_GetGR>
 8023ad2:	4581      	cmp	r9, r0
 8023ad4:	f47f af5c 	bne.w	8023990 <__gnu_unwind_pr_common+0x100>
 8023ad8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8023ada:	428d      	cmp	r5, r1
 8023adc:	f47f af58 	bne.w	8023990 <__gnu_unwind_pr_common+0x100>
 8023ae0:	4628      	mov	r0, r5
 8023ae2:	f7ff fd45 	bl	8023570 <selfrel_offset31>
 8023ae6:	210f      	movs	r1, #15
 8023ae8:	4602      	mov	r2, r0
 8023aea:	4638      	mov	r0, r7
 8023aec:	f7ff fec2 	bl	8023874 <_Unwind_SetGR>
 8023af0:	4638      	mov	r0, r7
 8023af2:	2100      	movs	r1, #0
 8023af4:	4622      	mov	r2, r4
 8023af6:	f7ff febd 	bl	8023874 <_Unwind_SetGR>
 8023afa:	2007      	movs	r0, #7
 8023afc:	e74e      	b.n	802399c <__gnu_unwind_pr_common+0x10c>
 8023afe:	9900      	ldr	r1, [sp, #0]
 8023b00:	2900      	cmp	r1, #0
 8023b02:	d19b      	bne.n	8023a3c <__gnu_unwind_pr_common+0x1ac>
 8023b04:	4638      	mov	r0, r7
 8023b06:	210d      	movs	r1, #13
 8023b08:	f7ff fe94 	bl	8023834 <_Unwind_GetGR>
 8023b0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8023b0e:	6220      	str	r0, [r4, #32]
 8023b10:	6263      	str	r3, [r4, #36]	; 0x24
 8023b12:	62a5      	str	r5, [r4, #40]	; 0x28
 8023b14:	2006      	movs	r0, #6
 8023b16:	e741      	b.n	802399c <__gnu_unwind_pr_common+0x10c>
 8023b18:	210f      	movs	r1, #15
 8023b1a:	4638      	mov	r0, r7
 8023b1c:	f7ff fe8a 	bl	8023834 <_Unwind_GetGR>
 8023b20:	210e      	movs	r1, #14
 8023b22:	4602      	mov	r2, r0
 8023b24:	4638      	mov	r0, r7
 8023b26:	f7ff fea5 	bl	8023874 <_Unwind_SetGR>
 8023b2a:	4638      	mov	r0, r7
 8023b2c:	210f      	movs	r1, #15
 8023b2e:	4a1e      	ldr	r2, [pc, #120]	; (8023ba8 <__gnu_unwind_pr_common+0x318>)
 8023b30:	f7ff fea0 	bl	8023874 <_Unwind_SetGR>
 8023b34:	2007      	movs	r0, #7
 8023b36:	e731      	b.n	802399c <__gnu_unwind_pr_common+0x10c>
 8023b38:	3504      	adds	r5, #4
 8023b3a:	e781      	b.n	8023a40 <__gnu_unwind_pr_common+0x1b0>
 8023b3c:	9902      	ldr	r1, [sp, #8]
 8023b3e:	4650      	mov	r0, sl
 8023b40:	9109      	str	r1, [sp, #36]	; 0x24
 8023b42:	f7ff fd0f 	bl	8023564 <_Unwind_decode_target2>
 8023b46:	9a03      	ldr	r2, [sp, #12]
 8023b48:	4601      	mov	r1, r0
 8023b4a:	ab09      	add	r3, sp, #36	; 0x24
 8023b4c:	4620      	mov	r0, r4
 8023b4e:	f3af 8000 	nop.w
 8023b52:	2800      	cmp	r0, #0
 8023b54:	f47f af6e 	bne.w	8023a34 <__gnu_unwind_pr_common+0x1a4>
 8023b58:	f8cd 8010 	str.w	r8, [sp, #16]
 8023b5c:	9605      	str	r6, [sp, #20]
 8023b5e:	f10a 0a04 	add.w	sl, sl, #4
 8023b62:	f04f 0901 	mov.w	r9, #1
 8023b66:	46a8      	mov	r8, r5
 8023b68:	9e02      	ldr	r6, [sp, #8]
 8023b6a:	e74c      	b.n	8023a06 <__gnu_unwind_pr_common+0x176>
 8023b6c:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 8023b70:	3508      	adds	r5, #8
 8023b72:	e6b3      	b.n	80238dc <__gnu_unwind_pr_common+0x4c>
 8023b74:	4628      	mov	r0, r5
 8023b76:	f7ff fcfb 	bl	8023570 <selfrel_offset31>
 8023b7a:	3504      	adds	r5, #4
 8023b7c:	4606      	mov	r6, r0
 8023b7e:	63a5      	str	r5, [r4, #56]	; 0x38
 8023b80:	4620      	mov	r0, r4
 8023b82:	f3af 8000 	nop.w
 8023b86:	2800      	cmp	r0, #0
 8023b88:	f43f af07 	beq.w	802399a <__gnu_unwind_pr_common+0x10a>
 8023b8c:	4638      	mov	r0, r7
 8023b8e:	210f      	movs	r1, #15
 8023b90:	4632      	mov	r2, r6
 8023b92:	f7ff fe6f 	bl	8023874 <_Unwind_SetGR>
 8023b96:	2007      	movs	r0, #7
 8023b98:	e700      	b.n	802399c <__gnu_unwind_pr_common+0x10c>
 8023b9a:	4645      	mov	r5, r8
 8023b9c:	e7b2      	b.n	8023b04 <__gnu_unwind_pr_common+0x274>
 8023b9e:	9b00      	ldr	r3, [sp, #0]
 8023ba0:	1c59      	adds	r1, r3, #1
 8023ba2:	eb05 0081 	add.w	r0, r5, r1, lsl #2
 8023ba6:	e79c      	b.n	8023ae2 <__gnu_unwind_pr_common+0x252>
 8023ba8:	00000000 	.word	0x00000000

08023bac <__aeabi_unwind_cpp_pr2>:
 8023bac:	2302      	movs	r3, #2
 8023bae:	e66f      	b.n	8023890 <__gnu_unwind_pr_common>

08023bb0 <__aeabi_unwind_cpp_pr1>:
 8023bb0:	2301      	movs	r3, #1
 8023bb2:	e66d      	b.n	8023890 <__gnu_unwind_pr_common>

08023bb4 <__aeabi_unwind_cpp_pr0>:
 8023bb4:	2300      	movs	r3, #0
 8023bb6:	e66b      	b.n	8023890 <__gnu_unwind_pr_common>

08023bb8 <_Unwind_VRS_Pop>:
 8023bb8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8023bbc:	4604      	mov	r4, r0
 8023bbe:	b0e8      	sub	sp, #416	; 0x1a0
 8023bc0:	2904      	cmp	r1, #4
 8023bc2:	d80c      	bhi.n	8023bde <_Unwind_VRS_Pop+0x26>
 8023bc4:	e8df f001 	tbb	[pc, r1]
 8023bc8:	93910338 	.word	0x93910338
 8023bcc:	0f          	.byte	0x0f
 8023bcd:	00          	.byte	0x00
 8023bce:	0c15      	lsrs	r5, r2, #16
 8023bd0:	2b01      	cmp	r3, #1
 8023bd2:	b296      	uxth	r6, r2
 8023bd4:	f000 8178 	beq.w	8023ec8 <_Unwind_VRS_Pop+0x310>
 8023bd8:	2b05      	cmp	r3, #5
 8023bda:	f000 80c7 	beq.w	8023d6c <_Unwind_VRS_Pop+0x1b4>
 8023bde:	2002      	movs	r0, #2
 8023be0:	b068      	add	sp, #416	; 0x1a0
 8023be2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023be6:	2b00      	cmp	r3, #0
 8023be8:	d1f9      	bne.n	8023bde <_Unwind_VRS_Pop+0x26>
 8023bea:	2a10      	cmp	r2, #16
 8023bec:	d8f7      	bhi.n	8023bde <_Unwind_VRS_Pop+0x26>
 8023bee:	6823      	ldr	r3, [r4, #0]
 8023bf0:	06d9      	lsls	r1, r3, #27
 8023bf2:	f100 8173 	bmi.w	8023edc <_Unwind_VRS_Pop+0x324>
 8023bf6:	a864      	add	r0, sp, #400	; 0x190
 8023bf8:	9201      	str	r2, [sp, #4]
 8023bfa:	f000 facf 	bl	802419c <__gnu_Unwind_Save_WMMXC>
 8023bfe:	9a01      	ldr	r2, [sp, #4]
 8023c00:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8023c02:	07d0      	lsls	r0, r2, #31
 8023c04:	bf44      	itt	mi
 8023c06:	f853 0b04 	ldrmi.w	r0, [r3], #4
 8023c0a:	9064      	strmi	r0, [sp, #400]	; 0x190
 8023c0c:	0791      	lsls	r1, r2, #30
 8023c0e:	bf44      	itt	mi
 8023c10:	f853 1b04 	ldrmi.w	r1, [r3], #4
 8023c14:	9165      	strmi	r1, [sp, #404]	; 0x194
 8023c16:	0750      	lsls	r0, r2, #29
 8023c18:	bf44      	itt	mi
 8023c1a:	f853 1b04 	ldrmi.w	r1, [r3], #4
 8023c1e:	9166      	strmi	r1, [sp, #408]	; 0x198
 8023c20:	0711      	lsls	r1, r2, #28
 8023c22:	bf48      	it	mi
 8023c24:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c28:	a864      	add	r0, sp, #400	; 0x190
 8023c2a:	63a3      	str	r3, [r4, #56]	; 0x38
 8023c2c:	bf48      	it	mi
 8023c2e:	9267      	strmi	r2, [sp, #412]	; 0x19c
 8023c30:	f000 faaa 	bl	8024188 <__gnu_Unwind_Restore_WMMXC>
 8023c34:	2000      	movs	r0, #0
 8023c36:	e7d3      	b.n	8023be0 <_Unwind_VRS_Pop+0x28>
 8023c38:	2b00      	cmp	r3, #0
 8023c3a:	d1d0      	bne.n	8023bde <_Unwind_VRS_Pop+0x26>
 8023c3c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8023c3e:	07d0      	lsls	r0, r2, #31
 8023c40:	b291      	uxth	r1, r2
 8023c42:	bf44      	itt	mi
 8023c44:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c48:	6062      	strmi	r2, [r4, #4]
 8023c4a:	078a      	lsls	r2, r1, #30
 8023c4c:	bf44      	itt	mi
 8023c4e:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c52:	60a2      	strmi	r2, [r4, #8]
 8023c54:	0748      	lsls	r0, r1, #29
 8023c56:	bf44      	itt	mi
 8023c58:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c5c:	60e2      	strmi	r2, [r4, #12]
 8023c5e:	070a      	lsls	r2, r1, #28
 8023c60:	bf44      	itt	mi
 8023c62:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c66:	6122      	strmi	r2, [r4, #16]
 8023c68:	06c8      	lsls	r0, r1, #27
 8023c6a:	bf44      	itt	mi
 8023c6c:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c70:	6162      	strmi	r2, [r4, #20]
 8023c72:	068a      	lsls	r2, r1, #26
 8023c74:	bf44      	itt	mi
 8023c76:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c7a:	61a2      	strmi	r2, [r4, #24]
 8023c7c:	0648      	lsls	r0, r1, #25
 8023c7e:	bf44      	itt	mi
 8023c80:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c84:	61e2      	strmi	r2, [r4, #28]
 8023c86:	060a      	lsls	r2, r1, #24
 8023c88:	bf44      	itt	mi
 8023c8a:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c8e:	6222      	strmi	r2, [r4, #32]
 8023c90:	05c8      	lsls	r0, r1, #23
 8023c92:	bf44      	itt	mi
 8023c94:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023c98:	6262      	strmi	r2, [r4, #36]	; 0x24
 8023c9a:	058a      	lsls	r2, r1, #22
 8023c9c:	bf44      	itt	mi
 8023c9e:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023ca2:	62a2      	strmi	r2, [r4, #40]	; 0x28
 8023ca4:	0548      	lsls	r0, r1, #21
 8023ca6:	bf44      	itt	mi
 8023ca8:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023cac:	62e2      	strmi	r2, [r4, #44]	; 0x2c
 8023cae:	050a      	lsls	r2, r1, #20
 8023cb0:	bf44      	itt	mi
 8023cb2:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023cb6:	6322      	strmi	r2, [r4, #48]	; 0x30
 8023cb8:	04c8      	lsls	r0, r1, #19
 8023cba:	bf44      	itt	mi
 8023cbc:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023cc0:	6362      	strmi	r2, [r4, #52]	; 0x34
 8023cc2:	f411 5000 	ands.w	r0, r1, #8192	; 0x2000
 8023cc6:	bf1c      	itt	ne
 8023cc8:	f853 2b04 	ldrne.w	r2, [r3], #4
 8023ccc:	63a2      	strne	r2, [r4, #56]	; 0x38
 8023cce:	044a      	lsls	r2, r1, #17
 8023cd0:	bf44      	itt	mi
 8023cd2:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023cd6:	63e2      	strmi	r2, [r4, #60]	; 0x3c
 8023cd8:	040a      	lsls	r2, r1, #16
 8023cda:	bf44      	itt	mi
 8023cdc:	f853 2b04 	ldrmi.w	r2, [r3], #4
 8023ce0:	6422      	strmi	r2, [r4, #64]	; 0x40
 8023ce2:	2800      	cmp	r0, #0
 8023ce4:	d140      	bne.n	8023d68 <_Unwind_VRS_Pop+0x1b0>
 8023ce6:	63a3      	str	r3, [r4, #56]	; 0x38
 8023ce8:	e77a      	b.n	8023be0 <_Unwind_VRS_Pop+0x28>
 8023cea:	2001      	movs	r0, #1
 8023cec:	e778      	b.n	8023be0 <_Unwind_VRS_Pop+0x28>
 8023cee:	2b03      	cmp	r3, #3
 8023cf0:	f47f af75 	bne.w	8023bde <_Unwind_VRS_Pop+0x26>
 8023cf4:	0c16      	lsrs	r6, r2, #16
 8023cf6:	b295      	uxth	r5, r2
 8023cf8:	19aa      	adds	r2, r5, r6
 8023cfa:	2a10      	cmp	r2, #16
 8023cfc:	f63f af6f 	bhi.w	8023bde <_Unwind_VRS_Pop+0x26>
 8023d00:	6823      	ldr	r3, [r4, #0]
 8023d02:	0718      	lsls	r0, r3, #28
 8023d04:	f100 810b 	bmi.w	8023f1e <_Unwind_VRS_Pop+0x366>
 8023d08:	a844      	add	r0, sp, #272	; 0x110
 8023d0a:	f000 fa1b 	bl	8024144 <__gnu_Unwind_Save_WMMXD>
 8023d0e:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8023d10:	ea4f 0e45 	mov.w	lr, r5, lsl #1
 8023d14:	463b      	mov	r3, r7
 8023d16:	b30d      	cbz	r5, 8023d5c <_Unwind_VRS_Pop+0x1a4>
 8023d18:	a944      	add	r1, sp, #272	; 0x110
 8023d1a:	f10e 3cff 	add.w	ip, lr, #4294967295
 8023d1e:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
 8023d22:	f853 0b04 	ldr.w	r0, [r3], #4
 8023d26:	4662      	mov	r2, ip
 8023d28:	f00c 0101 	and.w	r1, ip, #1
 8023d2c:	f846 0b04 	str.w	r0, [r6], #4
 8023d30:	b192      	cbz	r2, 8023d58 <_Unwind_VRS_Pop+0x1a0>
 8023d32:	b129      	cbz	r1, 8023d40 <_Unwind_VRS_Pop+0x188>
 8023d34:	f853 1b04 	ldr.w	r1, [r3], #4
 8023d38:	3a01      	subs	r2, #1
 8023d3a:	f846 1b04 	str.w	r1, [r6], #4
 8023d3e:	d00b      	beq.n	8023d58 <_Unwind_VRS_Pop+0x1a0>
 8023d40:	4618      	mov	r0, r3
 8023d42:	4631      	mov	r1, r6
 8023d44:	f850 5b04 	ldr.w	r5, [r0], #4
 8023d48:	f841 5b04 	str.w	r5, [r1], #4
 8023d4c:	685d      	ldr	r5, [r3, #4]
 8023d4e:	1d03      	adds	r3, r0, #4
 8023d50:	6075      	str	r5, [r6, #4]
 8023d52:	1d0e      	adds	r6, r1, #4
 8023d54:	3a02      	subs	r2, #2
 8023d56:	d1f3      	bne.n	8023d40 <_Unwind_VRS_Pop+0x188>
 8023d58:	eb07 038e 	add.w	r3, r7, lr, lsl #2
 8023d5c:	a844      	add	r0, sp, #272	; 0x110
 8023d5e:	63a3      	str	r3, [r4, #56]	; 0x38
 8023d60:	f000 f9ce 	bl	8024100 <__gnu_Unwind_Restore_WMMXD>
 8023d64:	2000      	movs	r0, #0
 8023d66:	e73b      	b.n	8023be0 <_Unwind_VRS_Pop+0x28>
 8023d68:	2000      	movs	r0, #0
 8023d6a:	e739      	b.n	8023be0 <_Unwind_VRS_Pop+0x28>
 8023d6c:	1977      	adds	r7, r6, r5
 8023d6e:	2220      	movs	r2, #32
 8023d70:	42ba      	cmp	r2, r7
 8023d72:	f4ff af34 	bcc.w	8023bde <_Unwind_VRS_Pop+0x26>
 8023d76:	2b01      	cmp	r3, #1
 8023d78:	f000 80a9 	beq.w	8023ece <_Unwind_VRS_Pop+0x316>
 8023d7c:	2d0f      	cmp	r5, #15
 8023d7e:	f240 80a9 	bls.w	8023ed4 <_Unwind_VRS_Pop+0x31c>
 8023d82:	4637      	mov	r7, r6
 8023d84:	b1f6      	cbz	r6, 8023dc4 <_Unwind_VRS_Pop+0x20c>
 8023d86:	2b05      	cmp	r3, #5
 8023d88:	f47f af29 	bne.w	8023bde <_Unwind_VRS_Pop+0x26>
 8023d8c:	2d0f      	cmp	r5, #15
 8023d8e:	d811      	bhi.n	8023db4 <_Unwind_VRS_Pop+0x1fc>
 8023d90:	6822      	ldr	r2, [r4, #0]
 8023d92:	07d0      	lsls	r0, r2, #31
 8023d94:	d50e      	bpl.n	8023db4 <_Unwind_VRS_Pop+0x1fc>
 8023d96:	f022 0101 	bic.w	r1, r2, #1
 8023d9a:	2b05      	cmp	r3, #5
 8023d9c:	6021      	str	r1, [r4, #0]
 8023d9e:	4620      	mov	r0, r4
 8023da0:	f000 80da 	beq.w	8023f58 <_Unwind_VRS_Pop+0x3a0>
 8023da4:	f022 0203 	bic.w	r2, r2, #3
 8023da8:	f840 2b48 	str.w	r2, [r0], #72
 8023dac:	9301      	str	r3, [sp, #4]
 8023dae:	f000 f993 	bl	80240d8 <__gnu_Unwind_Save_VFP>
 8023db2:	9b01      	ldr	r3, [sp, #4]
 8023db4:	b11f      	cbz	r7, 8023dbe <_Unwind_VRS_Pop+0x206>
 8023db6:	6822      	ldr	r2, [r4, #0]
 8023db8:	0751      	lsls	r1, r2, #29
 8023dba:	f100 80b8 	bmi.w	8023f2e <_Unwind_VRS_Pop+0x376>
 8023dbe:	2b01      	cmp	r3, #1
 8023dc0:	f000 80bf 	beq.w	8023f42 <_Unwind_VRS_Pop+0x38a>
 8023dc4:	2d0f      	cmp	r5, #15
 8023dc6:	d975      	bls.n	8023eb4 <_Unwind_VRS_Pop+0x2fc>
 8023dc8:	2f00      	cmp	r7, #0
 8023dca:	f040 80a0 	bne.w	8023f0e <_Unwind_VRS_Pop+0x356>
 8023dce:	f8d4 9038 	ldr.w	r9, [r4, #56]	; 0x38
 8023dd2:	2e00      	cmp	r6, #0
 8023dd4:	46c8      	mov	r8, r9
 8023dd6:	dd2e      	ble.n	8023e36 <_Unwind_VRS_Pop+0x27e>
 8023dd8:	4649      	mov	r1, r9
 8023dda:	f10d 0a08 	add.w	sl, sp, #8
 8023dde:	ea4f 0846 	mov.w	r8, r6, lsl #1
 8023de2:	eb0a 02c5 	add.w	r2, sl, r5, lsl #3
 8023de6:	f851 6b04 	ldr.w	r6, [r1], #4
 8023dea:	f108 30ff 	add.w	r0, r8, #4294967295
 8023dee:	f000 0a01 	and.w	sl, r0, #1
 8023df2:	f842 6b04 	str.w	r6, [r2], #4
 8023df6:	f1a8 0c02 	sub.w	ip, r8, #2
 8023dfa:	b1d0      	cbz	r0, 8023e32 <_Unwind_VRS_Pop+0x27a>
 8023dfc:	f1ba 0f00 	cmp.w	sl, #0
 8023e00:	d008      	beq.n	8023e14 <_Unwind_VRS_Pop+0x25c>
 8023e02:	f851 0b04 	ldr.w	r0, [r1], #4
 8023e06:	f10c 3cff 	add.w	ip, ip, #4294967295
 8023e0a:	f1bc 3fff 	cmp.w	ip, #4294967295
 8023e0e:	f842 0b04 	str.w	r0, [r2], #4
 8023e12:	d00e      	beq.n	8023e32 <_Unwind_VRS_Pop+0x27a>
 8023e14:	460e      	mov	r6, r1
 8023e16:	4610      	mov	r0, r2
 8023e18:	f856 ab04 	ldr.w	sl, [r6], #4
 8023e1c:	f840 ab04 	str.w	sl, [r0], #4
 8023e20:	6849      	ldr	r1, [r1, #4]
 8023e22:	f1ac 0c02 	sub.w	ip, ip, #2
 8023e26:	6051      	str	r1, [r2, #4]
 8023e28:	1d31      	adds	r1, r6, #4
 8023e2a:	1d02      	adds	r2, r0, #4
 8023e2c:	f1bc 3fff 	cmp.w	ip, #4294967295
 8023e30:	d1f0      	bne.n	8023e14 <_Unwind_VRS_Pop+0x25c>
 8023e32:	eb09 0888 	add.w	r8, r9, r8, lsl #2
 8023e36:	b3a7      	cbz	r7, 8023ea2 <_Unwind_VRS_Pop+0x2ea>
 8023e38:	2d10      	cmp	r5, #16
 8023e3a:	bf2c      	ite	cs
 8023e3c:	462e      	movcs	r6, r5
 8023e3e:	2610      	movcc	r6, #16
 8023e40:	f50d 79d0 	add.w	r9, sp, #416	; 0x1a0
 8023e44:	4641      	mov	r1, r8
 8023e46:	eb09 0cc6 	add.w	ip, r9, r6, lsl #3
 8023e4a:	f5ac 72c8 	sub.w	r2, ip, #400	; 0x190
 8023e4e:	ea4f 0947 	mov.w	r9, r7, lsl #1
 8023e52:	f851 6b04 	ldr.w	r6, [r1], #4
 8023e56:	f109 30ff 	add.w	r0, r9, #4294967295
 8023e5a:	f000 0a01 	and.w	sl, r0, #1
 8023e5e:	f842 6b04 	str.w	r6, [r2], #4
 8023e62:	f1a9 0c02 	sub.w	ip, r9, #2
 8023e66:	b1d0      	cbz	r0, 8023e9e <_Unwind_VRS_Pop+0x2e6>
 8023e68:	f1ba 0f00 	cmp.w	sl, #0
 8023e6c:	d008      	beq.n	8023e80 <_Unwind_VRS_Pop+0x2c8>
 8023e6e:	f851 0b04 	ldr.w	r0, [r1], #4
 8023e72:	f10c 3cff 	add.w	ip, ip, #4294967295
 8023e76:	f1bc 3fff 	cmp.w	ip, #4294967295
 8023e7a:	f842 0b04 	str.w	r0, [r2], #4
 8023e7e:	d00e      	beq.n	8023e9e <_Unwind_VRS_Pop+0x2e6>
 8023e80:	460e      	mov	r6, r1
 8023e82:	4610      	mov	r0, r2
 8023e84:	f856 ab04 	ldr.w	sl, [r6], #4
 8023e88:	f840 ab04 	str.w	sl, [r0], #4
 8023e8c:	6849      	ldr	r1, [r1, #4]
 8023e8e:	f1ac 0c02 	sub.w	ip, ip, #2
 8023e92:	6051      	str	r1, [r2, #4]
 8023e94:	1d31      	adds	r1, r6, #4
 8023e96:	1d02      	adds	r2, r0, #4
 8023e98:	f1bc 3fff 	cmp.w	ip, #4294967295
 8023e9c:	d1f0      	bne.n	8023e80 <_Unwind_VRS_Pop+0x2c8>
 8023e9e:	eb08 0889 	add.w	r8, r8, r9, lsl #2
 8023ea2:	2b01      	cmp	r3, #1
 8023ea4:	d02b      	beq.n	8023efe <_Unwind_VRS_Pop+0x346>
 8023ea6:	2d0f      	cmp	r5, #15
 8023ea8:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
 8023eac:	d908      	bls.n	8023ec0 <_Unwind_VRS_Pop+0x308>
 8023eae:	b9ff      	cbnz	r7, 8023ef0 <_Unwind_VRS_Pop+0x338>
 8023eb0:	4638      	mov	r0, r7
 8023eb2:	e695      	b.n	8023be0 <_Unwind_VRS_Pop+0x28>
 8023eb4:	a802      	add	r0, sp, #8
 8023eb6:	9301      	str	r3, [sp, #4]
 8023eb8:	f000 f916 	bl	80240e8 <__gnu_Unwind_Save_VFP_D>
 8023ebc:	9b01      	ldr	r3, [sp, #4]
 8023ebe:	e783      	b.n	8023dc8 <_Unwind_VRS_Pop+0x210>
 8023ec0:	a802      	add	r0, sp, #8
 8023ec2:	f000 f90d 	bl	80240e0 <__gnu_Unwind_Restore_VFP_D>
 8023ec6:	e7f2      	b.n	8023eae <_Unwind_VRS_Pop+0x2f6>
 8023ec8:	1977      	adds	r7, r6, r5
 8023eca:	2210      	movs	r2, #16
 8023ecc:	e750      	b.n	8023d70 <_Unwind_VRS_Pop+0x1b8>
 8023ece:	2d0f      	cmp	r5, #15
 8023ed0:	f63f ae85 	bhi.w	8023bde <_Unwind_VRS_Pop+0x26>
 8023ed4:	2f10      	cmp	r7, #16
 8023ed6:	d910      	bls.n	8023efa <_Unwind_VRS_Pop+0x342>
 8023ed8:	3f10      	subs	r7, #16
 8023eda:	e754      	b.n	8023d86 <_Unwind_VRS_Pop+0x1ce>
 8023edc:	f023 0310 	bic.w	r3, r3, #16
 8023ee0:	6023      	str	r3, [r4, #0]
 8023ee2:	f504 700c 	add.w	r0, r4, #560	; 0x230
 8023ee6:	9201      	str	r2, [sp, #4]
 8023ee8:	f000 f958 	bl	802419c <__gnu_Unwind_Save_WMMXC>
 8023eec:	9a01      	ldr	r2, [sp, #4]
 8023eee:	e682      	b.n	8023bf6 <_Unwind_VRS_Pop+0x3e>
 8023ef0:	a824      	add	r0, sp, #144	; 0x90
 8023ef2:	f000 f8fd 	bl	80240f0 <__gnu_Unwind_Restore_VFP_D_16_to_31>
 8023ef6:	2000      	movs	r0, #0
 8023ef8:	e672      	b.n	8023be0 <_Unwind_VRS_Pop+0x28>
 8023efa:	2700      	movs	r7, #0
 8023efc:	e746      	b.n	8023d8c <_Unwind_VRS_Pop+0x1d4>
 8023efe:	f108 0304 	add.w	r3, r8, #4
 8023f02:	a802      	add	r0, sp, #8
 8023f04:	63a3      	str	r3, [r4, #56]	; 0x38
 8023f06:	f000 f8e3 	bl	80240d0 <__gnu_Unwind_Restore_VFP>
 8023f0a:	2000      	movs	r0, #0
 8023f0c:	e668      	b.n	8023be0 <_Unwind_VRS_Pop+0x28>
 8023f0e:	a824      	add	r0, sp, #144	; 0x90
 8023f10:	9301      	str	r3, [sp, #4]
 8023f12:	f1c5 0610 	rsb	r6, r5, #16
 8023f16:	f000 f8ef 	bl	80240f8 <__gnu_Unwind_Save_VFP_D_16_to_31>
 8023f1a:	9b01      	ldr	r3, [sp, #4]
 8023f1c:	e757      	b.n	8023dce <_Unwind_VRS_Pop+0x216>
 8023f1e:	f023 0708 	bic.w	r7, r3, #8
 8023f22:	f504 70d8 	add.w	r0, r4, #432	; 0x1b0
 8023f26:	6027      	str	r7, [r4, #0]
 8023f28:	f000 f90c 	bl	8024144 <__gnu_Unwind_Save_WMMXD>
 8023f2c:	e6ec      	b.n	8023d08 <_Unwind_VRS_Pop+0x150>
 8023f2e:	4620      	mov	r0, r4
 8023f30:	f022 0104 	bic.w	r1, r2, #4
 8023f34:	f840 1bd0 	str.w	r1, [r0], #208
 8023f38:	9301      	str	r3, [sp, #4]
 8023f3a:	f000 f8dd 	bl	80240f8 <__gnu_Unwind_Save_VFP_D_16_to_31>
 8023f3e:	9b01      	ldr	r3, [sp, #4]
 8023f40:	e73d      	b.n	8023dbe <_Unwind_VRS_Pop+0x206>
 8023f42:	a802      	add	r0, sp, #8
 8023f44:	9301      	str	r3, [sp, #4]
 8023f46:	f000 f8c7 	bl	80240d8 <__gnu_Unwind_Save_VFP>
 8023f4a:	9b01      	ldr	r3, [sp, #4]
 8023f4c:	2f00      	cmp	r7, #0
 8023f4e:	f43f af3e 	beq.w	8023dce <_Unwind_VRS_Pop+0x216>
 8023f52:	f1c5 0610 	rsb	r6, r5, #16
 8023f56:	e73a      	b.n	8023dce <_Unwind_VRS_Pop+0x216>
 8023f58:	f041 0102 	orr.w	r1, r1, #2
 8023f5c:	f840 1b48 	str.w	r1, [r0], #72
 8023f60:	9301      	str	r3, [sp, #4]
 8023f62:	f000 f8c1 	bl	80240e8 <__gnu_Unwind_Save_VFP_D>
 8023f66:	9b01      	ldr	r3, [sp, #4]
 8023f68:	e724      	b.n	8023db4 <_Unwind_VRS_Pop+0x1fc>
 8023f6a:	bf00      	nop

08023f6c <_Unwind_GetCFA>:
 8023f6c:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8023f6e:	4770      	bx	lr

08023f70 <__gnu_Unwind_RaiseException>:
 8023f70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023f72:	460d      	mov	r5, r1
 8023f74:	1d0f      	adds	r7, r1, #4
 8023f76:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 8023f78:	6429      	str	r1, [r5, #64]	; 0x40
 8023f7a:	4604      	mov	r4, r0
 8023f7c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8023f7e:	f5ad 7d11 	sub.w	sp, sp, #580	; 0x244
 8023f82:	ae01      	add	r6, sp, #4
 8023f84:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8023f86:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8023f88:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8023f8a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8023f8c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8023f8e:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 8023f92:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
 8023f96:	f04f 33ff 	mov.w	r3, #4294967295
 8023f9a:	9300      	str	r3, [sp, #0]
 8023f9c:	9910      	ldr	r1, [sp, #64]	; 0x40
 8023f9e:	4620      	mov	r0, r4
 8023fa0:	f7ff fb22 	bl	80235e8 <get_eit_entry>
 8023fa4:	b958      	cbnz	r0, 8023fbe <__gnu_Unwind_RaiseException+0x4e>
 8023fa6:	6926      	ldr	r6, [r4, #16]
 8023fa8:	4621      	mov	r1, r4
 8023faa:	466a      	mov	r2, sp
 8023fac:	47b0      	blx	r6
 8023fae:	2808      	cmp	r0, #8
 8023fb0:	4606      	mov	r6, r0
 8023fb2:	d0f3      	beq.n	8023f9c <__gnu_Unwind_RaiseException+0x2c>
 8023fb4:	4668      	mov	r0, sp
 8023fb6:	f7ff fb7b 	bl	80236b0 <restore_non_core_regs>
 8023fba:	2e06      	cmp	r6, #6
 8023fbc:	d003      	beq.n	8023fc6 <__gnu_Unwind_RaiseException+0x56>
 8023fbe:	2009      	movs	r0, #9
 8023fc0:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
 8023fc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023fc6:	4620      	mov	r0, r4
 8023fc8:	4629      	mov	r1, r5
 8023fca:	f7ff fc07 	bl	80237dc <unwind_phase2>
 8023fce:	bf00      	nop

08023fd0 <__gnu_Unwind_ForcedUnwind>:
 8023fd0:	b410      	push	{r4}
 8023fd2:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8023fd4:	60c1      	str	r1, [r0, #12]
 8023fd6:	6182      	str	r2, [r0, #24]
 8023fd8:	4619      	mov	r1, r3
 8023fda:	2200      	movs	r2, #0
 8023fdc:	641c      	str	r4, [r3, #64]	; 0x40
 8023fde:	bc10      	pop	{r4}
 8023fe0:	f7ff bb92 	b.w	8023708 <unwind_phase2_forced>

08023fe4 <__gnu_Unwind_Resume>:
 8023fe4:	b538      	push	{r3, r4, r5, lr}
 8023fe6:	6942      	ldr	r2, [r0, #20]
 8023fe8:	68c3      	ldr	r3, [r0, #12]
 8023fea:	640a      	str	r2, [r1, #64]	; 0x40
 8023fec:	4604      	mov	r4, r0
 8023fee:	460d      	mov	r5, r1
 8023ff0:	b123      	cbz	r3, 8023ffc <__gnu_Unwind_Resume+0x18>
 8023ff2:	2201      	movs	r2, #1
 8023ff4:	f7ff fb88 	bl	8023708 <unwind_phase2_forced>
 8023ff8:	f005 f8d4 	bl	80291a4 <abort>
 8023ffc:	6903      	ldr	r3, [r0, #16]
 8023ffe:	4621      	mov	r1, r4
 8024000:	2002      	movs	r0, #2
 8024002:	462a      	mov	r2, r5
 8024004:	4798      	blx	r3
 8024006:	2807      	cmp	r0, #7
 8024008:	d003      	beq.n	8024012 <__gnu_Unwind_Resume+0x2e>
 802400a:	2808      	cmp	r0, #8
 802400c:	d004      	beq.n	8024018 <__gnu_Unwind_Resume+0x34>
 802400e:	f005 f8c9 	bl	80291a4 <abort>
 8024012:	1d28      	adds	r0, r5, #4
 8024014:	f000 f850 	bl	80240b8 <__restore_core_regs>
 8024018:	4620      	mov	r0, r4
 802401a:	4629      	mov	r1, r5
 802401c:	f7ff fbde 	bl	80237dc <unwind_phase2>

08024020 <__gnu_Unwind_Resume_or_Rethrow>:
 8024020:	68c3      	ldr	r3, [r0, #12]
 8024022:	b123      	cbz	r3, 802402e <__gnu_Unwind_Resume_or_Rethrow+0xe>
 8024024:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 8024026:	640a      	str	r2, [r1, #64]	; 0x40
 8024028:	2200      	movs	r2, #0
 802402a:	f7ff bb6d 	b.w	8023708 <unwind_phase2_forced>
 802402e:	e79f      	b.n	8023f70 <__gnu_Unwind_RaiseException>

08024030 <_Unwind_Complete>:
 8024030:	4770      	bx	lr
 8024032:	bf00      	nop

08024034 <_Unwind_DeleteException>:
 8024034:	b508      	push	{r3, lr}
 8024036:	6883      	ldr	r3, [r0, #8]
 8024038:	4601      	mov	r1, r0
 802403a:	b10b      	cbz	r3, 8024040 <_Unwind_DeleteException+0xc>
 802403c:	2001      	movs	r0, #1
 802403e:	4798      	blx	r3
 8024040:	bd08      	pop	{r3, pc}
 8024042:	bf00      	nop

08024044 <__gnu_Unwind_Backtrace>:
 8024044:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024046:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
 8024048:	1d17      	adds	r7, r2, #4
 802404a:	6414      	str	r4, [r2, #64]	; 0x40
 802404c:	4605      	mov	r5, r0
 802404e:	460c      	mov	r4, r1
 8024050:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8024052:	f5ad 7d27 	sub.w	sp, sp, #668	; 0x29c
 8024056:	ae01      	add	r6, sp, #4
 8024058:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 802405a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 802405c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 802405e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8024060:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8024062:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 8024066:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
 802406a:	f04f 33ff 	mov.w	r3, #4294967295
 802406e:	9300      	str	r3, [sp, #0]
 8024070:	9910      	ldr	r1, [sp, #64]	; 0x40
 8024072:	a890      	add	r0, sp, #576	; 0x240
 8024074:	f7ff fab8 	bl	80235e8 <get_eit_entry>
 8024078:	4603      	mov	r3, r0
 802407a:	aa90      	add	r2, sp, #576	; 0x240
 802407c:	4668      	mov	r0, sp
 802407e:	210c      	movs	r1, #12
 8024080:	b9bb      	cbnz	r3, 80240b2 <__gnu_Unwind_Backtrace+0x6e>
 8024082:	f7ff fbf7 	bl	8023874 <_Unwind_SetGR>
 8024086:	4621      	mov	r1, r4
 8024088:	4668      	mov	r0, sp
 802408a:	47a8      	blx	r5
 802408c:	4606      	mov	r6, r0
 802408e:	a990      	add	r1, sp, #576	; 0x240
 8024090:	2008      	movs	r0, #8
 8024092:	466a      	mov	r2, sp
 8024094:	b96e      	cbnz	r6, 80240b2 <__gnu_Unwind_Backtrace+0x6e>
 8024096:	9b94      	ldr	r3, [sp, #592]	; 0x250
 8024098:	4798      	blx	r3
 802409a:	2805      	cmp	r0, #5
 802409c:	4606      	mov	r6, r0
 802409e:	d001      	beq.n	80240a4 <__gnu_Unwind_Backtrace+0x60>
 80240a0:	2809      	cmp	r0, #9
 80240a2:	d1e5      	bne.n	8024070 <__gnu_Unwind_Backtrace+0x2c>
 80240a4:	4668      	mov	r0, sp
 80240a6:	f7ff fb03 	bl	80236b0 <restore_non_core_regs>
 80240aa:	4630      	mov	r0, r6
 80240ac:	f50d 7d27 	add.w	sp, sp, #668	; 0x29c
 80240b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80240b2:	2609      	movs	r6, #9
 80240b4:	e7f6      	b.n	80240a4 <__gnu_Unwind_Backtrace+0x60>
 80240b6:	bf00      	nop

080240b8 <__restore_core_regs>:
 80240b8:	f100 0134 	add.w	r1, r0, #52	; 0x34
 80240bc:	e891 0038 	ldmia.w	r1, {r3, r4, r5}
 80240c0:	469c      	mov	ip, r3
 80240c2:	46a6      	mov	lr, r4
 80240c4:	f84c 5d04 	str.w	r5, [ip, #-4]!
 80240c8:	e890 0fff 	ldmia.w	r0, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
 80240cc:	46e5      	mov	sp, ip
 80240ce:	bd00      	pop	{pc}

080240d0 <__gnu_Unwind_Restore_VFP>:
 80240d0:	ec90 0b21 	fldmiax	r0, {d0-d15}	;@ Deprecated
 80240d4:	4770      	bx	lr
 80240d6:	bf00      	nop

080240d8 <__gnu_Unwind_Save_VFP>:
 80240d8:	ec80 0b21 	fstmiax	r0, {d0-d15}	;@ Deprecated
 80240dc:	4770      	bx	lr
 80240de:	bf00      	nop

080240e0 <__gnu_Unwind_Restore_VFP_D>:
 80240e0:	ec90 0b20 	vldmia	r0, {d0-d15}
 80240e4:	4770      	bx	lr
 80240e6:	bf00      	nop

080240e8 <__gnu_Unwind_Save_VFP_D>:
 80240e8:	ec80 0b20 	vstmia	r0, {d0-d15}
 80240ec:	4770      	bx	lr
 80240ee:	bf00      	nop

080240f0 <__gnu_Unwind_Restore_VFP_D_16_to_31>:
 80240f0:	ecd0 0b20 	vldmia	r0, {d16-d31}
 80240f4:	4770      	bx	lr
 80240f6:	bf00      	nop

080240f8 <__gnu_Unwind_Save_VFP_D_16_to_31>:
 80240f8:	ecc0 0b20 	vstmia	r0, {d16-d31}
 80240fc:	4770      	bx	lr
 80240fe:	bf00      	nop

08024100 <__gnu_Unwind_Restore_WMMXD>:
 8024100:	ecf0 0102 	ldfe	f0, [r0], #8
 8024104:	ecf0 1102 	ldfe	f1, [r0], #8
 8024108:	ecf0 2102 	ldfe	f2, [r0], #8
 802410c:	ecf0 3102 	ldfe	f3, [r0], #8
 8024110:	ecf0 4102 	ldfe	f4, [r0], #8
 8024114:	ecf0 5102 	ldfe	f5, [r0], #8
 8024118:	ecf0 6102 	ldfe	f6, [r0], #8
 802411c:	ecf0 7102 	ldfe	f7, [r0], #8
 8024120:	ecf0 8102 	ldfp	f0, [r0], #8
 8024124:	ecf0 9102 	ldfp	f1, [r0], #8
 8024128:	ecf0 a102 	ldfp	f2, [r0], #8
 802412c:	ecf0 b102 	ldfp	f3, [r0], #8
 8024130:	ecf0 c102 	ldfp	f4, [r0], #8
 8024134:	ecf0 d102 	ldfp	f5, [r0], #8
 8024138:	ecf0 e102 	ldfp	f6, [r0], #8
 802413c:	ecf0 f102 	ldfp	f7, [r0], #8
 8024140:	4770      	bx	lr
 8024142:	bf00      	nop

08024144 <__gnu_Unwind_Save_WMMXD>:
 8024144:	ece0 0102 	stfe	f0, [r0], #8
 8024148:	ece0 1102 	stfe	f1, [r0], #8
 802414c:	ece0 2102 	stfe	f2, [r0], #8
 8024150:	ece0 3102 	stfe	f3, [r0], #8
 8024154:	ece0 4102 	stfe	f4, [r0], #8
 8024158:	ece0 5102 	stfe	f5, [r0], #8
 802415c:	ece0 6102 	stfe	f6, [r0], #8
 8024160:	ece0 7102 	stfe	f7, [r0], #8
 8024164:	ece0 8102 	stfp	f0, [r0], #8
 8024168:	ece0 9102 	stfp	f1, [r0], #8
 802416c:	ece0 a102 	stfp	f2, [r0], #8
 8024170:	ece0 b102 	stfp	f3, [r0], #8
 8024174:	ece0 c102 	stfp	f4, [r0], #8
 8024178:	ece0 d102 	stfp	f5, [r0], #8
 802417c:	ece0 e102 	stfp	f6, [r0], #8
 8024180:	ece0 f102 	stfp	f7, [r0], #8
 8024184:	4770      	bx	lr
 8024186:	bf00      	nop

08024188 <__gnu_Unwind_Restore_WMMXC>:
 8024188:	fcb0 8101 	ldc2	1, cr8, [r0], #4
 802418c:	fcb0 9101 	ldc2	1, cr9, [r0], #4
 8024190:	fcb0 a101 	ldc2	1, cr10, [r0], #4
 8024194:	fcb0 b101 	ldc2	1, cr11, [r0], #4
 8024198:	4770      	bx	lr
 802419a:	bf00      	nop

0802419c <__gnu_Unwind_Save_WMMXC>:
 802419c:	fca0 8101 	stc2	1, cr8, [r0], #4
 80241a0:	fca0 9101 	stc2	1, cr9, [r0], #4
 80241a4:	fca0 a101 	stc2	1, cr10, [r0], #4
 80241a8:	fca0 b101 	stc2	1, cr11, [r0], #4
 80241ac:	4770      	bx	lr
 80241ae:	bf00      	nop

080241b0 <_Unwind_RaiseException>:
 80241b0:	46ec      	mov	ip, sp
 80241b2:	b500      	push	{lr}
 80241b4:	e92d 5000 	stmdb	sp!, {ip, lr}
 80241b8:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 80241bc:	f04f 0300 	mov.w	r3, #0
 80241c0:	e92d 000c 	stmdb	sp!, {r2, r3}
 80241c4:	a901      	add	r1, sp, #4
 80241c6:	f7ff fed3 	bl	8023f70 <__gnu_Unwind_RaiseException>
 80241ca:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 80241ce:	b012      	add	sp, #72	; 0x48
 80241d0:	4770      	bx	lr
 80241d2:	bf00      	nop

080241d4 <_Unwind_Resume>:
 80241d4:	46ec      	mov	ip, sp
 80241d6:	b500      	push	{lr}
 80241d8:	e92d 5000 	stmdb	sp!, {ip, lr}
 80241dc:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 80241e0:	f04f 0300 	mov.w	r3, #0
 80241e4:	e92d 000c 	stmdb	sp!, {r2, r3}
 80241e8:	a901      	add	r1, sp, #4
 80241ea:	f7ff fefb 	bl	8023fe4 <__gnu_Unwind_Resume>
 80241ee:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 80241f2:	b012      	add	sp, #72	; 0x48
 80241f4:	4770      	bx	lr
 80241f6:	bf00      	nop

080241f8 <_Unwind_Resume_or_Rethrow>:
 80241f8:	46ec      	mov	ip, sp
 80241fa:	b500      	push	{lr}
 80241fc:	e92d 5000 	stmdb	sp!, {ip, lr}
 8024200:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8024204:	f04f 0300 	mov.w	r3, #0
 8024208:	e92d 000c 	stmdb	sp!, {r2, r3}
 802420c:	a901      	add	r1, sp, #4
 802420e:	f7ff ff07 	bl	8024020 <__gnu_Unwind_Resume_or_Rethrow>
 8024212:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8024216:	b012      	add	sp, #72	; 0x48
 8024218:	4770      	bx	lr
 802421a:	bf00      	nop

0802421c <_Unwind_ForcedUnwind>:
 802421c:	46ec      	mov	ip, sp
 802421e:	b500      	push	{lr}
 8024220:	e92d 5000 	stmdb	sp!, {ip, lr}
 8024224:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8024228:	f04f 0300 	mov.w	r3, #0
 802422c:	e92d 000c 	stmdb	sp!, {r2, r3}
 8024230:	ab01      	add	r3, sp, #4
 8024232:	f7ff fecd 	bl	8023fd0 <__gnu_Unwind_ForcedUnwind>
 8024236:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 802423a:	b012      	add	sp, #72	; 0x48
 802423c:	4770      	bx	lr
 802423e:	bf00      	nop

08024240 <_Unwind_Backtrace>:
 8024240:	46ec      	mov	ip, sp
 8024242:	b500      	push	{lr}
 8024244:	e92d 5000 	stmdb	sp!, {ip, lr}
 8024248:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 802424c:	f04f 0300 	mov.w	r3, #0
 8024250:	e92d 000c 	stmdb	sp!, {r2, r3}
 8024254:	aa01      	add	r2, sp, #4
 8024256:	f7ff fef5 	bl	8024044 <__gnu_Unwind_Backtrace>
 802425a:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 802425e:	b012      	add	sp, #72	; 0x48
 8024260:	4770      	bx	lr
 8024262:	bf00      	nop

08024264 <next_unwind_byte>:
 8024264:	7a02      	ldrb	r2, [r0, #8]
 8024266:	4603      	mov	r3, r0
 8024268:	b91a      	cbnz	r2, 8024272 <next_unwind_byte+0xe>
 802426a:	7a42      	ldrb	r2, [r0, #9]
 802426c:	b942      	cbnz	r2, 8024280 <next_unwind_byte+0x1c>
 802426e:	20b0      	movs	r0, #176	; 0xb0
 8024270:	4770      	bx	lr
 8024272:	6800      	ldr	r0, [r0, #0]
 8024274:	3a01      	subs	r2, #1
 8024276:	0201      	lsls	r1, r0, #8
 8024278:	721a      	strb	r2, [r3, #8]
 802427a:	0e00      	lsrs	r0, r0, #24
 802427c:	6019      	str	r1, [r3, #0]
 802427e:	4770      	bx	lr
 8024280:	6841      	ldr	r1, [r0, #4]
 8024282:	1e50      	subs	r0, r2, #1
 8024284:	7258      	strb	r0, [r3, #9]
 8024286:	f851 0b04 	ldr.w	r0, [r1], #4
 802428a:	2203      	movs	r2, #3
 802428c:	6059      	str	r1, [r3, #4]
 802428e:	0201      	lsls	r1, r0, #8
 8024290:	721a      	strb	r2, [r3, #8]
 8024292:	0e00      	lsrs	r0, r0, #24
 8024294:	6019      	str	r1, [r3, #0]
 8024296:	4770      	bx	lr

08024298 <_Unwind_GetGR.constprop.0>:
 8024298:	b510      	push	{r4, lr}
 802429a:	2100      	movs	r1, #0
 802429c:	b084      	sub	sp, #16
 802429e:	220c      	movs	r2, #12
 80242a0:	eb0d 0402 	add.w	r4, sp, r2
 80242a4:	460b      	mov	r3, r1
 80242a6:	9400      	str	r4, [sp, #0]
 80242a8:	f7ff fab0 	bl	802380c <_Unwind_VRS_Get>
 80242ac:	9803      	ldr	r0, [sp, #12]
 80242ae:	b004      	add	sp, #16
 80242b0:	bd10      	pop	{r4, pc}
 80242b2:	bf00      	nop

080242b4 <unwind_UCB_from_context>:
 80242b4:	e7f0      	b.n	8024298 <_Unwind_GetGR.constprop.0>
 80242b6:	bf00      	nop

080242b8 <__gnu_unwind_execute>:
 80242b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80242bc:	4606      	mov	r6, r0
 80242be:	b085      	sub	sp, #20
 80242c0:	460d      	mov	r5, r1
 80242c2:	f04f 0900 	mov.w	r9, #0
 80242c6:	f44f 677f 	mov.w	r7, #4080	; 0xff0
 80242ca:	4628      	mov	r0, r5
 80242cc:	f7ff ffca 	bl	8024264 <next_unwind_byte>
 80242d0:	28b0      	cmp	r0, #176	; 0xb0
 80242d2:	4604      	mov	r4, r0
 80242d4:	f000 80b0 	beq.w	8024438 <__gnu_unwind_execute+0x180>
 80242d8:	f010 0180 	ands.w	r1, r0, #128	; 0x80
 80242dc:	d020      	beq.n	8024320 <__gnu_unwind_execute+0x68>
 80242de:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
 80242e2:	2b80      	cmp	r3, #128	; 0x80
 80242e4:	d074      	beq.n	80243d0 <__gnu_unwind_execute+0x118>
 80242e6:	2b90      	cmp	r3, #144	; 0x90
 80242e8:	d037      	beq.n	802435a <__gnu_unwind_execute+0xa2>
 80242ea:	2ba0      	cmp	r3, #160	; 0xa0
 80242ec:	d045      	beq.n	802437a <__gnu_unwind_execute+0xc2>
 80242ee:	2bb0      	cmp	r3, #176	; 0xb0
 80242f0:	d056      	beq.n	80243a0 <__gnu_unwind_execute+0xe8>
 80242f2:	2bc0      	cmp	r3, #192	; 0xc0
 80242f4:	f000 8085 	beq.w	8024402 <__gnu_unwind_execute+0x14a>
 80242f8:	f000 00f8 	and.w	r0, r0, #248	; 0xf8
 80242fc:	28d0      	cmp	r0, #208	; 0xd0
 80242fe:	d10b      	bne.n	8024318 <__gnu_unwind_execute+0x60>
 8024300:	f004 0207 	and.w	r2, r4, #7
 8024304:	1c51      	adds	r1, r2, #1
 8024306:	f441 2200 	orr.w	r2, r1, #524288	; 0x80000
 802430a:	4630      	mov	r0, r6
 802430c:	2101      	movs	r1, #1
 802430e:	2305      	movs	r3, #5
 8024310:	f7ff fc52 	bl	8023bb8 <_Unwind_VRS_Pop>
 8024314:	2800      	cmp	r0, #0
 8024316:	d0d8      	beq.n	80242ca <__gnu_unwind_execute+0x12>
 8024318:	2009      	movs	r0, #9
 802431a:	b005      	add	sp, #20
 802431c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8024320:	ea4f 0280 	mov.w	r2, r0, lsl #2
 8024324:	a803      	add	r0, sp, #12
 8024326:	fa5f f882 	uxtb.w	r8, r2
 802432a:	9000      	str	r0, [sp, #0]
 802432c:	220d      	movs	r2, #13
 802432e:	460b      	mov	r3, r1
 8024330:	4630      	mov	r0, r6
 8024332:	f7ff fa6b 	bl	802380c <_Unwind_VRS_Get>
 8024336:	9b03      	ldr	r3, [sp, #12]
 8024338:	0660      	lsls	r0, r4, #25
 802433a:	f108 0804 	add.w	r8, r8, #4
 802433e:	bf4c      	ite	mi
 8024340:	ebc8 0303 	rsbmi	r3, r8, r3
 8024344:	4443      	addpl	r3, r8
 8024346:	ac03      	add	r4, sp, #12
 8024348:	9303      	str	r3, [sp, #12]
 802434a:	9400      	str	r4, [sp, #0]
 802434c:	2100      	movs	r1, #0
 802434e:	4630      	mov	r0, r6
 8024350:	220d      	movs	r2, #13
 8024352:	460b      	mov	r3, r1
 8024354:	f7ff fa7a 	bl	802384c <_Unwind_VRS_Set>
 8024358:	e7b7      	b.n	80242ca <__gnu_unwind_execute+0x12>
 802435a:	f000 020f 	and.w	r2, r0, #15
 802435e:	2a0d      	cmp	r2, #13
 8024360:	d0da      	beq.n	8024318 <__gnu_unwind_execute+0x60>
 8024362:	2a0f      	cmp	r2, #15
 8024364:	d0d8      	beq.n	8024318 <__gnu_unwind_execute+0x60>
 8024366:	2100      	movs	r1, #0
 8024368:	ac03      	add	r4, sp, #12
 802436a:	9400      	str	r4, [sp, #0]
 802436c:	4630      	mov	r0, r6
 802436e:	460b      	mov	r3, r1
 8024370:	ac03      	add	r4, sp, #12
 8024372:	f7ff fa4b 	bl	802380c <_Unwind_VRS_Get>
 8024376:	9400      	str	r4, [sp, #0]
 8024378:	e7e8      	b.n	802434c <__gnu_unwind_execute+0x94>
 802437a:	43c2      	mvns	r2, r0
 802437c:	f002 0c07 	and.w	ip, r2, #7
 8024380:	fa47 f00c 	asr.w	r0, r7, ip
 8024384:	0721      	lsls	r1, r4, #28
 8024386:	f400 627f 	and.w	r2, r0, #4080	; 0xff0
 802438a:	bf48      	it	mi
 802438c:	f442 4280 	orrmi.w	r2, r2, #16384	; 0x4000
 8024390:	2100      	movs	r1, #0
 8024392:	4630      	mov	r0, r6
 8024394:	460b      	mov	r3, r1
 8024396:	f7ff fc0f 	bl	8023bb8 <_Unwind_VRS_Pop>
 802439a:	2800      	cmp	r0, #0
 802439c:	d1bc      	bne.n	8024318 <__gnu_unwind_execute+0x60>
 802439e:	e794      	b.n	80242ca <__gnu_unwind_execute+0x12>
 80243a0:	28b1      	cmp	r0, #177	; 0xb1
 80243a2:	d05d      	beq.n	8024460 <__gnu_unwind_execute+0x1a8>
 80243a4:	28b2      	cmp	r0, #178	; 0xb2
 80243a6:	d06e      	beq.n	8024486 <__gnu_unwind_execute+0x1ce>
 80243a8:	28b3      	cmp	r0, #179	; 0xb3
 80243aa:	f000 8095 	beq.w	80244d8 <__gnu_unwind_execute+0x220>
 80243ae:	f000 02fc 	and.w	r2, r0, #252	; 0xfc
 80243b2:	2ab4      	cmp	r2, #180	; 0xb4
 80243b4:	d046      	beq.n	8024444 <__gnu_unwind_execute+0x18c>
 80243b6:	f000 0207 	and.w	r2, r0, #7
 80243ba:	1c53      	adds	r3, r2, #1
 80243bc:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
 80243c0:	2101      	movs	r1, #1
 80243c2:	4630      	mov	r0, r6
 80243c4:	460b      	mov	r3, r1
 80243c6:	f7ff fbf7 	bl	8023bb8 <_Unwind_VRS_Pop>
 80243ca:	2800      	cmp	r0, #0
 80243cc:	d1a4      	bne.n	8024318 <__gnu_unwind_execute+0x60>
 80243ce:	e77c      	b.n	80242ca <__gnu_unwind_execute+0x12>
 80243d0:	4628      	mov	r0, r5
 80243d2:	f7ff ff47 	bl	8024264 <next_unwind_byte>
 80243d6:	0221      	lsls	r1, r4, #8
 80243d8:	ea40 0401 	orr.w	r4, r0, r1
 80243dc:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
 80243e0:	d09a      	beq.n	8024318 <__gnu_unwind_execute+0x60>
 80243e2:	0523      	lsls	r3, r4, #20
 80243e4:	2100      	movs	r1, #0
 80243e6:	0c1a      	lsrs	r2, r3, #16
 80243e8:	4630      	mov	r0, r6
 80243ea:	460b      	mov	r3, r1
 80243ec:	0124      	lsls	r4, r4, #4
 80243ee:	f7ff fbe3 	bl	8023bb8 <_Unwind_VRS_Pop>
 80243f2:	2800      	cmp	r0, #0
 80243f4:	d190      	bne.n	8024318 <__gnu_unwind_execute+0x60>
 80243f6:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 80243fa:	bf18      	it	ne
 80243fc:	f04f 0901 	movne.w	r9, #1
 8024400:	e763      	b.n	80242ca <__gnu_unwind_execute+0x12>
 8024402:	28c6      	cmp	r0, #198	; 0xc6
 8024404:	d073      	beq.n	80244ee <__gnu_unwind_execute+0x236>
 8024406:	28c7      	cmp	r0, #199	; 0xc7
 8024408:	f000 8084 	beq.w	8024514 <__gnu_unwind_execute+0x25c>
 802440c:	f000 02f8 	and.w	r2, r0, #248	; 0xf8
 8024410:	2ac0      	cmp	r2, #192	; 0xc0
 8024412:	f000 8092 	beq.w	802453a <__gnu_unwind_execute+0x282>
 8024416:	28c8      	cmp	r0, #200	; 0xc8
 8024418:	f000 80a6 	beq.w	8024568 <__gnu_unwind_execute+0x2b0>
 802441c:	28c9      	cmp	r0, #201	; 0xc9
 802441e:	f47f af7b 	bne.w	8024318 <__gnu_unwind_execute+0x60>
 8024422:	4628      	mov	r0, r5
 8024424:	f7ff ff1e 	bl	8024264 <next_unwind_byte>
 8024428:	f000 030f 	and.w	r3, r0, #15
 802442c:	f000 01f0 	and.w	r1, r0, #240	; 0xf0
 8024430:	1c5a      	adds	r2, r3, #1
 8024432:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
 8024436:	e768      	b.n	802430a <__gnu_unwind_execute+0x52>
 8024438:	f1b9 0f00 	cmp.w	r9, #0
 802443c:	f000 8083 	beq.w	8024546 <__gnu_unwind_execute+0x28e>
 8024440:	2000      	movs	r0, #0
 8024442:	e76a      	b.n	802431a <__gnu_unwind_execute+0x62>
 8024444:	f000 0103 	and.w	r1, r0, #3
 8024448:	1c48      	adds	r0, r1, #1
 802444a:	2102      	movs	r1, #2
 802444c:	f440 2280 	orr.w	r2, r0, #262144	; 0x40000
 8024450:	460b      	mov	r3, r1
 8024452:	4630      	mov	r0, r6
 8024454:	f7ff fbb0 	bl	8023bb8 <_Unwind_VRS_Pop>
 8024458:	2800      	cmp	r0, #0
 802445a:	f47f af5d 	bne.w	8024318 <__gnu_unwind_execute+0x60>
 802445e:	e734      	b.n	80242ca <__gnu_unwind_execute+0x12>
 8024460:	4628      	mov	r0, r5
 8024462:	f7ff feff 	bl	8024264 <next_unwind_byte>
 8024466:	4602      	mov	r2, r0
 8024468:	2800      	cmp	r0, #0
 802446a:	f43f af55 	beq.w	8024318 <__gnu_unwind_execute+0x60>
 802446e:	f010 01f0 	ands.w	r1, r0, #240	; 0xf0
 8024472:	f47f af51 	bne.w	8024318 <__gnu_unwind_execute+0x60>
 8024476:	4630      	mov	r0, r6
 8024478:	460b      	mov	r3, r1
 802447a:	f7ff fb9d 	bl	8023bb8 <_Unwind_VRS_Pop>
 802447e:	2800      	cmp	r0, #0
 8024480:	f47f af4a 	bne.w	8024318 <__gnu_unwind_execute+0x60>
 8024484:	e721      	b.n	80242ca <__gnu_unwind_execute+0x12>
 8024486:	2100      	movs	r1, #0
 8024488:	220d      	movs	r2, #13
 802448a:	460b      	mov	r3, r1
 802448c:	ac03      	add	r4, sp, #12
 802448e:	4630      	mov	r0, r6
 8024490:	9400      	str	r4, [sp, #0]
 8024492:	f7ff f9bb 	bl	802380c <_Unwind_VRS_Get>
 8024496:	4628      	mov	r0, r5
 8024498:	f7ff fee4 	bl	8024264 <next_unwind_byte>
 802449c:	2402      	movs	r4, #2
 802449e:	0602      	lsls	r2, r0, #24
 80244a0:	d50d      	bpl.n	80244be <__gnu_unwind_execute+0x206>
 80244a2:	9b03      	ldr	r3, [sp, #12]
 80244a4:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 80244a8:	fa00 fe04 	lsl.w	lr, r0, r4
 80244ac:	eb03 010e 	add.w	r1, r3, lr
 80244b0:	4628      	mov	r0, r5
 80244b2:	9103      	str	r1, [sp, #12]
 80244b4:	f7ff fed6 	bl	8024264 <next_unwind_byte>
 80244b8:	3407      	adds	r4, #7
 80244ba:	0603      	lsls	r3, r0, #24
 80244bc:	d4f1      	bmi.n	80244a2 <__gnu_unwind_execute+0x1ea>
 80244be:	9b03      	ldr	r3, [sp, #12]
 80244c0:	f000 017f 	and.w	r1, r0, #127	; 0x7f
 80244c4:	aa03      	add	r2, sp, #12
 80244c6:	f503 7c01 	add.w	ip, r3, #516	; 0x204
 80244ca:	fa01 f404 	lsl.w	r4, r1, r4
 80244ce:	9200      	str	r2, [sp, #0]
 80244d0:	eb0c 0204 	add.w	r2, ip, r4
 80244d4:	9203      	str	r2, [sp, #12]
 80244d6:	e739      	b.n	802434c <__gnu_unwind_execute+0x94>
 80244d8:	4628      	mov	r0, r5
 80244da:	f7ff fec3 	bl	8024264 <next_unwind_byte>
 80244de:	f000 030f 	and.w	r3, r0, #15
 80244e2:	1c59      	adds	r1, r3, #1
 80244e4:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
 80244e8:	ea41 3200 	orr.w	r2, r1, r0, lsl #12
 80244ec:	e768      	b.n	80243c0 <__gnu_unwind_execute+0x108>
 80244ee:	4628      	mov	r0, r5
 80244f0:	f7ff feb8 	bl	8024264 <next_unwind_byte>
 80244f4:	f000 030f 	and.w	r3, r0, #15
 80244f8:	1c59      	adds	r1, r3, #1
 80244fa:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
 80244fe:	ea41 3200 	orr.w	r2, r1, r0, lsl #12
 8024502:	2103      	movs	r1, #3
 8024504:	4630      	mov	r0, r6
 8024506:	460b      	mov	r3, r1
 8024508:	f7ff fb56 	bl	8023bb8 <_Unwind_VRS_Pop>
 802450c:	2800      	cmp	r0, #0
 802450e:	f47f af03 	bne.w	8024318 <__gnu_unwind_execute+0x60>
 8024512:	e6da      	b.n	80242ca <__gnu_unwind_execute+0x12>
 8024514:	4628      	mov	r0, r5
 8024516:	f7ff fea5 	bl	8024264 <next_unwind_byte>
 802451a:	4602      	mov	r2, r0
 802451c:	2800      	cmp	r0, #0
 802451e:	f43f aefb 	beq.w	8024318 <__gnu_unwind_execute+0x60>
 8024522:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
 8024526:	f47f aef7 	bne.w	8024318 <__gnu_unwind_execute+0x60>
 802452a:	4630      	mov	r0, r6
 802452c:	2104      	movs	r1, #4
 802452e:	f7ff fb43 	bl	8023bb8 <_Unwind_VRS_Pop>
 8024532:	2800      	cmp	r0, #0
 8024534:	f47f aef0 	bne.w	8024318 <__gnu_unwind_execute+0x60>
 8024538:	e6c7      	b.n	80242ca <__gnu_unwind_execute+0x12>
 802453a:	f000 010f 	and.w	r1, r0, #15
 802453e:	1c48      	adds	r0, r1, #1
 8024540:	f440 2220 	orr.w	r2, r0, #655360	; 0xa0000
 8024544:	e7dd      	b.n	8024502 <__gnu_unwind_execute+0x24a>
 8024546:	ac03      	add	r4, sp, #12
 8024548:	4649      	mov	r1, r9
 802454a:	220e      	movs	r2, #14
 802454c:	464b      	mov	r3, r9
 802454e:	4630      	mov	r0, r6
 8024550:	9400      	str	r4, [sp, #0]
 8024552:	f7ff f95b 	bl	802380c <_Unwind_VRS_Get>
 8024556:	4630      	mov	r0, r6
 8024558:	4649      	mov	r1, r9
 802455a:	220f      	movs	r2, #15
 802455c:	464b      	mov	r3, r9
 802455e:	9400      	str	r4, [sp, #0]
 8024560:	f7ff f974 	bl	802384c <_Unwind_VRS_Set>
 8024564:	4648      	mov	r0, r9
 8024566:	e6d8      	b.n	802431a <__gnu_unwind_execute+0x62>
 8024568:	4628      	mov	r0, r5
 802456a:	f7ff fe7b 	bl	8024264 <next_unwind_byte>
 802456e:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 8024572:	f000 000f 	and.w	r0, r0, #15
 8024576:	3210      	adds	r2, #16
 8024578:	1c43      	adds	r3, r0, #1
 802457a:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
 802457e:	e6c4      	b.n	802430a <__gnu_unwind_execute+0x52>

08024580 <__gnu_unwind_frame>:
 8024580:	b510      	push	{r4, lr}
 8024582:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8024584:	b084      	sub	sp, #16
 8024586:	2003      	movs	r0, #3
 8024588:	6854      	ldr	r4, [r2, #4]
 802458a:	f88d 000c 	strb.w	r0, [sp, #12]
 802458e:	79d3      	ldrb	r3, [r2, #7]
 8024590:	0224      	lsls	r4, r4, #8
 8024592:	3208      	adds	r2, #8
 8024594:	4608      	mov	r0, r1
 8024596:	a901      	add	r1, sp, #4
 8024598:	9401      	str	r4, [sp, #4]
 802459a:	9202      	str	r2, [sp, #8]
 802459c:	f88d 300d 	strb.w	r3, [sp, #13]
 80245a0:	f7ff fe8a 	bl	80242b8 <__gnu_unwind_execute>
 80245a4:	b004      	add	sp, #16
 80245a6:	bd10      	pop	{r4, pc}

080245a8 <_Unwind_GetRegionStart>:
 80245a8:	b508      	push	{r3, lr}
 80245aa:	f7ff fe83 	bl	80242b4 <unwind_UCB_from_context>
 80245ae:	6c80      	ldr	r0, [r0, #72]	; 0x48
 80245b0:	bd08      	pop	{r3, pc}
 80245b2:	bf00      	nop

080245b4 <_Unwind_GetLanguageSpecificData>:
 80245b4:	b508      	push	{r3, lr}
 80245b6:	f7ff fe7d 	bl	80242b4 <unwind_UCB_from_context>
 80245ba:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 80245bc:	79c8      	ldrb	r0, [r1, #7]
 80245be:	eb01 0380 	add.w	r3, r1, r0, lsl #2
 80245c2:	f103 0008 	add.w	r0, r3, #8
 80245c6:	bd08      	pop	{r3, pc}

080245c8 <_Unwind_GetDataRelBase>:
 80245c8:	b508      	push	{r3, lr}
 80245ca:	f004 fdeb 	bl	80291a4 <abort>
 80245ce:	bf00      	nop

080245d0 <_Unwind_GetTextRelBase>:
 80245d0:	b508      	push	{r3, lr}
 80245d2:	f004 fde7 	bl	80291a4 <abort>
 80245d6:	bf00      	nop

080245d8 <__aeabi_idiv0>:
 80245d8:	4770      	bx	lr
 80245da:	bf00      	nop

080245dc <__divdi3>:
 80245dc:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 80245e0:	2900      	cmp	r1, #0
 80245e2:	461d      	mov	r5, r3
 80245e4:	f2c0 809d 	blt.w	8024722 <__divdi3+0x146>
 80245e8:	2400      	movs	r4, #0
 80245ea:	2d00      	cmp	r5, #0
 80245ec:	f2c0 8094 	blt.w	8024718 <__divdi3+0x13c>
 80245f0:	4607      	mov	r7, r0
 80245f2:	460d      	mov	r5, r1
 80245f4:	4616      	mov	r6, r2
 80245f6:	469c      	mov	ip, r3
 80245f8:	2b00      	cmp	r3, #0
 80245fa:	d13d      	bne.n	8024678 <__divdi3+0x9c>
 80245fc:	428a      	cmp	r2, r1
 80245fe:	d953      	bls.n	80246a8 <__divdi3+0xcc>
 8024600:	fab2 f382 	clz	r3, r2
 8024604:	b143      	cbz	r3, 8024618 <__divdi3+0x3c>
 8024606:	f1c3 0620 	rsb	r6, r3, #32
 802460a:	fa20 f506 	lsr.w	r5, r0, r6
 802460e:	fa01 f103 	lsl.w	r1, r1, r3
 8024612:	409a      	lsls	r2, r3
 8024614:	4329      	orrs	r1, r5
 8024616:	4098      	lsls	r0, r3
 8024618:	0c13      	lsrs	r3, r2, #16
 802461a:	fbb1 f6f3 	udiv	r6, r1, r3
 802461e:	b297      	uxth	r7, r2
 8024620:	fb03 1116 	mls	r1, r3, r6, r1
 8024624:	ea4f 4c10 	mov.w	ip, r0, lsr #16
 8024628:	fb07 f506 	mul.w	r5, r7, r6
 802462c:	ea4c 4101 	orr.w	r1, ip, r1, lsl #16
 8024630:	428d      	cmp	r5, r1
 8024632:	d909      	bls.n	8024648 <__divdi3+0x6c>
 8024634:	1889      	adds	r1, r1, r2
 8024636:	f106 3cff 	add.w	ip, r6, #4294967295
 802463a:	f080 8114 	bcs.w	8024866 <__divdi3+0x28a>
 802463e:	428d      	cmp	r5, r1
 8024640:	f240 8111 	bls.w	8024866 <__divdi3+0x28a>
 8024644:	3e02      	subs	r6, #2
 8024646:	1889      	adds	r1, r1, r2
 8024648:	1b49      	subs	r1, r1, r5
 802464a:	fbb1 f5f3 	udiv	r5, r1, r3
 802464e:	fb03 1315 	mls	r3, r3, r5, r1
 8024652:	b280      	uxth	r0, r0
 8024654:	fb07 f705 	mul.w	r7, r7, r5
 8024658:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 802465c:	429f      	cmp	r7, r3
 802465e:	d907      	bls.n	8024670 <__divdi3+0x94>
 8024660:	1e69      	subs	r1, r5, #1
 8024662:	189b      	adds	r3, r3, r2
 8024664:	f080 8105 	bcs.w	8024872 <__divdi3+0x296>
 8024668:	429f      	cmp	r7, r3
 802466a:	f240 8102 	bls.w	8024872 <__divdi3+0x296>
 802466e:	3d02      	subs	r5, #2
 8024670:	ea45 4206 	orr.w	r2, r5, r6, lsl #16
 8024674:	2300      	movs	r3, #0
 8024676:	e003      	b.n	8024680 <__divdi3+0xa4>
 8024678:	428b      	cmp	r3, r1
 802467a:	d90a      	bls.n	8024692 <__divdi3+0xb6>
 802467c:	2300      	movs	r3, #0
 802467e:	461a      	mov	r2, r3
 8024680:	4610      	mov	r0, r2
 8024682:	4619      	mov	r1, r3
 8024684:	b114      	cbz	r4, 802468c <__divdi3+0xb0>
 8024686:	4240      	negs	r0, r0
 8024688:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802468c:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8024690:	4770      	bx	lr
 8024692:	fab3 f383 	clz	r3, r3
 8024696:	2b00      	cmp	r3, #0
 8024698:	f040 8087 	bne.w	80247aa <__divdi3+0x1ce>
 802469c:	458c      	cmp	ip, r1
 802469e:	d301      	bcc.n	80246a4 <__divdi3+0xc8>
 80246a0:	4282      	cmp	r2, r0
 80246a2:	d8ec      	bhi.n	802467e <__divdi3+0xa2>
 80246a4:	2201      	movs	r2, #1
 80246a6:	e7eb      	b.n	8024680 <__divdi3+0xa4>
 80246a8:	b912      	cbnz	r2, 80246b0 <__divdi3+0xd4>
 80246aa:	2701      	movs	r7, #1
 80246ac:	fbb7 f2f2 	udiv	r2, r7, r2
 80246b0:	fab2 f682 	clz	r6, r2
 80246b4:	2e00      	cmp	r6, #0
 80246b6:	d13a      	bne.n	802472e <__divdi3+0x152>
 80246b8:	1a89      	subs	r1, r1, r2
 80246ba:	0c15      	lsrs	r5, r2, #16
 80246bc:	fa1f fc82 	uxth.w	ip, r2
 80246c0:	2301      	movs	r3, #1
 80246c2:	fbb1 f7f5 	udiv	r7, r1, r5
 80246c6:	fb05 1117 	mls	r1, r5, r7, r1
 80246ca:	ea4f 4810 	mov.w	r8, r0, lsr #16
 80246ce:	fb0c f607 	mul.w	r6, ip, r7
 80246d2:	ea48 4101 	orr.w	r1, r8, r1, lsl #16
 80246d6:	428e      	cmp	r6, r1
 80246d8:	d907      	bls.n	80246ea <__divdi3+0x10e>
 80246da:	1889      	adds	r1, r1, r2
 80246dc:	f107 38ff 	add.w	r8, r7, #4294967295
 80246e0:	d202      	bcs.n	80246e8 <__divdi3+0x10c>
 80246e2:	428e      	cmp	r6, r1
 80246e4:	f200 80da 	bhi.w	802489c <__divdi3+0x2c0>
 80246e8:	4647      	mov	r7, r8
 80246ea:	1b89      	subs	r1, r1, r6
 80246ec:	fbb1 f6f5 	udiv	r6, r1, r5
 80246f0:	fb05 1116 	mls	r1, r5, r6, r1
 80246f4:	b280      	uxth	r0, r0
 80246f6:	fb0c fc06 	mul.w	ip, ip, r6
 80246fa:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 80246fe:	4584      	cmp	ip, r0
 8024700:	d907      	bls.n	8024712 <__divdi3+0x136>
 8024702:	1e71      	subs	r1, r6, #1
 8024704:	1882      	adds	r2, r0, r2
 8024706:	f080 80b0 	bcs.w	802486a <__divdi3+0x28e>
 802470a:	4594      	cmp	ip, r2
 802470c:	f240 80ad 	bls.w	802486a <__divdi3+0x28e>
 8024710:	3e02      	subs	r6, #2
 8024712:	ea46 4207 	orr.w	r2, r6, r7, lsl #16
 8024716:	e7b3      	b.n	8024680 <__divdi3+0xa4>
 8024718:	43e4      	mvns	r4, r4
 802471a:	4252      	negs	r2, r2
 802471c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8024720:	e766      	b.n	80245f0 <__divdi3+0x14>
 8024722:	4240      	negs	r0, r0
 8024724:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8024728:	f04f 34ff 	mov.w	r4, #4294967295
 802472c:	e75d      	b.n	80245ea <__divdi3+0xe>
 802472e:	40b2      	lsls	r2, r6
 8024730:	f1c6 0520 	rsb	r5, r6, #32
 8024734:	fa21 f305 	lsr.w	r3, r1, r5
 8024738:	fa20 f705 	lsr.w	r7, r0, r5
 802473c:	fa01 f906 	lsl.w	r9, r1, r6
 8024740:	0c15      	lsrs	r5, r2, #16
 8024742:	fbb3 f8f5 	udiv	r8, r3, r5
 8024746:	ea47 0909 	orr.w	r9, r7, r9
 802474a:	fa1f fc82 	uxth.w	ip, r2
 802474e:	fb05 3718 	mls	r7, r5, r8, r3
 8024752:	ea4f 4119 	mov.w	r1, r9, lsr #16
 8024756:	fb0c f308 	mul.w	r3, ip, r8
 802475a:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 802475e:	40b0      	lsls	r0, r6
 8024760:	42bb      	cmp	r3, r7
 8024762:	d90a      	bls.n	802477a <__divdi3+0x19e>
 8024764:	18bf      	adds	r7, r7, r2
 8024766:	f108 31ff 	add.w	r1, r8, #4294967295
 802476a:	f080 8095 	bcs.w	8024898 <__divdi3+0x2bc>
 802476e:	42bb      	cmp	r3, r7
 8024770:	f240 8092 	bls.w	8024898 <__divdi3+0x2bc>
 8024774:	f1a8 0802 	sub.w	r8, r8, #2
 8024778:	18bf      	adds	r7, r7, r2
 802477a:	1afe      	subs	r6, r7, r3
 802477c:	fbb6 f3f5 	udiv	r3, r6, r5
 8024780:	fb05 6113 	mls	r1, r5, r3, r6
 8024784:	fa1f f989 	uxth.w	r9, r9
 8024788:	fb0c f603 	mul.w	r6, ip, r3
 802478c:	ea49 4101 	orr.w	r1, r9, r1, lsl #16
 8024790:	428e      	cmp	r6, r1
 8024792:	d906      	bls.n	80247a2 <__divdi3+0x1c6>
 8024794:	1e5f      	subs	r7, r3, #1
 8024796:	1889      	adds	r1, r1, r2
 8024798:	d278      	bcs.n	802488c <__divdi3+0x2b0>
 802479a:	428e      	cmp	r6, r1
 802479c:	d976      	bls.n	802488c <__divdi3+0x2b0>
 802479e:	3b02      	subs	r3, #2
 80247a0:	1889      	adds	r1, r1, r2
 80247a2:	1b89      	subs	r1, r1, r6
 80247a4:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80247a8:	e78b      	b.n	80246c2 <__divdi3+0xe6>
 80247aa:	f1c3 0720 	rsb	r7, r3, #32
 80247ae:	fa26 f807 	lsr.w	r8, r6, r7
 80247b2:	fa0c f203 	lsl.w	r2, ip, r3
 80247b6:	ea48 0c02 	orr.w	ip, r8, r2
 80247ba:	fa21 f107 	lsr.w	r1, r1, r7
 80247be:	fa05 fa03 	lsl.w	sl, r5, r3
 80247c2:	ea4f 481c 	mov.w	r8, ip, lsr #16
 80247c6:	fa20 f507 	lsr.w	r5, r0, r7
 80247ca:	fbb1 f9f8 	udiv	r9, r1, r8
 80247ce:	ea45 050a 	orr.w	r5, r5, sl
 80247d2:	fb08 1719 	mls	r7, r8, r9, r1
 80247d6:	0c2a      	lsrs	r2, r5, #16
 80247d8:	fa1f fa8c 	uxth.w	sl, ip
 80247dc:	fb0a f109 	mul.w	r1, sl, r9
 80247e0:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 80247e4:	42b9      	cmp	r1, r7
 80247e6:	fa06 f603 	lsl.w	r6, r6, r3
 80247ea:	d909      	bls.n	8024800 <__divdi3+0x224>
 80247ec:	eb17 070c 	adds.w	r7, r7, ip
 80247f0:	f109 32ff 	add.w	r2, r9, #4294967295
 80247f4:	d24e      	bcs.n	8024894 <__divdi3+0x2b8>
 80247f6:	42b9      	cmp	r1, r7
 80247f8:	d94c      	bls.n	8024894 <__divdi3+0x2b8>
 80247fa:	f1a9 0902 	sub.w	r9, r9, #2
 80247fe:	4467      	add	r7, ip
 8024800:	1a7f      	subs	r7, r7, r1
 8024802:	fbb7 f2f8 	udiv	r2, r7, r8
 8024806:	fb08 7112 	mls	r1, r8, r2, r7
 802480a:	b2ad      	uxth	r5, r5
 802480c:	fb0a fa02 	mul.w	sl, sl, r2
 8024810:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
 8024814:	458a      	cmp	sl, r1
 8024816:	d907      	bls.n	8024828 <__divdi3+0x24c>
 8024818:	1e55      	subs	r5, r2, #1
 802481a:	eb11 010c 	adds.w	r1, r1, ip
 802481e:	d237      	bcs.n	8024890 <__divdi3+0x2b4>
 8024820:	458a      	cmp	sl, r1
 8024822:	d935      	bls.n	8024890 <__divdi3+0x2b4>
 8024824:	3a02      	subs	r2, #2
 8024826:	4461      	add	r1, ip
 8024828:	ea42 4209 	orr.w	r2, r2, r9, lsl #16
 802482c:	fa1f f886 	uxth.w	r8, r6
 8024830:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 8024834:	0c36      	lsrs	r6, r6, #16
 8024836:	fb08 f70c 	mul.w	r7, r8, ip
 802483a:	b295      	uxth	r5, r2
 802483c:	fb08 f805 	mul.w	r8, r8, r5
 8024840:	fb06 7505 	mla	r5, r6, r5, r7
 8024844:	eb05 4518 	add.w	r5, r5, r8, lsr #16
 8024848:	fb06 fc0c 	mul.w	ip, r6, ip
 802484c:	42af      	cmp	r7, r5
 802484e:	bf88      	it	hi
 8024850:	f50c 3c80 	addhi.w	ip, ip, #65536	; 0x10000
 8024854:	ebca 0101 	rsb	r1, sl, r1
 8024858:	eb0c 4615 	add.w	r6, ip, r5, lsr #16
 802485c:	42b1      	cmp	r1, r6
 802485e:	d312      	bcc.n	8024886 <__divdi3+0x2aa>
 8024860:	d009      	beq.n	8024876 <__divdi3+0x29a>
 8024862:	2300      	movs	r3, #0
 8024864:	e70c      	b.n	8024680 <__divdi3+0xa4>
 8024866:	4666      	mov	r6, ip
 8024868:	e6ee      	b.n	8024648 <__divdi3+0x6c>
 802486a:	460e      	mov	r6, r1
 802486c:	ea46 4207 	orr.w	r2, r6, r7, lsl #16
 8024870:	e706      	b.n	8024680 <__divdi3+0xa4>
 8024872:	460d      	mov	r5, r1
 8024874:	e6fc      	b.n	8024670 <__divdi3+0x94>
 8024876:	fa1f f888 	uxth.w	r8, r8
 802487a:	fa00 f303 	lsl.w	r3, r0, r3
 802487e:	eb08 4505 	add.w	r5, r8, r5, lsl #16
 8024882:	42ab      	cmp	r3, r5
 8024884:	d2ed      	bcs.n	8024862 <__divdi3+0x286>
 8024886:	3a01      	subs	r2, #1
 8024888:	2300      	movs	r3, #0
 802488a:	e6f9      	b.n	8024680 <__divdi3+0xa4>
 802488c:	463b      	mov	r3, r7
 802488e:	e788      	b.n	80247a2 <__divdi3+0x1c6>
 8024890:	462a      	mov	r2, r5
 8024892:	e7c9      	b.n	8024828 <__divdi3+0x24c>
 8024894:	4691      	mov	r9, r2
 8024896:	e7b3      	b.n	8024800 <__divdi3+0x224>
 8024898:	4688      	mov	r8, r1
 802489a:	e76e      	b.n	802477a <__divdi3+0x19e>
 802489c:	3f02      	subs	r7, #2
 802489e:	1889      	adds	r1, r1, r2
 80248a0:	e723      	b.n	80246ea <__divdi3+0x10e>
 80248a2:	bf00      	nop

080248a4 <__udivdi3>:
 80248a4:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80248a8:	4614      	mov	r4, r2
 80248aa:	4605      	mov	r5, r0
 80248ac:	460e      	mov	r6, r1
 80248ae:	2b00      	cmp	r3, #0
 80248b0:	d13f      	bne.n	8024932 <__udivdi3+0x8e>
 80248b2:	428a      	cmp	r2, r1
 80248b4:	d94a      	bls.n	802494c <__udivdi3+0xa8>
 80248b6:	fab2 f382 	clz	r3, r2
 80248ba:	b143      	cbz	r3, 80248ce <__udivdi3+0x2a>
 80248bc:	f1c3 0020 	rsb	r0, r3, #32
 80248c0:	fa25 f200 	lsr.w	r2, r5, r0
 80248c4:	fa01 f603 	lsl.w	r6, r1, r3
 80248c8:	409c      	lsls	r4, r3
 80248ca:	4316      	orrs	r6, r2
 80248cc:	409d      	lsls	r5, r3
 80248ce:	0c23      	lsrs	r3, r4, #16
 80248d0:	fbb6 f1f3 	udiv	r1, r6, r3
 80248d4:	0c2f      	lsrs	r7, r5, #16
 80248d6:	b2a0      	uxth	r0, r4
 80248d8:	fb03 6c11 	mls	ip, r3, r1, r6
 80248dc:	fb00 f201 	mul.w	r2, r0, r1
 80248e0:	ea47 460c 	orr.w	r6, r7, ip, lsl #16
 80248e4:	42b2      	cmp	r2, r6
 80248e6:	d908      	bls.n	80248fa <__udivdi3+0x56>
 80248e8:	1e4f      	subs	r7, r1, #1
 80248ea:	1936      	adds	r6, r6, r4
 80248ec:	f080 80ff 	bcs.w	8024aee <__udivdi3+0x24a>
 80248f0:	42b2      	cmp	r2, r6
 80248f2:	f240 80fc 	bls.w	8024aee <__udivdi3+0x24a>
 80248f6:	3902      	subs	r1, #2
 80248f8:	1936      	adds	r6, r6, r4
 80248fa:	1ab6      	subs	r6, r6, r2
 80248fc:	fbb6 f2f3 	udiv	r2, r6, r3
 8024900:	fb03 6312 	mls	r3, r3, r2, r6
 8024904:	b2ad      	uxth	r5, r5
 8024906:	fb00 f002 	mul.w	r0, r0, r2
 802490a:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 802490e:	4298      	cmp	r0, r3
 8024910:	d907      	bls.n	8024922 <__udivdi3+0x7e>
 8024912:	1e56      	subs	r6, r2, #1
 8024914:	191b      	adds	r3, r3, r4
 8024916:	f080 80ec 	bcs.w	8024af2 <__udivdi3+0x24e>
 802491a:	4298      	cmp	r0, r3
 802491c:	f240 80e9 	bls.w	8024af2 <__udivdi3+0x24e>
 8024920:	3a02      	subs	r2, #2
 8024922:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8024926:	2300      	movs	r3, #0
 8024928:	4610      	mov	r0, r2
 802492a:	4619      	mov	r1, r3
 802492c:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8024930:	4770      	bx	lr
 8024932:	428b      	cmp	r3, r1
 8024934:	d843      	bhi.n	80249be <__udivdi3+0x11a>
 8024936:	fab3 f483 	clz	r4, r3
 802493a:	2c00      	cmp	r4, #0
 802493c:	d142      	bne.n	80249c4 <__udivdi3+0x120>
 802493e:	428b      	cmp	r3, r1
 8024940:	4623      	mov	r3, r4
 8024942:	d301      	bcc.n	8024948 <__udivdi3+0xa4>
 8024944:	4282      	cmp	r2, r0
 8024946:	d83b      	bhi.n	80249c0 <__udivdi3+0x11c>
 8024948:	2201      	movs	r2, #1
 802494a:	e7ed      	b.n	8024928 <__udivdi3+0x84>
 802494c:	b912      	cbnz	r2, 8024954 <__udivdi3+0xb0>
 802494e:	2701      	movs	r7, #1
 8024950:	fbb7 f4f2 	udiv	r4, r7, r2
 8024954:	fab4 f284 	clz	r2, r4
 8024958:	2a00      	cmp	r2, #0
 802495a:	f040 808a 	bne.w	8024a72 <__udivdi3+0x1ce>
 802495e:	1b09      	subs	r1, r1, r4
 8024960:	0c26      	lsrs	r6, r4, #16
 8024962:	b2a7      	uxth	r7, r4
 8024964:	2301      	movs	r3, #1
 8024966:	fbb1 f0f6 	udiv	r0, r1, r6
 802496a:	fb06 1110 	mls	r1, r6, r0, r1
 802496e:	ea4f 4c15 	mov.w	ip, r5, lsr #16
 8024972:	fb07 f200 	mul.w	r2, r7, r0
 8024976:	ea4c 4101 	orr.w	r1, ip, r1, lsl #16
 802497a:	428a      	cmp	r2, r1
 802497c:	d907      	bls.n	802498e <__udivdi3+0xea>
 802497e:	1909      	adds	r1, r1, r4
 8024980:	f100 3cff 	add.w	ip, r0, #4294967295
 8024984:	d202      	bcs.n	802498c <__udivdi3+0xe8>
 8024986:	428a      	cmp	r2, r1
 8024988:	f200 80d4 	bhi.w	8024b34 <__udivdi3+0x290>
 802498c:	4660      	mov	r0, ip
 802498e:	ebc2 0c01 	rsb	ip, r2, r1
 8024992:	fbbc f2f6 	udiv	r2, ip, r6
 8024996:	fb06 c112 	mls	r1, r6, r2, ip
 802499a:	b2ad      	uxth	r5, r5
 802499c:	fb07 f702 	mul.w	r7, r7, r2
 80249a0:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 80249a4:	42af      	cmp	r7, r5
 80249a6:	d907      	bls.n	80249b8 <__udivdi3+0x114>
 80249a8:	1e51      	subs	r1, r2, #1
 80249aa:	192c      	adds	r4, r5, r4
 80249ac:	f080 80a3 	bcs.w	8024af6 <__udivdi3+0x252>
 80249b0:	42a7      	cmp	r7, r4
 80249b2:	f240 80a0 	bls.w	8024af6 <__udivdi3+0x252>
 80249b6:	3a02      	subs	r2, #2
 80249b8:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80249bc:	e7b4      	b.n	8024928 <__udivdi3+0x84>
 80249be:	2300      	movs	r3, #0
 80249c0:	461a      	mov	r2, r3
 80249c2:	e7b1      	b.n	8024928 <__udivdi3+0x84>
 80249c4:	f1c4 0b20 	rsb	fp, r4, #32
 80249c8:	fa03 f604 	lsl.w	r6, r3, r4
 80249cc:	fa22 f30b 	lsr.w	r3, r2, fp
 80249d0:	4333      	orrs	r3, r6
 80249d2:	fa21 f90b 	lsr.w	r9, r1, fp
 80249d6:	0c1e      	lsrs	r6, r3, #16
 80249d8:	fa01 fa04 	lsl.w	sl, r1, r4
 80249dc:	fa20 f10b 	lsr.w	r1, r0, fp
 80249e0:	fbb9 fcf6 	udiv	ip, r9, r6
 80249e4:	ea41 0b0a 	orr.w	fp, r1, sl
 80249e8:	fb06 971c 	mls	r7, r6, ip, r9
 80249ec:	fa1f f883 	uxth.w	r8, r3
 80249f0:	ea4f 451b 	mov.w	r5, fp, lsr #16
 80249f4:	fb08 f90c 	mul.w	r9, r8, ip
 80249f8:	ea45 4507 	orr.w	r5, r5, r7, lsl #16
 80249fc:	45a9      	cmp	r9, r5
 80249fe:	fa02 fa04 	lsl.w	sl, r2, r4
 8024a02:	d905      	bls.n	8024a10 <__udivdi3+0x16c>
 8024a04:	18ed      	adds	r5, r5, r3
 8024a06:	f10c 32ff 	add.w	r2, ip, #4294967295
 8024a0a:	f0c0 8088 	bcc.w	8024b1e <__udivdi3+0x27a>
 8024a0e:	4694      	mov	ip, r2
 8024a10:	ebc9 0505 	rsb	r5, r9, r5
 8024a14:	fbb5 f7f6 	udiv	r7, r5, r6
 8024a18:	fb06 5217 	mls	r2, r6, r7, r5
 8024a1c:	fa1f fb8b 	uxth.w	fp, fp
 8024a20:	fb08 f807 	mul.w	r8, r8, r7
 8024a24:	ea4b 4102 	orr.w	r1, fp, r2, lsl #16
 8024a28:	4588      	cmp	r8, r1
 8024a2a:	d903      	bls.n	8024a34 <__udivdi3+0x190>
 8024a2c:	1e7a      	subs	r2, r7, #1
 8024a2e:	18c9      	adds	r1, r1, r3
 8024a30:	d370      	bcc.n	8024b14 <__udivdi3+0x270>
 8024a32:	4617      	mov	r7, r2
 8024a34:	ea47 420c 	orr.w	r2, r7, ip, lsl #16
 8024a38:	0c17      	lsrs	r7, r2, #16
 8024a3a:	fa1f fc8a 	uxth.w	ip, sl
 8024a3e:	fb0c f607 	mul.w	r6, ip, r7
 8024a42:	b295      	uxth	r5, r2
 8024a44:	ea4f 431a 	mov.w	r3, sl, lsr #16
 8024a48:	fb0c fc05 	mul.w	ip, ip, r5
 8024a4c:	fb03 6505 	mla	r5, r3, r5, r6
 8024a50:	eb05 451c 	add.w	r5, r5, ip, lsr #16
 8024a54:	fb03 f307 	mul.w	r3, r3, r7
 8024a58:	42ae      	cmp	r6, r5
 8024a5a:	bf88      	it	hi
 8024a5c:	f503 3380 	addhi.w	r3, r3, #65536	; 0x10000
 8024a60:	ebc8 0101 	rsb	r1, r8, r1
 8024a64:	eb03 4315 	add.w	r3, r3, r5, lsr #16
 8024a68:	4299      	cmp	r1, r3
 8024a6a:	d350      	bcc.n	8024b0e <__udivdi3+0x26a>
 8024a6c:	d047      	beq.n	8024afe <__udivdi3+0x25a>
 8024a6e:	2300      	movs	r3, #0
 8024a70:	e75a      	b.n	8024928 <__udivdi3+0x84>
 8024a72:	4094      	lsls	r4, r2
 8024a74:	f1c2 0820 	rsb	r8, r2, #32
 8024a78:	fa21 f508 	lsr.w	r5, r1, r8
 8024a7c:	0c26      	lsrs	r6, r4, #16
 8024a7e:	fa01 f702 	lsl.w	r7, r1, r2
 8024a82:	fa20 f308 	lsr.w	r3, r0, r8
 8024a86:	ea43 0907 	orr.w	r9, r3, r7
 8024a8a:	fbb5 f8f6 	udiv	r8, r5, r6
 8024a8e:	fb06 5518 	mls	r5, r6, r8, r5
 8024a92:	b2a7      	uxth	r7, r4
 8024a94:	ea4f 4119 	mov.w	r1, r9, lsr #16
 8024a98:	ea41 4c05 	orr.w	ip, r1, r5, lsl #16
 8024a9c:	fb07 f308 	mul.w	r3, r7, r8
 8024aa0:	4563      	cmp	r3, ip
 8024aa2:	fa00 f502 	lsl.w	r5, r0, r2
 8024aa6:	d909      	bls.n	8024abc <__udivdi3+0x218>
 8024aa8:	eb1c 0c04 	adds.w	ip, ip, r4
 8024aac:	f108 32ff 	add.w	r2, r8, #4294967295
 8024ab0:	d23e      	bcs.n	8024b30 <__udivdi3+0x28c>
 8024ab2:	4563      	cmp	r3, ip
 8024ab4:	d93c      	bls.n	8024b30 <__udivdi3+0x28c>
 8024ab6:	f1a8 0802 	sub.w	r8, r8, #2
 8024aba:	44a4      	add	ip, r4
 8024abc:	ebc3 020c 	rsb	r2, r3, ip
 8024ac0:	fbb2 f3f6 	udiv	r3, r2, r6
 8024ac4:	fb06 2013 	mls	r0, r6, r3, r2
 8024ac8:	fa1f f989 	uxth.w	r9, r9
 8024acc:	fb07 f203 	mul.w	r2, r7, r3
 8024ad0:	ea49 4100 	orr.w	r1, r9, r0, lsl #16
 8024ad4:	428a      	cmp	r2, r1
 8024ad6:	d906      	bls.n	8024ae6 <__udivdi3+0x242>
 8024ad8:	1e58      	subs	r0, r3, #1
 8024ada:	1909      	adds	r1, r1, r4
 8024adc:	d226      	bcs.n	8024b2c <__udivdi3+0x288>
 8024ade:	428a      	cmp	r2, r1
 8024ae0:	d924      	bls.n	8024b2c <__udivdi3+0x288>
 8024ae2:	3b02      	subs	r3, #2
 8024ae4:	1909      	adds	r1, r1, r4
 8024ae6:	1a89      	subs	r1, r1, r2
 8024ae8:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8024aec:	e73b      	b.n	8024966 <__udivdi3+0xc2>
 8024aee:	4639      	mov	r1, r7
 8024af0:	e703      	b.n	80248fa <__udivdi3+0x56>
 8024af2:	4632      	mov	r2, r6
 8024af4:	e715      	b.n	8024922 <__udivdi3+0x7e>
 8024af6:	460a      	mov	r2, r1
 8024af8:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8024afc:	e714      	b.n	8024928 <__udivdi3+0x84>
 8024afe:	fa1f f18c 	uxth.w	r1, ip
 8024b02:	fa00 f004 	lsl.w	r0, r0, r4
 8024b06:	eb01 4505 	add.w	r5, r1, r5, lsl #16
 8024b0a:	42a8      	cmp	r0, r5
 8024b0c:	d2af      	bcs.n	8024a6e <__udivdi3+0x1ca>
 8024b0e:	3a01      	subs	r2, #1
 8024b10:	2300      	movs	r3, #0
 8024b12:	e709      	b.n	8024928 <__udivdi3+0x84>
 8024b14:	4588      	cmp	r8, r1
 8024b16:	d98c      	bls.n	8024a32 <__udivdi3+0x18e>
 8024b18:	3f02      	subs	r7, #2
 8024b1a:	18c9      	adds	r1, r1, r3
 8024b1c:	e78a      	b.n	8024a34 <__udivdi3+0x190>
 8024b1e:	45a9      	cmp	r9, r5
 8024b20:	f67f af75 	bls.w	8024a0e <__udivdi3+0x16a>
 8024b24:	f1ac 0c02 	sub.w	ip, ip, #2
 8024b28:	18ed      	adds	r5, r5, r3
 8024b2a:	e771      	b.n	8024a10 <__udivdi3+0x16c>
 8024b2c:	4603      	mov	r3, r0
 8024b2e:	e7da      	b.n	8024ae6 <__udivdi3+0x242>
 8024b30:	4690      	mov	r8, r2
 8024b32:	e7c3      	b.n	8024abc <__udivdi3+0x218>
 8024b34:	3802      	subs	r0, #2
 8024b36:	1909      	adds	r1, r1, r4
 8024b38:	e729      	b.n	802498e <__udivdi3+0xea>
 8024b3a:	bf00      	nop

08024b3c <_ZNK5CTask7IsValidEv>:
	vTaskAllocateMPURegions(m_handleTask, xRegions);
#endif
}

inline
bool CTask::IsValid() const{
 8024b3c:	b480      	push	{r7}
 8024b3e:	b083      	sub	sp, #12
 8024b40:	af00      	add	r7, sp, #0
 8024b42:	6078      	str	r0, [r7, #4]
	return m_handleTask != NULL;
 8024b44:	687b      	ldr	r3, [r7, #4]
 8024b46:	685b      	ldr	r3, [r3, #4]
 8024b48:	2b00      	cmp	r3, #0
 8024b4a:	bf0c      	ite	eq
 8024b4c:	2300      	moveq	r3, #0
 8024b4e:	2301      	movne	r3, #1
 8024b50:	b2db      	uxtb	r3, r3
}
 8024b52:	4618      	mov	r0, r3
 8024b54:	f107 070c 	add.w	r7, r7, #12
 8024b58:	46bd      	mov	sp, r7
 8024b5a:	bc80      	pop	{r7}
 8024b5c:	4770      	bx	lr
 8024b5e:	bf00      	nop

08024b60 <_ZN5CTask6DetachEv>:

inline
xGenericHandle CTask::Detach() {
 8024b60:	b480      	push	{r7}
 8024b62:	b085      	sub	sp, #20
 8024b64:	af00      	add	r7, sp, #0
 8024b66:	6078      	str	r0, [r7, #4]
	xTaskHandle res = m_handleTask;
 8024b68:	687b      	ldr	r3, [r7, #4]
 8024b6a:	685b      	ldr	r3, [r3, #4]
 8024b6c:	60fb      	str	r3, [r7, #12]
	m_handleTask = NULL;
 8024b6e:	687b      	ldr	r3, [r7, #4]
 8024b70:	f04f 0200 	mov.w	r2, #0
 8024b74:	605a      	str	r2, [r3, #4]
	return res;
 8024b76:	68fb      	ldr	r3, [r7, #12]
}
 8024b78:	4618      	mov	r0, r3
 8024b7a:	f107 0714 	add.w	r7, r7, #20
 8024b7e:	46bd      	mov	sp, r7
 8024b80:	bc80      	pop	{r7}
 8024b82:	4770      	bx	lr

08024b84 <_ZN12AManagedTask8OnCreateEPKctm>:
	 * @param uxPriority specifies the task priority.
	 *
	 * @return pdTRUE if success, pdFALSE otherwise. If the method return pdFALSE the task creation process
	 * is stopped and no FreeRTOS resource are allocated.
	 */
	virtual portBASE_TYPE OnCreate(const portCHAR * const pcName, unsigned portSHORT usStackDepth, unsigned portBASE_TYPE uxPriority) { return pdTRUE; }
 8024b84:	b480      	push	{r7}
 8024b86:	b085      	sub	sp, #20
 8024b88:	af00      	add	r7, sp, #0
 8024b8a:	60f8      	str	r0, [r7, #12]
 8024b8c:	60b9      	str	r1, [r7, #8]
 8024b8e:	603b      	str	r3, [r7, #0]
 8024b90:	4613      	mov	r3, r2
 8024b92:	80fb      	strh	r3, [r7, #6]
 8024b94:	f04f 0301 	mov.w	r3, #1
 8024b98:	4618      	mov	r0, r3
 8024b9a:	f107 0714 	add.w	r7, r7, #20
 8024b9e:	46bd      	mov	sp, r7
 8024ba0:	bc80      	pop	{r7}
 8024ba2:	4770      	bx	lr

08024ba4 <_ZN5CTask13EnterCriticalEv>:
    inline static void Yeld() { taskYIELD(); }

    /**
     * \sa <a href="http://www.freertos.org/a00020.html#taskENTER_CRITICAL">taskENTER_CRITICAL</a>  FreeRTOS API function.
     */
    inline static void EnterCritical() { taskENTER_CRITICAL(); }
 8024ba4:	b580      	push	{r7, lr}
 8024ba6:	af00      	add	r7, sp, #0
 8024ba8:	f7f5 f800 	bl	8019bac <vPortEnterCritical>
 8024bac:	bd80      	pop	{r7, pc}
 8024bae:	bf00      	nop

08024bb0 <_ZN5CTask12ExitCriticalEv>:

    /**
     * \sa <a href="http://www.freertos.org/a00020.html#taskEXIT_CRITICAL">taskEXIT_CRITICAL</a>  FreeRTOS API function.
     */
    inline static void ExitCritical() { taskEXIT_CRITICAL(); }
 8024bb0:	b580      	push	{r7, lr}
 8024bb2:	af00      	add	r7, sp, #0
 8024bb4:	f7f5 f810 	bl	8019bd8 <vPortExitCritical>
 8024bb8:	bd80      	pop	{r7, pc}
 8024bba:	bf00      	nop

08024bbc <_ZN12AManagedTask12HardwareInitEv>:
	 * The framework calls this function before the scheduler start. The default implementation simply return true.
	 * Override this method to perform task specific hardware initialization that does not use FreeRTOS API.
	 *
	 * @return true if success, false otherwise.
	 */
	virtual bool HardwareInit() { return true; }
 8024bbc:	b480      	push	{r7}
 8024bbe:	b083      	sub	sp, #12
 8024bc0:	af00      	add	r7, sp, #0
 8024bc2:	6078      	str	r0, [r7, #4]
 8024bc4:	f04f 0301 	mov.w	r3, #1
 8024bc8:	4618      	mov	r0, r3
 8024bca:	f107 070c 	add.w	r7, r7, #12
 8024bce:	46bd      	mov	sp, r7
 8024bd0:	bc80      	pop	{r7}
 8024bd2:	4770      	bx	lr

08024bd4 <_ZN9CFreeRTOS15SuspendAllTasksEv>:
	static void EndScheduler() { vTaskEndScheduler(); }

	/**
	 * \sa <a href="http://www.freertos.org/a00134.html">vTaskSuspendAll</a> FreeRTOS API function.
	 */
	static void SuspendAllTasks() { vTaskSuspendAll(); }
 8024bd4:	b580      	push	{r7, lr}
 8024bd6:	af00      	add	r7, sp, #0
 8024bd8:	f7f6 f93c 	bl	801ae54 <vTaskSuspendAll>
 8024bdc:	bd80      	pop	{r7, pc}
 8024bde:	bf00      	nop

08024be0 <_ZN9CFreeRTOS14ResumeAllTasksEv>:

	/**
	 * \sa <a href="http://www.freertos.org/a00135.html">xTaskResumeAll</a> FreeRTOS API function.
	 */
	static signed portBASE_TYPE ResumeAllTasks() { return xTaskResumeAll(); }
 8024be0:	b580      	push	{r7, lr}
 8024be2:	af00      	add	r7, sp, #0
 8024be4:	f7f6 f948 	bl	801ae78 <xTaskResumeAll>
 8024be8:	4603      	mov	r3, r0
 8024bea:	4618      	mov	r0, r3
 8024bec:	bd80      	pop	{r7, pc}
 8024bee:	bf00      	nop

08024bf0 <_ZN12IFreeRTOSObjC1Ev>:
#ifndef IFREERTOSPROTOCOL_H_
#define IFREERTOSPROTOCOL_H_

typedef void *xGenericHandle;

class IFreeRTOSObj {
 8024bf0:	b480      	push	{r7}
 8024bf2:	b083      	sub	sp, #12
 8024bf4:	af00      	add	r7, sp, #0
 8024bf6:	6078      	str	r0, [r7, #4]
 8024bf8:	687b      	ldr	r3, [r7, #4]
 8024bfa:	4a04      	ldr	r2, [pc, #16]	; (8024c0c <_ZN12IFreeRTOSObjC1Ev+0x1c>)
 8024bfc:	601a      	str	r2, [r3, #0]
 8024bfe:	687b      	ldr	r3, [r7, #4]
 8024c00:	4618      	mov	r0, r3
 8024c02:	f107 070c 	add.w	r7, r7, #12
 8024c06:	46bd      	mov	sp, r7
 8024c08:	bc80      	pop	{r7}
 8024c0a:	4770      	bx	lr
 8024c0c:	08032a90 	.word	0x08032a90

08024c10 <_ZN12CFileHandler15GetUSBConnectedEv>:
/**
  * @brief  gets connected status from USB
  *
  * @retval true for connected and false for not
  */
inline bool CFileHandler::GetUSBConnected(){
 8024c10:	b580      	push	{r7, lr}
 8024c12:	b082      	sub	sp, #8
 8024c14:	af00      	add	r7, sp, #0
 8024c16:	6078      	str	r0, [r7, #4]
	return g_MSC.IsDeviceConnected();
 8024c18:	f643 708c 	movw	r0, #16268	; 0x3f8c
 8024c1c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8024c20:	f7f7 fe58 	bl	801c8d4 <_ZN16CUSB_MassStorage17IsDeviceConnectedEv>
 8024c24:	4603      	mov	r3, r0
}
 8024c26:	4618      	mov	r0, r3
 8024c28:	f107 0708 	add.w	r7, r7, #8
 8024c2c:	46bd      	mov	sp, r7
 8024c2e:	bd80      	pop	{r7, pc}

08024c30 <_ZN9CFreeRTOS14StartSchedulerEv>:
	~CFreeRTOS();

	/**
	 * \sa <a href="http://www.freertos.org/a00132.html">vTaskStartScheduler</a> FreeRTOS API function.
	 */
	static void StartScheduler() { vTaskStartScheduler(); }
 8024c30:	b580      	push	{r7, lr}
 8024c32:	af00      	add	r7, sp, #0
 8024c34:	f7f6 f8c0 	bl	801adb8 <vTaskStartScheduler>
 8024c38:	bd80      	pop	{r7, pc}
 8024c3a:	bf00      	nop

08024c3c <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8024c3c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8024c3e:	e003      	b.n	8024c48 <LoopCopyDataInit>

08024c40 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8024c40:	4b0e      	ldr	r3, [pc, #56]	; (8024c7c <LoopFillZerobss+0x20>)
  ldr  r3, [r3, r1]
 8024c42:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8024c44:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8024c46:	3104      	adds	r1, #4

08024c48 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8024c48:	480d      	ldr	r0, [pc, #52]	; (8024c80 <LoopFillZerobss+0x24>)
  ldr  r3, =_edata
 8024c4a:	4b0e      	ldr	r3, [pc, #56]	; (8024c84 <LoopFillZerobss+0x28>)
  adds  r2, r0, r1
 8024c4c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8024c4e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8024c50:	d3f6      	bcc.n	8024c40 <CopyDataInit>
  ldr  r2, =_sbss
 8024c52:	4a0d      	ldr	r2, [pc, #52]	; (8024c88 <LoopFillZerobss+0x2c>)
  b  LoopFillZerobss
 8024c54:	e002      	b.n	8024c5c <LoopFillZerobss>

08024c56 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8024c56:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8024c58:	f842 3b04 	str.w	r3, [r2], #4

08024c5c <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8024c5c:	4b0b      	ldr	r3, [pc, #44]	; (8024c8c <LoopFillZerobss+0x30>)
  cmp  r2, r3
 8024c5e:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8024c60:	d3f9      	bcc.n	8024c56 <FillZerobss>
  
  
/*FPU settings*/
 ldr     r0, =0xE000ED88           /* Enable CP10,CP11 */
 8024c62:	480b      	ldr	r0, [pc, #44]	; (8024c90 <LoopFillZerobss+0x34>)
 ldr     r1,[r0]
 8024c64:	6801      	ldr	r1, [r0, #0]
 orr     r1,r1,#(0xF << 20)
 8024c66:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 str     r1,[r0]
 8024c6a:	6001      	str	r1, [r0, #0]
	
/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8024c6c:	f7fd fd0e 	bl	802268c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8024c70:	f000 f87e 	bl	8024d70 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8024c74:	f7fd faf4 	bl	8022260 <main>
  bx  lr    
 8024c78:	4770      	bx	lr
 8024c7a:	0000      	.short	0x0000
 8024c7c:	080333a4 	.word	0x080333a4
 8024c80:	20000000 	.word	0x20000000
 8024c84:	200009d0 	.word	0x200009d0
 8024c88:	200009d0 	.word	0x200009d0
 8024c8c:	2000a548 	.word	0x2000a548
 8024c90:	e000ed88 	.word	0xe000ed88

08024c94 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8024c94:	e7fe      	b.n	8024c94 <ADC_IRQHandler>
	...

08024c98 <__aeabi_atexit>:
 8024c98:	4603      	mov	r3, r0
 8024c9a:	4608      	mov	r0, r1
 8024c9c:	4619      	mov	r1, r3
 8024c9e:	f000 b825 	b.w	8024cec <__cxa_atexit>
 8024ca2:	bf00      	nop

08024ca4 <__assert_func>:
 8024ca4:	b500      	push	{lr}
 8024ca6:	4c0a      	ldr	r4, [pc, #40]	; (8024cd0 <__assert_func+0x2c>)
 8024ca8:	6825      	ldr	r5, [r4, #0]
 8024caa:	b085      	sub	sp, #20
 8024cac:	4604      	mov	r4, r0
 8024cae:	68e8      	ldr	r0, [r5, #12]
 8024cb0:	b152      	cbz	r2, 8024cc8 <__assert_func+0x24>
 8024cb2:	4d08      	ldr	r5, [pc, #32]	; (8024cd4 <__assert_func+0x30>)
 8024cb4:	e88d 0022 	stmia.w	sp, {r1, r5}
 8024cb8:	9202      	str	r2, [sp, #8]
 8024cba:	4907      	ldr	r1, [pc, #28]	; (8024cd8 <__assert_func+0x34>)
 8024cbc:	461a      	mov	r2, r3
 8024cbe:	4623      	mov	r3, r4
 8024cc0:	f000 f834 	bl	8024d2c <fiprintf>
 8024cc4:	f004 fa6e 	bl	80291a4 <abort>
 8024cc8:	4d04      	ldr	r5, [pc, #16]	; (8024cdc <__assert_func+0x38>)
 8024cca:	462a      	mov	r2, r5
 8024ccc:	e7f2      	b.n	8024cb4 <__assert_func+0x10>
 8024cce:	bf00      	nop
 8024cd0:	20000510 	.word	0x20000510
 8024cd4:	08032be8 	.word	0x08032be8
 8024cd8:	08032bf8 	.word	0x08032bf8
 8024cdc:	08032bf4 	.word	0x08032bf4

08024ce0 <atexit>:
 8024ce0:	4601      	mov	r1, r0
 8024ce2:	2000      	movs	r0, #0
 8024ce4:	4602      	mov	r2, r0
 8024ce6:	4603      	mov	r3, r0
 8024ce8:	f004 b9fc 	b.w	80290e4 <__register_exitproc>

08024cec <__cxa_atexit>:
 8024cec:	b410      	push	{r4}
 8024cee:	460c      	mov	r4, r1
 8024cf0:	4613      	mov	r3, r2
 8024cf2:	4601      	mov	r1, r0
 8024cf4:	4622      	mov	r2, r4
 8024cf6:	2002      	movs	r0, #2
 8024cf8:	bc10      	pop	{r4}
 8024cfa:	f004 b9f3 	b.w	80290e4 <__register_exitproc>
 8024cfe:	bf00      	nop

08024d00 <__libc_fini_array>:
 8024d00:	b538      	push	{r3, r4, r5, lr}
 8024d02:	4d08      	ldr	r5, [pc, #32]	; (8024d24 <__libc_fini_array+0x24>)
 8024d04:	4c08      	ldr	r4, [pc, #32]	; (8024d28 <__libc_fini_array+0x28>)
 8024d06:	1b64      	subs	r4, r4, r5
 8024d08:	10a4      	asrs	r4, r4, #2
 8024d0a:	d006      	beq.n	8024d1a <__libc_fini_array+0x1a>
 8024d0c:	eb05 0584 	add.w	r5, r5, r4, lsl #2
 8024d10:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8024d14:	4798      	blx	r3
 8024d16:	3c01      	subs	r4, #1
 8024d18:	d1fa      	bne.n	8024d10 <__libc_fini_array+0x10>
 8024d1a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8024d1e:	f00e baab 	b.w	8033278 <_fini>
 8024d22:	bf00      	nop
 8024d24:	080333a0 	.word	0x080333a0
 8024d28:	080333a4 	.word	0x080333a4

08024d2c <fiprintf>:
 8024d2c:	b40e      	push	{r1, r2, r3}
 8024d2e:	b510      	push	{r4, lr}
 8024d30:	f240 5110 	movw	r1, #1296	; 0x510
 8024d34:	b083      	sub	sp, #12
 8024d36:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8024d3a:	ab05      	add	r3, sp, #20
 8024d3c:	680c      	ldr	r4, [r1, #0]
 8024d3e:	f853 2b04 	ldr.w	r2, [r3], #4
 8024d42:	4601      	mov	r1, r0
 8024d44:	4620      	mov	r0, r4
 8024d46:	9301      	str	r3, [sp, #4]
 8024d48:	f003 fb82 	bl	8028450 <_vfiprintf_r>
 8024d4c:	b003      	add	sp, #12
 8024d4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8024d52:	b003      	add	sp, #12
 8024d54:	4770      	bx	lr
 8024d56:	bf00      	nop

08024d58 <gmtime>:
 8024d58:	f240 5310 	movw	r3, #1296	; 0x510
 8024d5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8024d60:	6819      	ldr	r1, [r3, #0]
 8024d62:	317c      	adds	r1, #124	; 0x7c
 8024d64:	f000 b800 	b.w	8024d68 <gmtime_r>

08024d68 <gmtime_r>:
 8024d68:	2201      	movs	r2, #1
 8024d6a:	f000 bee9 	b.w	8025b40 <_mktm_r>
 8024d6e:	bf00      	nop

08024d70 <__libc_init_array>:
 8024d70:	b570      	push	{r4, r5, r6, lr}
 8024d72:	4d0d      	ldr	r5, [pc, #52]	; (8024da8 <__libc_init_array+0x38>)
 8024d74:	4e0d      	ldr	r6, [pc, #52]	; (8024dac <__libc_init_array+0x3c>)
 8024d76:	1b76      	subs	r6, r6, r5
 8024d78:	10b6      	asrs	r6, r6, #2
 8024d7a:	d006      	beq.n	8024d8a <__libc_init_array+0x1a>
 8024d7c:	2400      	movs	r4, #0
 8024d7e:	f855 3b04 	ldr.w	r3, [r5], #4
 8024d82:	3401      	adds	r4, #1
 8024d84:	4798      	blx	r3
 8024d86:	42a6      	cmp	r6, r4
 8024d88:	d1f9      	bne.n	8024d7e <__libc_init_array+0xe>
 8024d8a:	4d09      	ldr	r5, [pc, #36]	; (8024db0 <__libc_init_array+0x40>)
 8024d8c:	4e09      	ldr	r6, [pc, #36]	; (8024db4 <__libc_init_array+0x44>)
 8024d8e:	1b76      	subs	r6, r6, r5
 8024d90:	f00e fa6c 	bl	803326c <_init>
 8024d94:	10b6      	asrs	r6, r6, #2
 8024d96:	d006      	beq.n	8024da6 <__libc_init_array+0x36>
 8024d98:	2400      	movs	r4, #0
 8024d9a:	f855 3b04 	ldr.w	r3, [r5], #4
 8024d9e:	3401      	adds	r4, #1
 8024da0:	4798      	blx	r3
 8024da2:	42a6      	cmp	r6, r4
 8024da4:	d1f9      	bne.n	8024d9a <__libc_init_array+0x2a>
 8024da6:	bd70      	pop	{r4, r5, r6, pc}
 8024da8:	08033394 	.word	0x08033394
 8024dac:	08033394 	.word	0x08033394
 8024db0:	08033394 	.word	0x08033394
 8024db4:	080333a0 	.word	0x080333a0

08024db8 <malloc>:
 8024db8:	f240 5310 	movw	r3, #1296	; 0x510
 8024dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8024dc0:	4601      	mov	r1, r0
 8024dc2:	6818      	ldr	r0, [r3, #0]
 8024dc4:	f000 b808 	b.w	8024dd8 <_malloc_r>

08024dc8 <free>:
 8024dc8:	f240 5310 	movw	r3, #1296	; 0x510
 8024dcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8024dd0:	4601      	mov	r1, r0
 8024dd2:	6818      	ldr	r0, [r3, #0]
 8024dd4:	f005 bba4 	b.w	802a520 <_free_r>

08024dd8 <_malloc_r>:
 8024dd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024ddc:	f101 040b 	add.w	r4, r1, #11
 8024de0:	2c16      	cmp	r4, #22
 8024de2:	b083      	sub	sp, #12
 8024de4:	4605      	mov	r5, r0
 8024de6:	d927      	bls.n	8024e38 <_malloc_r+0x60>
 8024de8:	f034 0407 	bics.w	r4, r4, #7
 8024dec:	d427      	bmi.n	8024e3e <_malloc_r+0x66>
 8024dee:	42a1      	cmp	r1, r4
 8024df0:	d825      	bhi.n	8024e3e <_malloc_r+0x66>
 8024df2:	4628      	mov	r0, r5
 8024df4:	f7fd fc36 	bl	8022664 <__malloc_lock>
 8024df8:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 8024dfc:	d223      	bcs.n	8024e46 <_malloc_r+0x6e>
 8024dfe:	4eb1      	ldr	r6, [pc, #708]	; (80250c4 <_malloc_r+0x2ec>)
 8024e00:	ea4f 0ed4 	mov.w	lr, r4, lsr #3
 8024e04:	eb06 03ce 	add.w	r3, r6, lr, lsl #3
 8024e08:	68df      	ldr	r7, [r3, #12]
 8024e0a:	429f      	cmp	r7, r3
 8024e0c:	f000 81d5 	beq.w	80251ba <_malloc_r+0x3e2>
 8024e10:	687b      	ldr	r3, [r7, #4]
 8024e12:	68fa      	ldr	r2, [r7, #12]
 8024e14:	68b9      	ldr	r1, [r7, #8]
 8024e16:	f023 0303 	bic.w	r3, r3, #3
 8024e1a:	18fb      	adds	r3, r7, r3
 8024e1c:	60ca      	str	r2, [r1, #12]
 8024e1e:	6858      	ldr	r0, [r3, #4]
 8024e20:	6091      	str	r1, [r2, #8]
 8024e22:	f040 0201 	orr.w	r2, r0, #1
 8024e26:	605a      	str	r2, [r3, #4]
 8024e28:	4628      	mov	r0, r5
 8024e2a:	f7fd fc25 	bl	8022678 <__malloc_unlock>
 8024e2e:	3708      	adds	r7, #8
 8024e30:	4638      	mov	r0, r7
 8024e32:	b003      	add	sp, #12
 8024e34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024e38:	2410      	movs	r4, #16
 8024e3a:	42a1      	cmp	r1, r4
 8024e3c:	d9d9      	bls.n	8024df2 <_malloc_r+0x1a>
 8024e3e:	230c      	movs	r3, #12
 8024e40:	602b      	str	r3, [r5, #0]
 8024e42:	2700      	movs	r7, #0
 8024e44:	e7f4      	b.n	8024e30 <_malloc_r+0x58>
 8024e46:	ea5f 2e54 	movs.w	lr, r4, lsr #9
 8024e4a:	f000 8088 	beq.w	8024f5e <_malloc_r+0x186>
 8024e4e:	f1be 0f04 	cmp.w	lr, #4
 8024e52:	f200 8150 	bhi.w	80250f6 <_malloc_r+0x31e>
 8024e56:	ea4f 1e94 	mov.w	lr, r4, lsr #6
 8024e5a:	f10e 0e38 	add.w	lr, lr, #56	; 0x38
 8024e5e:	ea4f 01ce 	mov.w	r1, lr, lsl #3
 8024e62:	4e98      	ldr	r6, [pc, #608]	; (80250c4 <_malloc_r+0x2ec>)
 8024e64:	1871      	adds	r1, r6, r1
 8024e66:	68cf      	ldr	r7, [r1, #12]
 8024e68:	42b9      	cmp	r1, r7
 8024e6a:	d105      	bne.n	8024e78 <_malloc_r+0xa0>
 8024e6c:	e00c      	b.n	8024e88 <_malloc_r+0xb0>
 8024e6e:	2b00      	cmp	r3, #0
 8024e70:	da7a      	bge.n	8024f68 <_malloc_r+0x190>
 8024e72:	68ff      	ldr	r7, [r7, #12]
 8024e74:	42b9      	cmp	r1, r7
 8024e76:	d007      	beq.n	8024e88 <_malloc_r+0xb0>
 8024e78:	687a      	ldr	r2, [r7, #4]
 8024e7a:	f022 0203 	bic.w	r2, r2, #3
 8024e7e:	1b13      	subs	r3, r2, r4
 8024e80:	2b0f      	cmp	r3, #15
 8024e82:	ddf4      	ble.n	8024e6e <_malloc_r+0x96>
 8024e84:	f10e 3eff 	add.w	lr, lr, #4294967295
 8024e88:	f10e 0e01 	add.w	lr, lr, #1
 8024e8c:	4a8d      	ldr	r2, [pc, #564]	; (80250c4 <_malloc_r+0x2ec>)
 8024e8e:	6937      	ldr	r7, [r6, #16]
 8024e90:	f102 0c08 	add.w	ip, r2, #8
 8024e94:	4567      	cmp	r7, ip
 8024e96:	f000 816e 	beq.w	8025176 <_malloc_r+0x39e>
 8024e9a:	687b      	ldr	r3, [r7, #4]
 8024e9c:	f023 0303 	bic.w	r3, r3, #3
 8024ea0:	1b19      	subs	r1, r3, r4
 8024ea2:	290f      	cmp	r1, #15
 8024ea4:	f300 8154 	bgt.w	8025150 <_malloc_r+0x378>
 8024ea8:	2900      	cmp	r1, #0
 8024eaa:	f8c2 c014 	str.w	ip, [r2, #20]
 8024eae:	f8c2 c010 	str.w	ip, [r2, #16]
 8024eb2:	da67      	bge.n	8024f84 <_malloc_r+0x1ac>
 8024eb4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8024eb8:	f080 812b 	bcs.w	8025112 <_malloc_r+0x33a>
 8024ebc:	08db      	lsrs	r3, r3, #3
 8024ebe:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
 8024ec2:	f8d2 8004 	ldr.w	r8, [r2, #4]
 8024ec6:	6888      	ldr	r0, [r1, #8]
 8024ec8:	60f9      	str	r1, [r7, #12]
 8024eca:	109b      	asrs	r3, r3, #2
 8024ecc:	f04f 0901 	mov.w	r9, #1
 8024ed0:	fa09 f303 	lsl.w	r3, r9, r3
 8024ed4:	ea43 0308 	orr.w	r3, r3, r8
 8024ed8:	60b8      	str	r0, [r7, #8]
 8024eda:	6053      	str	r3, [r2, #4]
 8024edc:	608f      	str	r7, [r1, #8]
 8024ede:	60c7      	str	r7, [r0, #12]
 8024ee0:	2001      	movs	r0, #1
 8024ee2:	ea4f 02ae 	mov.w	r2, lr, asr #2
 8024ee6:	fa00 f002 	lsl.w	r0, r0, r2
 8024eea:	4298      	cmp	r0, r3
 8024eec:	d854      	bhi.n	8024f98 <_malloc_r+0x1c0>
 8024eee:	4203      	tst	r3, r0
 8024ef0:	d106      	bne.n	8024f00 <_malloc_r+0x128>
 8024ef2:	f02e 0e03 	bic.w	lr, lr, #3
 8024ef6:	0040      	lsls	r0, r0, #1
 8024ef8:	4203      	tst	r3, r0
 8024efa:	f10e 0e04 	add.w	lr, lr, #4
 8024efe:	d0fa      	beq.n	8024ef6 <_malloc_r+0x11e>
 8024f00:	eb06 09ce 	add.w	r9, r6, lr, lsl #3
 8024f04:	464f      	mov	r7, r9
 8024f06:	46f0      	mov	r8, lr
 8024f08:	68fb      	ldr	r3, [r7, #12]
 8024f0a:	429f      	cmp	r7, r3
 8024f0c:	d107      	bne.n	8024f1e <_malloc_r+0x146>
 8024f0e:	e134      	b.n	802517a <_malloc_r+0x3a2>
 8024f10:	2a00      	cmp	r2, #0
 8024f12:	f280 815b 	bge.w	80251cc <_malloc_r+0x3f4>
 8024f16:	68db      	ldr	r3, [r3, #12]
 8024f18:	429f      	cmp	r7, r3
 8024f1a:	f000 812e 	beq.w	802517a <_malloc_r+0x3a2>
 8024f1e:	6859      	ldr	r1, [r3, #4]
 8024f20:	f021 0103 	bic.w	r1, r1, #3
 8024f24:	1b0a      	subs	r2, r1, r4
 8024f26:	2a0f      	cmp	r2, #15
 8024f28:	ddf2      	ble.n	8024f10 <_malloc_r+0x138>
 8024f2a:	461f      	mov	r7, r3
 8024f2c:	1919      	adds	r1, r3, r4
 8024f2e:	68d8      	ldr	r0, [r3, #12]
 8024f30:	f857 ef08 	ldr.w	lr, [r7, #8]!
 8024f34:	508a      	str	r2, [r1, r2]
 8024f36:	f044 0401 	orr.w	r4, r4, #1
 8024f3a:	f042 0201 	orr.w	r2, r2, #1
 8024f3e:	f8ce 000c 	str.w	r0, [lr, #12]
 8024f42:	f8c0 e008 	str.w	lr, [r0, #8]
 8024f46:	605c      	str	r4, [r3, #4]
 8024f48:	6171      	str	r1, [r6, #20]
 8024f4a:	6131      	str	r1, [r6, #16]
 8024f4c:	f8c1 c00c 	str.w	ip, [r1, #12]
 8024f50:	f8c1 c008 	str.w	ip, [r1, #8]
 8024f54:	604a      	str	r2, [r1, #4]
 8024f56:	4628      	mov	r0, r5
 8024f58:	f7fd fb8e 	bl	8022678 <__malloc_unlock>
 8024f5c:	e768      	b.n	8024e30 <_malloc_r+0x58>
 8024f5e:	ea4f 0ed4 	mov.w	lr, r4, lsr #3
 8024f62:	ea4f 01ce 	mov.w	r1, lr, lsl #3
 8024f66:	e77c      	b.n	8024e62 <_malloc_r+0x8a>
 8024f68:	18ba      	adds	r2, r7, r2
 8024f6a:	68fb      	ldr	r3, [r7, #12]
 8024f6c:	6850      	ldr	r0, [r2, #4]
 8024f6e:	68b9      	ldr	r1, [r7, #8]
 8024f70:	f040 0001 	orr.w	r0, r0, #1
 8024f74:	6050      	str	r0, [r2, #4]
 8024f76:	60cb      	str	r3, [r1, #12]
 8024f78:	6099      	str	r1, [r3, #8]
 8024f7a:	4628      	mov	r0, r5
 8024f7c:	f7fd fb7c 	bl	8022678 <__malloc_unlock>
 8024f80:	3708      	adds	r7, #8
 8024f82:	e755      	b.n	8024e30 <_malloc_r+0x58>
 8024f84:	18fb      	adds	r3, r7, r3
 8024f86:	4628      	mov	r0, r5
 8024f88:	685a      	ldr	r2, [r3, #4]
 8024f8a:	f042 0201 	orr.w	r2, r2, #1
 8024f8e:	605a      	str	r2, [r3, #4]
 8024f90:	f7fd fb72 	bl	8022678 <__malloc_unlock>
 8024f94:	3708      	adds	r7, #8
 8024f96:	e74b      	b.n	8024e30 <_malloc_r+0x58>
 8024f98:	68b7      	ldr	r7, [r6, #8]
 8024f9a:	687b      	ldr	r3, [r7, #4]
 8024f9c:	f023 0903 	bic.w	r9, r3, #3
 8024fa0:	454c      	cmp	r4, r9
 8024fa2:	d804      	bhi.n	8024fae <_malloc_r+0x1d6>
 8024fa4:	ebc4 0209 	rsb	r2, r4, r9
 8024fa8:	2a0f      	cmp	r2, #15
 8024faa:	f300 8097 	bgt.w	80250dc <_malloc_r+0x304>
 8024fae:	f8df b124 	ldr.w	fp, [pc, #292]	; 80250d4 <_malloc_r+0x2fc>
 8024fb2:	4b45      	ldr	r3, [pc, #276]	; (80250c8 <_malloc_r+0x2f0>)
 8024fb4:	f8db 2000 	ldr.w	r2, [fp]
 8024fb8:	681b      	ldr	r3, [r3, #0]
 8024fba:	3201      	adds	r2, #1
 8024fbc:	4423      	add	r3, r4
 8024fbe:	f000 8151 	beq.w	8025264 <_malloc_r+0x48c>
 8024fc2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8024fc6:	330f      	adds	r3, #15
 8024fc8:	f423 637e 	bic.w	r3, r3, #4064	; 0xfe0
 8024fcc:	f023 031f 	bic.w	r3, r3, #31
 8024fd0:	4619      	mov	r1, r3
 8024fd2:	4628      	mov	r0, r5
 8024fd4:	9301      	str	r3, [sp, #4]
 8024fd6:	f000 ff89 	bl	8025eec <_sbrk_r>
 8024fda:	f1b0 3fff 	cmp.w	r0, #4294967295
 8024fde:	4680      	mov	r8, r0
 8024fe0:	9b01      	ldr	r3, [sp, #4]
 8024fe2:	f000 814a 	beq.w	802527a <_malloc_r+0x4a2>
 8024fe6:	eb07 0109 	add.w	r1, r7, r9
 8024fea:	4281      	cmp	r1, r0
 8024fec:	f200 8109 	bhi.w	8025202 <_malloc_r+0x42a>
 8024ff0:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 80250d8 <_malloc_r+0x300>
 8024ff4:	f8da 2000 	ldr.w	r2, [sl]
 8024ff8:	4541      	cmp	r1, r8
 8024ffa:	441a      	add	r2, r3
 8024ffc:	f8ca 2000 	str.w	r2, [sl]
 8025000:	f000 8140 	beq.w	8025284 <_malloc_r+0x4ac>
 8025004:	f8db 0000 	ldr.w	r0, [fp]
 8025008:	3001      	adds	r0, #1
 802500a:	f000 814b 	beq.w	80252a4 <_malloc_r+0x4cc>
 802500e:	ebc1 0108 	rsb	r1, r1, r8
 8025012:	1852      	adds	r2, r2, r1
 8025014:	f8ca 2000 	str.w	r2, [sl]
 8025018:	f018 0207 	ands.w	r2, r8, #7
 802501c:	f000 8104 	beq.w	8025228 <_malloc_r+0x450>
 8025020:	f1c2 0108 	rsb	r1, r2, #8
 8025024:	f5c2 5280 	rsb	r2, r2, #4096	; 0x1000
 8025028:	4488      	add	r8, r1
 802502a:	f102 0b08 	add.w	fp, r2, #8
 802502e:	4443      	add	r3, r8
 8025030:	051b      	lsls	r3, r3, #20
 8025032:	0d1b      	lsrs	r3, r3, #20
 8025034:	ebc3 0b0b 	rsb	fp, r3, fp
 8025038:	4628      	mov	r0, r5
 802503a:	4659      	mov	r1, fp
 802503c:	f000 ff56 	bl	8025eec <_sbrk_r>
 8025040:	1c43      	adds	r3, r0, #1
 8025042:	f000 813b 	beq.w	80252bc <_malloc_r+0x4e4>
 8025046:	ebc8 0300 	rsb	r3, r8, r0
 802504a:	445b      	add	r3, fp
 802504c:	f043 0301 	orr.w	r3, r3, #1
 8025050:	f8da 2000 	ldr.w	r2, [sl]
 8025054:	f8c6 8008 	str.w	r8, [r6, #8]
 8025058:	445a      	add	r2, fp
 802505a:	42b7      	cmp	r7, r6
 802505c:	f8ca 2000 	str.w	r2, [sl]
 8025060:	f8c8 3004 	str.w	r3, [r8, #4]
 8025064:	d015      	beq.n	8025092 <_malloc_r+0x2ba>
 8025066:	f1b9 0f0f 	cmp.w	r9, #15
 802506a:	f240 80ea 	bls.w	8025242 <_malloc_r+0x46a>
 802506e:	6878      	ldr	r0, [r7, #4]
 8025070:	f1a9 030c 	sub.w	r3, r9, #12
 8025074:	f023 0307 	bic.w	r3, r3, #7
 8025078:	18f9      	adds	r1, r7, r3
 802507a:	f000 0e01 	and.w	lr, r0, #1
 802507e:	ea43 0e0e 	orr.w	lr, r3, lr
 8025082:	2005      	movs	r0, #5
 8025084:	2b0f      	cmp	r3, #15
 8025086:	f8c7 e004 	str.w	lr, [r7, #4]
 802508a:	6048      	str	r0, [r1, #4]
 802508c:	6088      	str	r0, [r1, #8]
 802508e:	f200 810d 	bhi.w	80252ac <_malloc_r+0x4d4>
 8025092:	4b0e      	ldr	r3, [pc, #56]	; (80250cc <_malloc_r+0x2f4>)
 8025094:	68b7      	ldr	r7, [r6, #8]
 8025096:	6819      	ldr	r1, [r3, #0]
 8025098:	428a      	cmp	r2, r1
 802509a:	bf88      	it	hi
 802509c:	601a      	strhi	r2, [r3, #0]
 802509e:	4b0c      	ldr	r3, [pc, #48]	; (80250d0 <_malloc_r+0x2f8>)
 80250a0:	6819      	ldr	r1, [r3, #0]
 80250a2:	428a      	cmp	r2, r1
 80250a4:	bf88      	it	hi
 80250a6:	601a      	strhi	r2, [r3, #0]
 80250a8:	687a      	ldr	r2, [r7, #4]
 80250aa:	f022 0203 	bic.w	r2, r2, #3
 80250ae:	4294      	cmp	r4, r2
 80250b0:	d802      	bhi.n	80250b8 <_malloc_r+0x2e0>
 80250b2:	1b12      	subs	r2, r2, r4
 80250b4:	2a0f      	cmp	r2, #15
 80250b6:	dc11      	bgt.n	80250dc <_malloc_r+0x304>
 80250b8:	4628      	mov	r0, r5
 80250ba:	f7fd fadd 	bl	8022678 <__malloc_unlock>
 80250be:	2700      	movs	r7, #0
 80250c0:	e6b6      	b.n	8024e30 <_malloc_r+0x58>
 80250c2:	bf00      	nop
 80250c4:	20000514 	.word	0x20000514
 80250c8:	20003fb0 	.word	0x20003fb0
 80250cc:	20003fac 	.word	0x20003fac
 80250d0:	20003fa8 	.word	0x20003fa8
 80250d4:	20000920 	.word	0x20000920
 80250d8:	20003fb4 	.word	0x20003fb4
 80250dc:	193b      	adds	r3, r7, r4
 80250de:	f042 0201 	orr.w	r2, r2, #1
 80250e2:	f044 0401 	orr.w	r4, r4, #1
 80250e6:	607c      	str	r4, [r7, #4]
 80250e8:	4628      	mov	r0, r5
 80250ea:	605a      	str	r2, [r3, #4]
 80250ec:	60b3      	str	r3, [r6, #8]
 80250ee:	3708      	adds	r7, #8
 80250f0:	f7fd fac2 	bl	8022678 <__malloc_unlock>
 80250f4:	e69c      	b.n	8024e30 <_malloc_r+0x58>
 80250f6:	f1be 0f14 	cmp.w	lr, #20
 80250fa:	d976      	bls.n	80251ea <_malloc_r+0x412>
 80250fc:	f1be 0f54 	cmp.w	lr, #84	; 0x54
 8025100:	f200 8088 	bhi.w	8025214 <_malloc_r+0x43c>
 8025104:	ea4f 3e14 	mov.w	lr, r4, lsr #12
 8025108:	f10e 0e6e 	add.w	lr, lr, #110	; 0x6e
 802510c:	ea4f 01ce 	mov.w	r1, lr, lsl #3
 8025110:	e6a7      	b.n	8024e62 <_malloc_r+0x8a>
 8025112:	0a5a      	lsrs	r2, r3, #9
 8025114:	2a04      	cmp	r2, #4
 8025116:	d96d      	bls.n	80251f4 <_malloc_r+0x41c>
 8025118:	2a14      	cmp	r2, #20
 802511a:	f200 80a5 	bhi.w	8025268 <_malloc_r+0x490>
 802511e:	f102 085b 	add.w	r8, r2, #91	; 0x5b
 8025122:	ea4f 00c8 	mov.w	r0, r8, lsl #3
 8025126:	1830      	adds	r0, r6, r0
 8025128:	4978      	ldr	r1, [pc, #480]	; (802530c <_malloc_r+0x534>)
 802512a:	6882      	ldr	r2, [r0, #8]
 802512c:	4282      	cmp	r2, r0
 802512e:	d103      	bne.n	8025138 <_malloc_r+0x360>
 8025130:	e07d      	b.n	802522e <_malloc_r+0x456>
 8025132:	6892      	ldr	r2, [r2, #8]
 8025134:	4290      	cmp	r0, r2
 8025136:	d004      	beq.n	8025142 <_malloc_r+0x36a>
 8025138:	6851      	ldr	r1, [r2, #4]
 802513a:	f021 0103 	bic.w	r1, r1, #3
 802513e:	428b      	cmp	r3, r1
 8025140:	d3f7      	bcc.n	8025132 <_malloc_r+0x35a>
 8025142:	68d1      	ldr	r1, [r2, #12]
 8025144:	6873      	ldr	r3, [r6, #4]
 8025146:	60f9      	str	r1, [r7, #12]
 8025148:	60ba      	str	r2, [r7, #8]
 802514a:	60d7      	str	r7, [r2, #12]
 802514c:	608f      	str	r7, [r1, #8]
 802514e:	e6c7      	b.n	8024ee0 <_malloc_r+0x108>
 8025150:	193b      	adds	r3, r7, r4
 8025152:	f041 0001 	orr.w	r0, r1, #1
 8025156:	f044 0401 	orr.w	r4, r4, #1
 802515a:	607c      	str	r4, [r7, #4]
 802515c:	6153      	str	r3, [r2, #20]
 802515e:	6113      	str	r3, [r2, #16]
 8025160:	6058      	str	r0, [r3, #4]
 8025162:	f8c3 c00c 	str.w	ip, [r3, #12]
 8025166:	f8c3 c008 	str.w	ip, [r3, #8]
 802516a:	5059      	str	r1, [r3, r1]
 802516c:	4628      	mov	r0, r5
 802516e:	f7fd fa83 	bl	8022678 <__malloc_unlock>
 8025172:	3708      	adds	r7, #8
 8025174:	e65c      	b.n	8024e30 <_malloc_r+0x58>
 8025176:	6853      	ldr	r3, [r2, #4]
 8025178:	e6b2      	b.n	8024ee0 <_malloc_r+0x108>
 802517a:	f108 0801 	add.w	r8, r8, #1
 802517e:	3708      	adds	r7, #8
 8025180:	f018 0f03 	tst.w	r8, #3
 8025184:	f47f aec0 	bne.w	8024f08 <_malloc_r+0x130>
 8025188:	464b      	mov	r3, r9
 802518a:	f01e 0f03 	tst.w	lr, #3
 802518e:	f1a3 0208 	sub.w	r2, r3, #8
 8025192:	f10e 3eff 	add.w	lr, lr, #4294967295
 8025196:	f000 80aa 	beq.w	80252ee <_malloc_r+0x516>
 802519a:	681b      	ldr	r3, [r3, #0]
 802519c:	4293      	cmp	r3, r2
 802519e:	d0f4      	beq.n	802518a <_malloc_r+0x3b2>
 80251a0:	6873      	ldr	r3, [r6, #4]
 80251a2:	0040      	lsls	r0, r0, #1
 80251a4:	4298      	cmp	r0, r3
 80251a6:	f63f aef7 	bhi.w	8024f98 <_malloc_r+0x1c0>
 80251aa:	2800      	cmp	r0, #0
 80251ac:	f43f aef4 	beq.w	8024f98 <_malloc_r+0x1c0>
 80251b0:	4218      	tst	r0, r3
 80251b2:	f000 80a1 	beq.w	80252f8 <_malloc_r+0x520>
 80251b6:	46c6      	mov	lr, r8
 80251b8:	e6a2      	b.n	8024f00 <_malloc_r+0x128>
 80251ba:	f107 0308 	add.w	r3, r7, #8
 80251be:	697f      	ldr	r7, [r7, #20]
 80251c0:	42bb      	cmp	r3, r7
 80251c2:	f47f ae25 	bne.w	8024e10 <_malloc_r+0x38>
 80251c6:	f10e 0e02 	add.w	lr, lr, #2
 80251ca:	e65f      	b.n	8024e8c <_malloc_r+0xb4>
 80251cc:	1859      	adds	r1, r3, r1
 80251ce:	461f      	mov	r7, r3
 80251d0:	6848      	ldr	r0, [r1, #4]
 80251d2:	68db      	ldr	r3, [r3, #12]
 80251d4:	f857 2f08 	ldr.w	r2, [r7, #8]!
 80251d8:	f040 0001 	orr.w	r0, r0, #1
 80251dc:	6048      	str	r0, [r1, #4]
 80251de:	60d3      	str	r3, [r2, #12]
 80251e0:	609a      	str	r2, [r3, #8]
 80251e2:	4628      	mov	r0, r5
 80251e4:	f7fd fa48 	bl	8022678 <__malloc_unlock>
 80251e8:	e622      	b.n	8024e30 <_malloc_r+0x58>
 80251ea:	f10e 0e5b 	add.w	lr, lr, #91	; 0x5b
 80251ee:	ea4f 01ce 	mov.w	r1, lr, lsl #3
 80251f2:	e636      	b.n	8024e62 <_malloc_r+0x8a>
 80251f4:	ea4f 1893 	mov.w	r8, r3, lsr #6
 80251f8:	f108 0838 	add.w	r8, r8, #56	; 0x38
 80251fc:	ea4f 00c8 	mov.w	r0, r8, lsl #3
 8025200:	e791      	b.n	8025126 <_malloc_r+0x34e>
 8025202:	42b7      	cmp	r7, r6
 8025204:	f43f aef4 	beq.w	8024ff0 <_malloc_r+0x218>
 8025208:	4b40      	ldr	r3, [pc, #256]	; (802530c <_malloc_r+0x534>)
 802520a:	689f      	ldr	r7, [r3, #8]
 802520c:	687a      	ldr	r2, [r7, #4]
 802520e:	f022 0203 	bic.w	r2, r2, #3
 8025212:	e74c      	b.n	80250ae <_malloc_r+0x2d6>
 8025214:	f5be 7faa 	cmp.w	lr, #340	; 0x154
 8025218:	d819      	bhi.n	802524e <_malloc_r+0x476>
 802521a:	ea4f 3ed4 	mov.w	lr, r4, lsr #15
 802521e:	f10e 0e77 	add.w	lr, lr, #119	; 0x77
 8025222:	ea4f 01ce 	mov.w	r1, lr, lsl #3
 8025226:	e61c      	b.n	8024e62 <_malloc_r+0x8a>
 8025228:	f44f 5b80 	mov.w	fp, #4096	; 0x1000
 802522c:	e6ff      	b.n	802502e <_malloc_r+0x256>
 802522e:	684b      	ldr	r3, [r1, #4]
 8025230:	ea4f 08a8 	mov.w	r8, r8, asr #2
 8025234:	2001      	movs	r0, #1
 8025236:	fa00 f008 	lsl.w	r0, r0, r8
 802523a:	4303      	orrs	r3, r0
 802523c:	604b      	str	r3, [r1, #4]
 802523e:	4611      	mov	r1, r2
 8025240:	e781      	b.n	8025146 <_malloc_r+0x36e>
 8025242:	2301      	movs	r3, #1
 8025244:	f8c8 3004 	str.w	r3, [r8, #4]
 8025248:	4647      	mov	r7, r8
 802524a:	2200      	movs	r2, #0
 802524c:	e72f      	b.n	80250ae <_malloc_r+0x2d6>
 802524e:	f240 5354 	movw	r3, #1364	; 0x554
 8025252:	459e      	cmp	lr, r3
 8025254:	d821      	bhi.n	802529a <_malloc_r+0x4c2>
 8025256:	ea4f 4e94 	mov.w	lr, r4, lsr #18
 802525a:	f10e 0e7c 	add.w	lr, lr, #124	; 0x7c
 802525e:	ea4f 01ce 	mov.w	r1, lr, lsl #3
 8025262:	e5fe      	b.n	8024e62 <_malloc_r+0x8a>
 8025264:	3310      	adds	r3, #16
 8025266:	e6b3      	b.n	8024fd0 <_malloc_r+0x1f8>
 8025268:	2a54      	cmp	r2, #84	; 0x54
 802526a:	d82b      	bhi.n	80252c4 <_malloc_r+0x4ec>
 802526c:	ea4f 3813 	mov.w	r8, r3, lsr #12
 8025270:	f108 086e 	add.w	r8, r8, #110	; 0x6e
 8025274:	ea4f 00c8 	mov.w	r0, r8, lsl #3
 8025278:	e755      	b.n	8025126 <_malloc_r+0x34e>
 802527a:	68b7      	ldr	r7, [r6, #8]
 802527c:	687a      	ldr	r2, [r7, #4]
 802527e:	f022 0203 	bic.w	r2, r2, #3
 8025282:	e714      	b.n	80250ae <_malloc_r+0x2d6>
 8025284:	0508      	lsls	r0, r1, #20
 8025286:	0d00      	lsrs	r0, r0, #20
 8025288:	2800      	cmp	r0, #0
 802528a:	f47f aebb 	bne.w	8025004 <_malloc_r+0x22c>
 802528e:	68b1      	ldr	r1, [r6, #8]
 8025290:	444b      	add	r3, r9
 8025292:	f043 0301 	orr.w	r3, r3, #1
 8025296:	604b      	str	r3, [r1, #4]
 8025298:	e6fb      	b.n	8025092 <_malloc_r+0x2ba>
 802529a:	f44f 717c 	mov.w	r1, #1008	; 0x3f0
 802529e:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
 80252a2:	e5de      	b.n	8024e62 <_malloc_r+0x8a>
 80252a4:	4a1a      	ldr	r2, [pc, #104]	; (8025310 <_malloc_r+0x538>)
 80252a6:	f8c2 8000 	str.w	r8, [r2]
 80252aa:	e6b5      	b.n	8025018 <_malloc_r+0x240>
 80252ac:	f107 0108 	add.w	r1, r7, #8
 80252b0:	4628      	mov	r0, r5
 80252b2:	f005 f935 	bl	802a520 <_free_r>
 80252b6:	4b17      	ldr	r3, [pc, #92]	; (8025314 <_malloc_r+0x53c>)
 80252b8:	681a      	ldr	r2, [r3, #0]
 80252ba:	e6ea      	b.n	8025092 <_malloc_r+0x2ba>
 80252bc:	2301      	movs	r3, #1
 80252be:	f04f 0b00 	mov.w	fp, #0
 80252c2:	e6c5      	b.n	8025050 <_malloc_r+0x278>
 80252c4:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 80252c8:	d806      	bhi.n	80252d8 <_malloc_r+0x500>
 80252ca:	ea4f 38d3 	mov.w	r8, r3, lsr #15
 80252ce:	f108 0877 	add.w	r8, r8, #119	; 0x77
 80252d2:	ea4f 00c8 	mov.w	r0, r8, lsl #3
 80252d6:	e726      	b.n	8025126 <_malloc_r+0x34e>
 80252d8:	f240 5154 	movw	r1, #1364	; 0x554
 80252dc:	428a      	cmp	r2, r1
 80252de:	d80f      	bhi.n	8025300 <_malloc_r+0x528>
 80252e0:	ea4f 4893 	mov.w	r8, r3, lsr #18
 80252e4:	f108 087c 	add.w	r8, r8, #124	; 0x7c
 80252e8:	ea4f 00c8 	mov.w	r0, r8, lsl #3
 80252ec:	e71b      	b.n	8025126 <_malloc_r+0x34e>
 80252ee:	6873      	ldr	r3, [r6, #4]
 80252f0:	ea23 0300 	bic.w	r3, r3, r0
 80252f4:	6073      	str	r3, [r6, #4]
 80252f6:	e754      	b.n	80251a2 <_malloc_r+0x3ca>
 80252f8:	0040      	lsls	r0, r0, #1
 80252fa:	f108 0804 	add.w	r8, r8, #4
 80252fe:	e757      	b.n	80251b0 <_malloc_r+0x3d8>
 8025300:	f44f 707c 	mov.w	r0, #1008	; 0x3f0
 8025304:	f04f 087e 	mov.w	r8, #126	; 0x7e
 8025308:	e70d      	b.n	8025126 <_malloc_r+0x34e>
 802530a:	bf00      	nop
 802530c:	20000514 	.word	0x20000514
 8025310:	20000920 	.word	0x20000920
 8025314:	20003fb4 	.word	0x20003fb4

08025318 <memcpy>:
 8025318:	2a0f      	cmp	r2, #15
 802531a:	b4f0      	push	{r4, r5, r6, r7}
 802531c:	d93a      	bls.n	8025394 <memcpy+0x7c>
 802531e:	ea41 0300 	orr.w	r3, r1, r0
 8025322:	079b      	lsls	r3, r3, #30
 8025324:	d138      	bne.n	8025398 <memcpy+0x80>
 8025326:	460c      	mov	r4, r1
 8025328:	4603      	mov	r3, r0
 802532a:	4615      	mov	r5, r2
 802532c:	6826      	ldr	r6, [r4, #0]
 802532e:	601e      	str	r6, [r3, #0]
 8025330:	6866      	ldr	r6, [r4, #4]
 8025332:	605e      	str	r6, [r3, #4]
 8025334:	68a6      	ldr	r6, [r4, #8]
 8025336:	609e      	str	r6, [r3, #8]
 8025338:	68e6      	ldr	r6, [r4, #12]
 802533a:	3d10      	subs	r5, #16
 802533c:	60de      	str	r6, [r3, #12]
 802533e:	3410      	adds	r4, #16
 8025340:	3310      	adds	r3, #16
 8025342:	2d0f      	cmp	r5, #15
 8025344:	d8f2      	bhi.n	802532c <memcpy+0x14>
 8025346:	f1a2 0410 	sub.w	r4, r2, #16
 802534a:	f024 040f 	bic.w	r4, r4, #15
 802534e:	f002 020f 	and.w	r2, r2, #15
 8025352:	3410      	adds	r4, #16
 8025354:	2a03      	cmp	r2, #3
 8025356:	eb00 0304 	add.w	r3, r0, r4
 802535a:	4421      	add	r1, r4
 802535c:	d911      	bls.n	8025382 <memcpy+0x6a>
 802535e:	460e      	mov	r6, r1
 8025360:	461d      	mov	r5, r3
 8025362:	4614      	mov	r4, r2
 8025364:	f856 7b04 	ldr.w	r7, [r6], #4
 8025368:	3c04      	subs	r4, #4
 802536a:	2c03      	cmp	r4, #3
 802536c:	f845 7b04 	str.w	r7, [r5], #4
 8025370:	d8f8      	bhi.n	8025364 <memcpy+0x4c>
 8025372:	1f14      	subs	r4, r2, #4
 8025374:	f024 0403 	bic.w	r4, r4, #3
 8025378:	3404      	adds	r4, #4
 802537a:	f002 0203 	and.w	r2, r2, #3
 802537e:	1909      	adds	r1, r1, r4
 8025380:	191b      	adds	r3, r3, r4
 8025382:	b12a      	cbz	r2, 8025390 <memcpy+0x78>
 8025384:	f811 4b01 	ldrb.w	r4, [r1], #1
 8025388:	3a01      	subs	r2, #1
 802538a:	f803 4b01 	strb.w	r4, [r3], #1
 802538e:	d1f9      	bne.n	8025384 <memcpy+0x6c>
 8025390:	bcf0      	pop	{r4, r5, r6, r7}
 8025392:	4770      	bx	lr
 8025394:	4603      	mov	r3, r0
 8025396:	e7f4      	b.n	8025382 <memcpy+0x6a>
 8025398:	4603      	mov	r3, r0
 802539a:	e7f3      	b.n	8025384 <memcpy+0x6c>

0802539c <memmove>:
 802539c:	4288      	cmp	r0, r1
 802539e:	b4f0      	push	{r4, r5, r6, r7}
 80253a0:	d912      	bls.n	80253c8 <memmove+0x2c>
 80253a2:	188d      	adds	r5, r1, r2
 80253a4:	42a8      	cmp	r0, r5
 80253a6:	d20f      	bcs.n	80253c8 <memmove+0x2c>
 80253a8:	b162      	cbz	r2, 80253c4 <memmove+0x28>
 80253aa:	4251      	negs	r1, r2
 80253ac:	4613      	mov	r3, r2
 80253ae:	1882      	adds	r2, r0, r2
 80253b0:	186d      	adds	r5, r5, r1
 80253b2:	1852      	adds	r2, r2, r1
 80253b4:	18ec      	adds	r4, r5, r3
 80253b6:	18d1      	adds	r1, r2, r3
 80253b8:	f814 4c01 	ldrb.w	r4, [r4, #-1]
 80253bc:	3b01      	subs	r3, #1
 80253be:	f801 4c01 	strb.w	r4, [r1, #-1]
 80253c2:	d1f7      	bne.n	80253b4 <memmove+0x18>
 80253c4:	bcf0      	pop	{r4, r5, r6, r7}
 80253c6:	4770      	bx	lr
 80253c8:	2a0f      	cmp	r2, #15
 80253ca:	d93a      	bls.n	8025442 <memmove+0xa6>
 80253cc:	ea41 0300 	orr.w	r3, r1, r0
 80253d0:	079b      	lsls	r3, r3, #30
 80253d2:	d138      	bne.n	8025446 <memmove+0xaa>
 80253d4:	460c      	mov	r4, r1
 80253d6:	4603      	mov	r3, r0
 80253d8:	4615      	mov	r5, r2
 80253da:	6826      	ldr	r6, [r4, #0]
 80253dc:	601e      	str	r6, [r3, #0]
 80253de:	6866      	ldr	r6, [r4, #4]
 80253e0:	605e      	str	r6, [r3, #4]
 80253e2:	68a6      	ldr	r6, [r4, #8]
 80253e4:	609e      	str	r6, [r3, #8]
 80253e6:	68e6      	ldr	r6, [r4, #12]
 80253e8:	3d10      	subs	r5, #16
 80253ea:	60de      	str	r6, [r3, #12]
 80253ec:	3410      	adds	r4, #16
 80253ee:	3310      	adds	r3, #16
 80253f0:	2d0f      	cmp	r5, #15
 80253f2:	d8f2      	bhi.n	80253da <memmove+0x3e>
 80253f4:	f1a2 0410 	sub.w	r4, r2, #16
 80253f8:	f024 040f 	bic.w	r4, r4, #15
 80253fc:	f002 020f 	and.w	r2, r2, #15
 8025400:	3410      	adds	r4, #16
 8025402:	2a03      	cmp	r2, #3
 8025404:	eb00 0304 	add.w	r3, r0, r4
 8025408:	4421      	add	r1, r4
 802540a:	d911      	bls.n	8025430 <memmove+0x94>
 802540c:	460e      	mov	r6, r1
 802540e:	461d      	mov	r5, r3
 8025410:	4614      	mov	r4, r2
 8025412:	f856 7b04 	ldr.w	r7, [r6], #4
 8025416:	3c04      	subs	r4, #4
 8025418:	2c03      	cmp	r4, #3
 802541a:	f845 7b04 	str.w	r7, [r5], #4
 802541e:	d8f8      	bhi.n	8025412 <memmove+0x76>
 8025420:	1f14      	subs	r4, r2, #4
 8025422:	f024 0403 	bic.w	r4, r4, #3
 8025426:	3404      	adds	r4, #4
 8025428:	f002 0203 	and.w	r2, r2, #3
 802542c:	1909      	adds	r1, r1, r4
 802542e:	191b      	adds	r3, r3, r4
 8025430:	2a00      	cmp	r2, #0
 8025432:	d0c7      	beq.n	80253c4 <memmove+0x28>
 8025434:	f811 4b01 	ldrb.w	r4, [r1], #1
 8025438:	3a01      	subs	r2, #1
 802543a:	f803 4b01 	strb.w	r4, [r3], #1
 802543e:	d1f9      	bne.n	8025434 <memmove+0x98>
 8025440:	e7c0      	b.n	80253c4 <memmove+0x28>
 8025442:	4603      	mov	r3, r0
 8025444:	e7f4      	b.n	8025430 <memmove+0x94>
 8025446:	4603      	mov	r3, r0
 8025448:	e7f4      	b.n	8025434 <memmove+0x98>
 802544a:	bf00      	nop

0802544c <memset>:
 802544c:	f010 0f03 	tst.w	r0, #3
 8025450:	b470      	push	{r4, r5, r6}
 8025452:	4603      	mov	r3, r0
 8025454:	d03f      	beq.n	80254d6 <memset+0x8a>
 8025456:	2a00      	cmp	r2, #0
 8025458:	d03b      	beq.n	80254d2 <memset+0x86>
 802545a:	b2cd      	uxtb	r5, r1
 802545c:	e001      	b.n	8025462 <memset+0x16>
 802545e:	2a00      	cmp	r2, #0
 8025460:	d037      	beq.n	80254d2 <memset+0x86>
 8025462:	f803 5b01 	strb.w	r5, [r3], #1
 8025466:	3a01      	subs	r2, #1
 8025468:	f013 0f03 	tst.w	r3, #3
 802546c:	461c      	mov	r4, r3
 802546e:	d1f6      	bne.n	802545e <memset+0x12>
 8025470:	2a03      	cmp	r2, #3
 8025472:	d928      	bls.n	80254c6 <memset+0x7a>
 8025474:	b2cd      	uxtb	r5, r1
 8025476:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 802547a:	2a0f      	cmp	r2, #15
 802547c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8025480:	d913      	bls.n	80254aa <memset+0x5e>
 8025482:	4623      	mov	r3, r4
 8025484:	4616      	mov	r6, r2
 8025486:	3e10      	subs	r6, #16
 8025488:	601d      	str	r5, [r3, #0]
 802548a:	605d      	str	r5, [r3, #4]
 802548c:	609d      	str	r5, [r3, #8]
 802548e:	60dd      	str	r5, [r3, #12]
 8025490:	3310      	adds	r3, #16
 8025492:	2e0f      	cmp	r6, #15
 8025494:	d8f7      	bhi.n	8025486 <memset+0x3a>
 8025496:	f1a2 0310 	sub.w	r3, r2, #16
 802549a:	f023 030f 	bic.w	r3, r3, #15
 802549e:	f002 020f 	and.w	r2, r2, #15
 80254a2:	3310      	adds	r3, #16
 80254a4:	2a03      	cmp	r2, #3
 80254a6:	441c      	add	r4, r3
 80254a8:	d90d      	bls.n	80254c6 <memset+0x7a>
 80254aa:	4626      	mov	r6, r4
 80254ac:	4613      	mov	r3, r2
 80254ae:	3b04      	subs	r3, #4
 80254b0:	2b03      	cmp	r3, #3
 80254b2:	f846 5b04 	str.w	r5, [r6], #4
 80254b6:	d8fa      	bhi.n	80254ae <memset+0x62>
 80254b8:	1f13      	subs	r3, r2, #4
 80254ba:	f023 0303 	bic.w	r3, r3, #3
 80254be:	3304      	adds	r3, #4
 80254c0:	f002 0203 	and.w	r2, r2, #3
 80254c4:	18e4      	adds	r4, r4, r3
 80254c6:	b122      	cbz	r2, 80254d2 <memset+0x86>
 80254c8:	b2c9      	uxtb	r1, r1
 80254ca:	3a01      	subs	r2, #1
 80254cc:	f804 1b01 	strb.w	r1, [r4], #1
 80254d0:	d1fb      	bne.n	80254ca <memset+0x7e>
 80254d2:	bc70      	pop	{r4, r5, r6}
 80254d4:	4770      	bx	lr
 80254d6:	4604      	mov	r4, r0
 80254d8:	e7ca      	b.n	8025470 <memset+0x24>
 80254da:	bf00      	nop

080254dc <validate_structure>:
 80254dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80254e0:	6801      	ldr	r1, [r0, #0]
 80254e2:	293b      	cmp	r1, #59	; 0x3b
 80254e4:	b082      	sub	sp, #8
 80254e6:	4604      	mov	r4, r0
 80254e8:	f200 80cf 	bhi.w	802568a <validate_structure+0x1ae>
 80254ec:	6841      	ldr	r1, [r0, #4]
 80254ee:	293b      	cmp	r1, #59	; 0x3b
 80254f0:	f200 80b9 	bhi.w	8025666 <validate_structure+0x18a>
 80254f4:	68a1      	ldr	r1, [r4, #8]
 80254f6:	2917      	cmp	r1, #23
 80254f8:	f200 80a3 	bhi.w	8025642 <validate_structure+0x166>
 80254fc:	6921      	ldr	r1, [r4, #16]
 80254fe:	290b      	cmp	r1, #11
 8025500:	f300 808d 	bgt.w	802561e <validate_structure+0x142>
 8025504:	6963      	ldr	r3, [r4, #20]
 8025506:	079f      	lsls	r7, r3, #30
 8025508:	d12b      	bne.n	8025562 <validate_structure+0x86>
 802550a:	f248 521f 	movw	r2, #34079	; 0x851f
 802550e:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
 8025512:	fb82 0503 	smull	r0, r5, r2, r3
 8025516:	17d8      	asrs	r0, r3, #31
 8025518:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 802551c:	2564      	movs	r5, #100	; 0x64
 802551e:	fb05 3010 	mls	r0, r5, r0, r3
 8025522:	2800      	cmp	r0, #0
 8025524:	d06a      	beq.n	80255fc <validate_structure+0x120>
 8025526:	68e3      	ldr	r3, [r4, #12]
 8025528:	261d      	movs	r6, #29
 802552a:	2b00      	cmp	r3, #0
 802552c:	dc1d      	bgt.n	802556a <validate_structure+0x8e>
 802552e:	f248 551f 	movw	r5, #34079	; 0x851f
 8025532:	4871      	ldr	r0, [pc, #452]	; (80256f8 <validate_structure+0x21c>)
 8025534:	f2c5 15eb 	movt	r5, #20971	; 0x51eb
 8025538:	2764      	movs	r7, #100	; 0x64
 802553a:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 802553e:	1e4a      	subs	r2, r1, #1
 8025540:	2900      	cmp	r1, #0
 8025542:	f000 80b6 	beq.w	80256b2 <validate_structure+0x1d6>
 8025546:	2a01      	cmp	r2, #1
 8025548:	4611      	mov	r1, r2
 802554a:	f000 80b0 	beq.w	80256ae <validate_structure+0x1d2>
 802554e:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8025552:	189b      	adds	r3, r3, r2
 8025554:	2b00      	cmp	r3, #0
 8025556:	ddf2      	ble.n	802553e <validate_structure+0x62>
 8025558:	6121      	str	r1, [r4, #16]
 802555a:	60e3      	str	r3, [r4, #12]
 802555c:	b002      	add	sp, #8
 802555e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8025562:	261c      	movs	r6, #28
 8025564:	68e3      	ldr	r3, [r4, #12]
 8025566:	2b00      	cmp	r3, #0
 8025568:	dde1      	ble.n	802552e <validate_structure+0x52>
 802556a:	f248 5c1f 	movw	ip, #34079	; 0x851f
 802556e:	4f62      	ldr	r7, [pc, #392]	; (80256f8 <validate_structure+0x21c>)
 8025570:	f04f 0800 	mov.w	r8, #0
 8025574:	f2c5 1ceb 	movt	ip, #20971	; 0x51eb
 8025578:	f04f 0964 	mov.w	r9, #100	; 0x64
 802557c:	f44f 7ac8 	mov.w	sl, #400	; 0x190
 8025580:	1c4a      	adds	r2, r1, #1
 8025582:	eb07 0081 	add.w	r0, r7, r1, lsl #2
 8025586:	e008      	b.n	802559a <validate_structure+0xbe>
 8025588:	6805      	ldr	r5, [r0, #0]
 802558a:	6122      	str	r2, [r4, #16]
 802558c:	1b5b      	subs	r3, r3, r5
 802558e:	2a0c      	cmp	r2, #12
 8025590:	60e3      	str	r3, [r4, #12]
 8025592:	d00e      	beq.n	80255b2 <validate_structure+0xd6>
 8025594:	3101      	adds	r1, #1
 8025596:	3201      	adds	r2, #1
 8025598:	3004      	adds	r0, #4
 802559a:	2901      	cmp	r1, #1
 802559c:	bf14      	ite	ne
 802559e:	6805      	ldrne	r5, [r0, #0]
 80255a0:	4635      	moveq	r5, r6
 80255a2:	429d      	cmp	r5, r3
 80255a4:	dada      	bge.n	802555c <validate_structure+0x80>
 80255a6:	2901      	cmp	r1, #1
 80255a8:	d1ee      	bne.n	8025588 <validate_structure+0xac>
 80255aa:	1b9b      	subs	r3, r3, r6
 80255ac:	60e3      	str	r3, [r4, #12]
 80255ae:	6122      	str	r2, [r4, #16]
 80255b0:	e7f0      	b.n	8025594 <validate_structure+0xb8>
 80255b2:	6961      	ldr	r1, [r4, #20]
 80255b4:	f8c4 8010 	str.w	r8, [r4, #16]
 80255b8:	1c4a      	adds	r2, r1, #1
 80255ba:	0790      	lsls	r0, r2, #30
 80255bc:	6162      	str	r2, [r4, #20]
 80255be:	d117      	bne.n	80255f0 <validate_structure+0x114>
 80255c0:	fb8c 0502 	smull	r0, r5, ip, r2
 80255c4:	17d0      	asrs	r0, r2, #31
 80255c6:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 80255ca:	fb09 2210 	mls	r2, r9, r0, r2
 80255ce:	b992      	cbnz	r2, 80255f6 <validate_structure+0x11a>
 80255d0:	f501 61ec 	add.w	r1, r1, #1888	; 0x760
 80255d4:	310d      	adds	r1, #13
 80255d6:	fb8c 2601 	smull	r2, r6, ip, r1
 80255da:	17ca      	asrs	r2, r1, #31
 80255dc:	ebc2 16e6 	rsb	r6, r2, r6, asr #7
 80255e0:	fb0a 1116 	mls	r1, sl, r6, r1
 80255e4:	2900      	cmp	r1, #0
 80255e6:	bf0c      	ite	eq
 80255e8:	261d      	moveq	r6, #29
 80255ea:	261c      	movne	r6, #28
 80255ec:	2100      	movs	r1, #0
 80255ee:	e7c7      	b.n	8025580 <validate_structure+0xa4>
 80255f0:	261c      	movs	r6, #28
 80255f2:	2100      	movs	r1, #0
 80255f4:	e7c4      	b.n	8025580 <validate_structure+0xa4>
 80255f6:	261d      	movs	r6, #29
 80255f8:	2100      	movs	r1, #0
 80255fa:	e7c1      	b.n	8025580 <validate_structure+0xa4>
 80255fc:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 8025600:	330c      	adds	r3, #12
 8025602:	fb82 0203 	smull	r0, r2, r2, r3
 8025606:	17d8      	asrs	r0, r3, #31
 8025608:	ebc0 12e2 	rsb	r2, r0, r2, asr #7
 802560c:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8025610:	fb00 3312 	mls	r3, r0, r2, r3
 8025614:	2b00      	cmp	r3, #0
 8025616:	bf0c      	ite	eq
 8025618:	261d      	moveq	r6, #29
 802561a:	261c      	movne	r6, #28
 802561c:	e7a2      	b.n	8025564 <validate_structure+0x88>
 802561e:	220c      	movs	r2, #12
 8025620:	4668      	mov	r0, sp
 8025622:	f003 fdcb 	bl	80291bc <div>
 8025626:	6962      	ldr	r2, [r4, #20]
 8025628:	9901      	ldr	r1, [sp, #4]
 802562a:	9b00      	ldr	r3, [sp, #0]
 802562c:	6121      	str	r1, [r4, #16]
 802562e:	18d3      	adds	r3, r2, r3
 8025630:	2900      	cmp	r1, #0
 8025632:	6163      	str	r3, [r4, #20]
 8025634:	f6bf af67 	bge.w	8025506 <validate_structure+0x2a>
 8025638:	310c      	adds	r1, #12
 802563a:	3b01      	subs	r3, #1
 802563c:	6121      	str	r1, [r4, #16]
 802563e:	6163      	str	r3, [r4, #20]
 8025640:	e761      	b.n	8025506 <validate_structure+0x2a>
 8025642:	2218      	movs	r2, #24
 8025644:	4668      	mov	r0, sp
 8025646:	f003 fdb9 	bl	80291bc <div>
 802564a:	e89d 000c 	ldmia.w	sp, {r2, r3}
 802564e:	68e1      	ldr	r1, [r4, #12]
 8025650:	60a3      	str	r3, [r4, #8]
 8025652:	188a      	adds	r2, r1, r2
 8025654:	2b00      	cmp	r3, #0
 8025656:	60e2      	str	r2, [r4, #12]
 8025658:	f6bf af50 	bge.w	80254fc <validate_structure+0x20>
 802565c:	3318      	adds	r3, #24
 802565e:	3a01      	subs	r2, #1
 8025660:	60a3      	str	r3, [r4, #8]
 8025662:	60e2      	str	r2, [r4, #12]
 8025664:	e74a      	b.n	80254fc <validate_structure+0x20>
 8025666:	223c      	movs	r2, #60	; 0x3c
 8025668:	4668      	mov	r0, sp
 802566a:	f003 fda7 	bl	80291bc <div>
 802566e:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8025672:	68a1      	ldr	r1, [r4, #8]
 8025674:	6063      	str	r3, [r4, #4]
 8025676:	1889      	adds	r1, r1, r2
 8025678:	2b00      	cmp	r3, #0
 802567a:	60a1      	str	r1, [r4, #8]
 802567c:	f6bf af3b 	bge.w	80254f6 <validate_structure+0x1a>
 8025680:	333c      	adds	r3, #60	; 0x3c
 8025682:	3901      	subs	r1, #1
 8025684:	6063      	str	r3, [r4, #4]
 8025686:	60a1      	str	r1, [r4, #8]
 8025688:	e735      	b.n	80254f6 <validate_structure+0x1a>
 802568a:	223c      	movs	r2, #60	; 0x3c
 802568c:	4668      	mov	r0, sp
 802568e:	f003 fd95 	bl	80291bc <div>
 8025692:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8025696:	6861      	ldr	r1, [r4, #4]
 8025698:	6023      	str	r3, [r4, #0]
 802569a:	1889      	adds	r1, r1, r2
 802569c:	2b00      	cmp	r3, #0
 802569e:	6061      	str	r1, [r4, #4]
 80256a0:	f6bf af25 	bge.w	80254ee <validate_structure+0x12>
 80256a4:	333c      	adds	r3, #60	; 0x3c
 80256a6:	3901      	subs	r1, #1
 80256a8:	6023      	str	r3, [r4, #0]
 80256aa:	6061      	str	r1, [r4, #4]
 80256ac:	e71f      	b.n	80254ee <validate_structure+0x12>
 80256ae:	4632      	mov	r2, r6
 80256b0:	e74f      	b.n	8025552 <validate_structure+0x76>
 80256b2:	6962      	ldr	r2, [r4, #20]
 80256b4:	3a01      	subs	r2, #1
 80256b6:	0796      	lsls	r6, r2, #30
 80256b8:	6162      	str	r2, [r4, #20]
 80256ba:	d109      	bne.n	80256d0 <validate_structure+0x1f4>
 80256bc:	fb85 1602 	smull	r1, r6, r5, r2
 80256c0:	17d1      	asrs	r1, r2, #31
 80256c2:	ebc1 1166 	rsb	r1, r1, r6, asr #5
 80256c6:	fb07 2111 	mls	r1, r7, r1, r2
 80256ca:	b129      	cbz	r1, 80256d8 <validate_structure+0x1fc>
 80256cc:	261d      	movs	r6, #29
 80256ce:	e000      	b.n	80256d2 <validate_structure+0x1f6>
 80256d0:	261c      	movs	r6, #28
 80256d2:	210b      	movs	r1, #11
 80256d4:	460a      	mov	r2, r1
 80256d6:	e73a      	b.n	802554e <validate_structure+0x72>
 80256d8:	f502 62ec 	add.w	r2, r2, #1888	; 0x760
 80256dc:	320c      	adds	r2, #12
 80256de:	fb85 1602 	smull	r1, r6, r5, r2
 80256e2:	17d1      	asrs	r1, r2, #31
 80256e4:	ebc1 11e6 	rsb	r1, r1, r6, asr #7
 80256e8:	fb0c 2211 	mls	r2, ip, r1, r2
 80256ec:	2a00      	cmp	r2, #0
 80256ee:	bf0c      	ite	eq
 80256f0:	261d      	moveq	r6, #29
 80256f2:	261c      	movne	r6, #28
 80256f4:	e7ed      	b.n	80256d2 <validate_structure+0x1f6>
 80256f6:	bf00      	nop
 80256f8:	08032c60 	.word	0x08032c60

080256fc <mktime>:
 80256fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025700:	b083      	sub	sp, #12
 8025702:	4604      	mov	r4, r0
 8025704:	f005 f97a 	bl	802a9fc <__gettzinfo>
 8025708:	4605      	mov	r5, r0
 802570a:	4620      	mov	r0, r4
 802570c:	f7ff fee6 	bl	80254dc <validate_structure>
 8025710:	6923      	ldr	r3, [r4, #16]
 8025712:	49a9      	ldr	r1, [pc, #676]	; (80259b8 <mktime+0x2bc>)
 8025714:	68e2      	ldr	r2, [r4, #12]
 8025716:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 802571a:	6820      	ldr	r0, [r4, #0]
 802571c:	68a7      	ldr	r7, [r4, #8]
 802571e:	9000      	str	r0, [sp, #0]
 8025720:	3a01      	subs	r2, #1
 8025722:	2b01      	cmp	r3, #1
 8025724:	9701      	str	r7, [sp, #4]
 8025726:	f8d4 a004 	ldr.w	sl, [r4, #4]
 802572a:	6966      	ldr	r6, [r4, #20]
 802572c:	440a      	add	r2, r1
 802572e:	dd02      	ble.n	8025736 <mktime+0x3a>
 8025730:	07b1      	lsls	r1, r6, #30
 8025732:	f000 80e2 	beq.w	80258fa <mktime+0x1fe>
 8025736:	f506 531c 	add.w	r3, r6, #9984	; 0x2700
 802573a:	3310      	adds	r3, #16
 802573c:	f644 6120 	movw	r1, #20000	; 0x4e20
 8025740:	428b      	cmp	r3, r1
 8025742:	61e2      	str	r2, [r4, #28]
 8025744:	f200 8135 	bhi.w	80259b2 <mktime+0x2b6>
 8025748:	2e46      	cmp	r6, #70	; 0x46
 802574a:	f300 80a0 	bgt.w	802588e <mktime+0x192>
 802574e:	d05d      	beq.n	802580c <mktime+0x110>
 8025750:	2e45      	cmp	r6, #69	; 0x45
 8025752:	f000 8125 	beq.w	80259a0 <mktime+0x2a4>
 8025756:	f248 501f 	movw	r0, #34079	; 0x851f
 802575a:	2345      	movs	r3, #69	; 0x45
 802575c:	f2c5 10eb 	movt	r0, #20971	; 0x51eb
 8025760:	f04f 0b64 	mov.w	fp, #100	; 0x64
 8025764:	46a9      	mov	r9, r5
 8025766:	e020      	b.n	80257aa <mktime+0xae>
 8025768:	f503 61ec 	add.w	r1, r3, #1888	; 0x760
 802576c:	310c      	adds	r1, #12
 802576e:	fb80 c801 	smull	ip, r8, r0, r1
 8025772:	ebc5 1567 	rsb	r5, r5, r7, asr #5
 8025776:	ea4f 7ce1 	mov.w	ip, r1, asr #31
 802577a:	ebcc 1ce8 	rsb	ip, ip, r8, asr #7
 802577e:	f44f 77c8 	mov.w	r7, #400	; 0x190
 8025782:	fb0b 3515 	mls	r5, fp, r5, r3
 8025786:	fb07 1c1c 	mls	ip, r7, ip, r1
 802578a:	2d00      	cmp	r5, #0
 802578c:	f040 80ed 	bne.w	802596a <mktime+0x26e>
 8025790:	f240 116d 	movw	r1, #365	; 0x16d
 8025794:	f1bc 0f00 	cmp.w	ip, #0
 8025798:	bf08      	it	eq
 802579a:	f44f 71b7 	moveq.w	r1, #366	; 0x16e
 802579e:	468c      	mov	ip, r1
 80257a0:	3b01      	subs	r3, #1
 80257a2:	42b3      	cmp	r3, r6
 80257a4:	ebcc 0202 	rsb	r2, ip, r2
 80257a8:	d00d      	beq.n	80257c6 <mktime+0xca>
 80257aa:	f013 0f03 	tst.w	r3, #3
 80257ae:	fb80 c703 	smull	ip, r7, r0, r3
 80257b2:	ea4f 75e3 	mov.w	r5, r3, asr #31
 80257b6:	d0d7      	beq.n	8025768 <mktime+0x6c>
 80257b8:	3b01      	subs	r3, #1
 80257ba:	f240 1c6d 	movw	ip, #365	; 0x16d
 80257be:	42b3      	cmp	r3, r6
 80257c0:	ebcc 0202 	rsb	r2, ip, r2
 80257c4:	d1f1      	bne.n	80257aa <mktime+0xae>
 80257c6:	07b3      	lsls	r3, r6, #30
 80257c8:	464d      	mov	r5, r9
 80257ca:	f040 80e9 	bne.w	80259a0 <mktime+0x2a4>
 80257ce:	f248 531f 	movw	r3, #34079	; 0x851f
 80257d2:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 80257d6:	fb83 7006 	smull	r7, r0, r3, r6
 80257da:	17f1      	asrs	r1, r6, #31
 80257dc:	ebc1 1160 	rsb	r1, r1, r0, asr #5
 80257e0:	2064      	movs	r0, #100	; 0x64
 80257e2:	fb00 6111 	mls	r1, r0, r1, r6
 80257e6:	b971      	cbnz	r1, 8025806 <mktime+0x10a>
 80257e8:	f506 61ec 	add.w	r1, r6, #1888	; 0x760
 80257ec:	310c      	adds	r1, #12
 80257ee:	17c8      	asrs	r0, r1, #31
 80257f0:	fb83 c301 	smull	ip, r3, r3, r1
 80257f4:	ebc0 13e3 	rsb	r3, r0, r3, asr #7
 80257f8:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80257fc:	fb00 1113 	mls	r1, r0, r3, r1
 8025800:	2900      	cmp	r1, #0
 8025802:	f040 80cd 	bne.w	80259a0 <mktime+0x2a4>
 8025806:	f44f 73b7 	mov.w	r3, #366	; 0x16e
 802580a:	1ad2      	subs	r2, r2, r3
 802580c:	f242 4393 	movw	r3, #9363	; 0x2493
 8025810:	1d11      	adds	r1, r2, #4
 8025812:	f2c9 2349 	movt	r3, #37449	; 0x9249
 8025816:	fb83 0301 	smull	r0, r3, r3, r1
 802581a:	185b      	adds	r3, r3, r1
 802581c:	17c8      	asrs	r0, r1, #31
 802581e:	ebc0 03a3 	rsb	r3, r0, r3, asr #2
 8025822:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8025826:	1acb      	subs	r3, r1, r3
 8025828:	2b00      	cmp	r3, #0
 802582a:	61a3      	str	r3, [r4, #24]
 802582c:	f2c0 80a0 	blt.w	8025970 <mktime+0x274>
 8025830:	4b62      	ldr	r3, [pc, #392]	; (80259bc <mktime+0x2c0>)
 8025832:	f8dd c000 	ldr.w	ip, [sp]
 8025836:	6819      	ldr	r1, [r3, #0]
 8025838:	9b01      	ldr	r3, [sp, #4]
 802583a:	6a20      	ldr	r0, [r4, #32]
 802583c:	ebca 1a0a 	rsb	sl, sl, sl, lsl #4
 8025840:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8025844:	f44f 6761 	mov.w	r7, #3600	; 0xe10
 8025848:	fb07 a703 	mla	r7, r7, r3, sl
 802584c:	f44f 43a3 	mov.w	r3, #20864	; 0x5180
 8025850:	4467      	add	r7, ip
 8025852:	f2c0 0301 	movt	r3, #1
 8025856:	fb03 7702 	mla	r7, r3, r2, r7
 802585a:	2801      	cmp	r0, #1
 802585c:	bfb4      	ite	lt
 802585e:	4680      	movlt	r8, r0
 8025860:	f04f 0801 	movge.w	r8, #1
 8025864:	b149      	cbz	r1, 802587a <mktime+0x17e>
 8025866:	f506 60ec 	add.w	r0, r6, #1888	; 0x760
 802586a:	686b      	ldr	r3, [r5, #4]
 802586c:	300c      	adds	r0, #12
 802586e:	4283      	cmp	r3, r0
 8025870:	d056      	beq.n	8025920 <mktime+0x224>
 8025872:	f000 f8a5 	bl	80259c0 <__tzcalc_limits>
 8025876:	2800      	cmp	r0, #0
 8025878:	d152      	bne.n	8025920 <mktime+0x224>
 802587a:	4646      	mov	r6, r8
 802587c:	2e01      	cmp	r6, #1
 802587e:	bf0c      	ite	eq
 8025880:	6be8      	ldreq	r0, [r5, #60]	; 0x3c
 8025882:	6a28      	ldrne	r0, [r5, #32]
 8025884:	6226      	str	r6, [r4, #32]
 8025886:	1838      	adds	r0, r7, r0
 8025888:	b003      	add	sp, #12
 802588a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802588e:	f248 501f 	movw	r0, #34079	; 0x851f
 8025892:	2346      	movs	r3, #70	; 0x46
 8025894:	f2c5 10eb 	movt	r0, #20971	; 0x51eb
 8025898:	f04f 0b64 	mov.w	fp, #100	; 0x64
 802589c:	46a9      	mov	r9, r5
 802589e:	e01d      	b.n	80258dc <mktime+0x1e0>
 80258a0:	f503 61ec 	add.w	r1, r3, #1888	; 0x760
 80258a4:	310c      	adds	r1, #12
 80258a6:	fb80 c801 	smull	ip, r8, r0, r1
 80258aa:	ebc5 1567 	rsb	r5, r5, r7, asr #5
 80258ae:	ea4f 7ce1 	mov.w	ip, r1, asr #31
 80258b2:	ebcc 1ce8 	rsb	ip, ip, r8, asr #7
 80258b6:	f44f 77c8 	mov.w	r7, #400	; 0x190
 80258ba:	fb0b 3515 	mls	r5, fp, r5, r3
 80258be:	fb07 1c1c 	mls	ip, r7, ip, r1
 80258c2:	bb55      	cbnz	r5, 802591a <mktime+0x21e>
 80258c4:	f240 116d 	movw	r1, #365	; 0x16d
 80258c8:	f1bc 0f00 	cmp.w	ip, #0
 80258cc:	bf08      	it	eq
 80258ce:	f44f 71b7 	moveq.w	r1, #366	; 0x16e
 80258d2:	468c      	mov	ip, r1
 80258d4:	3301      	adds	r3, #1
 80258d6:	42b3      	cmp	r3, r6
 80258d8:	4462      	add	r2, ip
 80258da:	d00c      	beq.n	80258f6 <mktime+0x1fa>
 80258dc:	f013 0f03 	tst.w	r3, #3
 80258e0:	fb80 1703 	smull	r1, r7, r0, r3
 80258e4:	ea4f 75e3 	mov.w	r5, r3, asr #31
 80258e8:	d0da      	beq.n	80258a0 <mktime+0x1a4>
 80258ea:	3301      	adds	r3, #1
 80258ec:	f240 1c6d 	movw	ip, #365	; 0x16d
 80258f0:	42b3      	cmp	r3, r6
 80258f2:	4462      	add	r2, ip
 80258f4:	d1f2      	bne.n	80258dc <mktime+0x1e0>
 80258f6:	464d      	mov	r5, r9
 80258f8:	e788      	b.n	802580c <mktime+0x110>
 80258fa:	f248 531f 	movw	r3, #34079	; 0x851f
 80258fe:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8025902:	fb83 c006 	smull	ip, r0, r3, r6
 8025906:	17f1      	asrs	r1, r6, #31
 8025908:	ebc1 1160 	rsb	r1, r1, r0, asr #5
 802590c:	2064      	movs	r0, #100	; 0x64
 802590e:	fb00 6111 	mls	r1, r0, r1, r6
 8025912:	2900      	cmp	r1, #0
 8025914:	d02f      	beq.n	8025976 <mktime+0x27a>
 8025916:	3201      	adds	r2, #1
 8025918:	e70d      	b.n	8025736 <mktime+0x3a>
 802591a:	f44f 7cb7 	mov.w	ip, #366	; 0x16e
 802591e:	e7d9      	b.n	80258d4 <mktime+0x1d8>
 8025920:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8025922:	6a29      	ldr	r1, [r5, #32]
 8025924:	69e8      	ldr	r0, [r5, #28]
 8025926:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8025928:	1a5e      	subs	r6, r3, r1
 802592a:	42b7      	cmp	r7, r6
 802592c:	db02      	blt.n	8025934 <mktime+0x238>
 802592e:	1a9b      	subs	r3, r3, r2
 8025930:	429f      	cmp	r7, r3
 8025932:	dba2      	blt.n	802587a <mktime+0x17e>
 8025934:	682b      	ldr	r3, [r5, #0]
 8025936:	1a80      	subs	r0, r0, r2
 8025938:	b373      	cbz	r3, 8025998 <mktime+0x29c>
 802593a:	4287      	cmp	r7, r0
 802593c:	da34      	bge.n	80259a8 <mktime+0x2ac>
 802593e:	2600      	movs	r6, #0
 8025940:	f1b8 0f00 	cmp.w	r8, #0
 8025944:	db9a      	blt.n	802587c <mktime+0x180>
 8025946:	ea86 0808 	eor.w	r8, r6, r8
 802594a:	f1b8 0f01 	cmp.w	r8, #1
 802594e:	d195      	bne.n	802587c <mktime+0x180>
 8025950:	ebc2 0801 	rsb	r8, r2, r1
 8025954:	b90e      	cbnz	r6, 802595a <mktime+0x25e>
 8025956:	f1c8 0800 	rsb	r8, r8, #0
 802595a:	6823      	ldr	r3, [r4, #0]
 802595c:	4443      	add	r3, r8
 802595e:	6023      	str	r3, [r4, #0]
 8025960:	4620      	mov	r0, r4
 8025962:	f7ff fdbb 	bl	80254dc <validate_structure>
 8025966:	4447      	add	r7, r8
 8025968:	e788      	b.n	802587c <mktime+0x180>
 802596a:	f44f 7cb7 	mov.w	ip, #366	; 0x16e
 802596e:	e717      	b.n	80257a0 <mktime+0xa4>
 8025970:	3307      	adds	r3, #7
 8025972:	61a3      	str	r3, [r4, #24]
 8025974:	e75c      	b.n	8025830 <mktime+0x134>
 8025976:	f506 61ec 	add.w	r1, r6, #1888	; 0x760
 802597a:	310c      	adds	r1, #12
 802597c:	fb83 0301 	smull	r0, r3, r3, r1
 8025980:	17c8      	asrs	r0, r1, #31
 8025982:	ebc0 13e3 	rsb	r3, r0, r3, asr #7
 8025986:	f44f 70c8 	mov.w	r0, #400	; 0x190
 802598a:	fb00 1113 	mls	r1, r0, r3, r1
 802598e:	2900      	cmp	r1, #0
 8025990:	f47f aed1 	bne.w	8025736 <mktime+0x3a>
 8025994:	3201      	adds	r2, #1
 8025996:	e6ce      	b.n	8025736 <mktime+0x3a>
 8025998:	4287      	cmp	r7, r0
 802599a:	db05      	blt.n	80259a8 <mktime+0x2ac>
 802599c:	2601      	movs	r6, #1
 802599e:	e7cf      	b.n	8025940 <mktime+0x244>
 80259a0:	f240 136d 	movw	r3, #365	; 0x16d
 80259a4:	1ad2      	subs	r2, r2, r3
 80259a6:	e731      	b.n	802580c <mktime+0x110>
 80259a8:	42b7      	cmp	r7, r6
 80259aa:	bfac      	ite	ge
 80259ac:	2600      	movge	r6, #0
 80259ae:	2601      	movlt	r6, #1
 80259b0:	e7c6      	b.n	8025940 <mktime+0x244>
 80259b2:	f04f 30ff 	mov.w	r0, #4294967295
 80259b6:	e767      	b.n	8025888 <mktime+0x18c>
 80259b8:	08032c30 	.word	0x08032c30
 80259bc:	200040dc 	.word	0x200040dc

080259c0 <__tzcalc_limits>:
 80259c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80259c4:	b085      	sub	sp, #20
 80259c6:	4604      	mov	r4, r0
 80259c8:	f005 f818 	bl	802a9fc <__gettzinfo>
 80259cc:	f240 73b1 	movw	r3, #1969	; 0x7b1
 80259d0:	429c      	cmp	r4, r3
 80259d2:	f340 809a 	ble.w	8025b0a <__tzcalc_limits+0x14a>
 80259d6:	f5a4 66f6 	sub.w	r6, r4, #1968	; 0x7b0
 80259da:	f5a4 65ec 	sub.w	r5, r4, #1888	; 0x760
 80259de:	f248 521f 	movw	r2, #34079	; 0x851f
 80259e2:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
 80259e6:	3d0d      	subs	r5, #13
 80259e8:	f106 3cff 	add.w	ip, r6, #4294967295
 80259ec:	f5a4 63c8 	sub.w	r3, r4, #1600	; 0x640
 80259f0:	fb82 8705 	smull	r8, r7, r2, r5
 80259f4:	3b01      	subs	r3, #1
 80259f6:	ea4f 0cac 	mov.w	ip, ip, asr #2
 80259fa:	f240 186d 	movw	r8, #365	; 0x16d
 80259fe:	3e02      	subs	r6, #2
 8025a00:	17ed      	asrs	r5, r5, #31
 8025a02:	fb82 1904 	smull	r1, r9, r2, r4
 8025a06:	fb08 c606 	mla	r6, r8, r6, ip
 8025a0a:	eba5 1567 	sub.w	r5, r5, r7, asr #5
 8025a0e:	fb82 7203 	smull	r7, r2, r2, r3
 8025a12:	17db      	asrs	r3, r3, #31
 8025a14:	17e1      	asrs	r1, r4, #31
 8025a16:	1975      	adds	r5, r6, r5
 8025a18:	ebc3 13e2 	rsb	r3, r3, r2, asr #7
 8025a1c:	ebc1 1ce9 	rsb	ip, r1, r9, asr #7
 8025a20:	18eb      	adds	r3, r5, r3
 8025a22:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8025a26:	fb02 4c1c 	mls	ip, r2, ip, r4
 8025a2a:	ebc1 1969 	rsb	r9, r1, r9, asr #5
 8025a2e:	9301      	str	r3, [sp, #4]
 8025a30:	2364      	movs	r3, #100	; 0x64
 8025a32:	f242 4a93 	movw	sl, #9363	; 0x2493
 8025a36:	f44f 48a3 	mov.w	r8, #20864	; 0x5180
 8025a3a:	6044      	str	r4, [r0, #4]
 8025a3c:	fb03 4919 	mls	r9, r3, r9, r4
 8025a40:	f1bc 0f00 	cmp.w	ip, #0
 8025a44:	bf0c      	ite	eq
 8025a46:	2130      	moveq	r1, #48	; 0x30
 8025a48:	2100      	movne	r1, #0
 8025a4a:	f004 0403 	and.w	r4, r4, #3
 8025a4e:	9103      	str	r1, [sp, #12]
 8025a50:	4605      	mov	r5, r0
 8025a52:	2700      	movs	r7, #0
 8025a54:	9402      	str	r4, [sp, #8]
 8025a56:	f2c9 2a49 	movt	sl, #37449	; 0x9249
 8025a5a:	f2c0 0801 	movt	r8, #1
 8025a5e:	46e3      	mov	fp, ip
 8025a60:	7a2b      	ldrb	r3, [r5, #8]
 8025a62:	2b4a      	cmp	r3, #74	; 0x4a
 8025a64:	d053      	beq.n	8025b0e <__tzcalc_limits+0x14e>
 8025a66:	2b44      	cmp	r3, #68	; 0x44
 8025a68:	d063      	beq.n	8025b32 <__tzcalc_limits+0x172>
 8025a6a:	9c02      	ldr	r4, [sp, #8]
 8025a6c:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8025a70:	2c00      	cmp	r4, #0
 8025a72:	d044      	beq.n	8025afe <__tzcalc_limits+0x13e>
 8025a74:	68ee      	ldr	r6, [r5, #12]
 8025a76:	f642 4190 	movw	r1, #11408	; 0x2c90
 8025a7a:	f6c0 0103 	movt	r1, #2051	; 0x803
 8025a7e:	2e01      	cmp	r6, #1
 8025a80:	448c      	add	ip, r1
 8025a82:	dd5a      	ble.n	8025b3a <__tzcalc_limits+0x17a>
 8025a84:	9a01      	ldr	r2, [sp, #4]
 8025a86:	4661      	mov	r1, ip
 8025a88:	2301      	movs	r3, #1
 8025a8a:	4604      	mov	r4, r0
 8025a8c:	f851 0b04 	ldr.w	r0, [r1], #4
 8025a90:	3301      	adds	r3, #1
 8025a92:	42b3      	cmp	r3, r6
 8025a94:	4402      	add	r2, r0
 8025a96:	d1f9      	bne.n	8025a8c <__tzcalc_limits+0xcc>
 8025a98:	3b01      	subs	r3, #1
 8025a9a:	4620      	mov	r0, r4
 8025a9c:	009b      	lsls	r3, r3, #2
 8025a9e:	1d11      	adds	r1, r2, #4
 8025aa0:	fb8a 4601 	smull	r4, r6, sl, r1
 8025aa4:	1876      	adds	r6, r6, r1
 8025aa6:	17cc      	asrs	r4, r1, #31
 8025aa8:	ebc4 04a6 	rsb	r4, r4, r6, asr #2
 8025aac:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
 8025ab0:	696e      	ldr	r6, [r5, #20]
 8025ab2:	f85c 3003 	ldr.w	r3, [ip, r3]
 8025ab6:	1b09      	subs	r1, r1, r4
 8025ab8:	692c      	ldr	r4, [r5, #16]
 8025aba:	1a71      	subs	r1, r6, r1
 8025abc:	bf48      	it	mi
 8025abe:	3107      	addmi	r1, #7
 8025ac0:	3c01      	subs	r4, #1
 8025ac2:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
 8025ac6:	1861      	adds	r1, r4, r1
 8025ac8:	4299      	cmp	r1, r3
 8025aca:	db02      	blt.n	8025ad2 <__tzcalc_limits+0x112>
 8025acc:	3907      	subs	r1, #7
 8025ace:	4299      	cmp	r1, r3
 8025ad0:	dafc      	bge.n	8025acc <__tzcalc_limits+0x10c>
 8025ad2:	1851      	adds	r1, r2, r1
 8025ad4:	69ae      	ldr	r6, [r5, #24]
 8025ad6:	6a2b      	ldr	r3, [r5, #32]
 8025ad8:	fb08 6101 	mla	r1, r8, r1, r6
 8025adc:	3701      	adds	r7, #1
 8025ade:	18cb      	adds	r3, r1, r3
 8025ae0:	2f02      	cmp	r7, #2
 8025ae2:	f845 3f1c 	str.w	r3, [r5, #28]!
 8025ae6:	d1bb      	bne.n	8025a60 <__tzcalc_limits+0xa0>
 8025ae8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8025aea:	69c2      	ldr	r2, [r0, #28]
 8025aec:	429a      	cmp	r2, r3
 8025aee:	bfac      	ite	ge
 8025af0:	2300      	movge	r3, #0
 8025af2:	2301      	movlt	r3, #1
 8025af4:	6003      	str	r3, [r0, #0]
 8025af6:	2001      	movs	r0, #1
 8025af8:	b005      	add	sp, #20
 8025afa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025afe:	f1b9 0f00 	cmp.w	r9, #0
 8025b02:	bf18      	it	ne
 8025b04:	f04f 0c30 	movne.w	ip, #48	; 0x30
 8025b08:	e7b4      	b.n	8025a74 <__tzcalc_limits+0xb4>
 8025b0a:	2000      	movs	r0, #0
 8025b0c:	e7f4      	b.n	8025af8 <__tzcalc_limits+0x138>
 8025b0e:	696b      	ldr	r3, [r5, #20]
 8025b10:	9c01      	ldr	r4, [sp, #4]
 8025b12:	9902      	ldr	r1, [sp, #8]
 8025b14:	191a      	adds	r2, r3, r4
 8025b16:	b939      	cbnz	r1, 8025b28 <__tzcalc_limits+0x168>
 8025b18:	f1b9 0f00 	cmp.w	r9, #0
 8025b1c:	d004      	beq.n	8025b28 <__tzcalc_limits+0x168>
 8025b1e:	2b3b      	cmp	r3, #59	; 0x3b
 8025b20:	bfd4      	ite	le
 8025b22:	2100      	movle	r1, #0
 8025b24:	2101      	movgt	r1, #1
 8025b26:	e7d4      	b.n	8025ad2 <__tzcalc_limits+0x112>
 8025b28:	f1bb 0f00 	cmp.w	fp, #0
 8025b2c:	d0f7      	beq.n	8025b1e <__tzcalc_limits+0x15e>
 8025b2e:	2100      	movs	r1, #0
 8025b30:	e7cf      	b.n	8025ad2 <__tzcalc_limits+0x112>
 8025b32:	6969      	ldr	r1, [r5, #20]
 8025b34:	9b01      	ldr	r3, [sp, #4]
 8025b36:	1859      	adds	r1, r3, r1
 8025b38:	e7cc      	b.n	8025ad4 <__tzcalc_limits+0x114>
 8025b3a:	9a01      	ldr	r2, [sp, #4]
 8025b3c:	2300      	movs	r3, #0
 8025b3e:	e7ae      	b.n	8025a9e <__tzcalc_limits+0xde>

08025b40 <_mktm_r>:
 8025b40:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025b44:	4604      	mov	r4, r0
 8025b46:	460d      	mov	r5, r1
 8025b48:	4616      	mov	r6, r2
 8025b4a:	f004 ff57 	bl	802a9fc <__gettzinfo>
 8025b4e:	6822      	ldr	r2, [r4, #0]
 8025b50:	f244 5307 	movw	r3, #17671	; 0x4507
 8025b54:	f2cc 232e 	movt	r3, #49710	; 0xc22e
 8025b58:	4680      	mov	r8, r0
 8025b5a:	fb83 0302 	smull	r0, r3, r3, r2
 8025b5e:	189b      	adds	r3, r3, r2
 8025b60:	17d0      	asrs	r0, r2, #31
 8025b62:	f44f 41a3 	mov.w	r1, #20864	; 0x5180
 8025b66:	ebc0 4323 	rsb	r3, r0, r3, asr #16
 8025b6a:	f2c0 0101 	movt	r1, #1
 8025b6e:	fb01 2213 	mls	r2, r1, r3, r2
 8025b72:	2a00      	cmp	r2, #0
 8025b74:	da04      	bge.n	8025b80 <_mktm_r+0x40>
 8025b76:	f502 32a8 	add.w	r2, r2, #86016	; 0x15000
 8025b7a:	f502 72c0 	add.w	r2, r2, #384	; 0x180
 8025b7e:	3b01      	subs	r3, #1
 8025b80:	f24b 3cc5 	movw	ip, #46021	; 0xb3c5
 8025b84:	f2c9 1ca2 	movt	ip, #37282	; 0x91a2
 8025b88:	fb8c 1c02 	smull	r1, ip, ip, r2
 8025b8c:	4494      	add	ip, r2
 8025b8e:	17d1      	asrs	r1, r2, #31
 8025b90:	ebc1 2cec 	rsb	ip, r1, ip, asr #11
 8025b94:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 8025b98:	f242 4193 	movw	r1, #9363	; 0x2493
 8025b9c:	fb00 221c 	mls	r2, r0, ip, r2
 8025ba0:	f648 0789 	movw	r7, #34953	; 0x8889
 8025ba4:	1d18      	adds	r0, r3, #4
 8025ba6:	f2c9 2149 	movt	r1, #37449	; 0x9249
 8025baa:	f6c8 0788 	movt	r7, #34952	; 0x8888
 8025bae:	fb81 b100 	smull	fp, r1, r1, r0
 8025bb2:	fb87 9702 	smull	r9, r7, r7, r2
 8025bb6:	1809      	adds	r1, r1, r0
 8025bb8:	ea4f 79e0 	mov.w	r9, r0, asr #31
 8025bbc:	18bf      	adds	r7, r7, r2
 8025bbe:	ea4f 7ae2 	mov.w	sl, r2, asr #31
 8025bc2:	ebc9 01a1 	rsb	r1, r9, r1, asr #2
 8025bc6:	ebca 1767 	rsb	r7, sl, r7, asr #5
 8025bca:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8025bce:	1a41      	subs	r1, r0, r1
 8025bd0:	ebc7 1907 	rsb	r9, r7, r7, lsl #4
 8025bd4:	eba2 0289 	sub.w	r2, r2, r9, lsl #2
 8025bd8:	2900      	cmp	r1, #0
 8025bda:	e885 1084 	stmia.w	r5, {r2, r7, ip}
 8025bde:	61a9      	str	r1, [r5, #24]
 8025be0:	f2c0 80a3 	blt.w	8025d2a <_mktm_r+0x1ea>
 8025be4:	2b00      	cmp	r3, #0
 8025be6:	db73      	blt.n	8025cd0 <_mktm_r+0x190>
 8025be8:	f248 501f 	movw	r0, #34079	; 0x851f
 8025bec:	4fa4      	ldr	r7, [pc, #656]	; (8025e80 <_mktm_r+0x340>)
 8025bee:	f240 79b2 	movw	r9, #1970	; 0x7b2
 8025bf2:	f2c5 10eb 	movt	r0, #20971	; 0x51eb
 8025bf6:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 8025bfa:	f04f 0a64 	mov.w	sl, #100	; 0x64
 8025bfe:	e00c      	b.n	8025c1a <_mktm_r+0xda>
 8025c00:	ebc2 1161 	rsb	r1, r2, r1, asr #5
 8025c04:	fb0a 9111 	mls	r1, sl, r1, r9
 8025c08:	b171      	cbz	r1, 8025c28 <_mktm_r+0xe8>
 8025c0a:	2201      	movs	r2, #1
 8025c0c:	f857 1022 	ldr.w	r1, [r7, r2, lsl #2]
 8025c10:	428b      	cmp	r3, r1
 8025c12:	db17      	blt.n	8025c44 <_mktm_r+0x104>
 8025c14:	f109 0901 	add.w	r9, r9, #1
 8025c18:	1a5b      	subs	r3, r3, r1
 8025c1a:	f019 0f03 	tst.w	r9, #3
 8025c1e:	ea4f 72e9 	mov.w	r2, r9, asr #31
 8025c22:	fb80 b109 	smull	fp, r1, r0, r9
 8025c26:	d0eb      	beq.n	8025c00 <_mktm_r+0xc0>
 8025c28:	fb80 b109 	smull	fp, r1, r0, r9
 8025c2c:	ebc2 12e1 	rsb	r2, r2, r1, asr #7
 8025c30:	fb0c 9212 	mls	r2, ip, r2, r9
 8025c34:	f1d2 0201 	rsbs	r2, r2, #1
 8025c38:	bf38      	it	cc
 8025c3a:	2200      	movcc	r2, #0
 8025c3c:	f857 1022 	ldr.w	r1, [r7, r2, lsl #2]
 8025c40:	428b      	cmp	r3, r1
 8025c42:	dae7      	bge.n	8025c14 <_mktm_r+0xd4>
 8025c44:	0057      	lsls	r7, r2, #1
 8025c46:	f5a9 60ec 	sub.w	r0, r9, #1888	; 0x760
 8025c4a:	18bf      	adds	r7, r7, r2
 8025c4c:	f1a0 020c 	sub.w	r2, r0, #12
 8025c50:	013f      	lsls	r7, r7, #4
 8025c52:	498c      	ldr	r1, [pc, #560]	; (8025e84 <_mktm_r+0x344>)
 8025c54:	616a      	str	r2, [r5, #20]
 8025c56:	2200      	movs	r2, #0
 8025c58:	61eb      	str	r3, [r5, #28]
 8025c5a:	612a      	str	r2, [r5, #16]
 8025c5c:	59ca      	ldr	r2, [r1, r7]
 8025c5e:	4293      	cmp	r3, r2
 8025c60:	440f      	add	r7, r1
 8025c62:	db08      	blt.n	8025c76 <_mktm_r+0x136>
 8025c64:	4638      	mov	r0, r7
 8025c66:	2101      	movs	r1, #1
 8025c68:	6129      	str	r1, [r5, #16]
 8025c6a:	1a9b      	subs	r3, r3, r2
 8025c6c:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8025c70:	3101      	adds	r1, #1
 8025c72:	429a      	cmp	r2, r3
 8025c74:	ddf8      	ble.n	8025c68 <_mktm_r+0x128>
 8025c76:	3301      	adds	r3, #1
 8025c78:	60eb      	str	r3, [r5, #12]
 8025c7a:	b126      	cbz	r6, 8025c86 <_mktm_r+0x146>
 8025c7c:	2300      	movs	r3, #0
 8025c7e:	622b      	str	r3, [r5, #32]
 8025c80:	4628      	mov	r0, r5
 8025c82:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025c86:	f002 fb9f 	bl	80283c8 <__tz_lock>
 8025c8a:	4b7f      	ldr	r3, [pc, #508]	; (8025e88 <_mktm_r+0x348>)
 8025c8c:	681b      	ldr	r3, [r3, #0]
 8025c8e:	2b00      	cmp	r3, #0
 8025c90:	d04e      	beq.n	8025d30 <_mktm_r+0x1f0>
 8025c92:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8025c96:	454b      	cmp	r3, r9
 8025c98:	d005      	beq.n	8025ca6 <_mktm_r+0x166>
 8025c9a:	4648      	mov	r0, r9
 8025c9c:	f7ff fe90 	bl	80259c0 <__tzcalc_limits>
 8025ca0:	2800      	cmp	r0, #0
 8025ca2:	f000 80da 	beq.w	8025e5a <_mktm_r+0x31a>
 8025ca6:	f8d8 3000 	ldr.w	r3, [r8]
 8025caa:	2b00      	cmp	r3, #0
 8025cac:	f000 80c2 	beq.w	8025e34 <_mktm_r+0x2f4>
 8025cb0:	6823      	ldr	r3, [r4, #0]
 8025cb2:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8025cb6:	4293      	cmp	r3, r2
 8025cb8:	f2c0 80dc 	blt.w	8025e74 <_mktm_r+0x334>
 8025cbc:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 8025cc0:	4293      	cmp	r3, r2
 8025cc2:	f280 80d7 	bge.w	8025e74 <_mktm_r+0x334>
 8025cc6:	2301      	movs	r3, #1
 8025cc8:	622b      	str	r3, [r5, #32]
 8025cca:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
 8025cce:	e032      	b.n	8025d36 <_mktm_r+0x1f6>
 8025cd0:	f248 511f 	movw	r1, #34079	; 0x851f
 8025cd4:	4f6a      	ldr	r7, [pc, #424]	; (8025e80 <_mktm_r+0x340>)
 8025cd6:	f240 79b2 	movw	r9, #1970	; 0x7b2
 8025cda:	f2c5 11eb 	movt	r1, #20971	; 0x51eb
 8025cde:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8025ce2:	f04f 0c64 	mov.w	ip, #100	; 0x64
 8025ce6:	e00c      	b.n	8025d02 <_mktm_r+0x1c2>
 8025ce8:	ebc2 1a6a 	rsb	sl, r2, sl, asr #5
 8025cec:	fb0c 9a1a 	mls	sl, ip, sl, r9
 8025cf0:	f1ba 0f00 	cmp.w	sl, #0
 8025cf4:	d00e      	beq.n	8025d14 <_mktm_r+0x1d4>
 8025cf6:	2201      	movs	r2, #1
 8025cf8:	f857 a022 	ldr.w	sl, [r7, r2, lsl #2]
 8025cfc:	eb13 030a 	adds.w	r3, r3, sl
 8025d00:	d5a0      	bpl.n	8025c44 <_mktm_r+0x104>
 8025d02:	f109 39ff 	add.w	r9, r9, #4294967295
 8025d06:	f019 0f03 	tst.w	r9, #3
 8025d0a:	ea4f 72e9 	mov.w	r2, r9, asr #31
 8025d0e:	fb81 ba09 	smull	fp, sl, r1, r9
 8025d12:	d0e9      	beq.n	8025ce8 <_mktm_r+0x1a8>
 8025d14:	fb81 ba09 	smull	fp, sl, r1, r9
 8025d18:	ebc2 12ea 	rsb	r2, r2, sl, asr #7
 8025d1c:	fb00 9212 	mls	r2, r0, r2, r9
 8025d20:	f1d2 0201 	rsbs	r2, r2, #1
 8025d24:	bf38      	it	cc
 8025d26:	2200      	movcc	r2, #0
 8025d28:	e7e6      	b.n	8025cf8 <_mktm_r+0x1b8>
 8025d2a:	3107      	adds	r1, #7
 8025d2c:	61a9      	str	r1, [r5, #24]
 8025d2e:	e759      	b.n	8025be4 <_mktm_r+0xa4>
 8025d30:	622e      	str	r6, [r5, #32]
 8025d32:	f8d8 1020 	ldr.w	r1, [r8, #32]
 8025d36:	f24b 33c5 	movw	r3, #46021	; 0xb3c5
 8025d3a:	f2c9 13a2 	movt	r3, #37282	; 0x91a2
 8025d3e:	fb83 0401 	smull	r0, r4, r3, r1
 8025d42:	1864      	adds	r4, r4, r1
 8025d44:	17c8      	asrs	r0, r1, #31
 8025d46:	12e4      	asrs	r4, r4, #11
 8025d48:	1a23      	subs	r3, r4, r0
 8025d4a:	f44f 6661 	mov.w	r6, #3600	; 0xe10
 8025d4e:	f648 0289 	movw	r2, #34953	; 0x8889
 8025d52:	fb06 1313 	mls	r3, r6, r3, r1
 8025d56:	f6c8 0288 	movt	r2, #34952	; 0x8888
 8025d5a:	fb82 1203 	smull	r1, r2, r2, r3
 8025d5e:	18d2      	adds	r2, r2, r3
 8025d60:	17d9      	asrs	r1, r3, #31
 8025d62:	ebc1 1162 	rsb	r1, r1, r2, asr #5
 8025d66:	f8d5 e000 	ldr.w	lr, [r5]
 8025d6a:	686e      	ldr	r6, [r5, #4]
 8025d6c:	68aa      	ldr	r2, [r5, #8]
 8025d6e:	ebc1 1c01 	rsb	ip, r1, r1, lsl #4
 8025d72:	eba3 038c 	sub.w	r3, r3, ip, lsl #2
 8025d76:	ebc3 030e 	rsb	r3, r3, lr
 8025d7a:	1a20      	subs	r0, r4, r0
 8025d7c:	1a71      	subs	r1, r6, r1
 8025d7e:	1a12      	subs	r2, r2, r0
 8025d80:	2b3b      	cmp	r3, #59	; 0x3b
 8025d82:	602b      	str	r3, [r5, #0]
 8025d84:	6069      	str	r1, [r5, #4]
 8025d86:	60aa      	str	r2, [r5, #8]
 8025d88:	dd2a      	ble.n	8025de0 <_mktm_r+0x2a0>
 8025d8a:	3101      	adds	r1, #1
 8025d8c:	3b3c      	subs	r3, #60	; 0x3c
 8025d8e:	6069      	str	r1, [r5, #4]
 8025d90:	602b      	str	r3, [r5, #0]
 8025d92:	293b      	cmp	r1, #59	; 0x3b
 8025d94:	dd47      	ble.n	8025e26 <_mktm_r+0x2e6>
 8025d96:	3201      	adds	r2, #1
 8025d98:	393c      	subs	r1, #60	; 0x3c
 8025d9a:	60aa      	str	r2, [r5, #8]
 8025d9c:	6069      	str	r1, [r5, #4]
 8025d9e:	2a17      	cmp	r2, #23
 8025da0:	dd25      	ble.n	8025dee <_mktm_r+0x2ae>
 8025da2:	69ab      	ldr	r3, [r5, #24]
 8025da4:	69e9      	ldr	r1, [r5, #28]
 8025da6:	3301      	adds	r3, #1
 8025da8:	3101      	adds	r1, #1
 8025daa:	2b06      	cmp	r3, #6
 8025dac:	61e9      	str	r1, [r5, #28]
 8025dae:	61ab      	str	r3, [r5, #24]
 8025db0:	dd01      	ble.n	8025db6 <_mktm_r+0x276>
 8025db2:	2300      	movs	r3, #0
 8025db4:	61ab      	str	r3, [r5, #24]
 8025db6:	68eb      	ldr	r3, [r5, #12]
 8025db8:	6929      	ldr	r1, [r5, #16]
 8025dba:	3a18      	subs	r2, #24
 8025dbc:	3301      	adds	r3, #1
 8025dbe:	60eb      	str	r3, [r5, #12]
 8025dc0:	60aa      	str	r2, [r5, #8]
 8025dc2:	f857 2021 	ldr.w	r2, [r7, r1, lsl #2]
 8025dc6:	4293      	cmp	r3, r2
 8025dc8:	dd05      	ble.n	8025dd6 <_mktm_r+0x296>
 8025dca:	3101      	adds	r1, #1
 8025dcc:	1a9b      	subs	r3, r3, r2
 8025dce:	290c      	cmp	r1, #12
 8025dd0:	60eb      	str	r3, [r5, #12]
 8025dd2:	6129      	str	r1, [r5, #16]
 8025dd4:	d045      	beq.n	8025e62 <_mktm_r+0x322>
 8025dd6:	f002 faf9 	bl	80283cc <__tz_unlock>
 8025dda:	4628      	mov	r0, r5
 8025ddc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025de0:	2b00      	cmp	r3, #0
 8025de2:	dad6      	bge.n	8025d92 <_mktm_r+0x252>
 8025de4:	3901      	subs	r1, #1
 8025de6:	333c      	adds	r3, #60	; 0x3c
 8025de8:	6069      	str	r1, [r5, #4]
 8025dea:	602b      	str	r3, [r5, #0]
 8025dec:	e7d1      	b.n	8025d92 <_mktm_r+0x252>
 8025dee:	2a00      	cmp	r2, #0
 8025df0:	daf1      	bge.n	8025dd6 <_mktm_r+0x296>
 8025df2:	69ab      	ldr	r3, [r5, #24]
 8025df4:	69e9      	ldr	r1, [r5, #28]
 8025df6:	3b01      	subs	r3, #1
 8025df8:	3901      	subs	r1, #1
 8025dfa:	2b00      	cmp	r3, #0
 8025dfc:	61e9      	str	r1, [r5, #28]
 8025dfe:	61ab      	str	r3, [r5, #24]
 8025e00:	db3b      	blt.n	8025e7a <_mktm_r+0x33a>
 8025e02:	68eb      	ldr	r3, [r5, #12]
 8025e04:	3218      	adds	r2, #24
 8025e06:	3b01      	subs	r3, #1
 8025e08:	60eb      	str	r3, [r5, #12]
 8025e0a:	60aa      	str	r2, [r5, #8]
 8025e0c:	2b00      	cmp	r3, #0
 8025e0e:	d1e2      	bne.n	8025dd6 <_mktm_r+0x296>
 8025e10:	692b      	ldr	r3, [r5, #16]
 8025e12:	3b01      	subs	r3, #1
 8025e14:	2b00      	cmp	r3, #0
 8025e16:	612b      	str	r3, [r5, #16]
 8025e18:	db38      	blt.n	8025e8c <_mktm_r+0x34c>
 8025e1a:	009b      	lsls	r3, r3, #2
 8025e1c:	58fb      	ldr	r3, [r7, r3]
 8025e1e:	60eb      	str	r3, [r5, #12]
 8025e20:	f002 fad4 	bl	80283cc <__tz_unlock>
 8025e24:	e7d9      	b.n	8025dda <_mktm_r+0x29a>
 8025e26:	2900      	cmp	r1, #0
 8025e28:	dab9      	bge.n	8025d9e <_mktm_r+0x25e>
 8025e2a:	3a01      	subs	r2, #1
 8025e2c:	313c      	adds	r1, #60	; 0x3c
 8025e2e:	60aa      	str	r2, [r5, #8]
 8025e30:	6069      	str	r1, [r5, #4]
 8025e32:	e7b4      	b.n	8025d9e <_mktm_r+0x25e>
 8025e34:	6823      	ldr	r3, [r4, #0]
 8025e36:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8025e3a:	4293      	cmp	r3, r2
 8025e3c:	f6bf af43 	bge.w	8025cc6 <_mktm_r+0x186>
 8025e40:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 8025e44:	4293      	cmp	r3, r2
 8025e46:	bfac      	ite	ge
 8025e48:	2300      	movge	r3, #0
 8025e4a:	2301      	movlt	r3, #1
 8025e4c:	622b      	str	r3, [r5, #32]
 8025e4e:	2b00      	cmp	r3, #0
 8025e50:	f43f af6f 	beq.w	8025d32 <_mktm_r+0x1f2>
 8025e54:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
 8025e58:	e76d      	b.n	8025d36 <_mktm_r+0x1f6>
 8025e5a:	f04f 33ff 	mov.w	r3, #4294967295
 8025e5e:	622b      	str	r3, [r5, #32]
 8025e60:	e767      	b.n	8025d32 <_mktm_r+0x1f2>
 8025e62:	696a      	ldr	r2, [r5, #20]
 8025e64:	2300      	movs	r3, #0
 8025e66:	3201      	adds	r2, #1
 8025e68:	612b      	str	r3, [r5, #16]
 8025e6a:	616a      	str	r2, [r5, #20]
 8025e6c:	61eb      	str	r3, [r5, #28]
 8025e6e:	f002 faad 	bl	80283cc <__tz_unlock>
 8025e72:	e7b2      	b.n	8025dda <_mktm_r+0x29a>
 8025e74:	2300      	movs	r3, #0
 8025e76:	622b      	str	r3, [r5, #32]
 8025e78:	e75b      	b.n	8025d32 <_mktm_r+0x1f2>
 8025e7a:	2306      	movs	r3, #6
 8025e7c:	61ab      	str	r3, [r5, #24]
 8025e7e:	e7c0      	b.n	8025e02 <_mktm_r+0x2c2>
 8025e80:	08032cf0 	.word	0x08032cf0
 8025e84:	08032c90 	.word	0x08032c90
 8025e88:	200040dc 	.word	0x200040dc
 8025e8c:	696b      	ldr	r3, [r5, #20]
 8025e8e:	220b      	movs	r2, #11
 8025e90:	3b01      	subs	r3, #1
 8025e92:	612a      	str	r2, [r5, #16]
 8025e94:	079a      	lsls	r2, r3, #30
 8025e96:	616b      	str	r3, [r5, #20]
 8025e98:	d016      	beq.n	8025ec8 <_mktm_r+0x388>
 8025e9a:	17da      	asrs	r2, r3, #31
 8025e9c:	f248 511f 	movw	r1, #34079	; 0x851f
 8025ea0:	f2c5 11eb 	movt	r1, #20971	; 0x51eb
 8025ea4:	fb81 b103 	smull	fp, r1, r1, r3
 8025ea8:	ebc2 12e1 	rsb	r2, r2, r1, asr #7
 8025eac:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8025eb0:	fb01 3312 	mls	r3, r1, r2, r3
 8025eb4:	f1d3 0301 	rsbs	r3, r3, #1
 8025eb8:	bf38      	it	cc
 8025eba:	2300      	movcc	r3, #0
 8025ebc:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 8025ec0:	3301      	adds	r3, #1
 8025ec2:	61eb      	str	r3, [r5, #28]
 8025ec4:	232c      	movs	r3, #44	; 0x2c
 8025ec6:	e7a9      	b.n	8025e1c <_mktm_r+0x2dc>
 8025ec8:	f248 521f 	movw	r2, #34079	; 0x851f
 8025ecc:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
 8025ed0:	fb82 9103 	smull	r9, r1, r2, r3
 8025ed4:	17da      	asrs	r2, r3, #31
 8025ed6:	ebc2 1161 	rsb	r1, r2, r1, asr #5
 8025eda:	2064      	movs	r0, #100	; 0x64
 8025edc:	fb00 3111 	mls	r1, r0, r1, r3
 8025ee0:	2900      	cmp	r1, #0
 8025ee2:	d0db      	beq.n	8025e9c <_mktm_r+0x35c>
 8025ee4:	f44f 73b7 	mov.w	r3, #366	; 0x16e
 8025ee8:	e7eb      	b.n	8025ec2 <_mktm_r+0x382>
 8025eea:	bf00      	nop

08025eec <_sbrk_r>:
 8025eec:	b538      	push	{r3, r4, r5, lr}
 8025eee:	4c07      	ldr	r4, [pc, #28]	; (8025f0c <_sbrk_r+0x20>)
 8025ef0:	2300      	movs	r3, #0
 8025ef2:	4605      	mov	r5, r0
 8025ef4:	4608      	mov	r0, r1
 8025ef6:	6023      	str	r3, [r4, #0]
 8025ef8:	f7fc f984 	bl	8022204 <_sbrk>
 8025efc:	1c43      	adds	r3, r0, #1
 8025efe:	d000      	beq.n	8025f02 <_sbrk_r+0x16>
 8025f00:	bd38      	pop	{r3, r4, r5, pc}
 8025f02:	6823      	ldr	r3, [r4, #0]
 8025f04:	2b00      	cmp	r3, #0
 8025f06:	d0fb      	beq.n	8025f00 <_sbrk_r+0x14>
 8025f08:	602b      	str	r3, [r5, #0]
 8025f0a:	bd38      	pop	{r3, r4, r5, pc}
 8025f0c:	2000a544 	.word	0x2000a544

08025f10 <sprintf>:
 8025f10:	b40e      	push	{r1, r2, r3}
 8025f12:	b570      	push	{r4, r5, r6, lr}
 8025f14:	f240 5110 	movw	r1, #1296	; 0x510
 8025f18:	b09d      	sub	sp, #116	; 0x74
 8025f1a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8025f1e:	ab21      	add	r3, sp, #132	; 0x84
 8025f20:	6809      	ldr	r1, [r1, #0]
 8025f22:	f853 2b04 	ldr.w	r2, [r3], #4
 8025f26:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 8025f2a:	4605      	mov	r5, r0
 8025f2c:	9403      	str	r4, [sp, #12]
 8025f2e:	9406      	str	r4, [sp, #24]
 8025f30:	4608      	mov	r0, r1
 8025f32:	f44f 7602 	mov.w	r6, #520	; 0x208
 8025f36:	a901      	add	r1, sp, #4
 8025f38:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8025f3c:	931b      	str	r3, [sp, #108]	; 0x6c
 8025f3e:	f8ad 6010 	strh.w	r6, [sp, #16]
 8025f42:	9501      	str	r5, [sp, #4]
 8025f44:	9505      	str	r5, [sp, #20]
 8025f46:	f8ad 4012 	strh.w	r4, [sp, #18]
 8025f4a:	f001 f811 	bl	8026f70 <_svfprintf_r>
 8025f4e:	9b01      	ldr	r3, [sp, #4]
 8025f50:	2200      	movs	r2, #0
 8025f52:	701a      	strb	r2, [r3, #0]
 8025f54:	b01d      	add	sp, #116	; 0x74
 8025f56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8025f5a:	b003      	add	sp, #12
 8025f5c:	4770      	bx	lr
 8025f5e:	bf00      	nop

08025f60 <strcat>:
 8025f60:	b538      	push	{r3, r4, r5, lr}
 8025f62:	0783      	lsls	r3, r0, #30
 8025f64:	4604      	mov	r4, r0
 8025f66:	d113      	bne.n	8025f90 <strcat+0x30>
 8025f68:	6803      	ldr	r3, [r0, #0]
 8025f6a:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8025f6e:	ea22 0303 	bic.w	r3, r2, r3
 8025f72:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8025f76:	d10b      	bne.n	8025f90 <strcat+0x30>
 8025f78:	4602      	mov	r2, r0
 8025f7a:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8025f7e:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 8025f82:	ea25 0303 	bic.w	r3, r5, r3
 8025f86:	3004      	adds	r0, #4
 8025f88:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8025f8c:	d0f5      	beq.n	8025f7a <strcat+0x1a>
 8025f8e:	e000      	b.n	8025f92 <strcat+0x32>
 8025f90:	4620      	mov	r0, r4
 8025f92:	7803      	ldrb	r3, [r0, #0]
 8025f94:	b12b      	cbz	r3, 8025fa2 <strcat+0x42>
 8025f96:	4603      	mov	r3, r0
 8025f98:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8025f9c:	3001      	adds	r0, #1
 8025f9e:	2a00      	cmp	r2, #0
 8025fa0:	d1fa      	bne.n	8025f98 <strcat+0x38>
 8025fa2:	f000 f803 	bl	8025fac <strcpy>
 8025fa6:	4620      	mov	r0, r4
 8025fa8:	bd38      	pop	{r3, r4, r5, pc}
 8025faa:	bf00      	nop

08025fac <strcpy>:
 8025fac:	ea80 0201 	eor.w	r2, r0, r1
 8025fb0:	4684      	mov	ip, r0
 8025fb2:	f012 0f03 	tst.w	r2, #3
 8025fb6:	d14f      	bne.n	8026058 <strcpy+0xac>
 8025fb8:	f011 0f03 	tst.w	r1, #3
 8025fbc:	d132      	bne.n	8026024 <strcpy+0x78>
 8025fbe:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8025fc2:	f011 0f04 	tst.w	r1, #4
 8025fc6:	f851 3b04 	ldr.w	r3, [r1], #4
 8025fca:	d00b      	beq.n	8025fe4 <strcpy+0x38>
 8025fcc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8025fd0:	439a      	bics	r2, r3
 8025fd2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8025fd6:	bf04      	itt	eq
 8025fd8:	f84c 3b04 	streq.w	r3, [ip], #4
 8025fdc:	f851 3b04 	ldreq.w	r3, [r1], #4
 8025fe0:	d116      	bne.n	8026010 <strcpy+0x64>
 8025fe2:	bf00      	nop
 8025fe4:	f851 4b04 	ldr.w	r4, [r1], #4
 8025fe8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8025fec:	439a      	bics	r2, r3
 8025fee:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8025ff2:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 8025ff6:	d10b      	bne.n	8026010 <strcpy+0x64>
 8025ff8:	f84c 3b04 	str.w	r3, [ip], #4
 8025ffc:	43a2      	bics	r2, r4
 8025ffe:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8026002:	bf04      	itt	eq
 8026004:	f851 3b04 	ldreq.w	r3, [r1], #4
 8026008:	f84c 4b04 	streq.w	r4, [ip], #4
 802600c:	d0ea      	beq.n	8025fe4 <strcpy+0x38>
 802600e:	4623      	mov	r3, r4
 8026010:	f80c 3b01 	strb.w	r3, [ip], #1
 8026014:	f013 0fff 	tst.w	r3, #255	; 0xff
 8026018:	ea4f 2333 	mov.w	r3, r3, ror #8
 802601c:	d1f8      	bne.n	8026010 <strcpy+0x64>
 802601e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8026022:	4770      	bx	lr
 8026024:	f011 0f01 	tst.w	r1, #1
 8026028:	d006      	beq.n	8026038 <strcpy+0x8c>
 802602a:	f811 2b01 	ldrb.w	r2, [r1], #1
 802602e:	f80c 2b01 	strb.w	r2, [ip], #1
 8026032:	2a00      	cmp	r2, #0
 8026034:	bf08      	it	eq
 8026036:	4770      	bxeq	lr
 8026038:	f011 0f02 	tst.w	r1, #2
 802603c:	d0bf      	beq.n	8025fbe <strcpy+0x12>
 802603e:	f831 2b02 	ldrh.w	r2, [r1], #2
 8026042:	f012 0fff 	tst.w	r2, #255	; 0xff
 8026046:	bf16      	itet	ne
 8026048:	f82c 2b02 	strhne.w	r2, [ip], #2
 802604c:	f88c 2000 	strbeq.w	r2, [ip]
 8026050:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 8026054:	d1b3      	bne.n	8025fbe <strcpy+0x12>
 8026056:	4770      	bx	lr
 8026058:	f811 2b01 	ldrb.w	r2, [r1], #1
 802605c:	f80c 2b01 	strb.w	r2, [ip], #1
 8026060:	2a00      	cmp	r2, #0
 8026062:	d1f9      	bne.n	8026058 <strcpy+0xac>
 8026064:	4770      	bx	lr
 8026066:	bf00      	nop

08026068 <iso_year_adjust>:
 8026068:	6943      	ldr	r3, [r0, #20]
 802606a:	079a      	lsls	r2, r3, #30
 802606c:	b410      	push	{r4}
 802606e:	d114      	bne.n	802609a <iso_year_adjust+0x32>
 8026070:	2b00      	cmp	r3, #0
 8026072:	f240 726c 	movw	r2, #1900	; 0x76c
 8026076:	bfa8      	it	ge
 8026078:	f06f 0263 	mvnge.w	r2, #99	; 0x63
 802607c:	f248 511f 	movw	r1, #34079	; 0x851f
 8026080:	18d2      	adds	r2, r2, r3
 8026082:	f2c5 11eb 	movt	r1, #20971	; 0x51eb
 8026086:	fb81 4102 	smull	r4, r1, r1, r2
 802608a:	17d4      	asrs	r4, r2, #31
 802608c:	ebc4 1161 	rsb	r1, r4, r1, asr #5
 8026090:	2464      	movs	r4, #100	; 0x64
 8026092:	fb04 2211 	mls	r2, r4, r1, r2
 8026096:	2a00      	cmp	r2, #0
 8026098:	d136      	bne.n	8026108 <iso_year_adjust+0xa0>
 802609a:	2b00      	cmp	r3, #0
 802609c:	f240 716c 	movw	r1, #1900	; 0x76c
 80260a0:	bfa8      	it	ge
 80260a2:	f06f 0163 	mvnge.w	r1, #99	; 0x63
 80260a6:	f248 521f 	movw	r2, #34079	; 0x851f
 80260aa:	18cb      	adds	r3, r1, r3
 80260ac:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
 80260b0:	fb82 1203 	smull	r1, r2, r2, r3
 80260b4:	17d9      	asrs	r1, r3, #31
 80260b6:	ebc1 12e2 	rsb	r2, r1, r2, asr #7
 80260ba:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80260be:	fb01 3312 	mls	r3, r1, r2, r3
 80260c2:	f1d3 0301 	rsbs	r3, r3, #1
 80260c6:	bf38      	it	cc
 80260c8:	2300      	movcc	r3, #0
 80260ca:	6981      	ldr	r1, [r0, #24]
 80260cc:	69c2      	ldr	r2, [r0, #28]
 80260ce:	0049      	lsls	r1, r1, #1
 80260d0:	eb01 1102 	add.w	r1, r1, r2, lsl #4
 80260d4:	185b      	adds	r3, r3, r1
 80260d6:	2b21      	cmp	r3, #33	; 0x21
 80260d8:	dc05      	bgt.n	80260e6 <iso_year_adjust+0x7e>
 80260da:	2b20      	cmp	r3, #32
 80260dc:	db26      	blt.n	802612c <iso_year_adjust+0xc4>
 80260de:	f04f 30ff 	mov.w	r0, #4294967295
 80260e2:	bc10      	pop	{r4}
 80260e4:	4770      	bx	lr
 80260e6:	f241 62c6 	movw	r2, #5830	; 0x16c6
 80260ea:	4293      	cmp	r3, r2
 80260ec:	dd0e      	ble.n	802610c <iso_year_adjust+0xa4>
 80260ee:	f241 62d5 	movw	r2, #5845	; 0x16d5
 80260f2:	4293      	cmp	r3, r2
 80260f4:	d018      	beq.n	8026128 <iso_year_adjust+0xc0>
 80260f6:	3202      	adds	r2, #2
 80260f8:	4293      	cmp	r3, r2
 80260fa:	d015      	beq.n	8026128 <iso_year_adjust+0xc0>
 80260fc:	f241 62d3 	movw	r2, #5843	; 0x16d3
 8026100:	4293      	cmp	r3, r2
 8026102:	d011      	beq.n	8026128 <iso_year_adjust+0xc0>
 8026104:	2000      	movs	r0, #0
 8026106:	e7ec      	b.n	80260e2 <iso_year_adjust+0x7a>
 8026108:	2301      	movs	r3, #1
 802610a:	e7de      	b.n	80260ca <iso_year_adjust+0x62>
 802610c:	f241 62c2 	movw	r2, #5826	; 0x16c2
 8026110:	4293      	cmp	r3, r2
 8026112:	da09      	bge.n	8026128 <iso_year_adjust+0xc0>
 8026114:	f241 62a2 	movw	r2, #5794	; 0x16a2
 8026118:	4293      	cmp	r3, r2
 802611a:	d005      	beq.n	8026128 <iso_year_adjust+0xc0>
 802611c:	dbf2      	blt.n	8026104 <iso_year_adjust+0x9c>
 802611e:	f5a3 53b4 	sub.w	r3, r3, #5760	; 0x1680
 8026122:	3b32      	subs	r3, #50	; 0x32
 8026124:	2b02      	cmp	r3, #2
 8026126:	d8ed      	bhi.n	8026104 <iso_year_adjust+0x9c>
 8026128:	2001      	movs	r0, #1
 802612a:	e7da      	b.n	80260e2 <iso_year_adjust+0x7a>
 802612c:	2b0d      	cmp	r3, #13
 802612e:	dd05      	ble.n	802613c <iso_year_adjust+0xd4>
 8026130:	2b10      	cmp	r3, #16
 8026132:	dbe7      	blt.n	8026104 <iso_year_adjust+0x9c>
 8026134:	2b11      	cmp	r3, #17
 8026136:	ddd2      	ble.n	80260de <iso_year_adjust+0x76>
 8026138:	3b1c      	subs	r3, #28
 802613a:	e001      	b.n	8026140 <iso_year_adjust+0xd8>
 802613c:	2b0a      	cmp	r3, #10
 802613e:	dace      	bge.n	80260de <iso_year_adjust+0x76>
 8026140:	2b01      	cmp	r3, #1
 8026142:	d9cc      	bls.n	80260de <iso_year_adjust+0x76>
 8026144:	2000      	movs	r0, #0
 8026146:	e7cc      	b.n	80260e2 <iso_year_adjust+0x7a>

08026148 <strftime>:
 8026148:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802614c:	b093      	sub	sp, #76	; 0x4c
 802614e:	4606      	mov	r6, r0
 8026150:	4688      	mov	r8, r1
 8026152:	4615      	mov	r5, r2
 8026154:	461f      	mov	r7, r3
 8026156:	f002 f919 	bl	802838c <__get_current_time_locale>
 802615a:	f648 0b89 	movw	fp, #34953	; 0x8889
 802615e:	2400      	movs	r4, #0
 8026160:	9006      	str	r0, [sp, #24]
 8026162:	f6c8 0b88 	movt	fp, #34952	; 0x8888
 8026166:	9602      	str	r6, [sp, #8]
 8026168:	782b      	ldrb	r3, [r5, #0]
 802616a:	b94b      	cbnz	r3, 8026180 <strftime+0x38>
 802616c:	9e02      	ldr	r6, [sp, #8]
 802616e:	f1b8 0f00 	cmp.w	r8, #0
 8026172:	d001      	beq.n	8026178 <strftime+0x30>
 8026174:	2300      	movs	r3, #0
 8026176:	5533      	strb	r3, [r6, r4]
 8026178:	4620      	mov	r0, r4
 802617a:	b013      	add	sp, #76	; 0x4c
 802617c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026180:	2b25      	cmp	r3, #37	; 0x25
 8026182:	d009      	beq.n	8026198 <strftime+0x50>
 8026184:	f108 32ff 	add.w	r2, r8, #4294967295
 8026188:	4294      	cmp	r4, r2
 802618a:	f080 8095 	bcs.w	80262b8 <strftime+0x170>
 802618e:	9e02      	ldr	r6, [sp, #8]
 8026190:	3501      	adds	r5, #1
 8026192:	5533      	strb	r3, [r6, r4]
 8026194:	3401      	adds	r4, #1
 8026196:	e7e7      	b.n	8026168 <strftime+0x20>
 8026198:	7869      	ldrb	r1, [r5, #1]
 802619a:	2930      	cmp	r1, #48	; 0x30
 802619c:	f000 808e 	beq.w	80262bc <strftime+0x174>
 80261a0:	292b      	cmp	r1, #43	; 0x2b
 80261a2:	f000 808b 	beq.w	80262bc <strftime+0x174>
 80261a6:	f1a1 0331 	sub.w	r3, r1, #49	; 0x31
 80261aa:	b2db      	uxtb	r3, r3
 80261ac:	3501      	adds	r5, #1
 80261ae:	2b08      	cmp	r3, #8
 80261b0:	f04f 0a00 	mov.w	sl, #0
 80261b4:	f240 808b 	bls.w	80262ce <strftime+0x186>
 80261b8:	2945      	cmp	r1, #69	; 0x45
 80261ba:	f04f 0900 	mov.w	r9, #0
 80261be:	f000 8091 	beq.w	80262e4 <strftime+0x19c>
 80261c2:	294f      	cmp	r1, #79	; 0x4f
 80261c4:	f000 808e 	beq.w	80262e4 <strftime+0x19c>
 80261c8:	f1a1 0325 	sub.w	r3, r1, #37	; 0x25
 80261cc:	2b55      	cmp	r3, #85	; 0x55
 80261ce:	d873      	bhi.n	80262b8 <strftime+0x170>
 80261d0:	e8df f013 	tbh	[pc, r3, lsl #1]
 80261d4:	0072009d 	.word	0x0072009d
 80261d8:	00720072 	.word	0x00720072
 80261dc:	00720072 	.word	0x00720072
 80261e0:	00720072 	.word	0x00720072
 80261e4:	00720072 	.word	0x00720072
 80261e8:	00720072 	.word	0x00720072
 80261ec:	00720072 	.word	0x00720072
 80261f0:	00720072 	.word	0x00720072
 80261f4:	00720072 	.word	0x00720072
 80261f8:	00720072 	.word	0x00720072
 80261fc:	00720072 	.word	0x00720072
 8026200:	00720072 	.word	0x00720072
 8026204:	00720072 	.word	0x00720072
 8026208:	00720072 	.word	0x00720072
 802620c:	00ce00ab 	.word	0x00ce00ab
 8026210:	02b302fc 	.word	0x02b302fc
 8026214:	02d90072 	.word	0x02d90072
 8026218:	0279020e 	.word	0x0279020e
 802621c:	0072028c 	.word	0x0072028c
 8026220:	00720072 	.word	0x00720072
 8026224:	007202b1 	.word	0x007202b1
 8026228:	01560072 	.word	0x01560072
 802622c:	018d0072 	.word	0x018d0072
 8026230:	01ab019e 	.word	0x01ab019e
 8026234:	01da01c0 	.word	0x01da01c0
 8026238:	01ef01e8 	.word	0x01ef01e8
 802623c:	012600eb 	.word	0x012600eb
 8026240:	00720072 	.word	0x00720072
 8026244:	00720072 	.word	0x00720072
 8026248:	00720072 	.word	0x00720072
 802624c:	03d603b6 	.word	0x03d603b6
 8026250:	036d0365 	.word	0x036d0365
 8026254:	0072036d 	.word	0x0072036d
 8026258:	03d60374 	.word	0x03d60374
 802625c:	03b20072 	.word	0x03b20072
 8026260:	028c0279 	.word	0x028c0279
 8026264:	04250445 	.word	0x04250445
 8026268:	01560072 	.word	0x01560072
 802626c:	04360072 	.word	0x04360072
 8026270:	040a0072 	.word	0x040a0072
 8026274:	0072008b 	.word	0x0072008b
 8026278:	043e0417 	.word	0x043e0417
 802627c:	03220056 	.word	0x03220056
 8026280:	697a      	ldr	r2, [r7, #20]
 8026282:	2a00      	cmp	r2, #0
 8026284:	f2c0 8499 	blt.w	8026bba <strftime+0xa72>
 8026288:	f248 531f 	movw	r3, #34079	; 0x851f
 802628c:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8026290:	17d1      	asrs	r1, r2, #31
 8026292:	fb83 a302 	smull	sl, r3, r3, r2
 8026296:	ebc1 1363 	rsb	r3, r1, r3, asr #5
 802629a:	2164      	movs	r1, #100	; 0x64
 802629c:	fb01 2313 	mls	r3, r1, r3, r2
 80262a0:	9e02      	ldr	r6, [sp, #8]
 80262a2:	1930      	adds	r0, r6, r4
 80262a4:	ebc4 0108 	rsb	r1, r4, r8
 80262a8:	4ab2      	ldr	r2, [pc, #712]	; (8026574 <strftime+0x42c>)
 80262aa:	f005 f9d1 	bl	802b650 <snprintf>
 80262ae:	2800      	cmp	r0, #0
 80262b0:	db02      	blt.n	80262b8 <strftime+0x170>
 80262b2:	1824      	adds	r4, r4, r0
 80262b4:	45a0      	cmp	r8, r4
 80262b6:	d824      	bhi.n	8026302 <strftime+0x1ba>
 80262b8:	2400      	movs	r4, #0
 80262ba:	e75d      	b.n	8026178 <strftime+0x30>
 80262bc:	468a      	mov	sl, r1
 80262be:	78a9      	ldrb	r1, [r5, #2]
 80262c0:	f1a1 0331 	sub.w	r3, r1, #49	; 0x31
 80262c4:	b2db      	uxtb	r3, r3
 80262c6:	3502      	adds	r5, #2
 80262c8:	2b08      	cmp	r3, #8
 80262ca:	f63f af75 	bhi.w	80261b8 <strftime+0x70>
 80262ce:	4628      	mov	r0, r5
 80262d0:	a911      	add	r1, sp, #68	; 0x44
 80262d2:	220a      	movs	r2, #10
 80262d4:	f000 fe3e 	bl	8026f54 <strtoul>
 80262d8:	9d11      	ldr	r5, [sp, #68]	; 0x44
 80262da:	7829      	ldrb	r1, [r5, #0]
 80262dc:	2945      	cmp	r1, #69	; 0x45
 80262de:	4681      	mov	r9, r0
 80262e0:	f47f af6f 	bne.w	80261c2 <strftime+0x7a>
 80262e4:	7869      	ldrb	r1, [r5, #1]
 80262e6:	3501      	adds	r5, #1
 80262e8:	e76e      	b.n	80261c8 <strftime+0x80>
 80262ea:	f108 33ff 	add.w	r3, r8, #4294967295
 80262ee:	429c      	cmp	r4, r3
 80262f0:	d2e2      	bcs.n	80262b8 <strftime+0x170>
 80262f2:	69bb      	ldr	r3, [r7, #24]
 80262f4:	2b00      	cmp	r3, #0
 80262f6:	f040 838a 	bne.w	8026a0e <strftime+0x8c6>
 80262fa:	9e02      	ldr	r6, [sp, #8]
 80262fc:	2337      	movs	r3, #55	; 0x37
 80262fe:	5533      	strb	r3, [r6, r4]
 8026300:	3401      	adds	r4, #1
 8026302:	782b      	ldrb	r3, [r5, #0]
 8026304:	2b00      	cmp	r3, #0
 8026306:	f43f af31 	beq.w	802616c <strftime+0x24>
 802630a:	3501      	adds	r5, #1
 802630c:	e72c      	b.n	8026168 <strftime+0x20>
 802630e:	f108 33ff 	add.w	r3, r8, #4294967295
 8026312:	429c      	cmp	r4, r3
 8026314:	d2d0      	bcs.n	80262b8 <strftime+0x170>
 8026316:	f8dd a008 	ldr.w	sl, [sp, #8]
 802631a:	2325      	movs	r3, #37	; 0x25
 802631c:	f80a 3004 	strb.w	r3, [sl, r4]
 8026320:	782b      	ldrb	r3, [r5, #0]
 8026322:	3401      	adds	r4, #1
 8026324:	2b00      	cmp	r3, #0
 8026326:	d1f0      	bne.n	802630a <strftime+0x1c2>
 8026328:	e720      	b.n	802616c <strftime+0x24>
 802632a:	69bb      	ldr	r3, [r7, #24]
 802632c:	f8dd a018 	ldr.w	sl, [sp, #24]
 8026330:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
 8026334:	f8d3 907c 	ldr.w	r9, [r3, #124]	; 0x7c
 8026338:	4648      	mov	r0, r9
 802633a:	f000 fd0f 	bl	8026d5c <strlen>
 802633e:	2800      	cmp	r0, #0
 8026340:	d0df      	beq.n	8026302 <strftime+0x1ba>
 8026342:	f108 31ff 	add.w	r1, r8, #4294967295
 8026346:	428c      	cmp	r4, r1
 8026348:	d2b6      	bcs.n	80262b8 <strftime+0x170>
 802634a:	2200      	movs	r2, #0
 802634c:	4613      	mov	r3, r2
 802634e:	9e02      	ldr	r6, [sp, #8]
 8026350:	e001      	b.n	8026356 <strftime+0x20e>
 8026352:	428c      	cmp	r4, r1
 8026354:	d2b0      	bcs.n	80262b8 <strftime+0x170>
 8026356:	f819 2002 	ldrb.w	r2, [r9, r2]
 802635a:	3301      	adds	r3, #1
 802635c:	5532      	strb	r2, [r6, r4]
 802635e:	3401      	adds	r4, #1
 8026360:	4283      	cmp	r3, r0
 8026362:	461a      	mov	r2, r3
 8026364:	d1f5      	bne.n	8026352 <strftime+0x20a>
 8026366:	782b      	ldrb	r3, [r5, #0]
 8026368:	9602      	str	r6, [sp, #8]
 802636a:	2b00      	cmp	r3, #0
 802636c:	d1cd      	bne.n	802630a <strftime+0x1c2>
 802636e:	e6fd      	b.n	802616c <strftime+0x24>
 8026370:	693b      	ldr	r3, [r7, #16]
 8026372:	9e06      	ldr	r6, [sp, #24]
 8026374:	330c      	adds	r3, #12
 8026376:	f856 9023 	ldr.w	r9, [r6, r3, lsl #2]
 802637a:	4648      	mov	r0, r9
 802637c:	f000 fcee 	bl	8026d5c <strlen>
 8026380:	2800      	cmp	r0, #0
 8026382:	d0be      	beq.n	8026302 <strftime+0x1ba>
 8026384:	f108 31ff 	add.w	r1, r8, #4294967295
 8026388:	428c      	cmp	r4, r1
 802638a:	d295      	bcs.n	80262b8 <strftime+0x170>
 802638c:	2200      	movs	r2, #0
 802638e:	4613      	mov	r3, r2
 8026390:	9e02      	ldr	r6, [sp, #8]
 8026392:	e001      	b.n	8026398 <strftime+0x250>
 8026394:	428c      	cmp	r4, r1
 8026396:	d28f      	bcs.n	80262b8 <strftime+0x170>
 8026398:	f819 2002 	ldrb.w	r2, [r9, r2]
 802639c:	3301      	adds	r3, #1
 802639e:	5532      	strb	r2, [r6, r4]
 80263a0:	3401      	adds	r4, #1
 80263a2:	4283      	cmp	r3, r0
 80263a4:	461a      	mov	r2, r3
 80263a6:	d1f5      	bne.n	8026394 <strftime+0x24c>
 80263a8:	e7dd      	b.n	8026366 <strftime+0x21e>
 80263aa:	697a      	ldr	r2, [r7, #20]
 80263ac:	f64f 0394 	movw	r3, #63636	; 0xf894
 80263b0:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80263b4:	f502 6cec 	add.w	ip, r2, #1888	; 0x760
 80263b8:	429a      	cmp	r2, r3
 80263ba:	f10c 0c0c 	add.w	ip, ip, #12
 80263be:	f280 839a 	bge.w	8026af6 <strftime+0x9ae>
 80263c2:	232d      	movs	r3, #45	; 0x2d
 80263c4:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 80263c8:	f1cc 0c00 	rsb	ip, ip, #0
 80263cc:	2301      	movs	r3, #1
 80263ce:	f10d 0025 	add.w	r0, sp, #37	; 0x25
 80263d2:	aa09      	add	r2, sp, #36	; 0x24
 80263d4:	f1b9 0f00 	cmp.w	r9, #0
 80263d8:	d002      	beq.n	80263e0 <strftime+0x298>
 80263da:	2b00      	cmp	r3, #0
 80263dc:	f040 839f 	bne.w	8026b1e <strftime+0x9d6>
 80263e0:	2325      	movs	r3, #37	; 0x25
 80263e2:	7003      	strb	r3, [r0, #0]
 80263e4:	f1ba 0f00 	cmp.w	sl, #0
 80263e8:	f040 837f 	bne.w	8026aea <strftime+0x9a2>
 80263ec:	3001      	adds	r0, #1
 80263ee:	4962      	ldr	r1, [pc, #392]	; (8026578 <strftime+0x430>)
 80263f0:	9205      	str	r2, [sp, #20]
 80263f2:	f8cd c010 	str.w	ip, [sp, #16]
 80263f6:	f7ff fdd9 	bl	8025fac <strcpy>
 80263fa:	f8dd a008 	ldr.w	sl, [sp, #8]
 80263fe:	f8dd c010 	ldr.w	ip, [sp, #16]
 8026402:	9a05      	ldr	r2, [sp, #20]
 8026404:	f8cd c000 	str.w	ip, [sp]
 8026408:	eb0a 0004 	add.w	r0, sl, r4
 802640c:	ebc4 0108 	rsb	r1, r4, r8
 8026410:	464b      	mov	r3, r9
 8026412:	f005 f91d 	bl	802b650 <snprintf>
 8026416:	2800      	cmp	r0, #0
 8026418:	f6bf af4b 	bge.w	80262b2 <strftime+0x16a>
 802641c:	2400      	movs	r4, #0
 802641e:	e6ab      	b.n	8026178 <strftime+0x30>
 8026420:	6a3b      	ldr	r3, [r7, #32]
 8026422:	2b00      	cmp	r3, #0
 8026424:	f6ff af71 	blt.w	802630a <strftime+0x1c2>
 8026428:	f001 ffce 	bl	80283c8 <__tz_lock>
 802642c:	6a3b      	ldr	r3, [r7, #32]
 802642e:	f8df 9154 	ldr.w	r9, [pc, #340]	; 8026584 <strftime+0x43c>
 8026432:	2b00      	cmp	r3, #0
 8026434:	bfd4      	ite	le
 8026436:	2300      	movle	r3, #0
 8026438:	2301      	movgt	r3, #1
 802643a:	f859 0023 	ldr.w	r0, [r9, r3, lsl #2]
 802643e:	f000 fc8d 	bl	8026d5c <strlen>
 8026442:	2800      	cmp	r0, #0
 8026444:	dd18      	ble.n	8026478 <strftime+0x330>
 8026446:	f108 31ff 	add.w	r1, r8, #4294967295
 802644a:	428c      	cmp	r4, r1
 802644c:	f080 8397 	bcs.w	8026b7e <strftime+0xa36>
 8026450:	2300      	movs	r3, #0
 8026452:	9e02      	ldr	r6, [sp, #8]
 8026454:	e002      	b.n	802645c <strftime+0x314>
 8026456:	428c      	cmp	r4, r1
 8026458:	f080 8391 	bcs.w	8026b7e <strftime+0xa36>
 802645c:	6a3a      	ldr	r2, [r7, #32]
 802645e:	2a00      	cmp	r2, #0
 8026460:	bfd4      	ite	le
 8026462:	2200      	movle	r2, #0
 8026464:	2201      	movgt	r2, #1
 8026466:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 802646a:	5cd2      	ldrb	r2, [r2, r3]
 802646c:	3301      	adds	r3, #1
 802646e:	5532      	strb	r2, [r6, r4]
 8026470:	3401      	adds	r4, #1
 8026472:	4298      	cmp	r0, r3
 8026474:	d1ef      	bne.n	8026456 <strftime+0x30e>
 8026476:	9602      	str	r6, [sp, #8]
 8026478:	f001 ffa8 	bl	80283cc <__tz_unlock>
 802647c:	782b      	ldrb	r3, [r5, #0]
 802647e:	e741      	b.n	8026304 <strftime+0x1bc>
 8026480:	68bb      	ldr	r3, [r7, #8]
 8026482:	f8dd c018 	ldr.w	ip, [sp, #24]
 8026486:	2b0b      	cmp	r3, #11
 8026488:	bfcc      	ite	gt
 802648a:	23a4      	movgt	r3, #164	; 0xa4
 802648c:	23a0      	movle	r3, #160	; 0xa0
 802648e:	4463      	add	r3, ip
 8026490:	f8d3 9004 	ldr.w	r9, [r3, #4]
 8026494:	4648      	mov	r0, r9
 8026496:	f000 fc61 	bl	8026d5c <strlen>
 802649a:	2800      	cmp	r0, #0
 802649c:	f43f af31 	beq.w	8026302 <strftime+0x1ba>
 80264a0:	f108 3cff 	add.w	ip, r8, #4294967295
 80264a4:	4564      	cmp	r4, ip
 80264a6:	f4bf af07 	bcs.w	80262b8 <strftime+0x170>
 80264aa:	2200      	movs	r2, #0
 80264ac:	4613      	mov	r3, r2
 80264ae:	9e02      	ldr	r6, [sp, #8]
 80264b0:	e009      	b.n	80264c6 <strftime+0x37e>
 80264b2:	3301      	adds	r3, #1
 80264b4:	5532      	strb	r2, [r6, r4]
 80264b6:	3401      	adds	r4, #1
 80264b8:	4283      	cmp	r3, r0
 80264ba:	461a      	mov	r2, r3
 80264bc:	f43f af53 	beq.w	8026366 <strftime+0x21e>
 80264c0:	4564      	cmp	r4, ip
 80264c2:	f4bf aef9 	bcs.w	80262b8 <strftime+0x170>
 80264c6:	7829      	ldrb	r1, [r5, #0]
 80264c8:	f819 2002 	ldrb.w	r2, [r9, r2]
 80264cc:	2950      	cmp	r1, #80	; 0x50
 80264ce:	d1f0      	bne.n	80264b2 <strftime+0x36a>
 80264d0:	f640 1a2c 	movw	sl, #2348	; 0x92c
 80264d4:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80264d8:	f8da 1000 	ldr.w	r1, [sl]
 80264dc:	1889      	adds	r1, r1, r2
 80264de:	7849      	ldrb	r1, [r1, #1]
 80264e0:	f001 0103 	and.w	r1, r1, #3
 80264e4:	2901      	cmp	r1, #1
 80264e6:	bf08      	it	eq
 80264e8:	3220      	addeq	r2, #32
 80264ea:	b2d2      	uxtb	r2, r2
 80264ec:	e7e1      	b.n	80264b2 <strftime+0x36a>
 80264ee:	6879      	ldr	r1, [r7, #4]
 80264f0:	f8dd c008 	ldr.w	ip, [sp, #8]
 80264f4:	68bb      	ldr	r3, [r7, #8]
 80264f6:	4a21      	ldr	r2, [pc, #132]	; (802657c <strftime+0x434>)
 80264f8:	9100      	str	r1, [sp, #0]
 80264fa:	eb0c 0004 	add.w	r0, ip, r4
 80264fe:	ebc4 0108 	rsb	r1, r4, r8
 8026502:	f005 f8a5 	bl	802b650 <snprintf>
 8026506:	2800      	cmp	r0, #0
 8026508:	f6bf aed3 	bge.w	80262b2 <strftime+0x16a>
 802650c:	2400      	movs	r4, #0
 802650e:	e633      	b.n	8026178 <strftime+0x30>
 8026510:	683b      	ldr	r3, [r7, #0]
 8026512:	4a18      	ldr	r2, [pc, #96]	; (8026574 <strftime+0x42c>)
 8026514:	9e02      	ldr	r6, [sp, #8]
 8026516:	ebc4 0108 	rsb	r1, r4, r8
 802651a:	1930      	adds	r0, r6, r4
 802651c:	f005 f898 	bl	802b650 <snprintf>
 8026520:	2800      	cmp	r0, #0
 8026522:	f6bf aec6 	bge.w	80262b2 <strftime+0x16a>
 8026526:	2400      	movs	r4, #0
 8026528:	e626      	b.n	8026178 <strftime+0x30>
 802652a:	6879      	ldr	r1, [r7, #4]
 802652c:	f8dd c008 	ldr.w	ip, [sp, #8]
 8026530:	f8d7 e000 	ldr.w	lr, [r7]
 8026534:	68bb      	ldr	r3, [r7, #8]
 8026536:	4a12      	ldr	r2, [pc, #72]	; (8026580 <strftime+0x438>)
 8026538:	9100      	str	r1, [sp, #0]
 802653a:	eb0c 0004 	add.w	r0, ip, r4
 802653e:	ebc4 0108 	rsb	r1, r4, r8
 8026542:	f8cd e004 	str.w	lr, [sp, #4]
 8026546:	f005 f883 	bl	802b650 <snprintf>
 802654a:	2800      	cmp	r0, #0
 802654c:	f6bf aeb1 	bge.w	80262b2 <strftime+0x16a>
 8026550:	2400      	movs	r4, #0
 8026552:	e611      	b.n	8026178 <strftime+0x30>
 8026554:	69f9      	ldr	r1, [r7, #28]
 8026556:	69b8      	ldr	r0, [r7, #24]
 8026558:	3107      	adds	r1, #7
 802655a:	f242 4393 	movw	r3, #9363	; 0x2493
 802655e:	1a09      	subs	r1, r1, r0
 8026560:	f2c9 2349 	movt	r3, #37449	; 0x9249
 8026564:	fb83 c301 	smull	ip, r3, r3, r1
 8026568:	185b      	adds	r3, r3, r1
 802656a:	17c9      	asrs	r1, r1, #31
 802656c:	4a01      	ldr	r2, [pc, #4]	; (8026574 <strftime+0x42c>)
 802656e:	ebc1 03a3 	rsb	r3, r1, r3, asr #2
 8026572:	e7cf      	b.n	8026514 <strftime+0x3cc>
 8026574:	08032d10 	.word	0x08032d10
 8026578:	08032d38 	.word	0x08032d38
 802657c:	08032d44 	.word	0x08032d44
 8026580:	08032d50 	.word	0x08032d50
 8026584:	20000924 	.word	0x20000924
 8026588:	4638      	mov	r0, r7
 802658a:	f7ff fd6d 	bl	8026068 <iso_year_adjust>
 802658e:	69bb      	ldr	r3, [r7, #24]
 8026590:	2b00      	cmp	r3, #0
 8026592:	f000 8287 	beq.w	8026aa4 <strftime+0x95c>
 8026596:	3b01      	subs	r3, #1
 8026598:	2800      	cmp	r0, #0
 802659a:	69fa      	ldr	r2, [r7, #28]
 802659c:	f340 82d4 	ble.w	8026b48 <strftime+0xa00>
 80265a0:	2301      	movs	r3, #1
 80265a2:	e67d      	b.n	80262a0 <strftime+0x158>
 80265a4:	69b8      	ldr	r0, [r7, #24]
 80265a6:	2800      	cmp	r0, #0
 80265a8:	f000 829c 	beq.w	8026ae4 <strftime+0x99c>
 80265ac:	3801      	subs	r0, #1
 80265ae:	69f9      	ldr	r1, [r7, #28]
 80265b0:	e7d2      	b.n	8026558 <strftime+0x410>
 80265b2:	f8dd a018 	ldr.w	sl, [sp, #24]
 80265b6:	f8da 9098 	ldr.w	r9, [sl, #152]	; 0x98
 80265ba:	4648      	mov	r0, r9
 80265bc:	f000 fbce 	bl	8026d5c <strlen>
 80265c0:	f899 3000 	ldrb.w	r3, [r9]
 80265c4:	2b00      	cmp	r3, #0
 80265c6:	f43f ae9c 	beq.w	8026302 <strftime+0x1ba>
 80265ca:	f8dd c008 	ldr.w	ip, [sp, #8]
 80265ce:	ebc4 0108 	rsb	r1, r4, r8
 80265d2:	eb0c 0004 	add.w	r0, ip, r4
 80265d6:	464a      	mov	r2, r9
 80265d8:	463b      	mov	r3, r7
 80265da:	f7ff fdb5 	bl	8026148 <strftime>
 80265de:	2800      	cmp	r0, #0
 80265e0:	f77f ae6a 	ble.w	80262b8 <strftime+0x170>
 80265e4:	782b      	ldrb	r3, [r5, #0]
 80265e6:	1824      	adds	r4, r4, r0
 80265e8:	2b00      	cmp	r3, #0
 80265ea:	f47f ae8e 	bne.w	802630a <strftime+0x1c2>
 80265ee:	e5bd      	b.n	802616c <strftime+0x24>
 80265f0:	697a      	ldr	r2, [r7, #20]
 80265f2:	f64f 0394 	movw	r3, #63636	; 0xf894
 80265f6:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80265fa:	429a      	cmp	r2, r3
 80265fc:	bfac      	ite	ge
 80265fe:	2300      	movge	r3, #0
 8026600:	2301      	movlt	r3, #1
 8026602:	4638      	mov	r0, r7
 8026604:	9205      	str	r2, [sp, #20]
 8026606:	9303      	str	r3, [sp, #12]
 8026608:	f7ff fd2e 	bl	8026068 <iso_year_adjust>
 802660c:	9a05      	ldr	r2, [sp, #20]
 802660e:	9b03      	ldr	r3, [sp, #12]
 8026610:	2a00      	cmp	r2, #0
 8026612:	4601      	mov	r1, r0
 8026614:	f2c0 82e4 	blt.w	8026be0 <strftime+0xa98>
 8026618:	f248 501f 	movw	r0, #34079	; 0x851f
 802661c:	f2c5 10eb 	movt	r0, #20971	; 0x51eb
 8026620:	fb80 ec02 	smull	lr, ip, r0, r2
 8026624:	17d6      	asrs	r6, r2, #31
 8026626:	ebc6 1c6c 	rsb	ip, r6, ip, asr #5
 802662a:	f10c 0c13 	add.w	ip, ip, #19
 802662e:	f248 5e1f 	movw	lr, #34079	; 0x851f
 8026632:	f2c5 1eeb 	movt	lr, #20971	; 0x51eb
 8026636:	fb8e 0e02 	smull	r0, lr, lr, r2
 802663a:	ebc6 1e6e 	rsb	lr, r6, lr, asr #5
 802663e:	2064      	movs	r0, #100	; 0x64
 8026640:	fb00 2e1e 	mls	lr, r0, lr, r2
 8026644:	2900      	cmp	r1, #0
 8026646:	f2c0 828f 	blt.w	8026b68 <strftime+0xa20>
 802664a:	d003      	beq.n	8026654 <strftime+0x50c>
 802664c:	b113      	cbz	r3, 8026654 <strftime+0x50c>
 802664e:	f04f 31ff 	mov.w	r1, #4294967295
 8026652:	2301      	movs	r3, #1
 8026654:	4471      	add	r1, lr
 8026656:	1c48      	adds	r0, r1, #1
 8026658:	f000 8268 	beq.w	8026b2c <strftime+0x9e4>
 802665c:	2964      	cmp	r1, #100	; 0x64
 802665e:	bf04      	itt	eq
 8026660:	f10c 0c01 	addeq.w	ip, ip, #1
 8026664:	2100      	moveq	r1, #0
 8026666:	2264      	movs	r2, #100	; 0x64
 8026668:	fb02 120c 	mla	r2, r2, ip, r1
 802666c:	9207      	str	r2, [sp, #28]
 802666e:	2b00      	cmp	r3, #0
 8026670:	f000 8248 	beq.w	8026b04 <strftime+0x9bc>
 8026674:	232d      	movs	r3, #45	; 0x2d
 8026676:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 802667a:	f10d 0025 	add.w	r0, sp, #37	; 0x25
 802667e:	2301      	movs	r3, #1
 8026680:	aa09      	add	r2, sp, #36	; 0x24
 8026682:	f1b9 0f00 	cmp.w	r9, #0
 8026686:	d002      	beq.n	802668e <strftime+0x546>
 8026688:	2b00      	cmp	r3, #0
 802668a:	f040 8245 	bne.w	8026b18 <strftime+0x9d0>
 802668e:	2325      	movs	r3, #37	; 0x25
 8026690:	7003      	strb	r3, [r0, #0]
 8026692:	f1ba 0f00 	cmp.w	sl, #0
 8026696:	f040 823b 	bne.w	8026b10 <strftime+0x9c8>
 802669a:	3001      	adds	r0, #1
 802669c:	49c2      	ldr	r1, [pc, #776]	; (80269a8 <strftime+0x860>)
 802669e:	9205      	str	r2, [sp, #20]
 80266a0:	f7ff fc84 	bl	8025fac <strcpy>
 80266a4:	f8dd a008 	ldr.w	sl, [sp, #8]
 80266a8:	9e07      	ldr	r6, [sp, #28]
 80266aa:	9a05      	ldr	r2, [sp, #20]
 80266ac:	9600      	str	r6, [sp, #0]
 80266ae:	eb0a 0004 	add.w	r0, sl, r4
 80266b2:	ebc4 0108 	rsb	r1, r4, r8
 80266b6:	464b      	mov	r3, r9
 80266b8:	f004 ffca 	bl	802b650 <snprintf>
 80266bc:	2800      	cmp	r0, #0
 80266be:	f6bf adf8 	bge.w	80262b2 <strftime+0x16a>
 80266c2:	2400      	movs	r4, #0
 80266c4:	e558      	b.n	8026178 <strftime+0x30>
 80266c6:	4ab9      	ldr	r2, [pc, #740]	; (80269ac <strftime+0x864>)
 80266c8:	48b9      	ldr	r0, [pc, #740]	; (80269b0 <strftime+0x868>)
 80266ca:	68bb      	ldr	r3, [r7, #8]
 80266cc:	296b      	cmp	r1, #107	; 0x6b
 80266ce:	bf08      	it	eq
 80266d0:	4602      	moveq	r2, r0
 80266d2:	f8dd a008 	ldr.w	sl, [sp, #8]
 80266d6:	ebc4 0108 	rsb	r1, r4, r8
 80266da:	eb0a 0004 	add.w	r0, sl, r4
 80266de:	f004 ffb7 	bl	802b650 <snprintf>
 80266e2:	2800      	cmp	r0, #0
 80266e4:	f6bf ade5 	bge.w	80262b2 <strftime+0x16a>
 80266e8:	2400      	movs	r4, #0
 80266ea:	e545      	b.n	8026178 <strftime+0x30>
 80266ec:	68ba      	ldr	r2, [r7, #8]
 80266ee:	2a00      	cmp	r2, #0
 80266f0:	f000 81ff 	beq.w	8026af2 <strftime+0x9aa>
 80266f4:	2a0c      	cmp	r2, #12
 80266f6:	f000 8253 	beq.w	8026ba0 <strftime+0xa58>
 80266fa:	f64a 23ab 	movw	r3, #43691	; 0xaaab
 80266fe:	f6c2 23aa 	movt	r3, #10922	; 0x2aaa
 8026702:	fb83 c302 	smull	ip, r3, r3, r2
 8026706:	17d0      	asrs	r0, r2, #31
 8026708:	ebc0 0363 	rsb	r3, r0, r3, asr #1
 802670c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8026710:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
 8026714:	9e02      	ldr	r6, [sp, #8]
 8026716:	f8df e294 	ldr.w	lr, [pc, #660]	; 80269ac <strftime+0x864>
 802671a:	4aa5      	ldr	r2, [pc, #660]	; (80269b0 <strftime+0x868>)
 802671c:	1930      	adds	r0, r6, r4
 802671e:	2949      	cmp	r1, #73	; 0x49
 8026720:	bf08      	it	eq
 8026722:	4672      	moveq	r2, lr
 8026724:	ebc4 0108 	rsb	r1, r4, r8
 8026728:	f004 ff92 	bl	802b650 <snprintf>
 802672c:	2800      	cmp	r0, #0
 802672e:	f6bf adc0 	bge.w	80262b2 <strftime+0x16a>
 8026732:	2400      	movs	r4, #0
 8026734:	e520      	b.n	8026178 <strftime+0x30>
 8026736:	687b      	ldr	r3, [r7, #4]
 8026738:	e6eb      	b.n	8026512 <strftime+0x3ca>
 802673a:	693b      	ldr	r3, [r7, #16]
 802673c:	697a      	ldr	r2, [r7, #20]
 802673e:	f8dd c008 	ldr.w	ip, [sp, #8]
 8026742:	f8d7 a00c 	ldr.w	sl, [r7, #12]
 8026746:	3301      	adds	r3, #1
 8026748:	2a00      	cmp	r2, #0
 802674a:	eb0c 0904 	add.w	r9, ip, r4
 802674e:	ebc4 0108 	rsb	r1, r4, r8
 8026752:	f2c0 8283 	blt.w	8026c5c <strftime+0xb14>
 8026756:	f248 501f 	movw	r0, #34079	; 0x851f
 802675a:	f2c5 10eb 	movt	r0, #20971	; 0x51eb
 802675e:	fb80 e002 	smull	lr, r0, r0, r2
 8026762:	ea4f 7ee2 	mov.w	lr, r2, asr #31
 8026766:	ebce 1e60 	rsb	lr, lr, r0, asr #5
 802676a:	2064      	movs	r0, #100	; 0x64
 802676c:	fb00 2e1e 	mls	lr, r0, lr, r2
 8026770:	4648      	mov	r0, r9
 8026772:	4a90      	ldr	r2, [pc, #576]	; (80269b4 <strftime+0x86c>)
 8026774:	e88d 4400 	stmia.w	sp, {sl, lr}
 8026778:	f004 ff6a 	bl	802b650 <snprintf>
 802677c:	2800      	cmp	r0, #0
 802677e:	f6bf ad98 	bge.w	80262b2 <strftime+0x16a>
 8026782:	2400      	movs	r4, #0
 8026784:	e4f8      	b.n	8026178 <strftime+0x30>
 8026786:	2325      	movs	r3, #37	; 0x25
 8026788:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 802678c:	f1ba 0f00 	cmp.w	sl, #0
 8026790:	f000 8176 	beq.w	8026a80 <strftime+0x938>
 8026794:	f1b9 0f05 	cmp.w	r9, #5
 8026798:	f88d a025 	strb.w	sl, [sp, #37]	; 0x25
 802679c:	f200 82ca 	bhi.w	8026d34 <strftime+0xbec>
 80267a0:	f10d 0026 	add.w	r0, sp, #38	; 0x26
 80267a4:	aa09      	add	r2, sp, #36	; 0x24
 80267a6:	4984      	ldr	r1, [pc, #528]	; (80269b8 <strftime+0x870>)
 80267a8:	9205      	str	r2, [sp, #20]
 80267aa:	f7ff fbff 	bl	8025fac <strcpy>
 80267ae:	f8dd c008 	ldr.w	ip, [sp, #8]
 80267b2:	9a05      	ldr	r2, [sp, #20]
 80267b4:	eb0c 0004 	add.w	r0, ip, r4
 80267b8:	ebc4 0108 	rsb	r1, r4, r8
 80267bc:	463b      	mov	r3, r7
 80267be:	f7ff fcc3 	bl	8026148 <strftime>
 80267c2:	2800      	cmp	r0, #0
 80267c4:	f73f af0e 	bgt.w	80265e4 <strftime+0x49c>
 80267c8:	2400      	movs	r4, #0
 80267ca:	e4d5      	b.n	8026178 <strftime+0x30>
 80267cc:	697b      	ldr	r3, [r7, #20]
 80267ce:	f64f 0294 	movw	r2, #63636	; 0xf894
 80267d2:	f6cf 72ff 	movt	r2, #65535	; 0xffff
 80267d6:	4293      	cmp	r3, r2
 80267d8:	bfac      	ite	ge
 80267da:	2200      	movge	r2, #0
 80267dc:	2201      	movlt	r2, #1
 80267de:	2b00      	cmp	r3, #0
 80267e0:	f2c0 8253 	blt.w	8026c8a <strftime+0xb42>
 80267e4:	f248 511f 	movw	r1, #34079	; 0x851f
 80267e8:	f2c5 11eb 	movt	r1, #20971	; 0x51eb
 80267ec:	fb81 e103 	smull	lr, r1, r1, r3
 80267f0:	17db      	asrs	r3, r3, #31
 80267f2:	ebc3 1161 	rsb	r1, r3, r1, asr #5
 80267f6:	3113      	adds	r1, #19
 80267f8:	f1ba 0f00 	cmp.w	sl, #0
 80267fc:	f000 8154 	beq.w	8026aa8 <strftime+0x960>
 8026800:	2963      	cmp	r1, #99	; 0x63
 8026802:	f340 818f 	ble.w	8026b24 <strftime+0x9dc>
 8026806:	4b6d      	ldr	r3, [pc, #436]	; (80269bc <strftime+0x874>)
 8026808:	486d      	ldr	r0, [pc, #436]	; (80269c0 <strftime+0x878>)
 802680a:	f8df c1c0 	ldr.w	ip, [pc, #448]	; 80269cc <strftime+0x884>
 802680e:	f1ba 0f2b 	cmp.w	sl, #43	; 0x2b
 8026812:	bf08      	it	eq
 8026814:	4603      	moveq	r3, r0
 8026816:	e14a      	b.n	8026aae <strftime+0x966>
 8026818:	6a3b      	ldr	r3, [r7, #32]
 802681a:	2b00      	cmp	r3, #0
 802681c:	f6ff ad75 	blt.w	802630a <strftime+0x1c2>
 8026820:	f004 f8ec 	bl	802a9fc <__gettzinfo>
 8026824:	4681      	mov	r9, r0
 8026826:	f001 fdcf 	bl	80283c8 <__tz_lock>
 802682a:	6a3b      	ldr	r3, [r7, #32]
 802682c:	f8dd c008 	ldr.w	ip, [sp, #8]
 8026830:	2b00      	cmp	r3, #0
 8026832:	bfcc      	ite	gt
 8026834:	231c      	movgt	r3, #28
 8026836:	2300      	movle	r3, #0
 8026838:	444b      	add	r3, r9
 802683a:	eb0c 0904 	add.w	r9, ip, r4
 802683e:	6a1b      	ldr	r3, [r3, #32]
 8026840:	f1c3 0a00 	rsb	sl, r3, #0
 8026844:	f001 fdc2 	bl	80283cc <__tz_unlock>
 8026848:	fb8b e00a 	smull	lr, r0, fp, sl
 802684c:	ea4f 73ea 	mov.w	r3, sl, asr #31
 8026850:	4450      	add	r0, sl
 8026852:	ebc3 1060 	rsb	r0, r3, r0, asr #5
 8026856:	9303      	str	r3, [sp, #12]
 8026858:	f004 f8d6 	bl	802aa08 <labs>
 802685c:	f24b 32c5 	movw	r2, #46021	; 0xb3c5
 8026860:	fb8b 1e00 	smull	r1, lr, fp, r0
 8026864:	4486      	add	lr, r0
 8026866:	17c1      	asrs	r1, r0, #31
 8026868:	f2c9 12a2 	movt	r2, #37282	; 0x91a2
 802686c:	fb82 620a 	smull	r6, r2, r2, sl
 8026870:	ebc1 1e6e 	rsb	lr, r1, lr, asr #5
 8026874:	9b03      	ldr	r3, [sp, #12]
 8026876:	4492      	add	sl, r2
 8026878:	ebce 1e0e 	rsb	lr, lr, lr, lsl #4
 802687c:	eba0 0e8e 	sub.w	lr, r0, lr, lsl #2
 8026880:	ebc3 23ea 	rsb	r3, r3, sl, asr #11
 8026884:	ebc4 0108 	rsb	r1, r4, r8
 8026888:	4648      	mov	r0, r9
 802688a:	4a4e      	ldr	r2, [pc, #312]	; (80269c4 <strftime+0x87c>)
 802688c:	f8cd e000 	str.w	lr, [sp]
 8026890:	f004 fede 	bl	802b650 <snprintf>
 8026894:	2800      	cmp	r0, #0
 8026896:	f6bf ad0c 	bge.w	80262b2 <strftime+0x16a>
 802689a:	2400      	movs	r4, #0
 802689c:	e46c      	b.n	8026178 <strftime+0x30>
 802689e:	f8dd a018 	ldr.w	sl, [sp, #24]
 80268a2:	f8da 90a0 	ldr.w	r9, [sl, #160]	; 0xa0
 80268a6:	4648      	mov	r0, r9
 80268a8:	f000 fa58 	bl	8026d5c <strlen>
 80268ac:	e688      	b.n	80265c0 <strftime+0x478>
 80268ae:	4a40      	ldr	r2, [pc, #256]	; (80269b0 <strftime+0x868>)
 80268b0:	483e      	ldr	r0, [pc, #248]	; (80269ac <strftime+0x864>)
 80268b2:	68fb      	ldr	r3, [r7, #12]
 80268b4:	2964      	cmp	r1, #100	; 0x64
 80268b6:	bf08      	it	eq
 80268b8:	4602      	moveq	r2, r0
 80268ba:	e70a      	b.n	80266d2 <strftime+0x58a>
 80268bc:	4638      	mov	r0, r7
 80268be:	f7ff fbd3 	bl	8026068 <iso_year_adjust>
 80268c2:	697b      	ldr	r3, [r7, #20]
 80268c4:	2b00      	cmp	r3, #0
 80268c6:	4681      	mov	r9, r0
 80268c8:	f2c0 81b6 	blt.w	8026c38 <strftime+0xaf0>
 80268cc:	f248 521f 	movw	r2, #34079	; 0x851f
 80268d0:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
 80268d4:	17d9      	asrs	r1, r3, #31
 80268d6:	fb82 e203 	smull	lr, r2, r2, r3
 80268da:	ebc1 1262 	rsb	r2, r1, r2, asr #5
 80268de:	2164      	movs	r1, #100	; 0x64
 80268e0:	fb01 3212 	mls	r2, r1, r2, r3
 80268e4:	f1b9 0f00 	cmp.w	r9, #0
 80268e8:	f2c0 8124 	blt.w	8026b34 <strftime+0x9ec>
 80268ec:	d008      	beq.n	8026900 <strftime+0x7b8>
 80268ee:	f64f 0394 	movw	r3, #63636	; 0xf894
 80268f2:	6979      	ldr	r1, [r7, #20]
 80268f4:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80268f8:	4299      	cmp	r1, r3
 80268fa:	bfb8      	it	lt
 80268fc:	f04f 39ff 	movlt.w	r9, #4294967295
 8026900:	f248 511f 	movw	r1, #34079	; 0x851f
 8026904:	4491      	add	r9, r2
 8026906:	f2c5 11eb 	movt	r1, #20971	; 0x51eb
 802690a:	fb81 3209 	smull	r3, r2, r1, r9
 802690e:	ea4f 73e9 	mov.w	r3, r9, asr #31
 8026912:	2064      	movs	r0, #100	; 0x64
 8026914:	ebc3 1262 	rsb	r2, r3, r2, asr #5
 8026918:	fb00 9912 	mls	r9, r0, r2, r9
 802691c:	eb09 0200 	add.w	r2, r9, r0
 8026920:	fb81 6102 	smull	r6, r1, r1, r2
 8026924:	17d3      	asrs	r3, r2, #31
 8026926:	f8dd a008 	ldr.w	sl, [sp, #8]
 802692a:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 802692e:	fb00 2313 	mls	r3, r0, r3, r2
 8026932:	eb0a 0004 	add.w	r0, sl, r4
 8026936:	e4b5      	b.n	80262a4 <strftime+0x15c>
 8026938:	69fb      	ldr	r3, [r7, #28]
 802693a:	4a23      	ldr	r2, [pc, #140]	; (80269c8 <strftime+0x880>)
 802693c:	3301      	adds	r3, #1
 802693e:	e6c8      	b.n	80266d2 <strftime+0x58a>
 8026940:	69bb      	ldr	r3, [r7, #24]
 8026942:	9e06      	ldr	r6, [sp, #24]
 8026944:	3318      	adds	r3, #24
 8026946:	f856 9023 	ldr.w	r9, [r6, r3, lsl #2]
 802694a:	4648      	mov	r0, r9
 802694c:	f000 fa06 	bl	8026d5c <strlen>
 8026950:	2800      	cmp	r0, #0
 8026952:	f43f acd6 	beq.w	8026302 <strftime+0x1ba>
 8026956:	f108 31ff 	add.w	r1, r8, #4294967295
 802695a:	428c      	cmp	r4, r1
 802695c:	f4bf acac 	bcs.w	80262b8 <strftime+0x170>
 8026960:	2200      	movs	r2, #0
 8026962:	4613      	mov	r3, r2
 8026964:	9e02      	ldr	r6, [sp, #8]
 8026966:	e002      	b.n	802696e <strftime+0x826>
 8026968:	428c      	cmp	r4, r1
 802696a:	f4bf aca5 	bcs.w	80262b8 <strftime+0x170>
 802696e:	f819 2002 	ldrb.w	r2, [r9, r2]
 8026972:	3301      	adds	r3, #1
 8026974:	5532      	strb	r2, [r6, r4]
 8026976:	3401      	adds	r4, #1
 8026978:	4283      	cmp	r3, r0
 802697a:	461a      	mov	r2, r3
 802697c:	d1f4      	bne.n	8026968 <strftime+0x820>
 802697e:	e4f2      	b.n	8026366 <strftime+0x21e>
 8026980:	693b      	ldr	r3, [r7, #16]
 8026982:	f8dd c018 	ldr.w	ip, [sp, #24]
 8026986:	f85c 9023 	ldr.w	r9, [ip, r3, lsl #2]
 802698a:	4648      	mov	r0, r9
 802698c:	f000 f9e6 	bl	8026d5c <strlen>
 8026990:	2800      	cmp	r0, #0
 8026992:	f43f acb6 	beq.w	8026302 <strftime+0x1ba>
 8026996:	f108 31ff 	add.w	r1, r8, #4294967295
 802699a:	428c      	cmp	r4, r1
 802699c:	f4bf ac8c 	bcs.w	80262b8 <strftime+0x170>
 80269a0:	2200      	movs	r2, #0
 80269a2:	4613      	mov	r3, r2
 80269a4:	9e02      	ldr	r6, [sp, #8]
 80269a6:	e016      	b.n	80269d6 <strftime+0x88e>
 80269a8:	08032d38 	.word	0x08032d38
 80269ac:	08032d10 	.word	0x08032d10
 80269b0:	08032d18 	.word	0x08032d18
 80269b4:	08032d1c 	.word	0x08032d1c
 80269b8:	08032d30 	.word	0x08032d30
 80269bc:	08032bf4 	.word	0x08032bf4
 80269c0:	08032d08 	.word	0x08032d08
 80269c4:	08032d60 	.word	0x08032d60
 80269c8:	08032d3c 	.word	0x08032d3c
 80269cc:	08032d00 	.word	0x08032d00
 80269d0:	428c      	cmp	r4, r1
 80269d2:	f4bf ac71 	bcs.w	80262b8 <strftime+0x170>
 80269d6:	f819 2002 	ldrb.w	r2, [r9, r2]
 80269da:	3301      	adds	r3, #1
 80269dc:	5532      	strb	r2, [r6, r4]
 80269de:	3401      	adds	r4, #1
 80269e0:	4283      	cmp	r3, r0
 80269e2:	461a      	mov	r2, r3
 80269e4:	d1f4      	bne.n	80269d0 <strftime+0x888>
 80269e6:	e4be      	b.n	8026366 <strftime+0x21e>
 80269e8:	f108 33ff 	add.w	r3, r8, #4294967295
 80269ec:	429c      	cmp	r4, r3
 80269ee:	f4bf ac63 	bcs.w	80262b8 <strftime+0x170>
 80269f2:	f8dd a008 	ldr.w	sl, [sp, #8]
 80269f6:	2309      	movs	r3, #9
 80269f8:	f80a 3004 	strb.w	r3, [sl, r4]
 80269fc:	3401      	adds	r4, #1
 80269fe:	782b      	ldrb	r3, [r5, #0]
 8026a00:	e480      	b.n	8026304 <strftime+0x1bc>
 8026a02:	f108 33ff 	add.w	r3, r8, #4294967295
 8026a06:	429c      	cmp	r4, r3
 8026a08:	f4bf ac56 	bcs.w	80262b8 <strftime+0x170>
 8026a0c:	69bb      	ldr	r3, [r7, #24]
 8026a0e:	f8dd a008 	ldr.w	sl, [sp, #8]
 8026a12:	3330      	adds	r3, #48	; 0x30
 8026a14:	f80a 3004 	strb.w	r3, [sl, r4]
 8026a18:	3401      	adds	r4, #1
 8026a1a:	782b      	ldrb	r3, [r5, #0]
 8026a1c:	e472      	b.n	8026304 <strftime+0x1bc>
 8026a1e:	f108 33ff 	add.w	r3, r8, #4294967295
 8026a22:	429c      	cmp	r4, r3
 8026a24:	f4bf ac48 	bcs.w	80262b8 <strftime+0x170>
 8026a28:	f8dd a008 	ldr.w	sl, [sp, #8]
 8026a2c:	230a      	movs	r3, #10
 8026a2e:	f80a 3004 	strb.w	r3, [sl, r4]
 8026a32:	782b      	ldrb	r3, [r5, #0]
 8026a34:	3401      	adds	r4, #1
 8026a36:	2b00      	cmp	r3, #0
 8026a38:	f47f ac67 	bne.w	802630a <strftime+0x1c2>
 8026a3c:	f7ff bb96 	b.w	802616c <strftime+0x24>
 8026a40:	f8dd c018 	ldr.w	ip, [sp, #24]
 8026a44:	f8dc 90e4 	ldr.w	r9, [ip, #228]	; 0xe4
 8026a48:	4648      	mov	r0, r9
 8026a4a:	f000 f987 	bl	8026d5c <strlen>
 8026a4e:	e5b7      	b.n	80265c0 <strftime+0x478>
 8026a50:	9e06      	ldr	r6, [sp, #24]
 8026a52:	f8d6 909c 	ldr.w	r9, [r6, #156]	; 0x9c
 8026a56:	4648      	mov	r0, r9
 8026a58:	f000 f980 	bl	8026d5c <strlen>
 8026a5c:	e5b0      	b.n	80265c0 <strftime+0x478>
 8026a5e:	693b      	ldr	r3, [r7, #16]
 8026a60:	f8dd c008 	ldr.w	ip, [sp, #8]
 8026a64:	4ab7      	ldr	r2, [pc, #732]	; (8026d44 <strftime+0xbfc>)
 8026a66:	3301      	adds	r3, #1
 8026a68:	eb0c 0004 	add.w	r0, ip, r4
 8026a6c:	ebc4 0108 	rsb	r1, r4, r8
 8026a70:	f004 fdee 	bl	802b650 <snprintf>
 8026a74:	2800      	cmp	r0, #0
 8026a76:	f6bf ac1c 	bge.w	80262b2 <strftime+0x16a>
 8026a7a:	2400      	movs	r4, #0
 8026a7c:	f7ff bb7c 	b.w	8026178 <strftime+0x30>
 8026a80:	232b      	movs	r3, #43	; 0x2b
 8026a82:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 8026a86:	2304      	movs	r3, #4
 8026a88:	211e      	movs	r1, #30
 8026a8a:	f10d 0026 	add.w	r0, sp, #38	; 0x26
 8026a8e:	4aae      	ldr	r2, [pc, #696]	; (8026d48 <strftime+0xc00>)
 8026a90:	f004 fdde 	bl	802b650 <snprintf>
 8026a94:	2800      	cmp	r0, #0
 8026a96:	f77f ae83 	ble.w	80267a0 <strftime+0x658>
 8026a9a:	f10d 0a26 	add.w	sl, sp, #38	; 0x26
 8026a9e:	4450      	add	r0, sl
 8026aa0:	aa09      	add	r2, sp, #36	; 0x24
 8026aa2:	e680      	b.n	80267a6 <strftime+0x65e>
 8026aa4:	2306      	movs	r3, #6
 8026aa6:	e577      	b.n	8026598 <strftime+0x450>
 8026aa8:	4ba8      	ldr	r3, [pc, #672]	; (8026d4c <strftime+0xc04>)
 8026aaa:	f8df c2a8 	ldr.w	ip, [pc, #680]	; 8026d54 <strftime+0xc0c>
 8026aae:	9101      	str	r1, [sp, #4]
 8026ab0:	9e02      	ldr	r6, [sp, #8]
 8026ab2:	49a7      	ldr	r1, [pc, #668]	; (8026d50 <strftime+0xc08>)
 8026ab4:	f1b9 0f01 	cmp.w	r9, #1
 8026ab8:	bf98      	it	ls
 8026aba:	f04f 0902 	movls.w	r9, #2
 8026abe:	2a00      	cmp	r2, #0
 8026ac0:	bf18      	it	ne
 8026ac2:	460b      	movne	r3, r1
 8026ac4:	ebc2 0e09 	rsb	lr, r2, r9
 8026ac8:	1930      	adds	r0, r6, r4
 8026aca:	ebc4 0108 	rsb	r1, r4, r8
 8026ace:	4662      	mov	r2, ip
 8026ad0:	f8cd e000 	str.w	lr, [sp]
 8026ad4:	f004 fdbc 	bl	802b650 <snprintf>
 8026ad8:	2800      	cmp	r0, #0
 8026ada:	f6bf abea 	bge.w	80262b2 <strftime+0x16a>
 8026ade:	2400      	movs	r4, #0
 8026ae0:	f7ff bb4a 	b.w	8026178 <strftime+0x30>
 8026ae4:	2006      	movs	r0, #6
 8026ae6:	69f9      	ldr	r1, [r7, #28]
 8026ae8:	e536      	b.n	8026558 <strftime+0x410>
 8026aea:	2330      	movs	r3, #48	; 0x30
 8026aec:	7043      	strb	r3, [r0, #1]
 8026aee:	3002      	adds	r0, #2
 8026af0:	e47d      	b.n	80263ee <strftime+0x2a6>
 8026af2:	230c      	movs	r3, #12
 8026af4:	e60e      	b.n	8026714 <strftime+0x5cc>
 8026af6:	f1ba 0f2b 	cmp.w	sl, #43	; 0x2b
 8026afa:	d053      	beq.n	8026ba4 <strftime+0xa5c>
 8026afc:	aa09      	add	r2, sp, #36	; 0x24
 8026afe:	2300      	movs	r3, #0
 8026b00:	4610      	mov	r0, r2
 8026b02:	e467      	b.n	80263d4 <strftime+0x28c>
 8026b04:	f1ba 0f2b 	cmp.w	sl, #43	; 0x2b
 8026b08:	d03e      	beq.n	8026b88 <strftime+0xa40>
 8026b0a:	aa09      	add	r2, sp, #36	; 0x24
 8026b0c:	4610      	mov	r0, r2
 8026b0e:	e5b8      	b.n	8026682 <strftime+0x53a>
 8026b10:	2330      	movs	r3, #48	; 0x30
 8026b12:	7043      	strb	r3, [r0, #1]
 8026b14:	3002      	adds	r0, #2
 8026b16:	e5c1      	b.n	802669c <strftime+0x554>
 8026b18:	f109 39ff 	add.w	r9, r9, #4294967295
 8026b1c:	e5b7      	b.n	802668e <strftime+0x546>
 8026b1e:	f109 39ff 	add.w	r9, r9, #4294967295
 8026b22:	e45d      	b.n	80263e0 <strftime+0x298>
 8026b24:	4b89      	ldr	r3, [pc, #548]	; (8026d4c <strftime+0xc04>)
 8026b26:	f8df c230 	ldr.w	ip, [pc, #560]	; 8026d58 <strftime+0xc10>
 8026b2a:	e7c0      	b.n	8026aae <strftime+0x966>
 8026b2c:	f10c 3cff 	add.w	ip, ip, #4294967295
 8026b30:	2163      	movs	r1, #99	; 0x63
 8026b32:	e598      	b.n	8026666 <strftime+0x51e>
 8026b34:	f64f 0395 	movw	r3, #63637	; 0xf895
 8026b38:	6979      	ldr	r1, [r7, #20]
 8026b3a:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8026b3e:	4299      	cmp	r1, r3
 8026b40:	bfb8      	it	lt
 8026b42:	f04f 0901 	movlt.w	r9, #1
 8026b46:	e6db      	b.n	8026900 <strftime+0x7b8>
 8026b48:	f040 80b0 	bne.w	8026cac <strftime+0xb64>
 8026b4c:	320a      	adds	r2, #10
 8026b4e:	f242 4193 	movw	r1, #9363	; 0x2493
 8026b52:	1ad3      	subs	r3, r2, r3
 8026b54:	f2c9 2149 	movt	r1, #37449	; 0x9249
 8026b58:	fb81 a203 	smull	sl, r2, r1, r3
 8026b5c:	18d2      	adds	r2, r2, r3
 8026b5e:	17db      	asrs	r3, r3, #31
 8026b60:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8026b64:	f7ff bb9c 	b.w	80262a0 <strftime+0x158>
 8026b68:	f64f 0295 	movw	r2, #63637	; 0xf895
 8026b6c:	6978      	ldr	r0, [r7, #20]
 8026b6e:	f6cf 72ff 	movt	r2, #65535	; 0xffff
 8026b72:	4290      	cmp	r0, r2
 8026b74:	f6bf ad6e 	bge.w	8026654 <strftime+0x50c>
 8026b78:	2101      	movs	r1, #1
 8026b7a:	460b      	mov	r3, r1
 8026b7c:	e56a      	b.n	8026654 <strftime+0x50c>
 8026b7e:	f001 fc25 	bl	80283cc <__tz_unlock>
 8026b82:	2400      	movs	r4, #0
 8026b84:	f7ff baf8 	b.w	8026178 <strftime+0x30>
 8026b88:	9e07      	ldr	r6, [sp, #28]
 8026b8a:	f242 720f 	movw	r2, #9999	; 0x270f
 8026b8e:	4296      	cmp	r6, r2
 8026b90:	d9bb      	bls.n	8026b0a <strftime+0x9c2>
 8026b92:	f88d a024 	strb.w	sl, [sp, #36]	; 0x24
 8026b96:	f10d 0025 	add.w	r0, sp, #37	; 0x25
 8026b9a:	2301      	movs	r3, #1
 8026b9c:	aa09      	add	r2, sp, #36	; 0x24
 8026b9e:	e570      	b.n	8026682 <strftime+0x53a>
 8026ba0:	4613      	mov	r3, r2
 8026ba2:	e5b7      	b.n	8026714 <strftime+0x5cc>
 8026ba4:	f242 730f 	movw	r3, #9999	; 0x270f
 8026ba8:	459c      	cmp	ip, r3
 8026baa:	d9a7      	bls.n	8026afc <strftime+0x9b4>
 8026bac:	f88d a024 	strb.w	sl, [sp, #36]	; 0x24
 8026bb0:	2301      	movs	r3, #1
 8026bb2:	f10d 0025 	add.w	r0, sp, #37	; 0x25
 8026bb6:	aa09      	add	r2, sp, #36	; 0x24
 8026bb8:	e40c      	b.n	80263d4 <strftime+0x28c>
 8026bba:	f502 60ec 	add.w	r0, r2, #1888	; 0x760
 8026bbe:	300c      	adds	r0, #12
 8026bc0:	f002 faf8 	bl	80291b4 <abs>
 8026bc4:	f248 531f 	movw	r3, #34079	; 0x851f
 8026bc8:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8026bcc:	17c2      	asrs	r2, r0, #31
 8026bce:	fb83 c300 	smull	ip, r3, r3, r0
 8026bd2:	ebc2 1363 	rsb	r3, r2, r3, asr #5
 8026bd6:	2264      	movs	r2, #100	; 0x64
 8026bd8:	fb02 0313 	mls	r3, r2, r3, r0
 8026bdc:	f7ff bb60 	b.w	80262a0 <strftime+0x158>
 8026be0:	f502 60ec 	add.w	r0, r2, #1888	; 0x760
 8026be4:	300c      	adds	r0, #12
 8026be6:	9105      	str	r1, [sp, #20]
 8026be8:	9303      	str	r3, [sp, #12]
 8026bea:	f002 fae3 	bl	80291b4 <abs>
 8026bee:	f248 561f 	movw	r6, #34079	; 0x851f
 8026bf2:	697a      	ldr	r2, [r7, #20]
 8026bf4:	9905      	ldr	r1, [sp, #20]
 8026bf6:	9b03      	ldr	r3, [sp, #12]
 8026bf8:	f2c5 16eb 	movt	r6, #20971	; 0x51eb
 8026bfc:	fb86 ce00 	smull	ip, lr, r6, r0
 8026c00:	17c0      	asrs	r0, r0, #31
 8026c02:	2a00      	cmp	r2, #0
 8026c04:	ebc0 1c6e 	rsb	ip, r0, lr, asr #5
 8026c08:	f280 8092 	bge.w	8026d30 <strftime+0xbe8>
 8026c0c:	f502 60ec 	add.w	r0, r2, #1888	; 0x760
 8026c10:	300c      	adds	r0, #12
 8026c12:	9105      	str	r1, [sp, #20]
 8026c14:	9303      	str	r3, [sp, #12]
 8026c16:	f8cd c010 	str.w	ip, [sp, #16]
 8026c1a:	f002 facb 	bl	80291b4 <abs>
 8026c1e:	fb86 2e00 	smull	r2, lr, r6, r0
 8026c22:	17c2      	asrs	r2, r0, #31
 8026c24:	ebc2 1e6e 	rsb	lr, r2, lr, asr #5
 8026c28:	2264      	movs	r2, #100	; 0x64
 8026c2a:	fb02 0e1e 	mls	lr, r2, lr, r0
 8026c2e:	f8dd c010 	ldr.w	ip, [sp, #16]
 8026c32:	9b03      	ldr	r3, [sp, #12]
 8026c34:	9905      	ldr	r1, [sp, #20]
 8026c36:	e505      	b.n	8026644 <strftime+0x4fc>
 8026c38:	f503 60ec 	add.w	r0, r3, #1888	; 0x760
 8026c3c:	300c      	adds	r0, #12
 8026c3e:	f002 fab9 	bl	80291b4 <abs>
 8026c42:	f248 531f 	movw	r3, #34079	; 0x851f
 8026c46:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8026c4a:	fb83 1300 	smull	r1, r3, r3, r0
 8026c4e:	17c2      	asrs	r2, r0, #31
 8026c50:	ebc2 1263 	rsb	r2, r2, r3, asr #5
 8026c54:	2364      	movs	r3, #100	; 0x64
 8026c56:	fb03 0212 	mls	r2, r3, r2, r0
 8026c5a:	e643      	b.n	80268e4 <strftime+0x79c>
 8026c5c:	f502 60ec 	add.w	r0, r2, #1888	; 0x760
 8026c60:	300c      	adds	r0, #12
 8026c62:	9105      	str	r1, [sp, #20]
 8026c64:	9303      	str	r3, [sp, #12]
 8026c66:	f002 faa5 	bl	80291b4 <abs>
 8026c6a:	f248 521f 	movw	r2, #34079	; 0x851f
 8026c6e:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
 8026c72:	fb82 6200 	smull	r6, r2, r2, r0
 8026c76:	ea4f 7ee0 	mov.w	lr, r0, asr #31
 8026c7a:	ebce 1e62 	rsb	lr, lr, r2, asr #5
 8026c7e:	2264      	movs	r2, #100	; 0x64
 8026c80:	fb02 0e1e 	mls	lr, r2, lr, r0
 8026c84:	9b03      	ldr	r3, [sp, #12]
 8026c86:	9905      	ldr	r1, [sp, #20]
 8026c88:	e572      	b.n	8026770 <strftime+0x628>
 8026c8a:	f503 60ec 	add.w	r0, r3, #1888	; 0x760
 8026c8e:	300c      	adds	r0, #12
 8026c90:	9205      	str	r2, [sp, #20]
 8026c92:	f002 fa8f 	bl	80291b4 <abs>
 8026c96:	f248 531f 	movw	r3, #34079	; 0x851f
 8026c9a:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8026c9e:	fb83 1300 	smull	r1, r3, r3, r0
 8026ca2:	17c0      	asrs	r0, r0, #31
 8026ca4:	ebc0 1163 	rsb	r1, r0, r3, asr #5
 8026ca8:	9a05      	ldr	r2, [sp, #20]
 8026caa:	e5a5      	b.n	80267f8 <strftime+0x6b0>
 8026cac:	6979      	ldr	r1, [r7, #20]
 8026cae:	f240 706b 	movw	r0, #1899	; 0x76b
 8026cb2:	2900      	cmp	r1, #0
 8026cb4:	bfac      	ite	ge
 8026cb6:	f06f 0e64 	mvnge.w	lr, #100	; 0x64
 8026cba:	4686      	movlt	lr, r0
 8026cbc:	448e      	add	lr, r1
 8026cbe:	f01e 0f03 	tst.w	lr, #3
 8026cc2:	ebc2 0303 	rsb	r3, r2, r3
 8026cc6:	d11a      	bne.n	8026cfe <strftime+0xbb6>
 8026cc8:	2900      	cmp	r1, #0
 8026cca:	bfa8      	it	ge
 8026ccc:	f06f 0064 	mvnge.w	r0, #100	; 0x64
 8026cd0:	f248 5e1f 	movw	lr, #34079	; 0x851f
 8026cd4:	1840      	adds	r0, r0, r1
 8026cd6:	f2c5 1eeb 	movt	lr, #20971	; 0x51eb
 8026cda:	fb8e ce00 	smull	ip, lr, lr, r0
 8026cde:	17c2      	asrs	r2, r0, #31
 8026ce0:	ebc2 126e 	rsb	r2, r2, lr, asr #5
 8026ce4:	f04f 0e64 	mov.w	lr, #100	; 0x64
 8026ce8:	fb0e 0012 	mls	r0, lr, r2, r0
 8026cec:	b138      	cbz	r0, 8026cfe <strftime+0xbb6>
 8026cee:	2101      	movs	r1, #1
 8026cf0:	1a5b      	subs	r3, r3, r1
 8026cf2:	2b04      	cmp	r3, #4
 8026cf4:	bfcc      	ite	gt
 8026cf6:	2334      	movgt	r3, #52	; 0x34
 8026cf8:	2335      	movle	r3, #53	; 0x35
 8026cfa:	f7ff bad1 	b.w	80262a0 <strftime+0x158>
 8026cfe:	2900      	cmp	r1, #0
 8026d00:	f240 726b 	movw	r2, #1899	; 0x76b
 8026d04:	bfa8      	it	ge
 8026d06:	f06f 0264 	mvnge.w	r2, #100	; 0x64
 8026d0a:	f248 501f 	movw	r0, #34079	; 0x851f
 8026d0e:	1851      	adds	r1, r2, r1
 8026d10:	f2c5 10eb 	movt	r0, #20971	; 0x51eb
 8026d14:	fb80 e001 	smull	lr, r0, r0, r1
 8026d18:	17ca      	asrs	r2, r1, #31
 8026d1a:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 8026d1e:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8026d22:	fb00 1112 	mls	r1, r0, r2, r1
 8026d26:	f1d1 0101 	rsbs	r1, r1, #1
 8026d2a:	bf38      	it	cc
 8026d2c:	2100      	movcc	r1, #0
 8026d2e:	e7df      	b.n	8026cf0 <strftime+0xba8>
 8026d30:	17d6      	asrs	r6, r2, #31
 8026d32:	e47c      	b.n	802662e <strftime+0x4e6>
 8026d34:	f1b9 0306 	subs.w	r3, r9, #6
 8026d38:	f47f aea6 	bne.w	8026a88 <strftime+0x940>
 8026d3c:	aa09      	add	r2, sp, #36	; 0x24
 8026d3e:	1c90      	adds	r0, r2, #2
 8026d40:	e531      	b.n	80267a6 <strftime+0x65e>
 8026d42:	bf00      	nop
 8026d44:	08032d10 	.word	0x08032d10
 8026d48:	08032d2c 	.word	0x08032d2c
 8026d4c:	08032bf4 	.word	0x08032bf4
 8026d50:	08032d0c 	.word	0x08032d0c
 8026d54:	08032cf8 	.word	0x08032cf8
 8026d58:	08032d00 	.word	0x08032d00

08026d5c <strlen>:
 8026d5c:	f020 0103 	bic.w	r1, r0, #3
 8026d60:	f010 0003 	ands.w	r0, r0, #3
 8026d64:	f1c0 0000 	rsb	r0, r0, #0
 8026d68:	f851 3b04 	ldr.w	r3, [r1], #4
 8026d6c:	f100 0c04 	add.w	ip, r0, #4
 8026d70:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8026d74:	f06f 0200 	mvn.w	r2, #0
 8026d78:	bf1c      	itt	ne
 8026d7a:	fa22 f20c 	lsrne.w	r2, r2, ip
 8026d7e:	4313      	orrne	r3, r2
 8026d80:	f04f 0c01 	mov.w	ip, #1
 8026d84:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 8026d88:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8026d8c:	eba3 020c 	sub.w	r2, r3, ip
 8026d90:	ea22 0203 	bic.w	r2, r2, r3
 8026d94:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8026d98:	bf04      	itt	eq
 8026d9a:	f851 3b04 	ldreq.w	r3, [r1], #4
 8026d9e:	3004      	addeq	r0, #4
 8026da0:	d0f4      	beq.n	8026d8c <strlen+0x30>
 8026da2:	f013 0fff 	tst.w	r3, #255	; 0xff
 8026da6:	bf1f      	itttt	ne
 8026da8:	3001      	addne	r0, #1
 8026daa:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 8026dae:	3001      	addne	r0, #1
 8026db0:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 8026db4:	bf18      	it	ne
 8026db6:	3001      	addne	r0, #1
 8026db8:	4770      	bx	lr
 8026dba:	bf00      	nop

08026dbc <strncpy>:
 8026dbc:	ea41 0300 	orr.w	r3, r1, r0
 8026dc0:	079b      	lsls	r3, r3, #30
 8026dc2:	b470      	push	{r4, r5, r6}
 8026dc4:	460d      	mov	r5, r1
 8026dc6:	4604      	mov	r4, r0
 8026dc8:	d12a      	bne.n	8026e20 <strncpy+0x64>
 8026dca:	2a03      	cmp	r2, #3
 8026dcc:	d817      	bhi.n	8026dfe <strncpy+0x42>
 8026dce:	b1a2      	cbz	r2, 8026dfa <strncpy+0x3e>
 8026dd0:	780e      	ldrb	r6, [r1, #0]
 8026dd2:	1e53      	subs	r3, r2, #1
 8026dd4:	f804 6b01 	strb.w	r6, [r4], #1
 8026dd8:	b14e      	cbz	r6, 8026dee <strncpy+0x32>
 8026dda:	4622      	mov	r2, r4
 8026ddc:	b16b      	cbz	r3, 8026dfa <strncpy+0x3e>
 8026dde:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8026de2:	f802 5b01 	strb.w	r5, [r2], #1
 8026de6:	3b01      	subs	r3, #1
 8026de8:	4614      	mov	r4, r2
 8026dea:	2d00      	cmp	r5, #0
 8026dec:	d1f6      	bne.n	8026ddc <strncpy+0x20>
 8026dee:	b123      	cbz	r3, 8026dfa <strncpy+0x3e>
 8026df0:	2200      	movs	r2, #0
 8026df2:	3b01      	subs	r3, #1
 8026df4:	f804 2b01 	strb.w	r2, [r4], #1
 8026df8:	d1fb      	bne.n	8026df2 <strncpy+0x36>
 8026dfa:	bc70      	pop	{r4, r5, r6}
 8026dfc:	4770      	bx	lr
 8026dfe:	4629      	mov	r1, r5
 8026e00:	f855 3b04 	ldr.w	r3, [r5], #4
 8026e04:	f1a3 3601 	sub.w	r6, r3, #16843009	; 0x1010101
 8026e08:	ea26 0603 	bic.w	r6, r6, r3
 8026e0c:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
 8026e10:	d1dd      	bne.n	8026dce <strncpy+0x12>
 8026e12:	3a04      	subs	r2, #4
 8026e14:	2a03      	cmp	r2, #3
 8026e16:	f844 3b04 	str.w	r3, [r4], #4
 8026e1a:	d8f0      	bhi.n	8026dfe <strncpy+0x42>
 8026e1c:	4629      	mov	r1, r5
 8026e1e:	e7d6      	b.n	8026dce <strncpy+0x12>
 8026e20:	4604      	mov	r4, r0
 8026e22:	e7d4      	b.n	8026dce <strncpy+0x12>

08026e24 <_strtoul_r>:
 8026e24:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8026e28:	4c49      	ldr	r4, [pc, #292]	; (8026f50 <_strtoul_r+0x12c>)
 8026e2a:	6824      	ldr	r4, [r4, #0]
 8026e2c:	4683      	mov	fp, r0
 8026e2e:	b082      	sub	sp, #8
 8026e30:	4608      	mov	r0, r1
 8026e32:	4684      	mov	ip, r0
 8026e34:	3001      	adds	r0, #1
 8026e36:	f89c 5000 	ldrb.w	r5, [ip]
 8026e3a:	1966      	adds	r6, r4, r5
 8026e3c:	4607      	mov	r7, r0
 8026e3e:	7876      	ldrb	r6, [r6, #1]
 8026e40:	f016 0608 	ands.w	r6, r6, #8
 8026e44:	d1f5      	bne.n	8026e32 <_strtoul_r+0xe>
 8026e46:	2d2d      	cmp	r5, #45	; 0x2d
 8026e48:	d065      	beq.n	8026f16 <_strtoul_r+0xf2>
 8026e4a:	2d2b      	cmp	r5, #43	; 0x2b
 8026e4c:	bf08      	it	eq
 8026e4e:	f89c 5001 	ldrbeq.w	r5, [ip, #1]
 8026e52:	9601      	str	r6, [sp, #4]
 8026e54:	bf08      	it	eq
 8026e56:	f10c 0702 	addeq.w	r7, ip, #2
 8026e5a:	2b00      	cmp	r3, #0
 8026e5c:	d040      	beq.n	8026ee0 <_strtoul_r+0xbc>
 8026e5e:	2b10      	cmp	r3, #16
 8026e60:	d03e      	beq.n	8026ee0 <_strtoul_r+0xbc>
 8026e62:	f04f 38ff 	mov.w	r8, #4294967295
 8026e66:	fbb8 f8f3 	udiv	r8, r8, r3
 8026e6a:	fb03 fa08 	mul.w	sl, r3, r8
 8026e6e:	4699      	mov	r9, r3
 8026e70:	ea6f 0a0a 	mvn.w	sl, sl
 8026e74:	1966      	adds	r6, r4, r5
 8026e76:	f04f 0c00 	mov.w	ip, #0
 8026e7a:	7876      	ldrb	r6, [r6, #1]
 8026e7c:	f016 0f04 	tst.w	r6, #4
 8026e80:	4660      	mov	r0, ip
 8026e82:	d013      	beq.n	8026eac <_strtoul_r+0x88>
 8026e84:	3d30      	subs	r5, #48	; 0x30
 8026e86:	42ab      	cmp	r3, r5
 8026e88:	dd1a      	ble.n	8026ec0 <_strtoul_r+0x9c>
 8026e8a:	f1bc 3fff 	cmp.w	ip, #4294967295
 8026e8e:	d006      	beq.n	8026e9e <_strtoul_r+0x7a>
 8026e90:	4540      	cmp	r0, r8
 8026e92:	d836      	bhi.n	8026f02 <_strtoul_r+0xde>
 8026e94:	d033      	beq.n	8026efe <_strtoul_r+0xda>
 8026e96:	fb09 5000 	mla	r0, r9, r0, r5
 8026e9a:	f04f 0c01 	mov.w	ip, #1
 8026e9e:	f817 5b01 	ldrb.w	r5, [r7], #1
 8026ea2:	1966      	adds	r6, r4, r5
 8026ea4:	7876      	ldrb	r6, [r6, #1]
 8026ea6:	f016 0f04 	tst.w	r6, #4
 8026eaa:	d1eb      	bne.n	8026e84 <_strtoul_r+0x60>
 8026eac:	f016 0603 	ands.w	r6, r6, #3
 8026eb0:	d006      	beq.n	8026ec0 <_strtoul_r+0x9c>
 8026eb2:	2e01      	cmp	r6, #1
 8026eb4:	bf14      	ite	ne
 8026eb6:	2657      	movne	r6, #87	; 0x57
 8026eb8:	2637      	moveq	r6, #55	; 0x37
 8026eba:	1bad      	subs	r5, r5, r6
 8026ebc:	42ab      	cmp	r3, r5
 8026ebe:	dce4      	bgt.n	8026e8a <_strtoul_r+0x66>
 8026ec0:	f1bc 3fff 	cmp.w	ip, #4294967295
 8026ec4:	d022      	beq.n	8026f0c <_strtoul_r+0xe8>
 8026ec6:	9b01      	ldr	r3, [sp, #4]
 8026ec8:	b103      	cbz	r3, 8026ecc <_strtoul_r+0xa8>
 8026eca:	4240      	negs	r0, r0
 8026ecc:	b122      	cbz	r2, 8026ed8 <_strtoul_r+0xb4>
 8026ece:	f1bc 0f00 	cmp.w	ip, #0
 8026ed2:	d000      	beq.n	8026ed6 <_strtoul_r+0xb2>
 8026ed4:	1e79      	subs	r1, r7, #1
 8026ed6:	6011      	str	r1, [r2, #0]
 8026ed8:	b002      	add	sp, #8
 8026eda:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8026ede:	4770      	bx	lr
 8026ee0:	2d30      	cmp	r5, #48	; 0x30
 8026ee2:	d01f      	beq.n	8026f24 <_strtoul_r+0x100>
 8026ee4:	2b00      	cmp	r3, #0
 8026ee6:	d1bc      	bne.n	8026e62 <_strtoul_r+0x3e>
 8026ee8:	2d30      	cmp	r5, #48	; 0x30
 8026eea:	d02a      	beq.n	8026f42 <_strtoul_r+0x11e>
 8026eec:	f649 1899 	movw	r8, #39321	; 0x9999
 8026ef0:	230a      	movs	r3, #10
 8026ef2:	f04f 0a05 	mov.w	sl, #5
 8026ef6:	f6c1 1899 	movt	r8, #6553	; 0x1999
 8026efa:	4699      	mov	r9, r3
 8026efc:	e7ba      	b.n	8026e74 <_strtoul_r+0x50>
 8026efe:	4555      	cmp	r5, sl
 8026f00:	ddc9      	ble.n	8026e96 <_strtoul_r+0x72>
 8026f02:	f04f 3cff 	mov.w	ip, #4294967295
 8026f06:	f817 5b01 	ldrb.w	r5, [r7], #1
 8026f0a:	e7ca      	b.n	8026ea2 <_strtoul_r+0x7e>
 8026f0c:	2322      	movs	r3, #34	; 0x22
 8026f0e:	f8cb 3000 	str.w	r3, [fp]
 8026f12:	4660      	mov	r0, ip
 8026f14:	e7da      	b.n	8026ecc <_strtoul_r+0xa8>
 8026f16:	2001      	movs	r0, #1
 8026f18:	f89c 5001 	ldrb.w	r5, [ip, #1]
 8026f1c:	9001      	str	r0, [sp, #4]
 8026f1e:	f10c 0702 	add.w	r7, ip, #2
 8026f22:	e79a      	b.n	8026e5a <_strtoul_r+0x36>
 8026f24:	7838      	ldrb	r0, [r7, #0]
 8026f26:	2878      	cmp	r0, #120	; 0x78
 8026f28:	d001      	beq.n	8026f2e <_strtoul_r+0x10a>
 8026f2a:	2858      	cmp	r0, #88	; 0x58
 8026f2c:	d1da      	bne.n	8026ee4 <_strtoul_r+0xc0>
 8026f2e:	f04f 0910 	mov.w	r9, #16
 8026f32:	787d      	ldrb	r5, [r7, #1]
 8026f34:	f04f 0a0f 	mov.w	sl, #15
 8026f38:	3702      	adds	r7, #2
 8026f3a:	f06f 4870 	mvn.w	r8, #4026531840	; 0xf0000000
 8026f3e:	464b      	mov	r3, r9
 8026f40:	e798      	b.n	8026e74 <_strtoul_r+0x50>
 8026f42:	2308      	movs	r3, #8
 8026f44:	f04f 0a07 	mov.w	sl, #7
 8026f48:	f06f 4860 	mvn.w	r8, #3758096384	; 0xe0000000
 8026f4c:	4699      	mov	r9, r3
 8026f4e:	e791      	b.n	8026e74 <_strtoul_r+0x50>
 8026f50:	2000092c 	.word	0x2000092c

08026f54 <strtoul>:
 8026f54:	f240 5310 	movw	r3, #1296	; 0x510
 8026f58:	b430      	push	{r4, r5}
 8026f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8026f5e:	460c      	mov	r4, r1
 8026f60:	681d      	ldr	r5, [r3, #0]
 8026f62:	4601      	mov	r1, r0
 8026f64:	4613      	mov	r3, r2
 8026f66:	4628      	mov	r0, r5
 8026f68:	4622      	mov	r2, r4
 8026f6a:	bc30      	pop	{r4, r5}
 8026f6c:	f7ff bf5a 	b.w	8026e24 <_strtoul_r>

08026f70 <_svfprintf_r>:
 8026f70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026f74:	b0c3      	sub	sp, #268	; 0x10c
 8026f76:	4693      	mov	fp, r2
 8026f78:	9109      	str	r1, [sp, #36]	; 0x24
 8026f7a:	930f      	str	r3, [sp, #60]	; 0x3c
 8026f7c:	900c      	str	r0, [sp, #48]	; 0x30
 8026f7e:	f003 fd53 	bl	802aa28 <_localeconv_r>
 8026f82:	6800      	ldr	r0, [r0, #0]
 8026f84:	2300      	movs	r3, #0
 8026f86:	2200      	movs	r2, #0
 8026f88:	e9cd 2318 	strd	r2, r3, [sp, #96]	; 0x60
 8026f8c:	9014      	str	r0, [sp, #80]	; 0x50
 8026f8e:	f7ff fee5 	bl	8026d5c <strlen>
 8026f92:	9016      	str	r0, [sp, #88]	; 0x58
 8026f94:	9809      	ldr	r0, [sp, #36]	; 0x24
 8026f96:	8983      	ldrh	r3, [r0, #12]
 8026f98:	061b      	lsls	r3, r3, #24
 8026f9a:	d503      	bpl.n	8026fa4 <_svfprintf_r+0x34>
 8026f9c:	6903      	ldr	r3, [r0, #16]
 8026f9e:	2b00      	cmp	r3, #0
 8026fa0:	f001 8039 	beq.w	8028016 <_svfprintf_r+0x10a6>
 8026fa4:	f246 6167 	movw	r1, #26215	; 0x6667
 8026fa8:	2300      	movs	r3, #0
 8026faa:	aa1d      	add	r2, sp, #116	; 0x74
 8026fac:	f2c6 6166 	movt	r1, #26214	; 0x6666
 8026fb0:	930e      	str	r3, [sp, #56]	; 0x38
 8026fb2:	9237      	str	r2, [sp, #220]	; 0xdc
 8026fb4:	9339      	str	r3, [sp, #228]	; 0xe4
 8026fb6:	9338      	str	r3, [sp, #224]	; 0xe0
 8026fb8:	931a      	str	r3, [sp, #104]	; 0x68
 8026fba:	931b      	str	r3, [sp, #108]	; 0x6c
 8026fbc:	930b      	str	r3, [sp, #44]	; 0x2c
 8026fbe:	4616      	mov	r6, r2
 8026fc0:	9117      	str	r1, [sp, #92]	; 0x5c
 8026fc2:	f89b 3000 	ldrb.w	r3, [fp]
 8026fc6:	2b00      	cmp	r3, #0
 8026fc8:	f000 80bc 	beq.w	8027144 <_svfprintf_r+0x1d4>
 8026fcc:	2b25      	cmp	r3, #37	; 0x25
 8026fce:	f000 80b9 	beq.w	8027144 <_svfprintf_r+0x1d4>
 8026fd2:	465a      	mov	r2, fp
 8026fd4:	465f      	mov	r7, fp
 8026fd6:	e001      	b.n	8026fdc <_svfprintf_r+0x6c>
 8026fd8:	2b25      	cmp	r3, #37	; 0x25
 8026fda:	d004      	beq.n	8026fe6 <_svfprintf_r+0x76>
 8026fdc:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8026fe0:	3701      	adds	r7, #1
 8026fe2:	2b00      	cmp	r3, #0
 8026fe4:	d1f8      	bne.n	8026fd8 <_svfprintf_r+0x68>
 8026fe6:	ebcb 0307 	rsb	r3, fp, r7
 8026fea:	b17b      	cbz	r3, 802700c <_svfprintf_r+0x9c>
 8026fec:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8026fee:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8026ff0:	f8c6 b000 	str.w	fp, [r6]
 8026ff4:	3401      	adds	r4, #1
 8026ff6:	18ed      	adds	r5, r5, r3
 8026ff8:	2c07      	cmp	r4, #7
 8026ffa:	6073      	str	r3, [r6, #4]
 8026ffc:	9539      	str	r5, [sp, #228]	; 0xe4
 8026ffe:	9438      	str	r4, [sp, #224]	; 0xe0
 8027000:	f300 8082 	bgt.w	8027108 <_svfprintf_r+0x198>
 8027004:	3608      	adds	r6, #8
 8027006:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8027008:	18c0      	adds	r0, r0, r3
 802700a:	900b      	str	r0, [sp, #44]	; 0x2c
 802700c:	783b      	ldrb	r3, [r7, #0]
 802700e:	2b00      	cmp	r3, #0
 8027010:	f000 8084 	beq.w	802711c <_svfprintf_r+0x1ac>
 8027014:	2100      	movs	r1, #0
 8027016:	2200      	movs	r2, #0
 8027018:	f107 0b01 	add.w	fp, r7, #1
 802701c:	787b      	ldrb	r3, [r7, #1]
 802701e:	910a      	str	r1, [sp, #40]	; 0x28
 8027020:	f88d 2107 	strb.w	r2, [sp, #263]	; 0x107
 8027024:	f04f 37ff 	mov.w	r7, #4294967295
 8027028:	9107      	str	r1, [sp, #28]
 802702a:	2420      	movs	r4, #32
 802702c:	202b      	movs	r0, #43	; 0x2b
 802702e:	f10b 0b01 	add.w	fp, fp, #1
 8027032:	f1a3 0220 	sub.w	r2, r3, #32
 8027036:	2a58      	cmp	r2, #88	; 0x58
 8027038:	f200 8215 	bhi.w	8027466 <_svfprintf_r+0x4f6>
 802703c:	e8df f012 	tbh	[pc, r2, lsl #1]
 8027040:	021302bf 	.word	0x021302bf
 8027044:	02ac0213 	.word	0x02ac0213
 8027048:	02130213 	.word	0x02130213
 802704c:	02130213 	.word	0x02130213
 8027050:	02130213 	.word	0x02130213
 8027054:	008402b3 	.word	0x008402b3
 8027058:	005d0213 	.word	0x005d0213
 802705c:	02130089 	.word	0x02130089
 8027060:	00aa00a3 	.word	0x00aa00a3
 8027064:	00aa00aa 	.word	0x00aa00aa
 8027068:	00aa00aa 	.word	0x00aa00aa
 802706c:	00aa00aa 	.word	0x00aa00aa
 8027070:	00aa00aa 	.word	0x00aa00aa
 8027074:	02130213 	.word	0x02130213
 8027078:	02130213 	.word	0x02130213
 802707c:	02130213 	.word	0x02130213
 8027080:	02130213 	.word	0x02130213
 8027084:	02130213 	.word	0x02130213
 8027088:	014900bb 	.word	0x014900bb
 802708c:	01490213 	.word	0x01490213
 8027090:	02130213 	.word	0x02130213
 8027094:	02130213 	.word	0x02130213
 8027098:	02130182 	.word	0x02130182
 802709c:	01890213 	.word	0x01890213
 80270a0:	02130213 	.word	0x02130213
 80270a4:	02130213 	.word	0x02130213
 80270a8:	01a10213 	.word	0x01a10213
 80270ac:	02130213 	.word	0x02130213
 80270b0:	021301b5 	.word	0x021301b5
 80270b4:	02130213 	.word	0x02130213
 80270b8:	02130213 	.word	0x02130213
 80270bc:	02130213 	.word	0x02130213
 80270c0:	02130213 	.word	0x02130213
 80270c4:	024d0213 	.word	0x024d0213
 80270c8:	01490225 	.word	0x01490225
 80270cc:	01490149 	.word	0x01490149
 80270d0:	02250246 	.word	0x02250246
 80270d4:	02130213 	.word	0x02130213
 80270d8:	02130208 	.word	0x02130208
 80270dc:	025e0288 	.word	0x025e0288
 80270e0:	01d80271 	.word	0x01d80271
 80270e4:	01df0213 	.word	0x01df0213
 80270e8:	02960213 	.word	0x02960213
 80270ec:	02130213 	.word	0x02130213
 80270f0:	02d4      	.short	0x02d4
 80270f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80270f4:	910f      	str	r1, [sp, #60]	; 0x3c
 80270f6:	425b      	negs	r3, r3
 80270f8:	930a      	str	r3, [sp, #40]	; 0x28
 80270fa:	9907      	ldr	r1, [sp, #28]
 80270fc:	f041 0104 	orr.w	r1, r1, #4
 8027100:	9107      	str	r1, [sp, #28]
 8027102:	f89b 3000 	ldrb.w	r3, [fp]
 8027106:	e792      	b.n	802702e <_svfprintf_r+0xbe>
 8027108:	980c      	ldr	r0, [sp, #48]	; 0x30
 802710a:	9909      	ldr	r1, [sp, #36]	; 0x24
 802710c:	9306      	str	r3, [sp, #24]
 802710e:	aa37      	add	r2, sp, #220	; 0xdc
 8027110:	f004 fb1a 	bl	802b748 <__ssprint_r>
 8027114:	9b06      	ldr	r3, [sp, #24]
 8027116:	b940      	cbnz	r0, 802712a <_svfprintf_r+0x1ba>
 8027118:	ae1d      	add	r6, sp, #116	; 0x74
 802711a:	e774      	b.n	8027006 <_svfprintf_r+0x96>
 802711c:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 802711e:	b123      	cbz	r3, 802712a <_svfprintf_r+0x1ba>
 8027120:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027122:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027124:	aa37      	add	r2, sp, #220	; 0xdc
 8027126:	f004 fb0f 	bl	802b748 <__ssprint_r>
 802712a:	9909      	ldr	r1, [sp, #36]	; 0x24
 802712c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802712e:	898b      	ldrh	r3, [r1, #12]
 8027130:	f013 0f40 	tst.w	r3, #64	; 0x40
 8027134:	bf18      	it	ne
 8027136:	f04f 32ff 	movne.w	r2, #4294967295
 802713a:	920b      	str	r2, [sp, #44]	; 0x2c
 802713c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 802713e:	b043      	add	sp, #268	; 0x10c
 8027140:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8027144:	465f      	mov	r7, fp
 8027146:	e761      	b.n	802700c <_svfprintf_r+0x9c>
 8027148:	f88d 0107 	strb.w	r0, [sp, #263]	; 0x107
 802714c:	f89b 3000 	ldrb.w	r3, [fp]
 8027150:	e76d      	b.n	802702e <_svfprintf_r+0xbe>
 8027152:	465a      	mov	r2, fp
 8027154:	f812 3b01 	ldrb.w	r3, [r2], #1
 8027158:	2b2a      	cmp	r3, #42	; 0x2a
 802715a:	f001 80f5 	beq.w	8028348 <_svfprintf_r+0x13d8>
 802715e:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8027162:	2909      	cmp	r1, #9
 8027164:	f201 80a4 	bhi.w	80282b0 <_svfprintf_r+0x1340>
 8027168:	2700      	movs	r7, #0
 802716a:	f812 3b01 	ldrb.w	r3, [r2], #1
 802716e:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8027172:	eb01 0747 	add.w	r7, r1, r7, lsl #1
 8027176:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 802717a:	2909      	cmp	r1, #9
 802717c:	4693      	mov	fp, r2
 802717e:	d9f4      	bls.n	802716a <_svfprintf_r+0x1fa>
 8027180:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 8027184:	e755      	b.n	8027032 <_svfprintf_r+0xc2>
 8027186:	9907      	ldr	r1, [sp, #28]
 8027188:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 802718c:	9107      	str	r1, [sp, #28]
 802718e:	f89b 3000 	ldrb.w	r3, [fp]
 8027192:	e74c      	b.n	802702e <_svfprintf_r+0xbe>
 8027194:	4659      	mov	r1, fp
 8027196:	2200      	movs	r2, #0
 8027198:	f1a3 0c30 	sub.w	ip, r3, #48	; 0x30
 802719c:	f811 3b01 	ldrb.w	r3, [r1], #1
 80271a0:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
 80271a4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80271a8:	2d09      	cmp	r5, #9
 80271aa:	eb0c 0242 	add.w	r2, ip, r2, lsl #1
 80271ae:	468b      	mov	fp, r1
 80271b0:	d9f2      	bls.n	8027198 <_svfprintf_r+0x228>
 80271b2:	920a      	str	r2, [sp, #40]	; 0x28
 80271b4:	e73d      	b.n	8027032 <_svfprintf_r+0xc2>
 80271b6:	9313      	str	r3, [sp, #76]	; 0x4c
 80271b8:	9b07      	ldr	r3, [sp, #28]
 80271ba:	f043 0310 	orr.w	r3, r3, #16
 80271be:	9307      	str	r3, [sp, #28]
 80271c0:	9807      	ldr	r0, [sp, #28]
 80271c2:	0685      	lsls	r5, r0, #26
 80271c4:	f140 8166 	bpl.w	8027494 <_svfprintf_r+0x524>
 80271c8:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80271ca:	1dcb      	adds	r3, r1, #7
 80271cc:	f023 0307 	bic.w	r3, r3, #7
 80271d0:	e9d3 0100 	ldrd	r0, r1, [r3]
 80271d4:	3308      	adds	r3, #8
 80271d6:	930f      	str	r3, [sp, #60]	; 0x3c
 80271d8:	2800      	cmp	r0, #0
 80271da:	f171 0300 	sbcs.w	r3, r1, #0
 80271de:	4680      	mov	r8, r0
 80271e0:	4689      	mov	r9, r1
 80271e2:	f2c0 816a 	blt.w	80274ba <_svfprintf_r+0x54a>
 80271e6:	2301      	movs	r3, #1
 80271e8:	2f00      	cmp	r7, #0
 80271ea:	db03      	blt.n	80271f4 <_svfprintf_r+0x284>
 80271ec:	9907      	ldr	r1, [sp, #28]
 80271ee:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 80271f2:	9107      	str	r1, [sp, #28]
 80271f4:	ea58 0209 	orrs.w	r2, r8, r9
 80271f8:	f040 82e6 	bne.w	80277c8 <_svfprintf_r+0x858>
 80271fc:	2f00      	cmp	r7, #0
 80271fe:	f040 82e3 	bne.w	80277c8 <_svfprintf_r+0x858>
 8027202:	2b00      	cmp	r3, #0
 8027204:	f040 8435 	bne.w	8027a72 <_svfprintf_r+0xb02>
 8027208:	9a07      	ldr	r2, [sp, #28]
 802720a:	07d1      	lsls	r1, r2, #31
 802720c:	f140 8431 	bpl.w	8027a72 <_svfprintf_r+0xb02>
 8027210:	2330      	movs	r3, #48	; 0x30
 8027212:	f88d 30db 	strb.w	r3, [sp, #219]	; 0xdb
 8027216:	2301      	movs	r3, #1
 8027218:	930d      	str	r3, [sp, #52]	; 0x34
 802721a:	f10d 0adb 	add.w	sl, sp, #219	; 0xdb
 802721e:	980d      	ldr	r0, [sp, #52]	; 0x34
 8027220:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
 8027224:	9710      	str	r7, [sp, #64]	; 0x40
 8027226:	42b8      	cmp	r0, r7
 8027228:	bfb8      	it	lt
 802722a:	4638      	movlt	r0, r7
 802722c:	2100      	movs	r1, #0
 802722e:	9008      	str	r0, [sp, #32]
 8027230:	9115      	str	r1, [sp, #84]	; 0x54
 8027232:	b113      	cbz	r3, 802723a <_svfprintf_r+0x2ca>
 8027234:	9808      	ldr	r0, [sp, #32]
 8027236:	3001      	adds	r0, #1
 8027238:	9008      	str	r0, [sp, #32]
 802723a:	9b07      	ldr	r3, [sp, #28]
 802723c:	f013 0302 	ands.w	r3, r3, #2
 8027240:	9311      	str	r3, [sp, #68]	; 0x44
 8027242:	d002      	beq.n	802724a <_svfprintf_r+0x2da>
 8027244:	9808      	ldr	r0, [sp, #32]
 8027246:	3002      	adds	r0, #2
 8027248:	9008      	str	r0, [sp, #32]
 802724a:	9b07      	ldr	r3, [sp, #28]
 802724c:	f013 0384 	ands.w	r3, r3, #132	; 0x84
 8027250:	9312      	str	r3, [sp, #72]	; 0x48
 8027252:	f040 81e0 	bne.w	8027616 <_svfprintf_r+0x6a6>
 8027256:	980a      	ldr	r0, [sp, #40]	; 0x28
 8027258:	9908      	ldr	r1, [sp, #32]
 802725a:	1a47      	subs	r7, r0, r1
 802725c:	2f00      	cmp	r7, #0
 802725e:	f340 81da 	ble.w	8027616 <_svfprintf_r+0x6a6>
 8027262:	2f10      	cmp	r7, #16
 8027264:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027266:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027268:	f8df 8378 	ldr.w	r8, [pc, #888]	; 80275e4 <_svfprintf_r+0x674>
 802726c:	dd25      	ble.n	80272ba <_svfprintf_r+0x34a>
 802726e:	4623      	mov	r3, r4
 8027270:	462a      	mov	r2, r5
 8027272:	4644      	mov	r4, r8
 8027274:	f04f 0910 	mov.w	r9, #16
 8027278:	9d09      	ldr	r5, [sp, #36]	; 0x24
 802727a:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 802727e:	e003      	b.n	8027288 <_svfprintf_r+0x318>
 8027280:	3f10      	subs	r7, #16
 8027282:	3608      	adds	r6, #8
 8027284:	2f10      	cmp	r7, #16
 8027286:	dd15      	ble.n	80272b4 <_svfprintf_r+0x344>
 8027288:	3301      	adds	r3, #1
 802728a:	3210      	adds	r2, #16
 802728c:	2b07      	cmp	r3, #7
 802728e:	e886 0210 	stmia.w	r6, {r4, r9}
 8027292:	9239      	str	r2, [sp, #228]	; 0xe4
 8027294:	9338      	str	r3, [sp, #224]	; 0xe0
 8027296:	ddf3      	ble.n	8027280 <_svfprintf_r+0x310>
 8027298:	4640      	mov	r0, r8
 802729a:	4629      	mov	r1, r5
 802729c:	aa37      	add	r2, sp, #220	; 0xdc
 802729e:	f004 fa53 	bl	802b748 <__ssprint_r>
 80272a2:	2800      	cmp	r0, #0
 80272a4:	f47f af41 	bne.w	802712a <_svfprintf_r+0x1ba>
 80272a8:	3f10      	subs	r7, #16
 80272aa:	2f10      	cmp	r7, #16
 80272ac:	9a39      	ldr	r2, [sp, #228]	; 0xe4
 80272ae:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 80272b0:	ae1d      	add	r6, sp, #116	; 0x74
 80272b2:	dce9      	bgt.n	8027288 <_svfprintf_r+0x318>
 80272b4:	46a0      	mov	r8, r4
 80272b6:	4615      	mov	r5, r2
 80272b8:	461c      	mov	r4, r3
 80272ba:	3401      	adds	r4, #1
 80272bc:	19ed      	adds	r5, r5, r7
 80272be:	2c07      	cmp	r4, #7
 80272c0:	f8c6 8000 	str.w	r8, [r6]
 80272c4:	6077      	str	r7, [r6, #4]
 80272c6:	9539      	str	r5, [sp, #228]	; 0xe4
 80272c8:	9438      	str	r4, [sp, #224]	; 0xe0
 80272ca:	f300 8452 	bgt.w	8027b72 <_svfprintf_r+0xc02>
 80272ce:	3608      	adds	r6, #8
 80272d0:	e1a2      	b.n	8027618 <_svfprintf_r+0x6a8>
 80272d2:	9807      	ldr	r0, [sp, #28]
 80272d4:	9313      	str	r3, [sp, #76]	; 0x4c
 80272d6:	0702      	lsls	r2, r0, #28
 80272d8:	f140 857f 	bpl.w	8027dda <_svfprintf_r+0xe6a>
 80272dc:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80272de:	1dcb      	adds	r3, r1, #7
 80272e0:	f023 0307 	bic.w	r3, r3, #7
 80272e4:	f103 0208 	add.w	r2, r3, #8
 80272e8:	920f      	str	r2, [sp, #60]	; 0x3c
 80272ea:	f8d3 8000 	ldr.w	r8, [r3]
 80272ee:	685d      	ldr	r5, [r3, #4]
 80272f0:	4642      	mov	r2, r8
 80272f2:	462b      	mov	r3, r5
 80272f4:	4629      	mov	r1, r5
 80272f6:	4640      	mov	r0, r8
 80272f8:	e9cd 2318 	strd	r2, r3, [sp, #96]	; 0x60
 80272fc:	f004 f940 	bl	802b580 <__fpclassifyd>
 8027300:	2801      	cmp	r0, #1
 8027302:	4629      	mov	r1, r5
 8027304:	4640      	mov	r0, r8
 8027306:	f040 853e 	bne.w	8027d86 <_svfprintf_r+0xe16>
 802730a:	2200      	movs	r2, #0
 802730c:	2300      	movs	r3, #0
 802730e:	f7fc f897 	bl	8023440 <__aeabi_dcmplt>
 8027312:	2800      	cmp	r0, #0
 8027314:	f040 867a 	bne.w	802800c <_svfprintf_r+0x109c>
 8027318:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
 802731c:	2003      	movs	r0, #3
 802731e:	2100      	movs	r1, #0
 8027320:	4aac      	ldr	r2, [pc, #688]	; (80275d4 <_svfprintf_r+0x664>)
 8027322:	9008      	str	r0, [sp, #32]
 8027324:	9110      	str	r1, [sp, #64]	; 0x40
 8027326:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8027328:	49ab      	ldr	r1, [pc, #684]	; (80275d8 <_svfprintf_r+0x668>)
 802732a:	2847      	cmp	r0, #71	; 0x47
 802732c:	bfcc      	ite	gt
 802732e:	468a      	movgt	sl, r1
 8027330:	4692      	movle	sl, r2
 8027332:	9907      	ldr	r1, [sp, #28]
 8027334:	2203      	movs	r2, #3
 8027336:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 802733a:	2000      	movs	r0, #0
 802733c:	9107      	str	r1, [sp, #28]
 802733e:	920d      	str	r2, [sp, #52]	; 0x34
 8027340:	9015      	str	r0, [sp, #84]	; 0x54
 8027342:	e776      	b.n	8027232 <_svfprintf_r+0x2c2>
 8027344:	9a07      	ldr	r2, [sp, #28]
 8027346:	f042 0208 	orr.w	r2, r2, #8
 802734a:	9207      	str	r2, [sp, #28]
 802734c:	f89b 3000 	ldrb.w	r3, [fp]
 8027350:	e66d      	b.n	802702e <_svfprintf_r+0xbe>
 8027352:	9907      	ldr	r1, [sp, #28]
 8027354:	9313      	str	r3, [sp, #76]	; 0x4c
 8027356:	f041 0110 	orr.w	r1, r1, #16
 802735a:	9107      	str	r1, [sp, #28]
 802735c:	9a07      	ldr	r2, [sp, #28]
 802735e:	f012 0320 	ands.w	r3, r2, #32
 8027362:	f000 80d1 	beq.w	8027508 <_svfprintf_r+0x598>
 8027366:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027368:	1dc3      	adds	r3, r0, #7
 802736a:	f023 0307 	bic.w	r3, r3, #7
 802736e:	f103 0108 	add.w	r1, r3, #8
 8027372:	e9d3 8900 	ldrd	r8, r9, [r3]
 8027376:	910f      	str	r1, [sp, #60]	; 0x3c
 8027378:	2300      	movs	r3, #0
 802737a:	2000      	movs	r0, #0
 802737c:	f88d 0107 	strb.w	r0, [sp, #263]	; 0x107
 8027380:	e732      	b.n	80271e8 <_svfprintf_r+0x278>
 8027382:	9a07      	ldr	r2, [sp, #28]
 8027384:	9313      	str	r3, [sp, #76]	; 0x4c
 8027386:	f042 0210 	orr.w	r2, r2, #16
 802738a:	9207      	str	r2, [sp, #28]
 802738c:	9b07      	ldr	r3, [sp, #28]
 802738e:	069b      	lsls	r3, r3, #26
 8027390:	f140 80f1 	bpl.w	8027576 <_svfprintf_r+0x606>
 8027394:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027396:	1dc3      	adds	r3, r0, #7
 8027398:	f023 0307 	bic.w	r3, r3, #7
 802739c:	f103 0108 	add.w	r1, r3, #8
 80273a0:	e9d3 8900 	ldrd	r8, r9, [r3]
 80273a4:	910f      	str	r1, [sp, #60]	; 0x3c
 80273a6:	2301      	movs	r3, #1
 80273a8:	e7e7      	b.n	802737a <_svfprintf_r+0x40a>
 80273aa:	9313      	str	r3, [sp, #76]	; 0x4c
 80273ac:	9b07      	ldr	r3, [sp, #28]
 80273ae:	4a8b      	ldr	r2, [pc, #556]	; (80275dc <_svfprintf_r+0x66c>)
 80273b0:	0699      	lsls	r1, r3, #26
 80273b2:	921a      	str	r2, [sp, #104]	; 0x68
 80273b4:	f140 811f 	bpl.w	80275f6 <_svfprintf_r+0x686>
 80273b8:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80273ba:	1dc3      	adds	r3, r0, #7
 80273bc:	f023 0307 	bic.w	r3, r3, #7
 80273c0:	e9d3 8900 	ldrd	r8, r9, [r3]
 80273c4:	f103 0108 	add.w	r1, r3, #8
 80273c8:	910f      	str	r1, [sp, #60]	; 0x3c
 80273ca:	9907      	ldr	r1, [sp, #28]
 80273cc:	07cd      	lsls	r5, r1, #31
 80273ce:	f140 8381 	bpl.w	8027ad4 <_svfprintf_r+0xb64>
 80273d2:	ea58 0209 	orrs.w	r2, r8, r9
 80273d6:	f000 837d 	beq.w	8027ad4 <_svfprintf_r+0xb64>
 80273da:	2330      	movs	r3, #48	; 0x30
 80273dc:	f88d 3104 	strb.w	r3, [sp, #260]	; 0x104
 80273e0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80273e2:	f041 0102 	orr.w	r1, r1, #2
 80273e6:	f88d 3105 	strb.w	r3, [sp, #261]	; 0x105
 80273ea:	9107      	str	r1, [sp, #28]
 80273ec:	2302      	movs	r3, #2
 80273ee:	e7c4      	b.n	802737a <_svfprintf_r+0x40a>
 80273f0:	9b07      	ldr	r3, [sp, #28]
 80273f2:	f043 0320 	orr.w	r3, r3, #32
 80273f6:	9307      	str	r3, [sp, #28]
 80273f8:	f89b 3000 	ldrb.w	r3, [fp]
 80273fc:	e617      	b.n	802702e <_svfprintf_r+0xbe>
 80273fe:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8027400:	9313      	str	r3, [sp, #76]	; 0x4c
 8027402:	2100      	movs	r1, #0
 8027404:	f88d 1107 	strb.w	r1, [sp, #263]	; 0x107
 8027408:	f8d2 a000 	ldr.w	sl, [r2]
 802740c:	1d14      	adds	r4, r2, #4
 802740e:	f1ba 0f00 	cmp.w	sl, #0
 8027412:	f000 868a 	beq.w	802812a <_svfprintf_r+0x11ba>
 8027416:	2f00      	cmp	r7, #0
 8027418:	4650      	mov	r0, sl
 802741a:	f2c0 8635 	blt.w	8028088 <_svfprintf_r+0x1118>
 802741e:	2100      	movs	r1, #0
 8027420:	463a      	mov	r2, r7
 8027422:	f003 fb77 	bl	802ab14 <memchr>
 8027426:	2800      	cmp	r0, #0
 8027428:	f000 8725 	beq.w	8028276 <_svfprintf_r+0x1306>
 802742c:	ebca 0000 	rsb	r0, sl, r0
 8027430:	2300      	movs	r3, #0
 8027432:	42b8      	cmp	r0, r7
 8027434:	900d      	str	r0, [sp, #52]	; 0x34
 8027436:	9310      	str	r3, [sp, #64]	; 0x40
 8027438:	f340 8560 	ble.w	8027efc <_svfprintf_r+0xf8c>
 802743c:	ea27 70e7 	bic.w	r0, r7, r7, asr #31
 8027440:	2100      	movs	r1, #0
 8027442:	9008      	str	r0, [sp, #32]
 8027444:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
 8027448:	940f      	str	r4, [sp, #60]	; 0x3c
 802744a:	970d      	str	r7, [sp, #52]	; 0x34
 802744c:	9115      	str	r1, [sp, #84]	; 0x54
 802744e:	e6f0      	b.n	8027232 <_svfprintf_r+0x2c2>
 8027450:	f89b 3000 	ldrb.w	r3, [fp]
 8027454:	2b6c      	cmp	r3, #108	; 0x6c
 8027456:	465a      	mov	r2, fp
 8027458:	f000 8547 	beq.w	8027eea <_svfprintf_r+0xf7a>
 802745c:	9a07      	ldr	r2, [sp, #28]
 802745e:	f042 0210 	orr.w	r2, r2, #16
 8027462:	9207      	str	r2, [sp, #28]
 8027464:	e5e3      	b.n	802702e <_svfprintf_r+0xbe>
 8027466:	9313      	str	r3, [sp, #76]	; 0x4c
 8027468:	2b00      	cmp	r3, #0
 802746a:	f43f ae57 	beq.w	802711c <_svfprintf_r+0x1ac>
 802746e:	2201      	movs	r2, #1
 8027470:	f88d 30b4 	strb.w	r3, [sp, #180]	; 0xb4
 8027474:	2300      	movs	r3, #0
 8027476:	9208      	str	r2, [sp, #32]
 8027478:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
 802747c:	920d      	str	r2, [sp, #52]	; 0x34
 802747e:	f10d 0ab4 	add.w	sl, sp, #180	; 0xb4
 8027482:	2300      	movs	r3, #0
 8027484:	9310      	str	r3, [sp, #64]	; 0x40
 8027486:	9315      	str	r3, [sp, #84]	; 0x54
 8027488:	e6d7      	b.n	802723a <_svfprintf_r+0x2ca>
 802748a:	9807      	ldr	r0, [sp, #28]
 802748c:	9313      	str	r3, [sp, #76]	; 0x4c
 802748e:	0685      	lsls	r5, r0, #26
 8027490:	f53f ae9a 	bmi.w	80271c8 <_svfprintf_r+0x258>
 8027494:	9a07      	ldr	r2, [sp, #28]
 8027496:	06d0      	lsls	r0, r2, #27
 8027498:	f140 84a8 	bpl.w	8027dec <_svfprintf_r+0xe7c>
 802749c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 802749e:	6803      	ldr	r3, [r0, #0]
 80274a0:	4698      	mov	r8, r3
 80274a2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80274a4:	ea4f 79e8 	mov.w	r9, r8, asr #31
 80274a8:	4640      	mov	r0, r8
 80274aa:	4649      	mov	r1, r9
 80274ac:	3204      	adds	r2, #4
 80274ae:	2800      	cmp	r0, #0
 80274b0:	f171 0300 	sbcs.w	r3, r1, #0
 80274b4:	920f      	str	r2, [sp, #60]	; 0x3c
 80274b6:	f6bf ae96 	bge.w	80271e6 <_svfprintf_r+0x276>
 80274ba:	232d      	movs	r3, #45	; 0x2d
 80274bc:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
 80274c0:	f1d8 0800 	rsbs	r8, r8, #0
 80274c4:	eb69 0949 	sbc.w	r9, r9, r9, lsl #1
 80274c8:	2301      	movs	r3, #1
 80274ca:	e68d      	b.n	80271e8 <_svfprintf_r+0x278>
 80274cc:	9b07      	ldr	r3, [sp, #28]
 80274ce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80274d2:	9307      	str	r3, [sp, #28]
 80274d4:	f89b 3000 	ldrb.w	r3, [fp]
 80274d8:	e5a9      	b.n	802702e <_svfprintf_r+0xbe>
 80274da:	9313      	str	r3, [sp, #76]	; 0x4c
 80274dc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80274de:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80274e0:	681b      	ldr	r3, [r3, #0]
 80274e2:	2001      	movs	r0, #1
 80274e4:	2100      	movs	r1, #0
 80274e6:	3204      	adds	r2, #4
 80274e8:	9008      	str	r0, [sp, #32]
 80274ea:	f88d 1107 	strb.w	r1, [sp, #263]	; 0x107
 80274ee:	920f      	str	r2, [sp, #60]	; 0x3c
 80274f0:	f88d 30b4 	strb.w	r3, [sp, #180]	; 0xb4
 80274f4:	900d      	str	r0, [sp, #52]	; 0x34
 80274f6:	f10d 0ab4 	add.w	sl, sp, #180	; 0xb4
 80274fa:	e7c2      	b.n	8027482 <_svfprintf_r+0x512>
 80274fc:	9a07      	ldr	r2, [sp, #28]
 80274fe:	9313      	str	r3, [sp, #76]	; 0x4c
 8027500:	f012 0320 	ands.w	r3, r2, #32
 8027504:	f47f af2f 	bne.w	8027366 <_svfprintf_r+0x3f6>
 8027508:	9807      	ldr	r0, [sp, #28]
 802750a:	f010 0210 	ands.w	r2, r0, #16
 802750e:	f000 8455 	beq.w	8027dbc <_svfprintf_r+0xe4c>
 8027512:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8027514:	680a      	ldr	r2, [r1, #0]
 8027516:	3104      	adds	r1, #4
 8027518:	4690      	mov	r8, r2
 802751a:	f04f 0900 	mov.w	r9, #0
 802751e:	910f      	str	r1, [sp, #60]	; 0x3c
 8027520:	e72b      	b.n	802737a <_svfprintf_r+0x40a>
 8027522:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8027524:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8027526:	681b      	ldr	r3, [r3, #0]
 8027528:	482d      	ldr	r0, [pc, #180]	; (80275e0 <_svfprintf_r+0x670>)
 802752a:	4698      	mov	r8, r3
 802752c:	9b07      	ldr	r3, [sp, #28]
 802752e:	901a      	str	r0, [sp, #104]	; 0x68
 8027530:	f043 0302 	orr.w	r3, r3, #2
 8027534:	2278      	movs	r2, #120	; 0x78
 8027536:	3104      	adds	r1, #4
 8027538:	9307      	str	r3, [sp, #28]
 802753a:	2330      	movs	r3, #48	; 0x30
 802753c:	f88d 3104 	strb.w	r3, [sp, #260]	; 0x104
 8027540:	f88d 2105 	strb.w	r2, [sp, #261]	; 0x105
 8027544:	910f      	str	r1, [sp, #60]	; 0x3c
 8027546:	f04f 0900 	mov.w	r9, #0
 802754a:	2302      	movs	r3, #2
 802754c:	9213      	str	r2, [sp, #76]	; 0x4c
 802754e:	e714      	b.n	802737a <_svfprintf_r+0x40a>
 8027550:	9807      	ldr	r0, [sp, #28]
 8027552:	0680      	lsls	r0, r0, #26
 8027554:	f140 8453 	bpl.w	8027dfe <_svfprintf_r+0xe8e>
 8027558:	990f      	ldr	r1, [sp, #60]	; 0x3c
 802755a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802755c:	680b      	ldr	r3, [r1, #0]
 802755e:	17d1      	asrs	r1, r2, #31
 8027560:	601a      	str	r2, [r3, #0]
 8027562:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8027564:	6059      	str	r1, [r3, #4]
 8027566:	3204      	adds	r2, #4
 8027568:	920f      	str	r2, [sp, #60]	; 0x3c
 802756a:	e52a      	b.n	8026fc2 <_svfprintf_r+0x52>
 802756c:	9313      	str	r3, [sp, #76]	; 0x4c
 802756e:	9b07      	ldr	r3, [sp, #28]
 8027570:	069b      	lsls	r3, r3, #26
 8027572:	f53f af0f 	bmi.w	8027394 <_svfprintf_r+0x424>
 8027576:	9a07      	ldr	r2, [sp, #28]
 8027578:	06d5      	lsls	r5, r2, #27
 802757a:	f100 834f 	bmi.w	8027c1c <_svfprintf_r+0xcac>
 802757e:	9907      	ldr	r1, [sp, #28]
 8027580:	0648      	lsls	r0, r1, #25
 8027582:	f140 834b 	bpl.w	8027c1c <_svfprintf_r+0xcac>
 8027586:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8027588:	f8b2 8000 	ldrh.w	r8, [r2]
 802758c:	3204      	adds	r2, #4
 802758e:	2301      	movs	r3, #1
 8027590:	f04f 0900 	mov.w	r9, #0
 8027594:	920f      	str	r2, [sp, #60]	; 0x3c
 8027596:	e6f0      	b.n	802737a <_svfprintf_r+0x40a>
 8027598:	9a07      	ldr	r2, [sp, #28]
 802759a:	f042 0201 	orr.w	r2, r2, #1
 802759e:	9207      	str	r2, [sp, #28]
 80275a0:	f89b 3000 	ldrb.w	r3, [fp]
 80275a4:	e543      	b.n	802702e <_svfprintf_r+0xbe>
 80275a6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80275a8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80275aa:	681b      	ldr	r3, [r3, #0]
 80275ac:	1d11      	adds	r1, r2, #4
 80275ae:	2b00      	cmp	r3, #0
 80275b0:	930a      	str	r3, [sp, #40]	; 0x28
 80275b2:	f6ff ad9e 	blt.w	80270f2 <_svfprintf_r+0x182>
 80275b6:	f89b 3000 	ldrb.w	r3, [fp]
 80275ba:	910f      	str	r1, [sp, #60]	; 0x3c
 80275bc:	e537      	b.n	802702e <_svfprintf_r+0xbe>
 80275be:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
 80275c2:	2b00      	cmp	r3, #0
 80275c4:	f040 8427 	bne.w	8027e16 <_svfprintf_r+0xea6>
 80275c8:	f88d 4107 	strb.w	r4, [sp, #263]	; 0x107
 80275cc:	f89b 3000 	ldrb.w	r3, [fp]
 80275d0:	e52d      	b.n	802702e <_svfprintf_r+0xbe>
 80275d2:	bf00      	nop
 80275d4:	08032d7c 	.word	0x08032d7c
 80275d8:	08032d80 	.word	0x08032d80
 80275dc:	08032d8c 	.word	0x08032d8c
 80275e0:	08032da0 	.word	0x08032da0
 80275e4:	08032dc0 	.word	0x08032dc0
 80275e8:	498d      	ldr	r1, [pc, #564]	; (8027820 <_svfprintf_r+0x8b0>)
 80275ea:	9313      	str	r3, [sp, #76]	; 0x4c
 80275ec:	9b07      	ldr	r3, [sp, #28]
 80275ee:	911a      	str	r1, [sp, #104]	; 0x68
 80275f0:	0699      	lsls	r1, r3, #26
 80275f2:	f53f aee1 	bmi.w	80273b8 <_svfprintf_r+0x448>
 80275f6:	9a07      	ldr	r2, [sp, #28]
 80275f8:	06d2      	lsls	r2, r2, #27
 80275fa:	f100 8319 	bmi.w	8027c30 <_svfprintf_r+0xcc0>
 80275fe:	9907      	ldr	r1, [sp, #28]
 8027600:	064b      	lsls	r3, r1, #25
 8027602:	f140 8315 	bpl.w	8027c30 <_svfprintf_r+0xcc0>
 8027606:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8027608:	f8b2 8000 	ldrh.w	r8, [r2]
 802760c:	3204      	adds	r2, #4
 802760e:	920f      	str	r2, [sp, #60]	; 0x3c
 8027610:	f04f 0900 	mov.w	r9, #0
 8027614:	e6d9      	b.n	80273ca <_svfprintf_r+0x45a>
 8027616:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027618:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
 802761c:	b16b      	cbz	r3, 802763a <_svfprintf_r+0x6ca>
 802761e:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027620:	ab41      	add	r3, sp, #260	; 0x104
 8027622:	3303      	adds	r3, #3
 8027624:	3401      	adds	r4, #1
 8027626:	6033      	str	r3, [r6, #0]
 8027628:	3501      	adds	r5, #1
 802762a:	2301      	movs	r3, #1
 802762c:	2c07      	cmp	r4, #7
 802762e:	6073      	str	r3, [r6, #4]
 8027630:	9539      	str	r5, [sp, #228]	; 0xe4
 8027632:	9438      	str	r4, [sp, #224]	; 0xe0
 8027634:	f300 8207 	bgt.w	8027a46 <_svfprintf_r+0xad6>
 8027638:	3608      	adds	r6, #8
 802763a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802763c:	b163      	cbz	r3, 8027658 <_svfprintf_r+0x6e8>
 802763e:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027640:	ab41      	add	r3, sp, #260	; 0x104
 8027642:	3401      	adds	r4, #1
 8027644:	6033      	str	r3, [r6, #0]
 8027646:	3502      	adds	r5, #2
 8027648:	2302      	movs	r3, #2
 802764a:	2c07      	cmp	r4, #7
 802764c:	6073      	str	r3, [r6, #4]
 802764e:	9539      	str	r5, [sp, #228]	; 0xe4
 8027650:	9438      	str	r4, [sp, #224]	; 0xe0
 8027652:	f300 8203 	bgt.w	8027a5c <_svfprintf_r+0xaec>
 8027656:	3608      	adds	r6, #8
 8027658:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802765a:	2b80      	cmp	r3, #128	; 0x80
 802765c:	f000 8141 	beq.w	80278e2 <_svfprintf_r+0x972>
 8027660:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027662:	980d      	ldr	r0, [sp, #52]	; 0x34
 8027664:	1a1f      	subs	r7, r3, r0
 8027666:	2f00      	cmp	r7, #0
 8027668:	dd35      	ble.n	80276d6 <_svfprintf_r+0x766>
 802766a:	2f10      	cmp	r7, #16
 802766c:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 802766e:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 8027824 <_svfprintf_r+0x8b4>
 8027672:	dd25      	ble.n	80276c0 <_svfprintf_r+0x750>
 8027674:	4623      	mov	r3, r4
 8027676:	462a      	mov	r2, r5
 8027678:	4644      	mov	r4, r8
 802767a:	f04f 0910 	mov.w	r9, #16
 802767e:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8027680:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8027684:	e003      	b.n	802768e <_svfprintf_r+0x71e>
 8027686:	3f10      	subs	r7, #16
 8027688:	3608      	adds	r6, #8
 802768a:	2f10      	cmp	r7, #16
 802768c:	dd15      	ble.n	80276ba <_svfprintf_r+0x74a>
 802768e:	3301      	adds	r3, #1
 8027690:	3210      	adds	r2, #16
 8027692:	2b07      	cmp	r3, #7
 8027694:	e886 0210 	stmia.w	r6, {r4, r9}
 8027698:	9239      	str	r2, [sp, #228]	; 0xe4
 802769a:	9338      	str	r3, [sp, #224]	; 0xe0
 802769c:	ddf3      	ble.n	8027686 <_svfprintf_r+0x716>
 802769e:	4640      	mov	r0, r8
 80276a0:	4629      	mov	r1, r5
 80276a2:	aa37      	add	r2, sp, #220	; 0xdc
 80276a4:	f004 f850 	bl	802b748 <__ssprint_r>
 80276a8:	2800      	cmp	r0, #0
 80276aa:	f47f ad3e 	bne.w	802712a <_svfprintf_r+0x1ba>
 80276ae:	3f10      	subs	r7, #16
 80276b0:	2f10      	cmp	r7, #16
 80276b2:	9a39      	ldr	r2, [sp, #228]	; 0xe4
 80276b4:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 80276b6:	ae1d      	add	r6, sp, #116	; 0x74
 80276b8:	dce9      	bgt.n	802768e <_svfprintf_r+0x71e>
 80276ba:	46a0      	mov	r8, r4
 80276bc:	4615      	mov	r5, r2
 80276be:	461c      	mov	r4, r3
 80276c0:	3401      	adds	r4, #1
 80276c2:	19ed      	adds	r5, r5, r7
 80276c4:	2c07      	cmp	r4, #7
 80276c6:	f8c6 8000 	str.w	r8, [r6]
 80276ca:	6077      	str	r7, [r6, #4]
 80276cc:	9539      	str	r5, [sp, #228]	; 0xe4
 80276ce:	9438      	str	r4, [sp, #224]	; 0xe0
 80276d0:	f300 81ae 	bgt.w	8027a30 <_svfprintf_r+0xac0>
 80276d4:	3608      	adds	r6, #8
 80276d6:	9907      	ldr	r1, [sp, #28]
 80276d8:	05ca      	lsls	r2, r1, #23
 80276da:	f100 80a7 	bmi.w	802782c <_svfprintf_r+0x8bc>
 80276de:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 80276e0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80276e2:	f8c6 a000 	str.w	sl, [r6]
 80276e6:	3401      	adds	r4, #1
 80276e8:	18ed      	adds	r5, r5, r3
 80276ea:	2c07      	cmp	r4, #7
 80276ec:	6073      	str	r3, [r6, #4]
 80276ee:	9539      	str	r5, [sp, #228]	; 0xe4
 80276f0:	9438      	str	r4, [sp, #224]	; 0xe0
 80276f2:	dc5e      	bgt.n	80277b2 <_svfprintf_r+0x842>
 80276f4:	3608      	adds	r6, #8
 80276f6:	9a07      	ldr	r2, [sp, #28]
 80276f8:	0753      	lsls	r3, r2, #29
 80276fa:	d540      	bpl.n	802777e <_svfprintf_r+0x80e>
 80276fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80276fe:	9808      	ldr	r0, [sp, #32]
 8027700:	1a1f      	subs	r7, r3, r0
 8027702:	2f00      	cmp	r7, #0
 8027704:	dd3b      	ble.n	802777e <_svfprintf_r+0x80e>
 8027706:	2f10      	cmp	r7, #16
 8027708:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 802770a:	f8df 811c 	ldr.w	r8, [pc, #284]	; 8027828 <_svfprintf_r+0x8b8>
 802770e:	dd24      	ble.n	802775a <_svfprintf_r+0x7ea>
 8027710:	4623      	mov	r3, r4
 8027712:	f04f 0910 	mov.w	r9, #16
 8027716:	4644      	mov	r4, r8
 8027718:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 802771c:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8027720:	e003      	b.n	802772a <_svfprintf_r+0x7ba>
 8027722:	3f10      	subs	r7, #16
 8027724:	3608      	adds	r6, #8
 8027726:	2f10      	cmp	r7, #16
 8027728:	dd15      	ble.n	8027756 <_svfprintf_r+0x7e6>
 802772a:	3301      	adds	r3, #1
 802772c:	3510      	adds	r5, #16
 802772e:	2b07      	cmp	r3, #7
 8027730:	e886 0210 	stmia.w	r6, {r4, r9}
 8027734:	9539      	str	r5, [sp, #228]	; 0xe4
 8027736:	9338      	str	r3, [sp, #224]	; 0xe0
 8027738:	ddf3      	ble.n	8027722 <_svfprintf_r+0x7b2>
 802773a:	4640      	mov	r0, r8
 802773c:	4651      	mov	r1, sl
 802773e:	aa37      	add	r2, sp, #220	; 0xdc
 8027740:	f004 f802 	bl	802b748 <__ssprint_r>
 8027744:	2800      	cmp	r0, #0
 8027746:	f47f acf0 	bne.w	802712a <_svfprintf_r+0x1ba>
 802774a:	3f10      	subs	r7, #16
 802774c:	2f10      	cmp	r7, #16
 802774e:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027750:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 8027752:	ae1d      	add	r6, sp, #116	; 0x74
 8027754:	dce9      	bgt.n	802772a <_svfprintf_r+0x7ba>
 8027756:	46a0      	mov	r8, r4
 8027758:	461c      	mov	r4, r3
 802775a:	3401      	adds	r4, #1
 802775c:	197d      	adds	r5, r7, r5
 802775e:	2c07      	cmp	r4, #7
 8027760:	f8c6 8000 	str.w	r8, [r6]
 8027764:	6077      	str	r7, [r6, #4]
 8027766:	9539      	str	r5, [sp, #228]	; 0xe4
 8027768:	9438      	str	r4, [sp, #224]	; 0xe0
 802776a:	dd08      	ble.n	802777e <_svfprintf_r+0x80e>
 802776c:	980c      	ldr	r0, [sp, #48]	; 0x30
 802776e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027770:	aa37      	add	r2, sp, #220	; 0xdc
 8027772:	f003 ffe9 	bl	802b748 <__ssprint_r>
 8027776:	2800      	cmp	r0, #0
 8027778:	f47f acd7 	bne.w	802712a <_svfprintf_r+0x1ba>
 802777c:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 802777e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8027780:	9a08      	ldr	r2, [sp, #32]
 8027782:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027784:	429a      	cmp	r2, r3
 8027786:	bfac      	ite	ge
 8027788:	1889      	addge	r1, r1, r2
 802778a:	18c9      	addlt	r1, r1, r3
 802778c:	910b      	str	r1, [sp, #44]	; 0x2c
 802778e:	2d00      	cmp	r5, #0
 8027790:	f040 8144 	bne.w	8027a1c <_svfprintf_r+0xaac>
 8027794:	2000      	movs	r0, #0
 8027796:	9038      	str	r0, [sp, #224]	; 0xe0
 8027798:	ae1d      	add	r6, sp, #116	; 0x74
 802779a:	e412      	b.n	8026fc2 <_svfprintf_r+0x52>
 802779c:	46a0      	mov	r8, r4
 802779e:	461c      	mov	r4, r3
 80277a0:	3401      	adds	r4, #1
 80277a2:	19ed      	adds	r5, r5, r7
 80277a4:	2c07      	cmp	r4, #7
 80277a6:	f8c6 8000 	str.w	r8, [r6]
 80277aa:	6077      	str	r7, [r6, #4]
 80277ac:	9539      	str	r5, [sp, #228]	; 0xe4
 80277ae:	9438      	str	r4, [sp, #224]	; 0xe0
 80277b0:	dda0      	ble.n	80276f4 <_svfprintf_r+0x784>
 80277b2:	980c      	ldr	r0, [sp, #48]	; 0x30
 80277b4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80277b6:	aa37      	add	r2, sp, #220	; 0xdc
 80277b8:	f003 ffc6 	bl	802b748 <__ssprint_r>
 80277bc:	2800      	cmp	r0, #0
 80277be:	f47f acb4 	bne.w	802712a <_svfprintf_r+0x1ba>
 80277c2:	ae1d      	add	r6, sp, #116	; 0x74
 80277c4:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 80277c6:	e796      	b.n	80276f6 <_svfprintf_r+0x786>
 80277c8:	2b01      	cmp	r3, #1
 80277ca:	f000 8173 	beq.w	8027ab4 <_svfprintf_r+0xb44>
 80277ce:	2b02      	cmp	r3, #2
 80277d0:	f000 8154 	beq.w	8027a7c <_svfprintf_r+0xb0c>
 80277d4:	ac37      	add	r4, sp, #220	; 0xdc
 80277d6:	4623      	mov	r3, r4
 80277d8:	e000      	b.n	80277dc <_svfprintf_r+0x86c>
 80277da:	4653      	mov	r3, sl
 80277dc:	ea4f 02d8 	mov.w	r2, r8, lsr #3
 80277e0:	ea42 7249 	orr.w	r2, r2, r9, lsl #29
 80277e4:	ea4f 01d9 	mov.w	r1, r9, lsr #3
 80277e8:	f008 0007 	and.w	r0, r8, #7
 80277ec:	4689      	mov	r9, r1
 80277ee:	4690      	mov	r8, r2
 80277f0:	f100 0230 	add.w	r2, r0, #48	; 0x30
 80277f4:	ea58 0009 	orrs.w	r0, r8, r9
 80277f8:	f803 2c01 	strb.w	r2, [r3, #-1]
 80277fc:	f103 3aff 	add.w	sl, r3, #4294967295
 8027800:	d1eb      	bne.n	80277da <_svfprintf_r+0x86a>
 8027802:	9907      	ldr	r1, [sp, #28]
 8027804:	07c8      	lsls	r0, r1, #31
 8027806:	d506      	bpl.n	8027816 <_svfprintf_r+0x8a6>
 8027808:	2a30      	cmp	r2, #48	; 0x30
 802780a:	d004      	beq.n	8027816 <_svfprintf_r+0x8a6>
 802780c:	2230      	movs	r2, #48	; 0x30
 802780e:	f1a3 0a02 	sub.w	sl, r3, #2
 8027812:	f803 2c02 	strb.w	r2, [r3, #-2]
 8027816:	ebca 0404 	rsb	r4, sl, r4
 802781a:	940d      	str	r4, [sp, #52]	; 0x34
 802781c:	e4ff      	b.n	802721e <_svfprintf_r+0x2ae>
 802781e:	bf00      	nop
 8027820:	08032da0 	.word	0x08032da0
 8027824:	08032d6c 	.word	0x08032d6c
 8027828:	08032dc0 	.word	0x08032dc0
 802782c:	9813      	ldr	r0, [sp, #76]	; 0x4c
 802782e:	2865      	cmp	r0, #101	; 0x65
 8027830:	f340 8094 	ble.w	802795c <_svfprintf_r+0x9ec>
 8027834:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 8027838:	2200      	movs	r2, #0
 802783a:	2300      	movs	r3, #0
 802783c:	f7fb fdf6 	bl	802342c <__aeabi_dcmpeq>
 8027840:	2800      	cmp	r0, #0
 8027842:	f000 814d 	beq.w	8027ae0 <_svfprintf_r+0xb70>
 8027846:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027848:	4ba3      	ldr	r3, [pc, #652]	; (8027ad8 <_svfprintf_r+0xb68>)
 802784a:	3401      	adds	r4, #1
 802784c:	6033      	str	r3, [r6, #0]
 802784e:	3501      	adds	r5, #1
 8027850:	2301      	movs	r3, #1
 8027852:	2c07      	cmp	r4, #7
 8027854:	6073      	str	r3, [r6, #4]
 8027856:	9539      	str	r5, [sp, #228]	; 0xe4
 8027858:	9438      	str	r4, [sp, #224]	; 0xe0
 802785a:	f300 82ef 	bgt.w	8027e3c <_svfprintf_r+0xecc>
 802785e:	3608      	adds	r6, #8
 8027860:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 8027862:	990e      	ldr	r1, [sp, #56]	; 0x38
 8027864:	428b      	cmp	r3, r1
 8027866:	db03      	blt.n	8027870 <_svfprintf_r+0x900>
 8027868:	9a07      	ldr	r2, [sp, #28]
 802786a:	07d3      	lsls	r3, r2, #31
 802786c:	f57f af43 	bpl.w	80276f6 <_svfprintf_r+0x786>
 8027870:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027872:	9816      	ldr	r0, [sp, #88]	; 0x58
 8027874:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8027876:	6070      	str	r0, [r6, #4]
 8027878:	3401      	adds	r4, #1
 802787a:	182d      	adds	r5, r5, r0
 802787c:	2c07      	cmp	r4, #7
 802787e:	6033      	str	r3, [r6, #0]
 8027880:	9539      	str	r5, [sp, #228]	; 0xe4
 8027882:	9438      	str	r4, [sp, #224]	; 0xe0
 8027884:	f300 8345 	bgt.w	8027f12 <_svfprintf_r+0xfa2>
 8027888:	3608      	adds	r6, #8
 802788a:	990e      	ldr	r1, [sp, #56]	; 0x38
 802788c:	1e4f      	subs	r7, r1, #1
 802788e:	2f00      	cmp	r7, #0
 8027890:	f77f af31 	ble.w	80276f6 <_svfprintf_r+0x786>
 8027894:	2f10      	cmp	r7, #16
 8027896:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027898:	f8df 8240 	ldr.w	r8, [pc, #576]	; 8027adc <_svfprintf_r+0xb6c>
 802789c:	dd80      	ble.n	80277a0 <_svfprintf_r+0x830>
 802789e:	4623      	mov	r3, r4
 80278a0:	f04f 0910 	mov.w	r9, #16
 80278a4:	4644      	mov	r4, r8
 80278a6:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 80278aa:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 80278ae:	e004      	b.n	80278ba <_svfprintf_r+0x94a>
 80278b0:	3608      	adds	r6, #8
 80278b2:	3f10      	subs	r7, #16
 80278b4:	2f10      	cmp	r7, #16
 80278b6:	f77f af71 	ble.w	802779c <_svfprintf_r+0x82c>
 80278ba:	3301      	adds	r3, #1
 80278bc:	3510      	adds	r5, #16
 80278be:	2b07      	cmp	r3, #7
 80278c0:	e886 0210 	stmia.w	r6, {r4, r9}
 80278c4:	9539      	str	r5, [sp, #228]	; 0xe4
 80278c6:	9338      	str	r3, [sp, #224]	; 0xe0
 80278c8:	ddf2      	ble.n	80278b0 <_svfprintf_r+0x940>
 80278ca:	4640      	mov	r0, r8
 80278cc:	4651      	mov	r1, sl
 80278ce:	aa37      	add	r2, sp, #220	; 0xdc
 80278d0:	f003 ff3a 	bl	802b748 <__ssprint_r>
 80278d4:	2800      	cmp	r0, #0
 80278d6:	f47f ac28 	bne.w	802712a <_svfprintf_r+0x1ba>
 80278da:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 80278dc:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 80278de:	ae1d      	add	r6, sp, #116	; 0x74
 80278e0:	e7e7      	b.n	80278b2 <_svfprintf_r+0x942>
 80278e2:	980a      	ldr	r0, [sp, #40]	; 0x28
 80278e4:	9908      	ldr	r1, [sp, #32]
 80278e6:	1a47      	subs	r7, r0, r1
 80278e8:	2f00      	cmp	r7, #0
 80278ea:	f77f aeb9 	ble.w	8027660 <_svfprintf_r+0x6f0>
 80278ee:	2f10      	cmp	r7, #16
 80278f0:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 80278f2:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 8027adc <_svfprintf_r+0xb6c>
 80278f6:	dd25      	ble.n	8027944 <_svfprintf_r+0x9d4>
 80278f8:	4623      	mov	r3, r4
 80278fa:	462a      	mov	r2, r5
 80278fc:	4644      	mov	r4, r8
 80278fe:	f04f 0910 	mov.w	r9, #16
 8027902:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8027904:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8027908:	e003      	b.n	8027912 <_svfprintf_r+0x9a2>
 802790a:	3f10      	subs	r7, #16
 802790c:	3608      	adds	r6, #8
 802790e:	2f10      	cmp	r7, #16
 8027910:	dd15      	ble.n	802793e <_svfprintf_r+0x9ce>
 8027912:	3301      	adds	r3, #1
 8027914:	3210      	adds	r2, #16
 8027916:	2b07      	cmp	r3, #7
 8027918:	e886 0210 	stmia.w	r6, {r4, r9}
 802791c:	9239      	str	r2, [sp, #228]	; 0xe4
 802791e:	9338      	str	r3, [sp, #224]	; 0xe0
 8027920:	ddf3      	ble.n	802790a <_svfprintf_r+0x99a>
 8027922:	4640      	mov	r0, r8
 8027924:	4629      	mov	r1, r5
 8027926:	aa37      	add	r2, sp, #220	; 0xdc
 8027928:	f003 ff0e 	bl	802b748 <__ssprint_r>
 802792c:	2800      	cmp	r0, #0
 802792e:	f47f abfc 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027932:	3f10      	subs	r7, #16
 8027934:	2f10      	cmp	r7, #16
 8027936:	9a39      	ldr	r2, [sp, #228]	; 0xe4
 8027938:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 802793a:	ae1d      	add	r6, sp, #116	; 0x74
 802793c:	dce9      	bgt.n	8027912 <_svfprintf_r+0x9a2>
 802793e:	46a0      	mov	r8, r4
 8027940:	4615      	mov	r5, r2
 8027942:	461c      	mov	r4, r3
 8027944:	3401      	adds	r4, #1
 8027946:	19ed      	adds	r5, r5, r7
 8027948:	2c07      	cmp	r4, #7
 802794a:	f8c6 8000 	str.w	r8, [r6]
 802794e:	6077      	str	r7, [r6, #4]
 8027950:	9539      	str	r5, [sp, #228]	; 0xe4
 8027952:	9438      	str	r4, [sp, #224]	; 0xe0
 8027954:	f300 820c 	bgt.w	8027d70 <_svfprintf_r+0xe00>
 8027958:	3608      	adds	r6, #8
 802795a:	e681      	b.n	8027660 <_svfprintf_r+0x6f0>
 802795c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802795e:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027960:	2a01      	cmp	r2, #1
 8027962:	f340 81d2 	ble.w	8027d0a <_svfprintf_r+0xd9a>
 8027966:	3401      	adds	r4, #1
 8027968:	3501      	adds	r5, #1
 802796a:	2301      	movs	r3, #1
 802796c:	2c07      	cmp	r4, #7
 802796e:	f8c6 a000 	str.w	sl, [r6]
 8027972:	6073      	str	r3, [r6, #4]
 8027974:	9539      	str	r5, [sp, #228]	; 0xe4
 8027976:	9438      	str	r4, [sp, #224]	; 0xe0
 8027978:	f300 81e2 	bgt.w	8027d40 <_svfprintf_r+0xdd0>
 802797c:	3608      	adds	r6, #8
 802797e:	9816      	ldr	r0, [sp, #88]	; 0x58
 8027980:	9914      	ldr	r1, [sp, #80]	; 0x50
 8027982:	6070      	str	r0, [r6, #4]
 8027984:	3401      	adds	r4, #1
 8027986:	182d      	adds	r5, r5, r0
 8027988:	2c07      	cmp	r4, #7
 802798a:	6031      	str	r1, [r6, #0]
 802798c:	9539      	str	r5, [sp, #228]	; 0xe4
 802798e:	9438      	str	r4, [sp, #224]	; 0xe0
 8027990:	f300 81e2 	bgt.w	8027d58 <_svfprintf_r+0xde8>
 8027994:	3608      	adds	r6, #8
 8027996:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 802799a:	2200      	movs	r2, #0
 802799c:	2300      	movs	r3, #0
 802799e:	f7fb fd45 	bl	802342c <__aeabi_dcmpeq>
 80279a2:	2800      	cmp	r0, #0
 80279a4:	f040 80f0 	bne.w	8027b88 <_svfprintf_r+0xc18>
 80279a8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80279aa:	3401      	adds	r4, #1
 80279ac:	1e5a      	subs	r2, r3, #1
 80279ae:	18ad      	adds	r5, r5, r2
 80279b0:	f10a 0301 	add.w	r3, sl, #1
 80279b4:	2c07      	cmp	r4, #7
 80279b6:	6033      	str	r3, [r6, #0]
 80279b8:	6072      	str	r2, [r6, #4]
 80279ba:	9539      	str	r5, [sp, #228]	; 0xe4
 80279bc:	9438      	str	r4, [sp, #224]	; 0xe0
 80279be:	dc21      	bgt.n	8027a04 <_svfprintf_r+0xa94>
 80279c0:	3608      	adds	r6, #8
 80279c2:	991b      	ldr	r1, [sp, #108]	; 0x6c
 80279c4:	3401      	adds	r4, #1
 80279c6:	186d      	adds	r5, r5, r1
 80279c8:	ab3a      	add	r3, sp, #232	; 0xe8
 80279ca:	2c07      	cmp	r4, #7
 80279cc:	6033      	str	r3, [r6, #0]
 80279ce:	6071      	str	r1, [r6, #4]
 80279d0:	9539      	str	r5, [sp, #228]	; 0xe4
 80279d2:	9438      	str	r4, [sp, #224]	; 0xe0
 80279d4:	f77f ae8e 	ble.w	80276f4 <_svfprintf_r+0x784>
 80279d8:	980c      	ldr	r0, [sp, #48]	; 0x30
 80279da:	9909      	ldr	r1, [sp, #36]	; 0x24
 80279dc:	aa37      	add	r2, sp, #220	; 0xdc
 80279de:	f003 feb3 	bl	802b748 <__ssprint_r>
 80279e2:	2800      	cmp	r0, #0
 80279e4:	f47f aba1 	bne.w	802712a <_svfprintf_r+0x1ba>
 80279e8:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 80279ea:	ae1d      	add	r6, sp, #116	; 0x74
 80279ec:	e683      	b.n	80276f6 <_svfprintf_r+0x786>
 80279ee:	46a0      	mov	r8, r4
 80279f0:	461c      	mov	r4, r3
 80279f2:	3401      	adds	r4, #1
 80279f4:	19ed      	adds	r5, r5, r7
 80279f6:	2c07      	cmp	r4, #7
 80279f8:	f8c6 8000 	str.w	r8, [r6]
 80279fc:	6077      	str	r7, [r6, #4]
 80279fe:	9539      	str	r5, [sp, #228]	; 0xe4
 8027a00:	9438      	str	r4, [sp, #224]	; 0xe0
 8027a02:	dddd      	ble.n	80279c0 <_svfprintf_r+0xa50>
 8027a04:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027a06:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027a08:	aa37      	add	r2, sp, #220	; 0xdc
 8027a0a:	f003 fe9d 	bl	802b748 <__ssprint_r>
 8027a0e:	2800      	cmp	r0, #0
 8027a10:	f47f ab8b 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027a14:	ae1d      	add	r6, sp, #116	; 0x74
 8027a16:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027a18:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027a1a:	e7d2      	b.n	80279c2 <_svfprintf_r+0xa52>
 8027a1c:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027a1e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027a20:	aa37      	add	r2, sp, #220	; 0xdc
 8027a22:	f003 fe91 	bl	802b748 <__ssprint_r>
 8027a26:	2800      	cmp	r0, #0
 8027a28:	f43f aeb4 	beq.w	8027794 <_svfprintf_r+0x824>
 8027a2c:	f7ff bb7d 	b.w	802712a <_svfprintf_r+0x1ba>
 8027a30:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027a32:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027a34:	aa37      	add	r2, sp, #220	; 0xdc
 8027a36:	f003 fe87 	bl	802b748 <__ssprint_r>
 8027a3a:	2800      	cmp	r0, #0
 8027a3c:	f47f ab75 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027a40:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027a42:	ae1d      	add	r6, sp, #116	; 0x74
 8027a44:	e647      	b.n	80276d6 <_svfprintf_r+0x766>
 8027a46:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027a48:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027a4a:	aa37      	add	r2, sp, #220	; 0xdc
 8027a4c:	f003 fe7c 	bl	802b748 <__ssprint_r>
 8027a50:	2800      	cmp	r0, #0
 8027a52:	f47f ab6a 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027a56:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027a58:	ae1d      	add	r6, sp, #116	; 0x74
 8027a5a:	e5ee      	b.n	802763a <_svfprintf_r+0x6ca>
 8027a5c:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027a5e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027a60:	aa37      	add	r2, sp, #220	; 0xdc
 8027a62:	f003 fe71 	bl	802b748 <__ssprint_r>
 8027a66:	2800      	cmp	r0, #0
 8027a68:	f47f ab5f 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027a6c:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027a6e:	ae1d      	add	r6, sp, #116	; 0x74
 8027a70:	e5f2      	b.n	8027658 <_svfprintf_r+0x6e8>
 8027a72:	970d      	str	r7, [sp, #52]	; 0x34
 8027a74:	f10d 0adc 	add.w	sl, sp, #220	; 0xdc
 8027a78:	f7ff bbd1 	b.w	802721e <_svfprintf_r+0x2ae>
 8027a7c:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 8027a7e:	f10d 02db 	add.w	r2, sp, #219	; 0xdb
 8027a82:	f008 000f 	and.w	r0, r8, #15
 8027a86:	ea4f 1318 	mov.w	r3, r8, lsr #4
 8027a8a:	ea43 7309 	orr.w	r3, r3, r9, lsl #28
 8027a8e:	ea4f 1119 	mov.w	r1, r9, lsr #4
 8027a92:	4692      	mov	sl, r2
 8027a94:	4698      	mov	r8, r3
 8027a96:	5c22      	ldrb	r2, [r4, r0]
 8027a98:	4689      	mov	r9, r1
 8027a9a:	ea58 0109 	orrs.w	r1, r8, r9
 8027a9e:	f88a 2000 	strb.w	r2, [sl]
 8027aa2:	f10a 32ff 	add.w	r2, sl, #4294967295
 8027aa6:	d1ec      	bne.n	8027a82 <_svfprintf_r+0xb12>
 8027aa8:	ab37      	add	r3, sp, #220	; 0xdc
 8027aaa:	ebca 0303 	rsb	r3, sl, r3
 8027aae:	930d      	str	r3, [sp, #52]	; 0x34
 8027ab0:	f7ff bbb5 	b.w	802721e <_svfprintf_r+0x2ae>
 8027ab4:	f1b8 0f0a 	cmp.w	r8, #10
 8027ab8:	f179 0200 	sbcs.w	r2, r9, #0
 8027abc:	f080 8090 	bcs.w	8027be0 <_svfprintf_r+0xc70>
 8027ac0:	f108 0830 	add.w	r8, r8, #48	; 0x30
 8027ac4:	2301      	movs	r3, #1
 8027ac6:	f88d 80db 	strb.w	r8, [sp, #219]	; 0xdb
 8027aca:	930d      	str	r3, [sp, #52]	; 0x34
 8027acc:	f10d 0adb 	add.w	sl, sp, #219	; 0xdb
 8027ad0:	f7ff bba5 	b.w	802721e <_svfprintf_r+0x2ae>
 8027ad4:	2302      	movs	r3, #2
 8027ad6:	e450      	b.n	802737a <_svfprintf_r+0x40a>
 8027ad8:	08032dbc 	.word	0x08032dbc
 8027adc:	08032d6c 	.word	0x08032d6c
 8027ae0:	9f3e      	ldr	r7, [sp, #248]	; 0xf8
 8027ae2:	2f00      	cmp	r7, #0
 8027ae4:	f340 81b5 	ble.w	8027e52 <_svfprintf_r+0xee2>
 8027ae8:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8027aea:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 8027aec:	429f      	cmp	r7, r3
 8027aee:	bfa8      	it	ge
 8027af0:	461f      	movge	r7, r3
 8027af2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027af4:	2f00      	cmp	r7, #0
 8027af6:	4453      	add	r3, sl
 8027af8:	930d      	str	r3, [sp, #52]	; 0x34
 8027afa:	dd0b      	ble.n	8027b14 <_svfprintf_r+0xba4>
 8027afc:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027afe:	f8c6 a000 	str.w	sl, [r6]
 8027b02:	3401      	adds	r4, #1
 8027b04:	19ed      	adds	r5, r5, r7
 8027b06:	2c07      	cmp	r4, #7
 8027b08:	6077      	str	r7, [r6, #4]
 8027b0a:	9539      	str	r5, [sp, #228]	; 0xe4
 8027b0c:	9438      	str	r4, [sp, #224]	; 0xe0
 8027b0e:	f300 82d9 	bgt.w	80280c4 <_svfprintf_r+0x1154>
 8027b12:	3608      	adds	r6, #8
 8027b14:	9815      	ldr	r0, [sp, #84]	; 0x54
 8027b16:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
 8027b1a:	1bc7      	subs	r7, r0, r7
 8027b1c:	2f00      	cmp	r7, #0
 8027b1e:	f340 809a 	ble.w	8027c56 <_svfprintf_r+0xce6>
 8027b22:	2f10      	cmp	r7, #16
 8027b24:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027b26:	f8df 8518 	ldr.w	r8, [pc, #1304]	; 8028040 <_svfprintf_r+0x10d0>
 8027b2a:	f340 817b 	ble.w	8027e24 <_svfprintf_r+0xeb4>
 8027b2e:	4623      	mov	r3, r4
 8027b30:	462a      	mov	r2, r5
 8027b32:	4644      	mov	r4, r8
 8027b34:	f04f 0910 	mov.w	r9, #16
 8027b38:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8027b3a:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8027b3e:	e004      	b.n	8027b4a <_svfprintf_r+0xbda>
 8027b40:	3608      	adds	r6, #8
 8027b42:	3f10      	subs	r7, #16
 8027b44:	2f10      	cmp	r7, #16
 8027b46:	f340 816a 	ble.w	8027e1e <_svfprintf_r+0xeae>
 8027b4a:	3301      	adds	r3, #1
 8027b4c:	3210      	adds	r2, #16
 8027b4e:	2b07      	cmp	r3, #7
 8027b50:	e886 0210 	stmia.w	r6, {r4, r9}
 8027b54:	9239      	str	r2, [sp, #228]	; 0xe4
 8027b56:	9338      	str	r3, [sp, #224]	; 0xe0
 8027b58:	ddf2      	ble.n	8027b40 <_svfprintf_r+0xbd0>
 8027b5a:	4640      	mov	r0, r8
 8027b5c:	4629      	mov	r1, r5
 8027b5e:	aa37      	add	r2, sp, #220	; 0xdc
 8027b60:	f003 fdf2 	bl	802b748 <__ssprint_r>
 8027b64:	2800      	cmp	r0, #0
 8027b66:	f47f aae0 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027b6a:	9a39      	ldr	r2, [sp, #228]	; 0xe4
 8027b6c:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 8027b6e:	ae1d      	add	r6, sp, #116	; 0x74
 8027b70:	e7e7      	b.n	8027b42 <_svfprintf_r+0xbd2>
 8027b72:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027b74:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027b76:	aa37      	add	r2, sp, #220	; 0xdc
 8027b78:	f003 fde6 	bl	802b748 <__ssprint_r>
 8027b7c:	2800      	cmp	r0, #0
 8027b7e:	f47f aad4 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027b82:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027b84:	ae1d      	add	r6, sp, #116	; 0x74
 8027b86:	e547      	b.n	8027618 <_svfprintf_r+0x6a8>
 8027b88:	980e      	ldr	r0, [sp, #56]	; 0x38
 8027b8a:	1e47      	subs	r7, r0, #1
 8027b8c:	2f00      	cmp	r7, #0
 8027b8e:	f77f af18 	ble.w	80279c2 <_svfprintf_r+0xa52>
 8027b92:	2f10      	cmp	r7, #16
 8027b94:	f8df 84a8 	ldr.w	r8, [pc, #1192]	; 8028040 <_svfprintf_r+0x10d0>
 8027b98:	f77f af2b 	ble.w	80279f2 <_svfprintf_r+0xa82>
 8027b9c:	4623      	mov	r3, r4
 8027b9e:	f04f 0910 	mov.w	r9, #16
 8027ba2:	4644      	mov	r4, r8
 8027ba4:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 8027ba8:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8027bac:	e004      	b.n	8027bb8 <_svfprintf_r+0xc48>
 8027bae:	3608      	adds	r6, #8
 8027bb0:	3f10      	subs	r7, #16
 8027bb2:	2f10      	cmp	r7, #16
 8027bb4:	f77f af1b 	ble.w	80279ee <_svfprintf_r+0xa7e>
 8027bb8:	3301      	adds	r3, #1
 8027bba:	3510      	adds	r5, #16
 8027bbc:	2b07      	cmp	r3, #7
 8027bbe:	e886 0210 	stmia.w	r6, {r4, r9}
 8027bc2:	9539      	str	r5, [sp, #228]	; 0xe4
 8027bc4:	9338      	str	r3, [sp, #224]	; 0xe0
 8027bc6:	ddf2      	ble.n	8027bae <_svfprintf_r+0xc3e>
 8027bc8:	4640      	mov	r0, r8
 8027bca:	4651      	mov	r1, sl
 8027bcc:	aa37      	add	r2, sp, #220	; 0xdc
 8027bce:	f003 fdbb 	bl	802b748 <__ssprint_r>
 8027bd2:	2800      	cmp	r0, #0
 8027bd4:	f47f aaa9 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027bd8:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027bda:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 8027bdc:	ae1d      	add	r6, sp, #116	; 0x74
 8027bde:	e7e7      	b.n	8027bb0 <_svfprintf_r+0xc40>
 8027be0:	f10d 04db 	add.w	r4, sp, #219	; 0xdb
 8027be4:	4640      	mov	r0, r8
 8027be6:	4649      	mov	r1, r9
 8027be8:	220a      	movs	r2, #10
 8027bea:	2300      	movs	r3, #0
 8027bec:	f7fb fc78 	bl	80234e0 <__aeabi_uldivmod>
 8027bf0:	3230      	adds	r2, #48	; 0x30
 8027bf2:	7022      	strb	r2, [r4, #0]
 8027bf4:	4640      	mov	r0, r8
 8027bf6:	4649      	mov	r1, r9
 8027bf8:	220a      	movs	r2, #10
 8027bfa:	2300      	movs	r3, #0
 8027bfc:	f7fb fc70 	bl	80234e0 <__aeabi_uldivmod>
 8027c00:	4680      	mov	r8, r0
 8027c02:	4689      	mov	r9, r1
 8027c04:	ea58 0009 	orrs.w	r0, r8, r9
 8027c08:	46a2      	mov	sl, r4
 8027c0a:	f104 34ff 	add.w	r4, r4, #4294967295
 8027c0e:	d1e9      	bne.n	8027be4 <_svfprintf_r+0xc74>
 8027c10:	ab37      	add	r3, sp, #220	; 0xdc
 8027c12:	ebca 0303 	rsb	r3, sl, r3
 8027c16:	930d      	str	r3, [sp, #52]	; 0x34
 8027c18:	f7ff bb01 	b.w	802721e <_svfprintf_r+0x2ae>
 8027c1c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027c1e:	6803      	ldr	r3, [r0, #0]
 8027c20:	3004      	adds	r0, #4
 8027c22:	4698      	mov	r8, r3
 8027c24:	f04f 0900 	mov.w	r9, #0
 8027c28:	900f      	str	r0, [sp, #60]	; 0x3c
 8027c2a:	2301      	movs	r3, #1
 8027c2c:	f7ff bba5 	b.w	802737a <_svfprintf_r+0x40a>
 8027c30:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027c32:	6803      	ldr	r3, [r0, #0]
 8027c34:	3004      	adds	r0, #4
 8027c36:	4698      	mov	r8, r3
 8027c38:	f04f 0900 	mov.w	r9, #0
 8027c3c:	900f      	str	r0, [sp, #60]	; 0x3c
 8027c3e:	f7ff bbc4 	b.w	80273ca <_svfprintf_r+0x45a>
 8027c42:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027c44:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027c46:	aa37      	add	r2, sp, #220	; 0xdc
 8027c48:	f003 fd7e 	bl	802b748 <__ssprint_r>
 8027c4c:	2800      	cmp	r0, #0
 8027c4e:	f47f aa6c 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027c52:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027c54:	ae1d      	add	r6, sp, #116	; 0x74
 8027c56:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 8027c58:	990e      	ldr	r1, [sp, #56]	; 0x38
 8027c5a:	428b      	cmp	r3, r1
 8027c5c:	db47      	blt.n	8027cee <_svfprintf_r+0xd7e>
 8027c5e:	9a07      	ldr	r2, [sp, #28]
 8027c60:	07d1      	lsls	r1, r2, #31
 8027c62:	d444      	bmi.n	8027cee <_svfprintf_r+0xd7e>
 8027c64:	9815      	ldr	r0, [sp, #84]	; 0x54
 8027c66:	990d      	ldr	r1, [sp, #52]	; 0x34
 8027c68:	eb0a 0200 	add.w	r2, sl, r0
 8027c6c:	980e      	ldr	r0, [sp, #56]	; 0x38
 8027c6e:	1a8f      	subs	r7, r1, r2
 8027c70:	1ac3      	subs	r3, r0, r3
 8027c72:	42bb      	cmp	r3, r7
 8027c74:	bfb8      	it	lt
 8027c76:	461f      	movlt	r7, r3
 8027c78:	2f00      	cmp	r7, #0
 8027c7a:	dd0a      	ble.n	8027c92 <_svfprintf_r+0xd22>
 8027c7c:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027c7e:	6032      	str	r2, [r6, #0]
 8027c80:	3401      	adds	r4, #1
 8027c82:	19ed      	adds	r5, r5, r7
 8027c84:	2c07      	cmp	r4, #7
 8027c86:	6077      	str	r7, [r6, #4]
 8027c88:	9539      	str	r5, [sp, #228]	; 0xe4
 8027c8a:	9438      	str	r4, [sp, #224]	; 0xe0
 8027c8c:	f300 823f 	bgt.w	802810e <_svfprintf_r+0x119e>
 8027c90:	3608      	adds	r6, #8
 8027c92:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
 8027c96:	1bdf      	subs	r7, r3, r7
 8027c98:	2f00      	cmp	r7, #0
 8027c9a:	f77f ad2c 	ble.w	80276f6 <_svfprintf_r+0x786>
 8027c9e:	2f10      	cmp	r7, #16
 8027ca0:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027ca2:	f8df 839c 	ldr.w	r8, [pc, #924]	; 8028040 <_svfprintf_r+0x10d0>
 8027ca6:	f77f ad7b 	ble.w	80277a0 <_svfprintf_r+0x830>
 8027caa:	4623      	mov	r3, r4
 8027cac:	f04f 0910 	mov.w	r9, #16
 8027cb0:	4644      	mov	r4, r8
 8027cb2:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 8027cb6:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8027cba:	e004      	b.n	8027cc6 <_svfprintf_r+0xd56>
 8027cbc:	3608      	adds	r6, #8
 8027cbe:	3f10      	subs	r7, #16
 8027cc0:	2f10      	cmp	r7, #16
 8027cc2:	f77f ad6b 	ble.w	802779c <_svfprintf_r+0x82c>
 8027cc6:	3301      	adds	r3, #1
 8027cc8:	3510      	adds	r5, #16
 8027cca:	2b07      	cmp	r3, #7
 8027ccc:	e886 0210 	stmia.w	r6, {r4, r9}
 8027cd0:	9539      	str	r5, [sp, #228]	; 0xe4
 8027cd2:	9338      	str	r3, [sp, #224]	; 0xe0
 8027cd4:	ddf2      	ble.n	8027cbc <_svfprintf_r+0xd4c>
 8027cd6:	4640      	mov	r0, r8
 8027cd8:	4651      	mov	r1, sl
 8027cda:	aa37      	add	r2, sp, #220	; 0xdc
 8027cdc:	f003 fd34 	bl	802b748 <__ssprint_r>
 8027ce0:	2800      	cmp	r0, #0
 8027ce2:	f47f aa22 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027ce6:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027ce8:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 8027cea:	ae1d      	add	r6, sp, #116	; 0x74
 8027cec:	e7e7      	b.n	8027cbe <_svfprintf_r+0xd4e>
 8027cee:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027cf0:	9916      	ldr	r1, [sp, #88]	; 0x58
 8027cf2:	9814      	ldr	r0, [sp, #80]	; 0x50
 8027cf4:	6071      	str	r1, [r6, #4]
 8027cf6:	3401      	adds	r4, #1
 8027cf8:	186d      	adds	r5, r5, r1
 8027cfa:	2c07      	cmp	r4, #7
 8027cfc:	6030      	str	r0, [r6, #0]
 8027cfe:	9539      	str	r5, [sp, #228]	; 0xe4
 8027d00:	9438      	str	r4, [sp, #224]	; 0xe0
 8027d02:	f300 81ea 	bgt.w	80280da <_svfprintf_r+0x116a>
 8027d06:	3608      	adds	r6, #8
 8027d08:	e7ac      	b.n	8027c64 <_svfprintf_r+0xcf4>
 8027d0a:	9b07      	ldr	r3, [sp, #28]
 8027d0c:	07da      	lsls	r2, r3, #31
 8027d0e:	f53f ae2a 	bmi.w	8027966 <_svfprintf_r+0x9f6>
 8027d12:	3401      	adds	r4, #1
 8027d14:	3501      	adds	r5, #1
 8027d16:	2301      	movs	r3, #1
 8027d18:	2c07      	cmp	r4, #7
 8027d1a:	f8c6 a000 	str.w	sl, [r6]
 8027d1e:	6073      	str	r3, [r6, #4]
 8027d20:	9539      	str	r5, [sp, #228]	; 0xe4
 8027d22:	9438      	str	r4, [sp, #224]	; 0xe0
 8027d24:	f77f ae4c 	ble.w	80279c0 <_svfprintf_r+0xa50>
 8027d28:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027d2a:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027d2c:	aa37      	add	r2, sp, #220	; 0xdc
 8027d2e:	f003 fd0b 	bl	802b748 <__ssprint_r>
 8027d32:	2800      	cmp	r0, #0
 8027d34:	f47f a9f9 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027d38:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027d3a:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027d3c:	ae1d      	add	r6, sp, #116	; 0x74
 8027d3e:	e640      	b.n	80279c2 <_svfprintf_r+0xa52>
 8027d40:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027d42:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027d44:	aa37      	add	r2, sp, #220	; 0xdc
 8027d46:	f003 fcff 	bl	802b748 <__ssprint_r>
 8027d4a:	2800      	cmp	r0, #0
 8027d4c:	f47f a9ed 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027d50:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027d52:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027d54:	ae1d      	add	r6, sp, #116	; 0x74
 8027d56:	e612      	b.n	802797e <_svfprintf_r+0xa0e>
 8027d58:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027d5a:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027d5c:	aa37      	add	r2, sp, #220	; 0xdc
 8027d5e:	f003 fcf3 	bl	802b748 <__ssprint_r>
 8027d62:	2800      	cmp	r0, #0
 8027d64:	f47f a9e1 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027d68:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027d6a:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027d6c:	ae1d      	add	r6, sp, #116	; 0x74
 8027d6e:	e612      	b.n	8027996 <_svfprintf_r+0xa26>
 8027d70:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027d72:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027d74:	aa37      	add	r2, sp, #220	; 0xdc
 8027d76:	f003 fce7 	bl	802b748 <__ssprint_r>
 8027d7a:	2800      	cmp	r0, #0
 8027d7c:	f47f a9d5 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027d80:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027d82:	ae1d      	add	r6, sp, #116	; 0x74
 8027d84:	e46c      	b.n	8027660 <_svfprintf_r+0x6f0>
 8027d86:	f003 fbfb 	bl	802b580 <__fpclassifyd>
 8027d8a:	2800      	cmp	r0, #0
 8027d8c:	f040 80cc 	bne.w	8027f28 <_svfprintf_r+0xfb8>
 8027d90:	2103      	movs	r1, #3
 8027d92:	9010      	str	r0, [sp, #64]	; 0x40
 8027d94:	4aa7      	ldr	r2, [pc, #668]	; (8028034 <_svfprintf_r+0x10c4>)
 8027d96:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8027d98:	9108      	str	r1, [sp, #32]
 8027d9a:	49a7      	ldr	r1, [pc, #668]	; (8028038 <_svfprintf_r+0x10c8>)
 8027d9c:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
 8027da0:	2847      	cmp	r0, #71	; 0x47
 8027da2:	bfcc      	ite	gt
 8027da4:	468a      	movgt	sl, r1
 8027da6:	4692      	movle	sl, r2
 8027da8:	9907      	ldr	r1, [sp, #28]
 8027daa:	9810      	ldr	r0, [sp, #64]	; 0x40
 8027dac:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8027db0:	2203      	movs	r2, #3
 8027db2:	9107      	str	r1, [sp, #28]
 8027db4:	920d      	str	r2, [sp, #52]	; 0x34
 8027db6:	9015      	str	r0, [sp, #84]	; 0x54
 8027db8:	f7ff ba3b 	b.w	8027232 <_svfprintf_r+0x2c2>
 8027dbc:	9807      	ldr	r0, [sp, #28]
 8027dbe:	f010 0340 	ands.w	r3, r0, #64	; 0x40
 8027dc2:	f000 8158 	beq.w	8028076 <_svfprintf_r+0x1106>
 8027dc6:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8027dc8:	f8b1 8000 	ldrh.w	r8, [r1]
 8027dcc:	3104      	adds	r1, #4
 8027dce:	4613      	mov	r3, r2
 8027dd0:	f04f 0900 	mov.w	r9, #0
 8027dd4:	910f      	str	r1, [sp, #60]	; 0x3c
 8027dd6:	f7ff bad0 	b.w	802737a <_svfprintf_r+0x40a>
 8027dda:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027ddc:	1dc3      	adds	r3, r0, #7
 8027dde:	f023 0307 	bic.w	r3, r3, #7
 8027de2:	f103 0108 	add.w	r1, r3, #8
 8027de6:	910f      	str	r1, [sp, #60]	; 0x3c
 8027de8:	f7ff ba7f 	b.w	80272ea <_svfprintf_r+0x37a>
 8027dec:	9b07      	ldr	r3, [sp, #28]
 8027dee:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027df0:	0659      	lsls	r1, r3, #25
 8027df2:	f57f ab54 	bpl.w	802749e <_svfprintf_r+0x52e>
 8027df6:	f9b0 8000 	ldrsh.w	r8, [r0]
 8027dfa:	f7ff bb52 	b.w	80274a2 <_svfprintf_r+0x532>
 8027dfe:	9b07      	ldr	r3, [sp, #28]
 8027e00:	06d9      	lsls	r1, r3, #27
 8027e02:	f140 812d 	bpl.w	8028060 <_svfprintf_r+0x10f0>
 8027e06:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027e08:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8027e0a:	6803      	ldr	r3, [r0, #0]
 8027e0c:	3004      	adds	r0, #4
 8027e0e:	900f      	str	r0, [sp, #60]	; 0x3c
 8027e10:	6019      	str	r1, [r3, #0]
 8027e12:	f7ff b8d6 	b.w	8026fc2 <_svfprintf_r+0x52>
 8027e16:	f89b 3000 	ldrb.w	r3, [fp]
 8027e1a:	f7ff b908 	b.w	802702e <_svfprintf_r+0xbe>
 8027e1e:	46a0      	mov	r8, r4
 8027e20:	4615      	mov	r5, r2
 8027e22:	461c      	mov	r4, r3
 8027e24:	3401      	adds	r4, #1
 8027e26:	19ed      	adds	r5, r5, r7
 8027e28:	2c07      	cmp	r4, #7
 8027e2a:	f8c6 8000 	str.w	r8, [r6]
 8027e2e:	6077      	str	r7, [r6, #4]
 8027e30:	9539      	str	r5, [sp, #228]	; 0xe4
 8027e32:	9438      	str	r4, [sp, #224]	; 0xe0
 8027e34:	f73f af05 	bgt.w	8027c42 <_svfprintf_r+0xcd2>
 8027e38:	3608      	adds	r6, #8
 8027e3a:	e70c      	b.n	8027c56 <_svfprintf_r+0xce6>
 8027e3c:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027e3e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027e40:	aa37      	add	r2, sp, #220	; 0xdc
 8027e42:	f003 fc81 	bl	802b748 <__ssprint_r>
 8027e46:	2800      	cmp	r0, #0
 8027e48:	f47f a96f 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027e4c:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027e4e:	ae1d      	add	r6, sp, #116	; 0x74
 8027e50:	e506      	b.n	8027860 <_svfprintf_r+0x8f0>
 8027e52:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027e54:	4b79      	ldr	r3, [pc, #484]	; (802803c <_svfprintf_r+0x10cc>)
 8027e56:	3401      	adds	r4, #1
 8027e58:	6033      	str	r3, [r6, #0]
 8027e5a:	3501      	adds	r5, #1
 8027e5c:	2301      	movs	r3, #1
 8027e5e:	2c07      	cmp	r4, #7
 8027e60:	6073      	str	r3, [r6, #4]
 8027e62:	9539      	str	r5, [sp, #228]	; 0xe4
 8027e64:	9438      	str	r4, [sp, #224]	; 0xe0
 8027e66:	f300 80ed 	bgt.w	8028044 <_svfprintf_r+0x10d4>
 8027e6a:	3608      	adds	r6, #8
 8027e6c:	b92f      	cbnz	r7, 8027e7a <_svfprintf_r+0xf0a>
 8027e6e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8027e70:	b91a      	cbnz	r2, 8027e7a <_svfprintf_r+0xf0a>
 8027e72:	9b07      	ldr	r3, [sp, #28]
 8027e74:	07d8      	lsls	r0, r3, #31
 8027e76:	f57f ac3e 	bpl.w	80276f6 <_svfprintf_r+0x786>
 8027e7a:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 8027e7c:	9916      	ldr	r1, [sp, #88]	; 0x58
 8027e7e:	9814      	ldr	r0, [sp, #80]	; 0x50
 8027e80:	6071      	str	r1, [r6, #4]
 8027e82:	3401      	adds	r4, #1
 8027e84:	186d      	adds	r5, r5, r1
 8027e86:	2c07      	cmp	r4, #7
 8027e88:	6030      	str	r0, [r6, #0]
 8027e8a:	9539      	str	r5, [sp, #228]	; 0xe4
 8027e8c:	9438      	str	r4, [sp, #224]	; 0xe0
 8027e8e:	f300 81fe 	bgt.w	802828e <_svfprintf_r+0x131e>
 8027e92:	3608      	adds	r6, #8
 8027e94:	427f      	negs	r7, r7
 8027e96:	2f00      	cmp	r7, #0
 8027e98:	f340 8107 	ble.w	80280aa <_svfprintf_r+0x113a>
 8027e9c:	2f10      	cmp	r7, #16
 8027e9e:	f8df 81a0 	ldr.w	r8, [pc, #416]	; 8028040 <_svfprintf_r+0x10d0>
 8027ea2:	f340 8129 	ble.w	80280f8 <_svfprintf_r+0x1188>
 8027ea6:	4623      	mov	r3, r4
 8027ea8:	462a      	mov	r2, r5
 8027eaa:	4644      	mov	r4, r8
 8027eac:	f04f 0910 	mov.w	r9, #16
 8027eb0:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8027eb2:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 8027eb6:	e004      	b.n	8027ec2 <_svfprintf_r+0xf52>
 8027eb8:	3608      	adds	r6, #8
 8027eba:	3f10      	subs	r7, #16
 8027ebc:	2f10      	cmp	r7, #16
 8027ebe:	f340 8118 	ble.w	80280f2 <_svfprintf_r+0x1182>
 8027ec2:	3301      	adds	r3, #1
 8027ec4:	3210      	adds	r2, #16
 8027ec6:	2b07      	cmp	r3, #7
 8027ec8:	e886 0210 	stmia.w	r6, {r4, r9}
 8027ecc:	9239      	str	r2, [sp, #228]	; 0xe4
 8027ece:	9338      	str	r3, [sp, #224]	; 0xe0
 8027ed0:	ddf2      	ble.n	8027eb8 <_svfprintf_r+0xf48>
 8027ed2:	4628      	mov	r0, r5
 8027ed4:	4641      	mov	r1, r8
 8027ed6:	aa37      	add	r2, sp, #220	; 0xdc
 8027ed8:	f003 fc36 	bl	802b748 <__ssprint_r>
 8027edc:	2800      	cmp	r0, #0
 8027ede:	f47f a924 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027ee2:	9a39      	ldr	r2, [sp, #228]	; 0xe4
 8027ee4:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 8027ee6:	ae1d      	add	r6, sp, #116	; 0x74
 8027ee8:	e7e7      	b.n	8027eba <_svfprintf_r+0xf4a>
 8027eea:	9907      	ldr	r1, [sp, #28]
 8027eec:	7853      	ldrb	r3, [r2, #1]
 8027eee:	f041 0120 	orr.w	r1, r1, #32
 8027ef2:	f10b 0b01 	add.w	fp, fp, #1
 8027ef6:	9107      	str	r1, [sp, #28]
 8027ef8:	f7ff b899 	b.w	802702e <_svfprintf_r+0xbe>
 8027efc:	980d      	ldr	r0, [sp, #52]	; 0x34
 8027efe:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 8027f02:	2100      	movs	r1, #0
 8027f04:	9008      	str	r0, [sp, #32]
 8027f06:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
 8027f0a:	940f      	str	r4, [sp, #60]	; 0x3c
 8027f0c:	9115      	str	r1, [sp, #84]	; 0x54
 8027f0e:	f7ff b990 	b.w	8027232 <_svfprintf_r+0x2c2>
 8027f12:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027f14:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027f16:	aa37      	add	r2, sp, #220	; 0xdc
 8027f18:	f003 fc16 	bl	802b748 <__ssprint_r>
 8027f1c:	2800      	cmp	r0, #0
 8027f1e:	f47f a904 	bne.w	802712a <_svfprintf_r+0x1ba>
 8027f22:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8027f24:	ae1d      	add	r6, sp, #116	; 0x74
 8027f26:	e4b0      	b.n	802788a <_svfprintf_r+0x91a>
 8027f28:	1c7b      	adds	r3, r7, #1
 8027f2a:	f000 8097 	beq.w	802805c <_svfprintf_r+0x10ec>
 8027f2e:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8027f30:	2967      	cmp	r1, #103	; 0x67
 8027f32:	f000 81b9 	beq.w	80282a8 <_svfprintf_r+0x1338>
 8027f36:	2947      	cmp	r1, #71	; 0x47
 8027f38:	f000 81b6 	beq.w	80282a8 <_svfprintf_r+0x1338>
 8027f3c:	9a07      	ldr	r2, [sp, #28]
 8027f3e:	2d00      	cmp	r5, #0
 8027f40:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8027f44:	9207      	str	r2, [sp, #28]
 8027f46:	f2c0 81ba 	blt.w	80282be <_svfprintf_r+0x134e>
 8027f4a:	2000      	movs	r0, #0
 8027f4c:	9010      	str	r0, [sp, #64]	; 0x40
 8027f4e:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8027f50:	2966      	cmp	r1, #102	; 0x66
 8027f52:	f000 8152 	beq.w	80281fa <_svfprintf_r+0x128a>
 8027f56:	2946      	cmp	r1, #70	; 0x46
 8027f58:	f000 814f 	beq.w	80281fa <_svfprintf_r+0x128a>
 8027f5c:	2965      	cmp	r1, #101	; 0x65
 8027f5e:	f000 81ab 	beq.w	80282b8 <_svfprintf_r+0x1348>
 8027f62:	2945      	cmp	r1, #69	; 0x45
 8027f64:	f000 81a8 	beq.w	80282b8 <_svfprintf_r+0x1348>
 8027f68:	46b9      	mov	r9, r7
 8027f6a:	2102      	movs	r1, #2
 8027f6c:	e88d 0202 	stmia.w	sp, {r1, r9}
 8027f70:	a93e      	add	r1, sp, #248	; 0xf8
 8027f72:	9102      	str	r1, [sp, #8]
 8027f74:	a93f      	add	r1, sp, #252	; 0xfc
 8027f76:	4642      	mov	r2, r8
 8027f78:	9103      	str	r1, [sp, #12]
 8027f7a:	462b      	mov	r3, r5
 8027f7c:	a940      	add	r1, sp, #256	; 0x100
 8027f7e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8027f80:	9104      	str	r1, [sp, #16]
 8027f82:	f001 f9d9 	bl	8029338 <_dtoa_r>
 8027f86:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8027f88:	2a67      	cmp	r2, #103	; 0x67
 8027f8a:	4682      	mov	sl, r0
 8027f8c:	d001      	beq.n	8027f92 <_svfprintf_r+0x1022>
 8027f8e:	2a47      	cmp	r2, #71	; 0x47
 8027f90:	d103      	bne.n	8027f9a <_svfprintf_r+0x102a>
 8027f92:	9b07      	ldr	r3, [sp, #28]
 8027f94:	07dc      	lsls	r4, r3, #31
 8027f96:	f140 81ad 	bpl.w	80282f4 <_svfprintf_r+0x1384>
 8027f9a:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8027f9c:	2846      	cmp	r0, #70	; 0x46
 8027f9e:	eb0a 0409 	add.w	r4, sl, r9
 8027fa2:	f000 813b 	beq.w	802821c <_svfprintf_r+0x12ac>
 8027fa6:	4640      	mov	r0, r8
 8027fa8:	4629      	mov	r1, r5
 8027faa:	2200      	movs	r2, #0
 8027fac:	2300      	movs	r3, #0
 8027fae:	f7fb fa3d 	bl	802342c <__aeabi_dcmpeq>
 8027fb2:	2800      	cmp	r0, #0
 8027fb4:	f000 8146 	beq.w	8028244 <_svfprintf_r+0x12d4>
 8027fb8:	9440      	str	r4, [sp, #256]	; 0x100
 8027fba:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8027fbc:	ebca 0404 	rsb	r4, sl, r4
 8027fc0:	2967      	cmp	r1, #103	; 0x67
 8027fc2:	940e      	str	r4, [sp, #56]	; 0x38
 8027fc4:	f000 80c9 	beq.w	802815a <_svfprintf_r+0x11ea>
 8027fc8:	2947      	cmp	r1, #71	; 0x47
 8027fca:	f000 80c6 	beq.w	802815a <_svfprintf_r+0x11ea>
 8027fce:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8027fd0:	993e      	ldr	r1, [sp, #248]	; 0xf8
 8027fd2:	2b66      	cmp	r3, #102	; 0x66
 8027fd4:	f040 80c9 	bne.w	802816a <_svfprintf_r+0x11fa>
 8027fd8:	2900      	cmp	r1, #0
 8027fda:	f340 81ab 	ble.w	8028334 <_svfprintf_r+0x13c4>
 8027fde:	2f00      	cmp	r7, #0
 8027fe0:	f040 81a1 	bne.w	8028326 <_svfprintf_r+0x13b6>
 8027fe4:	9a07      	ldr	r2, [sp, #28]
 8027fe6:	07d2      	lsls	r2, r2, #31
 8027fe8:	f100 819d 	bmi.w	8028326 <_svfprintf_r+0x13b6>
 8027fec:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
 8027ff0:	9308      	str	r3, [sp, #32]
 8027ff2:	910d      	str	r1, [sp, #52]	; 0x34
 8027ff4:	9115      	str	r1, [sp, #84]	; 0x54
 8027ff6:	9910      	ldr	r1, [sp, #64]	; 0x40
 8027ff8:	2900      	cmp	r1, #0
 8027ffa:	f000 80a2 	beq.w	8028142 <_svfprintf_r+0x11d2>
 8027ffe:	232d      	movs	r3, #45	; 0x2d
 8028000:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
 8028004:	2300      	movs	r3, #0
 8028006:	9310      	str	r3, [sp, #64]	; 0x40
 8028008:	f7ff b914 	b.w	8027234 <_svfprintf_r+0x2c4>
 802800c:	232d      	movs	r3, #45	; 0x2d
 802800e:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
 8028012:	f7ff b983 	b.w	802731c <_svfprintf_r+0x3ac>
 8028016:	2140      	movs	r1, #64	; 0x40
 8028018:	980c      	ldr	r0, [sp, #48]	; 0x30
 802801a:	f7fc fedd 	bl	8024dd8 <_malloc_r>
 802801e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8028020:	6008      	str	r0, [r1, #0]
 8028022:	6108      	str	r0, [r1, #16]
 8028024:	2800      	cmp	r0, #0
 8028026:	f000 81a1 	beq.w	802836c <_svfprintf_r+0x13fc>
 802802a:	9809      	ldr	r0, [sp, #36]	; 0x24
 802802c:	2340      	movs	r3, #64	; 0x40
 802802e:	6143      	str	r3, [r0, #20]
 8028030:	f7fe bfb8 	b.w	8026fa4 <_svfprintf_r+0x34>
 8028034:	08032d84 	.word	0x08032d84
 8028038:	08032d88 	.word	0x08032d88
 802803c:	08032dbc 	.word	0x08032dbc
 8028040:	08032d6c 	.word	0x08032d6c
 8028044:	980c      	ldr	r0, [sp, #48]	; 0x30
 8028046:	9909      	ldr	r1, [sp, #36]	; 0x24
 8028048:	aa37      	add	r2, sp, #220	; 0xdc
 802804a:	f003 fb7d 	bl	802b748 <__ssprint_r>
 802804e:	2800      	cmp	r0, #0
 8028050:	f47f a86b 	bne.w	802712a <_svfprintf_r+0x1ba>
 8028054:	9f3e      	ldr	r7, [sp, #248]	; 0xf8
 8028056:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8028058:	ae1d      	add	r6, sp, #116	; 0x74
 802805a:	e707      	b.n	8027e6c <_svfprintf_r+0xefc>
 802805c:	2706      	movs	r7, #6
 802805e:	e76d      	b.n	8027f3c <_svfprintf_r+0xfcc>
 8028060:	9a07      	ldr	r2, [sp, #28]
 8028062:	0652      	lsls	r2, r2, #25
 8028064:	d571      	bpl.n	802814a <_svfprintf_r+0x11da>
 8028066:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8028068:	990b      	ldr	r1, [sp, #44]	; 0x2c
 802806a:	6803      	ldr	r3, [r0, #0]
 802806c:	3004      	adds	r0, #4
 802806e:	900f      	str	r0, [sp, #60]	; 0x3c
 8028070:	8019      	strh	r1, [r3, #0]
 8028072:	f7fe bfa6 	b.w	8026fc2 <_svfprintf_r+0x52>
 8028076:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8028078:	6802      	ldr	r2, [r0, #0]
 802807a:	3004      	adds	r0, #4
 802807c:	4690      	mov	r8, r2
 802807e:	f04f 0900 	mov.w	r9, #0
 8028082:	900f      	str	r0, [sp, #60]	; 0x3c
 8028084:	f7ff b979 	b.w	802737a <_svfprintf_r+0x40a>
 8028088:	f7fe fe68 	bl	8026d5c <strlen>
 802808c:	2300      	movs	r3, #0
 802808e:	900d      	str	r0, [sp, #52]	; 0x34
 8028090:	9310      	str	r3, [sp, #64]	; 0x40
 8028092:	e734      	b.n	8027efe <_svfprintf_r+0xf8e>
 8028094:	980c      	ldr	r0, [sp, #48]	; 0x30
 8028096:	9909      	ldr	r1, [sp, #36]	; 0x24
 8028098:	aa37      	add	r2, sp, #220	; 0xdc
 802809a:	f003 fb55 	bl	802b748 <__ssprint_r>
 802809e:	2800      	cmp	r0, #0
 80280a0:	f47f a843 	bne.w	802712a <_svfprintf_r+0x1ba>
 80280a4:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 80280a6:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 80280a8:	ae1d      	add	r6, sp, #116	; 0x74
 80280aa:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80280ac:	f8c6 a000 	str.w	sl, [r6]
 80280b0:	3401      	adds	r4, #1
 80280b2:	18ad      	adds	r5, r5, r2
 80280b4:	2c07      	cmp	r4, #7
 80280b6:	6072      	str	r2, [r6, #4]
 80280b8:	9539      	str	r5, [sp, #228]	; 0xe4
 80280ba:	9438      	str	r4, [sp, #224]	; 0xe0
 80280bc:	f77f ab1a 	ble.w	80276f4 <_svfprintf_r+0x784>
 80280c0:	f7ff bb77 	b.w	80277b2 <_svfprintf_r+0x842>
 80280c4:	980c      	ldr	r0, [sp, #48]	; 0x30
 80280c6:	9909      	ldr	r1, [sp, #36]	; 0x24
 80280c8:	aa37      	add	r2, sp, #220	; 0xdc
 80280ca:	f003 fb3d 	bl	802b748 <__ssprint_r>
 80280ce:	2800      	cmp	r0, #0
 80280d0:	f47f a82b 	bne.w	802712a <_svfprintf_r+0x1ba>
 80280d4:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 80280d6:	ae1d      	add	r6, sp, #116	; 0x74
 80280d8:	e51c      	b.n	8027b14 <_svfprintf_r+0xba4>
 80280da:	980c      	ldr	r0, [sp, #48]	; 0x30
 80280dc:	9909      	ldr	r1, [sp, #36]	; 0x24
 80280de:	aa37      	add	r2, sp, #220	; 0xdc
 80280e0:	f003 fb32 	bl	802b748 <__ssprint_r>
 80280e4:	2800      	cmp	r0, #0
 80280e6:	f47f a820 	bne.w	802712a <_svfprintf_r+0x1ba>
 80280ea:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 80280ec:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 80280ee:	ae1d      	add	r6, sp, #116	; 0x74
 80280f0:	e5b8      	b.n	8027c64 <_svfprintf_r+0xcf4>
 80280f2:	46a0      	mov	r8, r4
 80280f4:	4615      	mov	r5, r2
 80280f6:	461c      	mov	r4, r3
 80280f8:	3401      	adds	r4, #1
 80280fa:	19ed      	adds	r5, r5, r7
 80280fc:	2c07      	cmp	r4, #7
 80280fe:	f8c6 8000 	str.w	r8, [r6]
 8028102:	6077      	str	r7, [r6, #4]
 8028104:	9539      	str	r5, [sp, #228]	; 0xe4
 8028106:	9438      	str	r4, [sp, #224]	; 0xe0
 8028108:	dcc4      	bgt.n	8028094 <_svfprintf_r+0x1124>
 802810a:	3608      	adds	r6, #8
 802810c:	e7cd      	b.n	80280aa <_svfprintf_r+0x113a>
 802810e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8028110:	9909      	ldr	r1, [sp, #36]	; 0x24
 8028112:	aa37      	add	r2, sp, #220	; 0xdc
 8028114:	f003 fb18 	bl	802b748 <__ssprint_r>
 8028118:	2800      	cmp	r0, #0
 802811a:	f47f a806 	bne.w	802712a <_svfprintf_r+0x1ba>
 802811e:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 8028120:	990e      	ldr	r1, [sp, #56]	; 0x38
 8028122:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 8028124:	1acb      	subs	r3, r1, r3
 8028126:	ae1d      	add	r6, sp, #116	; 0x74
 8028128:	e5b3      	b.n	8027c92 <_svfprintf_r+0xd22>
 802812a:	2f06      	cmp	r7, #6
 802812c:	bf28      	it	cs
 802812e:	2706      	movcs	r7, #6
 8028130:	ea27 73e7 	bic.w	r3, r7, r7, asr #31
 8028134:	970d      	str	r7, [sp, #52]	; 0x34
 8028136:	9308      	str	r3, [sp, #32]
 8028138:	940f      	str	r4, [sp, #60]	; 0x3c
 802813a:	f8df a24c 	ldr.w	sl, [pc, #588]	; 8028388 <_svfprintf_r+0x1418>
 802813e:	f7ff b9a0 	b.w	8027482 <_svfprintf_r+0x512>
 8028142:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
 8028146:	f7ff b874 	b.w	8027232 <_svfprintf_r+0x2c2>
 802814a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802814c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 802814e:	6813      	ldr	r3, [r2, #0]
 8028150:	3204      	adds	r2, #4
 8028152:	920f      	str	r2, [sp, #60]	; 0x3c
 8028154:	6018      	str	r0, [r3, #0]
 8028156:	f7fe bf34 	b.w	8026fc2 <_svfprintf_r+0x52>
 802815a:	993e      	ldr	r1, [sp, #248]	; 0xf8
 802815c:	1cc8      	adds	r0, r1, #3
 802815e:	db01      	blt.n	8028164 <_svfprintf_r+0x11f4>
 8028160:	428f      	cmp	r7, r1
 8028162:	da7a      	bge.n	802825a <_svfprintf_r+0x12ea>
 8028164:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8028166:	3a02      	subs	r2, #2
 8028168:	9213      	str	r2, [sp, #76]	; 0x4c
 802816a:	3901      	subs	r1, #1
 802816c:	9813      	ldr	r0, [sp, #76]	; 0x4c
 802816e:	913e      	str	r1, [sp, #248]	; 0xf8
 8028170:	2900      	cmp	r1, #0
 8028172:	f88d 00e8 	strb.w	r0, [sp, #232]	; 0xe8
 8028176:	f2c0 80d1 	blt.w	802831c <_svfprintf_r+0x13ac>
 802817a:	232b      	movs	r3, #43	; 0x2b
 802817c:	f88d 30e9 	strb.w	r3, [sp, #233]	; 0xe9
 8028180:	2909      	cmp	r1, #9
 8028182:	f340 80a1 	ble.w	80282c8 <_svfprintf_r+0x1358>
 8028186:	f10d 04f7 	add.w	r4, sp, #247	; 0xf7
 802818a:	9f17      	ldr	r7, [sp, #92]	; 0x5c
 802818c:	4620      	mov	r0, r4
 802818e:	fb87 3201 	smull	r3, r2, r7, r1
 8028192:	17cb      	asrs	r3, r1, #31
 8028194:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8028198:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 802819c:	eba1 0242 	sub.w	r2, r1, r2, lsl #1
 80281a0:	f102 0530 	add.w	r5, r2, #48	; 0x30
 80281a4:	2b09      	cmp	r3, #9
 80281a6:	4602      	mov	r2, r0
 80281a8:	4619      	mov	r1, r3
 80281aa:	f800 5d01 	strb.w	r5, [r0, #-1]!
 80281ae:	dcee      	bgt.n	802818e <_svfprintf_r+0x121e>
 80281b0:	3130      	adds	r1, #48	; 0x30
 80281b2:	b2c9      	uxtb	r1, r1
 80281b4:	f802 1d02 	strb.w	r1, [r2, #-2]!
 80281b8:	4294      	cmp	r4, r2
 80281ba:	f240 80df 	bls.w	802837c <_svfprintf_r+0x140c>
 80281be:	f10d 03ea 	add.w	r3, sp, #234	; 0xea
 80281c2:	f10d 00f6 	add.w	r0, sp, #246	; 0xf6
 80281c6:	e001      	b.n	80281cc <_svfprintf_r+0x125c>
 80281c8:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 80281cc:	f803 1b01 	strb.w	r1, [r3], #1
 80281d0:	4282      	cmp	r2, r0
 80281d2:	4619      	mov	r1, r3
 80281d4:	d1f8      	bne.n	80281c8 <_svfprintf_r+0x1258>
 80281d6:	980e      	ldr	r0, [sp, #56]	; 0x38
 80281d8:	ab3a      	add	r3, sp, #232	; 0xe8
 80281da:	1acb      	subs	r3, r1, r3
 80281dc:	931b      	str	r3, [sp, #108]	; 0x6c
 80281de:	2801      	cmp	r0, #1
 80281e0:	4403      	add	r3, r0
 80281e2:	930d      	str	r3, [sp, #52]	; 0x34
 80281e4:	f340 8088 	ble.w	80282f8 <_svfprintf_r+0x1388>
 80281e8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80281ea:	3301      	adds	r3, #1
 80281ec:	ea23 70e3 	bic.w	r0, r3, r3, asr #31
 80281f0:	2100      	movs	r1, #0
 80281f2:	930d      	str	r3, [sp, #52]	; 0x34
 80281f4:	9008      	str	r0, [sp, #32]
 80281f6:	9115      	str	r1, [sp, #84]	; 0x54
 80281f8:	e6fd      	b.n	8027ff6 <_svfprintf_r+0x1086>
 80281fa:	2103      	movs	r1, #3
 80281fc:	e88d 0082 	stmia.w	sp, {r1, r7}
 8028200:	a93e      	add	r1, sp, #248	; 0xf8
 8028202:	9102      	str	r1, [sp, #8]
 8028204:	a93f      	add	r1, sp, #252	; 0xfc
 8028206:	9103      	str	r1, [sp, #12]
 8028208:	4642      	mov	r2, r8
 802820a:	a940      	add	r1, sp, #256	; 0x100
 802820c:	462b      	mov	r3, r5
 802820e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8028210:	9104      	str	r1, [sp, #16]
 8028212:	f001 f891 	bl	8029338 <_dtoa_r>
 8028216:	46b9      	mov	r9, r7
 8028218:	4682      	mov	sl, r0
 802821a:	19c4      	adds	r4, r0, r7
 802821c:	f89a 3000 	ldrb.w	r3, [sl]
 8028220:	2b30      	cmp	r3, #48	; 0x30
 8028222:	d002      	beq.n	802822a <_svfprintf_r+0x12ba>
 8028224:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 8028226:	18e4      	adds	r4, r4, r3
 8028228:	e6bd      	b.n	8027fa6 <_svfprintf_r+0x1036>
 802822a:	4640      	mov	r0, r8
 802822c:	4629      	mov	r1, r5
 802822e:	2200      	movs	r2, #0
 8028230:	2300      	movs	r3, #0
 8028232:	f7fb f8fb 	bl	802342c <__aeabi_dcmpeq>
 8028236:	2800      	cmp	r0, #0
 8028238:	d1f4      	bne.n	8028224 <_svfprintf_r+0x12b4>
 802823a:	f1c9 0301 	rsb	r3, r9, #1
 802823e:	933e      	str	r3, [sp, #248]	; 0xf8
 8028240:	18e4      	adds	r4, r4, r3
 8028242:	e6b0      	b.n	8027fa6 <_svfprintf_r+0x1036>
 8028244:	9b40      	ldr	r3, [sp, #256]	; 0x100
 8028246:	429c      	cmp	r4, r3
 8028248:	f240 809b 	bls.w	8028382 <_svfprintf_r+0x1412>
 802824c:	2230      	movs	r2, #48	; 0x30
 802824e:	f803 2b01 	strb.w	r2, [r3], #1
 8028252:	42a3      	cmp	r3, r4
 8028254:	9340      	str	r3, [sp, #256]	; 0x100
 8028256:	d1fa      	bne.n	802824e <_svfprintf_r+0x12de>
 8028258:	e6af      	b.n	8027fba <_svfprintf_r+0x104a>
 802825a:	980e      	ldr	r0, [sp, #56]	; 0x38
 802825c:	4281      	cmp	r1, r0
 802825e:	db3b      	blt.n	80282d8 <_svfprintf_r+0x1368>
 8028260:	9a07      	ldr	r2, [sp, #28]
 8028262:	07d5      	lsls	r5, r2, #31
 8028264:	d553      	bpl.n	802830e <_svfprintf_r+0x139e>
 8028266:	1c4b      	adds	r3, r1, #1
 8028268:	ea23 70e3 	bic.w	r0, r3, r3, asr #31
 802826c:	2267      	movs	r2, #103	; 0x67
 802826e:	930d      	str	r3, [sp, #52]	; 0x34
 8028270:	9008      	str	r0, [sp, #32]
 8028272:	9213      	str	r2, [sp, #76]	; 0x4c
 8028274:	e6be      	b.n	8027ff4 <_svfprintf_r+0x1084>
 8028276:	9010      	str	r0, [sp, #64]	; 0x40
 8028278:	9910      	ldr	r1, [sp, #64]	; 0x40
 802827a:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
 802827e:	940f      	str	r4, [sp, #60]	; 0x3c
 8028280:	ea27 70e7 	bic.w	r0, r7, r7, asr #31
 8028284:	9008      	str	r0, [sp, #32]
 8028286:	970d      	str	r7, [sp, #52]	; 0x34
 8028288:	9115      	str	r1, [sp, #84]	; 0x54
 802828a:	f7fe bfd2 	b.w	8027232 <_svfprintf_r+0x2c2>
 802828e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8028290:	9909      	ldr	r1, [sp, #36]	; 0x24
 8028292:	aa37      	add	r2, sp, #220	; 0xdc
 8028294:	f003 fa58 	bl	802b748 <__ssprint_r>
 8028298:	2800      	cmp	r0, #0
 802829a:	f47e af46 	bne.w	802712a <_svfprintf_r+0x1ba>
 802829e:	9f3e      	ldr	r7, [sp, #248]	; 0xf8
 80282a0:	9d39      	ldr	r5, [sp, #228]	; 0xe4
 80282a2:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 80282a4:	ae1d      	add	r6, sp, #116	; 0x74
 80282a6:	e5f5      	b.n	8027e94 <_svfprintf_r+0xf24>
 80282a8:	2f00      	cmp	r7, #0
 80282aa:	bf08      	it	eq
 80282ac:	2701      	moveq	r7, #1
 80282ae:	e645      	b.n	8027f3c <_svfprintf_r+0xfcc>
 80282b0:	4693      	mov	fp, r2
 80282b2:	2700      	movs	r7, #0
 80282b4:	f7fe bebd 	b.w	8027032 <_svfprintf_r+0xc2>
 80282b8:	f107 0901 	add.w	r9, r7, #1
 80282bc:	e655      	b.n	8027f6a <_svfprintf_r+0xffa>
 80282be:	232d      	movs	r3, #45	; 0x2d
 80282c0:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
 80282c4:	9310      	str	r3, [sp, #64]	; 0x40
 80282c6:	e642      	b.n	8027f4e <_svfprintf_r+0xfde>
 80282c8:	3130      	adds	r1, #48	; 0x30
 80282ca:	2330      	movs	r3, #48	; 0x30
 80282cc:	f88d 10eb 	strb.w	r1, [sp, #235]	; 0xeb
 80282d0:	f88d 30ea 	strb.w	r3, [sp, #234]	; 0xea
 80282d4:	a93b      	add	r1, sp, #236	; 0xec
 80282d6:	e77e      	b.n	80281d6 <_svfprintf_r+0x1266>
 80282d8:	2900      	cmp	r1, #0
 80282da:	980e      	ldr	r0, [sp, #56]	; 0x38
 80282dc:	bfd4      	ite	le
 80282de:	f1c1 0302 	rsble	r3, r1, #2
 80282e2:	2301      	movgt	r3, #1
 80282e4:	181b      	adds	r3, r3, r0
 80282e6:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
 80282ea:	930d      	str	r3, [sp, #52]	; 0x34
 80282ec:	2367      	movs	r3, #103	; 0x67
 80282ee:	9208      	str	r2, [sp, #32]
 80282f0:	9313      	str	r3, [sp, #76]	; 0x4c
 80282f2:	e67f      	b.n	8027ff4 <_svfprintf_r+0x1084>
 80282f4:	9c40      	ldr	r4, [sp, #256]	; 0x100
 80282f6:	e660      	b.n	8027fba <_svfprintf_r+0x104a>
 80282f8:	9907      	ldr	r1, [sp, #28]
 80282fa:	f011 0301 	ands.w	r3, r1, #1
 80282fe:	f47f af73 	bne.w	80281e8 <_svfprintf_r+0x1278>
 8028302:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8028304:	9315      	str	r3, [sp, #84]	; 0x54
 8028306:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 802830a:	9208      	str	r2, [sp, #32]
 802830c:	e673      	b.n	8027ff6 <_svfprintf_r+0x1086>
 802830e:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
 8028312:	2067      	movs	r0, #103	; 0x67
 8028314:	9308      	str	r3, [sp, #32]
 8028316:	910d      	str	r1, [sp, #52]	; 0x34
 8028318:	9013      	str	r0, [sp, #76]	; 0x4c
 802831a:	e66b      	b.n	8027ff4 <_svfprintf_r+0x1084>
 802831c:	232d      	movs	r3, #45	; 0x2d
 802831e:	4249      	negs	r1, r1
 8028320:	f88d 30e9 	strb.w	r3, [sp, #233]	; 0xe9
 8028324:	e72c      	b.n	8028180 <_svfprintf_r+0x1210>
 8028326:	3701      	adds	r7, #1
 8028328:	19cf      	adds	r7, r1, r7
 802832a:	ea27 70e7 	bic.w	r0, r7, r7, asr #31
 802832e:	970d      	str	r7, [sp, #52]	; 0x34
 8028330:	9008      	str	r0, [sp, #32]
 8028332:	e65f      	b.n	8027ff4 <_svfprintf_r+0x1084>
 8028334:	b917      	cbnz	r7, 802833c <_svfprintf_r+0x13cc>
 8028336:	9a07      	ldr	r2, [sp, #28]
 8028338:	07d3      	lsls	r3, r2, #31
 802833a:	d513      	bpl.n	8028364 <_svfprintf_r+0x13f4>
 802833c:	3702      	adds	r7, #2
 802833e:	ea27 73e7 	bic.w	r3, r7, r7, asr #31
 8028342:	970d      	str	r7, [sp, #52]	; 0x34
 8028344:	9308      	str	r3, [sp, #32]
 8028346:	e655      	b.n	8027ff4 <_svfprintf_r+0x1084>
 8028348:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802834a:	681f      	ldr	r7, [r3, #0]
 802834c:	1d19      	adds	r1, r3, #4
 802834e:	2f00      	cmp	r7, #0
 8028350:	f89b 3001 	ldrb.w	r3, [fp, #1]
 8028354:	910f      	str	r1, [sp, #60]	; 0x3c
 8028356:	4693      	mov	fp, r2
 8028358:	f6be ae69 	bge.w	802702e <_svfprintf_r+0xbe>
 802835c:	f04f 37ff 	mov.w	r7, #4294967295
 8028360:	f7fe be65 	b.w	802702e <_svfprintf_r+0xbe>
 8028364:	2001      	movs	r0, #1
 8028366:	9008      	str	r0, [sp, #32]
 8028368:	900d      	str	r0, [sp, #52]	; 0x34
 802836a:	e643      	b.n	8027ff4 <_svfprintf_r+0x1084>
 802836c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802836e:	230c      	movs	r3, #12
 8028370:	6013      	str	r3, [r2, #0]
 8028372:	f04f 33ff 	mov.w	r3, #4294967295
 8028376:	930b      	str	r3, [sp, #44]	; 0x2c
 8028378:	f7fe bee0 	b.w	802713c <_svfprintf_r+0x1cc>
 802837c:	f10d 01ea 	add.w	r1, sp, #234	; 0xea
 8028380:	e729      	b.n	80281d6 <_svfprintf_r+0x1266>
 8028382:	461c      	mov	r4, r3
 8028384:	e619      	b.n	8027fba <_svfprintf_r+0x104a>
 8028386:	bf00      	nop
 8028388:	08032db4 	.word	0x08032db4

0802838c <__get_current_time_locale>:
 802838c:	4b07      	ldr	r3, [pc, #28]	; (80283ac <__get_current_time_locale+0x20>)
 802838e:	f642 52d0 	movw	r2, #11728	; 0x2dd0
 8028392:	6818      	ldr	r0, [r3, #0]
 8028394:	f643 73e0 	movw	r3, #16352	; 0x3fe0
 8028398:	f6c0 0203 	movt	r2, #2051	; 0x803
 802839c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80283a0:	2800      	cmp	r0, #0
 80283a2:	bf0c      	ite	eq
 80283a4:	4610      	moveq	r0, r2
 80283a6:	4618      	movne	r0, r3
 80283a8:	4770      	bx	lr
 80283aa:	bf00      	nop
 80283ac:	20003fdc 	.word	0x20003fdc

080283b0 <toupper>:
 80283b0:	4b04      	ldr	r3, [pc, #16]	; (80283c4 <toupper+0x14>)
 80283b2:	681b      	ldr	r3, [r3, #0]
 80283b4:	181b      	adds	r3, r3, r0
 80283b6:	785b      	ldrb	r3, [r3, #1]
 80283b8:	f003 0303 	and.w	r3, r3, #3
 80283bc:	2b02      	cmp	r3, #2
 80283be:	bf08      	it	eq
 80283c0:	3820      	subeq	r0, #32
 80283c2:	4770      	bx	lr
 80283c4:	2000092c 	.word	0x2000092c

080283c8 <__tz_lock>:
 80283c8:	4770      	bx	lr
 80283ca:	bf00      	nop

080283cc <__tz_unlock>:
 80283cc:	4770      	bx	lr
 80283ce:	bf00      	nop

080283d0 <__sprint_r>:
 80283d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80283d4:	4680      	mov	r8, r0
 80283d6:	6890      	ldr	r0, [r2, #8]
 80283d8:	4691      	mov	r9, r2
 80283da:	460e      	mov	r6, r1
 80283dc:	b348      	cbz	r0, 8028432 <__sprint_r+0x62>
 80283de:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 80283e0:	049a      	lsls	r2, r3, #18
 80283e2:	d529      	bpl.n	8028438 <__sprint_r+0x68>
 80283e4:	f8d9 3000 	ldr.w	r3, [r9]
 80283e8:	f103 0a08 	add.w	sl, r3, #8
 80283ec:	e91a 00a0 	ldmdb	sl, {r5, r7}
 80283f0:	08bf      	lsrs	r7, r7, #2
 80283f2:	b1af      	cbz	r7, 8028420 <__sprint_r+0x50>
 80283f4:	2400      	movs	r4, #0
 80283f6:	e001      	b.n	80283fc <__sprint_r+0x2c>
 80283f8:	42a7      	cmp	r7, r4
 80283fa:	d00f      	beq.n	802841c <__sprint_r+0x4c>
 80283fc:	f855 1b04 	ldr.w	r1, [r5], #4
 8028400:	4640      	mov	r0, r8
 8028402:	4632      	mov	r2, r6
 8028404:	f001 ffd4 	bl	802a3b0 <_fputwc_r>
 8028408:	3401      	adds	r4, #1
 802840a:	1c43      	adds	r3, r0, #1
 802840c:	d1f4      	bne.n	80283f8 <__sprint_r+0x28>
 802840e:	2300      	movs	r3, #0
 8028410:	f8c9 3008 	str.w	r3, [r9, #8]
 8028414:	f8c9 3004 	str.w	r3, [r9, #4]
 8028418:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802841c:	f8d9 0008 	ldr.w	r0, [r9, #8]
 8028420:	eba0 0087 	sub.w	r0, r0, r7, lsl #2
 8028424:	f8c9 0008 	str.w	r0, [r9, #8]
 8028428:	f10a 0a08 	add.w	sl, sl, #8
 802842c:	2800      	cmp	r0, #0
 802842e:	d1dd      	bne.n	80283ec <__sprint_r+0x1c>
 8028430:	e7ed      	b.n	802840e <__sprint_r+0x3e>
 8028432:	6050      	str	r0, [r2, #4]
 8028434:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028438:	4640      	mov	r0, r8
 802843a:	464a      	mov	r2, r9
 802843c:	f002 f938 	bl	802a6b0 <__sfvwrite_r>
 8028440:	2300      	movs	r3, #0
 8028442:	f8c9 3008 	str.w	r3, [r9, #8]
 8028446:	f8c9 3004 	str.w	r3, [r9, #4]
 802844a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802844e:	bf00      	nop

08028450 <_vfiprintf_r>:
 8028450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028454:	f5ad 6da0 	sub.w	sp, sp, #1280	; 0x500
 8028458:	b083      	sub	sp, #12
 802845a:	4682      	mov	sl, r0
 802845c:	460f      	mov	r7, r1
 802845e:	4616      	mov	r6, r2
 8028460:	9304      	str	r3, [sp, #16]
 8028462:	b118      	cbz	r0, 802846c <_vfiprintf_r+0x1c>
 8028464:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8028466:	2b00      	cmp	r3, #0
 8028468:	f000 84b0 	beq.w	8028dcc <_vfiprintf_r+0x97c>
 802846c:	89bd      	ldrh	r5, [r7, #12]
 802846e:	b2ab      	uxth	r3, r5
 8028470:	0499      	lsls	r1, r3, #18
 8028472:	d407      	bmi.n	8028484 <_vfiprintf_r+0x34>
 8028474:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8028476:	f445 5500 	orr.w	r5, r5, #8192	; 0x2000
 802847a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802847e:	667b      	str	r3, [r7, #100]	; 0x64
 8028480:	81bd      	strh	r5, [r7, #12]
 8028482:	b2ab      	uxth	r3, r5
 8028484:	071a      	lsls	r2, r3, #28
 8028486:	f140 83e1 	bpl.w	8028c4c <_vfiprintf_r+0x7fc>
 802848a:	693a      	ldr	r2, [r7, #16]
 802848c:	2a00      	cmp	r2, #0
 802848e:	f000 83dd 	beq.w	8028c4c <_vfiprintf_r+0x7fc>
 8028492:	f003 031a 	and.w	r3, r3, #26
 8028496:	2b0a      	cmp	r3, #10
 8028498:	f000 83e6 	beq.w	8028c68 <_vfiprintf_r+0x818>
 802849c:	2300      	movs	r3, #0
 802849e:	f50d 6092 	add.w	r0, sp, #1168	; 0x490
 80284a2:	46d3      	mov	fp, sl
 80284a4:	9309      	str	r3, [sp, #36]	; 0x24
 80284a6:	f8cd 04f8 	str.w	r0, [sp, #1272]	; 0x4f8
 80284aa:	f8cd 3500 	str.w	r3, [sp, #1280]	; 0x500
 80284ae:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 80284b2:	9302      	str	r3, [sp, #8]
 80284b4:	4604      	mov	r4, r0
 80284b6:	46ba      	mov	sl, r7
 80284b8:	7833      	ldrb	r3, [r6, #0]
 80284ba:	2b00      	cmp	r3, #0
 80284bc:	f000 833c 	beq.w	8028b38 <_vfiprintf_r+0x6e8>
 80284c0:	2b25      	cmp	r3, #37	; 0x25
 80284c2:	f000 8339 	beq.w	8028b38 <_vfiprintf_r+0x6e8>
 80284c6:	4632      	mov	r2, r6
 80284c8:	4635      	mov	r5, r6
 80284ca:	e001      	b.n	80284d0 <_vfiprintf_r+0x80>
 80284cc:	2b25      	cmp	r3, #37	; 0x25
 80284ce:	d004      	beq.n	80284da <_vfiprintf_r+0x8a>
 80284d0:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80284d4:	3501      	adds	r5, #1
 80284d6:	2b00      	cmp	r3, #0
 80284d8:	d1f8      	bne.n	80284cc <_vfiprintf_r+0x7c>
 80284da:	1baf      	subs	r7, r5, r6
 80284dc:	b197      	cbz	r7, 8028504 <_vfiprintf_r+0xb4>
 80284de:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 80284e2:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 80284e6:	6026      	str	r6, [r4, #0]
 80284e8:	3301      	adds	r3, #1
 80284ea:	19d2      	adds	r2, r2, r7
 80284ec:	2b07      	cmp	r3, #7
 80284ee:	6067      	str	r7, [r4, #4]
 80284f0:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 80284f4:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 80284f8:	f300 83fc 	bgt.w	8028cf4 <_vfiprintf_r+0x8a4>
 80284fc:	3408      	adds	r4, #8
 80284fe:	9902      	ldr	r1, [sp, #8]
 8028500:	19c9      	adds	r1, r1, r7
 8028502:	9102      	str	r1, [sp, #8]
 8028504:	782b      	ldrb	r3, [r5, #0]
 8028506:	2b00      	cmp	r3, #0
 8028508:	f000 8522 	beq.w	8028f50 <_vfiprintf_r+0xb00>
 802850c:	2300      	movs	r3, #0
 802850e:	2200      	movs	r2, #0
 8028510:	f88d 3507 	strb.w	r3, [sp, #1287]	; 0x507
 8028514:	786b      	ldrb	r3, [r5, #1]
 8028516:	9203      	str	r2, [sp, #12]
 8028518:	1c6e      	adds	r6, r5, #1
 802851a:	f04f 37ff 	mov.w	r7, #4294967295
 802851e:	9200      	str	r2, [sp, #0]
 8028520:	3601      	adds	r6, #1
 8028522:	f1a3 0120 	sub.w	r1, r3, #32
 8028526:	2958      	cmp	r1, #88	; 0x58
 8028528:	f200 81d2 	bhi.w	80288d0 <_vfiprintf_r+0x480>
 802852c:	e8df f011 	tbh	[pc, r1, lsl #1]
 8028530:	01d00202 	.word	0x01d00202
 8028534:	01fc01d0 	.word	0x01fc01d0
 8028538:	01d001d0 	.word	0x01d001d0
 802853c:	01d001d0 	.word	0x01d001d0
 8028540:	01d001d0 	.word	0x01d001d0
 8028544:	01f900ae 	.word	0x01f900ae
 8028548:	00ba01d0 	.word	0x00ba01d0
 802854c:	01d0021f 	.word	0x01d0021f
 8028550:	02080219 	.word	0x02080219
 8028554:	02080208 	.word	0x02080208
 8028558:	02080208 	.word	0x02080208
 802855c:	02080208 	.word	0x02080208
 8028560:	02080208 	.word	0x02080208
 8028564:	01d001d0 	.word	0x01d001d0
 8028568:	01d001d0 	.word	0x01d001d0
 802856c:	01d001d0 	.word	0x01d001d0
 8028570:	01d001d0 	.word	0x01d001d0
 8028574:	01d001d0 	.word	0x01d001d0
 8028578:	01d001b3 	.word	0x01d001b3
 802857c:	01d001d0 	.word	0x01d001d0
 8028580:	01d001d0 	.word	0x01d001d0
 8028584:	01d001d0 	.word	0x01d001d0
 8028588:	01d001d0 	.word	0x01d001d0
 802858c:	009a01d0 	.word	0x009a01d0
 8028590:	01d001d0 	.word	0x01d001d0
 8028594:	01d001d0 	.word	0x01d001d0
 8028598:	005901d0 	.word	0x005901d0
 802859c:	01d001d0 	.word	0x01d001d0
 80285a0:	01d00191 	.word	0x01d00191
 80285a4:	01d001d0 	.word	0x01d001d0
 80285a8:	01d001d0 	.word	0x01d001d0
 80285ac:	01d001d0 	.word	0x01d001d0
 80285b0:	01d001d0 	.word	0x01d001d0
 80285b4:	013401d0 	.word	0x013401d0
 80285b8:	01d0011d 	.word	0x01d0011d
 80285bc:	01d001d0 	.word	0x01d001d0
 80285c0:	011d0117 	.word	0x011d0117
 80285c4:	01d001d0 	.word	0x01d001d0
 80285c8:	01d0010d 	.word	0x01d0010d
 80285cc:	009e00c0 	.word	0x009e00c0
 80285d0:	00f100f7 	.word	0x00f100f7
 80285d4:	00d101d0 	.word	0x00d101d0
 80285d8:	005d01d0 	.word	0x005d01d0
 80285dc:	01d001d0 	.word	0x01d001d0
 80285e0:	01e2      	.short	0x01e2
 80285e2:	9800      	ldr	r0, [sp, #0]
 80285e4:	f040 0010 	orr.w	r0, r0, #16
 80285e8:	9000      	str	r0, [sp, #0]
 80285ea:	9900      	ldr	r1, [sp, #0]
 80285ec:	0689      	lsls	r1, r1, #26
 80285ee:	f140 8414 	bpl.w	8028e1a <_vfiprintf_r+0x9ca>
 80285f2:	9a04      	ldr	r2, [sp, #16]
 80285f4:	1dd3      	adds	r3, r2, #7
 80285f6:	f023 0307 	bic.w	r3, r3, #7
 80285fa:	f103 0008 	add.w	r0, r3, #8
 80285fe:	e9d3 8900 	ldrd	r8, r9, [r3]
 8028602:	9004      	str	r0, [sp, #16]
 8028604:	2301      	movs	r3, #1
 8028606:	2000      	movs	r0, #0
 8028608:	f88d 0507 	strb.w	r0, [sp, #1287]	; 0x507
 802860c:	2f00      	cmp	r7, #0
 802860e:	db03      	blt.n	8028618 <_vfiprintf_r+0x1c8>
 8028610:	9900      	ldr	r1, [sp, #0]
 8028612:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8028616:	9100      	str	r1, [sp, #0]
 8028618:	ea58 0209 	orrs.w	r2, r8, r9
 802861c:	f040 828e 	bne.w	8028b3c <_vfiprintf_r+0x6ec>
 8028620:	2f00      	cmp	r7, #0
 8028622:	f040 828b 	bne.w	8028b3c <_vfiprintf_r+0x6ec>
 8028626:	2b00      	cmp	r3, #0
 8028628:	f040 81bb 	bne.w	80289a2 <_vfiprintf_r+0x552>
 802862c:	9800      	ldr	r0, [sp, #0]
 802862e:	07c3      	lsls	r3, r0, #31
 8028630:	f140 81b7 	bpl.w	80289a2 <_vfiprintf_r+0x552>
 8028634:	2330      	movs	r3, #48	; 0x30
 8028636:	f88d 34f7 	strb.w	r3, [sp, #1271]	; 0x4f7
 802863a:	2301      	movs	r3, #1
 802863c:	9301      	str	r3, [sp, #4]
 802863e:	f50d 639e 	add.w	r3, sp, #1264	; 0x4f0
 8028642:	3307      	adds	r3, #7
 8028644:	9306      	str	r3, [sp, #24]
 8028646:	9705      	str	r7, [sp, #20]
 8028648:	f8dd 9004 	ldr.w	r9, [sp, #4]
 802864c:	9805      	ldr	r0, [sp, #20]
 802864e:	f89d 3507 	ldrb.w	r3, [sp, #1287]	; 0x507
 8028652:	4581      	cmp	r9, r0
 8028654:	bfb8      	it	lt
 8028656:	4681      	movlt	r9, r0
 8028658:	2b00      	cmp	r3, #0
 802865a:	f000 80b0 	beq.w	80287be <_vfiprintf_r+0x36e>
 802865e:	f109 0901 	add.w	r9, r9, #1
 8028662:	e0ac      	b.n	80287be <_vfiprintf_r+0x36e>
 8028664:	9900      	ldr	r1, [sp, #0]
 8028666:	f041 0110 	orr.w	r1, r1, #16
 802866a:	9100      	str	r1, [sp, #0]
 802866c:	9a00      	ldr	r2, [sp, #0]
 802866e:	f012 0320 	ands.w	r3, r2, #32
 8028672:	f000 83bf 	beq.w	8028df4 <_vfiprintf_r+0x9a4>
 8028676:	9804      	ldr	r0, [sp, #16]
 8028678:	1dc3      	adds	r3, r0, #7
 802867a:	f023 0307 	bic.w	r3, r3, #7
 802867e:	f103 0108 	add.w	r1, r3, #8
 8028682:	e9d3 8900 	ldrd	r8, r9, [r3]
 8028686:	9104      	str	r1, [sp, #16]
 8028688:	2300      	movs	r3, #0
 802868a:	e7bc      	b.n	8028606 <_vfiprintf_r+0x1b6>
 802868c:	9804      	ldr	r0, [sp, #16]
 802868e:	9b04      	ldr	r3, [sp, #16]
 8028690:	6800      	ldr	r0, [r0, #0]
 8028692:	1d19      	adds	r1, r3, #4
 8028694:	2800      	cmp	r0, #0
 8028696:	9003      	str	r0, [sp, #12]
 8028698:	f280 8400 	bge.w	8028e9c <_vfiprintf_r+0xa4c>
 802869c:	9803      	ldr	r0, [sp, #12]
 802869e:	9104      	str	r1, [sp, #16]
 80286a0:	4240      	negs	r0, r0
 80286a2:	9003      	str	r0, [sp, #12]
 80286a4:	9900      	ldr	r1, [sp, #0]
 80286a6:	f041 0104 	orr.w	r1, r1, #4
 80286aa:	9100      	str	r1, [sp, #0]
 80286ac:	7833      	ldrb	r3, [r6, #0]
 80286ae:	e737      	b.n	8028520 <_vfiprintf_r+0xd0>
 80286b0:	9900      	ldr	r1, [sp, #0]
 80286b2:	f88d 2507 	strb.w	r2, [sp, #1287]	; 0x507
 80286b6:	068f      	lsls	r7, r1, #26
 80286b8:	f100 8427 	bmi.w	8028f0a <_vfiprintf_r+0xaba>
 80286bc:	9800      	ldr	r0, [sp, #0]
 80286be:	06c5      	lsls	r5, r0, #27
 80286c0:	f140 8454 	bpl.w	8028f6c <_vfiprintf_r+0xb1c>
 80286c4:	9904      	ldr	r1, [sp, #16]
 80286c6:	9a02      	ldr	r2, [sp, #8]
 80286c8:	680b      	ldr	r3, [r1, #0]
 80286ca:	3104      	adds	r1, #4
 80286cc:	9104      	str	r1, [sp, #16]
 80286ce:	601a      	str	r2, [r3, #0]
 80286d0:	e6f2      	b.n	80284b8 <_vfiprintf_r+0x68>
 80286d2:	9b04      	ldr	r3, [sp, #16]
 80286d4:	9904      	ldr	r1, [sp, #16]
 80286d6:	681b      	ldr	r3, [r3, #0]
 80286d8:	2000      	movs	r0, #0
 80286da:	3104      	adds	r1, #4
 80286dc:	f88d 0507 	strb.w	r0, [sp, #1287]	; 0x507
 80286e0:	9306      	str	r3, [sp, #24]
 80286e2:	9104      	str	r1, [sp, #16]
 80286e4:	2b00      	cmp	r3, #0
 80286e6:	f000 846a 	beq.w	8028fbe <_vfiprintf_r+0xb6e>
 80286ea:	2f00      	cmp	r7, #0
 80286ec:	9806      	ldr	r0, [sp, #24]
 80286ee:	f2c0 847c 	blt.w	8028fea <_vfiprintf_r+0xb9a>
 80286f2:	2100      	movs	r1, #0
 80286f4:	463a      	mov	r2, r7
 80286f6:	f002 fa0d 	bl	802ab14 <memchr>
 80286fa:	2800      	cmp	r0, #0
 80286fc:	f000 847c 	beq.w	8028ff8 <_vfiprintf_r+0xba8>
 8028700:	9b06      	ldr	r3, [sp, #24]
 8028702:	1ac0      	subs	r0, r0, r3
 8028704:	42b8      	cmp	r0, r7
 8028706:	9001      	str	r0, [sp, #4]
 8028708:	dd00      	ble.n	802870c <_vfiprintf_r+0x2bc>
 802870a:	9701      	str	r7, [sp, #4]
 802870c:	2300      	movs	r3, #0
 802870e:	9305      	str	r3, [sp, #20]
 8028710:	e79a      	b.n	8028648 <_vfiprintf_r+0x1f8>
 8028712:	9900      	ldr	r1, [sp, #0]
 8028714:	f041 0120 	orr.w	r1, r1, #32
 8028718:	9100      	str	r1, [sp, #0]
 802871a:	7833      	ldrb	r3, [r6, #0]
 802871c:	e700      	b.n	8028520 <_vfiprintf_r+0xd0>
 802871e:	9b04      	ldr	r3, [sp, #16]
 8028720:	9904      	ldr	r1, [sp, #16]
 8028722:	681a      	ldr	r2, [r3, #0]
 8028724:	2330      	movs	r3, #48	; 0x30
 8028726:	f88d 3504 	strb.w	r3, [sp, #1284]	; 0x504
 802872a:	4690      	mov	r8, r2
 802872c:	2378      	movs	r3, #120	; 0x78
 802872e:	9a00      	ldr	r2, [sp, #0]
 8028730:	f88d 3505 	strb.w	r3, [sp, #1285]	; 0x505
 8028734:	4b9e      	ldr	r3, [pc, #632]	; (80289b0 <_vfiprintf_r+0x560>)
 8028736:	3104      	adds	r1, #4
 8028738:	f042 0202 	orr.w	r2, r2, #2
 802873c:	9309      	str	r3, [sp, #36]	; 0x24
 802873e:	9104      	str	r1, [sp, #16]
 8028740:	f04f 0900 	mov.w	r9, #0
 8028744:	9200      	str	r2, [sp, #0]
 8028746:	2302      	movs	r3, #2
 8028748:	e75d      	b.n	8028606 <_vfiprintf_r+0x1b6>
 802874a:	7833      	ldrb	r3, [r6, #0]
 802874c:	2b6c      	cmp	r3, #108	; 0x6c
 802874e:	4631      	mov	r1, r6
 8028750:	f000 83e6 	beq.w	8028f20 <_vfiprintf_r+0xad0>
 8028754:	9800      	ldr	r0, [sp, #0]
 8028756:	f040 0010 	orr.w	r0, r0, #16
 802875a:	9000      	str	r0, [sp, #0]
 802875c:	e6e0      	b.n	8028520 <_vfiprintf_r+0xd0>
 802875e:	9900      	ldr	r1, [sp, #0]
 8028760:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8028764:	9100      	str	r1, [sp, #0]
 8028766:	7833      	ldrb	r3, [r6, #0]
 8028768:	e6da      	b.n	8028520 <_vfiprintf_r+0xd0>
 802876a:	9900      	ldr	r1, [sp, #0]
 802876c:	f88d 2507 	strb.w	r2, [sp, #1287]	; 0x507
 8028770:	0689      	lsls	r1, r1, #26
 8028772:	f140 809a 	bpl.w	80288aa <_vfiprintf_r+0x45a>
 8028776:	9a04      	ldr	r2, [sp, #16]
 8028778:	1dd1      	adds	r1, r2, #7
 802877a:	f021 0107 	bic.w	r1, r1, #7
 802877e:	e9d1 2300 	ldrd	r2, r3, [r1]
 8028782:	3108      	adds	r1, #8
 8028784:	9104      	str	r1, [sp, #16]
 8028786:	4690      	mov	r8, r2
 8028788:	4699      	mov	r9, r3
 802878a:	2a00      	cmp	r2, #0
 802878c:	f173 0000 	sbcs.w	r0, r3, #0
 8028790:	f2c0 83a7 	blt.w	8028ee2 <_vfiprintf_r+0xa92>
 8028794:	2301      	movs	r3, #1
 8028796:	e739      	b.n	802860c <_vfiprintf_r+0x1bc>
 8028798:	9b04      	ldr	r3, [sp, #16]
 802879a:	9804      	ldr	r0, [sp, #16]
 802879c:	681b      	ldr	r3, [r3, #0]
 802879e:	f04f 0901 	mov.w	r9, #1
 80287a2:	2200      	movs	r2, #0
 80287a4:	3004      	adds	r0, #4
 80287a6:	f88d 34d0 	strb.w	r3, [sp, #1232]	; 0x4d0
 80287aa:	f50d 639a 	add.w	r3, sp, #1232	; 0x4d0
 80287ae:	f88d 2507 	strb.w	r2, [sp, #1287]	; 0x507
 80287b2:	9004      	str	r0, [sp, #16]
 80287b4:	f8cd 9004 	str.w	r9, [sp, #4]
 80287b8:	9306      	str	r3, [sp, #24]
 80287ba:	2300      	movs	r3, #0
 80287bc:	9305      	str	r3, [sp, #20]
 80287be:	9b00      	ldr	r3, [sp, #0]
 80287c0:	f013 0302 	ands.w	r3, r3, #2
 80287c4:	9307      	str	r3, [sp, #28]
 80287c6:	9b00      	ldr	r3, [sp, #0]
 80287c8:	bf18      	it	ne
 80287ca:	f109 0902 	addne.w	r9, r9, #2
 80287ce:	f013 0384 	ands.w	r3, r3, #132	; 0x84
 80287d2:	9308      	str	r3, [sp, #32]
 80287d4:	f040 80f2 	bne.w	80289bc <_vfiprintf_r+0x56c>
 80287d8:	9803      	ldr	r0, [sp, #12]
 80287da:	ebc9 0500 	rsb	r5, r9, r0
 80287de:	2d00      	cmp	r5, #0
 80287e0:	f340 80ec 	ble.w	80289bc <_vfiprintf_r+0x56c>
 80287e4:	2d10      	cmp	r5, #16
 80287e6:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 80287ea:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 80287ee:	4f71      	ldr	r7, [pc, #452]	; (80289b4 <_vfiprintf_r+0x564>)
 80287f0:	dd22      	ble.n	8028838 <_vfiprintf_r+0x3e8>
 80287f2:	f04f 0810 	mov.w	r8, #16
 80287f6:	e003      	b.n	8028800 <_vfiprintf_r+0x3b0>
 80287f8:	3d10      	subs	r5, #16
 80287fa:	3408      	adds	r4, #8
 80287fc:	2d10      	cmp	r5, #16
 80287fe:	dd1b      	ble.n	8028838 <_vfiprintf_r+0x3e8>
 8028800:	3301      	adds	r3, #1
 8028802:	3210      	adds	r2, #16
 8028804:	2b07      	cmp	r3, #7
 8028806:	e884 0180 	stmia.w	r4, {r7, r8}
 802880a:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 802880e:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 8028812:	ddf1      	ble.n	80287f8 <_vfiprintf_r+0x3a8>
 8028814:	4658      	mov	r0, fp
 8028816:	4651      	mov	r1, sl
 8028818:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 802881c:	f7ff fdd8 	bl	80283d0 <__sprint_r>
 8028820:	2800      	cmp	r0, #0
 8028822:	f040 81bf 	bne.w	8028ba4 <_vfiprintf_r+0x754>
 8028826:	3d10      	subs	r5, #16
 8028828:	2d10      	cmp	r5, #16
 802882a:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 802882e:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028832:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028836:	dce3      	bgt.n	8028800 <_vfiprintf_r+0x3b0>
 8028838:	3301      	adds	r3, #1
 802883a:	1952      	adds	r2, r2, r5
 802883c:	2b07      	cmp	r3, #7
 802883e:	6027      	str	r7, [r4, #0]
 8028840:	6065      	str	r5, [r4, #4]
 8028842:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 8028846:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 802884a:	f300 82c3 	bgt.w	8028dd4 <_vfiprintf_r+0x984>
 802884e:	3408      	adds	r4, #8
 8028850:	e0b8      	b.n	80289c4 <_vfiprintf_r+0x574>
 8028852:	4959      	ldr	r1, [pc, #356]	; (80289b8 <_vfiprintf_r+0x568>)
 8028854:	f88d 2507 	strb.w	r2, [sp, #1287]	; 0x507
 8028858:	9109      	str	r1, [sp, #36]	; 0x24
 802885a:	9900      	ldr	r1, [sp, #0]
 802885c:	0688      	lsls	r0, r1, #26
 802885e:	d550      	bpl.n	8028902 <_vfiprintf_r+0x4b2>
 8028860:	9804      	ldr	r0, [sp, #16]
 8028862:	1dc2      	adds	r2, r0, #7
 8028864:	f022 0207 	bic.w	r2, r2, #7
 8028868:	e9d2 8900 	ldrd	r8, r9, [r2]
 802886c:	f102 0108 	add.w	r1, r2, #8
 8028870:	9104      	str	r1, [sp, #16]
 8028872:	9900      	ldr	r1, [sp, #0]
 8028874:	07c8      	lsls	r0, r1, #31
 8028876:	f140 8099 	bpl.w	80289ac <_vfiprintf_r+0x55c>
 802887a:	ea58 0209 	orrs.w	r2, r8, r9
 802887e:	f000 8095 	beq.w	80289ac <_vfiprintf_r+0x55c>
 8028882:	2230      	movs	r2, #48	; 0x30
 8028884:	f041 0102 	orr.w	r1, r1, #2
 8028888:	f88d 3505 	strb.w	r3, [sp, #1285]	; 0x505
 802888c:	f88d 2504 	strb.w	r2, [sp, #1284]	; 0x504
 8028890:	9100      	str	r1, [sp, #0]
 8028892:	2302      	movs	r3, #2
 8028894:	e6b7      	b.n	8028606 <_vfiprintf_r+0x1b6>
 8028896:	9800      	ldr	r0, [sp, #0]
 8028898:	f88d 2507 	strb.w	r2, [sp, #1287]	; 0x507
 802889c:	f040 0010 	orr.w	r0, r0, #16
 80288a0:	9000      	str	r0, [sp, #0]
 80288a2:	9900      	ldr	r1, [sp, #0]
 80288a4:	0689      	lsls	r1, r1, #26
 80288a6:	f53f af66 	bmi.w	8028776 <_vfiprintf_r+0x326>
 80288aa:	9b00      	ldr	r3, [sp, #0]
 80288ac:	06da      	lsls	r2, r3, #27
 80288ae:	f100 830a 	bmi.w	8028ec6 <_vfiprintf_r+0xa76>
 80288b2:	9900      	ldr	r1, [sp, #0]
 80288b4:	064b      	lsls	r3, r1, #25
 80288b6:	f140 836d 	bpl.w	8028f94 <_vfiprintf_r+0xb44>
 80288ba:	9a04      	ldr	r2, [sp, #16]
 80288bc:	9804      	ldr	r0, [sp, #16]
 80288be:	f9b2 8000 	ldrsh.w	r8, [r2]
 80288c2:	3004      	adds	r0, #4
 80288c4:	ea4f 79e8 	mov.w	r9, r8, asr #31
 80288c8:	4642      	mov	r2, r8
 80288ca:	464b      	mov	r3, r9
 80288cc:	9004      	str	r0, [sp, #16]
 80288ce:	e75c      	b.n	802878a <_vfiprintf_r+0x33a>
 80288d0:	f88d 2507 	strb.w	r2, [sp, #1287]	; 0x507
 80288d4:	2b00      	cmp	r3, #0
 80288d6:	f000 833b 	beq.w	8028f50 <_vfiprintf_r+0xb00>
 80288da:	f04f 0901 	mov.w	r9, #1
 80288de:	f88d 34d0 	strb.w	r3, [sp, #1232]	; 0x4d0
 80288e2:	2000      	movs	r0, #0
 80288e4:	f50d 639a 	add.w	r3, sp, #1232	; 0x4d0
 80288e8:	f88d 0507 	strb.w	r0, [sp, #1287]	; 0x507
 80288ec:	f8cd 9004 	str.w	r9, [sp, #4]
 80288f0:	9306      	str	r3, [sp, #24]
 80288f2:	e762      	b.n	80287ba <_vfiprintf_r+0x36a>
 80288f4:	482e      	ldr	r0, [pc, #184]	; (80289b0 <_vfiprintf_r+0x560>)
 80288f6:	9900      	ldr	r1, [sp, #0]
 80288f8:	9009      	str	r0, [sp, #36]	; 0x24
 80288fa:	0688      	lsls	r0, r1, #26
 80288fc:	f88d 2507 	strb.w	r2, [sp, #1287]	; 0x507
 8028900:	d4ae      	bmi.n	8028860 <_vfiprintf_r+0x410>
 8028902:	9a00      	ldr	r2, [sp, #0]
 8028904:	06d1      	lsls	r1, r2, #27
 8028906:	f100 82cd 	bmi.w	8028ea4 <_vfiprintf_r+0xa54>
 802890a:	9900      	ldr	r1, [sp, #0]
 802890c:	064a      	lsls	r2, r1, #25
 802890e:	f140 82c9 	bpl.w	8028ea4 <_vfiprintf_r+0xa54>
 8028912:	9a04      	ldr	r2, [sp, #16]
 8028914:	f8b2 8000 	ldrh.w	r8, [r2]
 8028918:	3204      	adds	r2, #4
 802891a:	9204      	str	r2, [sp, #16]
 802891c:	f04f 0900 	mov.w	r9, #0
 8028920:	e7a7      	b.n	8028872 <_vfiprintf_r+0x422>
 8028922:	7833      	ldrb	r3, [r6, #0]
 8028924:	222b      	movs	r2, #43	; 0x2b
 8028926:	e5fb      	b.n	8028520 <_vfiprintf_r+0xd0>
 8028928:	9b00      	ldr	r3, [sp, #0]
 802892a:	f043 0301 	orr.w	r3, r3, #1
 802892e:	9300      	str	r3, [sp, #0]
 8028930:	7833      	ldrb	r3, [r6, #0]
 8028932:	e5f5      	b.n	8028520 <_vfiprintf_r+0xd0>
 8028934:	7833      	ldrb	r3, [r6, #0]
 8028936:	2a00      	cmp	r2, #0
 8028938:	f47f adf2 	bne.w	8028520 <_vfiprintf_r+0xd0>
 802893c:	2220      	movs	r2, #32
 802893e:	e5ef      	b.n	8028520 <_vfiprintf_r+0xd0>
 8028940:	4630      	mov	r0, r6
 8028942:	2100      	movs	r1, #0
 8028944:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
 8028948:	f810 3b01 	ldrb.w	r3, [r0], #1
 802894c:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
 8028950:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8028954:	2d09      	cmp	r5, #9
 8028956:	eb06 0141 	add.w	r1, r6, r1, lsl #1
 802895a:	4606      	mov	r6, r0
 802895c:	d9f2      	bls.n	8028944 <_vfiprintf_r+0x4f4>
 802895e:	9103      	str	r1, [sp, #12]
 8028960:	e5df      	b.n	8028522 <_vfiprintf_r+0xd2>
 8028962:	9800      	ldr	r0, [sp, #0]
 8028964:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8028968:	9000      	str	r0, [sp, #0]
 802896a:	7833      	ldrb	r3, [r6, #0]
 802896c:	e5d8      	b.n	8028520 <_vfiprintf_r+0xd0>
 802896e:	4630      	mov	r0, r6
 8028970:	f810 3b01 	ldrb.w	r3, [r0], #1
 8028974:	2b2a      	cmp	r3, #42	; 0x2a
 8028976:	f000 8347 	beq.w	8029008 <_vfiprintf_r+0xbb8>
 802897a:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 802897e:	2909      	cmp	r1, #9
 8028980:	f200 832f 	bhi.w	8028fe2 <_vfiprintf_r+0xb92>
 8028984:	2700      	movs	r7, #0
 8028986:	f810 3b01 	ldrb.w	r3, [r0], #1
 802898a:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 802898e:	eb01 0747 	add.w	r7, r1, r7, lsl #1
 8028992:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8028996:	2909      	cmp	r1, #9
 8028998:	4606      	mov	r6, r0
 802899a:	d9f4      	bls.n	8028986 <_vfiprintf_r+0x536>
 802899c:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 80289a0:	e5bf      	b.n	8028522 <_vfiprintf_r+0xd2>
 80289a2:	f50d 639f 	add.w	r3, sp, #1272	; 0x4f8
 80289a6:	9701      	str	r7, [sp, #4]
 80289a8:	9306      	str	r3, [sp, #24]
 80289aa:	e64c      	b.n	8028646 <_vfiprintf_r+0x1f6>
 80289ac:	2302      	movs	r3, #2
 80289ae:	e62a      	b.n	8028606 <_vfiprintf_r+0x1b6>
 80289b0:	08032da0 	.word	0x08032da0
 80289b4:	08033040 	.word	0x08033040
 80289b8:	08032d8c 	.word	0x08032d8c
 80289bc:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 80289c0:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 80289c4:	f89d 1507 	ldrb.w	r1, [sp, #1287]	; 0x507
 80289c8:	b179      	cbz	r1, 80289ea <_vfiprintf_r+0x59a>
 80289ca:	f50d 61a0 	add.w	r1, sp, #1280	; 0x500
 80289ce:	3107      	adds	r1, #7
 80289d0:	3301      	adds	r3, #1
 80289d2:	3201      	adds	r2, #1
 80289d4:	6021      	str	r1, [r4, #0]
 80289d6:	2101      	movs	r1, #1
 80289d8:	2b07      	cmp	r3, #7
 80289da:	6061      	str	r1, [r4, #4]
 80289dc:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 80289e0:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 80289e4:	f300 81d2 	bgt.w	8028d8c <_vfiprintf_r+0x93c>
 80289e8:	3408      	adds	r4, #8
 80289ea:	9907      	ldr	r1, [sp, #28]
 80289ec:	b179      	cbz	r1, 8028a0e <_vfiprintf_r+0x5be>
 80289ee:	f50d 61a0 	add.w	r1, sp, #1280	; 0x500
 80289f2:	3104      	adds	r1, #4
 80289f4:	3301      	adds	r3, #1
 80289f6:	3202      	adds	r2, #2
 80289f8:	6021      	str	r1, [r4, #0]
 80289fa:	2102      	movs	r1, #2
 80289fc:	2b07      	cmp	r3, #7
 80289fe:	6061      	str	r1, [r4, #4]
 8028a00:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 8028a04:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 8028a08:	f300 81d0 	bgt.w	8028dac <_vfiprintf_r+0x95c>
 8028a0c:	3408      	adds	r4, #8
 8028a0e:	9808      	ldr	r0, [sp, #32]
 8028a10:	2880      	cmp	r0, #128	; 0x80
 8028a12:	f000 80d6 	beq.w	8028bc2 <_vfiprintf_r+0x772>
 8028a16:	9805      	ldr	r0, [sp, #20]
 8028a18:	9901      	ldr	r1, [sp, #4]
 8028a1a:	1a45      	subs	r5, r0, r1
 8028a1c:	2d00      	cmp	r5, #0
 8028a1e:	dd31      	ble.n	8028a84 <_vfiprintf_r+0x634>
 8028a20:	2d10      	cmp	r5, #16
 8028a22:	4fb2      	ldr	r7, [pc, #712]	; (8028cec <_vfiprintf_r+0x89c>)
 8028a24:	dd22      	ble.n	8028a6c <_vfiprintf_r+0x61c>
 8028a26:	f04f 0810 	mov.w	r8, #16
 8028a2a:	e003      	b.n	8028a34 <_vfiprintf_r+0x5e4>
 8028a2c:	3d10      	subs	r5, #16
 8028a2e:	3408      	adds	r4, #8
 8028a30:	2d10      	cmp	r5, #16
 8028a32:	dd1b      	ble.n	8028a6c <_vfiprintf_r+0x61c>
 8028a34:	3301      	adds	r3, #1
 8028a36:	3210      	adds	r2, #16
 8028a38:	2b07      	cmp	r3, #7
 8028a3a:	e884 0180 	stmia.w	r4, {r7, r8}
 8028a3e:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 8028a42:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 8028a46:	ddf1      	ble.n	8028a2c <_vfiprintf_r+0x5dc>
 8028a48:	4658      	mov	r0, fp
 8028a4a:	4651      	mov	r1, sl
 8028a4c:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028a50:	f7ff fcbe 	bl	80283d0 <__sprint_r>
 8028a54:	2800      	cmp	r0, #0
 8028a56:	f040 80a5 	bne.w	8028ba4 <_vfiprintf_r+0x754>
 8028a5a:	3d10      	subs	r5, #16
 8028a5c:	2d10      	cmp	r5, #16
 8028a5e:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028a62:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028a66:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028a6a:	dce3      	bgt.n	8028a34 <_vfiprintf_r+0x5e4>
 8028a6c:	3301      	adds	r3, #1
 8028a6e:	1952      	adds	r2, r2, r5
 8028a70:	2b07      	cmp	r3, #7
 8028a72:	6027      	str	r7, [r4, #0]
 8028a74:	6065      	str	r5, [r4, #4]
 8028a76:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 8028a7a:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 8028a7e:	f300 8146 	bgt.w	8028d0e <_vfiprintf_r+0x8be>
 8028a82:	3408      	adds	r4, #8
 8028a84:	9801      	ldr	r0, [sp, #4]
 8028a86:	9906      	ldr	r1, [sp, #24]
 8028a88:	6060      	str	r0, [r4, #4]
 8028a8a:	3301      	adds	r3, #1
 8028a8c:	1812      	adds	r2, r2, r0
 8028a8e:	2b07      	cmp	r3, #7
 8028a90:	6021      	str	r1, [r4, #0]
 8028a92:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 8028a96:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 8028a9a:	f300 80ca 	bgt.w	8028c32 <_vfiprintf_r+0x7e2>
 8028a9e:	f104 0108 	add.w	r1, r4, #8
 8028aa2:	9c00      	ldr	r4, [sp, #0]
 8028aa4:	0760      	lsls	r0, r4, #29
 8028aa6:	d535      	bpl.n	8028b14 <_vfiprintf_r+0x6c4>
 8028aa8:	9c03      	ldr	r4, [sp, #12]
 8028aaa:	ebc9 0504 	rsb	r5, r9, r4
 8028aae:	2d00      	cmp	r5, #0
 8028ab0:	dd30      	ble.n	8028b14 <_vfiprintf_r+0x6c4>
 8028ab2:	2d10      	cmp	r5, #16
 8028ab4:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028ab8:	4f8d      	ldr	r7, [pc, #564]	; (8028cf0 <_vfiprintf_r+0x8a0>)
 8028aba:	dd20      	ble.n	8028afe <_vfiprintf_r+0x6ae>
 8028abc:	2410      	movs	r4, #16
 8028abe:	e003      	b.n	8028ac8 <_vfiprintf_r+0x678>
 8028ac0:	3d10      	subs	r5, #16
 8028ac2:	3108      	adds	r1, #8
 8028ac4:	2d10      	cmp	r5, #16
 8028ac6:	dd1a      	ble.n	8028afe <_vfiprintf_r+0x6ae>
 8028ac8:	3301      	adds	r3, #1
 8028aca:	3210      	adds	r2, #16
 8028acc:	2b07      	cmp	r3, #7
 8028ace:	600f      	str	r7, [r1, #0]
 8028ad0:	604c      	str	r4, [r1, #4]
 8028ad2:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 8028ad6:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 8028ada:	ddf1      	ble.n	8028ac0 <_vfiprintf_r+0x670>
 8028adc:	4658      	mov	r0, fp
 8028ade:	4651      	mov	r1, sl
 8028ae0:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028ae4:	f7ff fc74 	bl	80283d0 <__sprint_r>
 8028ae8:	2800      	cmp	r0, #0
 8028aea:	d15b      	bne.n	8028ba4 <_vfiprintf_r+0x754>
 8028aec:	3d10      	subs	r5, #16
 8028aee:	2d10      	cmp	r5, #16
 8028af0:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028af4:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028af8:	f50d 6192 	add.w	r1, sp, #1168	; 0x490
 8028afc:	dce4      	bgt.n	8028ac8 <_vfiprintf_r+0x678>
 8028afe:	3301      	adds	r3, #1
 8028b00:	18aa      	adds	r2, r5, r2
 8028b02:	2b07      	cmp	r3, #7
 8028b04:	600f      	str	r7, [r1, #0]
 8028b06:	604d      	str	r5, [r1, #4]
 8028b08:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 8028b0c:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 8028b10:	f300 81b8 	bgt.w	8028e84 <_vfiprintf_r+0xa34>
 8028b14:	9c02      	ldr	r4, [sp, #8]
 8028b16:	9803      	ldr	r0, [sp, #12]
 8028b18:	4581      	cmp	r9, r0
 8028b1a:	bfac      	ite	ge
 8028b1c:	444c      	addge	r4, r9
 8028b1e:	1824      	addlt	r4, r4, r0
 8028b20:	9402      	str	r4, [sp, #8]
 8028b22:	2a00      	cmp	r2, #0
 8028b24:	d136      	bne.n	8028b94 <_vfiprintf_r+0x744>
 8028b26:	7833      	ldrb	r3, [r6, #0]
 8028b28:	2100      	movs	r1, #0
 8028b2a:	f8cd 14fc 	str.w	r1, [sp, #1276]	; 0x4fc
 8028b2e:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028b32:	2b00      	cmp	r3, #0
 8028b34:	f47f acc4 	bne.w	80284c0 <_vfiprintf_r+0x70>
 8028b38:	4635      	mov	r5, r6
 8028b3a:	e4e3      	b.n	8028504 <_vfiprintf_r+0xb4>
 8028b3c:	2b01      	cmp	r3, #1
 8028b3e:	f000 8115 	beq.w	8028d6c <_vfiprintf_r+0x91c>
 8028b42:	2b02      	cmp	r3, #2
 8028b44:	f000 80f3 	beq.w	8028d2e <_vfiprintf_r+0x8de>
 8028b48:	f50d 659f 	add.w	r5, sp, #1272	; 0x4f8
 8028b4c:	462a      	mov	r2, r5
 8028b4e:	e000      	b.n	8028b52 <_vfiprintf_r+0x702>
 8028b50:	460a      	mov	r2, r1
 8028b52:	ea4f 03d8 	mov.w	r3, r8, lsr #3
 8028b56:	ea43 7349 	orr.w	r3, r3, r9, lsl #29
 8028b5a:	ea4f 01d9 	mov.w	r1, r9, lsr #3
 8028b5e:	f008 0007 	and.w	r0, r8, #7
 8028b62:	4689      	mov	r9, r1
 8028b64:	4698      	mov	r8, r3
 8028b66:	1e51      	subs	r1, r2, #1
 8028b68:	f100 0330 	add.w	r3, r0, #48	; 0x30
 8028b6c:	ea58 0009 	orrs.w	r0, r8, r9
 8028b70:	f802 3c01 	strb.w	r3, [r2, #-1]
 8028b74:	d1ec      	bne.n	8028b50 <_vfiprintf_r+0x700>
 8028b76:	9106      	str	r1, [sp, #24]
 8028b78:	9900      	ldr	r1, [sp, #0]
 8028b7a:	07c9      	lsls	r1, r1, #31
 8028b7c:	d506      	bpl.n	8028b8c <_vfiprintf_r+0x73c>
 8028b7e:	2b30      	cmp	r3, #48	; 0x30
 8028b80:	d004      	beq.n	8028b8c <_vfiprintf_r+0x73c>
 8028b82:	1e93      	subs	r3, r2, #2
 8028b84:	9306      	str	r3, [sp, #24]
 8028b86:	2330      	movs	r3, #48	; 0x30
 8028b88:	f802 3c02 	strb.w	r3, [r2, #-2]
 8028b8c:	9b06      	ldr	r3, [sp, #24]
 8028b8e:	1aed      	subs	r5, r5, r3
 8028b90:	9501      	str	r5, [sp, #4]
 8028b92:	e558      	b.n	8028646 <_vfiprintf_r+0x1f6>
 8028b94:	4658      	mov	r0, fp
 8028b96:	4651      	mov	r1, sl
 8028b98:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028b9c:	f7ff fc18 	bl	80283d0 <__sprint_r>
 8028ba0:	2800      	cmp	r0, #0
 8028ba2:	d0c0      	beq.n	8028b26 <_vfiprintf_r+0x6d6>
 8028ba4:	4657      	mov	r7, sl
 8028ba6:	89bb      	ldrh	r3, [r7, #12]
 8028ba8:	9c02      	ldr	r4, [sp, #8]
 8028baa:	f013 0f40 	tst.w	r3, #64	; 0x40
 8028bae:	bf18      	it	ne
 8028bb0:	f04f 34ff 	movne.w	r4, #4294967295
 8028bb4:	9402      	str	r4, [sp, #8]
 8028bb6:	9802      	ldr	r0, [sp, #8]
 8028bb8:	b043      	add	sp, #268	; 0x10c
 8028bba:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
 8028bbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028bc2:	9903      	ldr	r1, [sp, #12]
 8028bc4:	ebc9 0501 	rsb	r5, r9, r1
 8028bc8:	2d00      	cmp	r5, #0
 8028bca:	f77f af24 	ble.w	8028a16 <_vfiprintf_r+0x5c6>
 8028bce:	2d10      	cmp	r5, #16
 8028bd0:	4f46      	ldr	r7, [pc, #280]	; (8028cec <_vfiprintf_r+0x89c>)
 8028bd2:	dd21      	ble.n	8028c18 <_vfiprintf_r+0x7c8>
 8028bd4:	f04f 0810 	mov.w	r8, #16
 8028bd8:	e003      	b.n	8028be2 <_vfiprintf_r+0x792>
 8028bda:	3d10      	subs	r5, #16
 8028bdc:	3408      	adds	r4, #8
 8028bde:	2d10      	cmp	r5, #16
 8028be0:	dd1a      	ble.n	8028c18 <_vfiprintf_r+0x7c8>
 8028be2:	3301      	adds	r3, #1
 8028be4:	3210      	adds	r2, #16
 8028be6:	2b07      	cmp	r3, #7
 8028be8:	e884 0180 	stmia.w	r4, {r7, r8}
 8028bec:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 8028bf0:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 8028bf4:	ddf1      	ble.n	8028bda <_vfiprintf_r+0x78a>
 8028bf6:	4658      	mov	r0, fp
 8028bf8:	4651      	mov	r1, sl
 8028bfa:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028bfe:	f7ff fbe7 	bl	80283d0 <__sprint_r>
 8028c02:	2800      	cmp	r0, #0
 8028c04:	d1ce      	bne.n	8028ba4 <_vfiprintf_r+0x754>
 8028c06:	3d10      	subs	r5, #16
 8028c08:	2d10      	cmp	r5, #16
 8028c0a:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028c0e:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028c12:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028c16:	dce4      	bgt.n	8028be2 <_vfiprintf_r+0x792>
 8028c18:	3301      	adds	r3, #1
 8028c1a:	1952      	adds	r2, r2, r5
 8028c1c:	2b07      	cmp	r3, #7
 8028c1e:	6027      	str	r7, [r4, #0]
 8028c20:	6065      	str	r5, [r4, #4]
 8028c22:	f8cd 2500 	str.w	r2, [sp, #1280]	; 0x500
 8028c26:	f8cd 34fc 	str.w	r3, [sp, #1276]	; 0x4fc
 8028c2a:	f300 8181 	bgt.w	8028f30 <_vfiprintf_r+0xae0>
 8028c2e:	3408      	adds	r4, #8
 8028c30:	e6f1      	b.n	8028a16 <_vfiprintf_r+0x5c6>
 8028c32:	4658      	mov	r0, fp
 8028c34:	4651      	mov	r1, sl
 8028c36:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028c3a:	f7ff fbc9 	bl	80283d0 <__sprint_r>
 8028c3e:	2800      	cmp	r0, #0
 8028c40:	d1b0      	bne.n	8028ba4 <_vfiprintf_r+0x754>
 8028c42:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028c46:	f50d 6192 	add.w	r1, sp, #1168	; 0x490
 8028c4a:	e72a      	b.n	8028aa2 <_vfiprintf_r+0x652>
 8028c4c:	4650      	mov	r0, sl
 8028c4e:	4639      	mov	r1, r7
 8028c50:	f000 f9ea 	bl	8029028 <__swsetup_r>
 8028c54:	2800      	cmp	r0, #0
 8028c56:	f040 81d3 	bne.w	8029000 <_vfiprintf_r+0xbb0>
 8028c5a:	89bd      	ldrh	r5, [r7, #12]
 8028c5c:	b2ab      	uxth	r3, r5
 8028c5e:	f003 031a 	and.w	r3, r3, #26
 8028c62:	2b0a      	cmp	r3, #10
 8028c64:	f47f ac1a 	bne.w	802849c <_vfiprintf_r+0x4c>
 8028c68:	89fc      	ldrh	r4, [r7, #14]
 8028c6a:	0423      	lsls	r3, r4, #16
 8028c6c:	f53f ac16 	bmi.w	802849c <_vfiprintf_r+0x4c>
 8028c70:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8028c72:	f8d7 c01c 	ldr.w	ip, [r7, #28]
 8028c76:	f8d7 8024 	ldr.w	r8, [r7, #36]	; 0x24
 8028c7a:	f8ad 4436 	strh.w	r4, [sp, #1078]	; 0x436
 8028c7e:	ac0a      	add	r4, sp, #40	; 0x28
 8028c80:	f44f 6e80 	mov.w	lr, #1024	; 0x400
 8028c84:	f8cd 348c 	str.w	r3, [sp, #1164]	; 0x48c
 8028c88:	f8cd 4428 	str.w	r4, [sp, #1064]	; 0x428
 8028c8c:	f8cd 4438 	str.w	r4, [sp, #1080]	; 0x438
 8028c90:	f025 0502 	bic.w	r5, r5, #2
 8028c94:	2400      	movs	r4, #0
 8028c96:	4650      	mov	r0, sl
 8028c98:	f50d 6185 	add.w	r1, sp, #1064	; 0x428
 8028c9c:	4632      	mov	r2, r6
 8028c9e:	9b04      	ldr	r3, [sp, #16]
 8028ca0:	f8ad 5434 	strh.w	r5, [sp, #1076]	; 0x434
 8028ca4:	f8cd c444 	str.w	ip, [sp, #1092]	; 0x444
 8028ca8:	f8cd 844c 	str.w	r8, [sp, #1100]	; 0x44c
 8028cac:	f8cd e430 	str.w	lr, [sp, #1072]	; 0x430
 8028cb0:	f8cd e43c 	str.w	lr, [sp, #1084]	; 0x43c
 8028cb4:	f8cd 4440 	str.w	r4, [sp, #1088]	; 0x440
 8028cb8:	f7ff fbca 	bl	8028450 <_vfiprintf_r>
 8028cbc:	42a0      	cmp	r0, r4
 8028cbe:	9002      	str	r0, [sp, #8]
 8028cc0:	db0a      	blt.n	8028cd8 <_vfiprintf_r+0x888>
 8028cc2:	4650      	mov	r0, sl
 8028cc4:	f50d 6185 	add.w	r1, sp, #1064	; 0x428
 8028cc8:	f001 fa66 	bl	802a198 <_fflush_r>
 8028ccc:	9c02      	ldr	r4, [sp, #8]
 8028cce:	2800      	cmp	r0, #0
 8028cd0:	bf18      	it	ne
 8028cd2:	f04f 34ff 	movne.w	r4, #4294967295
 8028cd6:	9402      	str	r4, [sp, #8]
 8028cd8:	f8bd 3434 	ldrh.w	r3, [sp, #1076]	; 0x434
 8028cdc:	0658      	lsls	r0, r3, #25
 8028cde:	f57f af6a 	bpl.w	8028bb6 <_vfiprintf_r+0x766>
 8028ce2:	89bb      	ldrh	r3, [r7, #12]
 8028ce4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8028ce8:	81bb      	strh	r3, [r7, #12]
 8028cea:	e764      	b.n	8028bb6 <_vfiprintf_r+0x766>
 8028cec:	08033030 	.word	0x08033030
 8028cf0:	08033040 	.word	0x08033040
 8028cf4:	4658      	mov	r0, fp
 8028cf6:	4651      	mov	r1, sl
 8028cf8:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028cfc:	f7ff fb68 	bl	80283d0 <__sprint_r>
 8028d00:	2800      	cmp	r0, #0
 8028d02:	f47f af4f 	bne.w	8028ba4 <_vfiprintf_r+0x754>
 8028d06:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028d0a:	f7ff bbf8 	b.w	80284fe <_vfiprintf_r+0xae>
 8028d0e:	4658      	mov	r0, fp
 8028d10:	4651      	mov	r1, sl
 8028d12:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028d16:	f7ff fb5b 	bl	80283d0 <__sprint_r>
 8028d1a:	2800      	cmp	r0, #0
 8028d1c:	f47f af42 	bne.w	8028ba4 <_vfiprintf_r+0x754>
 8028d20:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028d24:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028d28:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028d2c:	e6aa      	b.n	8028a84 <_vfiprintf_r+0x634>
 8028d2e:	f50d 629e 	add.w	r2, sp, #1264	; 0x4f0
 8028d32:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8028d36:	3207      	adds	r2, #7
 8028d38:	4625      	mov	r5, r4
 8028d3a:	f008 040f 	and.w	r4, r8, #15
 8028d3e:	ea4f 1318 	mov.w	r3, r8, lsr #4
 8028d42:	ea43 7309 	orr.w	r3, r3, r9, lsl #28
 8028d46:	4611      	mov	r1, r2
 8028d48:	ea4f 1019 	mov.w	r0, r9, lsr #4
 8028d4c:	f81c 2004 	ldrb.w	r2, [ip, r4]
 8028d50:	4698      	mov	r8, r3
 8028d52:	4681      	mov	r9, r0
 8028d54:	700a      	strb	r2, [r1, #0]
 8028d56:	1e4a      	subs	r2, r1, #1
 8028d58:	ea58 0309 	orrs.w	r3, r8, r9
 8028d5c:	d1ed      	bne.n	8028d3a <_vfiprintf_r+0x8ea>
 8028d5e:	f50d 639f 	add.w	r3, sp, #1272	; 0x4f8
 8028d62:	1a5b      	subs	r3, r3, r1
 8028d64:	9106      	str	r1, [sp, #24]
 8028d66:	462c      	mov	r4, r5
 8028d68:	9301      	str	r3, [sp, #4]
 8028d6a:	e46c      	b.n	8028646 <_vfiprintf_r+0x1f6>
 8028d6c:	f1b8 0f0a 	cmp.w	r8, #10
 8028d70:	f179 0000 	sbcs.w	r0, r9, #0
 8028d74:	d262      	bcs.n	8028e3c <_vfiprintf_r+0x9ec>
 8028d76:	2301      	movs	r3, #1
 8028d78:	9301      	str	r3, [sp, #4]
 8028d7a:	f50d 639e 	add.w	r3, sp, #1264	; 0x4f0
 8028d7e:	f108 0830 	add.w	r8, r8, #48	; 0x30
 8028d82:	3307      	adds	r3, #7
 8028d84:	f88d 84f7 	strb.w	r8, [sp, #1271]	; 0x4f7
 8028d88:	9306      	str	r3, [sp, #24]
 8028d8a:	e45c      	b.n	8028646 <_vfiprintf_r+0x1f6>
 8028d8c:	4658      	mov	r0, fp
 8028d8e:	4651      	mov	r1, sl
 8028d90:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028d94:	f7ff fb1c 	bl	80283d0 <__sprint_r>
 8028d98:	2800      	cmp	r0, #0
 8028d9a:	f47f af03 	bne.w	8028ba4 <_vfiprintf_r+0x754>
 8028d9e:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028da2:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028da6:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028daa:	e61e      	b.n	80289ea <_vfiprintf_r+0x59a>
 8028dac:	4658      	mov	r0, fp
 8028dae:	4651      	mov	r1, sl
 8028db0:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028db4:	f7ff fb0c 	bl	80283d0 <__sprint_r>
 8028db8:	2800      	cmp	r0, #0
 8028dba:	f47f aef3 	bne.w	8028ba4 <_vfiprintf_r+0x754>
 8028dbe:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028dc2:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028dc6:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028dca:	e620      	b.n	8028a0e <_vfiprintf_r+0x5be>
 8028dcc:	f001 fac8 	bl	802a360 <__sinit>
 8028dd0:	f7ff bb4c 	b.w	802846c <_vfiprintf_r+0x1c>
 8028dd4:	4658      	mov	r0, fp
 8028dd6:	4651      	mov	r1, sl
 8028dd8:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028ddc:	f7ff faf8 	bl	80283d0 <__sprint_r>
 8028de0:	2800      	cmp	r0, #0
 8028de2:	f47f aedf 	bne.w	8028ba4 <_vfiprintf_r+0x754>
 8028de6:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028dea:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028dee:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028df2:	e5e7      	b.n	80289c4 <_vfiprintf_r+0x574>
 8028df4:	9800      	ldr	r0, [sp, #0]
 8028df6:	f010 0210 	ands.w	r2, r0, #16
 8028dfa:	d15b      	bne.n	8028eb4 <_vfiprintf_r+0xa64>
 8028dfc:	9800      	ldr	r0, [sp, #0]
 8028dfe:	f010 0340 	ands.w	r3, r0, #64	; 0x40
 8028e02:	f000 80be 	beq.w	8028f82 <_vfiprintf_r+0xb32>
 8028e06:	9904      	ldr	r1, [sp, #16]
 8028e08:	f8b1 8000 	ldrh.w	r8, [r1]
 8028e0c:	3104      	adds	r1, #4
 8028e0e:	4613      	mov	r3, r2
 8028e10:	f04f 0900 	mov.w	r9, #0
 8028e14:	9104      	str	r1, [sp, #16]
 8028e16:	f7ff bbf6 	b.w	8028606 <_vfiprintf_r+0x1b6>
 8028e1a:	9900      	ldr	r1, [sp, #0]
 8028e1c:	06ca      	lsls	r2, r1, #27
 8028e1e:	d46a      	bmi.n	8028ef6 <_vfiprintf_r+0xaa6>
 8028e20:	9b00      	ldr	r3, [sp, #0]
 8028e22:	065b      	lsls	r3, r3, #25
 8028e24:	f140 80c1 	bpl.w	8028faa <_vfiprintf_r+0xb5a>
 8028e28:	9804      	ldr	r0, [sp, #16]
 8028e2a:	f8b0 8000 	ldrh.w	r8, [r0]
 8028e2e:	3004      	adds	r0, #4
 8028e30:	2301      	movs	r3, #1
 8028e32:	f04f 0900 	mov.w	r9, #0
 8028e36:	9004      	str	r0, [sp, #16]
 8028e38:	f7ff bbe5 	b.w	8028606 <_vfiprintf_r+0x1b6>
 8028e3c:	f50d 659e 	add.w	r5, sp, #1264	; 0x4f0
 8028e40:	9601      	str	r6, [sp, #4]
 8028e42:	3507      	adds	r5, #7
 8028e44:	4626      	mov	r6, r4
 8028e46:	4640      	mov	r0, r8
 8028e48:	4649      	mov	r1, r9
 8028e4a:	220a      	movs	r2, #10
 8028e4c:	2300      	movs	r3, #0
 8028e4e:	f7fa fb47 	bl	80234e0 <__aeabi_uldivmod>
 8028e52:	3230      	adds	r2, #48	; 0x30
 8028e54:	702a      	strb	r2, [r5, #0]
 8028e56:	4640      	mov	r0, r8
 8028e58:	4649      	mov	r1, r9
 8028e5a:	220a      	movs	r2, #10
 8028e5c:	2300      	movs	r3, #0
 8028e5e:	f7fa fb3f 	bl	80234e0 <__aeabi_uldivmod>
 8028e62:	4680      	mov	r8, r0
 8028e64:	4689      	mov	r9, r1
 8028e66:	462c      	mov	r4, r5
 8028e68:	3d01      	subs	r5, #1
 8028e6a:	ea58 0009 	orrs.w	r0, r8, r9
 8028e6e:	d1ea      	bne.n	8028e46 <_vfiprintf_r+0x9f6>
 8028e70:	9406      	str	r4, [sp, #24]
 8028e72:	9906      	ldr	r1, [sp, #24]
 8028e74:	f50d 639f 	add.w	r3, sp, #1272	; 0x4f8
 8028e78:	1a5b      	subs	r3, r3, r1
 8028e7a:	4634      	mov	r4, r6
 8028e7c:	9e01      	ldr	r6, [sp, #4]
 8028e7e:	9301      	str	r3, [sp, #4]
 8028e80:	f7ff bbe1 	b.w	8028646 <_vfiprintf_r+0x1f6>
 8028e84:	4658      	mov	r0, fp
 8028e86:	4651      	mov	r1, sl
 8028e88:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028e8c:	f7ff faa0 	bl	80283d0 <__sprint_r>
 8028e90:	2800      	cmp	r0, #0
 8028e92:	f47f ae87 	bne.w	8028ba4 <_vfiprintf_r+0x754>
 8028e96:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028e9a:	e63b      	b.n	8028b14 <_vfiprintf_r+0x6c4>
 8028e9c:	7833      	ldrb	r3, [r6, #0]
 8028e9e:	9104      	str	r1, [sp, #16]
 8028ea0:	f7ff bb3e 	b.w	8028520 <_vfiprintf_r+0xd0>
 8028ea4:	9804      	ldr	r0, [sp, #16]
 8028ea6:	6802      	ldr	r2, [r0, #0]
 8028ea8:	3004      	adds	r0, #4
 8028eaa:	4690      	mov	r8, r2
 8028eac:	f04f 0900 	mov.w	r9, #0
 8028eb0:	9004      	str	r0, [sp, #16]
 8028eb2:	e4de      	b.n	8028872 <_vfiprintf_r+0x422>
 8028eb4:	9904      	ldr	r1, [sp, #16]
 8028eb6:	680a      	ldr	r2, [r1, #0]
 8028eb8:	3104      	adds	r1, #4
 8028eba:	4690      	mov	r8, r2
 8028ebc:	f04f 0900 	mov.w	r9, #0
 8028ec0:	9104      	str	r1, [sp, #16]
 8028ec2:	f7ff bba0 	b.w	8028606 <_vfiprintf_r+0x1b6>
 8028ec6:	9804      	ldr	r0, [sp, #16]
 8028ec8:	6803      	ldr	r3, [r0, #0]
 8028eca:	ea4f 79e3 	mov.w	r9, r3, asr #31
 8028ece:	461a      	mov	r2, r3
 8028ed0:	3004      	adds	r0, #4
 8028ed2:	4698      	mov	r8, r3
 8028ed4:	464b      	mov	r3, r9
 8028ed6:	9004      	str	r0, [sp, #16]
 8028ed8:	2a00      	cmp	r2, #0
 8028eda:	f173 0000 	sbcs.w	r0, r3, #0
 8028ede:	f6bf ac59 	bge.w	8028794 <_vfiprintf_r+0x344>
 8028ee2:	232d      	movs	r3, #45	; 0x2d
 8028ee4:	f88d 3507 	strb.w	r3, [sp, #1287]	; 0x507
 8028ee8:	f1d8 0800 	rsbs	r8, r8, #0
 8028eec:	eb69 0949 	sbc.w	r9, r9, r9, lsl #1
 8028ef0:	2301      	movs	r3, #1
 8028ef2:	f7ff bb8b 	b.w	802860c <_vfiprintf_r+0x1bc>
 8028ef6:	9a04      	ldr	r2, [sp, #16]
 8028ef8:	6813      	ldr	r3, [r2, #0]
 8028efa:	3204      	adds	r2, #4
 8028efc:	4698      	mov	r8, r3
 8028efe:	f04f 0900 	mov.w	r9, #0
 8028f02:	9204      	str	r2, [sp, #16]
 8028f04:	2301      	movs	r3, #1
 8028f06:	f7ff bb7e 	b.w	8028606 <_vfiprintf_r+0x1b6>
 8028f0a:	9a04      	ldr	r2, [sp, #16]
 8028f0c:	6813      	ldr	r3, [r2, #0]
 8028f0e:	9a02      	ldr	r2, [sp, #8]
 8028f10:	17d1      	asrs	r1, r2, #31
 8028f12:	601a      	str	r2, [r3, #0]
 8028f14:	6059      	str	r1, [r3, #4]
 8028f16:	9b04      	ldr	r3, [sp, #16]
 8028f18:	3304      	adds	r3, #4
 8028f1a:	9304      	str	r3, [sp, #16]
 8028f1c:	f7ff bacc 	b.w	80284b8 <_vfiprintf_r+0x68>
 8028f20:	9b00      	ldr	r3, [sp, #0]
 8028f22:	f043 0320 	orr.w	r3, r3, #32
 8028f26:	9300      	str	r3, [sp, #0]
 8028f28:	3601      	adds	r6, #1
 8028f2a:	784b      	ldrb	r3, [r1, #1]
 8028f2c:	f7ff baf8 	b.w	8028520 <_vfiprintf_r+0xd0>
 8028f30:	4658      	mov	r0, fp
 8028f32:	4651      	mov	r1, sl
 8028f34:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028f38:	f7ff fa4a 	bl	80283d0 <__sprint_r>
 8028f3c:	2800      	cmp	r0, #0
 8028f3e:	f47f ae31 	bne.w	8028ba4 <_vfiprintf_r+0x754>
 8028f42:	f8dd 2500 	ldr.w	r2, [sp, #1280]	; 0x500
 8028f46:	f8dd 34fc 	ldr.w	r3, [sp, #1276]	; 0x4fc
 8028f4a:	f50d 6492 	add.w	r4, sp, #1168	; 0x490
 8028f4e:	e562      	b.n	8028a16 <_vfiprintf_r+0x5c6>
 8028f50:	f8dd 3500 	ldr.w	r3, [sp, #1280]	; 0x500
 8028f54:	4657      	mov	r7, sl
 8028f56:	46da      	mov	sl, fp
 8028f58:	2b00      	cmp	r3, #0
 8028f5a:	f43f ae24 	beq.w	8028ba6 <_vfiprintf_r+0x756>
 8028f5e:	4658      	mov	r0, fp
 8028f60:	4639      	mov	r1, r7
 8028f62:	f50d 629f 	add.w	r2, sp, #1272	; 0x4f8
 8028f66:	f7ff fa33 	bl	80283d0 <__sprint_r>
 8028f6a:	e61c      	b.n	8028ba6 <_vfiprintf_r+0x756>
 8028f6c:	9b00      	ldr	r3, [sp, #0]
 8028f6e:	0658      	lsls	r0, r3, #25
 8028f70:	d52f      	bpl.n	8028fd2 <_vfiprintf_r+0xb82>
 8028f72:	9804      	ldr	r0, [sp, #16]
 8028f74:	9902      	ldr	r1, [sp, #8]
 8028f76:	6803      	ldr	r3, [r0, #0]
 8028f78:	3004      	adds	r0, #4
 8028f7a:	9004      	str	r0, [sp, #16]
 8028f7c:	8019      	strh	r1, [r3, #0]
 8028f7e:	f7ff ba9b 	b.w	80284b8 <_vfiprintf_r+0x68>
 8028f82:	9804      	ldr	r0, [sp, #16]
 8028f84:	6802      	ldr	r2, [r0, #0]
 8028f86:	3004      	adds	r0, #4
 8028f88:	4690      	mov	r8, r2
 8028f8a:	f04f 0900 	mov.w	r9, #0
 8028f8e:	9004      	str	r0, [sp, #16]
 8028f90:	f7ff bb39 	b.w	8028606 <_vfiprintf_r+0x1b6>
 8028f94:	9904      	ldr	r1, [sp, #16]
 8028f96:	680b      	ldr	r3, [r1, #0]
 8028f98:	3104      	adds	r1, #4
 8028f9a:	ea4f 79e3 	mov.w	r9, r3, asr #31
 8028f9e:	4698      	mov	r8, r3
 8028fa0:	461a      	mov	r2, r3
 8028fa2:	9104      	str	r1, [sp, #16]
 8028fa4:	464b      	mov	r3, r9
 8028fa6:	f7ff bbf0 	b.w	802878a <_vfiprintf_r+0x33a>
 8028faa:	9904      	ldr	r1, [sp, #16]
 8028fac:	680b      	ldr	r3, [r1, #0]
 8028fae:	3104      	adds	r1, #4
 8028fb0:	4698      	mov	r8, r3
 8028fb2:	f04f 0900 	mov.w	r9, #0
 8028fb6:	9104      	str	r1, [sp, #16]
 8028fb8:	2301      	movs	r3, #1
 8028fba:	f7ff bb24 	b.w	8028606 <_vfiprintf_r+0x1b6>
 8028fbe:	4b19      	ldr	r3, [pc, #100]	; (8029024 <_vfiprintf_r+0xbd4>)
 8028fc0:	2f06      	cmp	r7, #6
 8028fc2:	bf28      	it	cs
 8028fc4:	2706      	movcs	r7, #6
 8028fc6:	9701      	str	r7, [sp, #4]
 8028fc8:	ea27 79e7 	bic.w	r9, r7, r7, asr #31
 8028fcc:	9306      	str	r3, [sp, #24]
 8028fce:	f7ff bbf4 	b.w	80287ba <_vfiprintf_r+0x36a>
 8028fd2:	9a04      	ldr	r2, [sp, #16]
 8028fd4:	9802      	ldr	r0, [sp, #8]
 8028fd6:	6813      	ldr	r3, [r2, #0]
 8028fd8:	3204      	adds	r2, #4
 8028fda:	9204      	str	r2, [sp, #16]
 8028fdc:	6018      	str	r0, [r3, #0]
 8028fde:	f7ff ba6b 	b.w	80284b8 <_vfiprintf_r+0x68>
 8028fe2:	4606      	mov	r6, r0
 8028fe4:	2700      	movs	r7, #0
 8028fe6:	f7ff ba9c 	b.w	8028522 <_vfiprintf_r+0xd2>
 8028fea:	f7fd feb7 	bl	8026d5c <strlen>
 8028fee:	2300      	movs	r3, #0
 8028ff0:	9001      	str	r0, [sp, #4]
 8028ff2:	9305      	str	r3, [sp, #20]
 8028ff4:	f7ff bb28 	b.w	8028648 <_vfiprintf_r+0x1f8>
 8028ff8:	9701      	str	r7, [sp, #4]
 8028ffa:	9005      	str	r0, [sp, #20]
 8028ffc:	f7ff bb24 	b.w	8028648 <_vfiprintf_r+0x1f8>
 8029000:	f04f 34ff 	mov.w	r4, #4294967295
 8029004:	9402      	str	r4, [sp, #8]
 8029006:	e5d6      	b.n	8028bb6 <_vfiprintf_r+0x766>
 8029008:	9b04      	ldr	r3, [sp, #16]
 802900a:	681f      	ldr	r7, [r3, #0]
 802900c:	1d19      	adds	r1, r3, #4
 802900e:	2f00      	cmp	r7, #0
 8029010:	7873      	ldrb	r3, [r6, #1]
 8029012:	9104      	str	r1, [sp, #16]
 8029014:	4606      	mov	r6, r0
 8029016:	f6bf aa83 	bge.w	8028520 <_vfiprintf_r+0xd0>
 802901a:	f04f 37ff 	mov.w	r7, #4294967295
 802901e:	f7ff ba7f 	b.w	8028520 <_vfiprintf_r+0xd0>
 8029022:	bf00      	nop
 8029024:	08032db4 	.word	0x08032db4

08029028 <__swsetup_r>:
 8029028:	b538      	push	{r3, r4, r5, lr}
 802902a:	4b2d      	ldr	r3, [pc, #180]	; (80290e0 <__swsetup_r+0xb8>)
 802902c:	681b      	ldr	r3, [r3, #0]
 802902e:	4605      	mov	r5, r0
 8029030:	460c      	mov	r4, r1
 8029032:	b113      	cbz	r3, 802903a <__swsetup_r+0x12>
 8029034:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8029036:	2a00      	cmp	r2, #0
 8029038:	d035      	beq.n	80290a6 <__swsetup_r+0x7e>
 802903a:	89a2      	ldrh	r2, [r4, #12]
 802903c:	b293      	uxth	r3, r2
 802903e:	0719      	lsls	r1, r3, #28
 8029040:	d50c      	bpl.n	802905c <__swsetup_r+0x34>
 8029042:	6921      	ldr	r1, [r4, #16]
 8029044:	b1a9      	cbz	r1, 8029072 <__swsetup_r+0x4a>
 8029046:	f013 0201 	ands.w	r2, r3, #1
 802904a:	d01e      	beq.n	802908a <__swsetup_r+0x62>
 802904c:	6963      	ldr	r3, [r4, #20]
 802904e:	2200      	movs	r2, #0
 8029050:	425b      	negs	r3, r3
 8029052:	60a2      	str	r2, [r4, #8]
 8029054:	61a3      	str	r3, [r4, #24]
 8029056:	b1f1      	cbz	r1, 8029096 <__swsetup_r+0x6e>
 8029058:	2000      	movs	r0, #0
 802905a:	bd38      	pop	{r3, r4, r5, pc}
 802905c:	06d8      	lsls	r0, r3, #27
 802905e:	d53b      	bpl.n	80290d8 <__swsetup_r+0xb0>
 8029060:	0759      	lsls	r1, r3, #29
 8029062:	d424      	bmi.n	80290ae <__swsetup_r+0x86>
 8029064:	6921      	ldr	r1, [r4, #16]
 8029066:	f042 0308 	orr.w	r3, r2, #8
 802906a:	81a3      	strh	r3, [r4, #12]
 802906c:	b29b      	uxth	r3, r3
 802906e:	2900      	cmp	r1, #0
 8029070:	d1e9      	bne.n	8029046 <__swsetup_r+0x1e>
 8029072:	f403 7220 	and.w	r2, r3, #640	; 0x280
 8029076:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 802907a:	d0e4      	beq.n	8029046 <__swsetup_r+0x1e>
 802907c:	4621      	mov	r1, r4
 802907e:	4628      	mov	r0, r5
 8029080:	f001 fcd8 	bl	802aa34 <__smakebuf_r>
 8029084:	89a3      	ldrh	r3, [r4, #12]
 8029086:	6921      	ldr	r1, [r4, #16]
 8029088:	e7dd      	b.n	8029046 <__swsetup_r+0x1e>
 802908a:	079b      	lsls	r3, r3, #30
 802908c:	bf58      	it	pl
 802908e:	6962      	ldrpl	r2, [r4, #20]
 8029090:	60a2      	str	r2, [r4, #8]
 8029092:	2900      	cmp	r1, #0
 8029094:	d1e0      	bne.n	8029058 <__swsetup_r+0x30>
 8029096:	89a3      	ldrh	r3, [r4, #12]
 8029098:	f013 0f80 	tst.w	r3, #128	; 0x80
 802909c:	bf14      	ite	ne
 802909e:	f04f 30ff 	movne.w	r0, #4294967295
 80290a2:	2000      	moveq	r0, #0
 80290a4:	bd38      	pop	{r3, r4, r5, pc}
 80290a6:	4618      	mov	r0, r3
 80290a8:	f001 f95a 	bl	802a360 <__sinit>
 80290ac:	e7c5      	b.n	802903a <__swsetup_r+0x12>
 80290ae:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80290b0:	b149      	cbz	r1, 80290c6 <__swsetup_r+0x9e>
 80290b2:	f104 0340 	add.w	r3, r4, #64	; 0x40
 80290b6:	4299      	cmp	r1, r3
 80290b8:	d003      	beq.n	80290c2 <__swsetup_r+0x9a>
 80290ba:	4628      	mov	r0, r5
 80290bc:	f001 fa30 	bl	802a520 <_free_r>
 80290c0:	89a2      	ldrh	r2, [r4, #12]
 80290c2:	2300      	movs	r3, #0
 80290c4:	6323      	str	r3, [r4, #48]	; 0x30
 80290c6:	f022 0224 	bic.w	r2, r2, #36	; 0x24
 80290ca:	6921      	ldr	r1, [r4, #16]
 80290cc:	0412      	lsls	r2, r2, #16
 80290ce:	2300      	movs	r3, #0
 80290d0:	0c12      	lsrs	r2, r2, #16
 80290d2:	e884 000a 	stmia.w	r4, {r1, r3}
 80290d6:	e7c6      	b.n	8029066 <__swsetup_r+0x3e>
 80290d8:	f04f 30ff 	mov.w	r0, #4294967295
 80290dc:	bd38      	pop	{r3, r4, r5, pc}
 80290de:	bf00      	nop
 80290e0:	20000510 	.word	0x20000510

080290e4 <__register_exitproc>:
 80290e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80290e8:	4c27      	ldr	r4, [pc, #156]	; (8029188 <__register_exitproc+0xa4>)
 80290ea:	6825      	ldr	r5, [r4, #0]
 80290ec:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 80290f0:	b084      	sub	sp, #16
 80290f2:	4606      	mov	r6, r0
 80290f4:	2c00      	cmp	r4, #0
 80290f6:	d042      	beq.n	802917e <__register_exitproc+0x9a>
 80290f8:	6860      	ldr	r0, [r4, #4]
 80290fa:	281f      	cmp	r0, #31
 80290fc:	dd1d      	ble.n	802913a <__register_exitproc+0x56>
 80290fe:	4823      	ldr	r0, [pc, #140]	; (802918c <__register_exitproc+0xa8>)
 8029100:	b910      	cbnz	r0, 8029108 <__register_exitproc+0x24>
 8029102:	f04f 30ff 	mov.w	r0, #4294967295
 8029106:	e01f      	b.n	8029148 <__register_exitproc+0x64>
 8029108:	f44f 70c8 	mov.w	r0, #400	; 0x190
 802910c:	9103      	str	r1, [sp, #12]
 802910e:	9202      	str	r2, [sp, #8]
 8029110:	9301      	str	r3, [sp, #4]
 8029112:	f7fb fe51 	bl	8024db8 <malloc>
 8029116:	9903      	ldr	r1, [sp, #12]
 8029118:	9a02      	ldr	r2, [sp, #8]
 802911a:	9b01      	ldr	r3, [sp, #4]
 802911c:	4604      	mov	r4, r0
 802911e:	2800      	cmp	r0, #0
 8029120:	d0ef      	beq.n	8029102 <__register_exitproc+0x1e>
 8029122:	f8d5 0148 	ldr.w	r0, [r5, #328]	; 0x148
 8029126:	2700      	movs	r7, #0
 8029128:	e884 0081 	stmia.w	r4, {r0, r7}
 802912c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8029130:	4638      	mov	r0, r7
 8029132:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
 8029136:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
 802913a:	b946      	cbnz	r6, 802914e <__register_exitproc+0x6a>
 802913c:	1c83      	adds	r3, r0, #2
 802913e:	3001      	adds	r0, #1
 8029140:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
 8029144:	6060      	str	r0, [r4, #4]
 8029146:	2000      	movs	r0, #0
 8029148:	b004      	add	sp, #16
 802914a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802914e:	f8d4 c188 	ldr.w	ip, [r4, #392]	; 0x188
 8029152:	2501      	movs	r5, #1
 8029154:	eb04 0880 	add.w	r8, r4, r0, lsl #2
 8029158:	fa05 f500 	lsl.w	r5, r5, r0
 802915c:	ea4c 0c05 	orr.w	ip, ip, r5
 8029160:	2e02      	cmp	r6, #2
 8029162:	4647      	mov	r7, r8
 8029164:	f8c8 2088 	str.w	r2, [r8, #136]	; 0x88
 8029168:	f8c4 c188 	str.w	ip, [r4, #392]	; 0x188
 802916c:	f8c8 3108 	str.w	r3, [r8, #264]	; 0x108
 8029170:	d1e4      	bne.n	802913c <__register_exitproc+0x58>
 8029172:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
 8029176:	431d      	orrs	r5, r3
 8029178:	f8c4 518c 	str.w	r5, [r4, #396]	; 0x18c
 802917c:	e7de      	b.n	802913c <__register_exitproc+0x58>
 802917e:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 8029182:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8029186:	e7b7      	b.n	80290f8 <__register_exitproc+0x14>
 8029188:	08032c2c 	.word	0x08032c2c
 802918c:	08024db9 	.word	0x08024db9

08029190 <register_fini>:
 8029190:	4b02      	ldr	r3, [pc, #8]	; (802919c <register_fini+0xc>)
 8029192:	b113      	cbz	r3, 802919a <register_fini+0xa>
 8029194:	4802      	ldr	r0, [pc, #8]	; (80291a0 <register_fini+0x10>)
 8029196:	f7fb bda3 	b.w	8024ce0 <atexit>
 802919a:	4770      	bx	lr
 802919c:	00000000 	.word	0x00000000
 80291a0:	08024d01 	.word	0x08024d01

080291a4 <abort>:
 80291a4:	b508      	push	{r3, lr}
 80291a6:	2006      	movs	r0, #6
 80291a8:	f002 fa4a 	bl	802b640 <raise>
 80291ac:	2001      	movs	r0, #1
 80291ae:	f7f9 f9bd 	bl	802252c <_exit>
 80291b2:	bf00      	nop

080291b4 <abs>:
 80291b4:	2800      	cmp	r0, #0
 80291b6:	bfb8      	it	lt
 80291b8:	4240      	neglt	r0, r0
 80291ba:	4770      	bx	lr

080291bc <div>:
 80291bc:	fb91 f3f2 	sdiv	r3, r1, r2
 80291c0:	2900      	cmp	r1, #0
 80291c2:	b410      	push	{r4}
 80291c4:	fb02 1413 	mls	r4, r2, r3, r1
 80291c8:	db05      	blt.n	80291d6 <div+0x1a>
 80291ca:	2c00      	cmp	r4, #0
 80291cc:	db08      	blt.n	80291e0 <div+0x24>
 80291ce:	e880 0018 	stmia.w	r0, {r3, r4}
 80291d2:	bc10      	pop	{r4}
 80291d4:	4770      	bx	lr
 80291d6:	2c00      	cmp	r4, #0
 80291d8:	ddf9      	ble.n	80291ce <div+0x12>
 80291da:	3b01      	subs	r3, #1
 80291dc:	18a4      	adds	r4, r4, r2
 80291de:	e7f6      	b.n	80291ce <div+0x12>
 80291e0:	3301      	adds	r3, #1
 80291e2:	1aa4      	subs	r4, r4, r2
 80291e4:	e7f3      	b.n	80291ce <div+0x12>
 80291e6:	bf00      	nop

080291e8 <quorem>:
 80291e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80291ec:	6902      	ldr	r2, [r0, #16]
 80291ee:	690b      	ldr	r3, [r1, #16]
 80291f0:	4293      	cmp	r3, r2
 80291f2:	b083      	sub	sp, #12
 80291f4:	4680      	mov	r8, r0
 80291f6:	f300 809b 	bgt.w	8029330 <quorem+0x148>
 80291fa:	1cda      	adds	r2, r3, #3
 80291fc:	0092      	lsls	r2, r2, #2
 80291fe:	188f      	adds	r7, r1, r2
 8029200:	1882      	adds	r2, r0, r2
 8029202:	687e      	ldr	r6, [r7, #4]
 8029204:	6852      	ldr	r2, [r2, #4]
 8029206:	3601      	adds	r6, #1
 8029208:	fbb2 f6f6 	udiv	r6, r2, r6
 802920c:	f100 0214 	add.w	r2, r0, #20
 8029210:	f101 0514 	add.w	r5, r1, #20
 8029214:	1e5c      	subs	r4, r3, #1
 8029216:	3704      	adds	r7, #4
 8029218:	9201      	str	r2, [sp, #4]
 802921a:	2e00      	cmp	r6, #0
 802921c:	d049      	beq.n	80292b2 <quorem+0xca>
 802921e:	f04f 0e00 	mov.w	lr, #0
 8029222:	4610      	mov	r0, r2
 8029224:	46f2      	mov	sl, lr
 8029226:	462a      	mov	r2, r5
 8029228:	4699      	mov	r9, r3
 802922a:	f852 bb04 	ldr.w	fp, [r2], #4
 802922e:	6803      	ldr	r3, [r0, #0]
 8029230:	fa1f fc8b 	uxth.w	ip, fp
 8029234:	ea4f 4b1b 	mov.w	fp, fp, lsr #16
 8029238:	fb06 ec0c 	mla	ip, r6, ip, lr
 802923c:	fb06 fe0b 	mul.w	lr, r6, fp
 8029240:	eb0e 4e1c 	add.w	lr, lr, ip, lsr #16
 8029244:	fa1a fa83 	uxtah	sl, sl, r3
 8029248:	fa1f fb8e 	uxth.w	fp, lr
 802924c:	fa1f fc8c 	uxth.w	ip, ip
 8029250:	ebcc 0c0a 	rsb	ip, ip, sl
 8029254:	ebcb 4a13 	rsb	sl, fp, r3, lsr #16
 8029258:	eb0a 4a2c 	add.w	sl, sl, ip, asr #16
 802925c:	fa1f fc8c 	uxth.w	ip, ip
 8029260:	ea4c 430a 	orr.w	r3, ip, sl, lsl #16
 8029264:	4297      	cmp	r7, r2
 8029266:	f840 3b04 	str.w	r3, [r0], #4
 802926a:	ea4f 4e1e 	mov.w	lr, lr, lsr #16
 802926e:	ea4f 4a2a 	mov.w	sl, sl, asr #16
 8029272:	d2da      	bcs.n	802922a <quorem+0x42>
 8029274:	1d20      	adds	r0, r4, #4
 8029276:	eb08 0280 	add.w	r2, r8, r0, lsl #2
 802927a:	464b      	mov	r3, r9
 802927c:	f8d2 e004 	ldr.w	lr, [r2, #4]
 8029280:	f1be 0f00 	cmp.w	lr, #0
 8029284:	d115      	bne.n	80292b2 <quorem+0xca>
 8029286:	f8dd e004 	ldr.w	lr, [sp, #4]
 802928a:	4596      	cmp	lr, r2
 802928c:	d20f      	bcs.n	80292ae <quorem+0xc6>
 802928e:	f858 0020 	ldr.w	r0, [r8, r0, lsl #2]
 8029292:	b960      	cbnz	r0, 80292ae <quorem+0xc6>
 8029294:	ea6f 000e 	mvn.w	r0, lr
 8029298:	3b02      	subs	r3, #2
 802929a:	1880      	adds	r0, r0, r2
 802929c:	eba3 0390 	sub.w	r3, r3, r0, lsr #2
 80292a0:	e002      	b.n	80292a8 <quorem+0xc0>
 80292a2:	f852 0d04 	ldr.w	r0, [r2, #-4]!
 80292a6:	b910      	cbnz	r0, 80292ae <quorem+0xc6>
 80292a8:	3c01      	subs	r4, #1
 80292aa:	429c      	cmp	r4, r3
 80292ac:	d1f9      	bne.n	80292a2 <quorem+0xba>
 80292ae:	f8c8 4010 	str.w	r4, [r8, #16]
 80292b2:	4640      	mov	r0, r8
 80292b4:	f001 fe86 	bl	802afc4 <__mcmp>
 80292b8:	2800      	cmp	r0, #0
 80292ba:	db35      	blt.n	8029328 <quorem+0x140>
 80292bc:	f04f 0c00 	mov.w	ip, #0
 80292c0:	9b01      	ldr	r3, [sp, #4]
 80292c2:	3601      	adds	r6, #1
 80292c4:	4662      	mov	r2, ip
 80292c6:	f855 0b04 	ldr.w	r0, [r5], #4
 80292ca:	6819      	ldr	r1, [r3, #0]
 80292cc:	fa1f fc80 	uxth.w	ip, r0
 80292d0:	fa1f f981 	uxth.w	r9, r1
 80292d4:	0c00      	lsrs	r0, r0, #16
 80292d6:	ebcc 0c09 	rsb	ip, ip, r9
 80292da:	4494      	add	ip, r2
 80292dc:	ebc0 4211 	rsb	r2, r0, r1, lsr #16
 80292e0:	eb02 422c 	add.w	r2, r2, ip, asr #16
 80292e4:	fa1f fc8c 	uxth.w	ip, ip
 80292e8:	ea4c 4102 	orr.w	r1, ip, r2, lsl #16
 80292ec:	1412      	asrs	r2, r2, #16
 80292ee:	42af      	cmp	r7, r5
 80292f0:	f843 1b04 	str.w	r1, [r3], #4
 80292f4:	d2e7      	bcs.n	80292c6 <quorem+0xde>
 80292f6:	1d22      	adds	r2, r4, #4
 80292f8:	eb08 0382 	add.w	r3, r8, r2, lsl #2
 80292fc:	6859      	ldr	r1, [r3, #4]
 80292fe:	b999      	cbnz	r1, 8029328 <quorem+0x140>
 8029300:	9901      	ldr	r1, [sp, #4]
 8029302:	4299      	cmp	r1, r3
 8029304:	d20e      	bcs.n	8029324 <quorem+0x13c>
 8029306:	f858 2022 	ldr.w	r2, [r8, r2, lsl #2]
 802930a:	b95a      	cbnz	r2, 8029324 <quorem+0x13c>
 802930c:	43c9      	mvns	r1, r1
 802930e:	18c9      	adds	r1, r1, r3
 8029310:	f021 0103 	bic.w	r1, r1, #3
 8029314:	1a59      	subs	r1, r3, r1
 8029316:	e002      	b.n	802931e <quorem+0x136>
 8029318:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 802931c:	b912      	cbnz	r2, 8029324 <quorem+0x13c>
 802931e:	3c01      	subs	r4, #1
 8029320:	428b      	cmp	r3, r1
 8029322:	d1f9      	bne.n	8029318 <quorem+0x130>
 8029324:	f8c8 4010 	str.w	r4, [r8, #16]
 8029328:	4630      	mov	r0, r6
 802932a:	b003      	add	sp, #12
 802932c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029330:	2000      	movs	r0, #0
 8029332:	e7fa      	b.n	802932a <quorem+0x142>
 8029334:	0000      	movs	r0, r0
	...

08029338 <_dtoa_r>:
 8029338:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802933c:	6c01      	ldr	r1, [r0, #64]	; 0x40
 802933e:	b09f      	sub	sp, #124	; 0x7c
 8029340:	4692      	mov	sl, r2
 8029342:	9003      	str	r0, [sp, #12]
 8029344:	9d2b      	ldr	r5, [sp, #172]	; 0xac
 8029346:	469b      	mov	fp, r3
 8029348:	b151      	cbz	r1, 8029360 <_dtoa_r+0x28>
 802934a:	6c43      	ldr	r3, [r0, #68]	; 0x44
 802934c:	2201      	movs	r2, #1
 802934e:	fa02 f203 	lsl.w	r2, r2, r3
 8029352:	604b      	str	r3, [r1, #4]
 8029354:	608a      	str	r2, [r1, #8]
 8029356:	f001 fc45 	bl	802abe4 <_Bfree>
 802935a:	9c03      	ldr	r4, [sp, #12]
 802935c:	2300      	movs	r3, #0
 802935e:	6423      	str	r3, [r4, #64]	; 0x40
 8029360:	f1bb 0400 	subs.w	r4, fp, #0
 8029364:	f2c0 80e7 	blt.w	8029536 <_dtoa_r+0x1fe>
 8029368:	2300      	movs	r3, #0
 802936a:	602b      	str	r3, [r5, #0]
 802936c:	2300      	movs	r3, #0
 802936e:	461a      	mov	r2, r3
 8029370:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 8029374:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 8029378:	4023      	ands	r3, r4
 802937a:	4293      	cmp	r3, r2
 802937c:	f000 80c4 	beq.w	8029508 <_dtoa_r+0x1d0>
 8029380:	2300      	movs	r3, #0
 8029382:	4650      	mov	r0, sl
 8029384:	4659      	mov	r1, fp
 8029386:	2200      	movs	r2, #0
 8029388:	f7fa f850 	bl	802342c <__aeabi_dcmpeq>
 802938c:	4656      	mov	r6, sl
 802938e:	465f      	mov	r7, fp
 8029390:	2301      	movs	r3, #1
 8029392:	b990      	cbnz	r0, 80293ba <_dtoa_r+0x82>
 8029394:	f013 0fff 	tst.w	r3, #255	; 0xff
 8029398:	d113      	bne.n	80293c2 <_dtoa_r+0x8a>
 802939a:	9d2a      	ldr	r5, [sp, #168]	; 0xa8
 802939c:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 802939e:	2301      	movs	r3, #1
 80293a0:	602b      	str	r3, [r5, #0]
 80293a2:	2c00      	cmp	r4, #0
 80293a4:	f000 80ec 	beq.w	8029580 <_dtoa_r+0x248>
 80293a8:	4c7d      	ldr	r4, [pc, #500]	; (80295a0 <_dtoa_r+0x268>)
 80293aa:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 80293ac:	602c      	str	r4, [r5, #0]
 80293ae:	3c01      	subs	r4, #1
 80293b0:	9406      	str	r4, [sp, #24]
 80293b2:	9806      	ldr	r0, [sp, #24]
 80293b4:	b01f      	add	sp, #124	; 0x7c
 80293b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80293ba:	2300      	movs	r3, #0
 80293bc:	f013 0fff 	tst.w	r3, #255	; 0xff
 80293c0:	d0eb      	beq.n	802939a <_dtoa_r+0x62>
 80293c2:	a91d      	add	r1, sp, #116	; 0x74
 80293c4:	9100      	str	r1, [sp, #0]
 80293c6:	9803      	ldr	r0, [sp, #12]
 80293c8:	a91c      	add	r1, sp, #112	; 0x70
 80293ca:	4632      	mov	r2, r6
 80293cc:	463b      	mov	r3, r7
 80293ce:	9101      	str	r1, [sp, #4]
 80293d0:	f001 fe82 	bl	802b0d8 <__d2b>
 80293d4:	f3c4 550a 	ubfx	r5, r4, #20, #11
 80293d8:	900d      	str	r0, [sp, #52]	; 0x34
 80293da:	2d00      	cmp	r5, #0
 80293dc:	f040 80ba 	bne.w	8029554 <_dtoa_r+0x21c>
 80293e0:	f8dd 8070 	ldr.w	r8, [sp, #112]	; 0x70
 80293e4:	9d1d      	ldr	r5, [sp, #116]	; 0x74
 80293e6:	f46f 6382 	mvn.w	r3, #1040	; 0x410
 80293ea:	4445      	add	r5, r8
 80293ec:	429d      	cmp	r5, r3
 80293ee:	f2c0 82cb 	blt.w	8029988 <_dtoa_r+0x650>
 80293f2:	f64f 430e 	movw	r3, #64526	; 0xfc0e
 80293f6:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80293fa:	f505 6282 	add.w	r2, r5, #1040	; 0x410
 80293fe:	1b5b      	subs	r3, r3, r5
 8029400:	3202      	adds	r2, #2
 8029402:	fa04 f303 	lsl.w	r3, r4, r3
 8029406:	fa2a f002 	lsr.w	r0, sl, r2
 802940a:	4318      	orrs	r0, r3
 802940c:	f7f9 fd30 	bl	8022e70 <__aeabi_ui2d>
 8029410:	460b      	mov	r3, r1
 8029412:	4602      	mov	r2, r0
 8029414:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8029418:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802941a:	2401      	movs	r4, #1
 802941c:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
 8029420:	9309      	str	r3, [sp, #36]	; 0x24
 8029422:	3d01      	subs	r5, #1
 8029424:	9417      	str	r4, [sp, #92]	; 0x5c
 8029426:	2300      	movs	r3, #0
 8029428:	2200      	movs	r2, #0
 802942a:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 802942e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8029432:	f7f9 fbdf 	bl	8022bf4 <__aeabi_dsub>
 8029436:	a354      	add	r3, pc, #336	; (adr r3, 8029588 <_dtoa_r+0x250>)
 8029438:	e9d3 2300 	ldrd	r2, r3, [r3]
 802943c:	f7f9 fd8e 	bl	8022f5c <__aeabi_dmul>
 8029440:	a353      	add	r3, pc, #332	; (adr r3, 8029590 <_dtoa_r+0x258>)
 8029442:	e9d3 2300 	ldrd	r2, r3, [r3]
 8029446:	f7f9 fbd7 	bl	8022bf8 <__adddf3>
 802944a:	4606      	mov	r6, r0
 802944c:	4628      	mov	r0, r5
 802944e:	460f      	mov	r7, r1
 8029450:	f7f9 fd1e 	bl	8022e90 <__aeabi_i2d>
 8029454:	a350      	add	r3, pc, #320	; (adr r3, 8029598 <_dtoa_r+0x260>)
 8029456:	e9d3 2300 	ldrd	r2, r3, [r3]
 802945a:	f7f9 fd7f 	bl	8022f5c <__aeabi_dmul>
 802945e:	4602      	mov	r2, r0
 8029460:	460b      	mov	r3, r1
 8029462:	4630      	mov	r0, r6
 8029464:	4639      	mov	r1, r7
 8029466:	f7f9 fbc7 	bl	8022bf8 <__adddf3>
 802946a:	4606      	mov	r6, r0
 802946c:	460f      	mov	r7, r1
 802946e:	f7fa f80f 	bl	8023490 <__aeabi_d2iz>
 8029472:	4639      	mov	r1, r7
 8029474:	900b      	str	r0, [sp, #44]	; 0x2c
 8029476:	2200      	movs	r2, #0
 8029478:	4630      	mov	r0, r6
 802947a:	2300      	movs	r3, #0
 802947c:	f7f9 ffe0 	bl	8023440 <__aeabi_dcmplt>
 8029480:	b150      	cbz	r0, 8029498 <_dtoa_r+0x160>
 8029482:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8029484:	f7f9 fd04 	bl	8022e90 <__aeabi_i2d>
 8029488:	4632      	mov	r2, r6
 802948a:	463b      	mov	r3, r7
 802948c:	f7f9 ffce 	bl	802342c <__aeabi_dcmpeq>
 8029490:	b910      	cbnz	r0, 8029498 <_dtoa_r+0x160>
 8029492:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8029494:	3c01      	subs	r4, #1
 8029496:	940b      	str	r4, [sp, #44]	; 0x2c
 8029498:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 802949a:	2c16      	cmp	r4, #22
 802949c:	f200 8252 	bhi.w	8029944 <_dtoa_r+0x60c>
 80294a0:	4b40      	ldr	r3, [pc, #256]	; (80295a4 <_dtoa_r+0x26c>)
 80294a2:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80294a6:	e9d3 0100 	ldrd	r0, r1, [r3]
 80294aa:	4652      	mov	r2, sl
 80294ac:	465b      	mov	r3, fp
 80294ae:	f7f9 ffe5 	bl	802347c <__aeabi_dcmpgt>
 80294b2:	2800      	cmp	r0, #0
 80294b4:	f000 8265 	beq.w	8029982 <_dtoa_r+0x64a>
 80294b8:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80294ba:	3c01      	subs	r4, #1
 80294bc:	940b      	str	r4, [sp, #44]	; 0x2c
 80294be:	2400      	movs	r4, #0
 80294c0:	9416      	str	r4, [sp, #88]	; 0x58
 80294c2:	ebc5 0508 	rsb	r5, r5, r8
 80294c6:	f1b5 0901 	subs.w	r9, r5, #1
 80294ca:	f100 8247 	bmi.w	802995c <_dtoa_r+0x624>
 80294ce:	2500      	movs	r5, #0
 80294d0:	950a      	str	r5, [sp, #40]	; 0x28
 80294d2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80294d4:	2c00      	cmp	r4, #0
 80294d6:	f2c0 8238 	blt.w	802994a <_dtoa_r+0x612>
 80294da:	2500      	movs	r5, #0
 80294dc:	44a1      	add	r9, r4
 80294de:	9414      	str	r4, [sp, #80]	; 0x50
 80294e0:	9510      	str	r5, [sp, #64]	; 0x40
 80294e2:	9c28      	ldr	r4, [sp, #160]	; 0xa0
 80294e4:	2c09      	cmp	r4, #9
 80294e6:	d865      	bhi.n	80295b4 <_dtoa_r+0x27c>
 80294e8:	2c05      	cmp	r4, #5
 80294ea:	f340 8648 	ble.w	802a17e <_dtoa_r+0xe46>
 80294ee:	3c04      	subs	r4, #4
 80294f0:	9428      	str	r4, [sp, #160]	; 0xa0
 80294f2:	2600      	movs	r6, #0
 80294f4:	9d28      	ldr	r5, [sp, #160]	; 0xa0
 80294f6:	1eab      	subs	r3, r5, #2
 80294f8:	2b03      	cmp	r3, #3
 80294fa:	d85d      	bhi.n	80295b8 <_dtoa_r+0x280>
 80294fc:	e8df f013 	tbh	[pc, r3, lsl #1]
 8029500:	02cd03f8 	.word	0x02cd03f8
 8029504:	04020405 	.word	0x04020405
 8029508:	9d2a      	ldr	r5, [sp, #168]	; 0xa8
 802950a:	f242 730f 	movw	r3, #9999	; 0x270f
 802950e:	602b      	str	r3, [r5, #0]
 8029510:	f1ba 0f00 	cmp.w	sl, #0
 8029514:	d015      	beq.n	8029542 <_dtoa_r+0x20a>
 8029516:	4c24      	ldr	r4, [pc, #144]	; (80295a8 <_dtoa_r+0x270>)
 8029518:	9406      	str	r4, [sp, #24]
 802951a:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 802951c:	2d00      	cmp	r5, #0
 802951e:	f43f af48 	beq.w	80293b2 <_dtoa_r+0x7a>
 8029522:	9c06      	ldr	r4, [sp, #24]
 8029524:	78e3      	ldrb	r3, [r4, #3]
 8029526:	2b00      	cmp	r3, #0
 8029528:	f000 811b 	beq.w	8029762 <_dtoa_r+0x42a>
 802952c:	f104 0308 	add.w	r3, r4, #8
 8029530:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8029532:	6023      	str	r3, [r4, #0]
 8029534:	e73d      	b.n	80293b2 <_dtoa_r+0x7a>
 8029536:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 802953a:	2301      	movs	r3, #1
 802953c:	602b      	str	r3, [r5, #0]
 802953e:	46a3      	mov	fp, r4
 8029540:	e714      	b.n	802936c <_dtoa_r+0x34>
 8029542:	4b19      	ldr	r3, [pc, #100]	; (80295a8 <_dtoa_r+0x270>)
 8029544:	4a19      	ldr	r2, [pc, #100]	; (80295ac <_dtoa_r+0x274>)
 8029546:	f3c4 0413 	ubfx	r4, r4, #0, #20
 802954a:	2c00      	cmp	r4, #0
 802954c:	bf18      	it	ne
 802954e:	461a      	movne	r2, r3
 8029550:	9206      	str	r2, [sp, #24]
 8029552:	e7e2      	b.n	802951a <_dtoa_r+0x1e2>
 8029554:	4639      	mov	r1, r7
 8029556:	4630      	mov	r0, r6
 8029558:	e9cd 0108 	strd	r0, r1, [sp, #32]
 802955c:	9909      	ldr	r1, [sp, #36]	; 0x24
 802955e:	f8dd 8070 	ldr.w	r8, [sp, #112]	; 0x70
 8029562:	f021 437f 	bic.w	r3, r1, #4278190080	; 0xff000000
 8029566:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 802956a:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 802956e:	f5a5 757e 	sub.w	r5, r5, #1016	; 0x3f8
 8029572:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
 8029576:	2400      	movs	r4, #0
 8029578:	9309      	str	r3, [sp, #36]	; 0x24
 802957a:	3d07      	subs	r5, #7
 802957c:	9417      	str	r4, [sp, #92]	; 0x5c
 802957e:	e752      	b.n	8029426 <_dtoa_r+0xee>
 8029580:	4c0b      	ldr	r4, [pc, #44]	; (80295b0 <_dtoa_r+0x278>)
 8029582:	9406      	str	r4, [sp, #24]
 8029584:	e715      	b.n	80293b2 <_dtoa_r+0x7a>
 8029586:	bf00      	nop
 8029588:	636f4361 	.word	0x636f4361
 802958c:	3fd287a7 	.word	0x3fd287a7
 8029590:	8b60c8b3 	.word	0x8b60c8b3
 8029594:	3fc68a28 	.word	0x3fc68a28
 8029598:	509f79fb 	.word	0x509f79fb
 802959c:	3fd34413 	.word	0x3fd34413
 80295a0:	08032dbd 	.word	0x08032dbd
 80295a4:	08033170 	.word	0x08033170
 80295a8:	08033160 	.word	0x08033160
 80295ac:	08033154 	.word	0x08033154
 80295b0:	08032dbc 	.word	0x08032dbc
 80295b4:	2400      	movs	r4, #0
 80295b6:	9428      	str	r4, [sp, #160]	; 0xa0
 80295b8:	9d03      	ldr	r5, [sp, #12]
 80295ba:	2400      	movs	r4, #0
 80295bc:	646c      	str	r4, [r5, #68]	; 0x44
 80295be:	4628      	mov	r0, r5
 80295c0:	4621      	mov	r1, r4
 80295c2:	f001 fae9 	bl	802ab98 <_Balloc>
 80295c6:	f04f 35ff 	mov.w	r5, #4294967295
 80295ca:	9515      	str	r5, [sp, #84]	; 0x54
 80295cc:	9d03      	ldr	r5, [sp, #12]
 80295ce:	9006      	str	r0, [sp, #24]
 80295d0:	6428      	str	r0, [r5, #64]	; 0x40
 80295d2:	2501      	movs	r5, #1
 80295d4:	9511      	str	r5, [sp, #68]	; 0x44
 80295d6:	f04f 35ff 	mov.w	r5, #4294967295
 80295da:	950c      	str	r5, [sp, #48]	; 0x30
 80295dc:	9429      	str	r4, [sp, #164]	; 0xa4
 80295de:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80295e0:	2b00      	cmp	r3, #0
 80295e2:	f2c0 80c3 	blt.w	802976c <_dtoa_r+0x434>
 80295e6:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80295e8:	2c0e      	cmp	r4, #14
 80295ea:	f300 80bf 	bgt.w	802976c <_dtoa_r+0x434>
 80295ee:	4b5e      	ldr	r3, [pc, #376]	; (8029768 <_dtoa_r+0x430>)
 80295f0:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80295f4:	e9d3 4500 	ldrd	r4, r5, [r3]
 80295f8:	e9cd 4504 	strd	r4, r5, [sp, #16]
 80295fc:	9d29      	ldr	r5, [sp, #164]	; 0xa4
 80295fe:	2d00      	cmp	r5, #0
 8029600:	f2c0 8386 	blt.w	8029d10 <_dtoa_r+0x9d8>
 8029604:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8029608:	4650      	mov	r0, sl
 802960a:	4659      	mov	r1, fp
 802960c:	f7f9 fdd0 	bl	80231b0 <__aeabi_ddiv>
 8029610:	f7f9 ff3e 	bl	8023490 <__aeabi_d2iz>
 8029614:	4680      	mov	r8, r0
 8029616:	f7f9 fc3b 	bl	8022e90 <__aeabi_i2d>
 802961a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 802961e:	f7f9 fc9d 	bl	8022f5c <__aeabi_dmul>
 8029622:	9c06      	ldr	r4, [sp, #24]
 8029624:	460b      	mov	r3, r1
 8029626:	4602      	mov	r2, r0
 8029628:	4659      	mov	r1, fp
 802962a:	4650      	mov	r0, sl
 802962c:	f7f9 fae2 	bl	8022bf4 <__aeabi_dsub>
 8029630:	f108 0330 	add.w	r3, r8, #48	; 0x30
 8029634:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8029636:	f804 3b01 	strb.w	r3, [r4], #1
 802963a:	2d01      	cmp	r5, #1
 802963c:	940e      	str	r4, [sp, #56]	; 0x38
 802963e:	4682      	mov	sl, r0
 8029640:	468b      	mov	fp, r1
 8029642:	4627      	mov	r7, r4
 8029644:	d04b      	beq.n	80296de <_dtoa_r+0x3a6>
 8029646:	2300      	movs	r3, #0
 8029648:	2200      	movs	r2, #0
 802964a:	f2c4 0324 	movt	r3, #16420	; 0x4024
 802964e:	f7f9 fc85 	bl	8022f5c <__aeabi_dmul>
 8029652:	2300      	movs	r3, #0
 8029654:	2200      	movs	r2, #0
 8029656:	4682      	mov	sl, r0
 8029658:	468b      	mov	fp, r1
 802965a:	f7f9 fee7 	bl	802342c <__aeabi_dcmpeq>
 802965e:	2301      	movs	r3, #1
 8029660:	2800      	cmp	r0, #0
 8029662:	f040 8218 	bne.w	8029a96 <_dtoa_r+0x75e>
 8029666:	f013 0fff 	tst.w	r3, #255	; 0xff
 802966a:	d06a      	beq.n	8029742 <_dtoa_r+0x40a>
 802966c:	9d06      	ldr	r5, [sp, #24]
 802966e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8029670:	1cac      	adds	r4, r5, #2
 8029672:	eb05 0900 	add.w	r9, r5, r0
 8029676:	e00e      	b.n	8029696 <_dtoa_r+0x35e>
 8029678:	f7f9 fc70 	bl	8022f5c <__aeabi_dmul>
 802967c:	2300      	movs	r3, #0
 802967e:	2200      	movs	r2, #0
 8029680:	4682      	mov	sl, r0
 8029682:	468b      	mov	fp, r1
 8029684:	f7f9 fed2 	bl	802342c <__aeabi_dcmpeq>
 8029688:	3401      	adds	r4, #1
 802968a:	2301      	movs	r3, #1
 802968c:	b100      	cbz	r0, 8029690 <_dtoa_r+0x358>
 802968e:	2300      	movs	r3, #0
 8029690:	f013 0fff 	tst.w	r3, #255	; 0xff
 8029694:	d055      	beq.n	8029742 <_dtoa_r+0x40a>
 8029696:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 802969a:	4650      	mov	r0, sl
 802969c:	4659      	mov	r1, fp
 802969e:	f7f9 fd87 	bl	80231b0 <__aeabi_ddiv>
 80296a2:	f7f9 fef5 	bl	8023490 <__aeabi_d2iz>
 80296a6:	4680      	mov	r8, r0
 80296a8:	f7f9 fbf2 	bl	8022e90 <__aeabi_i2d>
 80296ac:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80296b0:	f7f9 fc54 	bl	8022f5c <__aeabi_dmul>
 80296b4:	4602      	mov	r2, r0
 80296b6:	460b      	mov	r3, r1
 80296b8:	4650      	mov	r0, sl
 80296ba:	4659      	mov	r1, fp
 80296bc:	f7f9 fa9a 	bl	8022bf4 <__aeabi_dsub>
 80296c0:	f108 0530 	add.w	r5, r8, #48	; 0x30
 80296c4:	460f      	mov	r7, r1
 80296c6:	2300      	movs	r3, #0
 80296c8:	4606      	mov	r6, r0
 80296ca:	2200      	movs	r2, #0
 80296cc:	454c      	cmp	r4, r9
 80296ce:	46bb      	mov	fp, r7
 80296d0:	f2c4 0324 	movt	r3, #16420	; 0x4024
 80296d4:	f804 5c01 	strb.w	r5, [r4, #-1]
 80296d8:	46b2      	mov	sl, r6
 80296da:	4627      	mov	r7, r4
 80296dc:	d1cc      	bne.n	8029678 <_dtoa_r+0x340>
 80296de:	4652      	mov	r2, sl
 80296e0:	465b      	mov	r3, fp
 80296e2:	4650      	mov	r0, sl
 80296e4:	4659      	mov	r1, fp
 80296e6:	f7f9 fa87 	bl	8022bf8 <__adddf3>
 80296ea:	4604      	mov	r4, r0
 80296ec:	460d      	mov	r5, r1
 80296ee:	4622      	mov	r2, r4
 80296f0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80296f4:	462b      	mov	r3, r5
 80296f6:	f7f9 fea3 	bl	8023440 <__aeabi_dcmplt>
 80296fa:	b948      	cbnz	r0, 8029710 <_dtoa_r+0x3d8>
 80296fc:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8029700:	4622      	mov	r2, r4
 8029702:	462b      	mov	r3, r5
 8029704:	f7f9 fe92 	bl	802342c <__aeabi_dcmpeq>
 8029708:	b1d8      	cbz	r0, 8029742 <_dtoa_r+0x40a>
 802970a:	f018 0f01 	tst.w	r8, #1
 802970e:	d018      	beq.n	8029742 <_dtoa_r+0x40a>
 8029710:	f817 5c01 	ldrb.w	r5, [r7, #-1]
 8029714:	463b      	mov	r3, r7
 8029716:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8029718:	e002      	b.n	8029720 <_dtoa_r+0x3e8>
 802971a:	f813 5c02 	ldrb.w	r5, [r3, #-2]
 802971e:	3b01      	subs	r3, #1
 8029720:	2d39      	cmp	r5, #57	; 0x39
 8029722:	461f      	mov	r7, r3
 8029724:	f040 84da 	bne.w	802a0dc <_dtoa_r+0xda4>
 8029728:	4293      	cmp	r3, r2
 802972a:	d1f6      	bne.n	802971a <_dtoa_r+0x3e2>
 802972c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 802972e:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8029730:	2330      	movs	r3, #48	; 0x30
 8029732:	f805 3c01 	strb.w	r3, [r5, #-1]
 8029736:	462b      	mov	r3, r5
 8029738:	3401      	adds	r4, #1
 802973a:	2231      	movs	r2, #49	; 0x31
 802973c:	940b      	str	r4, [sp, #44]	; 0x2c
 802973e:	f803 2c01 	strb.w	r2, [r3, #-1]
 8029742:	9803      	ldr	r0, [sp, #12]
 8029744:	990d      	ldr	r1, [sp, #52]	; 0x34
 8029746:	f001 fa4d 	bl	802abe4 <_Bfree>
 802974a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802974c:	9c2a      	ldr	r4, [sp, #168]	; 0xa8
 802974e:	1c6b      	adds	r3, r5, #1
 8029750:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 8029752:	2200      	movs	r2, #0
 8029754:	703a      	strb	r2, [r7, #0]
 8029756:	6023      	str	r3, [r4, #0]
 8029758:	2d00      	cmp	r5, #0
 802975a:	f43f ae2a 	beq.w	80293b2 <_dtoa_r+0x7a>
 802975e:	602f      	str	r7, [r5, #0]
 8029760:	e627      	b.n	80293b2 <_dtoa_r+0x7a>
 8029762:	9d06      	ldr	r5, [sp, #24]
 8029764:	1ceb      	adds	r3, r5, #3
 8029766:	e6e3      	b.n	8029530 <_dtoa_r+0x1f8>
 8029768:	08033170 	.word	0x08033170
 802976c:	9d11      	ldr	r5, [sp, #68]	; 0x44
 802976e:	2d00      	cmp	r5, #0
 8029770:	f000 80fb 	beq.w	802996a <_dtoa_r+0x632>
 8029774:	9c28      	ldr	r4, [sp, #160]	; 0xa0
 8029776:	2c01      	cmp	r4, #1
 8029778:	f340 82f8 	ble.w	8029d6c <_dtoa_r+0xa34>
 802977c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 802977e:	1e65      	subs	r5, r4, #1
 8029780:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8029782:	42ac      	cmp	r4, r5
 8029784:	f2c0 83ab 	blt.w	8029ede <_dtoa_r+0xba6>
 8029788:	1b65      	subs	r5, r4, r5
 802978a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 802978c:	2c00      	cmp	r4, #0
 802978e:	f2c0 8494 	blt.w	802a0ba <_dtoa_r+0xd82>
 8029792:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8029794:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8029796:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8029798:	9803      	ldr	r0, [sp, #12]
 802979a:	18d2      	adds	r2, r2, r3
 802979c:	2101      	movs	r1, #1
 802979e:	920a      	str	r2, [sp, #40]	; 0x28
 80297a0:	4499      	add	r9, r3
 80297a2:	f001 fab7 	bl	802ad14 <__i2b>
 80297a6:	4680      	mov	r8, r0
 80297a8:	b164      	cbz	r4, 80297c4 <_dtoa_r+0x48c>
 80297aa:	f1b9 0f00 	cmp.w	r9, #0
 80297ae:	dd09      	ble.n	80297c4 <_dtoa_r+0x48c>
 80297b0:	980a      	ldr	r0, [sp, #40]	; 0x28
 80297b2:	45a1      	cmp	r9, r4
 80297b4:	bfb4      	ite	lt
 80297b6:	464b      	movlt	r3, r9
 80297b8:	4623      	movge	r3, r4
 80297ba:	1ac0      	subs	r0, r0, r3
 80297bc:	900a      	str	r0, [sp, #40]	; 0x28
 80297be:	1ae4      	subs	r4, r4, r3
 80297c0:	ebc3 0909 	rsb	r9, r3, r9
 80297c4:	9910      	ldr	r1, [sp, #64]	; 0x40
 80297c6:	2900      	cmp	r1, #0
 80297c8:	dd1a      	ble.n	8029800 <_dtoa_r+0x4c8>
 80297ca:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80297cc:	2a00      	cmp	r2, #0
 80297ce:	f000 837f 	beq.w	8029ed0 <_dtoa_r+0xb98>
 80297d2:	2d00      	cmp	r5, #0
 80297d4:	dd10      	ble.n	80297f8 <_dtoa_r+0x4c0>
 80297d6:	4641      	mov	r1, r8
 80297d8:	462a      	mov	r2, r5
 80297da:	9803      	ldr	r0, [sp, #12]
 80297dc:	f001 fb46 	bl	802ae6c <__pow5mult>
 80297e0:	4680      	mov	r8, r0
 80297e2:	4641      	mov	r1, r8
 80297e4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80297e6:	9803      	ldr	r0, [sp, #12]
 80297e8:	f001 fa9e 	bl	802ad28 <__multiply>
 80297ec:	990d      	ldr	r1, [sp, #52]	; 0x34
 80297ee:	4606      	mov	r6, r0
 80297f0:	9803      	ldr	r0, [sp, #12]
 80297f2:	f001 f9f7 	bl	802abe4 <_Bfree>
 80297f6:	960d      	str	r6, [sp, #52]	; 0x34
 80297f8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80297fa:	1b5a      	subs	r2, r3, r5
 80297fc:	f040 82a5 	bne.w	8029d4a <_dtoa_r+0xa12>
 8029800:	2101      	movs	r1, #1
 8029802:	9803      	ldr	r0, [sp, #12]
 8029804:	f001 fa86 	bl	802ad14 <__i2b>
 8029808:	4605      	mov	r5, r0
 802980a:	9814      	ldr	r0, [sp, #80]	; 0x50
 802980c:	2800      	cmp	r0, #0
 802980e:	dd05      	ble.n	802981c <_dtoa_r+0x4e4>
 8029810:	4629      	mov	r1, r5
 8029812:	9803      	ldr	r0, [sp, #12]
 8029814:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8029816:	f001 fb29 	bl	802ae6c <__pow5mult>
 802981a:	4605      	mov	r5, r0
 802981c:	9928      	ldr	r1, [sp, #160]	; 0xa0
 802981e:	2901      	cmp	r1, #1
 8029820:	f340 8122 	ble.w	8029a68 <_dtoa_r+0x730>
 8029824:	2600      	movs	r6, #0
 8029826:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8029828:	2b00      	cmp	r3, #0
 802982a:	f040 832a 	bne.w	8029e82 <_dtoa_r+0xb4a>
 802982e:	2301      	movs	r3, #1
 8029830:	444b      	add	r3, r9
 8029832:	f013 031f 	ands.w	r3, r3, #31
 8029836:	f000 809d 	beq.w	8029974 <_dtoa_r+0x63c>
 802983a:	f1c3 0220 	rsb	r2, r3, #32
 802983e:	2a04      	cmp	r2, #4
 8029840:	f340 84a0 	ble.w	802a184 <_dtoa_r+0xe4c>
 8029844:	980a      	ldr	r0, [sp, #40]	; 0x28
 8029846:	f1c3 031c 	rsb	r3, r3, #28
 802984a:	18c0      	adds	r0, r0, r3
 802984c:	900a      	str	r0, [sp, #40]	; 0x28
 802984e:	18e4      	adds	r4, r4, r3
 8029850:	4499      	add	r9, r3
 8029852:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8029854:	2a00      	cmp	r2, #0
 8029856:	dd04      	ble.n	8029862 <_dtoa_r+0x52a>
 8029858:	9803      	ldr	r0, [sp, #12]
 802985a:	990d      	ldr	r1, [sp, #52]	; 0x34
 802985c:	f001 fb52 	bl	802af04 <__lshift>
 8029860:	900d      	str	r0, [sp, #52]	; 0x34
 8029862:	f1b9 0f00 	cmp.w	r9, #0
 8029866:	dd05      	ble.n	8029874 <_dtoa_r+0x53c>
 8029868:	4629      	mov	r1, r5
 802986a:	9803      	ldr	r0, [sp, #12]
 802986c:	464a      	mov	r2, r9
 802986e:	f001 fb49 	bl	802af04 <__lshift>
 8029872:	4605      	mov	r5, r0
 8029874:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8029876:	2b00      	cmp	r3, #0
 8029878:	f040 82eb 	bne.w	8029e52 <_dtoa_r+0xb1a>
 802987c:	980c      	ldr	r0, [sp, #48]	; 0x30
 802987e:	2800      	cmp	r0, #0
 8029880:	f340 8308 	ble.w	8029e94 <_dtoa_r+0xb5c>
 8029884:	9811      	ldr	r0, [sp, #68]	; 0x44
 8029886:	2800      	cmp	r0, #0
 8029888:	f040 8086 	bne.w	8029998 <_dtoa_r+0x660>
 802988c:	46c2      	mov	sl, r8
 802988e:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8029890:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8029892:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
 8029896:	9f06      	ldr	r7, [sp, #24]
 8029898:	f8dd 800c 	ldr.w	r8, [sp, #12]
 802989c:	e006      	b.n	80298ac <_dtoa_r+0x574>
 802989e:	4659      	mov	r1, fp
 80298a0:	4640      	mov	r0, r8
 80298a2:	220a      	movs	r2, #10
 80298a4:	2300      	movs	r3, #0
 80298a6:	f001 f9a7 	bl	802abf8 <__multadd>
 80298aa:	4683      	mov	fp, r0
 80298ac:	4629      	mov	r1, r5
 80298ae:	4658      	mov	r0, fp
 80298b0:	f7ff fc9a 	bl	80291e8 <quorem>
 80298b4:	f100 0930 	add.w	r9, r0, #48	; 0x30
 80298b8:	f807 9004 	strb.w	r9, [r7, r4]
 80298bc:	3401      	adds	r4, #1
 80298be:	42a6      	cmp	r6, r4
 80298c0:	dced      	bgt.n	802989e <_dtoa_r+0x566>
 80298c2:	46d0      	mov	r8, sl
 80298c4:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80298c6:	f8dd a018 	ldr.w	sl, [sp, #24]
 80298ca:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
 80298ce:	2c01      	cmp	r4, #1
 80298d0:	bfac      	ite	ge
 80298d2:	44a2      	addge	sl, r4
 80298d4:	f10a 0a01 	addlt.w	sl, sl, #1
 80298d8:	2600      	movs	r6, #0
 80298da:	2201      	movs	r2, #1
 80298dc:	990d      	ldr	r1, [sp, #52]	; 0x34
 80298de:	9803      	ldr	r0, [sp, #12]
 80298e0:	f001 fb10 	bl	802af04 <__lshift>
 80298e4:	4629      	mov	r1, r5
 80298e6:	900d      	str	r0, [sp, #52]	; 0x34
 80298e8:	f001 fb6c 	bl	802afc4 <__mcmp>
 80298ec:	2800      	cmp	r0, #0
 80298ee:	f340 8232 	ble.w	8029d56 <_dtoa_r+0xa1e>
 80298f2:	f81a 3c01 	ldrb.w	r3, [sl, #-1]
 80298f6:	9c06      	ldr	r4, [sp, #24]
 80298f8:	1c62      	adds	r2, r4, #1
 80298fa:	e003      	b.n	8029904 <_dtoa_r+0x5cc>
 80298fc:	f81a 3c02 	ldrb.w	r3, [sl, #-2]
 8029900:	f10a 3aff 	add.w	sl, sl, #4294967295
 8029904:	2b39      	cmp	r3, #57	; 0x39
 8029906:	4657      	mov	r7, sl
 8029908:	f040 834c 	bne.w	8029fa4 <_dtoa_r+0xc6c>
 802990c:	4592      	cmp	sl, r2
 802990e:	d1f5      	bne.n	80298fc <_dtoa_r+0x5c4>
 8029910:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8029912:	2331      	movs	r3, #49	; 0x31
 8029914:	3401      	adds	r4, #1
 8029916:	940b      	str	r4, [sp, #44]	; 0x2c
 8029918:	f802 3c01 	strb.w	r3, [r2, #-1]
 802991c:	9803      	ldr	r0, [sp, #12]
 802991e:	4629      	mov	r1, r5
 8029920:	f001 f960 	bl	802abe4 <_Bfree>
 8029924:	f1b8 0f00 	cmp.w	r8, #0
 8029928:	f43f af0b 	beq.w	8029742 <_dtoa_r+0x40a>
 802992c:	b12e      	cbz	r6, 802993a <_dtoa_r+0x602>
 802992e:	4546      	cmp	r6, r8
 8029930:	d003      	beq.n	802993a <_dtoa_r+0x602>
 8029932:	9803      	ldr	r0, [sp, #12]
 8029934:	4631      	mov	r1, r6
 8029936:	f001 f955 	bl	802abe4 <_Bfree>
 802993a:	9803      	ldr	r0, [sp, #12]
 802993c:	4641      	mov	r1, r8
 802993e:	f001 f951 	bl	802abe4 <_Bfree>
 8029942:	e6fe      	b.n	8029742 <_dtoa_r+0x40a>
 8029944:	2401      	movs	r4, #1
 8029946:	9416      	str	r4, [sp, #88]	; 0x58
 8029948:	e5bb      	b.n	80294c2 <_dtoa_r+0x18a>
 802994a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802994c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 802994e:	1b64      	subs	r4, r4, r5
 8029950:	940a      	str	r4, [sp, #40]	; 0x28
 8029952:	426c      	negs	r4, r5
 8029954:	2500      	movs	r5, #0
 8029956:	9410      	str	r4, [sp, #64]	; 0x40
 8029958:	9514      	str	r5, [sp, #80]	; 0x50
 802995a:	e5c2      	b.n	80294e2 <_dtoa_r+0x1aa>
 802995c:	f1c9 0900 	rsb	r9, r9, #0
 8029960:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 8029964:	f04f 0900 	mov.w	r9, #0
 8029968:	e5b3      	b.n	80294d2 <_dtoa_r+0x19a>
 802996a:	9d10      	ldr	r5, [sp, #64]	; 0x40
 802996c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 802996e:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8029972:	e719      	b.n	80297a8 <_dtoa_r+0x470>
 8029974:	231c      	movs	r3, #28
 8029976:	990a      	ldr	r1, [sp, #40]	; 0x28
 8029978:	18c9      	adds	r1, r1, r3
 802997a:	910a      	str	r1, [sp, #40]	; 0x28
 802997c:	18e4      	adds	r4, r4, r3
 802997e:	4499      	add	r9, r3
 8029980:	e767      	b.n	8029852 <_dtoa_r+0x51a>
 8029982:	2400      	movs	r4, #0
 8029984:	9416      	str	r4, [sp, #88]	; 0x58
 8029986:	e59c      	b.n	80294c2 <_dtoa_r+0x18a>
 8029988:	f64f 30ee 	movw	r0, #64494	; 0xfbee
 802998c:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 8029990:	1b40      	subs	r0, r0, r5
 8029992:	fa0a f000 	lsl.w	r0, sl, r0
 8029996:	e539      	b.n	802940c <_dtoa_r+0xd4>
 8029998:	2c00      	cmp	r4, #0
 802999a:	dd05      	ble.n	80299a8 <_dtoa_r+0x670>
 802999c:	4641      	mov	r1, r8
 802999e:	9803      	ldr	r0, [sp, #12]
 80299a0:	4622      	mov	r2, r4
 80299a2:	f001 faaf 	bl	802af04 <__lshift>
 80299a6:	4680      	mov	r8, r0
 80299a8:	2e00      	cmp	r6, #0
 80299aa:	f040 82ff 	bne.w	8029fac <_dtoa_r+0xc74>
 80299ae:	4644      	mov	r4, r8
 80299b0:	9f06      	ldr	r7, [sp, #24]
 80299b2:	9507      	str	r5, [sp, #28]
 80299b4:	4646      	mov	r6, r8
 80299b6:	f04f 0801 	mov.w	r8, #1
 80299ba:	ea0a 0108 	and.w	r1, sl, r8
 80299be:	46c1      	mov	r9, r8
 80299c0:	9d03      	ldr	r5, [sp, #12]
 80299c2:	9110      	str	r1, [sp, #64]	; 0x40
 80299c4:	46b8      	mov	r8, r7
 80299c6:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 80299c8:	9907      	ldr	r1, [sp, #28]
 80299ca:	4638      	mov	r0, r7
 80299cc:	f7ff fc0c 	bl	80291e8 <quorem>
 80299d0:	4631      	mov	r1, r6
 80299d2:	900a      	str	r0, [sp, #40]	; 0x28
 80299d4:	4638      	mov	r0, r7
 80299d6:	f001 faf5 	bl	802afc4 <__mcmp>
 80299da:	4622      	mov	r2, r4
 80299dc:	9008      	str	r0, [sp, #32]
 80299de:	9907      	ldr	r1, [sp, #28]
 80299e0:	4628      	mov	r0, r5
 80299e2:	f001 fb0d 	bl	802b000 <__mdiff>
 80299e6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80299e8:	f102 0330 	add.w	r3, r2, #48	; 0x30
 80299ec:	68c2      	ldr	r2, [r0, #12]
 80299ee:	4682      	mov	sl, r0
 80299f0:	2a00      	cmp	r2, #0
 80299f2:	f000 81c9 	beq.w	8029d88 <_dtoa_r+0xa50>
 80299f6:	4628      	mov	r0, r5
 80299f8:	4651      	mov	r1, sl
 80299fa:	9302      	str	r3, [sp, #8]
 80299fc:	f001 f8f2 	bl	802abe4 <_Bfree>
 8029a00:	9b02      	ldr	r3, [sp, #8]
 8029a02:	f04f 0b01 	mov.w	fp, #1
 8029a06:	9808      	ldr	r0, [sp, #32]
 8029a08:	2800      	cmp	r0, #0
 8029a0a:	f2c0 8281 	blt.w	8029f10 <_dtoa_r+0xbd8>
 8029a0e:	d105      	bne.n	8029a1c <_dtoa_r+0x6e4>
 8029a10:	9928      	ldr	r1, [sp, #160]	; 0xa0
 8029a12:	b919      	cbnz	r1, 8029a1c <_dtoa_r+0x6e4>
 8029a14:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8029a16:	2a00      	cmp	r2, #0
 8029a18:	f000 827a 	beq.w	8029f10 <_dtoa_r+0xbd8>
 8029a1c:	f1bb 0f00 	cmp.w	fp, #0
 8029a20:	f300 82db 	bgt.w	8029fda <_dtoa_r+0xca2>
 8029a24:	980c      	ldr	r0, [sp, #48]	; 0x30
 8029a26:	f808 3b01 	strb.w	r3, [r8], #1
 8029a2a:	4581      	cmp	r9, r0
 8029a2c:	46c2      	mov	sl, r8
 8029a2e:	f000 82e0 	beq.w	8029ff2 <_dtoa_r+0xcba>
 8029a32:	4639      	mov	r1, r7
 8029a34:	220a      	movs	r2, #10
 8029a36:	2300      	movs	r3, #0
 8029a38:	4628      	mov	r0, r5
 8029a3a:	f001 f8dd 	bl	802abf8 <__multadd>
 8029a3e:	42a6      	cmp	r6, r4
 8029a40:	4607      	mov	r7, r0
 8029a42:	f000 81c9 	beq.w	8029dd8 <_dtoa_r+0xaa0>
 8029a46:	4631      	mov	r1, r6
 8029a48:	220a      	movs	r2, #10
 8029a4a:	2300      	movs	r3, #0
 8029a4c:	4628      	mov	r0, r5
 8029a4e:	f001 f8d3 	bl	802abf8 <__multadd>
 8029a52:	4621      	mov	r1, r4
 8029a54:	4606      	mov	r6, r0
 8029a56:	220a      	movs	r2, #10
 8029a58:	4628      	mov	r0, r5
 8029a5a:	2300      	movs	r3, #0
 8029a5c:	f001 f8cc 	bl	802abf8 <__multadd>
 8029a60:	f109 0901 	add.w	r9, r9, #1
 8029a64:	4604      	mov	r4, r0
 8029a66:	e7af      	b.n	80299c8 <_dtoa_r+0x690>
 8029a68:	f1ba 0f00 	cmp.w	sl, #0
 8029a6c:	f47f aeda 	bne.w	8029824 <_dtoa_r+0x4ec>
 8029a70:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8029a74:	2b00      	cmp	r3, #0
 8029a76:	f040 832e 	bne.w	802a0d6 <_dtoa_r+0xd9e>
 8029a7a:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 8029a7e:	ea0b 0303 	and.w	r3, fp, r3
 8029a82:	2b00      	cmp	r3, #0
 8029a84:	f000 8350 	beq.w	802a128 <_dtoa_r+0xdf0>
 8029a88:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8029a8a:	3201      	adds	r2, #1
 8029a8c:	920a      	str	r2, [sp, #40]	; 0x28
 8029a8e:	f109 0901 	add.w	r9, r9, #1
 8029a92:	2601      	movs	r6, #1
 8029a94:	e6c7      	b.n	8029826 <_dtoa_r+0x4ee>
 8029a96:	2300      	movs	r3, #0
 8029a98:	e5e5      	b.n	8029666 <_dtoa_r+0x32e>
 8029a9a:	2400      	movs	r4, #0
 8029a9c:	9411      	str	r4, [sp, #68]	; 0x44
 8029a9e:	9c29      	ldr	r4, [sp, #164]	; 0xa4
 8029aa0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8029aa2:	1965      	adds	r5, r4, r5
 8029aa4:	9515      	str	r5, [sp, #84]	; 0x54
 8029aa6:	3501      	adds	r5, #1
 8029aa8:	2d00      	cmp	r5, #0
 8029aaa:	462c      	mov	r4, r5
 8029aac:	f340 8229 	ble.w	8029f02 <_dtoa_r+0xbca>
 8029ab0:	950c      	str	r5, [sp, #48]	; 0x30
 8029ab2:	9803      	ldr	r0, [sp, #12]
 8029ab4:	2100      	movs	r1, #0
 8029ab6:	2d17      	cmp	r5, #23
 8029ab8:	6441      	str	r1, [r0, #68]	; 0x44
 8029aba:	d90a      	bls.n	8029ad2 <_dtoa_r+0x79a>
 8029abc:	2201      	movs	r2, #1
 8029abe:	2304      	movs	r3, #4
 8029ac0:	005b      	lsls	r3, r3, #1
 8029ac2:	f103 0014 	add.w	r0, r3, #20
 8029ac6:	4611      	mov	r1, r2
 8029ac8:	3201      	adds	r2, #1
 8029aca:	42a8      	cmp	r0, r5
 8029acc:	d9f8      	bls.n	8029ac0 <_dtoa_r+0x788>
 8029ace:	9d03      	ldr	r5, [sp, #12]
 8029ad0:	6469      	str	r1, [r5, #68]	; 0x44
 8029ad2:	9803      	ldr	r0, [sp, #12]
 8029ad4:	f001 f860 	bl	802ab98 <_Balloc>
 8029ad8:	9d03      	ldr	r5, [sp, #12]
 8029ada:	9006      	str	r0, [sp, #24]
 8029adc:	2c0e      	cmp	r4, #14
 8029ade:	6428      	str	r0, [r5, #64]	; 0x40
 8029ae0:	f63f ad7d 	bhi.w	80295de <_dtoa_r+0x2a6>
 8029ae4:	2e00      	cmp	r6, #0
 8029ae6:	f43f ad7a 	beq.w	80295de <_dtoa_r+0x2a6>
 8029aea:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8029aec:	4650      	mov	r0, sl
 8029aee:	4659      	mov	r1, fp
 8029af0:	2c00      	cmp	r4, #0
 8029af2:	e9cd ab0e 	strd	sl, fp, [sp, #56]	; 0x38
 8029af6:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8029afa:	f340 822f 	ble.w	8029f5c <_dtoa_r+0xc24>
 8029afe:	4ba0      	ldr	r3, [pc, #640]	; (8029d80 <_dtoa_r+0xa48>)
 8029b00:	f004 020f 	and.w	r2, r4, #15
 8029b04:	1124      	asrs	r4, r4, #4
 8029b06:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8029b0a:	06e5      	lsls	r5, r4, #27
 8029b0c:	e9d3 ab00 	ldrd	sl, fp, [r3]
 8029b10:	f140 81ed 	bpl.w	8029eee <_dtoa_r+0xbb6>
 8029b14:	4b9b      	ldr	r3, [pc, #620]	; (8029d84 <_dtoa_r+0xa4c>)
 8029b16:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8029b1a:	f7f9 fb49 	bl	80231b0 <__aeabi_ddiv>
 8029b1e:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8029b22:	f004 040f 	and.w	r4, r4, #15
 8029b26:	2603      	movs	r6, #3
 8029b28:	b174      	cbz	r4, 8029b48 <_dtoa_r+0x810>
 8029b2a:	4d96      	ldr	r5, [pc, #600]	; (8029d84 <_dtoa_r+0xa4c>)
 8029b2c:	4650      	mov	r0, sl
 8029b2e:	4659      	mov	r1, fp
 8029b30:	07e2      	lsls	r2, r4, #31
 8029b32:	d504      	bpl.n	8029b3e <_dtoa_r+0x806>
 8029b34:	e9d5 2300 	ldrd	r2, r3, [r5]
 8029b38:	f7f9 fa10 	bl	8022f5c <__aeabi_dmul>
 8029b3c:	3601      	adds	r6, #1
 8029b3e:	3508      	adds	r5, #8
 8029b40:	1064      	asrs	r4, r4, #1
 8029b42:	d1f5      	bne.n	8029b30 <_dtoa_r+0x7f8>
 8029b44:	4682      	mov	sl, r0
 8029b46:	468b      	mov	fp, r1
 8029b48:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8029b4c:	4652      	mov	r2, sl
 8029b4e:	465b      	mov	r3, fp
 8029b50:	f7f9 fb2e 	bl	80231b0 <__aeabi_ddiv>
 8029b54:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8029b58:	9c16      	ldr	r4, [sp, #88]	; 0x58
 8029b5a:	2c00      	cmp	r4, #0
 8029b5c:	f000 8147 	beq.w	8029dee <_dtoa_r+0xab6>
 8029b60:	2300      	movs	r3, #0
 8029b62:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8029b66:	2200      	movs	r2, #0
 8029b68:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 8029b6c:	f7f9 fc68 	bl	8023440 <__aeabi_dcmplt>
 8029b70:	2800      	cmp	r0, #0
 8029b72:	f000 813c 	beq.w	8029dee <_dtoa_r+0xab6>
 8029b76:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8029b78:	2d00      	cmp	r5, #0
 8029b7a:	f000 82d8 	beq.w	802a12e <_dtoa_r+0xdf6>
 8029b7e:	9c15      	ldr	r4, [sp, #84]	; 0x54
 8029b80:	2c00      	cmp	r4, #0
 8029b82:	f340 81e5 	ble.w	8029f50 <_dtoa_r+0xc18>
 8029b86:	2300      	movs	r3, #0
 8029b88:	2200      	movs	r2, #0
 8029b8a:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8029b8e:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8029b92:	f7f9 f9e3 	bl	8022f5c <__aeabi_dmul>
 8029b96:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8029b9a:	1c70      	adds	r0, r6, #1
 8029b9c:	f7f9 f978 	bl	8022e90 <__aeabi_i2d>
 8029ba0:	4602      	mov	r2, r0
 8029ba2:	460b      	mov	r3, r1
 8029ba4:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8029ba8:	f7f9 f9d8 	bl	8022f5c <__aeabi_dmul>
 8029bac:	2300      	movs	r3, #0
 8029bae:	2200      	movs	r2, #0
 8029bb0:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8029bb4:	f7f9 f820 	bl	8022bf8 <__adddf3>
 8029bb8:	4604      	mov	r4, r0
 8029bba:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8029bbc:	f8dd 8054 	ldr.w	r8, [sp, #84]	; 0x54
 8029bc0:	3801      	subs	r0, #1
 8029bc2:	901a      	str	r0, [sp, #104]	; 0x68
 8029bc4:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
 8029bc8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8029bca:	2b00      	cmp	r3, #0
 8029bcc:	f000 8219 	beq.w	802a002 <_dtoa_r+0xcca>
 8029bd0:	4b6b      	ldr	r3, [pc, #428]	; (8029d80 <_dtoa_r+0xa48>)
 8029bd2:	2100      	movs	r1, #0
 8029bd4:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
 8029bd8:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8029bdc:	2000      	movs	r0, #0
 8029bde:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 8029be2:	f7f9 fae5 	bl	80231b0 <__aeabi_ddiv>
 8029be6:	4622      	mov	r2, r4
 8029be8:	462b      	mov	r3, r5
 8029bea:	f7f9 f803 	bl	8022bf4 <__aeabi_dsub>
 8029bee:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 8029bf2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8029bf6:	f7f9 fc4b 	bl	8023490 <__aeabi_d2iz>
 8029bfa:	4605      	mov	r5, r0
 8029bfc:	f7f9 f948 	bl	8022e90 <__aeabi_i2d>
 8029c00:	4602      	mov	r2, r0
 8029c02:	460b      	mov	r3, r1
 8029c04:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8029c08:	f7f8 fff4 	bl	8022bf4 <__aeabi_dsub>
 8029c0c:	3530      	adds	r5, #48	; 0x30
 8029c0e:	9c06      	ldr	r4, [sp, #24]
 8029c10:	b2ed      	uxtb	r5, r5
 8029c12:	4682      	mov	sl, r0
 8029c14:	468b      	mov	fp, r1
 8029c16:	f804 5b01 	strb.w	r5, [r4], #1
 8029c1a:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 8029c1e:	4652      	mov	r2, sl
 8029c20:	465b      	mov	r3, fp
 8029c22:	940e      	str	r4, [sp, #56]	; 0x38
 8029c24:	f7f9 fc2a 	bl	802347c <__aeabi_dcmpgt>
 8029c28:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 8029c2a:	2800      	cmp	r0, #0
 8029c2c:	f040 8274 	bne.w	802a118 <_dtoa_r+0xde0>
 8029c30:	2100      	movs	r1, #0
 8029c32:	4652      	mov	r2, sl
 8029c34:	465b      	mov	r3, fp
 8029c36:	2000      	movs	r0, #0
 8029c38:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8029c3c:	f7f8 ffda 	bl	8022bf4 <__aeabi_dsub>
 8029c40:	4602      	mov	r2, r0
 8029c42:	460b      	mov	r3, r1
 8029c44:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 8029c48:	f7f9 fc18 	bl	802347c <__aeabi_dcmpgt>
 8029c4c:	2800      	cmp	r0, #0
 8029c4e:	f040 8267 	bne.w	802a120 <_dtoa_r+0xde8>
 8029c52:	f1b8 0f01 	cmp.w	r8, #1
 8029c56:	f340 817b 	ble.w	8029f50 <_dtoa_r+0xc18>
 8029c5a:	9d06      	ldr	r5, [sp, #24]
 8029c5c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8029c5e:	f8cd 906c 	str.w	r9, [sp, #108]	; 0x6c
 8029c62:	44a8      	add	r8, r5
 8029c64:	f8cd 8060 	str.w	r8, [sp, #96]	; 0x60
 8029c68:	e00c      	b.n	8029c84 <_dtoa_r+0x94c>
 8029c6a:	f7f8 ffc3 	bl	8022bf4 <__aeabi_dsub>
 8029c6e:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8029c72:	f7f9 fbe5 	bl	8023440 <__aeabi_dcmplt>
 8029c76:	2800      	cmp	r0, #0
 8029c78:	f040 8252 	bne.w	802a120 <_dtoa_r+0xde8>
 8029c7c:	9c18      	ldr	r4, [sp, #96]	; 0x60
 8029c7e:	42a6      	cmp	r6, r4
 8029c80:	f000 8164 	beq.w	8029f4c <_dtoa_r+0xc14>
 8029c84:	2300      	movs	r3, #0
 8029c86:	2200      	movs	r2, #0
 8029c88:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8029c8c:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 8029c90:	f7f9 f964 	bl	8022f5c <__aeabi_dmul>
 8029c94:	2300      	movs	r3, #0
 8029c96:	2200      	movs	r2, #0
 8029c98:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8029c9c:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 8029ca0:	4650      	mov	r0, sl
 8029ca2:	4659      	mov	r1, fp
 8029ca4:	f7f9 f95a 	bl	8022f5c <__aeabi_dmul>
 8029ca8:	4689      	mov	r9, r1
 8029caa:	4680      	mov	r8, r0
 8029cac:	f7f9 fbf0 	bl	8023490 <__aeabi_d2iz>
 8029cb0:	4604      	mov	r4, r0
 8029cb2:	f7f9 f8ed 	bl	8022e90 <__aeabi_i2d>
 8029cb6:	4602      	mov	r2, r0
 8029cb8:	460b      	mov	r3, r1
 8029cba:	4640      	mov	r0, r8
 8029cbc:	4649      	mov	r1, r9
 8029cbe:	f7f8 ff99 	bl	8022bf4 <__aeabi_dsub>
 8029cc2:	3430      	adds	r4, #48	; 0x30
 8029cc4:	b2e5      	uxtb	r5, r4
 8029cc6:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8029cca:	f806 5b01 	strb.w	r5, [r6], #1
 8029cce:	468b      	mov	fp, r1
 8029cd0:	4682      	mov	sl, r0
 8029cd2:	f7f9 fbb5 	bl	8023440 <__aeabi_dcmplt>
 8029cd6:	2100      	movs	r1, #0
 8029cd8:	4604      	mov	r4, r0
 8029cda:	4652      	mov	r2, sl
 8029cdc:	465b      	mov	r3, fp
 8029cde:	2000      	movs	r0, #0
 8029ce0:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8029ce4:	4637      	mov	r7, r6
 8029ce6:	2c00      	cmp	r4, #0
 8029ce8:	d0bf      	beq.n	8029c6a <_dtoa_r+0x932>
 8029cea:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 8029cec:	940b      	str	r4, [sp, #44]	; 0x2c
 8029cee:	e528      	b.n	8029742 <_dtoa_r+0x40a>
 8029cf0:	2400      	movs	r4, #0
 8029cf2:	9411      	str	r4, [sp, #68]	; 0x44
 8029cf4:	9d29      	ldr	r5, [sp, #164]	; 0xa4
 8029cf6:	2d00      	cmp	r5, #0
 8029cf8:	f340 80fb 	ble.w	8029ef2 <_dtoa_r+0xbba>
 8029cfc:	462c      	mov	r4, r5
 8029cfe:	9515      	str	r5, [sp, #84]	; 0x54
 8029d00:	950c      	str	r5, [sp, #48]	; 0x30
 8029d02:	e6d6      	b.n	8029ab2 <_dtoa_r+0x77a>
 8029d04:	2501      	movs	r5, #1
 8029d06:	9511      	str	r5, [sp, #68]	; 0x44
 8029d08:	e6c9      	b.n	8029a9e <_dtoa_r+0x766>
 8029d0a:	2401      	movs	r4, #1
 8029d0c:	9411      	str	r4, [sp, #68]	; 0x44
 8029d0e:	e7f1      	b.n	8029cf4 <_dtoa_r+0x9bc>
 8029d10:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8029d12:	2c00      	cmp	r4, #0
 8029d14:	f73f ac76 	bgt.w	8029604 <_dtoa_r+0x2cc>
 8029d18:	f040 8223 	bne.w	802a162 <_dtoa_r+0xe2a>
 8029d1c:	2300      	movs	r3, #0
 8029d1e:	2200      	movs	r2, #0
 8029d20:	f2c4 0314 	movt	r3, #16404	; 0x4014
 8029d24:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8029d28:	f7f9 f918 	bl	8022f5c <__aeabi_dmul>
 8029d2c:	4652      	mov	r2, sl
 8029d2e:	465b      	mov	r3, fp
 8029d30:	f7f9 fb9a 	bl	8023468 <__aeabi_dcmpge>
 8029d34:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8029d36:	46a8      	mov	r8, r5
 8029d38:	2800      	cmp	r0, #0
 8029d3a:	f000 80c0 	beq.w	8029ebe <_dtoa_r+0xb86>
 8029d3e:	9c29      	ldr	r4, [sp, #164]	; 0xa4
 8029d40:	9f06      	ldr	r7, [sp, #24]
 8029d42:	43e4      	mvns	r4, r4
 8029d44:	940b      	str	r4, [sp, #44]	; 0x2c
 8029d46:	2600      	movs	r6, #0
 8029d48:	e5e8      	b.n	802991c <_dtoa_r+0x5e4>
 8029d4a:	9803      	ldr	r0, [sp, #12]
 8029d4c:	990d      	ldr	r1, [sp, #52]	; 0x34
 8029d4e:	f001 f88d 	bl	802ae6c <__pow5mult>
 8029d52:	900d      	str	r0, [sp, #52]	; 0x34
 8029d54:	e554      	b.n	8029800 <_dtoa_r+0x4c8>
 8029d56:	d103      	bne.n	8029d60 <_dtoa_r+0xa28>
 8029d58:	f019 0f01 	tst.w	r9, #1
 8029d5c:	f47f adc9 	bne.w	80298f2 <_dtoa_r+0x5ba>
 8029d60:	4657      	mov	r7, sl
 8029d62:	f81a 3d01 	ldrb.w	r3, [sl, #-1]!
 8029d66:	2b30      	cmp	r3, #48	; 0x30
 8029d68:	d0fa      	beq.n	8029d60 <_dtoa_r+0xa28>
 8029d6a:	e5d7      	b.n	802991c <_dtoa_r+0x5e4>
 8029d6c:	9d17      	ldr	r5, [sp, #92]	; 0x5c
 8029d6e:	2d00      	cmp	r5, #0
 8029d70:	f000 81aa 	beq.w	802a0c8 <_dtoa_r+0xd90>
 8029d74:	f503 6386 	add.w	r3, r3, #1072	; 0x430
 8029d78:	3303      	adds	r3, #3
 8029d7a:	9d10      	ldr	r5, [sp, #64]	; 0x40
 8029d7c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8029d7e:	e50a      	b.n	8029796 <_dtoa_r+0x45e>
 8029d80:	08033170 	.word	0x08033170
 8029d84:	08033238 	.word	0x08033238
 8029d88:	4651      	mov	r1, sl
 8029d8a:	4638      	mov	r0, r7
 8029d8c:	9302      	str	r3, [sp, #8]
 8029d8e:	f001 f919 	bl	802afc4 <__mcmp>
 8029d92:	4651      	mov	r1, sl
 8029d94:	4683      	mov	fp, r0
 8029d96:	4628      	mov	r0, r5
 8029d98:	f000 ff24 	bl	802abe4 <_Bfree>
 8029d9c:	9b02      	ldr	r3, [sp, #8]
 8029d9e:	f1bb 0f00 	cmp.w	fp, #0
 8029da2:	f47f ae30 	bne.w	8029a06 <_dtoa_r+0x6ce>
 8029da6:	9828      	ldr	r0, [sp, #160]	; 0xa0
 8029da8:	2800      	cmp	r0, #0
 8029daa:	f47f ae2c 	bne.w	8029a06 <_dtoa_r+0x6ce>
 8029dae:	9910      	ldr	r1, [sp, #64]	; 0x40
 8029db0:	2900      	cmp	r1, #0
 8029db2:	f47f ae28 	bne.w	8029a06 <_dtoa_r+0x6ce>
 8029db6:	2b39      	cmp	r3, #57	; 0x39
 8029db8:	970d      	str	r7, [sp, #52]	; 0x34
 8029dba:	4699      	mov	r9, r3
 8029dbc:	9d07      	ldr	r5, [sp, #28]
 8029dbe:	4647      	mov	r7, r8
 8029dc0:	f000 80be 	beq.w	8029f40 <_dtoa_r+0xc08>
 8029dc4:	9b08      	ldr	r3, [sp, #32]
 8029dc6:	2b00      	cmp	r3, #0
 8029dc8:	dd02      	ble.n	8029dd0 <_dtoa_r+0xa98>
 8029dca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8029dcc:	f103 0931 	add.w	r9, r3, #49	; 0x31
 8029dd0:	46a0      	mov	r8, r4
 8029dd2:	f807 9b01 	strb.w	r9, [r7], #1
 8029dd6:	e5a1      	b.n	802991c <_dtoa_r+0x5e4>
 8029dd8:	4631      	mov	r1, r6
 8029dda:	4628      	mov	r0, r5
 8029ddc:	220a      	movs	r2, #10
 8029dde:	2300      	movs	r3, #0
 8029de0:	f000 ff0a 	bl	802abf8 <__multadd>
 8029de4:	f109 0901 	add.w	r9, r9, #1
 8029de8:	4606      	mov	r6, r0
 8029dea:	4604      	mov	r4, r0
 8029dec:	e5ec      	b.n	80299c8 <_dtoa_r+0x690>
 8029dee:	4630      	mov	r0, r6
 8029df0:	f7f9 f84e 	bl	8022e90 <__aeabi_i2d>
 8029df4:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 8029df8:	f7f9 f8b0 	bl	8022f5c <__aeabi_dmul>
 8029dfc:	2300      	movs	r3, #0
 8029dfe:	2200      	movs	r2, #0
 8029e00:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8029e04:	f7f8 fef8 	bl	8022bf8 <__adddf3>
 8029e08:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
 8029e0c:	990c      	ldr	r1, [sp, #48]	; 0x30
 8029e0e:	4604      	mov	r4, r0
 8029e10:	2900      	cmp	r1, #0
 8029e12:	d178      	bne.n	8029f06 <_dtoa_r+0xbce>
 8029e14:	2300      	movs	r3, #0
 8029e16:	2200      	movs	r2, #0
 8029e18:	f2c4 0314 	movt	r3, #16404	; 0x4014
 8029e1c:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8029e20:	f7f8 fee8 	bl	8022bf4 <__aeabi_dsub>
 8029e24:	4622      	mov	r2, r4
 8029e26:	462b      	mov	r3, r5
 8029e28:	4682      	mov	sl, r0
 8029e2a:	468b      	mov	fp, r1
 8029e2c:	f7f9 fb26 	bl	802347c <__aeabi_dcmpgt>
 8029e30:	4606      	mov	r6, r0
 8029e32:	2800      	cmp	r0, #0
 8029e34:	f040 80e2 	bne.w	8029ffc <_dtoa_r+0xcc4>
 8029e38:	4622      	mov	r2, r4
 8029e3a:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
 8029e3e:	4650      	mov	r0, sl
 8029e40:	4659      	mov	r1, fp
 8029e42:	f7f9 fafd 	bl	8023440 <__aeabi_dcmplt>
 8029e46:	2800      	cmp	r0, #0
 8029e48:	f000 8082 	beq.w	8029f50 <_dtoa_r+0xc18>
 8029e4c:	4635      	mov	r5, r6
 8029e4e:	46b0      	mov	r8, r6
 8029e50:	e775      	b.n	8029d3e <_dtoa_r+0xa06>
 8029e52:	980d      	ldr	r0, [sp, #52]	; 0x34
 8029e54:	4629      	mov	r1, r5
 8029e56:	f001 f8b5 	bl	802afc4 <__mcmp>
 8029e5a:	2800      	cmp	r0, #0
 8029e5c:	f6bf ad0e 	bge.w	802987c <_dtoa_r+0x544>
 8029e60:	990d      	ldr	r1, [sp, #52]	; 0x34
 8029e62:	9803      	ldr	r0, [sp, #12]
 8029e64:	220a      	movs	r2, #10
 8029e66:	2300      	movs	r3, #0
 8029e68:	f000 fec6 	bl	802abf8 <__multadd>
 8029e6c:	900d      	str	r0, [sp, #52]	; 0x34
 8029e6e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8029e70:	9911      	ldr	r1, [sp, #68]	; 0x44
 8029e72:	3801      	subs	r0, #1
 8029e74:	900b      	str	r0, [sp, #44]	; 0x2c
 8029e76:	2900      	cmp	r1, #0
 8029e78:	f040 8176 	bne.w	802a168 <_dtoa_r+0xe30>
 8029e7c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8029e7e:	930c      	str	r3, [sp, #48]	; 0x30
 8029e80:	e4fc      	b.n	802987c <_dtoa_r+0x544>
 8029e82:	692b      	ldr	r3, [r5, #16]
 8029e84:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8029e88:	6918      	ldr	r0, [r3, #16]
 8029e8a:	f000 fef7 	bl	802ac7c <__hi0bits>
 8029e8e:	f1c0 0320 	rsb	r3, r0, #32
 8029e92:	e4cd      	b.n	8029830 <_dtoa_r+0x4f8>
 8029e94:	9928      	ldr	r1, [sp, #160]	; 0xa0
 8029e96:	2902      	cmp	r1, #2
 8029e98:	f77f acf4 	ble.w	8029884 <_dtoa_r+0x54c>
 8029e9c:	2800      	cmp	r0, #0
 8029e9e:	f47f af4e 	bne.w	8029d3e <_dtoa_r+0xa06>
 8029ea2:	2205      	movs	r2, #5
 8029ea4:	4603      	mov	r3, r0
 8029ea6:	4629      	mov	r1, r5
 8029ea8:	9803      	ldr	r0, [sp, #12]
 8029eaa:	f000 fea5 	bl	802abf8 <__multadd>
 8029eae:	4605      	mov	r5, r0
 8029eb0:	4629      	mov	r1, r5
 8029eb2:	980d      	ldr	r0, [sp, #52]	; 0x34
 8029eb4:	f001 f886 	bl	802afc4 <__mcmp>
 8029eb8:	2800      	cmp	r0, #0
 8029eba:	f77f af40 	ble.w	8029d3e <_dtoa_r+0xa06>
 8029ebe:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8029ec0:	9f06      	ldr	r7, [sp, #24]
 8029ec2:	2331      	movs	r3, #49	; 0x31
 8029ec4:	3401      	adds	r4, #1
 8029ec6:	f807 3b01 	strb.w	r3, [r7], #1
 8029eca:	940b      	str	r4, [sp, #44]	; 0x2c
 8029ecc:	2600      	movs	r6, #0
 8029ece:	e525      	b.n	802991c <_dtoa_r+0x5e4>
 8029ed0:	9803      	ldr	r0, [sp, #12]
 8029ed2:	990d      	ldr	r1, [sp, #52]	; 0x34
 8029ed4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8029ed6:	f000 ffc9 	bl	802ae6c <__pow5mult>
 8029eda:	900d      	str	r0, [sp, #52]	; 0x34
 8029edc:	e490      	b.n	8029800 <_dtoa_r+0x4c8>
 8029ede:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8029ee0:	9510      	str	r5, [sp, #64]	; 0x40
 8029ee2:	1b2b      	subs	r3, r5, r4
 8029ee4:	9c14      	ldr	r4, [sp, #80]	; 0x50
 8029ee6:	18e4      	adds	r4, r4, r3
 8029ee8:	9414      	str	r4, [sp, #80]	; 0x50
 8029eea:	2500      	movs	r5, #0
 8029eec:	e44d      	b.n	802978a <_dtoa_r+0x452>
 8029eee:	2602      	movs	r6, #2
 8029ef0:	e61a      	b.n	8029b28 <_dtoa_r+0x7f0>
 8029ef2:	2401      	movs	r4, #1
 8029ef4:	9415      	str	r4, [sp, #84]	; 0x54
 8029ef6:	940c      	str	r4, [sp, #48]	; 0x30
 8029ef8:	9429      	str	r4, [sp, #164]	; 0xa4
 8029efa:	9d03      	ldr	r5, [sp, #12]
 8029efc:	2100      	movs	r1, #0
 8029efe:	6469      	str	r1, [r5, #68]	; 0x44
 8029f00:	e5e7      	b.n	8029ad2 <_dtoa_r+0x79a>
 8029f02:	950c      	str	r5, [sp, #48]	; 0x30
 8029f04:	e7f9      	b.n	8029efa <_dtoa_r+0xbc2>
 8029f06:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8029f08:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8029f0c:	921a      	str	r2, [sp, #104]	; 0x68
 8029f0e:	e65b      	b.n	8029bc8 <_dtoa_r+0x890>
 8029f10:	f1bb 0f00 	cmp.w	fp, #0
 8029f14:	970d      	str	r7, [sp, #52]	; 0x34
 8029f16:	4699      	mov	r9, r3
 8029f18:	9d07      	ldr	r5, [sp, #28]
 8029f1a:	4647      	mov	r7, r8
 8029f1c:	f77f af58 	ble.w	8029dd0 <_dtoa_r+0xa98>
 8029f20:	2201      	movs	r2, #1
 8029f22:	990d      	ldr	r1, [sp, #52]	; 0x34
 8029f24:	9803      	ldr	r0, [sp, #12]
 8029f26:	f000 ffed 	bl	802af04 <__lshift>
 8029f2a:	4629      	mov	r1, r5
 8029f2c:	900d      	str	r0, [sp, #52]	; 0x34
 8029f2e:	f001 f849 	bl	802afc4 <__mcmp>
 8029f32:	2800      	cmp	r0, #0
 8029f34:	f340 810e 	ble.w	802a154 <_dtoa_r+0xe1c>
 8029f38:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 8029f3c:	f47f af45 	bne.w	8029dca <_dtoa_r+0xa92>
 8029f40:	46ba      	mov	sl, r7
 8029f42:	2339      	movs	r3, #57	; 0x39
 8029f44:	f80a 3b01 	strb.w	r3, [sl], #1
 8029f48:	46a0      	mov	r8, r4
 8029f4a:	e4d4      	b.n	80298f6 <_dtoa_r+0x5be>
 8029f4c:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 8029f50:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8029f54:	4682      	mov	sl, r0
 8029f56:	468b      	mov	fp, r1
 8029f58:	f7ff bb41 	b.w	80295de <_dtoa_r+0x2a6>
 8029f5c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8029f5e:	426c      	negs	r4, r5
 8029f60:	2c00      	cmp	r4, #0
 8029f62:	f000 80af 	beq.w	802a0c4 <_dtoa_r+0xd8c>
 8029f66:	4b8a      	ldr	r3, [pc, #552]	; (802a190 <_dtoa_r+0xe58>)
 8029f68:	f004 020f 	and.w	r2, r4, #15
 8029f6c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8029f70:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8029f74:	e9d3 2300 	ldrd	r2, r3, [r3]
 8029f78:	f7f8 fff0 	bl	8022f5c <__aeabi_dmul>
 8029f7c:	1124      	asrs	r4, r4, #4
 8029f7e:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8029f82:	f000 809f 	beq.w	802a0c4 <_dtoa_r+0xd8c>
 8029f86:	4d83      	ldr	r5, [pc, #524]	; (802a194 <_dtoa_r+0xe5c>)
 8029f88:	2602      	movs	r6, #2
 8029f8a:	07e3      	lsls	r3, r4, #31
 8029f8c:	d504      	bpl.n	8029f98 <_dtoa_r+0xc60>
 8029f8e:	e9d5 2300 	ldrd	r2, r3, [r5]
 8029f92:	f7f8 ffe3 	bl	8022f5c <__aeabi_dmul>
 8029f96:	3601      	adds	r6, #1
 8029f98:	3508      	adds	r5, #8
 8029f9a:	1064      	asrs	r4, r4, #1
 8029f9c:	d1f5      	bne.n	8029f8a <_dtoa_r+0xc52>
 8029f9e:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8029fa2:	e5d9      	b.n	8029b58 <_dtoa_r+0x820>
 8029fa4:	3301      	adds	r3, #1
 8029fa6:	f80a 3c01 	strb.w	r3, [sl, #-1]
 8029faa:	e4b7      	b.n	802991c <_dtoa_r+0x5e4>
 8029fac:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8029fb0:	9803      	ldr	r0, [sp, #12]
 8029fb2:	f000 fdf1 	bl	802ab98 <_Balloc>
 8029fb6:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8029fba:	3202      	adds	r2, #2
 8029fbc:	4604      	mov	r4, r0
 8029fbe:	0092      	lsls	r2, r2, #2
 8029fc0:	f108 010c 	add.w	r1, r8, #12
 8029fc4:	f100 000c 	add.w	r0, r0, #12
 8029fc8:	f7fb f9a6 	bl	8025318 <memcpy>
 8029fcc:	4621      	mov	r1, r4
 8029fce:	9803      	ldr	r0, [sp, #12]
 8029fd0:	2201      	movs	r2, #1
 8029fd2:	f000 ff97 	bl	802af04 <__lshift>
 8029fd6:	4604      	mov	r4, r0
 8029fd8:	e4ea      	b.n	80299b0 <_dtoa_r+0x678>
 8029fda:	2b39      	cmp	r3, #57	; 0x39
 8029fdc:	970d      	str	r7, [sp, #52]	; 0x34
 8029fde:	4699      	mov	r9, r3
 8029fe0:	9d07      	ldr	r5, [sp, #28]
 8029fe2:	4647      	mov	r7, r8
 8029fe4:	d0ac      	beq.n	8029f40 <_dtoa_r+0xc08>
 8029fe6:	f103 0901 	add.w	r9, r3, #1
 8029fea:	f807 9b01 	strb.w	r9, [r7], #1
 8029fee:	46a0      	mov	r8, r4
 8029ff0:	e494      	b.n	802991c <_dtoa_r+0x5e4>
 8029ff2:	4699      	mov	r9, r3
 8029ff4:	970d      	str	r7, [sp, #52]	; 0x34
 8029ff6:	9d07      	ldr	r5, [sp, #28]
 8029ff8:	46a0      	mov	r8, r4
 8029ffa:	e46e      	b.n	80298da <_dtoa_r+0x5a2>
 8029ffc:	2500      	movs	r5, #0
 8029ffe:	46a8      	mov	r8, r5
 802a000:	e75d      	b.n	8029ebe <_dtoa_r+0xb86>
 802a002:	4963      	ldr	r1, [pc, #396]	; (802a190 <_dtoa_r+0xe58>)
 802a004:	f108 30ff 	add.w	r0, r8, #4294967295
 802a008:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 802a00c:	4622      	mov	r2, r4
 802a00e:	462b      	mov	r3, r5
 802a010:	9012      	str	r0, [sp, #72]	; 0x48
 802a012:	e9d1 0100 	ldrd	r0, r1, [r1]
 802a016:	f7f8 ffa1 	bl	8022f5c <__aeabi_dmul>
 802a01a:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
 802a01e:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 802a022:	f7f9 fa35 	bl	8023490 <__aeabi_d2iz>
 802a026:	4604      	mov	r4, r0
 802a028:	f7f8 ff32 	bl	8022e90 <__aeabi_i2d>
 802a02c:	9d06      	ldr	r5, [sp, #24]
 802a02e:	460b      	mov	r3, r1
 802a030:	4602      	mov	r2, r0
 802a032:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 802a036:	f7f8 fddd 	bl	8022bf4 <__aeabi_dsub>
 802a03a:	f104 0330 	add.w	r3, r4, #48	; 0x30
 802a03e:	f805 3b01 	strb.w	r3, [r5], #1
 802a042:	f1b8 0f01 	cmp.w	r8, #1
 802a046:	4682      	mov	sl, r0
 802a048:	468b      	mov	fp, r1
 802a04a:	950e      	str	r5, [sp, #56]	; 0x38
 802a04c:	462f      	mov	r7, r5
 802a04e:	d01f      	beq.n	802a090 <_dtoa_r+0xd58>
 802a050:	9c06      	ldr	r4, [sp, #24]
 802a052:	1e63      	subs	r3, r4, #1
 802a054:	4498      	add	r8, r3
 802a056:	2300      	movs	r3, #0
 802a058:	2200      	movs	r2, #0
 802a05a:	f2c4 0324 	movt	r3, #16420	; 0x4024
 802a05e:	f7f8 ff7d 	bl	8022f5c <__aeabi_dmul>
 802a062:	460f      	mov	r7, r1
 802a064:	4606      	mov	r6, r0
 802a066:	f7f9 fa13 	bl	8023490 <__aeabi_d2iz>
 802a06a:	4605      	mov	r5, r0
 802a06c:	f7f8 ff10 	bl	8022e90 <__aeabi_i2d>
 802a070:	3530      	adds	r5, #48	; 0x30
 802a072:	4602      	mov	r2, r0
 802a074:	460b      	mov	r3, r1
 802a076:	4630      	mov	r0, r6
 802a078:	4639      	mov	r1, r7
 802a07a:	f7f8 fdbb 	bl	8022bf4 <__aeabi_dsub>
 802a07e:	f804 5f01 	strb.w	r5, [r4, #1]!
 802a082:	4544      	cmp	r4, r8
 802a084:	d1e7      	bne.n	802a056 <_dtoa_r+0xd1e>
 802a086:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 802a088:	9c12      	ldr	r4, [sp, #72]	; 0x48
 802a08a:	4682      	mov	sl, r0
 802a08c:	468b      	mov	fp, r1
 802a08e:	192f      	adds	r7, r5, r4
 802a090:	2300      	movs	r3, #0
 802a092:	2200      	movs	r2, #0
 802a094:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
 802a098:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 802a09c:	f7f8 fdac 	bl	8022bf8 <__adddf3>
 802a0a0:	4602      	mov	r2, r0
 802a0a2:	460b      	mov	r3, r1
 802a0a4:	4650      	mov	r0, sl
 802a0a6:	4659      	mov	r1, fp
 802a0a8:	f7f9 f9e8 	bl	802347c <__aeabi_dcmpgt>
 802a0ac:	b1e0      	cbz	r0, 802a0e8 <_dtoa_r+0xdb0>
 802a0ae:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 802a0b0:	f817 5c01 	ldrb.w	r5, [r7, #-1]
 802a0b4:	940b      	str	r4, [sp, #44]	; 0x2c
 802a0b6:	f7ff bb2d 	b.w	8029714 <_dtoa_r+0x3dc>
 802a0ba:	980a      	ldr	r0, [sp, #40]	; 0x28
 802a0bc:	2300      	movs	r3, #0
 802a0be:	1b04      	subs	r4, r0, r4
 802a0c0:	f7ff bb69 	b.w	8029796 <_dtoa_r+0x45e>
 802a0c4:	2602      	movs	r6, #2
 802a0c6:	e547      	b.n	8029b58 <_dtoa_r+0x820>
 802a0c8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 802a0ca:	9d10      	ldr	r5, [sp, #64]	; 0x40
 802a0cc:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 802a0ce:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 802a0d2:	f7ff bb60 	b.w	8029796 <_dtoa_r+0x45e>
 802a0d6:	4656      	mov	r6, sl
 802a0d8:	f7ff bba5 	b.w	8029826 <_dtoa_r+0x4ee>
 802a0dc:	1c6a      	adds	r2, r5, #1
 802a0de:	b2d2      	uxtb	r2, r2
 802a0e0:	f803 2c01 	strb.w	r2, [r3, #-1]
 802a0e4:	f7ff bb2d 	b.w	8029742 <_dtoa_r+0x40a>
 802a0e8:	2100      	movs	r1, #0
 802a0ea:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
 802a0ee:	2000      	movs	r0, #0
 802a0f0:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 802a0f4:	f7f8 fd7e 	bl	8022bf4 <__aeabi_dsub>
 802a0f8:	4602      	mov	r2, r0
 802a0fa:	460b      	mov	r3, r1
 802a0fc:	4650      	mov	r0, sl
 802a0fe:	4659      	mov	r1, fp
 802a100:	f7f9 f99e 	bl	8023440 <__aeabi_dcmplt>
 802a104:	2800      	cmp	r0, #0
 802a106:	f43f af23 	beq.w	8029f50 <_dtoa_r+0xc18>
 802a10a:	463b      	mov	r3, r7
 802a10c:	461f      	mov	r7, r3
 802a10e:	3b01      	subs	r3, #1
 802a110:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 802a114:	2a30      	cmp	r2, #48	; 0x30
 802a116:	d0f9      	beq.n	802a10c <_dtoa_r+0xdd4>
 802a118:	9d1a      	ldr	r5, [sp, #104]	; 0x68
 802a11a:	950b      	str	r5, [sp, #44]	; 0x2c
 802a11c:	f7ff bb11 	b.w	8029742 <_dtoa_r+0x40a>
 802a120:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 802a122:	940b      	str	r4, [sp, #44]	; 0x2c
 802a124:	f7ff baf6 	b.w	8029714 <_dtoa_r+0x3dc>
 802a128:	461e      	mov	r6, r3
 802a12a:	f7ff bb7c 	b.w	8029826 <_dtoa_r+0x4ee>
 802a12e:	4630      	mov	r0, r6
 802a130:	f7f8 feae 	bl	8022e90 <__aeabi_i2d>
 802a134:	4602      	mov	r2, r0
 802a136:	460b      	mov	r3, r1
 802a138:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 802a13c:	f7f8 ff0e 	bl	8022f5c <__aeabi_dmul>
 802a140:	2300      	movs	r3, #0
 802a142:	2200      	movs	r2, #0
 802a144:	f2c4 031c 	movt	r3, #16412	; 0x401c
 802a148:	f7f8 fd56 	bl	8022bf8 <__adddf3>
 802a14c:	4604      	mov	r4, r0
 802a14e:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
 802a152:	e65f      	b.n	8029e14 <_dtoa_r+0xadc>
 802a154:	f47f ae3c 	bne.w	8029dd0 <_dtoa_r+0xa98>
 802a158:	f019 0f01 	tst.w	r9, #1
 802a15c:	f43f ae38 	beq.w	8029dd0 <_dtoa_r+0xa98>
 802a160:	e6ea      	b.n	8029f38 <_dtoa_r+0xc00>
 802a162:	2500      	movs	r5, #0
 802a164:	46a8      	mov	r8, r5
 802a166:	e5ea      	b.n	8029d3e <_dtoa_r+0xa06>
 802a168:	4641      	mov	r1, r8
 802a16a:	220a      	movs	r2, #10
 802a16c:	9803      	ldr	r0, [sp, #12]
 802a16e:	2300      	movs	r3, #0
 802a170:	f000 fd42 	bl	802abf8 <__multadd>
 802a174:	9a15      	ldr	r2, [sp, #84]	; 0x54
 802a176:	4680      	mov	r8, r0
 802a178:	920c      	str	r2, [sp, #48]	; 0x30
 802a17a:	f7ff bb7f 	b.w	802987c <_dtoa_r+0x544>
 802a17e:	2601      	movs	r6, #1
 802a180:	f7ff b9b8 	b.w	80294f4 <_dtoa_r+0x1bc>
 802a184:	f43f ab65 	beq.w	8029852 <_dtoa_r+0x51a>
 802a188:	f1c3 033c 	rsb	r3, r3, #60	; 0x3c
 802a18c:	f7ff bbf3 	b.w	8029976 <_dtoa_r+0x63e>
 802a190:	08033170 	.word	0x08033170
 802a194:	08033238 	.word	0x08033238

0802a198 <_fflush_r>:
 802a198:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a19c:	4680      	mov	r8, r0
 802a19e:	460c      	mov	r4, r1
 802a1a0:	b110      	cbz	r0, 802a1a8 <_fflush_r+0x10>
 802a1a2:	6b83      	ldr	r3, [r0, #56]	; 0x38
 802a1a4:	2b00      	cmp	r3, #0
 802a1a6:	d067      	beq.n	802a278 <_fflush_r+0xe0>
 802a1a8:	89a6      	ldrh	r6, [r4, #12]
 802a1aa:	2e00      	cmp	r6, #0
 802a1ac:	d061      	beq.n	802a272 <_fflush_r+0xda>
 802a1ae:	b233      	sxth	r3, r6
 802a1b0:	f013 0008 	ands.w	r0, r3, #8
 802a1b4:	d01d      	beq.n	802a1f2 <_fflush_r+0x5a>
 802a1b6:	6926      	ldr	r6, [r4, #16]
 802a1b8:	2e00      	cmp	r6, #0
 802a1ba:	f000 8084 	beq.w	802a2c6 <_fflush_r+0x12e>
 802a1be:	079b      	lsls	r3, r3, #30
 802a1c0:	6825      	ldr	r5, [r4, #0]
 802a1c2:	bf08      	it	eq
 802a1c4:	6963      	ldreq	r3, [r4, #20]
 802a1c6:	6026      	str	r6, [r4, #0]
 802a1c8:	bf18      	it	ne
 802a1ca:	2300      	movne	r3, #0
 802a1cc:	1bad      	subs	r5, r5, r6
 802a1ce:	60a3      	str	r3, [r4, #8]
 802a1d0:	e00a      	b.n	802a1e8 <_fflush_r+0x50>
 802a1d2:	4632      	mov	r2, r6
 802a1d4:	462b      	mov	r3, r5
 802a1d6:	69e1      	ldr	r1, [r4, #28]
 802a1d8:	6a67      	ldr	r7, [r4, #36]	; 0x24
 802a1da:	4640      	mov	r0, r8
 802a1dc:	47b8      	blx	r7
 802a1de:	2800      	cmp	r0, #0
 802a1e0:	ebc0 0505 	rsb	r5, r0, r5
 802a1e4:	4406      	add	r6, r0
 802a1e6:	dd54      	ble.n	802a292 <_fflush_r+0xfa>
 802a1e8:	2d00      	cmp	r5, #0
 802a1ea:	dcf2      	bgt.n	802a1d2 <_fflush_r+0x3a>
 802a1ec:	2000      	movs	r0, #0
 802a1ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a1f2:	6862      	ldr	r2, [r4, #4]
 802a1f4:	f446 6300 	orr.w	r3, r6, #2048	; 0x800
 802a1f8:	2a00      	cmp	r2, #0
 802a1fa:	81a3      	strh	r3, [r4, #12]
 802a1fc:	dd51      	ble.n	802a2a2 <_fflush_r+0x10a>
 802a1fe:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 802a200:	2e00      	cmp	r6, #0
 802a202:	d060      	beq.n	802a2c6 <_fflush_r+0x12e>
 802a204:	2200      	movs	r2, #0
 802a206:	b29b      	uxth	r3, r3
 802a208:	f8d8 5000 	ldr.w	r5, [r8]
 802a20c:	f8c8 2000 	str.w	r2, [r8]
 802a210:	f413 5280 	ands.w	r2, r3, #4096	; 0x1000
 802a214:	d033      	beq.n	802a27e <_fflush_r+0xe6>
 802a216:	6d22      	ldr	r2, [r4, #80]	; 0x50
 802a218:	0759      	lsls	r1, r3, #29
 802a21a:	d505      	bpl.n	802a228 <_fflush_r+0x90>
 802a21c:	6861      	ldr	r1, [r4, #4]
 802a21e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 802a220:	1a52      	subs	r2, r2, r1
 802a222:	b10b      	cbz	r3, 802a228 <_fflush_r+0x90>
 802a224:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 802a226:	1ad2      	subs	r2, r2, r3
 802a228:	2300      	movs	r3, #0
 802a22a:	69e1      	ldr	r1, [r4, #28]
 802a22c:	4640      	mov	r0, r8
 802a22e:	47b0      	blx	r6
 802a230:	1c43      	adds	r3, r0, #1
 802a232:	d03a      	beq.n	802a2aa <_fflush_r+0x112>
 802a234:	89a3      	ldrh	r3, [r4, #12]
 802a236:	6922      	ldr	r2, [r4, #16]
 802a238:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 802a23c:	041b      	lsls	r3, r3, #16
 802a23e:	0c1b      	lsrs	r3, r3, #16
 802a240:	2100      	movs	r1, #0
 802a242:	6061      	str	r1, [r4, #4]
 802a244:	04d9      	lsls	r1, r3, #19
 802a246:	81a3      	strh	r3, [r4, #12]
 802a248:	6022      	str	r2, [r4, #0]
 802a24a:	d502      	bpl.n	802a252 <_fflush_r+0xba>
 802a24c:	1c42      	adds	r2, r0, #1
 802a24e:	d03d      	beq.n	802a2cc <_fflush_r+0x134>
 802a250:	6520      	str	r0, [r4, #80]	; 0x50
 802a252:	6b21      	ldr	r1, [r4, #48]	; 0x30
 802a254:	f8c8 5000 	str.w	r5, [r8]
 802a258:	2900      	cmp	r1, #0
 802a25a:	d03c      	beq.n	802a2d6 <_fflush_r+0x13e>
 802a25c:	f104 0340 	add.w	r3, r4, #64	; 0x40
 802a260:	4299      	cmp	r1, r3
 802a262:	d002      	beq.n	802a26a <_fflush_r+0xd2>
 802a264:	4640      	mov	r0, r8
 802a266:	f000 f95b 	bl	802a520 <_free_r>
 802a26a:	2000      	movs	r0, #0
 802a26c:	6320      	str	r0, [r4, #48]	; 0x30
 802a26e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a272:	4630      	mov	r0, r6
 802a274:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a278:	f000 f872 	bl	802a360 <__sinit>
 802a27c:	e794      	b.n	802a1a8 <_fflush_r+0x10>
 802a27e:	2301      	movs	r3, #1
 802a280:	69e1      	ldr	r1, [r4, #28]
 802a282:	4640      	mov	r0, r8
 802a284:	47b0      	blx	r6
 802a286:	4602      	mov	r2, r0
 802a288:	3001      	adds	r0, #1
 802a28a:	d027      	beq.n	802a2dc <_fflush_r+0x144>
 802a28c:	89a3      	ldrh	r3, [r4, #12]
 802a28e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 802a290:	e7c2      	b.n	802a218 <_fflush_r+0x80>
 802a292:	89a3      	ldrh	r3, [r4, #12]
 802a294:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a298:	81a3      	strh	r3, [r4, #12]
 802a29a:	f04f 30ff 	mov.w	r0, #4294967295
 802a29e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a2a2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 802a2a4:	2a00      	cmp	r2, #0
 802a2a6:	dcaa      	bgt.n	802a1fe <_fflush_r+0x66>
 802a2a8:	e7e4      	b.n	802a274 <_fflush_r+0xdc>
 802a2aa:	f8d8 3000 	ldr.w	r3, [r8]
 802a2ae:	2b00      	cmp	r3, #0
 802a2b0:	d0c0      	beq.n	802a234 <_fflush_r+0x9c>
 802a2b2:	2b1d      	cmp	r3, #29
 802a2b4:	d0be      	beq.n	802a234 <_fflush_r+0x9c>
 802a2b6:	2b16      	cmp	r3, #22
 802a2b8:	d0bc      	beq.n	802a234 <_fflush_r+0x9c>
 802a2ba:	89a3      	ldrh	r3, [r4, #12]
 802a2bc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a2c0:	81a3      	strh	r3, [r4, #12]
 802a2c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a2c6:	4630      	mov	r0, r6
 802a2c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a2cc:	f8d8 3000 	ldr.w	r3, [r8]
 802a2d0:	2b00      	cmp	r3, #0
 802a2d2:	d1be      	bne.n	802a252 <_fflush_r+0xba>
 802a2d4:	e7bc      	b.n	802a250 <_fflush_r+0xb8>
 802a2d6:	4608      	mov	r0, r1
 802a2d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a2dc:	f8d8 3000 	ldr.w	r3, [r8]
 802a2e0:	2b00      	cmp	r3, #0
 802a2e2:	d0d3      	beq.n	802a28c <_fflush_r+0xf4>
 802a2e4:	2b1d      	cmp	r3, #29
 802a2e6:	d008      	beq.n	802a2fa <_fflush_r+0x162>
 802a2e8:	2b16      	cmp	r3, #22
 802a2ea:	d006      	beq.n	802a2fa <_fflush_r+0x162>
 802a2ec:	89a3      	ldrh	r3, [r4, #12]
 802a2ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a2f2:	81a3      	strh	r3, [r4, #12]
 802a2f4:	4610      	mov	r0, r2
 802a2f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a2fa:	f8c8 5000 	str.w	r5, [r8]
 802a2fe:	2000      	movs	r0, #0
 802a300:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0802a304 <_cleanup_r>:
 802a304:	f64b 215d 	movw	r1, #47709	; 0xba5d
 802a308:	f6c0 0102 	movt	r1, #2050	; 0x802
 802a30c:	f000 bb4c 	b.w	802a9a8 <_fwalk>

0802a310 <std.isra.0>:
 802a310:	b510      	push	{r4, lr}
 802a312:	4604      	mov	r4, r0
 802a314:	2300      	movs	r3, #0
 802a316:	6023      	str	r3, [r4, #0]
 802a318:	6063      	str	r3, [r4, #4]
 802a31a:	60a3      	str	r3, [r4, #8]
 802a31c:	81a1      	strh	r1, [r4, #12]
 802a31e:	6663      	str	r3, [r4, #100]	; 0x64
 802a320:	81e2      	strh	r2, [r4, #14]
 802a322:	6123      	str	r3, [r4, #16]
 802a324:	6163      	str	r3, [r4, #20]
 802a326:	61a3      	str	r3, [r4, #24]
 802a328:	4619      	mov	r1, r3
 802a32a:	f100 005c 	add.w	r0, r0, #92	; 0x5c
 802a32e:	2208      	movs	r2, #8
 802a330:	f7fb f88c 	bl	802544c <memset>
 802a334:	f24b 63bd 	movw	r3, #46781	; 0xb6bd
 802a338:	f6c0 0302 	movt	r3, #2050	; 0x802
 802a33c:	6223      	str	r3, [r4, #32]
 802a33e:	f24b 63e1 	movw	r3, #46817	; 0xb6e1
 802a342:	f6c0 0302 	movt	r3, #2050	; 0x802
 802a346:	6263      	str	r3, [r4, #36]	; 0x24
 802a348:	f24b 731d 	movw	r3, #46877	; 0xb71d
 802a34c:	f6c0 0302 	movt	r3, #2050	; 0x802
 802a350:	62a3      	str	r3, [r4, #40]	; 0x28
 802a352:	f24b 7341 	movw	r3, #46913	; 0xb741
 802a356:	f6c0 0302 	movt	r3, #2050	; 0x802
 802a35a:	61e4      	str	r4, [r4, #28]
 802a35c:	62e3      	str	r3, [r4, #44]	; 0x2c
 802a35e:	bd10      	pop	{r4, pc}

0802a360 <__sinit>:
 802a360:	6b82      	ldr	r2, [r0, #56]	; 0x38
 802a362:	b570      	push	{r4, r5, r6, lr}
 802a364:	4604      	mov	r4, r0
 802a366:	b102      	cbz	r2, 802a36a <__sinit+0xa>
 802a368:	bd70      	pop	{r4, r5, r6, pc}
 802a36a:	4e0e      	ldr	r6, [pc, #56]	; (802a3a4 <__sinit+0x44>)
 802a36c:	f8c4 22e0 	str.w	r2, [r4, #736]	; 0x2e0
 802a370:	f504 733b 	add.w	r3, r4, #748	; 0x2ec
 802a374:	2501      	movs	r5, #1
 802a376:	63e6      	str	r6, [r4, #60]	; 0x3c
 802a378:	2603      	movs	r6, #3
 802a37a:	2104      	movs	r1, #4
 802a37c:	f8c4 32e8 	str.w	r3, [r4, #744]	; 0x2e8
 802a380:	6840      	ldr	r0, [r0, #4]
 802a382:	63a5      	str	r5, [r4, #56]	; 0x38
 802a384:	f8c4 62e4 	str.w	r6, [r4, #740]	; 0x2e4
 802a388:	f7ff ffc2 	bl	802a310 <std.isra.0>
 802a38c:	68a0      	ldr	r0, [r4, #8]
 802a38e:	2109      	movs	r1, #9
 802a390:	462a      	mov	r2, r5
 802a392:	f7ff ffbd 	bl	802a310 <std.isra.0>
 802a396:	68e0      	ldr	r0, [r4, #12]
 802a398:	2112      	movs	r1, #18
 802a39a:	2202      	movs	r2, #2
 802a39c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 802a3a0:	f7ff bfb6 	b.w	802a310 <std.isra.0>
 802a3a4:	0802a305 	.word	0x0802a305

0802a3a8 <__sfp_lock_acquire>:
 802a3a8:	4770      	bx	lr
 802a3aa:	bf00      	nop

0802a3ac <__sfp_lock_release>:
 802a3ac:	4770      	bx	lr
 802a3ae:	bf00      	nop

0802a3b0 <_fputwc_r>:
 802a3b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802a3b4:	8993      	ldrh	r3, [r2, #12]
 802a3b6:	4614      	mov	r4, r2
 802a3b8:	049a      	lsls	r2, r3, #18
 802a3ba:	b083      	sub	sp, #12
 802a3bc:	4607      	mov	r7, r0
 802a3be:	460e      	mov	r6, r1
 802a3c0:	d406      	bmi.n	802a3d0 <_fputwc_r+0x20>
 802a3c2:	6e62      	ldr	r2, [r4, #100]	; 0x64
 802a3c4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 802a3c8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 802a3cc:	81a3      	strh	r3, [r4, #12]
 802a3ce:	6662      	str	r2, [r4, #100]	; 0x64
 802a3d0:	f000 fb24 	bl	802aa1c <__locale_mb_cur_max>
 802a3d4:	2801      	cmp	r0, #1
 802a3d6:	d04a      	beq.n	802a46e <_fputwc_r+0xbe>
 802a3d8:	ad01      	add	r5, sp, #4
 802a3da:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 802a3de:	4638      	mov	r0, r7
 802a3e0:	4629      	mov	r1, r5
 802a3e2:	4632      	mov	r2, r6
 802a3e4:	f001 fa8e 	bl	802b904 <_wcrtomb_r>
 802a3e8:	f1b0 3fff 	cmp.w	r0, #4294967295
 802a3ec:	4681      	mov	r9, r0
 802a3ee:	d027      	beq.n	802a440 <_fputwc_r+0x90>
 802a3f0:	2800      	cmp	r0, #0
 802a3f2:	d02c      	beq.n	802a44e <_fputwc_r+0x9e>
 802a3f4:	f04f 0800 	mov.w	r8, #0
 802a3f8:	e00a      	b.n	802a410 <_fputwc_r+0x60>
 802a3fa:	6823      	ldr	r3, [r4, #0]
 802a3fc:	f815 2008 	ldrb.w	r2, [r5, r8]
 802a400:	701a      	strb	r2, [r3, #0]
 802a402:	6823      	ldr	r3, [r4, #0]
 802a404:	3301      	adds	r3, #1
 802a406:	6023      	str	r3, [r4, #0]
 802a408:	f108 0801 	add.w	r8, r8, #1
 802a40c:	45c8      	cmp	r8, r9
 802a40e:	d21e      	bcs.n	802a44e <_fputwc_r+0x9e>
 802a410:	68a3      	ldr	r3, [r4, #8]
 802a412:	3b01      	subs	r3, #1
 802a414:	2b00      	cmp	r3, #0
 802a416:	60a3      	str	r3, [r4, #8]
 802a418:	daef      	bge.n	802a3fa <_fputwc_r+0x4a>
 802a41a:	69a2      	ldr	r2, [r4, #24]
 802a41c:	4293      	cmp	r3, r2
 802a41e:	db18      	blt.n	802a452 <_fputwc_r+0xa2>
 802a420:	6823      	ldr	r3, [r4, #0]
 802a422:	f815 2008 	ldrb.w	r2, [r5, r8]
 802a426:	701a      	strb	r2, [r3, #0]
 802a428:	6823      	ldr	r3, [r4, #0]
 802a42a:	7819      	ldrb	r1, [r3, #0]
 802a42c:	290a      	cmp	r1, #10
 802a42e:	d012      	beq.n	802a456 <_fputwc_r+0xa6>
 802a430:	3301      	adds	r3, #1
 802a432:	2000      	movs	r0, #0
 802a434:	6023      	str	r3, [r4, #0]
 802a436:	2800      	cmp	r0, #0
 802a438:	d0e6      	beq.n	802a408 <_fputwc_r+0x58>
 802a43a:	f04f 30ff 	mov.w	r0, #4294967295
 802a43e:	e003      	b.n	802a448 <_fputwc_r+0x98>
 802a440:	89a3      	ldrh	r3, [r4, #12]
 802a442:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a446:	81a3      	strh	r3, [r4, #12]
 802a448:	b003      	add	sp, #12
 802a44a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802a44e:	4630      	mov	r0, r6
 802a450:	e7fa      	b.n	802a448 <_fputwc_r+0x98>
 802a452:	f815 1008 	ldrb.w	r1, [r5, r8]
 802a456:	4638      	mov	r0, r7
 802a458:	4622      	mov	r2, r4
 802a45a:	f001 f9f3 	bl	802b844 <__swbuf_r>
 802a45e:	f1a0 33ff 	sub.w	r3, r0, #4294967295
 802a462:	4258      	negs	r0, r3
 802a464:	eb40 0003 	adc.w	r0, r0, r3
 802a468:	2800      	cmp	r0, #0
 802a46a:	d0cd      	beq.n	802a408 <_fputwc_r+0x58>
 802a46c:	e7e5      	b.n	802a43a <_fputwc_r+0x8a>
 802a46e:	2e00      	cmp	r6, #0
 802a470:	d0b2      	beq.n	802a3d8 <_fputwc_r+0x28>
 802a472:	2eff      	cmp	r6, #255	; 0xff
 802a474:	d8b0      	bhi.n	802a3d8 <_fputwc_r+0x28>
 802a476:	ad02      	add	r5, sp, #8
 802a478:	4681      	mov	r9, r0
 802a47a:	f805 6d04 	strb.w	r6, [r5, #-4]!
 802a47e:	e7b9      	b.n	802a3f4 <_fputwc_r+0x44>

0802a480 <_malloc_trim_r>:
 802a480:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802a482:	4d24      	ldr	r5, [pc, #144]	; (802a514 <_malloc_trim_r+0x94>)
 802a484:	4604      	mov	r4, r0
 802a486:	460f      	mov	r7, r1
 802a488:	f7f8 f8ec 	bl	8022664 <__malloc_lock>
 802a48c:	68ab      	ldr	r3, [r5, #8]
 802a48e:	685e      	ldr	r6, [r3, #4]
 802a490:	f026 0603 	bic.w	r6, r6, #3
 802a494:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
 802a498:	330f      	adds	r3, #15
 802a49a:	1bdf      	subs	r7, r3, r7
 802a49c:	0b3f      	lsrs	r7, r7, #12
 802a49e:	3f01      	subs	r7, #1
 802a4a0:	033f      	lsls	r7, r7, #12
 802a4a2:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 802a4a6:	4620      	mov	r0, r4
 802a4a8:	db1c      	blt.n	802a4e4 <_malloc_trim_r+0x64>
 802a4aa:	2100      	movs	r1, #0
 802a4ac:	f7fb fd1e 	bl	8025eec <_sbrk_r>
 802a4b0:	68ab      	ldr	r3, [r5, #8]
 802a4b2:	199b      	adds	r3, r3, r6
 802a4b4:	4298      	cmp	r0, r3
 802a4b6:	d019      	beq.n	802a4ec <_malloc_trim_r+0x6c>
 802a4b8:	4620      	mov	r0, r4
 802a4ba:	f7f8 f8dd 	bl	8022678 <__malloc_unlock>
 802a4be:	2000      	movs	r0, #0
 802a4c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802a4c2:	2100      	movs	r1, #0
 802a4c4:	4620      	mov	r0, r4
 802a4c6:	f7fb fd11 	bl	8025eec <_sbrk_r>
 802a4ca:	68ab      	ldr	r3, [r5, #8]
 802a4cc:	1ac2      	subs	r2, r0, r3
 802a4ce:	2a0f      	cmp	r2, #15
 802a4d0:	dd07      	ble.n	802a4e2 <_malloc_trim_r+0x62>
 802a4d2:	4911      	ldr	r1, [pc, #68]	; (802a518 <_malloc_trim_r+0x98>)
 802a4d4:	6809      	ldr	r1, [r1, #0]
 802a4d6:	1a40      	subs	r0, r0, r1
 802a4d8:	4910      	ldr	r1, [pc, #64]	; (802a51c <_malloc_trim_r+0x9c>)
 802a4da:	f042 0201 	orr.w	r2, r2, #1
 802a4de:	6008      	str	r0, [r1, #0]
 802a4e0:	605a      	str	r2, [r3, #4]
 802a4e2:	4620      	mov	r0, r4
 802a4e4:	f7f8 f8c8 	bl	8022678 <__malloc_unlock>
 802a4e8:	2000      	movs	r0, #0
 802a4ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802a4ec:	4279      	negs	r1, r7
 802a4ee:	4620      	mov	r0, r4
 802a4f0:	f7fb fcfc 	bl	8025eec <_sbrk_r>
 802a4f4:	3001      	adds	r0, #1
 802a4f6:	d0e4      	beq.n	802a4c2 <_malloc_trim_r+0x42>
 802a4f8:	4b08      	ldr	r3, [pc, #32]	; (802a51c <_malloc_trim_r+0x9c>)
 802a4fa:	68aa      	ldr	r2, [r5, #8]
 802a4fc:	6819      	ldr	r1, [r3, #0]
 802a4fe:	1bf6      	subs	r6, r6, r7
 802a500:	f046 0601 	orr.w	r6, r6, #1
 802a504:	1bcf      	subs	r7, r1, r7
 802a506:	4620      	mov	r0, r4
 802a508:	6056      	str	r6, [r2, #4]
 802a50a:	601f      	str	r7, [r3, #0]
 802a50c:	f7f8 f8b4 	bl	8022678 <__malloc_unlock>
 802a510:	2001      	movs	r0, #1
 802a512:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802a514:	20000514 	.word	0x20000514
 802a518:	20000920 	.word	0x20000920
 802a51c:	20003fb4 	.word	0x20003fb4

0802a520 <_free_r>:
 802a520:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a524:	460d      	mov	r5, r1
 802a526:	4604      	mov	r4, r0
 802a528:	2900      	cmp	r1, #0
 802a52a:	d058      	beq.n	802a5de <_free_r+0xbe>
 802a52c:	f7f8 f89a 	bl	8022664 <__malloc_lock>
 802a530:	f855 0c04 	ldr.w	r0, [r5, #-4]
 802a534:	4e5a      	ldr	r6, [pc, #360]	; (802a6a0 <_free_r+0x180>)
 802a536:	f1a5 0108 	sub.w	r1, r5, #8
 802a53a:	f020 0301 	bic.w	r3, r0, #1
 802a53e:	18ca      	adds	r2, r1, r3
 802a540:	f8d6 c008 	ldr.w	ip, [r6, #8]
 802a544:	6857      	ldr	r7, [r2, #4]
 802a546:	4594      	cmp	ip, r2
 802a548:	f027 0703 	bic.w	r7, r7, #3
 802a54c:	d065      	beq.n	802a61a <_free_r+0xfa>
 802a54e:	f010 0001 	ands.w	r0, r0, #1
 802a552:	6057      	str	r7, [r2, #4]
 802a554:	d032      	beq.n	802a5bc <_free_r+0x9c>
 802a556:	2000      	movs	r0, #0
 802a558:	19d5      	adds	r5, r2, r7
 802a55a:	686d      	ldr	r5, [r5, #4]
 802a55c:	f015 0f01 	tst.w	r5, #1
 802a560:	d106      	bne.n	802a570 <_free_r+0x50>
 802a562:	19db      	adds	r3, r3, r7
 802a564:	6895      	ldr	r5, [r2, #8]
 802a566:	2800      	cmp	r0, #0
 802a568:	d04b      	beq.n	802a602 <_free_r+0xe2>
 802a56a:	68d2      	ldr	r2, [r2, #12]
 802a56c:	60ea      	str	r2, [r5, #12]
 802a56e:	6095      	str	r5, [r2, #8]
 802a570:	f043 0201 	orr.w	r2, r3, #1
 802a574:	604a      	str	r2, [r1, #4]
 802a576:	50cb      	str	r3, [r1, r3]
 802a578:	b9d8      	cbnz	r0, 802a5b2 <_free_r+0x92>
 802a57a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802a57e:	d330      	bcc.n	802a5e2 <_free_r+0xc2>
 802a580:	0a5a      	lsrs	r2, r3, #9
 802a582:	2a04      	cmp	r2, #4
 802a584:	d864      	bhi.n	802a650 <_free_r+0x130>
 802a586:	099d      	lsrs	r5, r3, #6
 802a588:	3538      	adds	r5, #56	; 0x38
 802a58a:	00e8      	lsls	r0, r5, #3
 802a58c:	1986      	adds	r6, r0, r6
 802a58e:	4844      	ldr	r0, [pc, #272]	; (802a6a0 <_free_r+0x180>)
 802a590:	68b2      	ldr	r2, [r6, #8]
 802a592:	42b2      	cmp	r2, r6
 802a594:	d103      	bne.n	802a59e <_free_r+0x7e>
 802a596:	e061      	b.n	802a65c <_free_r+0x13c>
 802a598:	6892      	ldr	r2, [r2, #8]
 802a59a:	4296      	cmp	r6, r2
 802a59c:	d004      	beq.n	802a5a8 <_free_r+0x88>
 802a59e:	6850      	ldr	r0, [r2, #4]
 802a5a0:	f020 0003 	bic.w	r0, r0, #3
 802a5a4:	4283      	cmp	r3, r0
 802a5a6:	d3f7      	bcc.n	802a598 <_free_r+0x78>
 802a5a8:	68d3      	ldr	r3, [r2, #12]
 802a5aa:	60cb      	str	r3, [r1, #12]
 802a5ac:	608a      	str	r2, [r1, #8]
 802a5ae:	60d1      	str	r1, [r2, #12]
 802a5b0:	6099      	str	r1, [r3, #8]
 802a5b2:	4620      	mov	r0, r4
 802a5b4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802a5b8:	f7f8 b85e 	b.w	8022678 <__malloc_unlock>
 802a5bc:	f855 cc08 	ldr.w	ip, [r5, #-8]
 802a5c0:	ebcc 0101 	rsb	r1, ip, r1
 802a5c4:	f106 0808 	add.w	r8, r6, #8
 802a5c8:	688d      	ldr	r5, [r1, #8]
 802a5ca:	4545      	cmp	r5, r8
 802a5cc:	4463      	add	r3, ip
 802a5ce:	d03d      	beq.n	802a64c <_free_r+0x12c>
 802a5d0:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 802a5d4:	f8c5 c00c 	str.w	ip, [r5, #12]
 802a5d8:	f8cc 5008 	str.w	r5, [ip, #8]
 802a5dc:	e7bc      	b.n	802a558 <_free_r+0x38>
 802a5de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a5e2:	08db      	lsrs	r3, r3, #3
 802a5e4:	eb06 02c3 	add.w	r2, r6, r3, lsl #3
 802a5e8:	6875      	ldr	r5, [r6, #4]
 802a5ea:	6890      	ldr	r0, [r2, #8]
 802a5ec:	60ca      	str	r2, [r1, #12]
 802a5ee:	109b      	asrs	r3, r3, #2
 802a5f0:	2701      	movs	r7, #1
 802a5f2:	fa07 f303 	lsl.w	r3, r7, r3
 802a5f6:	432b      	orrs	r3, r5
 802a5f8:	6088      	str	r0, [r1, #8]
 802a5fa:	6073      	str	r3, [r6, #4]
 802a5fc:	6091      	str	r1, [r2, #8]
 802a5fe:	60c1      	str	r1, [r0, #12]
 802a600:	e7d7      	b.n	802a5b2 <_free_r+0x92>
 802a602:	4f28      	ldr	r7, [pc, #160]	; (802a6a4 <_free_r+0x184>)
 802a604:	42bd      	cmp	r5, r7
 802a606:	d1b0      	bne.n	802a56a <_free_r+0x4a>
 802a608:	f043 0201 	orr.w	r2, r3, #1
 802a60c:	6171      	str	r1, [r6, #20]
 802a60e:	6131      	str	r1, [r6, #16]
 802a610:	60cd      	str	r5, [r1, #12]
 802a612:	608d      	str	r5, [r1, #8]
 802a614:	604a      	str	r2, [r1, #4]
 802a616:	50cb      	str	r3, [r1, r3]
 802a618:	e7cb      	b.n	802a5b2 <_free_r+0x92>
 802a61a:	07c2      	lsls	r2, r0, #31
 802a61c:	443b      	add	r3, r7
 802a61e:	d407      	bmi.n	802a630 <_free_r+0x110>
 802a620:	f855 2c08 	ldr.w	r2, [r5, #-8]
 802a624:	1a89      	subs	r1, r1, r2
 802a626:	189b      	adds	r3, r3, r2
 802a628:	6888      	ldr	r0, [r1, #8]
 802a62a:	68ca      	ldr	r2, [r1, #12]
 802a62c:	60c2      	str	r2, [r0, #12]
 802a62e:	6090      	str	r0, [r2, #8]
 802a630:	4a1d      	ldr	r2, [pc, #116]	; (802a6a8 <_free_r+0x188>)
 802a632:	60b1      	str	r1, [r6, #8]
 802a634:	6812      	ldr	r2, [r2, #0]
 802a636:	f043 0001 	orr.w	r0, r3, #1
 802a63a:	4293      	cmp	r3, r2
 802a63c:	6048      	str	r0, [r1, #4]
 802a63e:	d3b8      	bcc.n	802a5b2 <_free_r+0x92>
 802a640:	4b1a      	ldr	r3, [pc, #104]	; (802a6ac <_free_r+0x18c>)
 802a642:	4620      	mov	r0, r4
 802a644:	6819      	ldr	r1, [r3, #0]
 802a646:	f7ff ff1b 	bl	802a480 <_malloc_trim_r>
 802a64a:	e7b2      	b.n	802a5b2 <_free_r+0x92>
 802a64c:	2001      	movs	r0, #1
 802a64e:	e783      	b.n	802a558 <_free_r+0x38>
 802a650:	2a14      	cmp	r2, #20
 802a652:	d80c      	bhi.n	802a66e <_free_r+0x14e>
 802a654:	f102 055b 	add.w	r5, r2, #91	; 0x5b
 802a658:	00e8      	lsls	r0, r5, #3
 802a65a:	e797      	b.n	802a58c <_free_r+0x6c>
 802a65c:	6843      	ldr	r3, [r0, #4]
 802a65e:	10ad      	asrs	r5, r5, #2
 802a660:	2601      	movs	r6, #1
 802a662:	fa06 f505 	lsl.w	r5, r6, r5
 802a666:	432b      	orrs	r3, r5
 802a668:	6043      	str	r3, [r0, #4]
 802a66a:	4613      	mov	r3, r2
 802a66c:	e79d      	b.n	802a5aa <_free_r+0x8a>
 802a66e:	2a54      	cmp	r2, #84	; 0x54
 802a670:	d803      	bhi.n	802a67a <_free_r+0x15a>
 802a672:	0b1d      	lsrs	r5, r3, #12
 802a674:	356e      	adds	r5, #110	; 0x6e
 802a676:	00e8      	lsls	r0, r5, #3
 802a678:	e788      	b.n	802a58c <_free_r+0x6c>
 802a67a:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 802a67e:	d803      	bhi.n	802a688 <_free_r+0x168>
 802a680:	0bdd      	lsrs	r5, r3, #15
 802a682:	3577      	adds	r5, #119	; 0x77
 802a684:	00e8      	lsls	r0, r5, #3
 802a686:	e781      	b.n	802a58c <_free_r+0x6c>
 802a688:	f240 5054 	movw	r0, #1364	; 0x554
 802a68c:	4282      	cmp	r2, r0
 802a68e:	d803      	bhi.n	802a698 <_free_r+0x178>
 802a690:	0c9d      	lsrs	r5, r3, #18
 802a692:	357c      	adds	r5, #124	; 0x7c
 802a694:	00e8      	lsls	r0, r5, #3
 802a696:	e779      	b.n	802a58c <_free_r+0x6c>
 802a698:	f44f 707c 	mov.w	r0, #1008	; 0x3f0
 802a69c:	257e      	movs	r5, #126	; 0x7e
 802a69e:	e775      	b.n	802a58c <_free_r+0x6c>
 802a6a0:	20000514 	.word	0x20000514
 802a6a4:	2000051c 	.word	0x2000051c
 802a6a8:	2000091c 	.word	0x2000091c
 802a6ac:	20003fb0 	.word	0x20003fb0

0802a6b0 <__sfvwrite_r>:
 802a6b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a6b4:	b083      	sub	sp, #12
 802a6b6:	4690      	mov	r8, r2
 802a6b8:	9001      	str	r0, [sp, #4]
 802a6ba:	6890      	ldr	r0, [r2, #8]
 802a6bc:	460c      	mov	r4, r1
 802a6be:	b330      	cbz	r0, 802a70e <__sfvwrite_r+0x5e>
 802a6c0:	898b      	ldrh	r3, [r1, #12]
 802a6c2:	0719      	lsls	r1, r3, #28
 802a6c4:	d526      	bpl.n	802a714 <__sfvwrite_r+0x64>
 802a6c6:	6922      	ldr	r2, [r4, #16]
 802a6c8:	2a00      	cmp	r2, #0
 802a6ca:	d023      	beq.n	802a714 <__sfvwrite_r+0x64>
 802a6cc:	f013 0b02 	ands.w	fp, r3, #2
 802a6d0:	f8d8 5000 	ldr.w	r5, [r8]
 802a6d4:	d033      	beq.n	802a73e <__sfvwrite_r+0x8e>
 802a6d6:	f04f 0900 	mov.w	r9, #0
 802a6da:	464f      	mov	r7, r9
 802a6dc:	f5b7 6f80 	cmp.w	r7, #1024	; 0x400
 802a6e0:	bf34      	ite	cc
 802a6e2:	463b      	movcc	r3, r7
 802a6e4:	f44f 6380 	movcs.w	r3, #1024	; 0x400
 802a6e8:	464a      	mov	r2, r9
 802a6ea:	9801      	ldr	r0, [sp, #4]
 802a6ec:	2f00      	cmp	r7, #0
 802a6ee:	d021      	beq.n	802a734 <__sfvwrite_r+0x84>
 802a6f0:	69e1      	ldr	r1, [r4, #28]
 802a6f2:	6a66      	ldr	r6, [r4, #36]	; 0x24
 802a6f4:	47b0      	blx	r6
 802a6f6:	2800      	cmp	r0, #0
 802a6f8:	dd5d      	ble.n	802a7b6 <__sfvwrite_r+0x106>
 802a6fa:	f8d8 3008 	ldr.w	r3, [r8, #8]
 802a6fe:	1a1b      	subs	r3, r3, r0
 802a700:	4481      	add	r9, r0
 802a702:	1a3f      	subs	r7, r7, r0
 802a704:	f8c8 3008 	str.w	r3, [r8, #8]
 802a708:	2b00      	cmp	r3, #0
 802a70a:	d1e7      	bne.n	802a6dc <__sfvwrite_r+0x2c>
 802a70c:	4618      	mov	r0, r3
 802a70e:	b003      	add	sp, #12
 802a710:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a714:	9801      	ldr	r0, [sp, #4]
 802a716:	4621      	mov	r1, r4
 802a718:	f7fe fc86 	bl	8029028 <__swsetup_r>
 802a71c:	89a3      	ldrh	r3, [r4, #12]
 802a71e:	2800      	cmp	r0, #0
 802a720:	d0d4      	beq.n	802a6cc <__sfvwrite_r+0x1c>
 802a722:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a726:	9a01      	ldr	r2, [sp, #4]
 802a728:	81a3      	strh	r3, [r4, #12]
 802a72a:	2309      	movs	r3, #9
 802a72c:	f04f 30ff 	mov.w	r0, #4294967295
 802a730:	6013      	str	r3, [r2, #0]
 802a732:	e7ec      	b.n	802a70e <__sfvwrite_r+0x5e>
 802a734:	f8d5 9000 	ldr.w	r9, [r5]
 802a738:	686f      	ldr	r7, [r5, #4]
 802a73a:	3508      	adds	r5, #8
 802a73c:	e7ce      	b.n	802a6dc <__sfvwrite_r+0x2c>
 802a73e:	f013 0901 	ands.w	r9, r3, #1
 802a742:	d13f      	bne.n	802a7c4 <__sfvwrite_r+0x114>
 802a744:	464e      	mov	r6, r9
 802a746:	b326      	cbz	r6, 802a792 <__sfvwrite_r+0xe2>
 802a748:	059a      	lsls	r2, r3, #22
 802a74a:	68a7      	ldr	r7, [r4, #8]
 802a74c:	d574      	bpl.n	802a838 <__sfvwrite_r+0x188>
 802a74e:	42be      	cmp	r6, r7
 802a750:	46bb      	mov	fp, r7
 802a752:	f080 80a9 	bcs.w	802a8a8 <__sfvwrite_r+0x1f8>
 802a756:	6820      	ldr	r0, [r4, #0]
 802a758:	4633      	mov	r3, r6
 802a75a:	46b3      	mov	fp, r6
 802a75c:	46b2      	mov	sl, r6
 802a75e:	4637      	mov	r7, r6
 802a760:	4649      	mov	r1, r9
 802a762:	465a      	mov	r2, fp
 802a764:	9300      	str	r3, [sp, #0]
 802a766:	f7fa fe19 	bl	802539c <memmove>
 802a76a:	9b00      	ldr	r3, [sp, #0]
 802a76c:	68a1      	ldr	r1, [r4, #8]
 802a76e:	6822      	ldr	r2, [r4, #0]
 802a770:	1acb      	subs	r3, r1, r3
 802a772:	445a      	add	r2, fp
 802a774:	60a3      	str	r3, [r4, #8]
 802a776:	6022      	str	r2, [r4, #0]
 802a778:	f8d8 0008 	ldr.w	r0, [r8, #8]
 802a77c:	1bc7      	subs	r7, r0, r7
 802a77e:	f8c8 7008 	str.w	r7, [r8, #8]
 802a782:	2f00      	cmp	r7, #0
 802a784:	d073      	beq.n	802a86e <__sfvwrite_r+0x1be>
 802a786:	ebca 0606 	rsb	r6, sl, r6
 802a78a:	44d1      	add	r9, sl
 802a78c:	89a3      	ldrh	r3, [r4, #12]
 802a78e:	2e00      	cmp	r6, #0
 802a790:	d1da      	bne.n	802a748 <__sfvwrite_r+0x98>
 802a792:	f8d5 9000 	ldr.w	r9, [r5]
 802a796:	686e      	ldr	r6, [r5, #4]
 802a798:	3508      	adds	r5, #8
 802a79a:	e7d4      	b.n	802a746 <__sfvwrite_r+0x96>
 802a79c:	f000 fd00 	bl	802b1a0 <_realloc_r>
 802a7a0:	4683      	mov	fp, r0
 802a7a2:	2800      	cmp	r0, #0
 802a7a4:	f040 80ca 	bne.w	802a93c <__sfvwrite_r+0x28c>
 802a7a8:	6921      	ldr	r1, [r4, #16]
 802a7aa:	9801      	ldr	r0, [sp, #4]
 802a7ac:	f7ff feb8 	bl	802a520 <_free_r>
 802a7b0:	9a01      	ldr	r2, [sp, #4]
 802a7b2:	230c      	movs	r3, #12
 802a7b4:	6013      	str	r3, [r2, #0]
 802a7b6:	89a3      	ldrh	r3, [r4, #12]
 802a7b8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a7bc:	81a3      	strh	r3, [r4, #12]
 802a7be:	f04f 30ff 	mov.w	r0, #4294967295
 802a7c2:	e7a4      	b.n	802a70e <__sfvwrite_r+0x5e>
 802a7c4:	46dc      	mov	ip, fp
 802a7c6:	46da      	mov	sl, fp
 802a7c8:	465f      	mov	r7, fp
 802a7ca:	2f00      	cmp	r7, #0
 802a7cc:	d02d      	beq.n	802a82a <__sfvwrite_r+0x17a>
 802a7ce:	f1bc 0f00 	cmp.w	ip, #0
 802a7d2:	d07e      	beq.n	802a8d2 <__sfvwrite_r+0x222>
 802a7d4:	6820      	ldr	r0, [r4, #0]
 802a7d6:	6922      	ldr	r2, [r4, #16]
 802a7d8:	68a6      	ldr	r6, [r4, #8]
 802a7da:	6963      	ldr	r3, [r4, #20]
 802a7dc:	45bb      	cmp	fp, r7
 802a7de:	bf34      	ite	cc
 802a7e0:	46d9      	movcc	r9, fp
 802a7e2:	46b9      	movcs	r9, r7
 802a7e4:	4290      	cmp	r0, r2
 802a7e6:	d903      	bls.n	802a7f0 <__sfvwrite_r+0x140>
 802a7e8:	18f6      	adds	r6, r6, r3
 802a7ea:	45b1      	cmp	r9, r6
 802a7ec:	f300 80b4 	bgt.w	802a958 <__sfvwrite_r+0x2a8>
 802a7f0:	4599      	cmp	r9, r3
 802a7f2:	db3e      	blt.n	802a872 <__sfvwrite_r+0x1c2>
 802a7f4:	6a66      	ldr	r6, [r4, #36]	; 0x24
 802a7f6:	69e1      	ldr	r1, [r4, #28]
 802a7f8:	9801      	ldr	r0, [sp, #4]
 802a7fa:	f8cd c000 	str.w	ip, [sp]
 802a7fe:	4652      	mov	r2, sl
 802a800:	47b0      	blx	r6
 802a802:	2800      	cmp	r0, #0
 802a804:	4606      	mov	r6, r0
 802a806:	f8dd c000 	ldr.w	ip, [sp]
 802a80a:	ddd4      	ble.n	802a7b6 <__sfvwrite_r+0x106>
 802a80c:	ebbb 0b06 	subs.w	fp, fp, r6
 802a810:	d042      	beq.n	802a898 <__sfvwrite_r+0x1e8>
 802a812:	f8d8 0008 	ldr.w	r0, [r8, #8]
 802a816:	1b80      	subs	r0, r0, r6
 802a818:	44b2      	add	sl, r6
 802a81a:	1bbf      	subs	r7, r7, r6
 802a81c:	f8c8 0008 	str.w	r0, [r8, #8]
 802a820:	2800      	cmp	r0, #0
 802a822:	f43f af74 	beq.w	802a70e <__sfvwrite_r+0x5e>
 802a826:	2f00      	cmp	r7, #0
 802a828:	d1d1      	bne.n	802a7ce <__sfvwrite_r+0x11e>
 802a82a:	f8d5 a000 	ldr.w	sl, [r5]
 802a82e:	686f      	ldr	r7, [r5, #4]
 802a830:	f04f 0c00 	mov.w	ip, #0
 802a834:	3508      	adds	r5, #8
 802a836:	e7c8      	b.n	802a7ca <__sfvwrite_r+0x11a>
 802a838:	6820      	ldr	r0, [r4, #0]
 802a83a:	6923      	ldr	r3, [r4, #16]
 802a83c:	4298      	cmp	r0, r3
 802a83e:	d903      	bls.n	802a848 <__sfvwrite_r+0x198>
 802a840:	42be      	cmp	r6, r7
 802a842:	46ba      	mov	sl, r7
 802a844:	f200 809b 	bhi.w	802a97e <__sfvwrite_r+0x2ce>
 802a848:	6963      	ldr	r3, [r4, #20]
 802a84a:	429e      	cmp	r6, r3
 802a84c:	d334      	bcc.n	802a8b8 <__sfvwrite_r+0x208>
 802a84e:	6a67      	ldr	r7, [r4, #36]	; 0x24
 802a850:	69e1      	ldr	r1, [r4, #28]
 802a852:	9801      	ldr	r0, [sp, #4]
 802a854:	464a      	mov	r2, r9
 802a856:	47b8      	blx	r7
 802a858:	2800      	cmp	r0, #0
 802a85a:	4607      	mov	r7, r0
 802a85c:	ddab      	ble.n	802a7b6 <__sfvwrite_r+0x106>
 802a85e:	4682      	mov	sl, r0
 802a860:	f8d8 0008 	ldr.w	r0, [r8, #8]
 802a864:	1bc7      	subs	r7, r0, r7
 802a866:	f8c8 7008 	str.w	r7, [r8, #8]
 802a86a:	2f00      	cmp	r7, #0
 802a86c:	d18b      	bne.n	802a786 <__sfvwrite_r+0xd6>
 802a86e:	4638      	mov	r0, r7
 802a870:	e74d      	b.n	802a70e <__sfvwrite_r+0x5e>
 802a872:	464a      	mov	r2, r9
 802a874:	4651      	mov	r1, sl
 802a876:	f8cd c000 	str.w	ip, [sp]
 802a87a:	f7fa fd8f 	bl	802539c <memmove>
 802a87e:	68a2      	ldr	r2, [r4, #8]
 802a880:	6823      	ldr	r3, [r4, #0]
 802a882:	f8dd c000 	ldr.w	ip, [sp]
 802a886:	464e      	mov	r6, r9
 802a888:	ebc9 0202 	rsb	r2, r9, r2
 802a88c:	444b      	add	r3, r9
 802a88e:	ebbb 0b06 	subs.w	fp, fp, r6
 802a892:	60a2      	str	r2, [r4, #8]
 802a894:	6023      	str	r3, [r4, #0]
 802a896:	d1bc      	bne.n	802a812 <__sfvwrite_r+0x162>
 802a898:	9801      	ldr	r0, [sp, #4]
 802a89a:	4621      	mov	r1, r4
 802a89c:	f7ff fc7c 	bl	802a198 <_fflush_r>
 802a8a0:	2800      	cmp	r0, #0
 802a8a2:	d188      	bne.n	802a7b6 <__sfvwrite_r+0x106>
 802a8a4:	46dc      	mov	ip, fp
 802a8a6:	e7b4      	b.n	802a812 <__sfvwrite_r+0x162>
 802a8a8:	f413 6f90 	tst.w	r3, #1152	; 0x480
 802a8ac:	d11f      	bne.n	802a8ee <__sfvwrite_r+0x23e>
 802a8ae:	463b      	mov	r3, r7
 802a8b0:	6820      	ldr	r0, [r4, #0]
 802a8b2:	46b2      	mov	sl, r6
 802a8b4:	4637      	mov	r7, r6
 802a8b6:	e753      	b.n	802a760 <__sfvwrite_r+0xb0>
 802a8b8:	4632      	mov	r2, r6
 802a8ba:	4649      	mov	r1, r9
 802a8bc:	f7fa fd6e 	bl	802539c <memmove>
 802a8c0:	68a2      	ldr	r2, [r4, #8]
 802a8c2:	6823      	ldr	r3, [r4, #0]
 802a8c4:	1b92      	subs	r2, r2, r6
 802a8c6:	199b      	adds	r3, r3, r6
 802a8c8:	4637      	mov	r7, r6
 802a8ca:	60a2      	str	r2, [r4, #8]
 802a8cc:	6023      	str	r3, [r4, #0]
 802a8ce:	46b2      	mov	sl, r6
 802a8d0:	e752      	b.n	802a778 <__sfvwrite_r+0xc8>
 802a8d2:	4650      	mov	r0, sl
 802a8d4:	210a      	movs	r1, #10
 802a8d6:	463a      	mov	r2, r7
 802a8d8:	f000 f91c 	bl	802ab14 <memchr>
 802a8dc:	2800      	cmp	r0, #0
 802a8de:	d05d      	beq.n	802a99c <__sfvwrite_r+0x2ec>
 802a8e0:	f100 0b01 	add.w	fp, r0, #1
 802a8e4:	ebca 0b0b 	rsb	fp, sl, fp
 802a8e8:	f04f 0c01 	mov.w	ip, #1
 802a8ec:	e772      	b.n	802a7d4 <__sfvwrite_r+0x124>
 802a8ee:	6822      	ldr	r2, [r4, #0]
 802a8f0:	6921      	ldr	r1, [r4, #16]
 802a8f2:	6967      	ldr	r7, [r4, #20]
 802a8f4:	ebc1 0a02 	rsb	sl, r1, r2
 802a8f8:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 802a8fc:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 802a900:	f10a 0001 	add.w	r0, sl, #1
 802a904:	107f      	asrs	r7, r7, #1
 802a906:	1980      	adds	r0, r0, r6
 802a908:	4287      	cmp	r7, r0
 802a90a:	463a      	mov	r2, r7
 802a90c:	bf3c      	itt	cc
 802a90e:	4607      	movcc	r7, r0
 802a910:	463a      	movcc	r2, r7
 802a912:	055b      	lsls	r3, r3, #21
 802a914:	9801      	ldr	r0, [sp, #4]
 802a916:	f57f af41 	bpl.w	802a79c <__sfvwrite_r+0xec>
 802a91a:	4611      	mov	r1, r2
 802a91c:	f7fa fa5c 	bl	8024dd8 <_malloc_r>
 802a920:	4683      	mov	fp, r0
 802a922:	2800      	cmp	r0, #0
 802a924:	f43f af44 	beq.w	802a7b0 <__sfvwrite_r+0x100>
 802a928:	6921      	ldr	r1, [r4, #16]
 802a92a:	4652      	mov	r2, sl
 802a92c:	f7fa fcf4 	bl	8025318 <memcpy>
 802a930:	89a3      	ldrh	r3, [r4, #12]
 802a932:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 802a936:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802a93a:	81a3      	strh	r3, [r4, #12]
 802a93c:	eb0b 000a 	add.w	r0, fp, sl
 802a940:	ebca 0207 	rsb	r2, sl, r7
 802a944:	f8c4 b010 	str.w	fp, [r4, #16]
 802a948:	6167      	str	r7, [r4, #20]
 802a94a:	6020      	str	r0, [r4, #0]
 802a94c:	4633      	mov	r3, r6
 802a94e:	60a2      	str	r2, [r4, #8]
 802a950:	46b3      	mov	fp, r6
 802a952:	46b2      	mov	sl, r6
 802a954:	4637      	mov	r7, r6
 802a956:	e703      	b.n	802a760 <__sfvwrite_r+0xb0>
 802a958:	4651      	mov	r1, sl
 802a95a:	4632      	mov	r2, r6
 802a95c:	f8cd c000 	str.w	ip, [sp]
 802a960:	f7fa fd1c 	bl	802539c <memmove>
 802a964:	6823      	ldr	r3, [r4, #0]
 802a966:	9801      	ldr	r0, [sp, #4]
 802a968:	199b      	adds	r3, r3, r6
 802a96a:	6023      	str	r3, [r4, #0]
 802a96c:	4621      	mov	r1, r4
 802a96e:	f7ff fc13 	bl	802a198 <_fflush_r>
 802a972:	f8dd c000 	ldr.w	ip, [sp]
 802a976:	2800      	cmp	r0, #0
 802a978:	f43f af48 	beq.w	802a80c <__sfvwrite_r+0x15c>
 802a97c:	e71b      	b.n	802a7b6 <__sfvwrite_r+0x106>
 802a97e:	4649      	mov	r1, r9
 802a980:	463a      	mov	r2, r7
 802a982:	f7fa fd0b 	bl	802539c <memmove>
 802a986:	6823      	ldr	r3, [r4, #0]
 802a988:	9801      	ldr	r0, [sp, #4]
 802a98a:	19db      	adds	r3, r3, r7
 802a98c:	6023      	str	r3, [r4, #0]
 802a98e:	4621      	mov	r1, r4
 802a990:	f7ff fc02 	bl	802a198 <_fflush_r>
 802a994:	2800      	cmp	r0, #0
 802a996:	f43f aeef 	beq.w	802a778 <__sfvwrite_r+0xc8>
 802a99a:	e70c      	b.n	802a7b6 <__sfvwrite_r+0x106>
 802a99c:	f107 0b01 	add.w	fp, r7, #1
 802a9a0:	f04f 0c01 	mov.w	ip, #1
 802a9a4:	e716      	b.n	802a7d4 <__sfvwrite_r+0x124>
 802a9a6:	bf00      	nop

0802a9a8 <_fwalk>:
 802a9a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a9ac:	4606      	mov	r6, r0
 802a9ae:	4688      	mov	r8, r1
 802a9b0:	f7ff fcfa 	bl	802a3a8 <__sfp_lock_acquire>
 802a9b4:	f516 7638 	adds.w	r6, r6, #736	; 0x2e0
 802a9b8:	d01a      	beq.n	802a9f0 <_fwalk+0x48>
 802a9ba:	2700      	movs	r7, #0
 802a9bc:	6875      	ldr	r5, [r6, #4]
 802a9be:	68b4      	ldr	r4, [r6, #8]
 802a9c0:	3d01      	subs	r5, #1
 802a9c2:	d40d      	bmi.n	802a9e0 <_fwalk+0x38>
 802a9c4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802a9c8:	3d01      	subs	r5, #1
 802a9ca:	b133      	cbz	r3, 802a9da <_fwalk+0x32>
 802a9cc:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 802a9d0:	3301      	adds	r3, #1
 802a9d2:	d002      	beq.n	802a9da <_fwalk+0x32>
 802a9d4:	4620      	mov	r0, r4
 802a9d6:	47c0      	blx	r8
 802a9d8:	4307      	orrs	r7, r0
 802a9da:	3468      	adds	r4, #104	; 0x68
 802a9dc:	1c6b      	adds	r3, r5, #1
 802a9de:	d1f1      	bne.n	802a9c4 <_fwalk+0x1c>
 802a9e0:	6836      	ldr	r6, [r6, #0]
 802a9e2:	2e00      	cmp	r6, #0
 802a9e4:	d1ea      	bne.n	802a9bc <_fwalk+0x14>
 802a9e6:	f7ff fce1 	bl	802a3ac <__sfp_lock_release>
 802a9ea:	4638      	mov	r0, r7
 802a9ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a9f0:	4637      	mov	r7, r6
 802a9f2:	f7ff fcdb 	bl	802a3ac <__sfp_lock_release>
 802a9f6:	4638      	mov	r0, r7
 802a9f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0802a9fc <__gettzinfo>:
 802a9fc:	f640 1030 	movw	r0, #2352	; 0x930
 802aa00:	f2c2 0000 	movt	r0, #8192	; 0x2000
 802aa04:	4770      	bx	lr
 802aa06:	bf00      	nop

0802aa08 <labs>:
 802aa08:	2800      	cmp	r0, #0
 802aa0a:	bfb8      	it	lt
 802aa0c:	4240      	neglt	r0, r0
 802aa0e:	4770      	bx	lr

0802aa10 <__locale_charset>:
 802aa10:	f640 10a8 	movw	r0, #2472	; 0x9a8
 802aa14:	f2c2 0000 	movt	r0, #8192	; 0x2000
 802aa18:	4770      	bx	lr
 802aa1a:	bf00      	nop

0802aa1c <__locale_mb_cur_max>:
 802aa1c:	f640 13c8 	movw	r3, #2504	; 0x9c8
 802aa20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802aa24:	6818      	ldr	r0, [r3, #0]
 802aa26:	4770      	bx	lr

0802aa28 <_localeconv_r>:
 802aa28:	f640 1070 	movw	r0, #2416	; 0x970
 802aa2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 802aa30:	4770      	bx	lr
 802aa32:	bf00      	nop

0802aa34 <__smakebuf_r>:
 802aa34:	b5f0      	push	{r4, r5, r6, r7, lr}
 802aa36:	898b      	ldrh	r3, [r1, #12]
 802aa38:	b29a      	uxth	r2, r3
 802aa3a:	4605      	mov	r5, r0
 802aa3c:	0790      	lsls	r0, r2, #30
 802aa3e:	b091      	sub	sp, #68	; 0x44
 802aa40:	460c      	mov	r4, r1
 802aa42:	d439      	bmi.n	802aab8 <__smakebuf_r+0x84>
 802aa44:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802aa48:	2900      	cmp	r1, #0
 802aa4a:	db19      	blt.n	802aa80 <__smakebuf_r+0x4c>
 802aa4c:	4628      	mov	r0, r5
 802aa4e:	aa01      	add	r2, sp, #4
 802aa50:	f7f7 fdb8 	bl	80225c4 <_fstat_r>
 802aa54:	2800      	cmp	r0, #0
 802aa56:	db11      	blt.n	802aa7c <__smakebuf_r+0x48>
 802aa58:	9b02      	ldr	r3, [sp, #8]
 802aa5a:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
 802aa5e:	f5a3 5100 	sub.w	r1, r3, #8192	; 0x2000
 802aa62:	424f      	negs	r7, r1
 802aa64:	eb47 0701 	adc.w	r7, r7, r1
 802aa68:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 802aa6c:	d037      	beq.n	802aade <__smakebuf_r+0xaa>
 802aa6e:	89a3      	ldrh	r3, [r4, #12]
 802aa70:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 802aa74:	81a3      	strh	r3, [r4, #12]
 802aa76:	f44f 6680 	mov.w	r6, #1024	; 0x400
 802aa7a:	e00b      	b.n	802aa94 <__smakebuf_r+0x60>
 802aa7c:	89a3      	ldrh	r3, [r4, #12]
 802aa7e:	b29a      	uxth	r2, r3
 802aa80:	f012 0f80 	tst.w	r2, #128	; 0x80
 802aa84:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 802aa88:	bf14      	ite	ne
 802aa8a:	2640      	movne	r6, #64	; 0x40
 802aa8c:	f44f 6680 	moveq.w	r6, #1024	; 0x400
 802aa90:	81a3      	strh	r3, [r4, #12]
 802aa92:	2700      	movs	r7, #0
 802aa94:	4628      	mov	r0, r5
 802aa96:	4631      	mov	r1, r6
 802aa98:	f7fa f99e 	bl	8024dd8 <_malloc_r>
 802aa9c:	89a3      	ldrh	r3, [r4, #12]
 802aa9e:	2800      	cmp	r0, #0
 802aaa0:	d028      	beq.n	802aaf4 <__smakebuf_r+0xc0>
 802aaa2:	4a1a      	ldr	r2, [pc, #104]	; (802ab0c <__smakebuf_r+0xd8>)
 802aaa4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802aaa8:	63ea      	str	r2, [r5, #60]	; 0x3c
 802aaaa:	81a3      	strh	r3, [r4, #12]
 802aaac:	6020      	str	r0, [r4, #0]
 802aaae:	6120      	str	r0, [r4, #16]
 802aab0:	6166      	str	r6, [r4, #20]
 802aab2:	b947      	cbnz	r7, 802aac6 <__smakebuf_r+0x92>
 802aab4:	b011      	add	sp, #68	; 0x44
 802aab6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802aab8:	f101 0343 	add.w	r3, r1, #67	; 0x43
 802aabc:	600b      	str	r3, [r1, #0]
 802aabe:	610b      	str	r3, [r1, #16]
 802aac0:	2301      	movs	r3, #1
 802aac2:	614b      	str	r3, [r1, #20]
 802aac4:	e7f6      	b.n	802aab4 <__smakebuf_r+0x80>
 802aac6:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802aaca:	4628      	mov	r0, r5
 802aacc:	f7f7 fd9a 	bl	8022604 <_isatty_r>
 802aad0:	2800      	cmp	r0, #0
 802aad2:	d0ef      	beq.n	802aab4 <__smakebuf_r+0x80>
 802aad4:	89a3      	ldrh	r3, [r4, #12]
 802aad6:	f043 0301 	orr.w	r3, r3, #1
 802aada:	81a3      	strh	r3, [r4, #12]
 802aadc:	e7ea      	b.n	802aab4 <__smakebuf_r+0x80>
 802aade:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 802aae0:	4b0b      	ldr	r3, [pc, #44]	; (802ab10 <__smakebuf_r+0xdc>)
 802aae2:	429a      	cmp	r2, r3
 802aae4:	d1c3      	bne.n	802aa6e <__smakebuf_r+0x3a>
 802aae6:	89a3      	ldrh	r3, [r4, #12]
 802aae8:	f44f 6680 	mov.w	r6, #1024	; 0x400
 802aaec:	4333      	orrs	r3, r6
 802aaee:	81a3      	strh	r3, [r4, #12]
 802aaf0:	64e6      	str	r6, [r4, #76]	; 0x4c
 802aaf2:	e7cf      	b.n	802aa94 <__smakebuf_r+0x60>
 802aaf4:	059a      	lsls	r2, r3, #22
 802aaf6:	d4dd      	bmi.n	802aab4 <__smakebuf_r+0x80>
 802aaf8:	f043 0302 	orr.w	r3, r3, #2
 802aafc:	f104 0243 	add.w	r2, r4, #67	; 0x43
 802ab00:	81a3      	strh	r3, [r4, #12]
 802ab02:	2301      	movs	r3, #1
 802ab04:	6022      	str	r2, [r4, #0]
 802ab06:	6122      	str	r2, [r4, #16]
 802ab08:	6163      	str	r3, [r4, #20]
 802ab0a:	e7d3      	b.n	802aab4 <__smakebuf_r+0x80>
 802ab0c:	0802a305 	.word	0x0802a305
 802ab10:	0802b71d 	.word	0x0802b71d

0802ab14 <memchr>:
 802ab14:	0783      	lsls	r3, r0, #30
 802ab16:	b470      	push	{r4, r5, r6}
 802ab18:	b2c9      	uxtb	r1, r1
 802ab1a:	d011      	beq.n	802ab40 <memchr+0x2c>
 802ab1c:	2a00      	cmp	r2, #0
 802ab1e:	d023      	beq.n	802ab68 <memchr+0x54>
 802ab20:	7803      	ldrb	r3, [r0, #0]
 802ab22:	428b      	cmp	r3, r1
 802ab24:	d01e      	beq.n	802ab64 <memchr+0x50>
 802ab26:	4603      	mov	r3, r0
 802ab28:	3a01      	subs	r2, #1
 802ab2a:	e005      	b.n	802ab38 <memchr+0x24>
 802ab2c:	b1e2      	cbz	r2, 802ab68 <memchr+0x54>
 802ab2e:	f813 4f01 	ldrb.w	r4, [r3, #1]!
 802ab32:	3a01      	subs	r2, #1
 802ab34:	428c      	cmp	r4, r1
 802ab36:	d015      	beq.n	802ab64 <memchr+0x50>
 802ab38:	3001      	adds	r0, #1
 802ab3a:	f010 0f03 	tst.w	r0, #3
 802ab3e:	d1f5      	bne.n	802ab2c <memchr+0x18>
 802ab40:	2a03      	cmp	r2, #3
 802ab42:	d813      	bhi.n	802ab6c <memchr+0x58>
 802ab44:	b182      	cbz	r2, 802ab68 <memchr+0x54>
 802ab46:	7803      	ldrb	r3, [r0, #0]
 802ab48:	428b      	cmp	r3, r1
 802ab4a:	d00b      	beq.n	802ab64 <memchr+0x50>
 802ab4c:	1c43      	adds	r3, r0, #1
 802ab4e:	1882      	adds	r2, r0, r2
 802ab50:	e003      	b.n	802ab5a <memchr+0x46>
 802ab52:	f813 4b01 	ldrb.w	r4, [r3], #1
 802ab56:	428c      	cmp	r4, r1
 802ab58:	d004      	beq.n	802ab64 <memchr+0x50>
 802ab5a:	4293      	cmp	r3, r2
 802ab5c:	f100 0001 	add.w	r0, r0, #1
 802ab60:	d1f7      	bne.n	802ab52 <memchr+0x3e>
 802ab62:	2000      	movs	r0, #0
 802ab64:	bc70      	pop	{r4, r5, r6}
 802ab66:	4770      	bx	lr
 802ab68:	4610      	mov	r0, r2
 802ab6a:	e7fb      	b.n	802ab64 <memchr+0x50>
 802ab6c:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 802ab70:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 802ab74:	4604      	mov	r4, r0
 802ab76:	3004      	adds	r0, #4
 802ab78:	6823      	ldr	r3, [r4, #0]
 802ab7a:	4073      	eors	r3, r6
 802ab7c:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 802ab80:	ea25 0303 	bic.w	r3, r5, r3
 802ab84:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 802ab88:	d103      	bne.n	802ab92 <memchr+0x7e>
 802ab8a:	3a04      	subs	r2, #4
 802ab8c:	2a03      	cmp	r2, #3
 802ab8e:	d8f1      	bhi.n	802ab74 <memchr+0x60>
 802ab90:	e7d8      	b.n	802ab44 <memchr+0x30>
 802ab92:	4620      	mov	r0, r4
 802ab94:	e7d6      	b.n	802ab44 <memchr+0x30>
 802ab96:	bf00      	nop

0802ab98 <_Balloc>:
 802ab98:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 802ab9a:	b570      	push	{r4, r5, r6, lr}
 802ab9c:	4605      	mov	r5, r0
 802ab9e:	460c      	mov	r4, r1
 802aba0:	b14b      	cbz	r3, 802abb6 <_Balloc+0x1e>
 802aba2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 802aba6:	b178      	cbz	r0, 802abc8 <_Balloc+0x30>
 802aba8:	6802      	ldr	r2, [r0, #0]
 802abaa:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 802abae:	2300      	movs	r3, #0
 802abb0:	6103      	str	r3, [r0, #16]
 802abb2:	60c3      	str	r3, [r0, #12]
 802abb4:	bd70      	pop	{r4, r5, r6, pc}
 802abb6:	2104      	movs	r1, #4
 802abb8:	2221      	movs	r2, #33	; 0x21
 802abba:	f000 fed7 	bl	802b96c <_calloc_r>
 802abbe:	4603      	mov	r3, r0
 802abc0:	64e8      	str	r0, [r5, #76]	; 0x4c
 802abc2:	2800      	cmp	r0, #0
 802abc4:	d1ed      	bne.n	802aba2 <_Balloc+0xa>
 802abc6:	bd70      	pop	{r4, r5, r6, pc}
 802abc8:	2101      	movs	r1, #1
 802abca:	fa01 f604 	lsl.w	r6, r1, r4
 802abce:	1d72      	adds	r2, r6, #5
 802abd0:	0092      	lsls	r2, r2, #2
 802abd2:	4628      	mov	r0, r5
 802abd4:	f000 feca 	bl	802b96c <_calloc_r>
 802abd8:	2800      	cmp	r0, #0
 802abda:	d0f4      	beq.n	802abc6 <_Balloc+0x2e>
 802abdc:	6044      	str	r4, [r0, #4]
 802abde:	6086      	str	r6, [r0, #8]
 802abe0:	e7e5      	b.n	802abae <_Balloc+0x16>
 802abe2:	bf00      	nop

0802abe4 <_Bfree>:
 802abe4:	b131      	cbz	r1, 802abf4 <_Bfree+0x10>
 802abe6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 802abe8:	684a      	ldr	r2, [r1, #4]
 802abea:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 802abee:	6008      	str	r0, [r1, #0]
 802abf0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 802abf4:	4770      	bx	lr
 802abf6:	bf00      	nop

0802abf8 <__multadd>:
 802abf8:	b5f0      	push	{r4, r5, r6, r7, lr}
 802abfa:	460d      	mov	r5, r1
 802abfc:	4606      	mov	r6, r0
 802abfe:	690c      	ldr	r4, [r1, #16]
 802ac00:	f101 0014 	add.w	r0, r1, #20
 802ac04:	b083      	sub	sp, #12
 802ac06:	2100      	movs	r1, #0
 802ac08:	6807      	ldr	r7, [r0, #0]
 802ac0a:	fa1f fc87 	uxth.w	ip, r7
 802ac0e:	0c3f      	lsrs	r7, r7, #16
 802ac10:	fb02 330c 	mla	r3, r2, ip, r3
 802ac14:	fb02 f707 	mul.w	r7, r2, r7
 802ac18:	eb07 4713 	add.w	r7, r7, r3, lsr #16
 802ac1c:	b29b      	uxth	r3, r3
 802ac1e:	eb03 4307 	add.w	r3, r3, r7, lsl #16
 802ac22:	3101      	adds	r1, #1
 802ac24:	f840 3b04 	str.w	r3, [r0], #4
 802ac28:	0c3b      	lsrs	r3, r7, #16
 802ac2a:	428c      	cmp	r4, r1
 802ac2c:	dcec      	bgt.n	802ac08 <__multadd+0x10>
 802ac2e:	b13b      	cbz	r3, 802ac40 <__multadd+0x48>
 802ac30:	68aa      	ldr	r2, [r5, #8]
 802ac32:	4294      	cmp	r4, r2
 802ac34:	da07      	bge.n	802ac46 <__multadd+0x4e>
 802ac36:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 802ac3a:	3401      	adds	r4, #1
 802ac3c:	6153      	str	r3, [r2, #20]
 802ac3e:	612c      	str	r4, [r5, #16]
 802ac40:	4628      	mov	r0, r5
 802ac42:	b003      	add	sp, #12
 802ac44:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802ac46:	6869      	ldr	r1, [r5, #4]
 802ac48:	9301      	str	r3, [sp, #4]
 802ac4a:	3101      	adds	r1, #1
 802ac4c:	4630      	mov	r0, r6
 802ac4e:	f7ff ffa3 	bl	802ab98 <_Balloc>
 802ac52:	692a      	ldr	r2, [r5, #16]
 802ac54:	3202      	adds	r2, #2
 802ac56:	f105 010c 	add.w	r1, r5, #12
 802ac5a:	4607      	mov	r7, r0
 802ac5c:	0092      	lsls	r2, r2, #2
 802ac5e:	f100 000c 	add.w	r0, r0, #12
 802ac62:	f7fa fb59 	bl	8025318 <memcpy>
 802ac66:	6869      	ldr	r1, [r5, #4]
 802ac68:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 802ac6a:	9b01      	ldr	r3, [sp, #4]
 802ac6c:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
 802ac70:	6028      	str	r0, [r5, #0]
 802ac72:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
 802ac76:	463d      	mov	r5, r7
 802ac78:	e7dd      	b.n	802ac36 <__multadd+0x3e>
 802ac7a:	bf00      	nop

0802ac7c <__hi0bits>:
 802ac7c:	0c02      	lsrs	r2, r0, #16
 802ac7e:	4603      	mov	r3, r0
 802ac80:	d116      	bne.n	802acb0 <__hi0bits+0x34>
 802ac82:	0403      	lsls	r3, r0, #16
 802ac84:	2010      	movs	r0, #16
 802ac86:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 802ac8a:	d101      	bne.n	802ac90 <__hi0bits+0x14>
 802ac8c:	3008      	adds	r0, #8
 802ac8e:	021b      	lsls	r3, r3, #8
 802ac90:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 802ac94:	d101      	bne.n	802ac9a <__hi0bits+0x1e>
 802ac96:	3004      	adds	r0, #4
 802ac98:	011b      	lsls	r3, r3, #4
 802ac9a:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 802ac9e:	d101      	bne.n	802aca4 <__hi0bits+0x28>
 802aca0:	3002      	adds	r0, #2
 802aca2:	009b      	lsls	r3, r3, #2
 802aca4:	2b00      	cmp	r3, #0
 802aca6:	db02      	blt.n	802acae <__hi0bits+0x32>
 802aca8:	005b      	lsls	r3, r3, #1
 802acaa:	d403      	bmi.n	802acb4 <__hi0bits+0x38>
 802acac:	2020      	movs	r0, #32
 802acae:	4770      	bx	lr
 802acb0:	2000      	movs	r0, #0
 802acb2:	e7e8      	b.n	802ac86 <__hi0bits+0xa>
 802acb4:	3001      	adds	r0, #1
 802acb6:	4770      	bx	lr

0802acb8 <__lo0bits>:
 802acb8:	6803      	ldr	r3, [r0, #0]
 802acba:	4602      	mov	r2, r0
 802acbc:	f013 0007 	ands.w	r0, r3, #7
 802acc0:	d007      	beq.n	802acd2 <__lo0bits+0x1a>
 802acc2:	07d9      	lsls	r1, r3, #31
 802acc4:	d41f      	bmi.n	802ad06 <__lo0bits+0x4e>
 802acc6:	0798      	lsls	r0, r3, #30
 802acc8:	d41f      	bmi.n	802ad0a <__lo0bits+0x52>
 802acca:	089b      	lsrs	r3, r3, #2
 802accc:	6013      	str	r3, [r2, #0]
 802acce:	2002      	movs	r0, #2
 802acd0:	4770      	bx	lr
 802acd2:	b299      	uxth	r1, r3
 802acd4:	b909      	cbnz	r1, 802acda <__lo0bits+0x22>
 802acd6:	0c1b      	lsrs	r3, r3, #16
 802acd8:	2010      	movs	r0, #16
 802acda:	f013 0fff 	tst.w	r3, #255	; 0xff
 802acde:	d101      	bne.n	802ace4 <__lo0bits+0x2c>
 802ace0:	3008      	adds	r0, #8
 802ace2:	0a1b      	lsrs	r3, r3, #8
 802ace4:	0719      	lsls	r1, r3, #28
 802ace6:	d101      	bne.n	802acec <__lo0bits+0x34>
 802ace8:	3004      	adds	r0, #4
 802acea:	091b      	lsrs	r3, r3, #4
 802acec:	0799      	lsls	r1, r3, #30
 802acee:	d101      	bne.n	802acf4 <__lo0bits+0x3c>
 802acf0:	3002      	adds	r0, #2
 802acf2:	089b      	lsrs	r3, r3, #2
 802acf4:	07d9      	lsls	r1, r3, #31
 802acf6:	d404      	bmi.n	802ad02 <__lo0bits+0x4a>
 802acf8:	085b      	lsrs	r3, r3, #1
 802acfa:	d101      	bne.n	802ad00 <__lo0bits+0x48>
 802acfc:	2020      	movs	r0, #32
 802acfe:	4770      	bx	lr
 802ad00:	3001      	adds	r0, #1
 802ad02:	6013      	str	r3, [r2, #0]
 802ad04:	4770      	bx	lr
 802ad06:	2000      	movs	r0, #0
 802ad08:	4770      	bx	lr
 802ad0a:	085b      	lsrs	r3, r3, #1
 802ad0c:	6013      	str	r3, [r2, #0]
 802ad0e:	2001      	movs	r0, #1
 802ad10:	4770      	bx	lr
 802ad12:	bf00      	nop

0802ad14 <__i2b>:
 802ad14:	b510      	push	{r4, lr}
 802ad16:	460c      	mov	r4, r1
 802ad18:	2101      	movs	r1, #1
 802ad1a:	f7ff ff3d 	bl	802ab98 <_Balloc>
 802ad1e:	2301      	movs	r3, #1
 802ad20:	6144      	str	r4, [r0, #20]
 802ad22:	6103      	str	r3, [r0, #16]
 802ad24:	bd10      	pop	{r4, pc}
 802ad26:	bf00      	nop

0802ad28 <__multiply>:
 802ad28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802ad2c:	690f      	ldr	r7, [r1, #16]
 802ad2e:	6915      	ldr	r5, [r2, #16]
 802ad30:	42af      	cmp	r7, r5
 802ad32:	b087      	sub	sp, #28
 802ad34:	460c      	mov	r4, r1
 802ad36:	4692      	mov	sl, r2
 802ad38:	da04      	bge.n	802ad44 <__multiply+0x1c>
 802ad3a:	463a      	mov	r2, r7
 802ad3c:	4654      	mov	r4, sl
 802ad3e:	462f      	mov	r7, r5
 802ad40:	468a      	mov	sl, r1
 802ad42:	4615      	mov	r5, r2
 802ad44:	68a3      	ldr	r3, [r4, #8]
 802ad46:	6861      	ldr	r1, [r4, #4]
 802ad48:	eb07 0b05 	add.w	fp, r7, r5
 802ad4c:	459b      	cmp	fp, r3
 802ad4e:	bfc8      	it	gt
 802ad50:	3101      	addgt	r1, #1
 802ad52:	f7ff ff21 	bl	802ab98 <_Balloc>
 802ad56:	f10b 0104 	add.w	r1, fp, #4
 802ad5a:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 802ad5e:	3304      	adds	r3, #4
 802ad60:	f100 0914 	add.w	r9, r0, #20
 802ad64:	4599      	cmp	r9, r3
 802ad66:	9002      	str	r0, [sp, #8]
 802ad68:	9104      	str	r1, [sp, #16]
 802ad6a:	9303      	str	r3, [sp, #12]
 802ad6c:	d206      	bcs.n	802ad7c <__multiply+0x54>
 802ad6e:	9903      	ldr	r1, [sp, #12]
 802ad70:	464b      	mov	r3, r9
 802ad72:	2200      	movs	r2, #0
 802ad74:	f843 2b04 	str.w	r2, [r3], #4
 802ad78:	4299      	cmp	r1, r3
 802ad7a:	d8fb      	bhi.n	802ad74 <__multiply+0x4c>
 802ad7c:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
 802ad80:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 802ad84:	f10a 0a14 	add.w	sl, sl, #20
 802ad88:	3514      	adds	r5, #20
 802ad8a:	3414      	adds	r4, #20
 802ad8c:	3714      	adds	r7, #20
 802ad8e:	45aa      	cmp	sl, r5
 802ad90:	9401      	str	r4, [sp, #4]
 802ad92:	d252      	bcs.n	802ae3a <__multiply+0x112>
 802ad94:	f8cd b014 	str.w	fp, [sp, #20]
 802ad98:	46ab      	mov	fp, r5
 802ad9a:	f85a 4b04 	ldr.w	r4, [sl], #4
 802ad9e:	b2a5      	uxth	r5, r4
 802ada0:	b1e5      	cbz	r5, 802addc <__multiply+0xb4>
 802ada2:	9a01      	ldr	r2, [sp, #4]
 802ada4:	464b      	mov	r3, r9
 802ada6:	2100      	movs	r1, #0
 802ada8:	f852 6b04 	ldr.w	r6, [r2], #4
 802adac:	681c      	ldr	r4, [r3, #0]
 802adae:	b2b0      	uxth	r0, r6
 802adb0:	fa11 f184 	uxtah	r1, r1, r4
 802adb4:	0c36      	lsrs	r6, r6, #16
 802adb6:	0c24      	lsrs	r4, r4, #16
 802adb8:	fb05 1000 	mla	r0, r5, r0, r1
 802adbc:	fb05 4106 	mla	r1, r5, r6, r4
 802adc0:	eb01 4110 	add.w	r1, r1, r0, lsr #16
 802adc4:	b280      	uxth	r0, r0
 802adc6:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 802adca:	0c09      	lsrs	r1, r1, #16
 802adcc:	4297      	cmp	r7, r2
 802adce:	461c      	mov	r4, r3
 802add0:	f843 0b04 	str.w	r0, [r3], #4
 802add4:	d8e8      	bhi.n	802ada8 <__multiply+0x80>
 802add6:	6061      	str	r1, [r4, #4]
 802add8:	f85a 4c04 	ldr.w	r4, [sl, #-4]
 802addc:	0c24      	lsrs	r4, r4, #16
 802adde:	d026      	beq.n	802ae2e <__multiply+0x106>
 802ade0:	f8d9 c000 	ldr.w	ip, [r9]
 802ade4:	9b01      	ldr	r3, [sp, #4]
 802ade6:	464e      	mov	r6, r9
 802ade8:	4661      	mov	r1, ip
 802adea:	464d      	mov	r5, r9
 802adec:	f04f 0800 	mov.w	r8, #0
 802adf0:	e000      	b.n	802adf4 <__multiply+0xcc>
 802adf2:	4615      	mov	r5, r2
 802adf4:	881a      	ldrh	r2, [r3, #0]
 802adf6:	eb08 4811 	add.w	r8, r8, r1, lsr #16
 802adfa:	fb04 8802 	mla	r8, r4, r2, r8
 802adfe:	fa1f fc8c 	uxth.w	ip, ip
 802ae02:	462a      	mov	r2, r5
 802ae04:	ea4c 4008 	orr.w	r0, ip, r8, lsl #16
 802ae08:	f842 0b04 	str.w	r0, [r2], #4
 802ae0c:	f853 cb04 	ldr.w	ip, [r3], #4
 802ae10:	f856 1f04 	ldr.w	r1, [r6, #4]!
 802ae14:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 802ae18:	b288      	uxth	r0, r1
 802ae1a:	fb04 0c0c 	mla	ip, r4, ip, r0
 802ae1e:	eb0c 4c18 	add.w	ip, ip, r8, lsr #16
 802ae22:	429f      	cmp	r7, r3
 802ae24:	ea4f 481c 	mov.w	r8, ip, lsr #16
 802ae28:	d8e3      	bhi.n	802adf2 <__multiply+0xca>
 802ae2a:	f8c5 c004 	str.w	ip, [r5, #4]
 802ae2e:	45d3      	cmp	fp, sl
 802ae30:	f109 0904 	add.w	r9, r9, #4
 802ae34:	d8b1      	bhi.n	802ad9a <__multiply+0x72>
 802ae36:	f8dd b014 	ldr.w	fp, [sp, #20]
 802ae3a:	f1bb 0f00 	cmp.w	fp, #0
 802ae3e:	dd0d      	ble.n	802ae5c <__multiply+0x134>
 802ae40:	9a04      	ldr	r2, [sp, #16]
 802ae42:	9902      	ldr	r1, [sp, #8]
 802ae44:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
 802ae48:	b943      	cbnz	r3, 802ae5c <__multiply+0x134>
 802ae4a:	9a03      	ldr	r2, [sp, #12]
 802ae4c:	1f13      	subs	r3, r2, #4
 802ae4e:	e002      	b.n	802ae56 <__multiply+0x12e>
 802ae50:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 802ae54:	b912      	cbnz	r2, 802ae5c <__multiply+0x134>
 802ae56:	f1bb 0b01 	subs.w	fp, fp, #1
 802ae5a:	d1f9      	bne.n	802ae50 <__multiply+0x128>
 802ae5c:	9b02      	ldr	r3, [sp, #8]
 802ae5e:	f8c3 b010 	str.w	fp, [r3, #16]
 802ae62:	4618      	mov	r0, r3
 802ae64:	b007      	add	sp, #28
 802ae66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802ae6a:	bf00      	nop

0802ae6c <__pow5mult>:
 802ae6c:	f012 0303 	ands.w	r3, r2, #3
 802ae70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ae74:	4615      	mov	r5, r2
 802ae76:	4604      	mov	r4, r0
 802ae78:	4688      	mov	r8, r1
 802ae7a:	d12d      	bne.n	802aed8 <__pow5mult+0x6c>
 802ae7c:	10ad      	asrs	r5, r5, #2
 802ae7e:	d01d      	beq.n	802aebc <__pow5mult+0x50>
 802ae80:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 802ae82:	b92f      	cbnz	r7, 802ae90 <__pow5mult+0x24>
 802ae84:	e031      	b.n	802aeea <__pow5mult+0x7e>
 802ae86:	106d      	asrs	r5, r5, #1
 802ae88:	d018      	beq.n	802aebc <__pow5mult+0x50>
 802ae8a:	683e      	ldr	r6, [r7, #0]
 802ae8c:	b1ce      	cbz	r6, 802aec2 <__pow5mult+0x56>
 802ae8e:	4637      	mov	r7, r6
 802ae90:	07e8      	lsls	r0, r5, #31
 802ae92:	d5f8      	bpl.n	802ae86 <__pow5mult+0x1a>
 802ae94:	4641      	mov	r1, r8
 802ae96:	463a      	mov	r2, r7
 802ae98:	4620      	mov	r0, r4
 802ae9a:	f7ff ff45 	bl	802ad28 <__multiply>
 802ae9e:	f1b8 0f00 	cmp.w	r8, #0
 802aea2:	d017      	beq.n	802aed4 <__pow5mult+0x68>
 802aea4:	f8d8 2004 	ldr.w	r2, [r8, #4]
 802aea8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 802aeaa:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 802aeae:	106d      	asrs	r5, r5, #1
 802aeb0:	f8c8 1000 	str.w	r1, [r8]
 802aeb4:	f843 8022 	str.w	r8, [r3, r2, lsl #2]
 802aeb8:	4680      	mov	r8, r0
 802aeba:	d1e6      	bne.n	802ae8a <__pow5mult+0x1e>
 802aebc:	4640      	mov	r0, r8
 802aebe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802aec2:	4639      	mov	r1, r7
 802aec4:	463a      	mov	r2, r7
 802aec6:	4620      	mov	r0, r4
 802aec8:	f7ff ff2e 	bl	802ad28 <__multiply>
 802aecc:	6038      	str	r0, [r7, #0]
 802aece:	6006      	str	r6, [r0, #0]
 802aed0:	4607      	mov	r7, r0
 802aed2:	e7dd      	b.n	802ae90 <__pow5mult+0x24>
 802aed4:	4680      	mov	r8, r0
 802aed6:	e7d6      	b.n	802ae86 <__pow5mult+0x1a>
 802aed8:	3b01      	subs	r3, #1
 802aeda:	4a09      	ldr	r2, [pc, #36]	; (802af00 <__pow5mult+0x94>)
 802aedc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 802aee0:	2300      	movs	r3, #0
 802aee2:	f7ff fe89 	bl	802abf8 <__multadd>
 802aee6:	4680      	mov	r8, r0
 802aee8:	e7c8      	b.n	802ae7c <__pow5mult+0x10>
 802aeea:	4620      	mov	r0, r4
 802aeec:	f240 2171 	movw	r1, #625	; 0x271
 802aef0:	f7ff ff10 	bl	802ad14 <__i2b>
 802aef4:	2300      	movs	r3, #0
 802aef6:	64a0      	str	r0, [r4, #72]	; 0x48
 802aef8:	4607      	mov	r7, r0
 802aefa:	6003      	str	r3, [r0, #0]
 802aefc:	e7c8      	b.n	802ae90 <__pow5mult+0x24>
 802aefe:	bf00      	nop
 802af00:	08033260 	.word	0x08033260

0802af04 <__lshift>:
 802af04:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802af08:	4691      	mov	r9, r2
 802af0a:	690a      	ldr	r2, [r1, #16]
 802af0c:	688b      	ldr	r3, [r1, #8]
 802af0e:	ea4f 1769 	mov.w	r7, r9, asr #5
 802af12:	eb07 0b02 	add.w	fp, r7, r2
 802af16:	f10b 0501 	add.w	r5, fp, #1
 802af1a:	429d      	cmp	r5, r3
 802af1c:	460c      	mov	r4, r1
 802af1e:	4606      	mov	r6, r0
 802af20:	6849      	ldr	r1, [r1, #4]
 802af22:	dd03      	ble.n	802af2c <__lshift+0x28>
 802af24:	005b      	lsls	r3, r3, #1
 802af26:	3101      	adds	r1, #1
 802af28:	429d      	cmp	r5, r3
 802af2a:	dcfb      	bgt.n	802af24 <__lshift+0x20>
 802af2c:	4630      	mov	r0, r6
 802af2e:	f7ff fe33 	bl	802ab98 <_Balloc>
 802af32:	2f00      	cmp	r7, #0
 802af34:	f100 0314 	add.w	r3, r0, #20
 802af38:	dd09      	ble.n	802af4e <__lshift+0x4a>
 802af3a:	2200      	movs	r2, #0
 802af3c:	4611      	mov	r1, r2
 802af3e:	3201      	adds	r2, #1
 802af40:	42ba      	cmp	r2, r7
 802af42:	f843 1b04 	str.w	r1, [r3], #4
 802af46:	d1fa      	bne.n	802af3e <__lshift+0x3a>
 802af48:	eb00 0382 	add.w	r3, r0, r2, lsl #2
 802af4c:	3314      	adds	r3, #20
 802af4e:	6922      	ldr	r2, [r4, #16]
 802af50:	f019 091f 	ands.w	r9, r9, #31
 802af54:	eb04 0c82 	add.w	ip, r4, r2, lsl #2
 802af58:	f104 0114 	add.w	r1, r4, #20
 802af5c:	f10c 0c14 	add.w	ip, ip, #20
 802af60:	d022      	beq.n	802afa8 <__lshift+0xa4>
 802af62:	f1c9 0a20 	rsb	sl, r9, #32
 802af66:	2200      	movs	r2, #0
 802af68:	e000      	b.n	802af6c <__lshift+0x68>
 802af6a:	463b      	mov	r3, r7
 802af6c:	f8d1 8000 	ldr.w	r8, [r1]
 802af70:	461f      	mov	r7, r3
 802af72:	fa08 f809 	lsl.w	r8, r8, r9
 802af76:	ea48 0202 	orr.w	r2, r8, r2
 802af7a:	f847 2b04 	str.w	r2, [r7], #4
 802af7e:	f851 2b04 	ldr.w	r2, [r1], #4
 802af82:	458c      	cmp	ip, r1
 802af84:	fa22 f20a 	lsr.w	r2, r2, sl
 802af88:	d8ef      	bhi.n	802af6a <__lshift+0x66>
 802af8a:	605a      	str	r2, [r3, #4]
 802af8c:	b10a      	cbz	r2, 802af92 <__lshift+0x8e>
 802af8e:	f10b 0502 	add.w	r5, fp, #2
 802af92:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 802af94:	6862      	ldr	r2, [r4, #4]
 802af96:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 802af9a:	3d01      	subs	r5, #1
 802af9c:	6105      	str	r5, [r0, #16]
 802af9e:	6021      	str	r1, [r4, #0]
 802afa0:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 802afa4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802afa8:	f851 2b04 	ldr.w	r2, [r1], #4
 802afac:	458c      	cmp	ip, r1
 802afae:	f843 2b04 	str.w	r2, [r3], #4
 802afb2:	d9ee      	bls.n	802af92 <__lshift+0x8e>
 802afb4:	f851 2b04 	ldr.w	r2, [r1], #4
 802afb8:	458c      	cmp	ip, r1
 802afba:	f843 2b04 	str.w	r2, [r3], #4
 802afbe:	d8f3      	bhi.n	802afa8 <__lshift+0xa4>
 802afc0:	e7e7      	b.n	802af92 <__lshift+0x8e>
 802afc2:	bf00      	nop

0802afc4 <__mcmp>:
 802afc4:	4603      	mov	r3, r0
 802afc6:	690a      	ldr	r2, [r1, #16]
 802afc8:	6900      	ldr	r0, [r0, #16]
 802afca:	1a80      	subs	r0, r0, r2
 802afcc:	b430      	push	{r4, r5}
 802afce:	d10f      	bne.n	802aff0 <__mcmp+0x2c>
 802afd0:	3204      	adds	r2, #4
 802afd2:	0094      	lsls	r4, r2, #2
 802afd4:	191a      	adds	r2, r3, r4
 802afd6:	1909      	adds	r1, r1, r4
 802afd8:	3314      	adds	r3, #20
 802afda:	3204      	adds	r2, #4
 802afdc:	3104      	adds	r1, #4
 802afde:	f852 5c04 	ldr.w	r5, [r2, #-4]
 802afe2:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 802afe6:	3a04      	subs	r2, #4
 802afe8:	42a5      	cmp	r5, r4
 802afea:	d103      	bne.n	802aff4 <__mcmp+0x30>
 802afec:	4293      	cmp	r3, r2
 802afee:	d3f6      	bcc.n	802afde <__mcmp+0x1a>
 802aff0:	bc30      	pop	{r4, r5}
 802aff2:	4770      	bx	lr
 802aff4:	d301      	bcc.n	802affa <__mcmp+0x36>
 802aff6:	2001      	movs	r0, #1
 802aff8:	e7fa      	b.n	802aff0 <__mcmp+0x2c>
 802affa:	f04f 30ff 	mov.w	r0, #4294967295
 802affe:	e7f7      	b.n	802aff0 <__mcmp+0x2c>

0802b000 <__mdiff>:
 802b000:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802b004:	460c      	mov	r4, r1
 802b006:	4607      	mov	r7, r0
 802b008:	4611      	mov	r1, r2
 802b00a:	4620      	mov	r0, r4
 802b00c:	4615      	mov	r5, r2
 802b00e:	f7ff ffd9 	bl	802afc4 <__mcmp>
 802b012:	2800      	cmp	r0, #0
 802b014:	4606      	mov	r6, r0
 802b016:	d056      	beq.n	802b0c6 <__mdiff+0xc6>
 802b018:	db50      	blt.n	802b0bc <__mdiff+0xbc>
 802b01a:	2600      	movs	r6, #0
 802b01c:	6861      	ldr	r1, [r4, #4]
 802b01e:	4638      	mov	r0, r7
 802b020:	f7ff fdba 	bl	802ab98 <_Balloc>
 802b024:	6927      	ldr	r7, [r4, #16]
 802b026:	692b      	ldr	r3, [r5, #16]
 802b028:	60c6      	str	r6, [r0, #12]
 802b02a:	eb04 0c87 	add.w	ip, r4, r7, lsl #2
 802b02e:	eb05 0883 	add.w	r8, r5, r3, lsl #2
 802b032:	f10c 0c14 	add.w	ip, ip, #20
 802b036:	f108 0814 	add.w	r8, r8, #20
 802b03a:	3414      	adds	r4, #20
 802b03c:	3514      	adds	r5, #20
 802b03e:	f100 0914 	add.w	r9, r0, #20
 802b042:	2600      	movs	r6, #0
 802b044:	f854 3b04 	ldr.w	r3, [r4], #4
 802b048:	f855 2b04 	ldr.w	r2, [r5], #4
 802b04c:	fa16 f183 	uxtah	r1, r6, r3
 802b050:	fa1f fa82 	uxth.w	sl, r2
 802b054:	0c12      	lsrs	r2, r2, #16
 802b056:	ebc2 4613 	rsb	r6, r2, r3, lsr #16
 802b05a:	ebca 0101 	rsb	r1, sl, r1
 802b05e:	eb06 4621 	add.w	r6, r6, r1, asr #16
 802b062:	464b      	mov	r3, r9
 802b064:	b289      	uxth	r1, r1
 802b066:	ea41 4106 	orr.w	r1, r1, r6, lsl #16
 802b06a:	f843 1b04 	str.w	r1, [r3], #4
 802b06e:	1436      	asrs	r6, r6, #16
 802b070:	45a8      	cmp	r8, r5
 802b072:	4622      	mov	r2, r4
 802b074:	4699      	mov	r9, r3
 802b076:	d8e5      	bhi.n	802b044 <__mdiff+0x44>
 802b078:	45a4      	cmp	ip, r4
 802b07a:	4698      	mov	r8, r3
 802b07c:	d914      	bls.n	802b0a8 <__mdiff+0xa8>
 802b07e:	f852 5b04 	ldr.w	r5, [r2], #4
 802b082:	fa16 f685 	uxtah	r6, r6, r5
 802b086:	0c2d      	lsrs	r5, r5, #16
 802b088:	eb05 4526 	add.w	r5, r5, r6, asr #16
 802b08c:	b2b6      	uxth	r6, r6
 802b08e:	ea46 4105 	orr.w	r1, r6, r5, lsl #16
 802b092:	142e      	asrs	r6, r5, #16
 802b094:	4594      	cmp	ip, r2
 802b096:	f843 1b04 	str.w	r1, [r3], #4
 802b09a:	d8f0      	bhi.n	802b07e <__mdiff+0x7e>
 802b09c:	43e3      	mvns	r3, r4
 802b09e:	4463      	add	r3, ip
 802b0a0:	f023 0303 	bic.w	r3, r3, #3
 802b0a4:	3304      	adds	r3, #4
 802b0a6:	4443      	add	r3, r8
 802b0a8:	b929      	cbnz	r1, 802b0b6 <__mdiff+0xb6>
 802b0aa:	3b04      	subs	r3, #4
 802b0ac:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 802b0b0:	3f01      	subs	r7, #1
 802b0b2:	2a00      	cmp	r2, #0
 802b0b4:	d0fa      	beq.n	802b0ac <__mdiff+0xac>
 802b0b6:	6107      	str	r7, [r0, #16]
 802b0b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802b0bc:	4623      	mov	r3, r4
 802b0be:	2601      	movs	r6, #1
 802b0c0:	462c      	mov	r4, r5
 802b0c2:	461d      	mov	r5, r3
 802b0c4:	e7aa      	b.n	802b01c <__mdiff+0x1c>
 802b0c6:	4638      	mov	r0, r7
 802b0c8:	4631      	mov	r1, r6
 802b0ca:	f7ff fd65 	bl	802ab98 <_Balloc>
 802b0ce:	2301      	movs	r3, #1
 802b0d0:	6103      	str	r3, [r0, #16]
 802b0d2:	6146      	str	r6, [r0, #20]
 802b0d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0802b0d8 <__d2b>:
 802b0d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802b0dc:	b083      	sub	sp, #12
 802b0de:	2101      	movs	r1, #1
 802b0e0:	461d      	mov	r5, r3
 802b0e2:	4614      	mov	r4, r2
 802b0e4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 802b0e6:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 802b0e8:	f7ff fd56 	bl	802ab98 <_Balloc>
 802b0ec:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
 802b0f0:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 802b0f4:	f3c5 590a 	ubfx	r9, r5, #20, #11
 802b0f8:	4680      	mov	r8, r0
 802b0fa:	9301      	str	r3, [sp, #4]
 802b0fc:	f1b9 0f00 	cmp.w	r9, #0
 802b100:	d002      	beq.n	802b108 <__d2b+0x30>
 802b102:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 802b106:	9301      	str	r3, [sp, #4]
 802b108:	2c00      	cmp	r4, #0
 802b10a:	d026      	beq.n	802b15a <__d2b+0x82>
 802b10c:	a802      	add	r0, sp, #8
 802b10e:	f840 4d08 	str.w	r4, [r0, #-8]!
 802b112:	4668      	mov	r0, sp
 802b114:	f7ff fdd0 	bl	802acb8 <__lo0bits>
 802b118:	9b01      	ldr	r3, [sp, #4]
 802b11a:	2800      	cmp	r0, #0
 802b11c:	d133      	bne.n	802b186 <__d2b+0xae>
 802b11e:	9a00      	ldr	r2, [sp, #0]
 802b120:	f8c8 2014 	str.w	r2, [r8, #20]
 802b124:	2b00      	cmp	r3, #0
 802b126:	bf0c      	ite	eq
 802b128:	2401      	moveq	r4, #1
 802b12a:	2402      	movne	r4, #2
 802b12c:	f8c8 3018 	str.w	r3, [r8, #24]
 802b130:	f8c8 4010 	str.w	r4, [r8, #16]
 802b134:	f1b9 0f00 	cmp.w	r9, #0
 802b138:	d11c      	bne.n	802b174 <__d2b+0x9c>
 802b13a:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 802b13e:	f5a0 6386 	sub.w	r3, r0, #1072	; 0x430
 802b142:	3b02      	subs	r3, #2
 802b144:	6910      	ldr	r0, [r2, #16]
 802b146:	603b      	str	r3, [r7, #0]
 802b148:	f7ff fd98 	bl	802ac7c <__hi0bits>
 802b14c:	ebc0 1444 	rsb	r4, r0, r4, lsl #5
 802b150:	6034      	str	r4, [r6, #0]
 802b152:	4640      	mov	r0, r8
 802b154:	b003      	add	sp, #12
 802b156:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802b15a:	a801      	add	r0, sp, #4
 802b15c:	f7ff fdac 	bl	802acb8 <__lo0bits>
 802b160:	9b01      	ldr	r3, [sp, #4]
 802b162:	2401      	movs	r4, #1
 802b164:	f8c8 3014 	str.w	r3, [r8, #20]
 802b168:	f8c8 4010 	str.w	r4, [r8, #16]
 802b16c:	3020      	adds	r0, #32
 802b16e:	f1b9 0f00 	cmp.w	r9, #0
 802b172:	d0e2      	beq.n	802b13a <__d2b+0x62>
 802b174:	f5a9 6386 	sub.w	r3, r9, #1072	; 0x430
 802b178:	3b03      	subs	r3, #3
 802b17a:	181b      	adds	r3, r3, r0
 802b17c:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 802b180:	603b      	str	r3, [r7, #0]
 802b182:	6030      	str	r0, [r6, #0]
 802b184:	e7e5      	b.n	802b152 <__d2b+0x7a>
 802b186:	f1c0 0220 	rsb	r2, r0, #32
 802b18a:	9900      	ldr	r1, [sp, #0]
 802b18c:	fa03 f202 	lsl.w	r2, r3, r2
 802b190:	430a      	orrs	r2, r1
 802b192:	fa23 f300 	lsr.w	r3, r3, r0
 802b196:	f8c8 2014 	str.w	r2, [r8, #20]
 802b19a:	9301      	str	r3, [sp, #4]
 802b19c:	e7c2      	b.n	802b124 <__d2b+0x4c>
 802b19e:	bf00      	nop

0802b1a0 <_realloc_r>:
 802b1a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802b1a4:	460c      	mov	r4, r1
 802b1a6:	b083      	sub	sp, #12
 802b1a8:	4606      	mov	r6, r0
 802b1aa:	4693      	mov	fp, r2
 802b1ac:	2900      	cmp	r1, #0
 802b1ae:	f000 80c4 	beq.w	802b33a <_realloc_r+0x19a>
 802b1b2:	f10b 050b 	add.w	r5, fp, #11
 802b1b6:	f7f7 fa55 	bl	8022664 <__malloc_lock>
 802b1ba:	2d16      	cmp	r5, #22
 802b1bc:	f854 2c04 	ldr.w	r2, [r4, #-4]
 802b1c0:	d852      	bhi.n	802b268 <_realloc_r+0xc8>
 802b1c2:	2110      	movs	r1, #16
 802b1c4:	460d      	mov	r5, r1
 802b1c6:	45ab      	cmp	fp, r5
 802b1c8:	d853      	bhi.n	802b272 <_realloc_r+0xd2>
 802b1ca:	f022 0903 	bic.w	r9, r2, #3
 802b1ce:	4589      	cmp	r9, r1
 802b1d0:	f1a4 0a08 	sub.w	sl, r4, #8
 802b1d4:	da51      	bge.n	802b27a <_realloc_r+0xda>
 802b1d6:	4b8c      	ldr	r3, [pc, #560]	; (802b408 <_realloc_r+0x268>)
 802b1d8:	f8d3 c008 	ldr.w	ip, [r3, #8]
 802b1dc:	eb0a 0009 	add.w	r0, sl, r9
 802b1e0:	4584      	cmp	ip, r0
 802b1e2:	f000 80b0 	beq.w	802b346 <_realloc_r+0x1a6>
 802b1e6:	6847      	ldr	r7, [r0, #4]
 802b1e8:	f027 0e01 	bic.w	lr, r7, #1
 802b1ec:	4486      	add	lr, r0
 802b1ee:	f8de e004 	ldr.w	lr, [lr, #4]
 802b1f2:	f01e 0f01 	tst.w	lr, #1
 802b1f6:	d057      	beq.n	802b2a8 <_realloc_r+0x108>
 802b1f8:	f04f 0e00 	mov.w	lr, #0
 802b1fc:	4670      	mov	r0, lr
 802b1fe:	07d2      	lsls	r2, r2, #31
 802b200:	d475      	bmi.n	802b2ee <_realloc_r+0x14e>
 802b202:	f854 2c08 	ldr.w	r2, [r4, #-8]
 802b206:	ebc2 080a 	rsb	r8, r2, sl
 802b20a:	f8d8 2004 	ldr.w	r2, [r8, #4]
 802b20e:	f022 0203 	bic.w	r2, r2, #3
 802b212:	2800      	cmp	r0, #0
 802b214:	d067      	beq.n	802b2e6 <_realloc_r+0x146>
 802b216:	4560      	cmp	r0, ip
 802b218:	eb02 0c09 	add.w	ip, r2, r9
 802b21c:	f000 80f6 	beq.w	802b40c <_realloc_r+0x26c>
 802b220:	eb0e 070c 	add.w	r7, lr, ip
 802b224:	428f      	cmp	r7, r1
 802b226:	db60      	blt.n	802b2ea <_realloc_r+0x14a>
 802b228:	68c3      	ldr	r3, [r0, #12]
 802b22a:	6882      	ldr	r2, [r0, #8]
 802b22c:	46c2      	mov	sl, r8
 802b22e:	609a      	str	r2, [r3, #8]
 802b230:	60d3      	str	r3, [r2, #12]
 802b232:	f8d8 300c 	ldr.w	r3, [r8, #12]
 802b236:	f85a 1f08 	ldr.w	r1, [sl, #8]!
 802b23a:	f1a9 0204 	sub.w	r2, r9, #4
 802b23e:	2a24      	cmp	r2, #36	; 0x24
 802b240:	60cb      	str	r3, [r1, #12]
 802b242:	6099      	str	r1, [r3, #8]
 802b244:	f200 812e 	bhi.w	802b4a4 <_realloc_r+0x304>
 802b248:	2a13      	cmp	r2, #19
 802b24a:	f240 80ba 	bls.w	802b3c2 <_realloc_r+0x222>
 802b24e:	6823      	ldr	r3, [r4, #0]
 802b250:	f8c8 3008 	str.w	r3, [r8, #8]
 802b254:	6863      	ldr	r3, [r4, #4]
 802b256:	2a1b      	cmp	r2, #27
 802b258:	f8c8 300c 	str.w	r3, [r8, #12]
 802b25c:	f200 813b 	bhi.w	802b4d6 <_realloc_r+0x336>
 802b260:	f108 0310 	add.w	r3, r8, #16
 802b264:	3408      	adds	r4, #8
 802b266:	e0ad      	b.n	802b3c4 <_realloc_r+0x224>
 802b268:	f025 0507 	bic.w	r5, r5, #7
 802b26c:	2d00      	cmp	r5, #0
 802b26e:	4629      	mov	r1, r5
 802b270:	daa9      	bge.n	802b1c6 <_realloc_r+0x26>
 802b272:	230c      	movs	r3, #12
 802b274:	6033      	str	r3, [r6, #0]
 802b276:	2700      	movs	r7, #0
 802b278:	e012      	b.n	802b2a0 <_realloc_r+0x100>
 802b27a:	464f      	mov	r7, r9
 802b27c:	1b7b      	subs	r3, r7, r5
 802b27e:	2b0f      	cmp	r3, #15
 802b280:	d81d      	bhi.n	802b2be <_realloc_r+0x11e>
 802b282:	f002 0201 	and.w	r2, r2, #1
 802b286:	eb0a 0307 	add.w	r3, sl, r7
 802b28a:	4317      	orrs	r7, r2
 802b28c:	f8ca 7004 	str.w	r7, [sl, #4]
 802b290:	685a      	ldr	r2, [r3, #4]
 802b292:	f042 0201 	orr.w	r2, r2, #1
 802b296:	605a      	str	r2, [r3, #4]
 802b298:	4630      	mov	r0, r6
 802b29a:	f7f7 f9ed 	bl	8022678 <__malloc_unlock>
 802b29e:	4627      	mov	r7, r4
 802b2a0:	4638      	mov	r0, r7
 802b2a2:	b003      	add	sp, #12
 802b2a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802b2a8:	f027 0e03 	bic.w	lr, r7, #3
 802b2ac:	eb0e 0709 	add.w	r7, lr, r9
 802b2b0:	428f      	cmp	r7, r1
 802b2b2:	dba4      	blt.n	802b1fe <_realloc_r+0x5e>
 802b2b4:	68c3      	ldr	r3, [r0, #12]
 802b2b6:	6881      	ldr	r1, [r0, #8]
 802b2b8:	60cb      	str	r3, [r1, #12]
 802b2ba:	6099      	str	r1, [r3, #8]
 802b2bc:	e7de      	b.n	802b27c <_realloc_r+0xdc>
 802b2be:	eb0a 0105 	add.w	r1, sl, r5
 802b2c2:	f002 0201 	and.w	r2, r2, #1
 802b2c6:	18c8      	adds	r0, r1, r3
 802b2c8:	4315      	orrs	r5, r2
 802b2ca:	f043 0301 	orr.w	r3, r3, #1
 802b2ce:	f8ca 5004 	str.w	r5, [sl, #4]
 802b2d2:	604b      	str	r3, [r1, #4]
 802b2d4:	6843      	ldr	r3, [r0, #4]
 802b2d6:	f043 0301 	orr.w	r3, r3, #1
 802b2da:	6043      	str	r3, [r0, #4]
 802b2dc:	3108      	adds	r1, #8
 802b2de:	4630      	mov	r0, r6
 802b2e0:	f7ff f91e 	bl	802a520 <_free_r>
 802b2e4:	e7d8      	b.n	802b298 <_realloc_r+0xf8>
 802b2e6:	eb02 0c09 	add.w	ip, r2, r9
 802b2ea:	458c      	cmp	ip, r1
 802b2ec:	da37      	bge.n	802b35e <_realloc_r+0x1be>
 802b2ee:	4630      	mov	r0, r6
 802b2f0:	4659      	mov	r1, fp
 802b2f2:	f7f9 fd71 	bl	8024dd8 <_malloc_r>
 802b2f6:	4607      	mov	r7, r0
 802b2f8:	b1d8      	cbz	r0, 802b332 <_realloc_r+0x192>
 802b2fa:	f854 2c04 	ldr.w	r2, [r4, #-4]
 802b2fe:	f022 0301 	bic.w	r3, r2, #1
 802b302:	f1a0 0108 	sub.w	r1, r0, #8
 802b306:	4453      	add	r3, sl
 802b308:	4299      	cmp	r1, r3
 802b30a:	f000 80c5 	beq.w	802b498 <_realloc_r+0x2f8>
 802b30e:	f1a9 0204 	sub.w	r2, r9, #4
 802b312:	2a24      	cmp	r2, #36	; 0x24
 802b314:	d874      	bhi.n	802b400 <_realloc_r+0x260>
 802b316:	2a13      	cmp	r2, #19
 802b318:	d848      	bhi.n	802b3ac <_realloc_r+0x20c>
 802b31a:	4603      	mov	r3, r0
 802b31c:	4622      	mov	r2, r4
 802b31e:	6811      	ldr	r1, [r2, #0]
 802b320:	6019      	str	r1, [r3, #0]
 802b322:	6851      	ldr	r1, [r2, #4]
 802b324:	6059      	str	r1, [r3, #4]
 802b326:	6892      	ldr	r2, [r2, #8]
 802b328:	609a      	str	r2, [r3, #8]
 802b32a:	4630      	mov	r0, r6
 802b32c:	4621      	mov	r1, r4
 802b32e:	f7ff f8f7 	bl	802a520 <_free_r>
 802b332:	4630      	mov	r0, r6
 802b334:	f7f7 f9a0 	bl	8022678 <__malloc_unlock>
 802b338:	e7b2      	b.n	802b2a0 <_realloc_r+0x100>
 802b33a:	4611      	mov	r1, r2
 802b33c:	b003      	add	sp, #12
 802b33e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802b342:	f7f9 bd49 	b.w	8024dd8 <_malloc_r>
 802b346:	f8dc 0004 	ldr.w	r0, [ip, #4]
 802b34a:	f020 0e03 	bic.w	lr, r0, #3
 802b34e:	eb0e 0009 	add.w	r0, lr, r9
 802b352:	f105 0710 	add.w	r7, r5, #16
 802b356:	42b8      	cmp	r0, r7
 802b358:	da3f      	bge.n	802b3da <_realloc_r+0x23a>
 802b35a:	4660      	mov	r0, ip
 802b35c:	e74f      	b.n	802b1fe <_realloc_r+0x5e>
 802b35e:	4647      	mov	r7, r8
 802b360:	f8d8 300c 	ldr.w	r3, [r8, #12]
 802b364:	f857 1f08 	ldr.w	r1, [r7, #8]!
 802b368:	f1a9 0204 	sub.w	r2, r9, #4
 802b36c:	2a24      	cmp	r2, #36	; 0x24
 802b36e:	60cb      	str	r3, [r1, #12]
 802b370:	6099      	str	r1, [r3, #8]
 802b372:	f200 80a2 	bhi.w	802b4ba <_realloc_r+0x31a>
 802b376:	2a13      	cmp	r2, #19
 802b378:	f240 809d 	bls.w	802b4b6 <_realloc_r+0x316>
 802b37c:	6823      	ldr	r3, [r4, #0]
 802b37e:	f8c8 3008 	str.w	r3, [r8, #8]
 802b382:	6863      	ldr	r3, [r4, #4]
 802b384:	2a1b      	cmp	r2, #27
 802b386:	f8c8 300c 	str.w	r3, [r8, #12]
 802b38a:	f200 80b9 	bhi.w	802b500 <_realloc_r+0x360>
 802b38e:	f108 0310 	add.w	r3, r8, #16
 802b392:	3408      	adds	r4, #8
 802b394:	6822      	ldr	r2, [r4, #0]
 802b396:	601a      	str	r2, [r3, #0]
 802b398:	6862      	ldr	r2, [r4, #4]
 802b39a:	605a      	str	r2, [r3, #4]
 802b39c:	68a2      	ldr	r2, [r4, #8]
 802b39e:	609a      	str	r2, [r3, #8]
 802b3a0:	463c      	mov	r4, r7
 802b3a2:	f8d8 2004 	ldr.w	r2, [r8, #4]
 802b3a6:	4667      	mov	r7, ip
 802b3a8:	46c2      	mov	sl, r8
 802b3aa:	e767      	b.n	802b27c <_realloc_r+0xdc>
 802b3ac:	6823      	ldr	r3, [r4, #0]
 802b3ae:	6003      	str	r3, [r0, #0]
 802b3b0:	6863      	ldr	r3, [r4, #4]
 802b3b2:	2a1b      	cmp	r2, #27
 802b3b4:	6043      	str	r3, [r0, #4]
 802b3b6:	d864      	bhi.n	802b482 <_realloc_r+0x2e2>
 802b3b8:	f100 0308 	add.w	r3, r0, #8
 802b3bc:	f104 0208 	add.w	r2, r4, #8
 802b3c0:	e7ad      	b.n	802b31e <_realloc_r+0x17e>
 802b3c2:	4653      	mov	r3, sl
 802b3c4:	6822      	ldr	r2, [r4, #0]
 802b3c6:	601a      	str	r2, [r3, #0]
 802b3c8:	6862      	ldr	r2, [r4, #4]
 802b3ca:	605a      	str	r2, [r3, #4]
 802b3cc:	68a2      	ldr	r2, [r4, #8]
 802b3ce:	609a      	str	r2, [r3, #8]
 802b3d0:	4654      	mov	r4, sl
 802b3d2:	f8d8 2004 	ldr.w	r2, [r8, #4]
 802b3d6:	46c2      	mov	sl, r8
 802b3d8:	e750      	b.n	802b27c <_realloc_r+0xdc>
 802b3da:	eb0a 0205 	add.w	r2, sl, r5
 802b3de:	1b41      	subs	r1, r0, r5
 802b3e0:	f041 0101 	orr.w	r1, r1, #1
 802b3e4:	6051      	str	r1, [r2, #4]
 802b3e6:	f854 1c04 	ldr.w	r1, [r4, #-4]
 802b3ea:	609a      	str	r2, [r3, #8]
 802b3ec:	f001 0301 	and.w	r3, r1, #1
 802b3f0:	431d      	orrs	r5, r3
 802b3f2:	f844 5c04 	str.w	r5, [r4, #-4]
 802b3f6:	4630      	mov	r0, r6
 802b3f8:	f7f7 f93e 	bl	8022678 <__malloc_unlock>
 802b3fc:	4627      	mov	r7, r4
 802b3fe:	e74f      	b.n	802b2a0 <_realloc_r+0x100>
 802b400:	4621      	mov	r1, r4
 802b402:	f7f9 ffcb 	bl	802539c <memmove>
 802b406:	e790      	b.n	802b32a <_realloc_r+0x18a>
 802b408:	20000514 	.word	0x20000514
 802b40c:	44e6      	add	lr, ip
 802b40e:	f105 0210 	add.w	r2, r5, #16
 802b412:	4596      	cmp	lr, r2
 802b414:	f8cd e004 	str.w	lr, [sp, #4]
 802b418:	f6ff af67 	blt.w	802b2ea <_realloc_r+0x14a>
 802b41c:	4647      	mov	r7, r8
 802b41e:	f8d8 100c 	ldr.w	r1, [r8, #12]
 802b422:	f857 0f08 	ldr.w	r0, [r7, #8]!
 802b426:	f1a9 0204 	sub.w	r2, r9, #4
 802b42a:	2a24      	cmp	r2, #36	; 0x24
 802b42c:	60c1      	str	r1, [r0, #12]
 802b42e:	6088      	str	r0, [r1, #8]
 802b430:	f200 8088 	bhi.w	802b544 <_realloc_r+0x3a4>
 802b434:	2a13      	cmp	r2, #19
 802b436:	d979      	bls.n	802b52c <_realloc_r+0x38c>
 802b438:	6821      	ldr	r1, [r4, #0]
 802b43a:	f8c8 1008 	str.w	r1, [r8, #8]
 802b43e:	6861      	ldr	r1, [r4, #4]
 802b440:	2a1b      	cmp	r2, #27
 802b442:	f8c8 100c 	str.w	r1, [r8, #12]
 802b446:	f200 8084 	bhi.w	802b552 <_realloc_r+0x3b2>
 802b44a:	f108 0210 	add.w	r2, r8, #16
 802b44e:	3408      	adds	r4, #8
 802b450:	6821      	ldr	r1, [r4, #0]
 802b452:	6011      	str	r1, [r2, #0]
 802b454:	6861      	ldr	r1, [r4, #4]
 802b456:	6051      	str	r1, [r2, #4]
 802b458:	68a1      	ldr	r1, [r4, #8]
 802b45a:	6091      	str	r1, [r2, #8]
 802b45c:	9801      	ldr	r0, [sp, #4]
 802b45e:	eb08 0205 	add.w	r2, r8, r5
 802b462:	1b41      	subs	r1, r0, r5
 802b464:	f041 0101 	orr.w	r1, r1, #1
 802b468:	6051      	str	r1, [r2, #4]
 802b46a:	f8d8 1004 	ldr.w	r1, [r8, #4]
 802b46e:	609a      	str	r2, [r3, #8]
 802b470:	f001 0301 	and.w	r3, r1, #1
 802b474:	431d      	orrs	r5, r3
 802b476:	f8c8 5004 	str.w	r5, [r8, #4]
 802b47a:	4630      	mov	r0, r6
 802b47c:	f7f7 f8fc 	bl	8022678 <__malloc_unlock>
 802b480:	e70e      	b.n	802b2a0 <_realloc_r+0x100>
 802b482:	68a3      	ldr	r3, [r4, #8]
 802b484:	6083      	str	r3, [r0, #8]
 802b486:	68e3      	ldr	r3, [r4, #12]
 802b488:	2a24      	cmp	r2, #36	; 0x24
 802b48a:	60c3      	str	r3, [r0, #12]
 802b48c:	d02f      	beq.n	802b4ee <_realloc_r+0x34e>
 802b48e:	f100 0310 	add.w	r3, r0, #16
 802b492:	f104 0210 	add.w	r2, r4, #16
 802b496:	e742      	b.n	802b31e <_realloc_r+0x17e>
 802b498:	f850 7c04 	ldr.w	r7, [r0, #-4]
 802b49c:	f027 0703 	bic.w	r7, r7, #3
 802b4a0:	444f      	add	r7, r9
 802b4a2:	e6eb      	b.n	802b27c <_realloc_r+0xdc>
 802b4a4:	4621      	mov	r1, r4
 802b4a6:	4650      	mov	r0, sl
 802b4a8:	f7f9 ff78 	bl	802539c <memmove>
 802b4ac:	4654      	mov	r4, sl
 802b4ae:	f8d8 2004 	ldr.w	r2, [r8, #4]
 802b4b2:	46c2      	mov	sl, r8
 802b4b4:	e6e2      	b.n	802b27c <_realloc_r+0xdc>
 802b4b6:	463b      	mov	r3, r7
 802b4b8:	e76c      	b.n	802b394 <_realloc_r+0x1f4>
 802b4ba:	4621      	mov	r1, r4
 802b4bc:	4638      	mov	r0, r7
 802b4be:	f8cd c000 	str.w	ip, [sp]
 802b4c2:	f7f9 ff6b 	bl	802539c <memmove>
 802b4c6:	f8dd c000 	ldr.w	ip, [sp]
 802b4ca:	f8d8 2004 	ldr.w	r2, [r8, #4]
 802b4ce:	463c      	mov	r4, r7
 802b4d0:	46c2      	mov	sl, r8
 802b4d2:	4667      	mov	r7, ip
 802b4d4:	e6d2      	b.n	802b27c <_realloc_r+0xdc>
 802b4d6:	68a3      	ldr	r3, [r4, #8]
 802b4d8:	f8c8 3010 	str.w	r3, [r8, #16]
 802b4dc:	68e3      	ldr	r3, [r4, #12]
 802b4de:	2a24      	cmp	r2, #36	; 0x24
 802b4e0:	f8c8 3014 	str.w	r3, [r8, #20]
 802b4e4:	d018      	beq.n	802b518 <_realloc_r+0x378>
 802b4e6:	f108 0318 	add.w	r3, r8, #24
 802b4ea:	3410      	adds	r4, #16
 802b4ec:	e76a      	b.n	802b3c4 <_realloc_r+0x224>
 802b4ee:	6923      	ldr	r3, [r4, #16]
 802b4f0:	6103      	str	r3, [r0, #16]
 802b4f2:	6962      	ldr	r2, [r4, #20]
 802b4f4:	f100 0318 	add.w	r3, r0, #24
 802b4f8:	6142      	str	r2, [r0, #20]
 802b4fa:	f104 0218 	add.w	r2, r4, #24
 802b4fe:	e70e      	b.n	802b31e <_realloc_r+0x17e>
 802b500:	68a3      	ldr	r3, [r4, #8]
 802b502:	f8c8 3010 	str.w	r3, [r8, #16]
 802b506:	68e3      	ldr	r3, [r4, #12]
 802b508:	2a24      	cmp	r2, #36	; 0x24
 802b50a:	f8c8 3014 	str.w	r3, [r8, #20]
 802b50e:	d00f      	beq.n	802b530 <_realloc_r+0x390>
 802b510:	f108 0318 	add.w	r3, r8, #24
 802b514:	3410      	adds	r4, #16
 802b516:	e73d      	b.n	802b394 <_realloc_r+0x1f4>
 802b518:	6923      	ldr	r3, [r4, #16]
 802b51a:	f8c8 3018 	str.w	r3, [r8, #24]
 802b51e:	6962      	ldr	r2, [r4, #20]
 802b520:	f108 0320 	add.w	r3, r8, #32
 802b524:	f8c8 201c 	str.w	r2, [r8, #28]
 802b528:	3418      	adds	r4, #24
 802b52a:	e74b      	b.n	802b3c4 <_realloc_r+0x224>
 802b52c:	463a      	mov	r2, r7
 802b52e:	e78f      	b.n	802b450 <_realloc_r+0x2b0>
 802b530:	6923      	ldr	r3, [r4, #16]
 802b532:	f8c8 3018 	str.w	r3, [r8, #24]
 802b536:	6962      	ldr	r2, [r4, #20]
 802b538:	f108 0320 	add.w	r3, r8, #32
 802b53c:	f8c8 201c 	str.w	r2, [r8, #28]
 802b540:	3418      	adds	r4, #24
 802b542:	e727      	b.n	802b394 <_realloc_r+0x1f4>
 802b544:	4638      	mov	r0, r7
 802b546:	4621      	mov	r1, r4
 802b548:	9300      	str	r3, [sp, #0]
 802b54a:	f7f9 ff27 	bl	802539c <memmove>
 802b54e:	9b00      	ldr	r3, [sp, #0]
 802b550:	e784      	b.n	802b45c <_realloc_r+0x2bc>
 802b552:	68a1      	ldr	r1, [r4, #8]
 802b554:	f8c8 1010 	str.w	r1, [r8, #16]
 802b558:	68e1      	ldr	r1, [r4, #12]
 802b55a:	2a24      	cmp	r2, #36	; 0x24
 802b55c:	f8c8 1014 	str.w	r1, [r8, #20]
 802b560:	d003      	beq.n	802b56a <_realloc_r+0x3ca>
 802b562:	f108 0218 	add.w	r2, r8, #24
 802b566:	3410      	adds	r4, #16
 802b568:	e772      	b.n	802b450 <_realloc_r+0x2b0>
 802b56a:	6922      	ldr	r2, [r4, #16]
 802b56c:	f8c8 2018 	str.w	r2, [r8, #24]
 802b570:	6961      	ldr	r1, [r4, #20]
 802b572:	f108 0220 	add.w	r2, r8, #32
 802b576:	f8c8 101c 	str.w	r1, [r8, #28]
 802b57a:	3418      	adds	r4, #24
 802b57c:	e768      	b.n	802b450 <_realloc_r+0x2b0>
 802b57e:	bf00      	nop

0802b580 <__fpclassifyd>:
 802b580:	460b      	mov	r3, r1
 802b582:	b161      	cbz	r1, 802b59e <__fpclassifyd+0x1e>
 802b584:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 802b588:	d009      	beq.n	802b59e <__fpclassifyd+0x1e>
 802b58a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802b58e:	f5a3 1180 	sub.w	r1, r3, #1048576	; 0x100000
 802b592:	f6c7 72df 	movt	r2, #32735	; 0x7fdf
 802b596:	4291      	cmp	r1, r2
 802b598:	d805      	bhi.n	802b5a6 <__fpclassifyd+0x26>
 802b59a:	2004      	movs	r0, #4
 802b59c:	4770      	bx	lr
 802b59e:	2800      	cmp	r0, #0
 802b5a0:	d1f3      	bne.n	802b58a <__fpclassifyd+0xa>
 802b5a2:	2002      	movs	r0, #2
 802b5a4:	4770      	bx	lr
 802b5a6:	f103 41fe 	add.w	r1, r3, #2130706432	; 0x7f000000
 802b5aa:	f501 0170 	add.w	r1, r1, #15728640	; 0xf00000
 802b5ae:	4291      	cmp	r1, r2
 802b5b0:	d9f3      	bls.n	802b59a <__fpclassifyd+0x1a>
 802b5b2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802b5b6:	f2c0 020f 	movt	r2, #15
 802b5ba:	4293      	cmp	r3, r2
 802b5bc:	d801      	bhi.n	802b5c2 <__fpclassifyd+0x42>
 802b5be:	2003      	movs	r0, #3
 802b5c0:	4770      	bx	lr
 802b5c2:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 802b5c6:	4291      	cmp	r1, r2
 802b5c8:	d9f9      	bls.n	802b5be <__fpclassifyd+0x3e>
 802b5ca:	2200      	movs	r2, #0
 802b5cc:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 802b5d0:	4293      	cmp	r3, r2
 802b5d2:	d004      	beq.n	802b5de <__fpclassifyd+0x5e>
 802b5d4:	f513 1f80 	cmn.w	r3, #1048576	; 0x100000
 802b5d8:	d001      	beq.n	802b5de <__fpclassifyd+0x5e>
 802b5da:	2000      	movs	r0, #0
 802b5dc:	4770      	bx	lr
 802b5de:	f1d0 0001 	rsbs	r0, r0, #1
 802b5e2:	bf38      	it	cc
 802b5e4:	2000      	movcc	r0, #0
 802b5e6:	4770      	bx	lr

0802b5e8 <_raise_r>:
 802b5e8:	291f      	cmp	r1, #31
 802b5ea:	b538      	push	{r3, r4, r5, lr}
 802b5ec:	460c      	mov	r4, r1
 802b5ee:	4605      	mov	r5, r0
 802b5f0:	d820      	bhi.n	802b634 <_raise_r+0x4c>
 802b5f2:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
 802b5f6:	b19a      	cbz	r2, 802b620 <_raise_r+0x38>
 802b5f8:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 802b5fc:	b183      	cbz	r3, 802b620 <_raise_r+0x38>
 802b5fe:	2b01      	cmp	r3, #1
 802b600:	d00c      	beq.n	802b61c <_raise_r+0x34>
 802b602:	1c59      	adds	r1, r3, #1
 802b604:	d006      	beq.n	802b614 <_raise_r+0x2c>
 802b606:	2500      	movs	r5, #0
 802b608:	4620      	mov	r0, r4
 802b60a:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
 802b60e:	4798      	blx	r3
 802b610:	4628      	mov	r0, r5
 802b612:	bd38      	pop	{r3, r4, r5, pc}
 802b614:	2316      	movs	r3, #22
 802b616:	6003      	str	r3, [r0, #0]
 802b618:	2001      	movs	r0, #1
 802b61a:	bd38      	pop	{r3, r4, r5, pc}
 802b61c:	2000      	movs	r0, #0
 802b61e:	bd38      	pop	{r3, r4, r5, pc}
 802b620:	4628      	mov	r0, r5
 802b622:	f7f7 f80f 	bl	8022644 <_getpid_r>
 802b626:	4622      	mov	r2, r4
 802b628:	4601      	mov	r1, r0
 802b62a:	4628      	mov	r0, r5
 802b62c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802b630:	f7f6 bff6 	b.w	8022620 <_kill_r>
 802b634:	2316      	movs	r3, #22
 802b636:	6003      	str	r3, [r0, #0]
 802b638:	f04f 30ff 	mov.w	r0, #4294967295
 802b63c:	bd38      	pop	{r3, r4, r5, pc}
 802b63e:	bf00      	nop

0802b640 <raise>:
 802b640:	f240 5310 	movw	r3, #1296	; 0x510
 802b644:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802b648:	4601      	mov	r1, r0
 802b64a:	6818      	ldr	r0, [r3, #0]
 802b64c:	f7ff bfcc 	b.w	802b5e8 <_raise_r>

0802b650 <snprintf>:
 802b650:	b40c      	push	{r2, r3}
 802b652:	b5f0      	push	{r4, r5, r6, r7, lr}
 802b654:	4b18      	ldr	r3, [pc, #96]	; (802b6b8 <snprintf+0x68>)
 802b656:	2900      	cmp	r1, #0
 802b658:	b09d      	sub	sp, #116	; 0x74
 802b65a:	681d      	ldr	r5, [r3, #0]
 802b65c:	460c      	mov	r4, r1
 802b65e:	db25      	blt.n	802b6ac <snprintf+0x5c>
 802b660:	f44f 7302 	mov.w	r3, #520	; 0x208
 802b664:	f8ad 3010 	strh.w	r3, [sp, #16]
 802b668:	9001      	str	r0, [sp, #4]
 802b66a:	9005      	str	r0, [sp, #20]
 802b66c:	d119      	bne.n	802b6a2 <snprintf+0x52>
 802b66e:	460f      	mov	r7, r1
 802b670:	ae23      	add	r6, sp, #140	; 0x8c
 802b672:	9a22      	ldr	r2, [sp, #136]	; 0x88
 802b674:	9703      	str	r7, [sp, #12]
 802b676:	9706      	str	r7, [sp, #24]
 802b678:	4628      	mov	r0, r5
 802b67a:	a901      	add	r1, sp, #4
 802b67c:	4633      	mov	r3, r6
 802b67e:	f64f 77ff 	movw	r7, #65535	; 0xffff
 802b682:	f8ad 7012 	strh.w	r7, [sp, #18]
 802b686:	961b      	str	r6, [sp, #108]	; 0x6c
 802b688:	f7fb fc72 	bl	8026f70 <_svfprintf_r>
 802b68c:	1c42      	adds	r2, r0, #1
 802b68e:	db0a      	blt.n	802b6a6 <snprintf+0x56>
 802b690:	b114      	cbz	r4, 802b698 <snprintf+0x48>
 802b692:	9b01      	ldr	r3, [sp, #4]
 802b694:	2200      	movs	r2, #0
 802b696:	701a      	strb	r2, [r3, #0]
 802b698:	b01d      	add	sp, #116	; 0x74
 802b69a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 802b69e:	b002      	add	sp, #8
 802b6a0:	4770      	bx	lr
 802b6a2:	1e4f      	subs	r7, r1, #1
 802b6a4:	e7e4      	b.n	802b670 <snprintf+0x20>
 802b6a6:	238b      	movs	r3, #139	; 0x8b
 802b6a8:	602b      	str	r3, [r5, #0]
 802b6aa:	e7f1      	b.n	802b690 <snprintf+0x40>
 802b6ac:	238b      	movs	r3, #139	; 0x8b
 802b6ae:	602b      	str	r3, [r5, #0]
 802b6b0:	f04f 30ff 	mov.w	r0, #4294967295
 802b6b4:	e7f0      	b.n	802b698 <snprintf+0x48>
 802b6b6:	bf00      	nop
 802b6b8:	20000510 	.word	0x20000510

0802b6bc <__sread>:
 802b6bc:	b510      	push	{r4, lr}
 802b6be:	460c      	mov	r4, r1
 802b6c0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802b6c4:	f7f6 ff38 	bl	8022538 <_read_r>
 802b6c8:	2800      	cmp	r0, #0
 802b6ca:	db03      	blt.n	802b6d4 <__sread+0x18>
 802b6cc:	6d23      	ldr	r3, [r4, #80]	; 0x50
 802b6ce:	181b      	adds	r3, r3, r0
 802b6d0:	6523      	str	r3, [r4, #80]	; 0x50
 802b6d2:	bd10      	pop	{r4, pc}
 802b6d4:	89a3      	ldrh	r3, [r4, #12]
 802b6d6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 802b6da:	81a3      	strh	r3, [r4, #12]
 802b6dc:	bd10      	pop	{r4, pc}
 802b6de:	bf00      	nop

0802b6e0 <__swrite>:
 802b6e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802b6e4:	4605      	mov	r5, r0
 802b6e6:	8988      	ldrh	r0, [r1, #12]
 802b6e8:	461e      	mov	r6, r3
 802b6ea:	05c3      	lsls	r3, r0, #23
 802b6ec:	460c      	mov	r4, r1
 802b6ee:	4617      	mov	r7, r2
 802b6f0:	d507      	bpl.n	802b702 <__swrite+0x22>
 802b6f2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802b6f6:	4628      	mov	r0, r5
 802b6f8:	2200      	movs	r2, #0
 802b6fa:	2302      	movs	r3, #2
 802b6fc:	f7f6 ff3c 	bl	8022578 <_lseek_r>
 802b700:	89a0      	ldrh	r0, [r4, #12]
 802b702:	f420 5080 	bic.w	r0, r0, #4096	; 0x1000
 802b706:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802b70a:	81a0      	strh	r0, [r4, #12]
 802b70c:	463a      	mov	r2, r7
 802b70e:	4628      	mov	r0, r5
 802b710:	4633      	mov	r3, r6
 802b712:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802b716:	f7f6 bf1f 	b.w	8022558 <_write_r>
 802b71a:	bf00      	nop

0802b71c <__sseek>:
 802b71c:	b510      	push	{r4, lr}
 802b71e:	460c      	mov	r4, r1
 802b720:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802b724:	f7f6 ff28 	bl	8022578 <_lseek_r>
 802b728:	1c42      	adds	r2, r0, #1
 802b72a:	89a3      	ldrh	r3, [r4, #12]
 802b72c:	d004      	beq.n	802b738 <__sseek+0x1c>
 802b72e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 802b732:	6520      	str	r0, [r4, #80]	; 0x50
 802b734:	81a3      	strh	r3, [r4, #12]
 802b736:	bd10      	pop	{r4, pc}
 802b738:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 802b73c:	81a3      	strh	r3, [r4, #12]
 802b73e:	bd10      	pop	{r4, pc}

0802b740 <__sclose>:
 802b740:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802b744:	f7f6 bf2c 	b.w	80225a0 <_close_r>

0802b748 <__ssprint_r>:
 802b748:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802b74c:	b083      	sub	sp, #12
 802b74e:	4691      	mov	r9, r2
 802b750:	9001      	str	r0, [sp, #4]
 802b752:	6890      	ldr	r0, [r2, #8]
 802b754:	6817      	ldr	r7, [r2, #0]
 802b756:	460d      	mov	r5, r1
 802b758:	2800      	cmp	r0, #0
 802b75a:	d071      	beq.n	802b840 <__ssprint_r+0xf8>
 802b75c:	f04f 0a00 	mov.w	sl, #0
 802b760:	6808      	ldr	r0, [r1, #0]
 802b762:	688b      	ldr	r3, [r1, #8]
 802b764:	4654      	mov	r4, sl
 802b766:	b1b4      	cbz	r4, 802b796 <__ssprint_r+0x4e>
 802b768:	429c      	cmp	r4, r3
 802b76a:	461e      	mov	r6, r3
 802b76c:	4698      	mov	r8, r3
 802b76e:	d217      	bcs.n	802b7a0 <__ssprint_r+0x58>
 802b770:	4626      	mov	r6, r4
 802b772:	46a0      	mov	r8, r4
 802b774:	4642      	mov	r2, r8
 802b776:	4651      	mov	r1, sl
 802b778:	f7f9 fe10 	bl	802539c <memmove>
 802b77c:	f8d9 2008 	ldr.w	r2, [r9, #8]
 802b780:	68ab      	ldr	r3, [r5, #8]
 802b782:	6828      	ldr	r0, [r5, #0]
 802b784:	1b9b      	subs	r3, r3, r6
 802b786:	4440      	add	r0, r8
 802b788:	1b14      	subs	r4, r2, r4
 802b78a:	60ab      	str	r3, [r5, #8]
 802b78c:	6028      	str	r0, [r5, #0]
 802b78e:	f8c9 4008 	str.w	r4, [r9, #8]
 802b792:	2c00      	cmp	r4, #0
 802b794:	d04e      	beq.n	802b834 <__ssprint_r+0xec>
 802b796:	f8d7 a000 	ldr.w	sl, [r7]
 802b79a:	687c      	ldr	r4, [r7, #4]
 802b79c:	3708      	adds	r7, #8
 802b79e:	e7e2      	b.n	802b766 <__ssprint_r+0x1e>
 802b7a0:	89ab      	ldrh	r3, [r5, #12]
 802b7a2:	f413 6f90 	tst.w	r3, #1152	; 0x480
 802b7a6:	d0e5      	beq.n	802b774 <__ssprint_r+0x2c>
 802b7a8:	696e      	ldr	r6, [r5, #20]
 802b7aa:	6929      	ldr	r1, [r5, #16]
 802b7ac:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 802b7b0:	ebc1 0800 	rsb	r8, r1, r0
 802b7b4:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
 802b7b8:	1c60      	adds	r0, r4, #1
 802b7ba:	1076      	asrs	r6, r6, #1
 802b7bc:	4440      	add	r0, r8
 802b7be:	4286      	cmp	r6, r0
 802b7c0:	4632      	mov	r2, r6
 802b7c2:	bf3c      	itt	cc
 802b7c4:	4606      	movcc	r6, r0
 802b7c6:	4632      	movcc	r2, r6
 802b7c8:	055b      	lsls	r3, r3, #21
 802b7ca:	9801      	ldr	r0, [sp, #4]
 802b7cc:	d51a      	bpl.n	802b804 <__ssprint_r+0xbc>
 802b7ce:	4611      	mov	r1, r2
 802b7d0:	f7f9 fb02 	bl	8024dd8 <_malloc_r>
 802b7d4:	4683      	mov	fp, r0
 802b7d6:	b1f0      	cbz	r0, 802b816 <__ssprint_r+0xce>
 802b7d8:	6929      	ldr	r1, [r5, #16]
 802b7da:	4642      	mov	r2, r8
 802b7dc:	f7f9 fd9c 	bl	8025318 <memcpy>
 802b7e0:	89ab      	ldrh	r3, [r5, #12]
 802b7e2:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 802b7e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802b7ea:	81ab      	strh	r3, [r5, #12]
 802b7ec:	ebc8 0306 	rsb	r3, r8, r6
 802b7f0:	eb0b 0008 	add.w	r0, fp, r8
 802b7f4:	616e      	str	r6, [r5, #20]
 802b7f6:	f8c5 b010 	str.w	fp, [r5, #16]
 802b7fa:	6028      	str	r0, [r5, #0]
 802b7fc:	4626      	mov	r6, r4
 802b7fe:	60ab      	str	r3, [r5, #8]
 802b800:	46a0      	mov	r8, r4
 802b802:	e7b7      	b.n	802b774 <__ssprint_r+0x2c>
 802b804:	f7ff fccc 	bl	802b1a0 <_realloc_r>
 802b808:	4683      	mov	fp, r0
 802b80a:	2800      	cmp	r0, #0
 802b80c:	d1ee      	bne.n	802b7ec <__ssprint_r+0xa4>
 802b80e:	6929      	ldr	r1, [r5, #16]
 802b810:	9801      	ldr	r0, [sp, #4]
 802b812:	f7fe fe85 	bl	802a520 <_free_r>
 802b816:	9a01      	ldr	r2, [sp, #4]
 802b818:	230c      	movs	r3, #12
 802b81a:	6013      	str	r3, [r2, #0]
 802b81c:	89aa      	ldrh	r2, [r5, #12]
 802b81e:	2300      	movs	r3, #0
 802b820:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802b824:	81aa      	strh	r2, [r5, #12]
 802b826:	f04f 30ff 	mov.w	r0, #4294967295
 802b82a:	f8c9 3008 	str.w	r3, [r9, #8]
 802b82e:	f8c9 3004 	str.w	r3, [r9, #4]
 802b832:	e002      	b.n	802b83a <__ssprint_r+0xf2>
 802b834:	f8c9 4004 	str.w	r4, [r9, #4]
 802b838:	4620      	mov	r0, r4
 802b83a:	b003      	add	sp, #12
 802b83c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802b840:	6050      	str	r0, [r2, #4]
 802b842:	e7fa      	b.n	802b83a <__ssprint_r+0xf2>

0802b844 <__swbuf_r>:
 802b844:	b570      	push	{r4, r5, r6, lr}
 802b846:	4604      	mov	r4, r0
 802b848:	460d      	mov	r5, r1
 802b84a:	4616      	mov	r6, r2
 802b84c:	b110      	cbz	r0, 802b854 <__swbuf_r+0x10>
 802b84e:	6b83      	ldr	r3, [r0, #56]	; 0x38
 802b850:	2b00      	cmp	r3, #0
 802b852:	d048      	beq.n	802b8e6 <__swbuf_r+0xa2>
 802b854:	89b2      	ldrh	r2, [r6, #12]
 802b856:	69b1      	ldr	r1, [r6, #24]
 802b858:	b293      	uxth	r3, r2
 802b85a:	60b1      	str	r1, [r6, #8]
 802b85c:	0719      	lsls	r1, r3, #28
 802b85e:	d539      	bpl.n	802b8d4 <__swbuf_r+0x90>
 802b860:	6931      	ldr	r1, [r6, #16]
 802b862:	2900      	cmp	r1, #0
 802b864:	d036      	beq.n	802b8d4 <__swbuf_r+0x90>
 802b866:	0498      	lsls	r0, r3, #18
 802b868:	d516      	bpl.n	802b898 <__swbuf_r+0x54>
 802b86a:	6833      	ldr	r3, [r6, #0]
 802b86c:	6972      	ldr	r2, [r6, #20]
 802b86e:	1a59      	subs	r1, r3, r1
 802b870:	4291      	cmp	r1, r2
 802b872:	da1d      	bge.n	802b8b0 <__swbuf_r+0x6c>
 802b874:	3101      	adds	r1, #1
 802b876:	68b2      	ldr	r2, [r6, #8]
 802b878:	b2ed      	uxtb	r5, r5
 802b87a:	3a01      	subs	r2, #1
 802b87c:	60b2      	str	r2, [r6, #8]
 802b87e:	f803 5b01 	strb.w	r5, [r3], #1
 802b882:	6972      	ldr	r2, [r6, #20]
 802b884:	6033      	str	r3, [r6, #0]
 802b886:	428a      	cmp	r2, r1
 802b888:	d01a      	beq.n	802b8c0 <__swbuf_r+0x7c>
 802b88a:	89b3      	ldrh	r3, [r6, #12]
 802b88c:	07db      	lsls	r3, r3, #31
 802b88e:	d501      	bpl.n	802b894 <__swbuf_r+0x50>
 802b890:	2d0a      	cmp	r5, #10
 802b892:	d015      	beq.n	802b8c0 <__swbuf_r+0x7c>
 802b894:	4628      	mov	r0, r5
 802b896:	bd70      	pop	{r4, r5, r6, pc}
 802b898:	6e73      	ldr	r3, [r6, #100]	; 0x64
 802b89a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802b89e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 802b8a2:	6673      	str	r3, [r6, #100]	; 0x64
 802b8a4:	6833      	ldr	r3, [r6, #0]
 802b8a6:	81b2      	strh	r2, [r6, #12]
 802b8a8:	6972      	ldr	r2, [r6, #20]
 802b8aa:	1a59      	subs	r1, r3, r1
 802b8ac:	4291      	cmp	r1, r2
 802b8ae:	dbe1      	blt.n	802b874 <__swbuf_r+0x30>
 802b8b0:	4620      	mov	r0, r4
 802b8b2:	4631      	mov	r1, r6
 802b8b4:	f7fe fc70 	bl	802a198 <_fflush_r>
 802b8b8:	bb08      	cbnz	r0, 802b8fe <__swbuf_r+0xba>
 802b8ba:	6833      	ldr	r3, [r6, #0]
 802b8bc:	2101      	movs	r1, #1
 802b8be:	e7da      	b.n	802b876 <__swbuf_r+0x32>
 802b8c0:	4620      	mov	r0, r4
 802b8c2:	4631      	mov	r1, r6
 802b8c4:	f7fe fc68 	bl	802a198 <_fflush_r>
 802b8c8:	2800      	cmp	r0, #0
 802b8ca:	bf18      	it	ne
 802b8cc:	f04f 35ff 	movne.w	r5, #4294967295
 802b8d0:	4628      	mov	r0, r5
 802b8d2:	bd70      	pop	{r4, r5, r6, pc}
 802b8d4:	4620      	mov	r0, r4
 802b8d6:	4631      	mov	r1, r6
 802b8d8:	f7fd fba6 	bl	8029028 <__swsetup_r>
 802b8dc:	b930      	cbnz	r0, 802b8ec <__swbuf_r+0xa8>
 802b8de:	89b2      	ldrh	r2, [r6, #12]
 802b8e0:	6931      	ldr	r1, [r6, #16]
 802b8e2:	b293      	uxth	r3, r2
 802b8e4:	e7bf      	b.n	802b866 <__swbuf_r+0x22>
 802b8e6:	f7fe fd3b 	bl	802a360 <__sinit>
 802b8ea:	e7b3      	b.n	802b854 <__swbuf_r+0x10>
 802b8ec:	89b3      	ldrh	r3, [r6, #12]
 802b8ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802b8f2:	81b3      	strh	r3, [r6, #12]
 802b8f4:	2309      	movs	r3, #9
 802b8f6:	f04f 35ff 	mov.w	r5, #4294967295
 802b8fa:	6023      	str	r3, [r4, #0]
 802b8fc:	e7ca      	b.n	802b894 <__swbuf_r+0x50>
 802b8fe:	f04f 35ff 	mov.w	r5, #4294967295
 802b902:	e7c7      	b.n	802b894 <__swbuf_r+0x50>

0802b904 <_wcrtomb_r>:
 802b904:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802b908:	461e      	mov	r6, r3
 802b90a:	4b10      	ldr	r3, [pc, #64]	; (802b94c <_wcrtomb_r+0x48>)
 802b90c:	b086      	sub	sp, #24
 802b90e:	460c      	mov	r4, r1
 802b910:	4605      	mov	r5, r0
 802b912:	4690      	mov	r8, r2
 802b914:	681f      	ldr	r7, [r3, #0]
 802b916:	b181      	cbz	r1, 802b93a <_wcrtomb_r+0x36>
 802b918:	f7ff f87a 	bl	802aa10 <__locale_charset>
 802b91c:	9600      	str	r6, [sp, #0]
 802b91e:	4603      	mov	r3, r0
 802b920:	4621      	mov	r1, r4
 802b922:	4628      	mov	r0, r5
 802b924:	4642      	mov	r2, r8
 802b926:	47b8      	blx	r7
 802b928:	1c43      	adds	r3, r0, #1
 802b92a:	d103      	bne.n	802b934 <_wcrtomb_r+0x30>
 802b92c:	2300      	movs	r3, #0
 802b92e:	6033      	str	r3, [r6, #0]
 802b930:	238a      	movs	r3, #138	; 0x8a
 802b932:	602b      	str	r3, [r5, #0]
 802b934:	b006      	add	sp, #24
 802b936:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802b93a:	f7ff f869 	bl	802aa10 <__locale_charset>
 802b93e:	9600      	str	r6, [sp, #0]
 802b940:	4603      	mov	r3, r0
 802b942:	a903      	add	r1, sp, #12
 802b944:	4628      	mov	r0, r5
 802b946:	4622      	mov	r2, r4
 802b948:	47b8      	blx	r7
 802b94a:	e7ed      	b.n	802b928 <_wcrtomb_r+0x24>
 802b94c:	200009cc 	.word	0x200009cc

0802b950 <__ascii_wctomb>:
 802b950:	b121      	cbz	r1, 802b95c <__ascii_wctomb+0xc>
 802b952:	2aff      	cmp	r2, #255	; 0xff
 802b954:	d804      	bhi.n	802b960 <__ascii_wctomb+0x10>
 802b956:	700a      	strb	r2, [r1, #0]
 802b958:	2001      	movs	r0, #1
 802b95a:	4770      	bx	lr
 802b95c:	4608      	mov	r0, r1
 802b95e:	4770      	bx	lr
 802b960:	238a      	movs	r3, #138	; 0x8a
 802b962:	6003      	str	r3, [r0, #0]
 802b964:	f04f 30ff 	mov.w	r0, #4294967295
 802b968:	4770      	bx	lr
 802b96a:	bf00      	nop

0802b96c <_calloc_r>:
 802b96c:	b510      	push	{r4, lr}
 802b96e:	fb01 f102 	mul.w	r1, r1, r2
 802b972:	f7f9 fa31 	bl	8024dd8 <_malloc_r>
 802b976:	4604      	mov	r4, r0
 802b978:	b1d8      	cbz	r0, 802b9b2 <_calloc_r+0x46>
 802b97a:	f850 2c04 	ldr.w	r2, [r0, #-4]
 802b97e:	f022 0203 	bic.w	r2, r2, #3
 802b982:	3a04      	subs	r2, #4
 802b984:	2a24      	cmp	r2, #36	; 0x24
 802b986:	d818      	bhi.n	802b9ba <_calloc_r+0x4e>
 802b988:	2a13      	cmp	r2, #19
 802b98a:	d914      	bls.n	802b9b6 <_calloc_r+0x4a>
 802b98c:	2300      	movs	r3, #0
 802b98e:	2a1b      	cmp	r2, #27
 802b990:	6003      	str	r3, [r0, #0]
 802b992:	6043      	str	r3, [r0, #4]
 802b994:	d916      	bls.n	802b9c4 <_calloc_r+0x58>
 802b996:	2a24      	cmp	r2, #36	; 0x24
 802b998:	6083      	str	r3, [r0, #8]
 802b99a:	60c3      	str	r3, [r0, #12]
 802b99c:	bf11      	iteee	ne
 802b99e:	f100 0210 	addne.w	r2, r0, #16
 802b9a2:	6103      	streq	r3, [r0, #16]
 802b9a4:	6143      	streq	r3, [r0, #20]
 802b9a6:	f100 0218 	addeq.w	r2, r0, #24
 802b9aa:	2300      	movs	r3, #0
 802b9ac:	6013      	str	r3, [r2, #0]
 802b9ae:	6053      	str	r3, [r2, #4]
 802b9b0:	6093      	str	r3, [r2, #8]
 802b9b2:	4620      	mov	r0, r4
 802b9b4:	bd10      	pop	{r4, pc}
 802b9b6:	4602      	mov	r2, r0
 802b9b8:	e7f7      	b.n	802b9aa <_calloc_r+0x3e>
 802b9ba:	2100      	movs	r1, #0
 802b9bc:	f7f9 fd46 	bl	802544c <memset>
 802b9c0:	4620      	mov	r0, r4
 802b9c2:	bd10      	pop	{r4, pc}
 802b9c4:	f100 0208 	add.w	r2, r0, #8
 802b9c8:	e7ef      	b.n	802b9aa <_calloc_r+0x3e>
 802b9ca:	bf00      	nop

0802b9cc <_fclose_r>:
 802b9cc:	b570      	push	{r4, r5, r6, lr}
 802b9ce:	460c      	mov	r4, r1
 802b9d0:	4605      	mov	r5, r0
 802b9d2:	2900      	cmp	r1, #0
 802b9d4:	d032      	beq.n	802ba3c <_fclose_r+0x70>
 802b9d6:	f7fe fce7 	bl	802a3a8 <__sfp_lock_acquire>
 802b9da:	b115      	cbz	r5, 802b9e2 <_fclose_r+0x16>
 802b9dc:	6bab      	ldr	r3, [r5, #56]	; 0x38
 802b9de:	2b00      	cmp	r3, #0
 802b9e0:	d02f      	beq.n	802ba42 <_fclose_r+0x76>
 802b9e2:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 802b9e6:	b32e      	cbz	r6, 802ba34 <_fclose_r+0x68>
 802b9e8:	4628      	mov	r0, r5
 802b9ea:	4621      	mov	r1, r4
 802b9ec:	f7fe fbd4 	bl	802a198 <_fflush_r>
 802b9f0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 802b9f2:	4606      	mov	r6, r0
 802b9f4:	b13b      	cbz	r3, 802ba06 <_fclose_r+0x3a>
 802b9f6:	69e1      	ldr	r1, [r4, #28]
 802b9f8:	4628      	mov	r0, r5
 802b9fa:	4798      	blx	r3
 802b9fc:	ea36 0620 	bics.w	r6, r6, r0, asr #32
 802ba00:	bf28      	it	cs
 802ba02:	f04f 36ff 	movcs.w	r6, #4294967295
 802ba06:	89a3      	ldrh	r3, [r4, #12]
 802ba08:	061b      	lsls	r3, r3, #24
 802ba0a:	d422      	bmi.n	802ba52 <_fclose_r+0x86>
 802ba0c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 802ba0e:	b141      	cbz	r1, 802ba22 <_fclose_r+0x56>
 802ba10:	f104 0340 	add.w	r3, r4, #64	; 0x40
 802ba14:	4299      	cmp	r1, r3
 802ba16:	d002      	beq.n	802ba1e <_fclose_r+0x52>
 802ba18:	4628      	mov	r0, r5
 802ba1a:	f7fe fd81 	bl	802a520 <_free_r>
 802ba1e:	2300      	movs	r3, #0
 802ba20:	6323      	str	r3, [r4, #48]	; 0x30
 802ba22:	6c61      	ldr	r1, [r4, #68]	; 0x44
 802ba24:	b121      	cbz	r1, 802ba30 <_fclose_r+0x64>
 802ba26:	4628      	mov	r0, r5
 802ba28:	f7fe fd7a 	bl	802a520 <_free_r>
 802ba2c:	2300      	movs	r3, #0
 802ba2e:	6463      	str	r3, [r4, #68]	; 0x44
 802ba30:	2300      	movs	r3, #0
 802ba32:	81a3      	strh	r3, [r4, #12]
 802ba34:	f7fe fcba 	bl	802a3ac <__sfp_lock_release>
 802ba38:	4630      	mov	r0, r6
 802ba3a:	bd70      	pop	{r4, r5, r6, pc}
 802ba3c:	460e      	mov	r6, r1
 802ba3e:	4630      	mov	r0, r6
 802ba40:	bd70      	pop	{r4, r5, r6, pc}
 802ba42:	4628      	mov	r0, r5
 802ba44:	f7fe fc8c 	bl	802a360 <__sinit>
 802ba48:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 802ba4c:	2e00      	cmp	r6, #0
 802ba4e:	d1cb      	bne.n	802b9e8 <_fclose_r+0x1c>
 802ba50:	e7f0      	b.n	802ba34 <_fclose_r+0x68>
 802ba52:	6921      	ldr	r1, [r4, #16]
 802ba54:	4628      	mov	r0, r5
 802ba56:	f7fe fd63 	bl	802a520 <_free_r>
 802ba5a:	e7d7      	b.n	802ba0c <_fclose_r+0x40>

0802ba5c <fclose>:
 802ba5c:	f240 5310 	movw	r3, #1296	; 0x510
 802ba60:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802ba64:	4601      	mov	r1, r0
 802ba66:	6818      	ldr	r0, [r3, #0]
 802ba68:	f7ff bfb0 	b.w	802b9cc <_fclose_r>
 802ba6c:	00412f4e 	.word	0x00412f4e
 802ba70:	72746e49 	.word	0x72746e49
 802ba74:	6375646f 	.word	0x6375646f
 802ba78:	20676e69 	.word	0x20676e69
 802ba7c:	6a6f7250 	.word	0x6a6f7250
 802ba80:	3a746365 	.word	0x3a746365
 802ba84:	00000000 	.word	0x00000000
 802ba88:	6e756854 	.word	0x6e756854
 802ba8c:	43726564 	.word	0x43726564
 802ba90:	72657972 	.word	0x72657972
 802ba94:	00000000 	.word	0x00000000
 802ba98:	313a3132 	.word	0x313a3132
 802ba9c:	00000034 	.word	0x00000034
 802baa0:	202e7246 	.word	0x202e7246
 802baa4:	302e3432 	.word	0x302e3432
 802baa8:	32312e32 	.word	0x32312e32
 802baac:	00000000 	.word	0x00000000
 802bab0:	65766544 	.word	0x65766544
 802bab4:	6d706f6c 	.word	0x6d706f6c
 802bab8:	20746e65 	.word	0x20746e65
 802babc:	70206e69 	.word	0x70206e69
 802bac0:	72676f72 	.word	0x72676f72
 802bac4:	00737365 	.word	0x00737365
 802bac8:	75323025 	.word	0x75323025
 802bacc:	00000000 	.word	0x00000000
 802bad0:	462f2e2e 	.word	0x462f2e2e
 802bad4:	52656572 	.word	0x52656572
 802bad8:	5f534f54 	.word	0x5f534f54
 802badc:	532f4345 	.word	0x532f4345
 802bae0:	6372756f 	.word	0x6372756f
 802bae4:	54432f65 	.word	0x54432f65
 802bae8:	2e6b7361 	.word	0x2e6b7361
 802baec:	00707063 	.word	0x00707063
 802baf0:	646e6168 	.word	0x646e6168
 802baf4:	2120656c 	.word	0x2120656c
 802baf8:	554e203d 	.word	0x554e203d
 802bafc:	00004c4c 	.word	0x00004c4c
 802bb00:	454c4449 	.word	0x454c4449
 802bb04:	00000000 	.word	0x00000000
 802bb08:	00000a0d 	.word	0x00000a0d
 802bb0c:	20207525 	.word	0x20207525
 802bb10:	20206325 	.word	0x20206325
 802bb14:	36312d25 	.word	0x36312d25
 802bb18:	20202073 	.word	0x20202073
 802bb1c:	20202020 	.word	0x20202020
 802bb20:	30202020 	.word	0x30202020
 802bb24:	30202020 	.word	0x30202020
 802bb28:	20202525 	.word	0x20202525
 802bb2c:	0d753525 	.word	0x0d753525
 802bb30:	0000000a 	.word	0x0000000a
 802bb34:	20207525 	.word	0x20207525
 802bb38:	20206325 	.word	0x20206325
 802bb3c:	36312d25 	.word	0x36312d25
 802bb40:	31252073 	.word	0x31252073
 802bb44:	25207530 	.word	0x25207530
 802bb48:	25257533 	.word	0x25257533
 802bb4c:	35252020 	.word	0x35252020
 802bb50:	000a0d75 	.word	0x000a0d75
 802bb54:	20207525 	.word	0x20207525
 802bb58:	20206325 	.word	0x20206325
 802bb5c:	36312d25 	.word	0x36312d25
 802bb60:	31252073 	.word	0x31252073
 802bb64:	20207530 	.word	0x20207530
 802bb68:	2525313c 	.word	0x2525313c
 802bb6c:	35252020 	.word	0x35252020
 802bb70:	000a0d75 	.word	0x000a0d75
 802bb74:	00000000 	.word	0x00000000
 802bb78:	00005825 	.word	0x00005825
 802bb7c:	25206125 	.word	0x25206125
 802bb80:	62262064 	.word	0x62262064
 802bb84:	00592520 	.word	0x00592520
 802bb88:	6b656557 	.word	0x6b656557
 802bb8c:	5725203a 	.word	0x5725203a
 802bb90:	00000000 	.word	0x00000000
 802bb94:	2b2a2220 	.word	0x2b2a2220
 802bb98:	5d3d5b2c 	.word	0x5d3d5b2c
 802bb9c:	00007f7c 	.word	0x00007f7c
 802bba0:	4e204f4e 	.word	0x4e204f4e
 802bba4:	20454d41 	.word	0x20454d41
 802bba8:	46202020 	.word	0x46202020
 802bbac:	20205441 	.word	0x20205441
 802bbb0:	00202020 	.word	0x00202020
 802bbb4:	4e204f4e 	.word	0x4e204f4e
 802bbb8:	20454d41 	.word	0x20454d41
 802bbbc:	46202020 	.word	0x46202020
 802bbc0:	32335441 	.word	0x32335441
 802bbc4:	00202020 	.word	0x00202020
 802bbc8:	2064654c 	.word	0x2064654c
 802bbcc:	72616548 	.word	0x72616548
 802bbd0:	61656274 	.word	0x61656274
 802bbd4:	00000074 	.word	0x00000074
 802bbd8:	20425355 	.word	0x20425355
 802bbdc:	7373614d 	.word	0x7373614d
 802bbe0:	726f7473 	.word	0x726f7473
 802bbe4:	00656761 	.word	0x00656761
 802bbe8:	756e654d 	.word	0x756e654d
 802bbec:	00000065 	.word	0x00000065
 802bbf0:	656c6946 	.word	0x656c6946
 802bbf4:	646e6148 	.word	0x646e6148
 802bbf8:	0072656c 	.word	0x0072656c

0802bbfc <GPIO_PIN>:
 802bbfc:	20001000 80004000                       ... .@..

0802bc04 <GPIO_CLK>:
 802bc04:	00000008 00000008 00000008 00000008     ................

0802bc14 <BUTTON_PIN>:
 802bc14:	00000001                                ....

0802bc18 <BUTTON_CLK>:
 802bc18:	00000001                                ....

0802bc1c <BUTTON_EXTI_LINE>:
 802bc1c:	00000001                                ....

0802bc20 <BUTTON_PORT_SOURCE>:
 802bc20:	00000000                                ....

0802bc24 <BUTTON_PIN_SOURCE>:
 802bc24:	00000000                                ....

0802bc28 <BUTTON_IRQn>:
 802bc28:	00000006 00000000                       ........

0802bc30 <_ZTV6CMenue>:
	...
 802bc38:	08024b3d 080199a1 08024b61 0800f441     =K......aK..A...
 802bc48:	0800f479 0800f499 0800f4b1 08024b85     y............K..

0802bc58 <_ZL12c_FontNative>:
	...

0802bc70 <dcttab>:
 802bc70:	4013c251 518522fb 404f4672 40b345bd     Q..@.".QrFO@.E.@
 802bc80:	6d0b20cf 42e13c10 41fa2d6d 41d95790     . .m.<.Bm-.A.W.A
 802bc90:	48919f44 43f93421 5efc8d96 52cb0e63     D..H!4.C...^c..R
 802bca0:	46cc1bc4 4ad81a97 64e2402e 4a9d9cf0     ...F...J.@.d...J
 802bcb0:	7c7d1db3 43e224a9 4fae3711 6b6fcf26     ..}|.$.C.7.O&.ok
 802bcc0:	6e3c92c1 56601ea7 5f4cf6eb 519e4e04     ..<n..`V..L_.N.Q
 802bcd0:	4140fb46 52036742 4545e9ef 4cf8de88     F.@ABg.R..EE...L
 802bce0:	73326bbf 539eba45 bebf04ba adfc98be     .k2sE..S........
 802bcf0:	4545e9ef b3072178 8ccd9441 539eba45     ..EEx!..A...E..S
 802bd00:	4140fb46 52036742 4545e9ef 4cf8de88     F.@ABg.R..EE...L
 802bd10:	73326bbf 539eba45 bebf04ba adfc98be     .k2sE..S........
 802bd20:	4545e9ef b3072178 8ccd9441 539eba45     ..EEx!..A...E..S

0802bd30 <preTab>:
	...
 802bd38:	01000000 02010101 03030302 00000002     ................

0802bd48 <pow14>:
 802bd48:	7fffffff 6ba27e65 5a82799a 4c1bf829     ....e~.k.y.Z)..L

0802bd58 <pow43_14>:
 802bd58:	00000000 10000000 285145f3 453a5cdb     .........EQ(.\:E
 802bd68:	0cb2ff53 111989d6 15ce31c8 1ac7f203     S........1......
 802bd78:	20000000 257106b9 2b16b4a3 30ed74b4     ... ..q%...+.t.0
 802bd88:	36f23fa5 3d227bd3 437be656 49fc823c     .?.6.{"=V.{C<..I
 802bd98:	00000000 0d744fcd 21e71f26 3a36abd9     .....Ot.&..!..6:
 802bda8:	0aadc084 0e610e6e 12560c1d 168523cf     ....n.a...V..#..
 802bdb8:	1ae89f99 1f7c03a4 243bae49 29249c67     ......|.I.;$g.$)
 802bdc8:	2e34420f 33686f85 38bf3dff 3e370182     .B4..oh3.=.8..7>
 802bdd8:	00000000 0b504f33 1c823e07 30f39a55     ....3OP..>..U..0
 802bde8:	08facd62 0c176319 0f6b3522 12efe2ad     b....c.."5k.....
 802bdf8:	16a09e66 1a79a317 1e77e301 2298d5b4     f.....y...w...."
 802be08:	26da56fc 2b3a902a 2fb7e7e7 3450f650     .V.&*.:+.../P.P4
 802be18:	00000000 09837f05 17f910d7 2929c7a9     ..............))
 802be28:	078d0dfa 0a2ae661 0cf73154 0fec91cb     ....a.*.T1......
 802be38:	1306fe0a 16434a6c 199ee595 1d17ae3d     ....lJC.....=...
 802be48:	20abd76a 2459d551 28204fbb 2bfe1808     j.. Q.Y$.O (...+

0802be58 <pow43>:
 802be58:	1428a2fa 15db1bd6 1796302c 19598d85     ..(.....,0....Y.
 802be68:	1b24e8bb 1cf7fcfa 1ed28af2 20b4582a     ..$.........*X. 
 802be78:	229d2e6e 248cdb55 26832fda 28800000     n.."U..$./.&...(
 802be88:	2a832287 2c8c70a8 2e9bc5d8 30b0ff99     .".*.p.,.......0
 802be98:	32cbfd4a 34eca001 3712ca62 393e6088     J..2...4b..7.`>9
 802bea8:	3b6f47e0 3da56717 3fe0a5fc 4220ed72     .Go;.g.=...?r. B
 802beb8:	44662758 46b03e7c 48ff1e87 4b52b3f3     X'fD|>.F...H..RK
 802bec8:	4daaebfd 5007b497 5268fc62 54ceb29c     ...M...Pb.hR...T
 802bed8:	5738c721 59a72a59 5c19cd35 5e90a129     !.8WY*.Y5..\)..^
 802bee8:	610b9821 638aa47f 660db90f 6894c90b     !..a...c...f...h
 802bef8:	6b1fc80c 6daeaa0d 70416360 72d7e8b0     ...k...m`cAp...r
 802bf08:	75722ef9 78102b85 7ab1d3ec 7d571e09     ..ru.+.x...z..W}

0802bf18 <poly43lo>:
 802bf18:	29a0bda9 b02e4828 5957aa1b 236c498d     ...)(H....WY.Il#
 802bf28:	ff581859                                Y.X.

0802bf2c <poly43hi>:
 802bf2c:	10852163 d333f6a4 46e9408b 27c2cef0     c!....3..@.F...'
 802bf3c:	fef577b4                                .w..

0802bf40 <pow2exp>:
 802bf40:	0000000e 0000000d 0000000b 0000000a     ................
 802bf50:	00000009 00000007 00000006 00000005     ................

0802bf60 <pow2frac>:
 802bf60:	6597fa94 50a28be6 7fffffff 6597fa94     ...e...P.......e
 802bf70:	50a28be6 7fffffff 6597fa94 50a28be6     ...P.......e...P

0802bf80 <xmp3_huffTable>:
 802bf80:	3112f003 20113101 10002011 10001000     ...1.1. . ......
 802bf90:	f0061000 62016222 52125212 51225122     ...."b.b.R.R"Q"Q
 802bfa0:	50215021 31123112 31123112 31123112     !P!P.1.1.1.1.1.1
 802bfb0:	31123112 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802bfc0:	31013101 30113011 30113011 30113011     .1.1.0.0.0.0.0.0
 802bfd0:	30113011 10001000 10001000 10001000     .0.0............
 802bfe0:	10001000 10001000 10001000 10001000     ................
 802bff0:	10001000 10001000 10001000 10001000     ................
 802c000:	10001000 10001000 10001000 10001000     ................
 802c010:	10001000 6222f006 52126201 51225212     ......"b.b.R.R"Q
 802c020:	50215122 30115021 30113011 30113011     "Q!P!P.0.0.0.0.0
 802c030:	30113011 21123011 21122112 21122112     .0.0.0.!.!.!.!.!
 802c040:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c050:	21122112 21012112 21012101 21012101     .!.!.!.!.!.!.!.!
 802c060:	21012101 21012101 21012101 21012101     .!.!.!.!.!.!.!.!
 802c070:	21012101 20002101 20002000 20002000     .!.!.!. . . . . 
 802c080:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802c090:	20002000 f0082000 83228332 72327232     . . . ..2.".2r2r
 802c0a0:	61326132 61326132 73127312 73017301     2a2a2a2a.s.s.s.s
 802c0b0:	70317031 72227222 62126212 62126212     1p1p"r"r.b.b.b.b
 802c0c0:	61226122 61226122 62016201 62016201     "a"a"a"a.b.b.b.b
 802c0d0:	60216021 60216021 31123112 31123112     !`!`!`!`.1.1.1.1
 802c0e0:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802c0f0:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802c100:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802c110:	31123112 31123112 31013101 31013101     .1.1.1.1.1.1.1.1
 802c120:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c130:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c140:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c150:	31013101 31013101 30113011 30113011     .1.1.1.1.0.0.0.0
 802c160:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c170:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c180:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c190:	30113011 30113011 10001000 10001000     .0.0.0.0........
 802c1a0:	10001000 10001000 10001000 10001000     ................
 802c1b0:	10001000 10001000 10001000 10001000     ................
 802c1c0:	10001000 10001000 10001000 10001000     ................
 802c1d0:	10001000 10001000 10001000 10001000     ................
 802c1e0:	10001000 10001000 10001000 10001000     ................
 802c1f0:	10001000 10001000 10001000 10001000     ................
 802c200:	10001000 10001000 10001000 10001000     ................
 802c210:	10001000 10001000 10001000 10001000     ................
 802c220:	10001000 10001000 10001000 10001000     ................
 802c230:	10001000 10001000 10001000 10001000     ................
 802c240:	10001000 10001000 10001000 10001000     ................
 802c250:	10001000 10001000 10001000 10001000     ................
 802c260:	10001000 10001000 10001000 10001000     ................
 802c270:	10001000 10001000 10001000 10001000     ................
 802c280:	10001000 10001000 10001000 10001000     ................
 802c290:	10001000 10001000 7332f007 63227301     ..........2s.s"c
 802c2a0:	62326322 60316232 53126031 53125312     "c2b2b1`1`.S.S.S
 802c2b0:	51325312 51325132 52225132 52225222     .S2Q2Q2Q2Q"R"R"R
 802c2c0:	52015222 52015201 42125201 42124212     "R.R.R.R.R.B.B.B
 802c2d0:	42124212 42124212 41224212 41224122     .B.B.B.B.B"A"A"A
 802c2e0:	41224122 41224122 40214122 40214021     "A"A"A"A"A!@!@!@
 802c2f0:	40214021 40214021 31014021 31013101     !@!@!@!@!@.1.1.1
 802c300:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c310:	31013101 31013101 21123101 21122112     .1.1.1.1.1.!.!.!
 802c320:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c330:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c340:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c350:	21122112 21122112 30112112 30113011     .!.!.!.!.!.0.0.0
 802c360:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c370:	30113011 30113011 30003011 30003000     .0.0.0.0.0.0.0.0
 802c380:	30003000 30003000 30003000 30003000     .0.0.0.0.0.0.0.0
 802c390:	30003000 30003000 f0063000 00520041     .0.0.0.0.0..A.R.
 802c3a0:	0060005b 00680063 6212006b 51225122     [.`.c.h.k..b"Q"Q
 802c3b0:	60216201 41124112 41124112 31013101     .b!`.A.A.A.A.1.1
 802c3c0:	31013101 31013101 31013101 30113011     .1.1.1.1.1.1.0.0
 802c3d0:	30113011 30113011 30113011 10001000     .0.0.0.0.0.0....
 802c3e0:	10001000 10001000 10001000 10001000     ................
 802c3f0:	10001000 10001000 10001000 10001000     ................
 802c400:	10001000 10001000 10001000 10001000     ................
 802c410:	10001000 10001000 10001000 4552f004     ..............RE
 802c420:	44524542 35324352 34423532 35223442     BERDRC2525B4B4"5
 802c430:	32523522 25123252 25122512 f0032512     "5R2R2.%.%.%.%..
 802c440:	21522152 34323501 20512051 33323342     R!R!.524Q Q B323
 802c450:	2422f002 14122242 f0011412 10411142     .."$B"......B.A.
 802c460:	2401f002 22322322 f0012301 11321312     ...$"#2".#....2.
 802c470:	1031f001 f0081222 010a0101 8512010f     ..1."...........
 802c480:	01128152 84220115 84128242 71427142     R.....".B...BqBq
 802c490:	80418401 82328322 81328312 80318301     ..A.".2...2...1.
 802c4a0:	62226222 62226222 62016201 62016201     "b"b"b"b.b.b.b.b
 802c4b0:	60216021 60216021 42124212 42124212     !`!`!`!`.B.B.B.B
 802c4c0:	42124212 42124212 42124212 42124212     .B.B.B.B.B.B.B.B
 802c4d0:	42124212 42124212 41224122 41224122     .B.B.B.B"A"A"A"A
 802c4e0:	41224122 41224122 41224122 41224122     "A"A"A"A"A"A"A"A
 802c4f0:	41224122 41224122 21122112 21122112     "A"A"A"A.!.!.!.!
 802c500:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c510:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c520:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c530:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c540:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c550:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c560:	21122112 21122112 21122112 21122112     .!.!.!.!.!.!.!.!
 802c570:	21122112 21122112 31013101 31013101     .!.!.!.!.1.1.1.1
 802c580:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c590:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c5a0:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c5b0:	31013101 31013101 30113011 30113011     .1.1.1.1.0.0.0.0
 802c5c0:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c5d0:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c5e0:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c5f0:	30113011 30113011 20002000 20002000     .0.0.0.0. . . . 
 802c600:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802c610:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802c620:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802c630:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802c640:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802c650:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802c660:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802c670:	20002000 20002000 3552f003 25423452     . . . . ..R5R4B%
 802c680:	13522542 13521352 f0021352 24422532     B%R.R.R.R...2%B$
 802c690:	15221522 1252f001 f0011501 13421432     "."...R.....2.B.
 802c6a0:	1051f001 f0061332 004a0041 0052004f     ..Q.2...A.J.O.R.
 802c6b0:	005a0057 61426412 62326322 53125312     W.Z..dBa"c2b.S.S
 802c6c0:	51325132 60316301 52225222 52015201     2Q2Q.c1`"R"R.R.R
 802c6d0:	42124212 42124212 41224122 41224122     .B.B.B.B"A"A"A"A
 802c6e0:	40214021 40214021 31123112 31123112     !@!@!@!@.1.1.1.1
 802c6f0:	31123112 31123112 31013101 31013101     .1.1.1.1.1.1.1.1
 802c700:	31013101 31013101 30113011 30113011     .1.1.1.1.0.0.0.0
 802c710:	30113011 30113011 30003000 30003000     .0.0.0.0.0.0.0.0
 802c720:	30003000 30003000 3552f003 25323542     .0.0.0.0..R5B52%
 802c730:	23522532 34522352 f0023501 25222442     2%R#R#R4.5..B$"%
 802c740:	25122252 1152f001 f0021432 13421342     R".%..R.2...B.B.
 802c750:	24012051 1422f001 f0011242 10411332     Q .$..".B...2.A.
 802c760:	0101f008 010f010a 011b0118 01250120     ............ .%.
 802c770:	81728712 012d012a 86120132 80618162     ..r.*.-.2...b.a.
 802c780:	013a0137 8412013d 80418142 82328322     7.:.=...B.A.".2.
 802c790:	73128301 71327312 70317132 72227031     ...s.s2q2q1p1p"r
 802c7a0:	62127222 62126212 61226212 61226122     "r.b.b.b.b"a"a"a
 802c7b0:	62016122 62016201 60216201 60216021     "a.b.b.b.b!`!`!`
 802c7c0:	41126021 41124112 41124112 41124112     !`.A.A.A.A.A.A.A
 802c7d0:	41124112 41124112 41124112 41124112     .A.A.A.A.A.A.A.A
 802c7e0:	31014112 31013101 31013101 31013101     .A.1.1.1.1.1.1.1
 802c7f0:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c800:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c810:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802c820:	30113101 30113011 30113011 30113011     .1.0.0.0.0.0.0.0
 802c830:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c840:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c850:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802c860:	10003011 10001000 10001000 10001000     .0..............
 802c870:	10001000 10001000 10001000 10001000     ................
 802c880:	10001000 10001000 10001000 10001000     ................
 802c890:	10001000 10001000 10001000 10001000     ................
 802c8a0:	10001000 10001000 10001000 10001000     ................
 802c8b0:	10001000 10001000 10001000 10001000     ................
 802c8c0:	10001000 10001000 10001000 10001000     ................
 802c8d0:	10001000 10001000 10001000 10001000     ................
 802c8e0:	10001000 10001000 10001000 10001000     ................
 802c8f0:	10001000 10001000 10001000 10001000     ................
 802c900:	10001000 10001000 10001000 10001000     ................
 802c910:	10001000 10001000 10001000 10001000     ................
 802c920:	10001000 10001000 10001000 10001000     ................
 802c930:	10001000 10001000 10001000 10001000     ................
 802c940:	10001000 10001000 10001000 10001000     ................
 802c950:	10001000 10001000 10001000 10001000     ................
 802c960:	f0031000 37623772 37523672 36623572     ....r7b7r6R7r5b6
 802c970:	27422742 2472f002 25622652 f0032732     B'B'..r$R&b%2'..
 802c980:	23722372 26422642 34523552 23622362     r#r#B&B&R5R4b#b#
 802c990:	1722f001 f0021272 27012462 10711071     ..".r...b$.'q.q.
 802c9a0:	1262f002 25421262 f0022532 16011601     ..b.b.B%2%......
 802c9b0:	24422352 1632f001 f0021622 22522522     R#B$..2."..."%R"
 802c9c0:	15121512 1152f002 24321152 f0012342     ......R.R.2$B#..
 802c9d0:	10511501 1422f001 f0011242 14011332     ..Q...".B...2...
 802c9e0:	0101f008 010f0106 01170114 82728722     ............".r.
 802c9f0:	7172011c 87127172 86328071 80618362     ..rqrq..q.2.b.a.
 802ca00:	0122011f 72628512 86227262 76128601     .."...brbr"....v
 802ca10:	71627612 81527162 80518432 84220125     .vbqbqR.2.Q.%.".
 802ca20:	84128242 84018142 73228041 72327322     B...B...A."s"s2r
 802ca30:	63127232 63126312 61326312 61326132     2r.c.c.c.c2a2a2a
 802ca40:	73016132 70317301 62227031 62226222     2a.s.s1p1p"b"b"b
 802ca50:	51226222 51225122 51225122 51225122     "b"Q"Q"Q"Q"Q"Q"Q
 802ca60:	42125122 42124212 42124212 42124212     "Q.B.B.B.B.B.B.B
 802ca70:	42124212 42124212 42124212 42124212     .B.B.B.B.B.B.B.B
 802ca80:	52014212 52015201 52015201 52015201     .B.R.R.R.R.R.R.R
 802ca90:	50215201 50215021 50215021 50215021     .R!P!P!P!P!P!P!P
 802caa0:	31125021 31123112 31123112 31123112     !P.1.1.1.1.1.1.1
 802cab0:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802cac0:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802cad0:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802cae0:	31013112 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802caf0:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802cb00:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802cb10:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802cb20:	30113101 30113011 30113011 30113011     .1.0.0.0.0.0.0.0
 802cb30:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802cb40:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802cb50:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802cb60:	20003011 20002000 20002000 20002000     .0. . . . . . . 
 802cb70:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802cb80:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802cb90:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802cba0:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802cbb0:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802cbc0:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802cbd0:	20002000 20002000 20002000 20002000     . . . . . . . . 
 802cbe0:	f0022000 27622772 25722672 2662f003     . ..r'b'r&r%..b&
 802cbf0:	27422662 24722742 37522472 f0023552     b&B'B'r$r$R7R5..
 802cc00:	25622652 17321732 1372f001 f0021642     R&b%2.2...r.B...
 802cc10:	24522542 23522532 1462f001 f0011701     B%R$2%R#..b.....
 802cc20:	15221442 1252f001 f0011501 13321342     B."...R.....B.2.
 802cc30:	0081f007 008f008a 00970092 009d009a     ................
 802cc40:	00a500a2 762200a8 71627262 00b000ad     ......"vbrbq....
 802cc50:	751200b3 74327152 00b67342 72427422     ...uRq2tBs.."tBr
 802cc60:	63327412 61426332 63226142 62326322     .t2c2cBaBa"c"c2b
 802cc70:	70416232 60317301 53126031 53125312     2bAp.s1`1`.S.S.S
 802cc80:	51325312 51325132 52225132 52225222     .S2Q2Q2Q2Q"R"R"R
 802cc90:	42125222 42124212 42124212 42124212     "R.B.B.B.B.B.B.B
 802cca0:	41224212 41224122 41224122 41224122     .B"A"A"A"A"A"A"A
 802ccb0:	52014122 52015201 50215201 50215021     "A.R.R.R.R!P!P!P
 802ccc0:	40005021 40004000 40004000 40004000     !P.@.@.@.@.@.@.@
 802ccd0:	31124000 31123112 31123112 31123112     .@.1.1.1.1.1.1.1
 802cce0:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802ccf0:	31013112 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802cd00:	31013101 31013101 31013101 31013101     .1.1.1.1.1.1.1.1
 802cd10:	30113101 30113011 30113011 30113011     .1.0.0.0.0.0.0.0
 802cd20:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802cd30:	f0033011 37623772 26722672 27522752     .0..r7b7r&r&R'R'
 802cd40:	25722572 2662f002 24722742 f0012562     r%r%..b&B'r$b%..
 802cd50:	17321652 2372f002 17222552 f0011722     R.2...r#R%"."...
 802cd60:	16421272 1462f001 f0021712 11721172     r.B...b.....r.r.
 802cd70:	20712701 1632f001 f0011362 14521542     .'q ..2.b...B.R.
 802cd80:	1442f002 26011442 f0012501 10611612     ..B.B..&.%....a.
 802cd90:	1532f001 f0011352 12521522 1051f001     ..2.R...".R...Q.
 802cda0:	f0061401 00820041 00e400c3 01160105     ....A...........
 802cdb0:	0130011f 013e0139 01460143 61226212     ..0.9.>.C.F..b"a
 802cdc0:	60216201 41124112 41124112 41014101     .b!`.A.A.A.A.A.A
 802cdd0:	41014101 30113011 30113011 30113011     .A.A.0.0.0.0.0.0
 802cde0:	30113011 10001000 10001000 10001000     .0.0............
 802cdf0:	10001000 10001000 10001000 10001000     ................
 802ce00:	10001000 10001000 10001000 10001000     ................
 802ce10:	10001000 10001000 10001000 10001000     ................
 802ce20:	10001000 0108f006 011a0111 012c0123     ............#.,.
 802ce30:	01360131 0144013f 014c0147 01560151     1.6.?.D.G.L.Q.V.
 802ce40:	6f12015b 60f161f2 01630160 62e20166     [..o.a.``.c.f..b
 802ce50:	6e120169 016c61e2 0172016f 01780175     i..n.al.o.r.u.x.
 802ce60:	66c2017b 017e6d32 62d26d22 67b26d12     {..f2m~."m.b.m.g
 802ce70:	01840181 018763c2 51d26b42 6d0151d2     .....c..Bk.Q.Q.m
 802ce80:	6a8260d1 6c4268a2 6b6264c2 5c3266b2     .`.j.hBl.dbk.f2\
 802ce90:	5c225c32 52c25c22 5b5252c2 65b25b52     2\"\"\.R.RR[R[.e
 802cea0:	5c126982 f0065c12 51c251c2 6c016892     .i.\.\...Q.Q.h.l
 802ceb0:	50c150c1 6a6264b2 697266a2 5b325b32     .P.P.dbj.fri2[2[
 802cec0:	53b253b2 6a526882 5b225b22 696265a2     .S.S.hRj"["[.ebi
 802ced0:	54a254a2 67826872 54925492 66726772     .T.Trh.g.T.Trgrf
 802cee0:	42b242b2 42b242b2 4b124b12 4b124b12     .B.B.B.B.K.K.K.K
 802cef0:	41b241b2 41b241b2 5b015b01 50b150b1     .A.A.A.A.[.[.P.P
 802cf00:	56925692 5a425a42 5a325a32 53a253a2     .V.VBZBZ2Z2Z.S.S
 802cf10:	59525952 55925592 4a224a22 4a224a22     RYRY.U.U"J"J"J"J
 802cf20:	42a242a2 42a242a2 4a12f005 41a24a12     .B.B.B.B...J.J.A
 802cf30:	5a0141a2 40a15862 568240a1 43925942     .A.ZbX.@.@.VBY.C
 802cf40:	59324392 55825852 49225762 42924922     .C2YRX.UbW"I"I.B
 802cf50:	57524292 48325572 43824832 56624382     .BRWrU2H2H.C.CbV
 802cf60:	54725742 55625652 f0055372 39123912     BWrTRVbUrS...9.9
 802cf70:	39123912 31923192 31923192 49014901     .9.9.1.1.1.1.I.I
 802cf80:	40914091 48424842 44824482 42724272     .@.@BHBH.D.DrBrB
 802cf90:	54625642 38223822 38223822 32823282     BVbT"8"8"8"8.2.2
 802cfa0:	32823282 38123812 38123812 4732f004     .2.2.8.8.8.8..2G
 802cfb0:	37124722 31723712 45523172 40714701     "G.7.7r1r1RE.Gq@
 802cfc0:	43624632 44524542 42624622 f0034532     2FbCBERD"FbB2E..
 802cfd0:	21822182 30813801 31623612 30613601     .!.!.8.0.6b1.6a0
 802cfe0:	4352f004 35224442 32523522 35013252     ..RCBD"5"5R2R2.5
 802cff0:	25123501 25122512 21522512 21522152     .5.%.%.%.%R!R!R!
 802d000:	f0032152 33423432 34223051 33323242     R!..24B3Q0"4B223
 802d010:	24122412 1142f002 24011142 f0022041     .$.$..B.B..$A ..
 802d020:	22322322 13121312 1132f001 f0011301     "#2"......2.....
 802d030:	12221031 0082f003 008e008b 00940091     1.".............
 802d040:	3ce20097 f0033dd2 3eb20093 3f923be2     ...<.=.....>.;.?
 802d050:	3ae239f2 3bd23db2 3f82f003 3cc238f2     .9.:.=.;...?.8.<
 802d060:	3e82008d 27f20090 f00327f2 2ad22ad2     ...>...'.'...*.*
 802d070:	3cb23da2 36f23bc2 2f622f62 28e2f002     .=.<.;.6b/b/...(
 802d080:	2d922f52 f00229d2 27e225f2 2bb22ca2     R/.-.)...%.'.,.+
 802d090:	2f42f003 24f22f42 3ac224f2 23f236e2     ..B/B/.$.$.:.6.#
 802d0a0:	f00223f2 1f321f32 28d22d82 1f22f001     .#..2.2..-.(..".
 802d0b0:	f00212f2 2c922e62 1f011f01 29c2f002     ....b..,.......)
 802d0c0:	1ba22e52 f0021ba2 27d22d72 1e421e42     R.......r-.'B.B.
 802d0d0:	28c2f002 1e3226d2 f0021e32 19b219b2     ...(.&2.2.......
 802d0e0:	2aa22b92 1ab2f001 f00115e2 1c8214e2     .+.*............
 802d0f0:	1d62f001 f00113e2 1e011e22 10e1f001     ..b.....".......
 802d100:	f0011d52 1c7215d2 17c2f001 f0011d42     R.....r.....B...
 802d110:	18b21b82 14d2f001 f0011a92 1c6219a2     ..............b.
 802d120:	13d2f001 f0011b72 15c21c52 1992f001     ....r...R.......
 802d130:	f0011a72 179217a2 0023f003 2de23df2     r.........#..=.-
 802d140:	1ff22de2 1ff21ff2 f0011ff2 1fd21fe2     .-..............
 802d150:	1ee2f001 f0011fc2 1fb21ed2 1bf2f001     ................
 802d160:	f0021ec2 1cd21cd2 29e22fa2 1af2f001     ........./.)....
 802d170:	f0011dc2 1e921ea2 1f72f001 f0011e72     ..........r.r...
 802d180:	1cf21ef2 0101f008 01430122 01650154     ........".C.T.e.
 802d190:	017f0176 01990188 01ab01a2 01bd01b4     v...............
 802d1a0:	01cb01c2 01d901d4 01e301de 01ed01e8     ................
 802d1b0:	01f701f2 020101fc 02070204 020f020a     ................
 802d1c0:	02150212 021d021a 81920220 02260223     ........ ...#.&.
 802d1d0:	022c0229 8822022f 88128282 02328182     ).,./.".......2.
 802d1e0:	02380235 8722023b 84628272 85528712     5.8.;.".r.b...R.
 802d1f0:	023e8172 83628632 84528542 82628622     r.>.2.b.B.R.".b.
 802d200:	02418612 71628532 83527162 75228442     ..A.2.bqbqR.B."u
 802d210:	72527522 75127252 71527512 85017152     "uRrRr.u.uRqRq..
 802d220:	74328051 73427432 74227342 72427422     Q.2t2tBsBs"t"tBr
 802d230:	73327242 61427332 61426142 74126142     Br2s2sBaBaBaBa.t
 802d240:	74017412 63227401 63226322 62326322     .t.t.t"c"c"c"c2b
 802d250:	62326232 70416232 73017041 63127301     2b2b2bApAp.s.s.c
 802d260:	63126312 61326312 61326132 60316132     .c.c.c2a2a2a2a1`
 802d270:	60316031 52226031 52225222 52225222     1`1`1`"R"R"R"R"R
 802d280:	52225222 52125222 52125212 52125212     "R"R"R.R.R.R.R.R
 802d290:	52125212 51225212 51225122 51225122     .R.R.R"Q"Q"Q"Q"Q
 802d2a0:	51225122 52015122 52015201 52015201     "Q"Q"Q.R.R.R.R.R
 802d2b0:	52015201 50215201 50215021 50215021     .R.R.R!P!P!P!P!P
 802d2c0:	50215021 31125021 31123112 31123112     !P!P!P.1.1.1.1.1
 802d2d0:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802d2e0:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802d2f0:	31123112 31123112 31123112 31123112     .1.1.1.1.1.1.1.1
 802d300:	31123112 41013112 41014101 41014101     .1.1.1.A.A.A.A.A
 802d310:	41014101 41014101 41014101 41014101     .A.A.A.A.A.A.A.A
 802d320:	41014101 40114101 40114011 40114011     .A.A.A.@.@.@.@.@
 802d330:	40114011 40114011 40114011 40114011     .@.@.@.@.@.@.@.@
 802d340:	40114011 30004011 30003000 30003000     .@.@.@.0.0.0.0.0
 802d350:	30003000 30003000 30003000 30003000     .0.0.0.0.0.0.0.0
 802d360:	30003000 30003000 30003000 30003000     .0.0.0.0.0.0.0.0
 802d370:	30003000 30003000 30003000 30003000     .0.0.0.0.0.0.0.0
 802d380:	30003000 f0053000 5fe25ff2 5fd25ef2     .0.0.0..._._.^._
 802d390:	4ee24ee2 5fc25df2 5ed25cf2 5fb25de2     .N.N.]._.\.^.]._
 802d3a0:	4bf24bf2 5ce25ec2 4dd24dd2 4fa24fa2     .K.K.^.\.M.M.O.O
 802d3b0:	4af24af2 4eb24eb2 4be24be2 4dc24dc2     .J.J.N.N.K.K.M.M
 802d3c0:	4cd24cd2 4f924f92 49f2f005 4ae249f2     .L.L.O.O...I.I.J
 802d3d0:	4db24ae2 4bd24db2 4f824bd2 48f24f82     .J.M.M.K.K.O.O.H
 802d3e0:	4cc248f2 4e924cc2 49e24e92 4f7249e2     .H.L.L.N.N.I.IrO
 802d3f0:	47f24f72 4da247f2 4ad24da2 4cb24ad2     rO.G.G.M.M.J.J.L
 802d400:	4f624cb2 5ea24f62 f0045f01 3bc23bc2     .LbObO.^._...;.;
 802d410:	36f236f2 48e24e82 4d924f52 35f235f2     .6.6.N.HRO.M.5.5
 802d420:	3e723e72 37e237e2 3ca23ca2 3ac2f004     r>r>.7.7.<.<...:
 802d430:	3bb23ac2 49d23bb2 3f424d82 34f23f42     .:.;.;.I.MB?B?.4
 802d440:	3f3234f2 33f23f32 38d233f2 f00438d2     .42?2?.3.3.8.8..
 802d450:	36e236e2 3f223f22 32f232f2 40f14e62     .6.6"?"?.2.2bN.@
 802d460:	3f123f12 31f231f2 3c923c92 39c239c2     .?.?.1.1.<.<.9.9
 802d470:	3e52f003 3ab23ba2 3d7235e2 3e4237d2     ..R>.;.:.5r=.7B>
 802d480:	f00334e2 38c23c82 3d623e32 33e236d2     .4...<.82>b=.6.3
 802d490:	39b23b92 3e22f004 3aa23e22 32e23aa2     .;.9..">">.:.:.2
 802d4a0:	3e1232e2 31e23e12 4e0131e2 3d5240e1     .2.>.>.1.1.N.@R=
 802d4b0:	35d23d52 f00335d2 37c23c72 3b823d42     R=.5.5..r<.7B=.;
 802d4c0:	24d224d2 3a9238b2 39a2f003 36c23c62     .$.$.8.:...9b<.6
 802d4d0:	23d23d32 22d223d2 f00322d2 3d013d22     2=.#.#.".".."=.=
 802d4e0:	2d122d12 2b722b72 27b227b2 21d2f003     .-.-r+r+.'.'...!
 802d4f0:	3c5221d2 25c230d1 2a8225c2 f0022a82     .!R<.0.%.%.*.*..
 802d500:	2c4228a2 2b6224c2 26b2f003 399226b2     .(B,.$b+...&.&.9
 802d510:	2c323c01 23c22c32 f00323c2 2a722a72     .<2,2,.#.#..r*r*
 802d520:	27a227a2 26a226a2 3b0130c1 12c2f002     .'.'.&.&.0.;....
 802d530:	2c2212c2 f0022b52 2c1225b2 28922982     ..",R+...%.,.).(
 802d540:	21c2f002 24b22b42 f0022a62 29722b32     ...!B+.$b*..2+r)
 802d550:	13b213b2 2792f002 2b222882 f0022a52     .......'.("+R*..
 802d560:	12b212b2 2b1225a2 11b2f002 20b111b2     .....%.+....... 
 802d570:	f0022962 2a422692 287224a2 2782f002     b)...&B*.$r(...'
 802d580:	13a22a32 f00113a2 15921952 1a22f001     2*......R.....".
 802d590:	f00112a2 11a21a12 2a01f002 186220a1     ...........*. b.
 802d5a0:	f0011862 19421682 1492f001 f0021932     b.....B.....2...
 802d5b0:	13921392 29012772 1852f001 f0011582     ....r'.)..R.....
 802d5c0:	17621922 1672f001 f0011292 10911912     ".b...r.........
 802d5d0:	1842f001 f0011482 15721752 1832f001     ..B.....R.r...2.
 802d5e0:	f0011382 17421662 1472f001 f0011801     ....b.B...r.....
 802d5f0:	16521081 1562f001 f0011732 16421372     ..R...b.2...r.B.
 802d600:	1701f001 f0011071 10611601 0101f008     ....q.....a.....
 802d610:	0113010a 01188ff2 0120011d 013182f2     .......... ...1.
 802d620:	81f28f12 01450134 01670156 01890178     ....4.E.V.g.x...
 802d630:	01a3019a 01b501ac 01c701be 01d901d0     ................
 802d640:	01e301de 01eb01e6 815201f0 01f601f3     ..........R.....
 802d650:	01fc01f9 81428412 832201ff 73128232     ......B...".2..s
 802d660:	71327312 83017132 72228031 62127222     .s2q2q..1."r"r.b
 802d670:	62126212 61226212 61226122 62016122     .b.b.b"a"a"a"a.b
 802d680:	62016201 60216201 60216021 41126021     .b.b.b!`!`!`!`.A
 802d690:	41124112 41124112 41124112 41124112     .A.A.A.A.A.A.A.A
 802d6a0:	41124112 41124112 41124112 41014112     .A.A.A.A.A.A.A.A
 802d6b0:	41014101 41014101 41014101 41014101     .A.A.A.A.A.A.A.A
 802d6c0:	41014101 41014101 41014101 30114101     .A.A.A.A.A.A.A.0
 802d6d0:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802d6e0:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802d6f0:	30113011 30113011 30113011 30113011     .0.0.0.0.0.0.0.0
 802d700:	30113011 30113011 30113011 10003011     .0.0.0.0.0.0.0..
 802d710:	10001000 10001000 10001000 10001000     ................
 802d720:	10001000 10001000 10001000 10001000     ................
 802d730:	10001000 10001000 10001000 10001000     ................
 802d740:	10001000 10001000 10001000 10001000     ................
 802d750:	10001000 10001000 10001000 10001000     ................
 802d760:	10001000 10001000 10001000 10001000     ................
 802d770:	10001000 10001000 10001000 10001000     ................
 802d780:	10001000 10001000 10001000 10001000     ................
 802d790:	10001000 10001000 10001000 10001000     ................
 802d7a0:	10001000 10001000 10001000 10001000     ................
 802d7b0:	10001000 10001000 10001000 10001000     ................
 802d7c0:	10001000 10001000 10001000 10001000     ................
 802d7d0:	10001000 10001000 10001000 10001000     ................
 802d7e0:	10001000 10001000 10001000 10001000     ................
 802d7f0:	10001000 10001000 10001000 10001000     ................
 802d800:	10001000 10001000 10001000 f0031000     ................
 802d810:	3ef23fe2 3df23fd2 3cf23fc2 3bf23fb2     .?.>.?.=.?.<.?.;
 802d820:	2fa2f003 3af22fa2 39f23f92 2f8238f2     ..././.:.?.9.8./
 802d830:	f0022f82 27f22f72 26f22f62 2f52f002     ./..r/.'b/.&..R/
 802d840:	1f4225f2 f0011f42 13f214f2 10f1f004     .%B.B...........
 802d850:	10f110f1 10f110f1 10f110f1 2f3210f1     ..............2/
 802d860:	2f322f32 00e22f32 00fc00f3 f0010105     2/2/2/..........
 802d870:	1f011f22 00faf004 010400ff 010c0109     "...............
 802d880:	01160111 011e0119 01280123 012d43e2     ........#.(..C-.
 802d890:	01330130 f0040136 012b0128 4d01012e     0.3.6...(.+....M
 802d8a0:	01340131 4c320137 4c12013a 013d40c1     1.4.7.2L:..L.@=.
 802d8b0:	32e232e2 4e124e22 43d2f004 42d24d22     .2.2"N.N...C"M.B
 802d8c0:	4b3241d2 3d12012f 44c23d12 43c24b62     .A2K/..=.=.DbK.C
 802d8d0:	3c2247a2 42c23c22 f00445b2 4c0141c2     .G"<"<.B.E...A.L
 802d8e0:	44b24b42 46a24a62 33b233b2 45a24a52     BK.DbJ.F.3.3RJ.E
 802d8f0:	3b223b22 32b232b2 3b123b12 31b2f004     ";";.2.2.;.;...1
 802d900:	4b0131b2 496240b1 4a424692 487244a2     .1.K.@bI.FBJ.DrH
 802d910:	33a24782 4a3233a2 3a224952 f0043a22     .G.3.32JRI":":..
 802d920:	48624592 31a231a2 47724682 34923492     .EbH.1.1.FrG.4.4
 802d930:	47524942 37623762 22a222a2 22a222a2     BIRGb7b7."."."."
 802d940:	2a12f003 3a012a12 393230a1 38523392     ...*.*.:.029.3R8
 802d950:	f0033582 29222922 22922292 39013672     .5..")")."."r6.9
 802d960:	29122912 2192f003 30912192 34823842     .).)...!.!.0B8.4
 802d970:	38323572 f0033382 38223662 22822282     r528.3..b6"8."."
 802d980:	34723742 28122812 2182f003 20812182     B7r4.(.(...!.!. 
 802d990:	38012081 27323652 f0032732 23722372     . .8R62'2'..r#r#
 802d9a0:	36423562 27222722 22722272 3462f003     b5B6"'"'r"r"..b4
 802d9b0:	27013552 17122701 17121712 f0021712     R5.'.'..........
 802d9c0:	11721172 26322071 2362f002 24522542     r.r.q 2&..b#B%R$
 802d9d0:	f0012622 16121262 1162f002 26011162     "&..b.....b.b..&
 802d9e0:	f0022061 13521352 24422532 1522f001     a ..R.R.2%B$..".
 802d9f0:	f0011252 15011512 1432f001 f0011342     R.........2.B...
 802da00:	14221051 1242f001 f0011332 10411401     Q."...B.2.....A.
 802da10:	4ec2f004 3ed20086 39e23ed2 4ae239e2     ...N...>.>.9.9.J
 802da20:	2ee249d2 2ee22ee2 3de22ee2 3be23de2     .I.........=.=.;
 802da30:	f0033be2 2eb22eb2 2dc22dc2 3bd23cd2     .;.......-.-.<.;
 802da40:	2ea22ea2 2cc2f003 3da22cc2 3e723ad2     .......,.,.=.:r>
 802da50:	2ac23ca2 f0032ac2 3d7239c2 2e522e52     .<.*.*...9r=R.R.
 802da60:	1db21db2 1db21db2 1e92f002 2cb21e92     ...............,
 802da70:	f0022bc2 28e22e82 27e22d92 2bb2f002     .+.....(.-.'...+
 802da80:	28d22d82 f0012e62 1c9216e2 2ba2f002     .-.(b..........+
 802da90:	25e22ab2 f00227d2 1e421e42 2c8224e2     .*.%.'..B.B..$.,
 802daa0:	18c2f001 f0021e32 1d621d62 2b9226d2     ....2...b.b..&.+
 802dab0:	29b2f002 11e22aa2 f00211e2 14d214d2     ...).*..........
 802dac0:	29a228b2 1b72f002 27b21b72 f00120d1     .(.)..r.r..'. ..
 802dad0:	10e11e01 1d52f001 f00115d2 17c21c72     ......R.....r...
 802dae0:	1d42f001 f0011b82 1c621a92 16c2f001     ..B.......b.....
 802daf0:	f0011d32 15c21c52 1a82f001 f00118a2     2...R...........
 802db00:	1c421992 16b2f001 f0011a72 19821b52     ..B.....r...R...
 802db10:	1892f001 f0011972 18821792 1ce2f001     ....r...........
 802db20:	f0091dd2 8fe28fe2 8ef28ef2 8fd28fd2     ................
 802db30:	8df28df2 8fc28fc2 8cf28cf2 8fb28fb2     ................
 802db40:	8bf28bf2 7af27af2 7af27af2 8fa28fa2     .....z.z.z.z....
 802db50:	8f928f92 79f279f2 79f279f2 78f278f2     .....y.y.y.y.x.x
 802db60:	78f278f2 8f828f82 8f728f72 77f277f2     .x.x....r.r..w.w
 802db70:	77f277f2 7f627f62 7f627f62 76f276f2     .w.wb.b.b.b..v.v
 802db80:	76f276f2 7f527f52 7f527f52 75f275f2     .v.vR.R.R.R..u.u
 802db90:	75f275f2 7f427f42 7f427f42 74f274f2     .u.uB.B.B.B..t.t
 802dba0:	74f274f2 7f327f32 7f327f32 73f273f2     .t.t2.2.2.2..s.s
 802dbb0:	73f273f2 7f227f22 7f227f22 72f272f2     .s.s"."."."..r.r
 802dbc0:	72f272f2 71f271f2 71f271f2 8f128f12     .r.r.q.q.q.q....
 802dbd0:	80f180f1 02019f01 020b0206 02150210     ................
 802dbe0:	021f021a 4ff24ff2 4ff24ff2 4ff24ff2     .....O.O.O.O.O.O
 802dbf0:	4ff24ff2 4ff24ff2 4ff24ff2 4ff24ff2     .O.O.O.O.O.O.O.O
 802dc00:	4ff24ff2 4ff24ff2 4ff24ff2 4ff24ff2     .O.O.O.O.O.O.O.O
 802dc10:	4ff24ff2 4ff24ff2 4ff24ff2 4ff24ff2     .O.O.O.O.O.O.O.O
 802dc20:	4ff24ff2 02290224 02370232 023f023a     .O.O$.).2.7.:.?.
 802dc30:	02450242 024d024a 02530250 02590256     B.E.J.M.P.S.V.Y.
 802dc40:	025f025c 02650262 026b0268 0271026e     \._.b.e.h.k.n.q.
 802dc50:	02770274 027d027a 02830280 028b0288     t.w.z.}.........
 802dc60:	0291028e 02970294 029f029a 02a494b2     ................
 802dc70:	02aa02a7 988293b2 92b202af 02b502b2     ................
 802dc80:	94a29692 978202b8 93a29a32 95929952     ........2...R...
 802dc90:	92a29a22 986291a2 97729682 94929942     ".....b...r.B...
 802dca0:	93929932 95829852 97629922 92929672     2...R...".b.r...
 802dcb0:	91929912 94829842 95729752 93829832     ....B...R.r.2...
 802dcc0:	98229662 98129282 94729742 02bb9182     b.".....B.r.....
 802dcd0:	95629652 02be9712 83728372 97229732     R.b.....r.r.2.".
 802dce0:	82728272 86428642 84628462 85528552     r.r.B.B.b.b.R.R.
 802dcf0:	81728172 86328632 83628362 85428542     r.r.2.2.b.b.B.B.
 802dd00:	84528452 86228622 82628262 86128612     R.R.".".b.b.....
 802dd10:	81628162 90619601 85328532 83528352     b.b...a.2.2.R.R.
 802dd20:	84428442 85228522 82528252 85128512     B.B.".".R.R.....
 802dd30:	90519501 71527152 71527152 84328432     ..Q.RqRqRqRq2.2.
 802dd40:	83428342 74227422 74227422 72427242     B.B."t"t"t"tBrBr
 802dd50:	72427242 73327332 73327332 74127412     BrBr2s2s2s2s.t.t
 802dd60:	74127412 71427142 71427142 84018401     .t.tBqBqBqBq....
 802dd70:	80418041 73227322 73227322 72327232     A.A."s"s"s"s2r2r
 802dd80:	72327232 63126312 63126312 63126312     2r2r.c.c.c.c.c.c
 802dd90:	63126312 61326132 61326132 61326132     .c.c2a2a2a2a2a2a
 802dda0:	61326132 73017301 73017301 70317031     2a2a.s.s.s.s1p1p
 802ddb0:	70317031 62226222 62226222 62226222     1p1p"b"b"b"b"b"b
 802ddc0:	62226222 52125212 52125212 52125212     "b"b.R.R.R.R.R.R
 802ddd0:	52125212 52125212 52125212 52125212     .R.R.R.R.R.R.R.R
 802dde0:	52125212 51225122 51225122 51225122     .R.R"Q"Q"Q"Q"Q"Q
 802ddf0:	51225122 51225122 51225122 51225122     "Q"Q"Q"Q"Q"Q"Q"Q
 802de00:	51225122 62016201 62016201 62016201     "Q"Q.b.b.b.b.b.b
 802de10:	62016201 60216021 60216021 60216021     .b.b!`!`!`!`!`!`
 802de20:	60216021 41124112 41124112 41124112     !`!`.A.A.A.A.A.A
 802de30:	41124112 41124112 41124112 41124112     .A.A.A.A.A.A.A.A
 802de40:	41124112 41124112 41124112 41124112     .A.A.A.A.A.A.A.A
 802de50:	41124112 41124112 41124112 41124112     .A.A.A.A.A.A.A.A
 802de60:	41124112 41014101 41014101 41014101     .A.A.A.A.A.A.A.A
 802de70:	41014101 41014101 41014101 41014101     .A.A.A.A.A.A.A.A
 802de80:	41014101 41014101 41014101 41014101     .A.A.A.A.A.A.A.A
 802de90:	41014101 41014101 41014101 41014101     .A.A.A.A.A.A.A.A
 802dea0:	41014101 40114011 40114011 40114011     .A.A.@.@.@.@.@.@
 802deb0:	40114011 40114011 40114011 40114011     .@.@.@.@.@.@.@.@
 802dec0:	40114011 40114011 40114011 40114011     .@.@.@.@.@.@.@.@
 802ded0:	40114011 40114011 40114011 40114011     .@.@.@.@.@.@.@.@
 802dee0:	40114011 40004000 40004000 40004000     .@.@.@.@.@.@.@.@
 802def0:	40004000 40004000 40004000 40004000     .@.@.@.@.@.@.@.@
 802df00:	40004000 40004000 40004000 40004000     .@.@.@.@.@.@.@.@
 802df10:	40004000 40004000 40004000 40004000     .@.@.@.@.@.@.@.@
 802df20:	40004000 2ee2f002 2de22ed2 f0022ec2     .@.@.......-....
 802df30:	2dd22ce2 2be22eb2 2dc2f002 2ea22cd2     .,.-...+...-.,..
 802df40:	f0022ae2 2bd22db2 2e922cc2 29e2f002     .*...-.+.,.....)
 802df50:	2ad22da2 f0022cb2 2e822bc2 2d9228e2     .-.*.,...+...(.-
 802df60:	29d2f002 27e22e72 f0022ca2 2bb22ac2     ...)r..'.,...*.+
 802df70:	28d22d82 3e01f003 2d0130e1 16e22d01     .-.(...>.0.-.-..
 802df80:	16e216e2 f00216e2 2c922e62 19c219c2     ........b..,....
 802df90:	1e52f001 f0021ab2 15e215e2 2d722ba2     ..R..........+r-
 802dfa0:	17d2f001 f00114e2 18c21c82 2e42f002     ..............B.
 802dfb0:	1e322e22 f0011e32 16d21d62 13e2f001     ".2.2...b.......
 802dfc0:	f0011b92 1aa219b2 12e2f001 f0011e12     ................
 802dfd0:	1d5211e2 15d2f001 f0011c72 1d4217c2     ..R.....r.....B.
 802dfe0:	1b82f001 f00118b2 1a9214d2 19a2f001     ................
 802dff0:	f0011c62 1d3216c2 13d2f001 f0011d22     b.....2....."...
 802e000:	1d1212d2 1b72f001 f00117b2 1c5211d2     ......r.......R.
 802e010:	15c2f001 f0011a82 199218a2 1c42f001     ..............B.
 802e020:	f00114c2 16b21b62 20d1f002 1c322c01     ....b...... .,2.
 802e030:	f0011c32 1a7213c2 17a2f001 f0011c22     2.....r....."...
 802e040:	1b5212c2 15b2f001 f0011c12 18921982     ..R.............
 802e050:	11c2f001 f0021b42 2b0120c1 1b321b32     ....B.... .+2.2.
 802e060:	20b1f002 1a122a01 f0011a12 16a21a62     ... .*......b...
 802e070:	1972f001 f0021792 290120a1 10911091     ..r...... .)....
 802e080:	1b22f001 f0011a52 1b1215a2 11b2f001     ..".R...........
 802e090:	f0011962 18721a42 1801f001 f0011081     b...B.r.........
 802e0a0:	10711701                                ..q.

0802e0a4 <xmp3_huffTabOffset>:
	...
 802e0ac:	00000009 0000004a 00000000 0000008b     ....J...........
 802e0bc:	0000018c 0000020d 0000027b 00000393     ........{.......
 802e0cc:	000003f0 00000530 00000658 00000711     ....0...X.......
 802e0dc:	00000000 00000902 00000b46 00000b46     ........F...F...
 802e0ec:	00000b46 00000b46 00000b46 00000b46     F...F...F...F...
 802e0fc:	00000b46 00000b46 00000dd1 00000dd1     F...F...........
 802e10c:	00000dd1 00000dd1 00000dd1 00000dd1     ................
 802e11c:	00000dd1 00000dd1                       ........

0802e124 <xmp3_huffTabLookup>:
	...
 802e130:	00000001 00000000 00000001 00000000     ................
 802e140:	00000001 00000000 00000006 00000000     ................
 802e150:	00000001 00000000 00000001 00000000     ................
 802e160:	00000002 00000000 00000002 00000000     ................
 802e170:	00000002 00000000 00000002 00000000     ................
 802e180:	00000002 00000000 00000002 00000000     ................
 802e190:	00000002 00000000 00000006 00000000     ................
 802e1a0:	00000002 00000001 00000003 00000002     ................
 802e1b0:	00000003 00000003 00000003 00000004     ................
 802e1c0:	00000003 00000006 00000003 00000008     ................
 802e1d0:	00000003 0000000a 00000003 0000000d     ................
 802e1e0:	00000003 00000004 00000003 00000005     ................
 802e1f0:	00000003 00000006 00000003 00000007     ................
 802e200:	00000003 00000008 00000003 00000009     ................
 802e210:	00000003 0000000b 00000003 0000000d     ................
 802e220:	00000003                                ....

0802e224 <xmp3_quadTable>:
 802e224:	6e6d6f6b 59596567 53535656 5c5c5a5a     komngeYYVVSSZZ\\
 802e234:	42424242 41414141 44444444 48484848     BBBBAAAADDDDHHHH
 802e244:	10101010 10101010 10101010 10101010     ................
 802e254:	10101010 10101010 10101010 10101010     ................
 802e264:	4c4d4e4f 48494a4b 44454647 40414243     ONMLKJIHGFEDCBA@

0802e274 <xmp3_quadTabOffset>:
 802e274:	00000000 00000040                       ....@...

0802e27c <xmp3_quadTabMaxBits>:
 802e27c:	00000006 00000004                       ........

0802e284 <c9_0>:
 802e284:	6ed9eba1                                ...n

0802e288 <c9_1>:
 802e288:	620dbe8b                                ...b

0802e28c <c9_2>:
 802e28c:	163a1a7e                                ~.:.

0802e290 <c9_3>:
 802e290:	5246dd49                                I.FR

0802e294 <c9_4>:
 802e294:	7e0e2e32                                2..~

0802e298 <c18>:
 802e298:	7f834ed0 7ba3751d 7401e4c1 68d9f964     .N...u.{...td..h
 802e2a8:	5a82799a 496af3e2 36185aee 2120fb83     .y.Z..jI.Z.6.. !
 802e2b8:	0b27eb5c                                \.'.

0802e2bc <fastWin36>:
 802e2bc:	42aace8b c2e92724 47311c28 c95f619a     ...B$'..(.1G.a_.
 802e2cc:	4a868feb d0859d8c 4c913b51 d8243ea0     ...J....Q;.L.>$.
 802e2dc:	4d413ccc e0000000 4c913b51 e7dbc161     .<AM....Q;.La...
 802e2ec:	4a868feb ef7a6275 47311c28 f6a09e67     ...Jubz.(.1Gg...
 802e2fc:	42aace8b fd16d8dd                       ...B....

0802e304 <c3_0>:
 802e304:	6ed9eba1                                ...n

0802e308 <c6>:
 802e308:	7ba3751d 5a82799a 2120fb83              .u.{.y.Z.. !

0802e314 <SFLenTab>:
 802e314:	01000000 03000200 01010003 03010201     ................
 802e324:	02020102 01030302 03030203 03040204     ................

0802e334 <NRTab>:
 802e334:	05050506 03030303 03030306 03070506     ................
 802e344:	02040303 02040306 00000a0b 00000606     ................
 802e354:	00060306 00070707 00040404 00040506     ................
 802e364:	03060606 02030304 02030406 00050808     ................
 802e374:	00030405 00030606                       ........

0802e37c <xmp3_imdctWin>:
 802e37c:	02aace8b 07311c28 0a868fec 0c913b52     ....(.1.....R;..
 802e38c:	0d413ccd 0c913b52 0a868fec 07311c28     .<A.R;......(.1.
 802e39c:	02aace8b fd16d8dd f6a09e66 ef7a6275     ........f...ubz.
 802e3ac:	e7dbc161 e0000000 d8243e9f d0859d8b     a........>$.....
 802e3bc:	c95f619a c2e92723 bd553175 b8cee3d8     .a_.#'..u1U.....
 802e3cc:	b5797014 b36ec4ae b2bec333 b36ec4ae     .py...n.3.....n.
 802e3dc:	b5797014 b8cee3d8 bd553175 c2e92723     .py.....u1U.#'..
 802e3ec:	c95f619a d0859d8b d8243e9f e0000000     .a_......>$.....
 802e3fc:	e7dbc161 ef7a6275 f6a09e66 fd16d8dd     a...ubz.f.......
 802e40c:	02aace8b 07311c28 0a868fec 0c913b52     ....(.1.....R;..
 802e41c:	0d413ccd 0c913b52 0a868fec 07311c28     .<A.R;......(.1.
 802e42c:	02aace8b fd16d8dd f6a09e66 ef7a6275     ........f...ubz.
 802e43c:	e7dbc161 e0000000 d8243e9f d0859d8b     a........>$.....
 802e44c:	c95f619a c2e92723 bd44ef14 b831a052     .a_.#'....D.R.1.
 802e45c:	b3aa3837 afb789a4 ac6145bb a9adecdc     78.......Ea.....
 802e46c:	a864491f ad1868f0 b8431f49 c8f42236     .Id..h..I.C.6"..
 802e47c:	dda8e6b1 f47755dc 00000000 00000000     .....Uw.........
	...
 802e49c:	07311c28 0d413ccd 07311c28 f6a09e66     (.1..<A.(.1.f...
 802e4ac:	e0000000 c95f619a b8cee3d8 b2bec333     .....a_.....3...
 802e4bc:	b8cee3d8 c95f619a e0000000 f6a09e66     .....a_.....f...
	...
 802e544:	028e9709 04855ec0 026743a1 fcde2c10     .....^...Cg..,..
 802e554:	f515dc82 ec93e53b e4c880f8 dd5d0b08     ....;.........].
 802e564:	d63510b7 cf5e834a c8e6b562 c2da4105     ..5.J.^.b....A..
 802e574:	bd553175 b8cee3d8 b5797014 b36ec4ae     u1U......py...n.
 802e584:	b2bec333 b36ec4ae b5797014 b8cee3d8     3.....n..py.....
 802e594:	bd553175 c2e92723 c95f619a d0859d8b     u1U.#'...a_.....
 802e5a4:	d8243e9f e0000000 e7dbc161 ef7a6275     .>$.....a...ubz.
 802e5b4:	f6a09e66 fd16d8dd                       f.......

0802e5bc <xmp3_ISFMpeg1>:
 802e5bc:	00000000 0d8658ba 176cf5d0 20000000     .....X....l.... 
 802e5cc:	28930a2f 3279a745 40000000 00000000     /..(E.y2...@....
 802e5dc:	13207f5c 2120fb83 2d413ccc 39617e16     \. ... !.<A-.~a9
 802e5ec:	4761fa3d 5a827999                       =.aG.y.Z

0802e5f4 <xmp3_ISFMpeg2>:
 802e5f4:	40000000 35d13f32 2d413ccc 260dfc14     ...@2?.5.<A-...&
 802e604:	1fffffff 1ae89f99 16a09e66 1306fe0a     ........f.......
 802e614:	0fffffff 0d744fcc 0b504f33 09837f05     .....Ot.3OP.....
 802e624:	07ffffff 06ba27e6 05a82799 04c1bf82     .....'...'......
 802e634:	5a827999 4c1bf827 3fffffff 35d13f32     .y.Z'..L...?2?.5
 802e644:	2d413ccc 260dfc13 1fffffff 1ae89f99     .<A-...&........
 802e654:	16a09e66 1306fe09 0fffffff 0d744fcc     f............Ot.
 802e664:	0b504f33 09837f04 07ffffff 06ba27e6     3OP..........'..
 802e674:	40000000 2d413ccc 20000000 16a09e66     ...@.<A-... f...
 802e684:	10000000 0b504f33 08000000 05a82799     ....3OP......'..
 802e694:	04000000 02d413cc 02000000 016a09e6     ..............j.
 802e6a4:	01000000 00b504f3 00800000 005a8279     ............y.Z.
 802e6b4:	5a827999 3fffffff 2d413ccc 1fffffff     .y.Z...?.<A-....
 802e6c4:	16a09e66 0fffffff 0b504f33 07ffffff     f.......3OP.....
 802e6d4:	05a82799 03ffffff 02d413cc 01ffffff     .'..............
 802e6e4:	016a09e6 00ffffff 00b504f3 007fffff     ..j.............

0802e6f4 <xmp3_ISFIIP>:
 802e6f4:	40000000 00000000 40000000 40000000     ...@.......@...@

0802e704 <xmp3_csa>:
 802e704:	6dc253f0 be2500aa 70dcebe4 c39e4949     .S.m..%....pII..
 802e714:	798d6e73 d7e33f4a 7ddd40a7 e8b71176     sn.yJ?...@.}v...
 802e724:	7f6d20b7 f3e4fe2f 7fe47e40 fac1a3c7     . m./...@~......
 802e734:	7ffcb263 fe2ebdc6 7fffc694 ff86c25d     c...........]...

0802e744 <xmp3_polyCoef>:
 802e744:	00000000 00000074 00000354 0000072c     ....t...T...,...
 802e754:	00001fd4 00005084 000066b8 000249c4     .....P...f...I..
 802e764:	00049478 fffdb63c 000066b8 ffffaf7c     x...<....f..|...
 802e774:	00001fd4 fffff8d4 00000354 ffffff8c     ........T.......
 802e784:	fffffffc 00000068 00000368 00000644     ....h...h...D...
 802e794:	00001f40 00004ad0 00005d1c 00022ce0     @....J...]...,..
 802e7a4:	000493c0 fffd9960 00006f78 ffffa9cc     ....`...xo......
 802e7b4:	0000203c fffff7e4 00000340 ffffff84     < ......@.......
 802e7c4:	fffffffc 00000060 00000378 0000056c     ....`...x...l...
 802e7d4:	00001e80 00004524 000052a0 00020ffc     ....$E...R......
 802e7e4:	000491a0 fffd7ca0 00007760 ffffa424     .....|..`w..$...
 802e7f4:	00002080 fffff6ec 00000328 ffffff74     . ......(...t...
 802e804:	fffffffc 00000054 00000384 00000498     ....T...........
 802e814:	00001d94 00003f7c 00004744 0001f32c     ....|?..DG..,...
 802e824:	00048e18 fffd6008 00007e70 ffff9e8c     .....`..p~......
 802e834:	0000209c fffff5ec 00000310 ffffff68     . ..........h...
 802e844:	fffffffc 0000004c 0000038c 000003d0     ....L...........
 802e854:	00001c78 000039e4 00003b00 0001d680     x....9...;......
 802e864:	00048924 fffd43ac 000084b0 ffff990c     $....C..........
 802e874:	00002094 fffff4e4 000002f8 ffffff5c     . ..........\...
 802e884:	fffffffc 00000044 00000390 00000314     ....D...........
 802e894:	00001b2c 0000345c 00002ddc 0001ba04     ,...\4...-......
 802e8a4:	000482d0 fffd279c 00008a20 ffff93a4     .....'.. .......
 802e8b4:	0000206c fffff3d4 000002dc ffffff4c     l ..........L...
 802e8c4:	fffffffc 00000040 00000390 00000264     ....@.......d...
 802e8d4:	000019b0 00002ef0 00001fd4 00019dc8     ................
 802e8e4:	00047b1c fffd0be8 00008ecc ffff8e64     .{..........d...
 802e8f4:	00002024 fffff2c0 000002c0 ffffff3c     $ ..........<...
 802e904:	fffffff8 00000038 0000038c 000001bc     ....8...........
 802e914:	000017fc 0000299c 000010e8 000181d8     .....)..........
 802e924:	0004720c fffcf09c 000092b4 ffff894c     .r..........L...
 802e934:	00001fc0 fffff1a4 000002a4 ffffff2c     ............,...
 802e944:	fffffff8 00000034 00000380 00000120     ....4....... ...
 802e954:	00001618 00002468 00000118 00016644     ....h$......Df..
 802e964:	000467a4 fffcd5cc 000095e0 ffff8468     .g..........h...
 802e974:	00001f44 fffff084 00000284 ffffff18     D...............
 802e984:	fffffff8 0000002c 00000374 00000090     ....,...t.......
 802e994:	00001400 00001f58 fffff068 00014b14     ....X...h....K..
 802e9a4:	00045bf0 fffcbb88 00009858 ffff7fbc     .[......X.......
 802e9b4:	00001ea8 ffffef60 00000268 ffffff04     ....`...h.......
 802e9c4:	fffffff8 00000028 0000035c 00000008     ....(...\.......
 802e9d4:	000011ac 00001a70 ffffded8 00013058     ....p.......X0..
 802e9e4:	00044ef8 fffca1d8 00009a1c ffff7b54     .N..........T{..
 802e9f4:	00001dfc ffffee3c 0000024c fffffef0     ....<...L.......
 802ea04:	fffffff4 00000024 00000340 ffffff8c     ....$...@.......
 802ea14:	00000f28 000015b0 ffffcc70 0001161c     (.......p.......
 802ea24:	000440bc fffc88d8 00009b3c ffff7734     .@......<...4w..
 802ea34:	00001d38 ffffed18 0000022c fffffedc     8.......,.......
 802ea44:	fffffff4 00000020 00000320 ffffff1c     .... ... .......
 802ea54:	00000c68 0000111c ffffb92c 0000fc6c     h.......,...l...
 802ea64:	00043150 fffc708c 00009bb8 ffff7368     P1...p......hs..
 802ea74:	00001c64 ffffebf4 00000210 fffffec4     d...............
 802ea84:	fffffff0 0000001c 000002f4 fffffeb4     ................
 802ea94:	00000974 00000cb8 ffffa518 0000e350     t...........P...
 802eaa4:	000420b4 fffc5908 00009b9c ffff6ff4     . ...Y.......o..
 802eab4:	00001b7c ffffead0 000001f4 fffffeac     |...............
 802eac4:	fffffff0 0000001c 000002c4 fffffe58     ............X...
 802ead4:	00000648 00000884 ffff9038 0000cad0     H.......8.......
 802eae4:	00040ef8 fffc425c 00009af0 ffff6ce0     ....\B.......l..
 802eaf4:	00001a88 ffffe9b0 000001d4 fffffe94     ................
 802eb04:	ffffffec 00000018 0000028c fffffe04     ................
 802eb14:	000002e4 00000480 ffff7a90 0000b2fc     .........z......
 802eb24:	0003fc28 fffc2c90 000099b8 ffff6a3c     (....,......<j..
 802eb34:	00001988 ffffe898 000001bc fffffe7c     ............|...
 802eb44:	000001a0 0000187c 000097fc 0003e84c     ....|.......L...
 802eb54:	ffff6424 ffffff4c 00000248 ffffffec     $d..L...H.......

0802eb64 <xmp3_samplerateTab>:
 802eb64:	0000ac44 0000bb80 00007d00 00005622     D........}.."V..
 802eb74:	00005dc0 00003e80 00002b11 00002ee0     .]...>...+......
 802eb84:	00001f40                                @...

0802eb88 <xmp3_bitrateTab>:
 802eb88:	00200000 00600040 00a00080 00e000c0     .. .@.`.........
 802eb98:	01200100 01600140 01a00180 000001c0     .. .@.`.........
 802eba8:	00300020 00400038 00600050 00800070      .0.8.@.P.`.p...
 802ebb8:	00c000a0 010000e0 01800140 00200000     ........@..... .
 802ebc8:	00300028 00400038 00600050 00800070     (.0.8.@.P.`.p...
 802ebd8:	00c000a0 010000e0 00000140 00300020     ........@... .0.
 802ebe8:	00400038 00600050 00800070 00a00090     8.@.P.`.p.......
 802ebf8:	00c000b0 010000e0 00080000 00180010     ................
 802ec08:	00280020 00380030 00500040 00700060      .(.0.8.@.P.`.p.
 802ec18:	00900080 000000a0 00100008 00200018     .............. .
 802ec28:	00300028 00400038 00600050 00800070     (.0.8.@.P.`.p...
 802ec38:	00a00090 00200000 00380030 00500040     ...... .0.8.@.P.
 802ec48:	00700060 00900080 00b000a0 00e000c0     `.p.............
 802ec58:	00000100 00100008 00200018 00300028     .......... .(.0.
 802ec68:	00400038 00600050 00800070 00a00090     8.@.P.`.p.......
 802ec78:	00080000 00180010 00280020 00380030     ........ .(.0.8.
 802ec88:	00500040 00700060 00900080 000000a0     @.P.`.p.........

0802ec98 <xmp3_samplesPerFrameTab>:
 802ec98:	04800180 01800480 02400480 04800180     ..........@.....
 802eca8:	00000240                                @...

0802ecac <xmp3_sideBytesTab>:
 802ecac:	00200011 00110009 00110009              .. .........

0802ecb8 <xmp3_slotTab>:
 802ecb8:	00680000 009c0082 00d000b6 01390105     ..h...........9.
 802ecc8:	01a1016d 0272020a 034302db 00000414     m.....r...C.....
 802ecd8:	00780060 00a80090 00f000c0 01500120     `.x......... .P.
 802ece8:	01e00180 02a00240 03c00300 00900000     ....@...........
 802ecf8:	00d800b4 012000fc 01b00168 024001f8     ...... .h.....@.
 802ed08:	036002d0 048003f0 000005a0 0034001a     ..`...........4.
 802ed18:	0068004e 009c0082 00d000b6 01390105     N.h...........9.
 802ed28:	01a1016d 020a01d6 00180000 00480030     m...........0.H.
 802ed38:	00780060 00a80090 00f000c0 01500120     `.x......... .P.
 802ed48:	01b00180 000001e0 00480024 0090006c     ........$.H.l...
 802ed58:	00d800b4 012000fc 01b00168 024001f8     ...... .h.....@.
 802ed68:	02d00288 00340000 009c0068 010500d0     ......4.h.......
 802ed78:	016d0139 020a01a1 02db0272 03ac0343     9.m.....r...C...
 802ed88:	00000414 00600030 00c00090 012000f0     ....0.`....... .
 802ed98:	01800150 024001e0 030002a0 03c00360     P.....@.....`...
 802eda8:	00480000 00d80090 01680120 01f801b0     ..H..... .h.....
 802edb8:	02d00240 03f00360 05100480 000005a0     @...`...........

0802edc8 <xmp3_sfBandTable>:
 802edc8:	00040000 000c0008 00140010 001e0018     ................
 802edd8:	002c0024 003e0034 005a004a 0086006e     $.,.4.>.J.Z.n...
 802ede8:	00c400a2 012000ee 01a20156 00000240     ...... .V...@...
 802edf8:	00080004 0010000c 001e0016 00340028     ............(.4.
 802ee08:	00540042 0088006a 000000c0 00080004     B.T.j...........
 802ee18:	0010000c 00180014 0024001e 0032002a     ..........$.*.2.
 802ee28:	0048003c 006a0058 009c0080 00e600be     <.H.X.j.........
 802ee38:	014a0114 02400180 00040000 000c0008     ..J...@.........
 802ee48:	00160010 0026001c 00400032 00640050     ......&.2.@.P.d.
 802ee58:	00c0007e 00040000 000c0008 00140010     ~...............
 802ee68:	001e0018 002c0024 00420036 00660052     ....$.,.6.B.R.f.
 802ee78:	009c007e 00f000c2 016c0128 022601c0     ~.......(.l...&.
 802ee88:	00000240 00080004 0010000c 001e0016     @...............
 802ee98:	003a002a 0068004e 00b4008a 000000c0     *.:.N.h.........
 802eea8:	000c0006 00180012 0024001e 0036002c     ..........$.,.6.
 802eeb8:	00500042 00740060 00a8008c 00ee00c8     B.P.`.t.........
 802eec8:	0150011c 01d0018c 0240020a 00040000     ..P.......@.....
 802eed8:	000c0008 00180012 002a0020 004a0038     ........ .*.8.J.
 802eee8:	00840064 00c000ae 00060000 0012000c     d...............
 802eef8:	001e0018 002c0024 00420036 00600050     ....$.,.6.B.P.`.
 802ef08:	00880072 00c200a2 011600e8 018a014c     r...........L...
 802ef18:	021c01d0 00000240 00080004 0012000c     ....@...........
 802ef28:	0024001a 003e0030 00680050 00b40088     ..$.0.>.P.h.....
 802ef38:	000000c0 000c0006 00180012 0024001e     ..............$.
 802ef48:	0036002c 00500042 00740060 00a8008c     ,.6.B.P.`.t.....
 802ef58:	00ee00c8 0150011c 01d0018c 0240020a     ......P.......@.
 802ef68:	00040000 000c0008 001a0012 00300024     ............$.0.
 802ef78:	0050003e 00860068 00c000ae 00060000     >.P.h...........
 802ef88:	0012000c 001e0018 002c0024 00420036     ........$.,.6.B.
 802ef98:	00600050 008c0074 00c800a8 011c00ee     P.`.t...........
 802efa8:	018c0150 020a01d0 00000240 00080004     P.......@.......
 802efb8:	0012000c 0024001a 003e0030 00680050     ......$.0.>.P.h.
 802efc8:	00ae0086 000000c0 000c0006 00180012     ................
 802efd8:	0024001e 0036002c 00500042 00740060     ..$.,.6.B.P.`.t.
 802efe8:	00a8008c 00ee00c8 0150011c 01d0018c     ..........P.....
 802eff8:	0240020a 00040000 000c0008 001a0012     ..@.............
 802f008:	00300024 0050003e 00860068 00c000ae     $.0.>.P.h.......
 802f018:	000c0000 00240018 003c0030 00580048     ......$.0.<.H.X.
 802f028:	0084006c 00c000a0 011800e8 01900150     l...........P...
 802f038:	023601dc 023a0238 023e023c 00000240     ..6.8.:.<.>.@...
 802f048:	00100008 00240018 00480034 007c0060     ......$.4.H.`.|.
 802f058:	00a200a0 00a600a4 000000c0 00000000     ................

0802f068 <_ZTV11CGraphicLCD>:
	...
 802f070:	08022195 08022195 08022195 08022195     .!...!...!...!..
 802f080:	08022195 08022195 08022195 08022195     .!...!...!...!..
 802f090:	08022195 080182d9 0801830d 00000000     .!..............

0802f0a0 <_ZTV13CT6963CDriver>:
	...
 802f0a8:	0801860d 08018929 08018a79 08018dc1     ....)...y.......
 802f0b8:	08018f05 08018f65 08018705 080190e9     ....e...........
 802f0c8:	080183e1 08018389 080183c1 08022195     .............!..
 802f0d8:	08022195 08022195 08022195 08022195     .!...!...!...!..

0802f0e8 <_ZTV21CT6963_GPIO_Interface>:
	...
 802f0f0:	0801860d 08018929 08018a79 08018dc1     ....)...y.......
 802f100:	08018f05 08018f65 08018705 080190e9     ....e...........
 802f110:	080183e1 080191e5 0801921d 080192f9     ................
 802f120:	080193b9 080193f1 0801949d 08019569     ............i...

0802f130 <c_FontSansSerif12>:
 802f130:	00000000 00000012 0802f148 0802fc88     ........H.......
 802f140:	0802fd88 0802fde4                       ........

0802f148 <_ZL35Microsoft_Sans_Serif__12_char_table>:
	...
 802f15c:	001c0000 00220022 00410041 00410041     ....".".A.A.A.A.
 802f16c:	00410041 00220022 0000001c 00000000     A.A.".".........
 802f17c:	00000000 10107010 10101010 10101010     .....p..........
	...
 802f194:	0022001c 00010041 00020001 00080004     ..".A...........
 802f1a4:	00200010 007f0040 00000000 00000000     .. .@...........
 802f1b4:	00000000 0022001c 00010041 000c0002     ......".A.......
 802f1c4:	00010002 00410001 001c0022 00000000     ......A.".......
	...
 802f1dc:	00060002 000a0006 00120012 00420022     ............".B.
 802f1ec:	0002007f 00020002 00000000 00000000     ................
 802f1fc:	00000000 0040007f 00400040 0062005c     ......@.@.@.\.b.
 802f20c:	00010001 00410001 001c0022 00000000     ......A.".......
	...
 802f224:	0022001c 00400041 0062005c 00410041     ..".A.@.\.b.A.A.
 802f234:	00410041 001c0022 00000000 00000000     A.A."...........
 802f244:	00000000 0001007f 00020001 00020002     ................
 802f254:	00040004 00080004 00080008 00000000     ................
	...
 802f26c:	0022001c 00410041 001c0022 00410022     ..".A.A."...".A.
 802f27c:	00410041 001c0022 00000000 00000000     A.A."...........
 802f28c:	00000000 0022001c 00410041 00410041     ......".A.A.A.A.
 802f29c:	001d0023 00410001 001c0022 00000000     #.....A.".......
	...
 802f2b4:	00020002 00050005 80088008 c01f4010     .............@..
 802f2c4:	20202020 10401040 00000000 00000000         @.@.........
 802f2d4:	00000000 0041007e 80408040 007e0041     ....~.A.@.@.A.~.
 802f2e4:	80400041 80408040 007e0041 00000000     A.@.@.@.A.~.....
	...
 802f2fc:	c030000f 20404020 00400040 00400040     ..0. @@ @.@.@.@.
 802f30c:	40202040 000fc030 00000000 00000000     @  @0...........
 802f31c:	00000000 8041007e 40408040 40404040     ....~.A.@.@@@@@@
 802f32c:	40404040 80404040 007e8041 00000000     @@@@@@@.A.~.....
	...
 802f344:	0040807f 00400040 007f0040 00400040     ..@.@.@.@...@.@.
 802f354:	00400040 807f0040 00000000 00000000     @.@.@...........
 802f364:	00000000 0040807f 00400040 007f0040     ......@.@.@.@...
 802f374:	00400040 00400040 00400040 00000000     @.@.@.@.@.@.....
	...
 802f38c:	c030000f 20404020 00400040 2040e041     ..0. @@ @.@.A.@ 
 802f39c:	60202040 200fe030 00000000 00000000     @  `0.. ........
 802f3ac:	00000000 80408040 80408040 807f8040     ....@.@.@.@.@...
 802f3bc:	80408040 80408040 80408040 00000000     @.@.@.@.@.@.....
 802f3cc:	00000000 40400000 40404040 40404040     ......@@@@@@@@@@
 802f3dc:	00004040 00000000 02020202 02020202     @@..............
 802f3ec:	3c424242 00000000 00000000 00420041     BBB<........A.B.
 802f3fc:	00480044 00600050 00480050 00420044     D.H.P.`.P.H.D.B.
 802f40c:	80400041 00000000 00000000 00000000     A.@.............
 802f41c:	00400040 00400040 00400040 00400040     @.@.@.@.@.@.@.@.
 802f42c:	00400040 007f0040 00000000 00000000     @.@.@...........
 802f43c:	00000000 40404040 c060c060 40514051     ....@@@@`.`.Q@Q@
 802f44c:	404a404a 40444044 40404040 00000000     J@J@D@D@@@@@....
	...
 802f464:	00610041 00510061 00490051 00450049     A.a.a.Q.Q.I.I.E.
 802f474:	00430045 00410043 00000000 00000000     E.C.C.A.........
 802f484:	00000000 c030000f 20404020 20402040     ......0. @@ @ @ 
 802f494:	20402040 40202040 000fc030 00000000     @ @ @  @0.......
	...
 802f4ac:	0041007e 80408040 00418040 0040007e     ~.A.@.@.@.A.~.@.
 802f4bc:	00400040 00400040 00000000 00000000     @.@.@.@.........
 802f4cc:	00000000 c030000f 20404020 20402040     ......0. @@ @ @ 
 802f4dc:	20402040 40212042 400fc030 00002000     @ @ B !@0..@. ..
	...
 802f4f4:	0041007e 80408040 00418040 0041007e     ~.A.@.@.@.A.~.A.
 802f504:	80408040 40408040 00000000 00000000     @.@.@.@@........
 802f514:	00000000 8020001f 00404040 001f0020     ...... .@@@. ...
 802f524:	40008000 40404000 001f8020 00000000     ...@.@@@ .......
	...
 802f53c:	0004c07f 00040004 00040004 00040004     ................
 802f54c:	00040004 00040004 00000000 00000000     ................
 802f55c:	00000000 80408040 80408040 80408040     ....@.@.@.@.@.@.
 802f56c:	80408040 80408040 001e0021 00000000     @.@.@.@.!.......
	...
 802f584:	10401040 20202020 40104010 80088008     @.@.    .@.@....
 802f594:	00050005 00020002 00000000 00000000     ................
 802f5a4:	00000000 01400000 00814000 20008220     ......@..@.. .. 
 802f5b4:	42210082 00441100 0a004411 280a0028     ..!B..D..D..(..(
 802f5c4:	00100400 04001004 00000010 00000000     ................
	...
 802f5dc:	10400000 40102020 00058008 00020002     ..@.  .@........
 802f5ec:	80080005 20204010 00001040 00000000     .....@  @.......
 802f5fc:	00000000 10400000 40102020 00058008     ......@.  .@....
 802f60c:	00020002 00020002 00020002 00000002     ................
	...
 802f624:	807f0000 00018000 00020002 00080004     ................
 802f634:	00100010 00400020 0000807f 00000000     .... .@.........
	...
 802f650:	0041003e 00010001 0041003f 00410041     >.A.....?.A.A.A.
 802f660:	0000803e 00000000 00000000 00400000     >.............@.
 802f670:	00400040 0062005c 00410041 00410041     @.@.\.b.A.A.A.A.
 802f680:	00620041 0000005c 00000000 00000000     A.b.\...........
	...
 802f698:	0022001c 00400041 00400040 00220041     ..".A.@.@.@.A.".
 802f6a8:	0000001c 00000000 00000000 00010000     ................
 802f6b8:	00010001 0023001d 00410041 00410041     ......#.A.A.A.A.
 802f6c8:	00230041 0000001d 00000000 00000000     A.#.............
	...
 802f6e0:	0022001c 00410041 0040007f 00220041     ..".A.A...@.A.".
 802f6f0:	0000001c 00000000 00000000 7c10100c     ...............|
 802f700:	10101010 10101010 00000000 00000000     ................
 802f710:	00000000 001d0000 00410023 00410041     ........#.A.A.A.
 802f720:	00410041 001d0023 00010001 003c0002     A.A.#.........<.
 802f730:	00000000 00400040 005c0040 00410062     ....@.@.@.\.b.A.
 802f740:	00410041 00410041 00410041 00000000     A.A.A.A.A.A.....
 802f750:	00000000 00400000 40404000 40404040     ......@..@@@@@@@
 802f760:	00004040 00000000 20000020 20202020     @@...... ..     
 802f770:	20202020 40202020 00000000 00400040            @....@.@.
 802f780:	00420040 00480044 00700050 00440048     @.B.D.H.P.p.H.D.
 802f790:	00410042 00000000 00000000 40400000     B.A...........@@
 802f7a0:	40404040 40404040 00004040 00000000     @@@@@@@@@@......
	...
 802f7b8:	2065c058 10421042 10421042 10421042     X.e B.B.B.B.B.B.
 802f7c8:	00001042 00000000 00000000 00000000     B...............
 802f7d8:	00000000 0062005c 00410041 00410041     ....\.b.A.A.A.A.
 802f7e8:	00410041 00000041 00000000 00000000     A.A.A...........
	...
 802f800:	0022001c 00410041 00410041 00220041     ..".A.A.A.A.A.".
 802f810:	0000001c 00000000 00000000 00000000     ................
 802f820:	00000000 0062005c 00410041 00410041     ....\.b.A.A.A.A.
 802f830:	00620041 0040005c 00400040 00000040     A.b.\.@.@.@.@...
	...
 802f848:	0023001d 00410041 00410041 00230041     ..#.A.A.A.A.A.#.
 802f858:	0001001d 00010001 00000001 58000000     ...............X
 802f868:	40404060 40404040 00000000 00000000     `@@@@@@@........
 802f878:	40423c00 02023c40 00003c42 00000000     .<B@@<..B<......
 802f888:	7c101010 10101010 08101010 00000000     ...|............
	...
 802f8a0:	00410000 00410041 00410041 00410041     ..A.A.A.A.A.A.A.
 802f8b0:	001d0023 00000000 00000000 00000000     #...............
 802f8c0:	00000000 00410000 00220041 00140022     ......A.A."."...
 802f8d0:	00080014 00080008 00000000 00000000     ................
	...
 802f8e8:	10420000 10421042 20252025 c018a028     ..B.B.B.% % (...
 802f8f8:	40104010 00000000 00000000 00000000     .@.@............
 802f908:	00000000 00410000 00220022 00080014     ......A.".".....
 802f918:	00220014 00410022 00000000 00000000     ..".".A.........
	...
 802f930:	00410000 00220041 00140022 00080014     ..A.A.".".......
 802f940:	00080008 00100010 00600010 00000000     ..........`.....
 802f950:	04027e00 20101008 00007e40 00000000     .~..... @~......
	...
 802f968:	40000000 00000000 00000000 00000000     ...@............
 802f978:	00000000 20202000 00000040 00000000     .....   @.......
 802f988:	00000020 20000000 00402020 00000000      ......   @.....
 802f998:	00400000 00000000 00004000 00000000     ..@......@......
 802f9a8:	00000000 78000000 00000000 00000000     .......x........
	...
 802f9d8:	0000c07f 00000000 00000000 00080000     ................
 802f9e8:	00080008 0008007f 00080008 00000000     ................
	...
 802fa00:	54100000 00282838 00000000 00000000     ...T8((.........
 802fa10:	00000000 80080000 80088008 0011c03f     ............?...
 802fa20:	00110011 807f0011 00220022 00000022     ........"."."...
	...
 802fa3c:	00000022 0022001c 00410041 00410041     ".....".A.A.A.A.
 802fa4c:	00220041 0000001c 00000000 00000000     A.".............
 802fa5c:	00000000 00000012 0041003e 00010001     ........>.A.....
 802fa6c:	0041003f 00410041 0000803e 00000000     ?.A.A.A.>.......
	...
 802fa84:	00000022 00410041 00410041 00410041     "...A.A.A.A.A.A.
 802fa94:	00230041 0000001d 00000000 00090000     A.#.............
 802faa4:	000f0000 4020c030 20402040 20402040     ....0. @@ @ @ @ 
 802fab4:	20402040 c0304020 0000000f 00000000     @ @  @0.........
 802fac4:	80080000 00020000 00050002 80080005     ................
 802fad4:	40108008 2020c01f 10402020 00001040     ...@..    @.@...
 802fae4:	00000000 00120000 80400000 80408040     ..........@.@.@.
 802faf4:	80408040 80408040 80408040 00218040     @.@.@.@.@.@.@.!.
 802fb04:	0000001e 00000000 00000000 001c0000     ................
 802fb14:	00410022 00010001 00040002 00080008     ".A.............
 802fb24:	00000000 00000008 00000000 00000000     ................
 802fb34:	40404040 40404040 40000040 00000000     @@@@@@@@@..@....
 802fb44:	48300000 00003048 00000000 00000000     ..0HH0..........
 802fb54:	00000000 00442810 00000000 00000000     .....(D.........
 802fb64:	00000000 08080000 10101010 20202020     ............    
 802fb74:	00004040 00000000 20202010 40404040     @@.......   @@@@
 802fb84:	40404040 10202020 20400000 10102020     @@@@   ...@   ..
 802fb94:	10101010 20201010 00004020 001c0000     ......   @......
 802fba4:	00220022 00140022 00240018 40412042     ".".".....$.B A@
 802fbb4:	40218040 0000201e 00000000 00000000     @.!@. ..........
 802fbc4:	20380000 40444044 00458044 70020039     ..8 D@D@D.E.9..p
 802fbd4:	88048802 88088808 00007010 00000000     .........p......
 802fbe4:	00000000 001c0008 0049002a 00280048     ........*.I.H.(.
 802fbf4:	000a001c 00090009 002a0049 0008001c     ........I.*.....
	...
 802fc0c:	e0030000 0410180c 2226e421 22482244     ........!.&"D"H"
 802fc1c:	42484248 cc484448 00207027 e0071018     HBHBHDH.'p .....
 802fc2c:	00000000 40404040 40404040 40404040     ....@@@@@@@@@@@@
 802fc3c:	40404040 00000000 00000000 00030000     @@@@............
 802fc4c:	0030000c 00300040 0003000c 00000000     ..0.@.0.........
	...
 802fc6c:	00600000 00060018 00060001 00600018     ..`...........`.
	...

0802fc88 <_ZL38Microsoft_Sans_Serif__12_mapping_table>:
	...
 802fca8:	47004f00 00555657 45465453 523f4340     .O.GWVU.STFE@C?R
 802fcb8:	04030201 08070605 41420a09 4e5b005a     ..........BAZ.[N
 802fcc8:	0d0c0b58 11100f0e 15141312 19181716     X...............
 802fcd8:	1d1c1b1a 21201f1e 00242322 44510000     ...... !"#$...QD
 802fce8:	27262500 2b2a2928 2f2e2d2c 33323130     .%&'()*+,-./0123
 802fcf8:	37363534 3b3a3938 003e3d3c 00000059     456789:;<=>.Y...
	...
 802fd38:	00000050 00000000 00000000 00000000     P...............
 802fd48:	00000000 0000004c 00000000 00000000     ....L...........
 802fd58:	00000000 004b0000 00000000 0000004d     ......K.....M...
 802fd68:	00000000 00000049 00000000 00000000     ....I...........
 802fd78:	00000000 00480000 00000000 0000004a     ......H.....J...

0802fd88 <_ZL36Microsoft_Sans_Serif__12_width_table>:
 802fd88:	09050905 09090909 0d090909 0a0b0c0a     ................
 802fd98:	030a0c0a 0b090a08 0c0a0c09 0a0b0b0b     ................
 802fda8:	0d0d110d 09090a0a 09070909 09040309     ................
 802fdb8:	09090d03 08060909 0d090907 03080909     ................
 802fdc8:	06030404 0b07090b 0c090a09 03090a0d     ................
 802fdd8:	05060706 090e0c05 09090310              ............

0802fde4 <_ZL37Microsoft_Sans_Serif__12_offset_table>:
 802fde4:	00000000 00000012 00000036 00000048     ........6...H...
 802fdf4:	0000006c 00000090 000000b4 000000d8     l...............
 802fe04:	000000fc 00000120 00000144 00000168     .... ...D...h...
 802fe14:	0000018c 000001b0 000001d4 000001f8     ................
 802fe24:	0000021c 00000240 00000264 00000288     ....@...d.......
 802fe34:	0000029a 000002ac 000002d0 000002f4     ................
 802fe44:	00000318 0000033c 00000360 00000384     ....<...`.......
 802fe54:	000003a8 000003cc 000003f0 00000414     ................
 802fe64:	00000438 0000045c 00000492 000004b6     8...\...........
 802fe74:	000004da 000004fe 00000522 00000546     ........"...F...
 802fe84:	0000056a 0000058e 000005b2 000005c4     j...............
 802fe94:	000005e8 0000060c 0000061e 00000630     ............0...
 802fea4:	00000654 00000666 0000068a 000006ae     T...f...........
 802feb4:	000006d2 000006f6 0000071a 0000072c     ............,...
 802fec4:	0000073e 00000750 00000774 00000798     >...P...t.......
 802fed4:	000007bc 000007e0 00000804 00000816     ................
 802fee4:	00000828 0000083a 0000084c 0000085e     (...:...L...^...
 802fef4:	00000870 00000894 000008b8 000008ca     p...............
 802ff04:	000008ee 00000912 00000936 0000095a     ........6...Z...
 802ff14:	0000097e 000009a2 000009c6 000009ea     ~...............
 802ff24:	000009fc 00000a0e 00000a20 00000a32     ........ ...2...
 802ff34:	00000a44 00000a56 00000a7a 00000a9e     D...V...z.......
 802ff44:	00000ac2 00000ae6 00000af8 00000b1c     ................

0802ff54 <c_FontSansSerif26>:
 802ff54:	00000000 00000028 0802ff6c 08032794     ....(...l....'..
 802ff64:	08032894 080328f0                       .(...(..

0802ff6c <_ZL35Microsoft_Sans_Serif__26_char_table>:
	...
 802ffd0:	00f80700 1f00fc0f 3f3f00fe 000f3c00     ..........??.<..
 802ffe0:	78800f7c 07788007 80077880 70800778     |..x..x..x..x..p
 802fff0:	03708003 80037080 70800370 07788003     ..p..p..p..p..x.
 8030000:	80077880 78800778 0f7c8007 000f3c80     .x..x..x..|..<..
 8030010:	1f003f3f fc0f00fe 00f80700 00000000     ??..............
	...
 8030040:	c0010000 c003c001 c01fc007 c07fc07f     ................
 8030050:	c001c07d c001c001 c001c001 c001c001     }...............
 8030060:	c001c001 c001c001 c001c001 c001c001     ................
 8030070:	c001c001 00000000 00000000 00000000     ................
	...
 8030098:	00fe0300 1f00ff0f 9f1f80ff c0073ec0     .............>..
 80300a8:	38c0033c 0100c001 c00300c0 00c00300     <..8............
 80300b8:	0700c003 000f0080 00003e00 f800007c     .........>..|...
 80300c8:	00f00300 0f00e007 001f0080 00003e00     .............>..
 80300d8:	7f00003c ff7fc0ff c0ff7fc0 00000000     <...............
	...
 8030110:	00f80700 3f00fc1f 3f3e00fe 000f7800     .......?..>?.x..
 8030120:	70000778 0f000007 000f0000 01007e00     x..p.........~..
 8030130:	fc0100fc 00fe0100 00003f00 0700800f     .........?......
 8030140:	80030080 70800300 07788007 800f7c80     .......p..x..|..
 8030150:	3f003f3f fe1f00ff 00f80700 00000000     ??.?............
	...
 8030188:	001c0000 00003c00 7c00007c 00fc0000     .....<..|..|....
 8030198:	0100fc01 9c0300dc 009c0700 0e001c07     ................
 80301a8:	1c1e001c 001c1c00 78001c38 1c70001c     ........8..x..p.
 80301b8:	80ff7f00 7f80ff7f 1c0080ff 001c0000     ................
 80301c8:	00001c00 1c00001c 001c0000 00000000     ................
	...
 8030200:	00ff1f00 3f00ff3f 003c00ff 00003c00     ....?..?..<..<..
 8030210:	3c00003c 003c0000 00f83f00 3f00fe3f     <..<..<..?..?..?
 8030220:	3f3f00ff 800f3c00 00800700 03008007     ..??.<..........
 8030230:	80030080 70800300 07788007 800f7c80     .......p..x..|..
 8030240:	3f003f3f fc1f00fe 00f80700 00000000     ??.?............
	...
 8030278:	00fc0300 1f00fe0f 9f1f00ff 80073e80     .............>..
 8030288:	7c80073c 00780000 00007800 7f00f87b     <..|..x..x..{...
 8030298:	ff7f00fe 003f7f00 78800f7c 07708007     ......?.|..x..p.
 80302a8:	80037880 78800378 077c8007 800f3c80     .x..x..x..|..<..
 80302b8:	1f003f3f fe0f00ff 00f80700 00000000     ??..............
	...
 80302f0:	80ff7f00 7f80ff7f 070080ff 000f0080     ................
 8030300:	00000f00 1e00000f 001e0000 00003c00     .............<..
 8030310:	7800003c 00780000 00007800 f00000f0     <..x..x..x......
 8030320:	00e00100 0300e001 c00300c0 00c00300     ................
 8030330:	07008007 000f0080 00000f00 00000000     ................
	...
 8030368:	00f80700 1f00fc0f 3f3f00fe 000f3c00     ..........??.<..
 8030378:	38000f3c 0f3c0007 000f3c00 1f001f3e     <..8..<..<..>...
 8030388:	fc0f00fe 00f80700 3f00fe1f 1f7e00ff     ...........?..~.
 8030398:	80077880 70800778 07788003 80077880     .x..x..p..x..x..
 80303a8:	3f803f7f fe1f00ff 00f80700 00000000     .?.?............
	...
 80303e0:	00f80700 3f00fc1f 3f3f00fe 000f7c00     .......?..??.|..
 80303f0:	78800f78 07708007 80077080 78800378     x..x..p..p..x..x
 8030400:	0f7c8007 803f3f80 1f80ff3f f70780ff     ..|..??.?.......
 8030410:	80070080 00800700 0f78800f 001f7800     ..........x..x..
 8030420:	3f007e7e fc1f00fe 00f00f00 00000000     ~~.?............
	...
 8030460:	00003e00 00007e00 00007e00 00007f00     .>...~...~......
 8030470:	0000f700 0080e700 0080e700 0080e301     ................
 8030480:	00c0c301 00c0c103 00e0c103 00e08103     ................
 8030490:	00e08007 00f08007 00f00007 00f8ff0f     ................
 80304a0:	00f8ff0f 00f8ff1f 003c001e 003c001e     ..........<...<.
 80304b0:	001e003c 001e003c 001e0038 000f0078     <...<...8...x...
 80304c0:	000f0078 00000000 00000000 00000000     x...............
	...
 80304f8:	00fe7f00 7f00ff7f 1f7080ff c00370c0     ..........p..p..
 8030508:	70c00370 0370c001 c00370c0 7f801f70     p..p..p..p..p...
 8030518:	ff7f00ff 80ff7f00 70c00f70 0170e003     ........p..p..p.
 8030528:	e00070e0 70e00070 0170e000 e00370e0     .p..p..p..p..p..
 8030538:	7fc00f70 ff7fc0ff 00fe7f80 00000000     p...............
	...
 8030570:	80ff0100 0fe0ff03 e31ff0ff f8001ff8     ................
 8030580:	3c3c003e 00783c00 0000781c 78000078     >.<<.<x..x..x..x
 8030590:	00700000 00007000 78000070 00780000     ..p..p..p..x..x.
 80305a0:	00007800 3c1c0078 003e3c00 f8001f3c     .x..x..<.<>.<...
 80305b0:	0ff8e31f ff03f0ff 80ff01e0 00000000     ................
	...
 80305e8:	00fc7f00 7f80ff7f 1f70c0ff f00370e0     ..........p..p..
 80305f8:	70f00070 0070f000 78007078 70780070     p..p..p.xp.xp.xp
 8030608:	00703800 38007038 70380070 00707800     .8p.8p.8p.8p.xp.
 8030618:	78007078 70780070 0170f000 f00370f0     xp.xp.xp..p..p..
 8030628:	7fe01f70 ff7fc0ff 00fc7f80 00000000     p...............
	...
 8030660:	c0ff7f00 7fc0ff7f 0070c0ff 00007000     ..........p..p..
 8030670:	70000070 00700000 00007000 70000070     p..p..p..p..p..p
 8030680:	ff7f0000 80ff7f80 7080ff7f 00700000     ...........p..p.
 8030690:	00007000 70000070 00700000 00007000     .p..p..p..p..p..
 80306a0:	7f000070 ff7fe0ff e0ff7fe0 00000000     p...............
	...
 80306d8:	80ff7f00 7f80ff7f 007080ff 00007000     ..........p..p..
 80306e8:	70000070 00700000 00007000 70000070     p..p..p..p..p..p
 80306f8:	fe7f0000 00fe7f00 7000fe7f 00700000     ...........p..p.
 8030708:	00007000 70000070 00700000 00007000     .p..p..p..p..p..
 8030718:	70000070 00700000 00007000 00000000     p..p..p..p......
	...
 8030758:	00c0ff00 00f0ff03 00fcff07 00fee10f     ................
 8030768:	003e801f 001f003e 000f003c 0007007c     ..>.>...<...|...
 8030778:	00000078 00000078 00000078 00000070     x...x...x...p...
 8030788:	00ff0370 00ff0370 00ff0378 00070078     p...p...x...x...
 8030798:	00070078 00070078 000f003c 000f003e     x...x...<...>...
 80307a8:	003f001f 00ffe10f 00ffff07 00f7ff03     ..?.............
 80307b8:	00c7ff00 00000000 00000000 00000000     ................
	...
 80307f0:	70007000 70700070 00707000 70007070     .p.pp.pp.pp.pp.p
 8030800:	70700070 00707000 70007070 7f700070     p.pp.pp.pp.pp.p.
 8030810:	ff7ff0ff f0ff7ff0 70700070 00707000     ........p.pp.pp.
 8030820:	70007070 70700070 00707000 70007070     pp.pp.pp.pp.pp.p
 8030830:	70700070 00707000 70007070 00000000     p.pp.pp.pp.p....
	...
 8030858:	70000000 70707070 70707070 70707070     ...ppppppppppppp
 8030868:	70707070 70707070 70707070 00000000     pppppppppppp....
	...
 8030888:	0e000000 0e000e00 0e000e00 0e000e00     ................
 8030898:	0e000e00 0e000e00 0e000e00 0e000e00     ................
 80308a8:	0e000e00 0e700e70 1e781e78 fc3f7e7e     ....p.p.x.x.~~?.
 80308b8:	f00ff81f 00000000 00000000 00000000     ................
	...
 80308e0:	f8007000 70e00170 0770c003 000f7080     .p..p..p..p..p..
 80308f0:	70001e70 7870003c 00f07000 7300e071     p..p<.px.p..q..s
 8030900:	f07700e0 00f07f00 7c00787e 3e78003c     ..w.....~x.|<.x>
 8030910:	001e7800 70000f70 0770800f c00370c0     .x..p..p..p..p..
 8030920:	70e00170 0070f001 780070f0 00000000     p..p..p..p.x....
	...
 8030958:	00007000 70000070 00700000 00007000     .p..p..p..p..p..
 8030968:	70000070 00700000 00007000 70000070     p..p..p..p..p..p
 8030978:	00700000 00007000 70000070 00700000     ..p..p..p..p..p.
 8030988:	00007000 70000070 00700000 00007000     .p..p..p..p..p..
 8030998:	7f000070 ff7f00ff 00ff7f00 00000000     p...............
	...
 80309d8:	001f007c 003f007e 003f007e 003f007e     |...~.?.~.?.~.?.
 80309e8:	007f007f 007f007f 007f007f 00f78077     ............w...
 80309f8:	00f78077 00f78077 00e7c173 00e7c173     w...w...s...s...
 8030a08:	00e7c173 00c7e371 00c7e371 00c7e371     s...q...q...q...
 8030a18:	0087f770 0087f770 0087f770 00077f70     p...p...p...p...
 8030a28:	00077f70 00077f70 00073e70 00073e70     p...p...p>..p>..
 8030a38:	00073e70 00000000 00000000 00000000     p>..............
	...
 8030a70:	70007800 7c70007c 007e7000 70007f70     .x.p|.p|.p~.p..p
 8030a80:	7f70007f c0777080 70c07370 7170e073     ..p..pw.ps.ps.pq
 8030a90:	f07070e0 70f87070 70707870 3e70703c     .pp.pp.ppxpp<pp>
 8030aa0:	701e7070 70701f70 0770f00f f00770f0     pp.pp.pp..p..p..
 8030ab0:	70f00370 0170f001 f00070f0 00000000     p..p..p..p......
	...
 8030af0:	0080ff00 00e0ff03 00f0ff07 00f8e30f     ................
 8030b00:	007c001f 003e003e 001e003c 000f0078     ..|.>.>.<...x...
 8030b10:	000f0078 000f0078 000f0078 00070070     x...x...x...p...
 8030b20:	00070070 00070070 000f0078 000f0078     p...p...x...x...
 8030b30:	000f0078 000f0078 001e003c 003e003e     x...x...<...>.>.
 8030b40:	007c001f 00f8e30f 00f0ff07 00e0ff03     ..|.............
 8030b50:	0080ff00 00000000 00000000 00000000     ................
	...
 8030b88:	00ff7f00 7f80ff7f 0f70c0ff e00170e0     ..........p..p..
 8030b98:	70e00170 0070e000 e00070e0 70e00170     p..p..p..p..p..p
 8030ba8:	0f70e003 c0ff7fc0 7f80ff7f 007000fe     ..p...........p.
 8030bb8:	00007000 70000070 00700000 00007000     .p..p..p..p..p..
 8030bc8:	70000070 00700000 00007000 00000000     p..p..p..p......
	...
 8030c08:	0080ff00 00e0ff03 00f0ff07 00f8e30f     ................
 8030c18:	007c001f 003e003e 001e003c 000f0078     ..|.>.>.<...x...
 8030c28:	000f0078 000f0078 000f0078 00070070     x...x...x...p...
 8030c38:	00070070 00070070 000f0078 000f0078     p...p...x...x...
 8030c48:	000f0078 001f0178 00de033c 00fe073e     x...x...<...>...
 8030c58:	00fc031f 00f8e30f 00fcff07 00feff03     ................
 8030c68:	009fff00 000f0000 00060000 00000000     ................
	...
 8030ca0:	80ff7f00 7fc0ff7f 0770e0ff f00070f0     ..........p..p..
 8030cb0:	70f00070 00707000 f0007070 70f00070     p..p.pp.pp..p..p
 8030cc0:	ff7fe007 c0ff7fe0 7000ff7f 0770801f     ...........p..p.
 8030cd0:	c00370c0 70e00170 0070e001 f00070e0     .p..p..p..p..p..
 8030ce0:	70f00070 00707800 78007078 00000000     p..p.xp.xp.x....
	...
 8030d18:	00fe0300 1f00ff0f 8f3f80ff e0033cc0     ..........?..<..
 8030d28:	38e0013c 003ce001 00003ee0 1f00803f     <..8..<..>..?...
 8030d38:	ff0f00f8 c0ff0300 00e07f00 0100f007     ................
 8030d48:	f00000f0 78700070 00787000 f0017ef0     ....p.px.px..~..
 8030d58:	1fe0873f ff0fe0ff 00ff03c0 00000000     ?...............
	...
 8030d90:	f0ff7f00 7ff0ff7f 7000f0ff 00700000     ...........p..p.
 8030da0:	00007000 70000070 00700000 00007000     .p..p..p..p..p..
 8030db0:	70000070 00700000 00007000 70000070     p..p..p..p..p..p
 8030dc0:	00700000 00007000 70000070 00700000     ..p..p..p..p..p.
 8030dd0:	00007000 70000070 00700000 00000000     .p..p..p..p.....
	...
 8030e08:	70007000 70700070 00707000 70007070     .p.pp.pp.pp.pp.p
 8030e18:	70700070 00707000 70007070 70700070     p.pp.pp.pp.pp.pp
 8030e28:	00707000 70007070 70700070 00707000     .pp.pp.pp.pp.pp.
 8030e38:	f0007870 78f00078 0078f000 f0017cf0     px..x..x..x..|..
 8030e48:	1fe08f3f ff0fc0ff 00ff0780 00000000     ?...............
	...
 8030e88:	000f0078 000f0078 001e003c 001e003c     x...x...<...<...
 8030e98:	001e003c 003c001e 003c001e 0038000e     <.....<...<...8.
 8030ea8:	0078000f 0078000f 00700007 00f08007     ..x...x...p.....
 8030eb8:	00f08007 00e0c103 00e0c103 00c0c101     ................
 8030ec8:	00c0e301 00c0e301 0080e300 0080f700     ................
 8030ed8:	00007700 00007f00 00007f00 00003e00     .w...........>..
 8030ee8:	00003e00 00000000 00000000 00000000     .>..............
	...
 8030f2c:	78000000 c003e000 03f00178 f00178c0     ...x....x....x..
 8030f3c:	0138c003 3c8003f0 8007f803 07b8033c     ..8....<....<...
 8030f4c:	b8033c80 071c8007 1e0007bc 000f1c07     .<..............
 8030f5c:	0f1c071e 1e0f0e00 0e0e000e 0f000e0e     ................
 8030f6c:	001e0e0e 1e0f1e0f 071c0700 1c07001c     ................
 8030f7c:	07001c07 003c079c b803b803 03b80300     ......<.........
 8030f8c:	f80300b8 0300f803 00f803f8 f001f001     ................
 8030f9c:	01f00100 f00100f0 0000f001 00e000e0     ................
	...
 8030ff0:	001e003c 003c001e 007c001f 00f8800f     <.....<...|.....
 8031000:	00f08007 00e0c103 00e0e303 00c0e301     ................
 8031010:	0080f700 00007f00 00007f00 00003e00     .............>..
 8031020:	00003e00 00007f00 0080ff00 0080f700     .>..............
 8031030:	00c0e301 00e0c103 00f0c107 00f08007     ................
 8031040:	0078000f 007c001f 003e003e 001e003c     ..x...|.>.>.<...
 8031050:	000f0078 00000000 00000000 00000000     x...............
	...
 8031090:	000f0078 001e003c 003e003e 003c001e     x...<...>.>...<.
 80310a0:	0078000f 00f8800f 00f08007 00e0c103     ..x.............
 80310b0:	00e0e303 00c0e301 0080f700 0080ff00     ................
 80310c0:	00007f00 00003e00 00001c00 00001c00     .....>..........
 80310d0:	00001c00 00001c00 00001c00 00001c00     ................
 80310e0:	00001c00 00001c00 00001c00 00001c00     ................
 80310f0:	00001c00 00000000 00000000 00000000     ................
	...
 8031128:	c0ff3f00 3fc0ff3f 0300c0ff c00700c0     .?..?..?........
 8031138:	00800f00 1e00000f 003e0000 00007c00     ..........>..|..
 8031148:	f8000078 00f00100 0300e003 c00700c0     x...............
 8031158:	00800f00 1e00000f 003e0000 00007c00     ..........>..|..
 8031168:	7f000078 ff7fc0ff c0ff7fc0 00000000     x...............
	...
 80311b0:	07000000 fe1f00f8 00ff1f00 3c001f3f     ............?..<
 80311c0:	0738000f 00070000 1f00ff07 ff3f00ff     ..8...........?.
 80311d0:	00877f00 7800077c 0f700007 001f7800     ....|..x..p..x..
 80311e0:	7f007f7c ff3f00ff 00f71f00 00000000     |.....?.........
	...
 8031218:	00007000 70000070 00700000 00007000     .p..p..p..p..p..
 8031228:	73000070 fc7f00f8 00fe7f00 7c003e7f     p..s.........>.|
 8031238:	0f78001f 000f7000 70000f70 07700007     ..x..p..p..p..p.
 8031248:	00077000 70000f70 0f70000f 001e7800     .p..p..p..p..x..
 8031258:	7f003e7e f87f00fc 00f07f00 00000000     ~>..............
	...
 80312a0:	07000000 fe0f00fc 00ff1f00 3c801f3f     ............?..<
 80312b0:	03788007 00007880 70000078 00700000     ..x..x..x..p..p.
 80312c0:	00007000 78000078 03780000 80073c80     .p..x..x..x..<..
 80312d0:	1f801f3f fe0f00ff 00fc0700 00000000     ?...............
	...
 8031308:	00070000 00000700 07000007 00070000     ................
 8031318:	07000700 ff0f00f7 00ff1f00 3c003f3e     ............>?.<
 8031328:	0778000f 00077800 70000778 07700007     ..x..x..x..p..p.
 8031338:	00077000 78000778 0f780007 001f7c00     .p..x..x..x..|..
 8031348:	3f007f3e ff1f00ff 00f70f00 00000000     >..?............
	...
 8031390:	07000000 fc0f00f8 00fe1f00 3c003f3f     ............??.<
 80313a0:	0778000f 80077880 7f800778 ff7f80ff     ..x..x..x.......
 80313b0:	80ff7f80 78000070 03780000 80073c80     ....p..x..x..<..
 80313c0:	1f801f3f fe0f00ff 00fc0700 00000000     ?...............
	...
 80313f0:	e0070000 e00fe00f 000e000f c07f000e     ................
 8031400:	c07fc07f 000e000e 000e000e 000e000e     ................
 8031410:	000e000e 000e000e 000e000e 000e000e     ................
 8031420:	000e000e 00000000 00000000 00000000     ................
	...
 8031458:	07000000 ff0f00ff 00ff1f00 3c003f3e     ............>?.<
 8031468:	0778000f 00077800 70000778 07700007     ..x..x..x..p..p.
 8031478:	00077000 78000778 0f780007 001f7c00     .p..x..x..x..|..
 8031488:	3f007f3e ff1f00ff 00e70f00 00000f00     >..?............
 8031498:	0f3c000f 003e3e00 1f00fe3f f80f00fc     ..<..>>.?.......
	...
 80314b8:	00700000 00700070 00700070 f8730070     ..p.p.p.p.p.p.s.
 80314c8:	fe7ffc7f 1e7c3e7f 0e701e78 0e700e70     .....>|.x.p.p.p.
 80314d8:	0e700e70 0e700e70 0e700e70 0e700e70     p.p.p.p.p.p.p.p.
 80314e8:	0e700e70 00000000 00000000 00000000     p.p.............
	...
 8031500:	70000000 00007070 70707000 70707070     ...ppp...ppppppp
 8031510:	70707070 70707070 70707070 00000000     pppppppppppp....
	...
 8031530:	00070000 00070007 00000000 00070000     ................
 8031540:	00070007 00070007 00070007 00070007     ................
 8031550:	00070007 00070007 00070007 00070007     ................
 8031560:	00070007 00070007 004f000f 007e007f     ..........O...~.
 8031570:	0000007c 00000000 00000000 00000000     |...............
	...
 8031588:	00007000 70000070 00700000 00007000     .p..p..p..p..p..
 8031598:	70000070 7c70003e 00f87000 7100f071     p..p>.p|.p..q..q
 80315a8:	c07300e0 00807700 7f00807f c07f00c0     ..s..w..........
 80315b8:	00e07900 7000f079 787000f0 007c7000     .y..y..p..px.p|.
 80315c8:	70003c70 1f70001e 000f7000 00000000     p<.p..p..p......
	...
 80315f0:	70000000 70707070 70707070 70707070     ...ppppppppppppp
 8031600:	70707070 70707070 70707070 00000000     pppppppppppp....
	...
 8031648:	007ff873 80fffc7f c0ffff7f c0e73f7f     s............?..
 8031658:	c0831f7c c0031f78 c0010e70 c0010e70     |...x...p...p...
 8031668:	c0010e70 c0010e70 c0010e70 c0010e70     p...p...p...p...
 8031678:	c0010e70 c0010e70 c0010e70 c0010e70     p...p...p...p...
 8031688:	c0010e70 c0010e70 c0010e70 00000000     p...p...p.......
	...
 80316cc:	f8730000 fe7ffc7f 1e7c3e7f 0e701e78     ..s......>|.x.p.
 80316dc:	0e700e70 0e700e70 0e700e70 0e700e70     p.p.p.p.p.p.p.p.
 80316ec:	0e700e70 0e700e70 00000000 00000000     p.p.p.p.........
	...
 8031728:	07000000 fc0f00f8 00fe1f00 7c003f3f     ............??.|
 8031738:	0778800f 80077880 70800778 03708003     ..x..x..x..p..p.
 8031748:	80037080 78800778 07788007 800f7c80     .p..x..x..x..|..
 8031758:	1f003f3f fc0f00fe 00f80700 00000000     ??..............
	...
 80317a0:	77000000 fc7f00f8 00fe7f00 7c003e7f     ...w.........>.|
 80317b0:	0f78001f 000f7000 70000f70 07700007     ..x..p..p..p..p.
 80317c0:	00077000 70000f70 0f70000f 001e7800     .p..p..p..p..x..
 80317d0:	7f003e7e f87f00fc 00f07700 70000070     ~>.......w..p..p
 80317e0:	00700000 00007000 70000070 00700000     ..p..p..p..p..p.
	...
 8031818:	07000000 ff0f00ff 00ff1f00 3c003f3e     ............>?.<
 8031828:	0778000f 00077800 70000778 07700007     ..x..x..x..p..p.
 8031838:	00077000 78000778 0f780007 001f7c00     .p..x..x..x..|..
 8031848:	3f007f3e ff1f00ff 00e70f00 00000700     >..?............
 8031858:	07000007 00070000 00000700 07000007     ................
	...
 8031884:	c0730000 c07fc07f 0078007e 00700078     ..s.....~.x.x.p.
 8031894:	00700070 00700070 00700070 00700070     p.p.p.p.p.p.p.p.
 80318a4:	00700070 00700070 00000000 00000000     p.p.p.p.........
	...
 80318e0:	0f000000 fc3f00f8 00fe7f00 78003e7e     ......?.....~>.x
 80318f0:	0078001e 00007c00 3f00c07f fe1f00f8     ..x..|.....?....
 8031900:	00ff0300 00003f00 0770000f 000f7800     .....?....p..x..
 8031910:	3f003f7e fc1f00fe 00f80f00 00000000     ~?.?............
	...
 8031944:	001c001c 001c001c 807f001c 807f807f     ................
 8031954:	001c001c 001c001c 001c001c 001c001c     ................
 8031964:	001c001c 001c001c 801f001e 800f801f     ................
	...
 803199c:	0e700000 0e700e70 0e700e70 0e700e70     ..p.p.p.p.p.p.p.
 80319ac:	0e700e70 0e700e70 0e700e70 3e781e78     p.p.p.p.p.p.x.x>
 80319bc:	fe7ffe7c ce1ffe3f 00000000 00000000     |...?...........
	...
 80319f8:	78000000 0378c003 800338c0 3c80073c     ...x..x..8..<..<
 8031a08:	071c8007 000f1e00 0e000f1e 1e0f000e     ................
 8031a18:	001e0f00 07001c07 b80300bc 00f80300     ................
 8031a28:	0100f803 f00100f0 00f00100 00000000     ................
	...
 8031a80:	80071e78 80071e78 80073f78 00073f38     x...x...x?..8?..
 8031a90:	00073f38 000f3f3c 008f7f3c 008e7f1c     8?..<?..<.......
 8031aa0:	008e731c 009e731e 00def30e 00dcf30e     .s...s..........
 8031ab0:	00dce10e 00fce10f 00f8e107 00f8e107     ................
 8031ac0:	00f8c007 00f8c007 00f0c003 00000000     ................
	...
 8031b10:	3c000000 0f3e8007 000f1e80 07001e0f     ...<..>.........
 8031b20:	bc0700bc 00f80300 0100f001 f00100f0     ................
 8031b30:	00f80300 0700f803 1e0f00bc 001e0f00     ................
 8031b40:	3c000f1e 077c8007 c00378c0 00000000     ...<..|..x......
	...
 8031b88:	78000000 0378c003 800338c0 3c80073c     ...x..x..8..<..<
 8031b98:	071c8007 000f1e00 0e000f1e 1e0f000e     ................
 8031ba8:	001e0f00 07001c07 b80300bc 00f80300     ................
 8031bb8:	0100f803 f00100f0 00f00100 0100e001     ................
 8031bc8:	c00300e0 00c02f00 3f00803f 003e0000     ...../..?..?..>.
	...
 8031c00:	3f000000 ff3f00ff 00ff3f00 00001f00     ...?..?..?......
 8031c10:	3c00001e 00780000 0100f800 e00300f0     ...<..x.........
 8031c20:	00c00700 0f00800f 001e0000 00003c00     .............<..
 8031c30:	7f00007c ff7f80ff 80ff7f80 00000000     |...............
	...
 8031c70:	70707070 00000000 00000000 00000000     pppp............
	...
 8031c98:	70707070 60707030 00000000 00000000     pppp0pp`........
	...
 8031cb0:	70700000 00007070 00000000 00000000     ..pppp..........
 8031cc0:	70707070 60707030 00000000 00000000     pppp0pp`........
	...
 8031cd8:	70700000 00007070 00000000 00000000     ..pppp..........
 8031ce8:	70707070 00000000 00000000 00000000     pppp............
	...
 8031d1c:	e07f0000 e07fe07f 00000000 00000000     ................
	...
 8031db0:	7ff0ff7f 0000f0ff 00000000 00000000     ................
	...
 8031ddc:	00e00000 0000e000 e00000e0 00e00000     ................
 8031dec:	0000e000 ff7f00e0 c0ff7fc0 00c0ff7f     ................
 8031dfc:	e00000e0 00e00000 0000e000 e00000e0     ................
 8031e0c:	00e00000 00000000 00000000 00000000     ................
	...
 8031e40:	00070000 00070007 f07f7077 800ff07f     ........wp......
 8031e50:	c01dc01f c018e03d 00000000 00000000     ....=...........
	...
 8031e98:	00cf0100 0300cf03 cf0300cf 00ce0300     ................
 8031ea8:	07009e03 ff3f009e 80ff3f80 0f80ff3f     ......?..?..?...
 8031eb8:	3c0f003c 003c0f00 0f003c0f 781e0038     <..<..<..<..8..x
 8031ec8:	00ff7f00 7f00ff7f 781e00ff 00f01c00     ...........x....
 8031ed8:	3c00f03c f03c00f0 00f03c00 00000000     <..<..<..<......
	...
 8031f10:	001c0700 07001c07 1c07001c 00000000     ................
 8031f20:	07000000 fc0f00f8 00fe1f00 7c003f3f     ............??.|
 8031f30:	0778800f 80077880 70800778 03708003     ..x..x..x..p..p.
 8031f40:	80037080 78800778 07788007 800f7c80     .p..x..x..x..|..
 8031f50:	1f003f3f fc0f00fe 00f80700 00000000     ??..............
	...
 8031f88:	001c0700 07001c07 1c07001c 00000000     ................
 8031f98:	07000000 fe1f00f8 00ff1f00 3c001f3f     ............?..<
 8031fa8:	0738000f 00070000 1f00ff07 ff3f00ff     ..8...........?.
 8031fb8:	00877f00 7800077c 0f700007 001f7800     ....|..x..p..x..
 8031fc8:	7f007f7c ff3f00ff 00f71f00 00000000     |.....?.........
	...
 8031ff8:	380e0000 380e380e 0000380e 0e700000     ...8.8.8.8....p.
 8032008:	0e700e70 0e700e70 0e700e70 0e700e70     p.p.p.p.p.p.p.p.
 8032018:	0e700e70 0e700e70 3e781e78 fe7ffe7c     p.p.p.p.x.x>|...
 8032028:	ce1ffe3f 00000000 00000000 00000000     ?...............
	...
 8032040:	0080e300 0080e300 0080e300 0080e300     ................
	...
 8032058:	0080ff00 00e0ff03 00f0ff07 00f8e30f     ................
 8032068:	007c001f 003e003e 001e003c 000f0078     ..|.>.>.<...x...
 8032078:	000f0078 000f0078 000f0078 00070070     x...x...x...p...
 8032088:	00070070 00070070 000f0078 000f0078     p...p...x...x...
 8032098:	000f0078 000f0078 001e003c 003e003e     x...x...<...>.>.
 80320a8:	007c001f 00f8e30f 00f0ff07 00e0ff03     ..|.............
 80320b8:	0080ff00 00000000 00000000 00000000     ................
	...
 80320e0:	0080e300 0080e300 0080e300 0080e300     ................
	...
 80320f8:	00003e00 00007e00 00007e00 00007f00     .>...~...~......
 8032108:	0000f700 0080e700 0080e700 0080e301     ................
 8032118:	00c0c301 00c0c103 00e0c103 00e08103     ................
 8032128:	00e08007 00f08007 00f00007 00f8ff0f     ................
 8032138:	00f8ff0f 00f8ff1f 003c001e 003c001e     ..........<...<.
 8032148:	001e003c 001e003c 001e0038 000f0078     <...<...8...x...
 8032158:	000f0078 00000000 00000000 00000000     x...............
	...
 803217c:	03000000 8e03008e 008e0300 00008e03     ................
 803218c:	00000000 70007000 70700070 00707000     .....p.pp.pp.pp.
 803219c:	70007070 70700070 00707000 70007070     pp.pp.pp.pp.pp.p
 80321ac:	70700070 00707000 70007070 70700070     p.pp.pp.pp.pp.pp
 80321bc:	00707000 f0007870 78f00078 0078f000     .pp.px..x..x..x.
 80321cc:	f0017cf0 1fe08f3f ff0fc0ff 00ff0780     .|..?...........
	...
 8032208:	00f80700 3f00fc1f 3f3e00fe 000f7c00     .......?..>?.|..
 8032218:	78000f78 07000007 000f0000 00001f00     x..x............
 8032228:	7c00003e 00f80000 0100f001 e00100e0     >..|............
 8032238:	00c00100 0000c001 00000000 00000000     ................
 8032248:	0100c001 c00100c0 00c00100 00000000     ................
	...
 8032270:	70000000 70707070 70707070 70707070     ...ppppppppppppp
 8032280:	70707070 00000070 70707070 00000000     ppppp...pppp....
	...
 80322a0:	001f0000 c07b803f c060c071 c07bc071     ....?.{.q.`.q.{.
 80322b0:	001f803f 00000000 00000000 00000000     ?...............
	...
 80322f0:	c0030000 e007c003 f00ff00f 781e781e     .............x.x
 8032300:	3c3c3c3c 1e781e78 00000000 00000000     <<<<x.x.........
	...
 8032340:	e0000000 e000e000 c001c001 8003c001     ................
 8032350:	80038003 00070007 00060007 000e000e     ................
 8032360:	001c000e 001c001c 00380038 00700038     ........8.8.8.p.
 8032370:	00700070 00000000 00000000 00000000     p.p.............
	...
 8032390:	80030000 00078007 000e000e 001c001e     ................
 80323a0:	003c003c 00780038 00780078 00700078     <.<.8.x.x.x.x.p.
 80323b0:	00700070 00780070 00780078 00380078     p.p.p.x.x.x.x.8.
 80323c0:	003c003c 001e001c 000e000e 80070007     <.<.............
 80323d0:	00008003 00000000 00000000 00000000     ................
 80323e0:	00700000 00380078 001c001c 000e001e     ..p.x.8.........
 80323f0:	000f000f 80070007 80078007 80038007     ................
 8032400:	80038003 80078003 80078007 00078007     ................
 8032410:	000f000f 001e000e 001c001c 00780038     ............8.x.
 8032420:	00000070 00000000 00000000 00000000     p...............
	...
 8032438:	00f80300 0f00fc07 be0f00fe 001e0f00     ................
 8032448:	0f000e0e 1e0f000e 00be0700 0300fc07     ................
 8032458:	f00f00f8 00f01f00 3ce0f83f 3f78e07c     ........?..<|.x?
 8032468:	e01f78e0 78e01f70 0778e00f e0077cc0     .x..p..x..x..|..
 8032478:	3fe03f3e fe1ff0ff 60f807f0 00000000     >?.?.......`....
	...
 80324b8:	000ec01f 001ee03f 001ce03d 0038f078     ....?...=...x.8.
 80324c8:	0038f078 00707070 00f07070 00e07070     x.8.ppp.pp..pp..
 80324d8:	00c0f178 00c0f178 0080e33d 0080e33f     x...x...=...?...
 80324e8:	c01fc71f e03f0e00 e03d0e00 f0781c00     ......?...=...x.
 80324f8:	f0781c00 70703800 70707800 70707000     ..x..8pp.xpp.ppp
 8032508:	f078e000 f078e000 e03dc001 e03fc003     ..x...x...=...?.
 8032518:	c01f8003 00000000 00000000 00000000     ................
	...
 8032548:	0000c000 c00000c0 00f80700 1f00fe0f     ................
 8032558:	ff3f00fe 00cf3c00 3800c73c c03800c0     ..?..<..<..8..8.
 8032568:	00c03c00 1f00c03e fc0f00e0 00fe0700     .<..>...........
 8032578:	0000ff01 c70080df 80c70080 7880c370     ............p..x
 8032588:	c77880c3 80c77c80 3f00ff3f fe1f00ff     ..x..|..?..?....
 8032598:	00f80700 0000c000 c00000c0 00000000     ................
	...
 80325d8:	0000fe0f c0ff7f00 1fff0000 f00100e0     ................
 80325e8:	0300f001 007800e0 3c008007 00000f00     ......x....<....
 80325f8:	071e001e 1e009eff 008fff1f 8fff3f3c     ............<?..
 8032608:	3f7e3c00 f878008f 7800070f 00070ff0     .<~?..x....x....
 8032618:	070ff078 0fe07900 e0710007 71000f0e     x....y....q....q
 8032628:	000f1ee0 0f1ec071 1ec07100 e079001f     ....q....q....y.
 8032638:	79001e3e 003e7ce0 fcfef979 ffff7800     >..y.|>.y....x..
 8032648:	7f3c00f8 3c00f0df 00c09f3f 0000001e     ..<....<?.......
 8032658:	00000f00 c00f0000 07000000 000000e0     ................
 8032668:	c007ff01 ff7f0000 1f0000c0 000080ff     ................
	...
 8032680:	70000000 70707070 70707070 70707070     ...ppppppppppppp
 8032690:	70707070 70707070 70707070 70707070     pppppppppppppppp
 80326a0:	00707070 00000000 00000000 00000000     ppp.............
	...
 80326c4:	00030000 00000f00 ff00003f 00fc0300     ........?.......
 80326d4:	7f00f01f 007e00c0 00007c00 7f00007e     ......~..|..~...
 80326e4:	f01f00c0 00fc0300 0000ff00 0f00003f     ............?...
 80326f4:	00030000 00000000 00000000 00000000     ................
	...
 803273c:	00006000 7e000078 807f0000 00e01f00     .`..x..~........
 803274c:	0100fc07 3f0000ff 001f0000 01003f00     .......?.....?..
 803275c:	fc0700ff 00e01f00 7e00807f 00780000     ...........~..x.
 803276c:	00006000 00000000 00000000 00000000     .`..............
	...

08032794 <_ZL38Microsoft_Sans_Serif__26_mapping_table>:
	...
 80327b4:	47004f00 00555657 45465453 523f4340     .O.GWVU.STFE@C?R
 80327c4:	04030201 08070605 41420a09 4e5b005a     ..........BAZ.[N
 80327d4:	0d0c0b58 11100f0e 15141312 19181716     X...............
 80327e4:	1d1c1b1a 21201f1e 00242322 44510000     ...... !"#$...QD
 80327f4:	27262500 2b2a2928 2f2e2d2c 33323130     .%&'()*+,-./0123
 8032804:	37363534 3b3a3938 003e3d3c 00000059     456789:;<=>.Y...
	...
 8032844:	00000050 00000000 00000000 00000000     P...............
 8032854:	00000000 0000004c 00000000 00000000     ....L...........
 8032864:	00000000 004b0000 00000000 0000004d     ......K.....M...
 8032874:	00000000 00000049 00000000 00000000     ....I...........
 8032884:	00000000 00480000 00000000 0000004a     ......H.....J...

08032894 <_ZL36Microsoft_Sans_Serif__26_width_table>:
 8032894:	130b120b 12121212 19121212 14161714     ................
 80328a4:	05151912 19111610 19141915 15151516     ................
 80328b4:	19192319 12111113 110c1211 11090510     .#..............
 80328c4:	12101b05 110b1111 1a13100a 05121313     ................
 80328d4:	0c050505 120d1315 19101112 05111519     ................
 80328e4:	0a0c100b 121d150a 11110521              ........!...

080328f0 <_ZL37Microsoft_Sans_Serif__26_offset_table>:
 80328f0:	00000000 00000050 000000c8 00000118     ....P...........
 8032900:	00000190 00000208 00000280 000002f8     ................
 8032910:	00000370 000003e8 00000460 000004d8     p.......`.......
 8032920:	00000578 000005f0 00000668 000006e0     x.......h.......
 8032930:	00000758 000007d0 00000870 000008e8     X.......p.......
 8032940:	00000910 00000960 000009d8 00000a50     ....`.......P...
 8032950:	00000af0 00000b68 00000c08 00000c80     ....h...........
 8032960:	00000d20 00000d98 00000e10 00000e88      ...............
 8032970:	00000f00 00000fa0 00001068 00001108     ........h.......
 8032980:	000011a8 00001220 00001298 00001310     .... ...........
 8032990:	00001388 00001400 00001478 000014c8     ........x.......
 80329a0:	00001540 00001590 000015b8 00001608     @...............
 80329b0:	00001680 000016a8 00001748 00001798     ........H.......
 80329c0:	00001810 00001888 00001900 00001950     ............P...
 80329d0:	000019c8 00001a18 00001a68 00001ae0     ........h.......
 80329e0:	00001b80 00001bf8 00001c70 00001ce8     ........p.......
 80329f0:	00001d10 00001d38 00001d60 00001d88     ....8...`.......
 8032a00:	00001dd8 00001e50 00001ec8 00001f18     ....P...........
 8032a10:	00001f90 00002008 00002080 000020d0     ..... ... ... ..
 8032a20:	00002170 00002210 00002288 00002300     p!..."..."...#..
 8032a30:	00002328 00002378 000023c8 00002418     (#..x#...#...$..
 8032a40:	00002468 000024b8 00002530 000025d0     h$...$..0%...%..
 8032a50:	00002648 00002710 00002738 000027b0     H&...'..8'...'..

08032a60 <_ZTV12AManagedTask>:
	...
 8032a68:	08024b3d 080199a1 08024b61 08019685     =K......aK......
 8032a78:	080196c5 08024bbd 08022195 08024b85     .....K...!...K..

08032a88 <_ZTV12IFreeRTOSObj>:
	...
 8032a90:	08022195 08022195 08022195 00000000     .!...!...!......

08032aa0 <_ZTV5CTask>:
	...
 8032aa8:	08024b3d 080199a1 08024b61 0801993d     =K......aK..=...
 8032ab8:	08019981 00000000                       ........

08032ac0 <_ZZN5CTask6AttachEPvE19__PRETTY_FUNCTION__>:
 8032ac0:	74726976 206c6175 64696f76 61544320     virtual void CTa
 8032ad0:	3a3a6b73 61747441 78286863 656e6547     sk::Attach(xGene
 8032ae0:	48636972 6c646e61 00002965 00000000     ricHandle)......

08032af0 <_ZTVN21rtc_handler_namespace11CRTCHandlerE>:
	...
 8032af8:	08024b3d 080199a1 08024b61 0801be45     =K......aK..E...
 8032b08:	0801be7d 0801bf05 0801bf4d 08024b85     }.......M....K..

08032b18 <_ZTVN4Time5CTimeE>:
	...
 8032b20:	0801c311 0801c345                       ....E...

08032b28 <_ZTV16CUSB_MassStorage>:
	...
 8032b30:	08024b3d 080199a1 08024b61 0801c81d     =K......aK......
 8032b40:	0801c855 0801c875 0801c8b5 08024b85     U...u........K..

08032b50 <sstbl.4504>:
 8032b50:	001f4000 000fa000 0007d000 0003e800     .@..............
 8032b60:	0001f400 0000fa00 00007d00 00003e80     .........}...>..
 8032b70:	00001f40 00000fa0 00000000              @...........

08032b7c <cstbl.4505>:
 8032b7c:	40008000 10002000 40000800 10002000     ...@. .....@. ..
 8032b8c:	04000800 00000200                       ........

08032b94 <fatstr.4303>:
 8032b94:	00544146                                FAT.

08032b98 <_ZTV12CFileHandler>:
	...
 8032ba0:	08024b3d 080199a1 08024b61 080212e1     =K......aK......
 8032bb0:	08021319 08021339 08021431 08024b85     ....9...1....K..

08032bc0 <_ZTV24CLedHeartBeatSTM32F4Disc>:
	...
 8032bc8:	08024b3d 080199a1 08024b61 08022015     =K......aK... ..
 8032bd8:	0802204d 0802206d 080220a5 08024b85     M ..m ... ...K..
 8032be8:	7566202c 6974636e 203a6e6f 00000000     , function: ....
 8032bf8:	65737361 6f697472 2522206e 66202273     assertion "%s" f
 8032c08:	656c6961 66203a64 20656c69 22732522     ailed: file "%s"
 8032c18:	696c202c 2520656e 25732564 00000a73     , line %d%s%s...
 8032c28:	00000043                                C...

08032c2c <_global_impure_ptr>:
 8032c2c:	200000e8                                ... 

08032c30 <_DAYS_BEFORE_MONTH>:
 8032c30:	00000000 0000001f 0000003b 0000005a     ........;...Z...
 8032c40:	00000078 00000097 000000b5 000000d4     x...............
 8032c50:	000000f3 00000111 00000130 0000014e     ........0...N...

08032c60 <DAYS_IN_MONTH>:
 8032c60:	0000001f 0000001c 0000001f 0000001e     ................
 8032c70:	0000001f 0000001e 0000001f 0000001f     ................
 8032c80:	0000001e 0000001f 0000001e 0000001f     ................

08032c90 <mon_lengths>:
 8032c90:	0000001f 0000001c 0000001f 0000001e     ................
 8032ca0:	0000001f 0000001e 0000001f 0000001f     ................
 8032cb0:	0000001e 0000001f 0000001e 0000001f     ................
 8032cc0:	0000001f 0000001d 0000001f 0000001e     ................
 8032cd0:	0000001f 0000001e 0000001f 0000001f     ................
 8032ce0:	0000001e 0000001f 0000001e 0000001f     ................

08032cf0 <year_lengths>:
 8032cf0:	0000016d 0000016e 2e257325 0000642a     m...n...%s%.*d..
 8032d00:	30257325 00642a2e 0000002b 0000002d     %s%0.*d.+...-...
 8032d10:	64322e25 00000000 00643225 64322e25     %.2d....%2d.%.2d
 8032d20:	322e252f 2e252f64 00006432 00756c25     /%.2d/%.2d..%lu.
 8032d30:	6d252d59 0064252d 00752a2e 64332e25     Y-%m-%d..*u.%.3d
 8032d40:	00000000 64322e25 322e253a 00000064     ....%.2d:%.2d...
 8032d50:	64322e25 322e253a 2e253a64 00006432     %.2d:%.2d:%.2d..
 8032d60:	33302b25 2e25646c 00646c32              %+03ld%.2ld.

08032d6c <zeroes.6590>:
 8032d6c:	30303030 30303030 30303030 30303030     0000000000000000
 8032d7c:	00464e49 00666e69 004e414e 006e616e     INF.inf.NAN.nan.
 8032d8c:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 8032d9c:	00000000 33323130 37363534 62613938     ....0123456789ab
 8032dac:	66656463 00000000 6c756e28 0000296c     cdef....(null)..
 8032dbc:	00000030                                0...

08032dc0 <blanks.6589>:
 8032dc0:	20202020 20202020 20202020 20202020                     

08032dd0 <_C_time_locale>:
 8032dd0:	08032ed4 08032ed8 08032edc 08032ee0     ................
 8032de0:	08032ee4 08032ee8 08032eec 08032ef0     ................
 8032df0:	08032ef4 08032ef8 08032efc 08032f00     ............./..
 8032e00:	08032f04 08032f0c 08032f18 08032f20     ./.../.../.. /..
 8032e10:	08032ee4 08032f28 08032f30 08032f38     ....(/..0/..8/..
 8032e20:	08032f40 08032f4c 08032f54 08032f60     @/..L/..T/..`/..
 8032e30:	08032f6c 08032f70 08032f74 08032f78     l/..p/..t/..x/..
 8032e40:	08032f7c 08032f80 08032f84 08032f88     |/.../.../.../..
 8032e50:	08032f90 08032f98 08032fa0 08032fac     ./.../.../.../..
 8032e60:	08032fb8 08032fc0 08032fcc 08032fd8     ./.../.../.../..
 8032e70:	08032fe4 08032ffc 08033000 08033004     ./.../...0...0..
 8032e80:	08032f04 08032f0c 08032f18 08032f20     ./.../.../.. /..
 8032e90:	08032ee4 08032f28 08032f30 08032f38     ....(/..0/..8/..
 8032ea0:	08032f40 08032f4c 08032f54 08032f60     @/..L/..T/..`/..
 8032eb0:	0803301c 08033020 08032bf4 08032bf4     .0.. 0...+...+..
 8032ec0:	08032bf4 08032bf4 08032bf4 545f434c     .+...+...+..LC_T
 8032ed0:	00454d49 006e614a 00626546 0072614d     IME.Jan.Feb.Mar.
 8032ee0:	00727041 0079614d 006e754a 006c754a     Apr.May.Jun.Jul.
 8032ef0:	00677541 00706553 0074634f 00766f4e     Aug.Sep.Oct.Nov.
 8032f00:	00636544 756e614a 00797261 72626546     Dec.January.Febr
 8032f10:	79726175 00000000 6372614d 00000068     uary....March...
 8032f20:	69727041 0000006c 656e754a 00000000     April...June....
 8032f30:	796c754a 00000000 75677541 00007473     July....August..
 8032f40:	74706553 65626d65 00000072 6f74634f     September...Octo
 8032f50:	00726562 65766f4e 7265626d 00000000     ber.November....
 8032f60:	65636544 7265626d 00000000 006e7553     December....Sun.
 8032f70:	006e6f4d 00657554 00646557 00756854     Mon.Tue.Wed.Thu.
 8032f80:	00697246 00746153 646e7553 00007961     Fri.Sat.Sunday..
 8032f90:	646e6f4d 00007961 73657554 00796164     Monday..Tuesday.
 8032fa0:	6e646557 61647365 00000079 72756854     Wednesday...Thur
 8032fb0:	79616473 00000000 64697246 00007961     sday....Friday..
 8032fc0:	75746153 79616472 00000000 253a4825     Saturday....%H:%
 8032fd0:	53253a4d 00000000 252f6d25 79252f64     M:%S....%m/%d/%y
 8032fe0:	00000000 25206125 65252062 3a482520     ....%a %b %e %H:
 8032ff0:	253a4d25 59252053 00000000 00004d41     %M:%S %Y....AM..
 8033000:	00004d50 25206125 65252062 3a482520     PM..%a %b %e %H:
 8033010:	253a4d25 5a252053 00592520 0000646d     %M:%S %Z %Y.md..
 8033020:	253a4925 53253a4d 00702520 00544d47     %I:%M:%S %p.GMT.

08033030 <zeroes.6548>:
 8033030:	30303030 30303030 30303030 30303030     0000000000000000

08033040 <blanks.6547>:
 8033040:	20202020 20202020 20202020 20202020                     

08033050 <_ctype_>:
 8033050:	20202000 20202020 28282020 20282828     .         ((((( 
 8033060:	20202020 20202020 20202020 20202020                     
 8033070:	10108820 10101010 10101010 10101010      ...............
 8033080:	04040410 04040404 10040404 10101010     ................
 8033090:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80330a0:	01010101 01010101 01010101 10101010     ................
 80330b0:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80330c0:	02020202 02020202 02020202 10101010     ................
 80330d0:	00000020 00000000 00000000 00000000      ...............
	...
 8033154:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.
 8033164:	49534f50 00000058 0000002e              POSIX.......

08033170 <__mprec_tens>:
 8033170:	00000000 3ff00000 00000000 40240000     .......?......$@
 8033180:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
 8033190:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
 80331a0:	00000000 412e8480 00000000 416312d0     .......A......cA
 80331b0:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
 80331c0:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
 80331d0:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
 80331e0:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
 80331f0:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
 8033200:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
 8033210:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
 8033220:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
 8033230:	79d99db4 44ea7843                       ...yCx.D

08033238 <__mprec_bigtens>:
 8033238:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
 8033248:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
 8033258:	7f73bf3c 75154fdd                       <.s..O.u

08033260 <p05.5111>:
 8033260:	00000005 00000019 0000007d              ........}...

0803326c <_init>:
 803326c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803326e:	bf00      	nop
 8033270:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8033272:	bc08      	pop	{r3}
 8033274:	469e      	mov	lr, r3
 8033276:	4770      	bx	lr

08033278 <_fini>:
 8033278:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803327a:	bf00      	nop
 803327c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803327e:	bc08      	pop	{r3}
 8033280:	469e      	mov	lr, r3
 8033282:	4770      	bx	lr
