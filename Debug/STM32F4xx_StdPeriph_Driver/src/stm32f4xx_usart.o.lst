   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"stm32f4xx_usart.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.USART_DeInit,"ax",%progbits
  19              		.align	1
  20              		.global	USART_DeInit
  21              		.thumb
  22              		.thumb_func
  24              	USART_DeInit:
  25              	.LFB110:
  26              		.file 1 "../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c"
   1:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
   2:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ******************************************************************************
   3:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @file    stm32f4xx_usart.c
   4:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @author  MCD Application Team
   5:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @version V1.0.0RC1
   6:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @date    25-August-2011
   7:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          functionalities of the Universal synchronous asynchronous receiver
   9:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          transmitter (USART):           
  10:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Initialization and Configuration
  11:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Data transfers
  12:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Multi-Processor Communication
  13:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - LIN mode
  14:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Half-duplex mode
  15:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Smartcard mode
  16:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - IrDA mode
  17:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - DMA transfers management
  18:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           - Interrupts and flags management 
  19:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *           
  20:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *  @verbatim
  21:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *      
  22:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          ===================================================================
  23:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                                 How to use this driver
  24:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          ===================================================================
  25:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          1. Enable peripheral clock using the follwoing functions
  26:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
  27:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or 
  28:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  29:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          2.  According to the USART mode, enable the GPIO clocks using 
  30:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *              RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
  31:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *              or/and SCLK). 
  32:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  33:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          3. Peripheral's alternate function: 
  34:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                 - Connect the pin to the desired peripherals' Alternate 
  35:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   Function (AF) using GPIO_PinAFConfig() function
  36:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                 - Configure the desired pin in alternate function by:
  37:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
  38:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                 - Select the type, pull-up/pull-down and output speed via 
  39:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
  40:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                 - Call GPIO_Init() function
  41:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *        
  42:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
  43:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             flow control and Mode(Receiver/Transmitter) using the USART_Init()
  44:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             function.
  45:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  46:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          5. For synchronous mode, enable the clock and program the polarity,
  47:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             phase and last bit using the USART_ClockInit() function.
  48:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  49:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          5. Enable the NVIC and the corresponding interrupt using the function 
  50:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *             USART_ITConfig() if you need to use interrupt mode. 
  51:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  52:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          6. When using the DMA mode 
  53:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   - Configure the DMA using DMA_Init() function
  54:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *                   - Active the needed channel Request using USART_DMACmd() function
  55:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * 
  56:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          7. Enable the USART using the USART_Cmd() function.
  57:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * 
  58:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
  59:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  60:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
  61:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          for more details
  62:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          
  63:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          In order to reach higher communication baudrates, it is possible to
  64:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
  65:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd(
  66:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          and before calling the function USART_Init().
  67:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          
  68:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *  @endverbatim
  69:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *        
  70:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ******************************************************************************
  71:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @attention
  72:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  73:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  74:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  75:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  76:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  77:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  78:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  79:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
  80:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  81:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ******************************************************************************  
  82:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */ 
  83:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
  84:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Includes ------------------------------------------------------------------*/
  85:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #include "stm32f4xx_usart.h"
  86:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #include "stm32f4xx_rcc.h"
  87:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
  88:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @addtogroup STM32F4xx_StdPeriph_Driver
  89:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
  90:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
  91:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
  92:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART 
  93:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief USART driver modules
  94:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
  95:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
  96:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
  97:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private typedef -----------------------------------------------------------*/
  98:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private define ------------------------------------------------------------*/
  99:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 100:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
 101:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
 102:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                               USART_CR1_PS | USART_CR1_TE | \
 103:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                               USART_CR1_RE))
 104:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 105:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
 106:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
 107:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                               USART_CR2_CPHA | USART_CR2_LBCL))
 108:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 109:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
 110:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
 111:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 112:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*!< USART Interrupts mask */
 113:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** #define IT_MASK                   ((uint16_t)0x001F)
 114:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 115:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private macro -------------------------------------------------------------*/
 116:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private variables ---------------------------------------------------------*/
 117:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private function prototypes -----------------------------------------------*/
 118:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /* Private functions ---------------------------------------------------------*/
 119:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 120:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Private_Functions
 121:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 122:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 123:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 124:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group1 Initialization and Configuration functions
 125:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Initialization and Configuration functions 
 126:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 127:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 128:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 129:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                   Initialization and Configuration functions
 130:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 131:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 132:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to initialize the USART 
 133:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   in asynchronous and in synchronous modes.
 134:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    - For the asynchronous mode only these parameters can be configured: 
 135:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Baud Rate
 136:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Word Length 
 137:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Stop Bit
 138:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Parity: If the parity is enabled, then the MSB bit of the data written
 139:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****           in the data register is transmitted but is changed by the parity bit.
 140:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****           Depending on the frame length defined by the M bit (8-bits or 9-bits),
 141:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****           the possible USART frame formats are as listed in the following table:
 142:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    +-------------------------------------------------------------+     
 143:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |   M bit |  PCE bit  |            USART frame                |
 144:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |---------------------|---------------------------------------|             
 145:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |    0    |    0      |    | SB | 8 bit data | STB |          |
 146:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 147:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
 148:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 149:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |    1    |    0      |    | SB | 9 bit data | STB |          |
 150:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 151:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
 152:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****    +-------------------------------------------------------------+            
 153:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Hardware flow control
 154:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Receiver/transmitter modes
 155:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 156:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The USART_Init() function follows the USART  asynchronous configuration procedure
 157:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   (details for the procedure are available in reference manual (RM0090)).
 158:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 159:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   - For the synchronous mode in addition to the asynchronous mode parameters these 
 160:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     parameters should be also configured:
 161:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART Clock Enabled
 162:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART polarity
 163:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART phase
 164:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART LastBit
 165:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 166:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   These parameters can be configured using the USART_ClockInit() function.
 167:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 168:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 169:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 170:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 171:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 172:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 173:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
 174:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 175:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 176:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 177:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 178:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
 179:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
  27              		.loc 1 179 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 08B5     		push	{r3, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 14, -4
  36              		.cfi_offset 3, -8
 180:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 181:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 182:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 183:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USARTx == USART1)
  37              		.loc 1 183 0
  38 0002 234B     		ldr	r3, .L10
  39 0004 9842     		cmp	r0, r3
  40 0006 05D1     		bne	.L2
 184:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 185:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  41              		.loc 1 185 0
  42 0008 1020     		movs	r0, #16
  43              	.LVL1:
  44 000a 0121     		movs	r1, #1
  45 000c FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 186:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  46              		.loc 1 186 0
  47 0010 1020     		movs	r0, #16
  48 0012 37E0     		b	.L8
  49              	.LVL2:
  50              	.L2:
 187:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 188:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == USART2)
  51              		.loc 1 188 0
  52 0014 1F4B     		ldr	r3, .L10+4
  53 0016 9842     		cmp	r0, r3
  54 0018 07D1     		bne	.L3
 189:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 190:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
  55              		.loc 1 190 0
  56 001a 4FF40030 		mov	r0, #131072
  57              	.LVL3:
  58 001e 0121     		movs	r1, #1
  59 0020 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 191:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  60              		.loc 1 191 0
  61 0024 4FF40030 		mov	r0, #131072
  62 0028 09E0     		b	.L9
  63              	.LVL4:
  64              	.L3:
 192:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 193:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == USART3)
  65              		.loc 1 193 0
  66 002a 1B4B     		ldr	r3, .L10+8
  67 002c 9842     		cmp	r0, r3
  68 002e 0BD1     		bne	.L4
 194:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 195:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
  69              		.loc 1 195 0
  70 0030 4FF48020 		mov	r0, #262144
  71              	.LVL5:
  72 0034 0121     		movs	r1, #1
  73 0036 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 196:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  74              		.loc 1 196 0
  75 003a 4FF48020 		mov	r0, #262144
  76              	.L9:
  77 003e 0021     		movs	r1, #0
 197:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }    
 198:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == UART4)
 199:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 200:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 201:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 202:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 203:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == UART5)
 204:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 205:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 206:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 207:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }     
 208:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 209:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 210:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     if (USARTx == USART6)
 211:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     { 
 212:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 213:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 214:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     }
 215:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 216:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
  78              		.loc 1 216 0
  79 0040 BDE80840 		pop	{r3, lr}
 196:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  80              		.loc 1 196 0
  81 0044 FFF7FEBF 		b	RCC_APB1PeriphResetCmd
  82              	.LVL6:
  83              	.L4:
 198:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == UART4)
  84              		.loc 1 198 0
  85 0048 144B     		ldr	r3, .L10+12
  86 004a 9842     		cmp	r0, r3
  87 004c 07D1     		bne	.L5
 200:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
  88              		.loc 1 200 0
  89 004e 4FF40020 		mov	r0, #524288
  90              	.LVL7:
  91 0052 0121     		movs	r1, #1
  92 0054 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 201:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
  93              		.loc 1 201 0
  94 0058 4FF40020 		mov	r0, #524288
  95 005c EFE7     		b	.L9
  96              	.LVL8:
  97              	.L5:
 203:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (USARTx == UART5)
  98              		.loc 1 203 0
  99 005e 104B     		ldr	r3, .L10+16
 100 0060 9842     		cmp	r0, r3
 101 0062 07D1     		bne	.L6
 205:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 102              		.loc 1 205 0
 103 0064 4FF48010 		mov	r0, #1048576
 104              	.LVL9:
 105 0068 0121     		movs	r1, #1
 106 006a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 206:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 107              		.loc 1 206 0
 108 006e 4FF48010 		mov	r0, #1048576
 109 0072 E4E7     		b	.L9
 110              	.LVL10:
 111              	.L6:
 210:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     if (USARTx == USART6)
 112              		.loc 1 210 0
 113 0074 0B4B     		ldr	r3, .L10+20
 114 0076 9842     		cmp	r0, r3
 115 0078 09D1     		bne	.L1
 212:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 116              		.loc 1 212 0
 117 007a 2020     		movs	r0, #32
 118              	.LVL11:
 119 007c 0121     		movs	r1, #1
 120 007e FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 213:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 121              		.loc 1 213 0
 122 0082 2020     		movs	r0, #32
 123              	.L8:
 124 0084 0021     		movs	r1, #0
 125              		.loc 1 216 0
 126 0086 BDE80840 		pop	{r3, lr}
 213:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 127              		.loc 1 213 0
 128 008a FFF7FEBF 		b	RCC_APB2PeriphResetCmd
 129              	.LVL12:
 130              	.L1:
 131 008e 08BD     		pop	{r3, pc}
 132              	.L11:
 133              		.align	2
 134              	.L10:
 135 0090 00100140 		.word	1073811456
 136 0094 00440040 		.word	1073759232
 137 0098 00480040 		.word	1073760256
 138 009c 004C0040 		.word	1073761280
 139 00a0 00500040 		.word	1073762304
 140 00a4 00140140 		.word	1073812480
 141              		.cfi_endproc
 142              	.LFE110:
 144              		.section	.text.USART_Init,"ax",%progbits
 145              		.align	1
 146              		.global	USART_Init
 147              		.thumb
 148              		.thumb_func
 150              	USART_Init:
 151              	.LFB111:
 217:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 218:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 219:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Initializes the USARTx peripheral according to the specified
 220:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         parameters in the USART_InitStruct .
 221:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 222:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 223:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
 224:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         the configuration information for the specified USART peripheral.
 225:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 226:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 227:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 228:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 152              		.loc 1 228 0
 153              		.cfi_startproc
 154              		@ args = 0, pretend = 0, frame = 16
 155              		@ frame_needed = 0, uses_anonymous_args = 0
 156              	.LVL13:
 157 0000 30B5     		push	{r4, r5, lr}
 158              	.LCFI1:
 159              		.cfi_def_cfa_offset 12
 160              		.cfi_offset 14, -4
 161              		.cfi_offset 5, -8
 162              		.cfi_offset 4, -12
 229:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t tmpreg = 0x00, apbclock = 0x00;
 230:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t integerdivider = 0x00;
 231:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t fractionaldivider = 0x00;
 232:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 233:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 234:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 235:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 236:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 237:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 238:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 239:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 240:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 241:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 242:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 243:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
 244:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
 245:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 246:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
 247:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 248:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 249:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 250:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 163              		.loc 1 250 0
 164 0002 038A     		ldrh	r3, [r0, #16]
 251:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 252:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear STOP[13:12] bits */
 253:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 254:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 255:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
 256:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       Set STOP[13:12] bits according to USART_StopBits value */
 257:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 165              		.loc 1 257 0
 166 0004 CA88     		ldrh	r2, [r1, #6]
 250:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 167              		.loc 1 250 0
 168 0006 9BB2     		uxth	r3, r3
 169              	.LVL14:
 253:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 170              		.loc 1 253 0
 171 0008 23F44053 		bic	r3, r3, #12288
 172              	.LVL15:
 228:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 173              		.loc 1 228 0
 174 000c 0D46     		mov	r5, r1
 258:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 259:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART CR2 */
 260:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 175              		.loc 1 260 0
 176 000e 1343     		orrs	r3, r3, r2
 177              	.LVL16:
 178 0010 0382     		strh	r3, [r0, #16]	@ movhi
 261:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 262:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART CR1 Configuration -----------------------*/
 263:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR1;
 179              		.loc 1 263 0
 180 0012 8389     		ldrh	r3, [r0, #12]
 181              	.LVL17:
 264:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 265:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 266:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 267:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 268:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART Word Length, Parity and mode: 
 269:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      Set the M bits according to USART_WordLength value 
 270:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      Set PCE and PS bits according to USART_Parity value
 271:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      Set TE and RE bits according to USART_Mode value */
 272:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 182              		.loc 1 272 0
 183 0014 0989     		ldrh	r1, [r1, #8]
 184              	.LVL18:
 185 0016 AA88     		ldrh	r2, [r5, #4]
 266:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 186              		.loc 1 266 0
 187 0018 23F4B053 		bic	r3, r3, #5632
 188              	.LVL19:
 189              		.loc 1 272 0
 190 001c 0A43     		orrs	r2, r2, r1
 191 001e 6989     		ldrh	r1, [r5, #10]
 266:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 192              		.loc 1 266 0
 193 0020 23F00C03 		bic	r3, r3, #12
 194 0024 1B04     		lsls	r3, r3, #16
 195              		.loc 1 272 0
 196 0026 0A43     		orrs	r2, r2, r1
 266:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 197              		.loc 1 266 0
 198 0028 1B0C     		lsrs	r3, r3, #16
 199              		.loc 1 272 0
 200 002a 92B2     		uxth	r2, r2
 273:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****             USART_InitStruct->USART_Mode;
 274:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 275:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART CR1 */
 276:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR1 = (uint16_t)tmpreg;
 201              		.loc 1 276 0
 202 002c 1343     		orrs	r3, r3, r2
 203 002e 8381     		strh	r3, [r0, #12]	@ movhi
 277:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 278:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART CR3 Configuration -----------------------*/  
 279:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR3;
 204              		.loc 1 279 0
 205 0030 838A     		ldrh	r3, [r0, #20]
 280:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 281:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear CTSE and RTSE bits */
 282:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 283:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 284:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART HFC : 
 285:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 286:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 206              		.loc 1 286 0
 207 0032 AA89     		ldrh	r2, [r5, #12]
 279:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR3;
 208              		.loc 1 279 0
 209 0034 9BB2     		uxth	r3, r3
 210              	.LVL20:
 282:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 211              		.loc 1 282 0
 212 0036 23F44073 		bic	r3, r3, #768
 213              	.LVL21:
 287:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 288:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART CR3 */
 289:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR3 = (uint16_t)tmpreg;
 214              		.loc 1 289 0
 215 003a 1343     		orrs	r3, r3, r2
 216              	.LVL22:
 228:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 217              		.loc 1 228 0
 218 003c 85B0     		sub	sp, sp, #20
 219              	.LCFI2:
 220              		.cfi_def_cfa_offset 32
 228:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 221              		.loc 1 228 0
 222 003e 0446     		mov	r4, r0
 223              		.loc 1 289 0
 224 0040 8382     		strh	r3, [r0, #20]	@ movhi
 290:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 291:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART BRR Configuration -----------------------*/
 292:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART Baud Rate */
 293:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 225              		.loc 1 293 0
 226 0042 6846     		mov	r0, sp
 227              	.LVL23:
 228 0044 FFF7FEFF 		bl	RCC_GetClocksFreq
 229              	.LVL24:
 294:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 295:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USARTx == USART1) || (USARTx == USART6))
 230              		.loc 1 295 0
 231 0048 1C4B     		ldr	r3, .L21
 232 004a E21A     		subs	r2, r4, r3
 233 004c 5342     		rsbs	r3, r2, #0
 234 004e 43EB0203 		adc	r3, r3, r2
 235 0052 1B4A     		ldr	r2, .L21+4
 236 0054 9442     		cmp	r4, r2
 237 0056 08BF     		it	eq
 238 0058 43F00103 		orreq	r3, r3, #1
 239 005c 0BB1     		cbz	r3, .L13
 296:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 297:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 240              		.loc 1 297 0
 241 005e 039B     		ldr	r3, [sp, #12]
 242              	.LVL25:
 243 0060 00E0     		b	.L14
 244              	.LVL26:
 245              	.L13:
 298:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 299:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 300:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 301:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 246              		.loc 1 301 0
 247 0062 029B     		ldr	r3, [sp, #8]
 248              	.LVL27:
 249              	.L14:
 302:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 303:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 304:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Determine the integer part */
 305:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 250              		.loc 1 305 0
 251 0064 A289     		ldrh	r2, [r4, #12]
 252 0066 12B2     		sxth	r2, r2
 253 0068 002A     		cmp	r2, #0
 254 006a 4FF01901 		mov	r1, #25
 255 006e 2A68     		ldr	r2, [r5, #0]
 306:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 307:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Integer part computing in case Oversampling mode is 8 Samples */
 308:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 256              		.loc 1 308 0
 257 0070 01FB03F1 		mul	r1, r1, r3
 305:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 258              		.loc 1 305 0
 259 0074 01DA     		bge	.L15
 260              		.loc 1 308 0
 261 0076 5200     		lsls	r2, r2, #1
 262 0078 00E0     		b	.L19
 263              	.L15:
 309:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 310:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
 311:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 312:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Integer part computing in case Oversampling mode is 16 Samples */
 313:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 264              		.loc 1 313 0
 265 007a 9200     		lsls	r2, r2, #2
 266              	.L19:
 314:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 315:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = (integerdivider / 100) << 4;
 267              		.loc 1 315 0
 268 007c 6423     		movs	r3, #100
 269              	.LVL28:
 313:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 270              		.loc 1 313 0
 271 007e B1FBF2F1 		udiv	r1, r1, r2
 272              	.LVL29:
 273              		.loc 1 315 0
 274 0082 B1FBF3F2 		udiv	r2, r1, r3
 275 0086 1201     		lsls	r2, r2, #4
 276              	.LVL30:
 316:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 317:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Determine the fractional part */
 318:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 277              		.loc 1 318 0
 278 0088 1009     		lsrs	r0, r2, #4
 279 008a 03FB1011 		mls	r1, r3, r0, r1
 280              	.LVL31:
 319:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 320:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Implement the fractional part in the register */
 321:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 281              		.loc 1 321 0
 282 008e A089     		ldrh	r0, [r4, #12]
 283 0090 00B2     		sxth	r0, r0
 284 0092 0028     		cmp	r0, #0
 285 0094 06DA     		bge	.L17
 322:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 323:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 286              		.loc 1 323 0
 287 0096 C900     		lsls	r1, r1, #3
 288              	.LVL32:
 289 0098 3231     		adds	r1, r1, #50
 290 009a B1FBF3F3 		udiv	r3, r1, r3
 291 009e 03F00703 		and	r3, r3, #7
 292 00a2 05E0     		b	.L20
 293              	.LVL33:
 294              	.L17:
 324:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 325:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
 326:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 327:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 295              		.loc 1 327 0
 296 00a4 0901     		lsls	r1, r1, #4
 297              	.LVL34:
 298 00a6 3231     		adds	r1, r1, #50
 299 00a8 B1FBF3F3 		udiv	r3, r1, r3
 300 00ac 03F00F03 		and	r3, r3, #15
 301              	.L20:
 302 00b0 1A43     		orrs	r2, r2, r3
 303              	.LVL35:
 328:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 329:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 330:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART BRR register */
 331:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->BRR = (uint16_t)tmpreg;
 304              		.loc 1 331 0
 305 00b2 92B2     		uxth	r2, r2
 306              	.LVL36:
 307 00b4 2281     		strh	r2, [r4, #8]	@ movhi
 332:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 308              		.loc 1 332 0
 309 00b6 05B0     		add	sp, sp, #20
 310 00b8 30BD     		pop	{r4, r5, pc}
 311              	.L22:
 312 00ba 00BF     		.align	2
 313              	.L21:
 314 00bc 00100140 		.word	1073811456
 315 00c0 00140140 		.word	1073812480
 316              		.cfi_endproc
 317              	.LFE111:
 319              		.section	.text.USART_StructInit,"ax",%progbits
 320              		.align	1
 321              		.global	USART_StructInit
 322              		.thumb
 323              		.thumb_func
 325              	USART_StructInit:
 326              	.LFB112:
 333:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 334:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 335:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Fills each USART_InitStruct member with its default value.
 336:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
 337:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         be initialized.
 338:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 339:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 340:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 341:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 327              		.loc 1 341 0
 328              		.cfi_startproc
 329              		@ args = 0, pretend = 0, frame = 0
 330              		@ frame_needed = 0, uses_anonymous_args = 0
 331              		@ link register save eliminated.
 332              	.LVL37:
 342:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* USART_InitStruct members default value */
 343:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
 333              		.loc 1 343 0
 334 0000 4FF41653 		mov	r3, #9600
 335 0004 0360     		str	r3, [r0, #0]
 344:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 345:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 346:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 347:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 336              		.loc 1 347 0
 337 0006 0C22     		movs	r2, #12
 344:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 338              		.loc 1 344 0
 339 0008 0023     		movs	r3, #0
 340 000a 8380     		strh	r3, [r0, #4]	@ movhi
 345:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 341              		.loc 1 345 0
 342 000c C380     		strh	r3, [r0, #6]	@ movhi
 346:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 343              		.loc 1 346 0
 344 000e 0381     		strh	r3, [r0, #8]	@ movhi
 345              		.loc 1 347 0
 346 0010 4281     		strh	r2, [r0, #10]	@ movhi
 348:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 347              		.loc 1 348 0
 348 0012 8381     		strh	r3, [r0, #12]	@ movhi
 349:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 349              		.loc 1 349 0
 350 0014 7047     		bx	lr
 351              		.cfi_endproc
 352              	.LFE112:
 354              		.section	.text.USART_ClockInit,"ax",%progbits
 355              		.align	1
 356              		.global	USART_ClockInit
 357              		.thumb
 358              		.thumb_func
 360              	USART_ClockInit:
 361              	.LFB113:
 350:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 351:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 352:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Initializes the USARTx peripheral Clock according to the 
 353:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         specified parameters in the USART_ClockInitStruct .
 354:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
 355:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
 356:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         contains the configuration information for the specified  USART peripheral.
 357:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
 358:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 359:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 360:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 361:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 362              		.loc 1 361 0
 363              		.cfi_startproc
 364              		@ args = 0, pretend = 0, frame = 0
 365              		@ frame_needed = 0, uses_anonymous_args = 0
 366              	.LVL38:
 362:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t tmpreg = 0x00;
 363:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 364:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 365:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 366:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 367:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 368:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
 369:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 370:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 371:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 372:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear CLKEN, CPOL, CPHA and LBCL bits */
 373:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 374:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
 375:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 376:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 377:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
 378:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 379:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 380:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                  USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 367              		.loc 1 380 0
 368 0000 0B88     		ldrh	r3, [r1, #0]
 371:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 369              		.loc 1 371 0
 370 0002 028A     		ldrh	r2, [r0, #16]
 361:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 371              		.loc 1 361 0
 372 0004 10B5     		push	{r4, lr}
 373              	.LCFI3:
 374              		.cfi_def_cfa_offset 8
 375              		.cfi_offset 14, -4
 376              		.cfi_offset 4, -8
 377              		.loc 1 380 0
 378 0006 4C88     		ldrh	r4, [r1, #2]
 379 0008 2343     		orrs	r3, r3, r4
 380 000a 8C88     		ldrh	r4, [r1, #4]
 381 000c C988     		ldrh	r1, [r1, #6]
 382              	.LVL39:
 383 000e 2343     		orrs	r3, r3, r4
 371:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 384              		.loc 1 371 0
 385 0010 92B2     		uxth	r2, r2
 386              	.LVL40:
 387              		.loc 1 380 0
 388 0012 0B43     		orrs	r3, r3, r1
 373:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 389              		.loc 1 373 0
 390 0014 22F47062 		bic	r2, r2, #3840
 391              	.LVL41:
 392              		.loc 1 380 0
 393 0018 9BB2     		uxth	r3, r3
 381:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Write to USART CR2 */
 382:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 394              		.loc 1 382 0
 395 001a 1343     		orrs	r3, r3, r2
 396 001c 0382     		strh	r3, [r0, #16]	@ movhi
 383:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 397              		.loc 1 383 0
 398 001e 10BD     		pop	{r4, pc}
 399              		.cfi_endproc
 400              	.LFE113:
 402              		.section	.text.USART_ClockStructInit,"ax",%progbits
 403              		.align	1
 404              		.global	USART_ClockStructInit
 405              		.thumb
 406              		.thumb_func
 408              	USART_ClockStructInit:
 409              	.LFB114:
 384:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 385:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 386:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Fills each USART_ClockInitStruct member with its default value.
 387:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
 388:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         which will be initialized.
 389:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 390:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 391:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 392:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 410              		.loc 1 392 0
 411              		.cfi_startproc
 412              		@ args = 0, pretend = 0, frame = 0
 413              		@ frame_needed = 0, uses_anonymous_args = 0
 414              		@ link register save eliminated.
 415              	.LVL42:
 393:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* USART_ClockInitStruct members default value */
 394:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 416              		.loc 1 394 0
 417 0000 0023     		movs	r3, #0
 418 0002 0380     		strh	r3, [r0, #0]	@ movhi
 395:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 419              		.loc 1 395 0
 420 0004 4380     		strh	r3, [r0, #2]	@ movhi
 396:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 421              		.loc 1 396 0
 422 0006 8380     		strh	r3, [r0, #4]	@ movhi
 397:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 423              		.loc 1 397 0
 424 0008 C380     		strh	r3, [r0, #6]	@ movhi
 398:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 425              		.loc 1 398 0
 426 000a 7047     		bx	lr
 427              		.cfi_endproc
 428              	.LFE114:
 430              		.section	.text.USART_Cmd,"ax",%progbits
 431              		.align	1
 432              		.global	USART_Cmd
 433              		.thumb
 434              		.thumb_func
 436              	USART_Cmd:
 437              	.LFB115:
 399:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 400:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 401:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the specified USART peripheral.
 402:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 403:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 404:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USARTx peripheral.
 405:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 406:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 407:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 408:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 409:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 438              		.loc 1 409 0
 439              		.cfi_startproc
 440              		@ args = 0, pretend = 0, frame = 0
 441              		@ frame_needed = 0, uses_anonymous_args = 0
 442              		@ link register save eliminated.
 443              	.LVL43:
 410:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 411:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 412:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 413:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 414:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 415:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 416:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 417:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_UE;
 444              		.loc 1 417 0
 445 0000 8389     		ldrh	r3, [r0, #12]
 414:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 446              		.loc 1 414 0
 447 0002 19B1     		cbz	r1, .L27
 448              		.loc 1 417 0
 449 0004 9BB2     		uxth	r3, r3
 450 0006 43F40053 		orr	r3, r3, #8192
 451 000a 03E0     		b	.L29
 452              	.L27:
 418:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 419:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 420:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 421:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 422:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 453              		.loc 1 422 0
 454 000c 23F40053 		bic	r3, r3, #8192
 455 0010 1B04     		lsls	r3, r3, #16
 456 0012 1B0C     		lsrs	r3, r3, #16
 457              	.L29:
 458 0014 8381     		strh	r3, [r0, #12]	@ movhi
 459 0016 7047     		bx	lr
 460              		.cfi_endproc
 461              	.LFE115:
 463              		.section	.text.USART_SetPrescaler,"ax",%progbits
 464              		.align	1
 465              		.global	USART_SetPrescaler
 466              		.thumb
 467              		.thumb_func
 469              	USART_SetPrescaler:
 470              	.LFB116:
 423:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 424:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 425:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 426:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 427:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Sets the system clock prescaler.
 428:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 429:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 430:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_Prescaler: specifies the prescaler clock. 
 431:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   The function is used for IrDA mode with UART4 and UART5.   
 432:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 433:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 434:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
 435:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** { 
 471              		.loc 1 435 0
 472              		.cfi_startproc
 473              		@ args = 0, pretend = 0, frame = 0
 474              		@ frame_needed = 0, uses_anonymous_args = 0
 475              		@ link register save eliminated.
 476              	.LVL44:
 436:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 437:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 438:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 439:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear the USART prescaler */
 440:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->GTPR &= USART_GTPR_GT;
 477              		.loc 1 440 0
 478 0000 038B     		ldrh	r3, [r0, #24]
 479 0002 03F47F43 		and	r3, r3, #65280
 480 0006 0383     		strh	r3, [r0, #24]	@ movhi
 441:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set the USART prescaler */
 442:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 481              		.loc 1 442 0
 482 0008 038B     		ldrh	r3, [r0, #24]
 483 000a 9BB2     		uxth	r3, r3
 484 000c 1943     		orrs	r1, r1, r3
 485              	.LVL45:
 486 000e 0183     		strh	r1, [r0, #24]	@ movhi
 443:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 487              		.loc 1 443 0
 488 0010 7047     		bx	lr
 489              		.cfi_endproc
 490              	.LFE116:
 492              		.section	.text.USART_OverSampling8Cmd,"ax",%progbits
 493              		.align	1
 494              		.global	USART_OverSampling8Cmd
 495              		.thumb
 496              		.thumb_func
 498              	USART_OverSampling8Cmd:
 499              	.LFB117:
 444:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 445:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 446:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's 8x oversampling mode.
 447:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   This function has to be called before calling USART_Init() function
 448:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         in order to have correct baudrate Divider value.
 449:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 450:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 451:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART 8x oversampling mode.
 452:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 453:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 454:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 455:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 456:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 500              		.loc 1 456 0
 501              		.cfi_startproc
 502              		@ args = 0, pretend = 0, frame = 0
 503              		@ frame_needed = 0, uses_anonymous_args = 0
 504              		@ link register save eliminated.
 505              	.LVL46:
 457:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 458:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 459:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 460:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 461:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 462:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 463:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
 464:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_OVER8;
 506              		.loc 1 464 0
 507 0000 8389     		ldrh	r3, [r0, #12]
 461:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 508              		.loc 1 461 0
 509 0002 29B1     		cbz	r1, .L32
 510              		.loc 1 464 0
 511 0004 6FEA4343 		mvn	r3, r3, lsl #17
 512 0008 6FEA5343 		mvn	r3, r3, lsr #17
 513 000c 9BB2     		uxth	r3, r3
 514 000e 01E0     		b	.L34
 515              	.L32:
 465:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 466:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 467:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 468:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
 469:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
 516              		.loc 1 469 0
 517 0010 5B04     		lsls	r3, r3, #17
 518 0012 5B0C     		lsrs	r3, r3, #17
 519              	.L34:
 520 0014 8381     		strh	r3, [r0, #12]	@ movhi
 521 0016 7047     		bx	lr
 522              		.cfi_endproc
 523              	.LFE117:
 525              		.section	.text.USART_OneBitMethodCmd,"ax",%progbits
 526              		.align	1
 527              		.global	USART_OneBitMethodCmd
 528              		.thumb
 529              		.thumb_func
 531              	USART_OneBitMethodCmd:
 532              	.LFB118:
 470:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 471:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }  
 472:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 473:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 474:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's one bit sampling method.
 475:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 476:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 477:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 478:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 479:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 480:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 481:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 482:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 533              		.loc 1 482 0
 534              		.cfi_startproc
 535              		@ args = 0, pretend = 0, frame = 0
 536              		@ frame_needed = 0, uses_anonymous_args = 0
 537              		@ link register save eliminated.
 538              	.LVL47:
 483:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 484:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 485:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 486:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 487:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 488:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 489:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
 490:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_ONEBIT;
 539              		.loc 1 490 0
 540 0000 838A     		ldrh	r3, [r0, #20]
 487:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 541              		.loc 1 487 0
 542 0002 19B1     		cbz	r1, .L36
 543              		.loc 1 490 0
 544 0004 9BB2     		uxth	r3, r3
 545 0006 43F40063 		orr	r3, r3, #2048
 546 000a 03E0     		b	.L38
 547              	.L36:
 491:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 492:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 493:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 494:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
 495:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
 548              		.loc 1 495 0
 549 000c 23F40063 		bic	r3, r3, #2048
 550 0010 1B04     		lsls	r3, r3, #16
 551 0012 1B0C     		lsrs	r3, r3, #16
 552              	.L38:
 553 0014 8382     		strh	r3, [r0, #20]	@ movhi
 554 0016 7047     		bx	lr
 555              		.cfi_endproc
 556              	.LFE118:
 558              		.section	.text.USART_SendData,"ax",%progbits
 559              		.align	1
 560              		.global	USART_SendData
 561              		.thumb
 562              		.thumb_func
 564              	USART_SendData:
 565              	.LFB119:
 496:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 497:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 498:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 499:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 500:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 501:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 502:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 503:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group2 Data transfers functions
 504:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Data transfers functions 
 505:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 506:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 507:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 508:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                             Data transfers functions
 509:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 510:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 511:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART data 
 512:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   transfers.
 513:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 514:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   During an USART reception, data shifts in least significant bit first through 
 515:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
 516:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   between the internal bus and the received shift register.
 517:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 518:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   When a transmission is taking place, a write instruction to the USART_DR register 
 519:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   stores the data in the TDR register and which is copied in the shift register 
 520:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   at the end of the current transmission.
 521:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 522:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The read access of the USART_DR register can be done using the USART_ReceiveData()
 523:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   function and returns the RDR buffered value. Whereas a write access to the USART_DR 
 524:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   can be done using USART_SendData() function and stores the written data into 
 525:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   TDR buffer.
 526:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 527:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 528:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 529:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 530:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 531:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 532:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Transmits single data through the USARTx peripheral.
 533:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 534:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 535:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  Data: the data to transmit.
 536:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 537:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 538:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
 539:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 566              		.loc 1 539 0
 567              		.cfi_startproc
 568              		@ args = 0, pretend = 0, frame = 0
 569              		@ frame_needed = 0, uses_anonymous_args = 0
 570              		@ link register save eliminated.
 571              	.LVL48:
 540:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 541:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 542:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 543:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
 544:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Transmit Data */
 545:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->DR = (Data & (uint16_t)0x01FF);
 572              		.loc 1 545 0
 573 0000 C905     		lsls	r1, r1, #23
 574              	.LVL49:
 575 0002 C90D     		lsrs	r1, r1, #23
 576 0004 8180     		strh	r1, [r0, #4]	@ movhi
 546:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 577              		.loc 1 546 0
 578 0006 7047     		bx	lr
 579              		.cfi_endproc
 580              	.LFE119:
 582              		.section	.text.USART_ReceiveData,"ax",%progbits
 583              		.align	1
 584              		.global	USART_ReceiveData
 585              		.thumb
 586              		.thumb_func
 588              	USART_ReceiveData:
 589              	.LFB120:
 547:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 548:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 549:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Returns the most recent received data by the USARTx peripheral.
 550:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 551:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 552:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval The received data.
 553:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 554:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
 555:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 590              		.loc 1 555 0
 591              		.cfi_startproc
 592              		@ args = 0, pretend = 0, frame = 0
 593              		@ frame_needed = 0, uses_anonymous_args = 0
 594              		@ link register save eliminated.
 595              	.LVL50:
 556:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 557:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 558:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 559:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Receive Data */
 560:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 596              		.loc 1 560 0
 597 0000 8088     		ldrh	r0, [r0, #4]
 598              	.LVL51:
 599 0002 C005     		lsls	r0, r0, #23
 600 0004 C00D     		lsrs	r0, r0, #23
 561:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 601              		.loc 1 561 0
 602 0006 7047     		bx	lr
 603              		.cfi_endproc
 604              	.LFE120:
 606              		.section	.text.USART_SetAddress,"ax",%progbits
 607              		.align	1
 608              		.global	USART_SetAddress
 609              		.thumb
 610              		.thumb_func
 612              	USART_SetAddress:
 613              	.LFB121:
 562:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 563:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 564:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 565:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 566:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 567:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group3 MultiProcessor Communication functions
 568:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Multi-Processor Communication functions 
 569:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 570:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 571:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 572:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                     Multi-Processor Communication functions
 573:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 574:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 575:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART 
 576:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   multiprocessor communication.
 577:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 578:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   For instance one of the USARTs can be the master, its TX output is connected to 
 579:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the RX input of the other USART. The others are slaves, their respective TX outputs 
 580:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   are logically ANDed together and connected to the RX input of the master.
 581:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 582:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART multiprocessor communication is possible through the following procedure:
 583:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
 584:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         or Mode receiver and hardware flow control values using the USART_Init()
 585:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         function.
 586:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Configures the USART address using the USART_SetAddress() function.
 587:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
 588:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         using USART_WakeUpConfig() function only for the slaves.
 589:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Enable the USART using the USART_Cmd() function.
 590:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
 591:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 592:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The USART Slave exit from mute mode when receive the wake up condition.
 593:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 594:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 595:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 596:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 597:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 598:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 599:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Sets the address of the USART node.
 600:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 601:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 602:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_Address: Indicates the address of the USART node.
 603:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 604:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 605:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
 606:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 614              		.loc 1 606 0
 615              		.cfi_startproc
 616              		@ args = 0, pretend = 0, frame = 0
 617              		@ frame_needed = 0, uses_anonymous_args = 0
 618              		@ link register save eliminated.
 619              	.LVL52:
 607:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 608:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 609:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ADDRESS(USART_Address)); 
 610:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
 611:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear the USART address */
 612:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
 620              		.loc 1 612 0
 621 0000 038A     		ldrh	r3, [r0, #16]
 622 0002 23F00F03 		bic	r3, r3, #15
 623 0006 1B04     		lsls	r3, r3, #16
 624 0008 1B0C     		lsrs	r3, r3, #16
 625 000a 0382     		strh	r3, [r0, #16]	@ movhi
 613:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set the USART address node */
 614:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 |= USART_Address;
 626              		.loc 1 614 0
 627 000c 038A     		ldrh	r3, [r0, #16]
 628 000e 9BB2     		uxth	r3, r3
 629 0010 1943     		orrs	r1, r1, r3
 630              	.LVL53:
 631 0012 0182     		strh	r1, [r0, #16]	@ movhi
 615:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 632              		.loc 1 615 0
 633 0014 7047     		bx	lr
 634              		.cfi_endproc
 635              	.LFE121:
 637              		.section	.text.USART_ReceiverWakeUpCmd,"ax",%progbits
 638              		.align	1
 639              		.global	USART_ReceiverWakeUpCmd
 640              		.thumb
 641              		.thumb_func
 643              	USART_ReceiverWakeUpCmd:
 644              	.LFB122:
 616:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 617:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 618:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Determines if the USART is in mute mode or not.
 619:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 620:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 621:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART mute mode.
 622:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 623:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 624:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 625:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 626:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 645              		.loc 1 626 0
 646              		.cfi_startproc
 647              		@ args = 0, pretend = 0, frame = 0
 648              		@ frame_needed = 0, uses_anonymous_args = 0
 649              		@ link register save eliminated.
 650              	.LVL54:
 627:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 628:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 629:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 630:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 631:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 632:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 633:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
 634:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_RWU;
 651              		.loc 1 634 0
 652 0000 8389     		ldrh	r3, [r0, #12]
 631:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 653              		.loc 1 631 0
 654 0002 19B1     		cbz	r1, .L43
 655              		.loc 1 634 0
 656 0004 9BB2     		uxth	r3, r3
 657 0006 43F00203 		orr	r3, r3, #2
 658 000a 03E0     		b	.L45
 659              	.L43:
 635:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 636:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 637:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 638:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
 639:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
 660              		.loc 1 639 0
 661 000c 23F00203 		bic	r3, r3, #2
 662 0010 1B04     		lsls	r3, r3, #16
 663 0012 1B0C     		lsrs	r3, r3, #16
 664              	.L45:
 665 0014 8381     		strh	r3, [r0, #12]	@ movhi
 666 0016 7047     		bx	lr
 667              		.cfi_endproc
 668              	.LFE122:
 670              		.section	.text.USART_WakeUpConfig,"ax",%progbits
 671              		.align	1
 672              		.global	USART_WakeUpConfig
 673              		.thumb
 674              		.thumb_func
 676              	USART_WakeUpConfig:
 677              	.LFB123:
 640:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 641:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 642:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 643:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Selects the USART WakeUp method.
 644:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 645:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 646:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_WakeUp: specifies the USART wakeup method.
 647:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
 648:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
 649:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
 650:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 651:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 652:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
 653:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 678              		.loc 1 653 0
 679              		.cfi_startproc
 680              		@ args = 0, pretend = 0, frame = 0
 681              		@ frame_needed = 0, uses_anonymous_args = 0
 682              		@ link register save eliminated.
 683              	.LVL55:
 654:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 655:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 656:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_WAKEUP(USART_WakeUp));
 657:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 658:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
 684              		.loc 1 658 0
 685 0000 8389     		ldrh	r3, [r0, #12]
 686 0002 23F40063 		bic	r3, r3, #2048
 687 0006 1B04     		lsls	r3, r3, #16
 688 0008 1B0C     		lsrs	r3, r3, #16
 689 000a 8381     		strh	r3, [r0, #12]	@ movhi
 659:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 690              		.loc 1 659 0
 691 000c 8389     		ldrh	r3, [r0, #12]
 692 000e 9BB2     		uxth	r3, r3
 693 0010 1943     		orrs	r1, r1, r3
 694              	.LVL56:
 695 0012 8181     		strh	r1, [r0, #12]	@ movhi
 660:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 696              		.loc 1 660 0
 697 0014 7047     		bx	lr
 698              		.cfi_endproc
 699              	.LFE123:
 701              		.section	.text.USART_LINBreakDetectLengthConfig,"ax",%progbits
 702              		.align	1
 703              		.global	USART_LINBreakDetectLengthConfig
 704              		.thumb
 705              		.thumb_func
 707              	USART_LINBreakDetectLengthConfig:
 708              	.LFB124:
 661:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 662:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 663:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 664:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 665:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 666:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group4 LIN mode functions
 667:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   LIN mode functions 
 668:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 669:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 670:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 671:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                 LIN mode functions
 672:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 673:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 674:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART LIN 
 675:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Mode communication.
 676:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 677:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
 678:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the LIN standard.
 679:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 680:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Only this LIN Feature is supported by the USART IP:
 681:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     - LIN Master Synchronous Break send capability and LIN slave break detection
 682:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       capability :  13-bit break generation and 10/11 bit break detection
 683:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 684:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 685:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART LIN Master transmitter communication is possible through the following procedure:
 686:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
 687:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         Mode transmitter or Mode receiver and hardware flow control values using 
 688:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         the USART_Init() function.
 689:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Enable the USART using the USART_Cmd() function.
 690:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Enable the LIN mode using the USART_LINCmd() function.
 691:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Send the break character using USART_SendBreak() function.
 692:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 693:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART LIN Master receiver communication is possible through the following procedure:
 694:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
 695:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         Mode transmitter or Mode receiver and hardware flow control values using 
 696:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         the USART_Init() function.
 697:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Enable the USART using the USART_Cmd() function.
 698:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
 699:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         function.
 700:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Enable the LIN mode using the USART_LINCmd() function.
 701:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 702:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 703:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note In LIN mode, the following bits must be kept cleared:
 704:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - CLKEN in the USART_CR2 register,
 705:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
 706:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 707:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 708:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 709:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 710:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 711:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 712:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Sets the USART LIN Break detection length.
 713:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 714:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 715:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
 716:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
 717:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
 718:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
 719:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 720:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 721:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
 722:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 709              		.loc 1 722 0
 710              		.cfi_startproc
 711              		@ args = 0, pretend = 0, frame = 0
 712              		@ frame_needed = 0, uses_anonymous_args = 0
 713              		@ link register save eliminated.
 714              	.LVL57:
 723:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 724:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 725:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
 726:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 727:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
 715              		.loc 1 727 0
 716 0000 038A     		ldrh	r3, [r0, #16]
 717 0002 23F02003 		bic	r3, r3, #32
 718 0006 1B04     		lsls	r3, r3, #16
 719 0008 1B0C     		lsrs	r3, r3, #16
 720 000a 0382     		strh	r3, [r0, #16]	@ movhi
 728:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 721              		.loc 1 728 0
 722 000c 038A     		ldrh	r3, [r0, #16]
 723 000e 9BB2     		uxth	r3, r3
 724 0010 1943     		orrs	r1, r1, r3
 725              	.LVL58:
 726 0012 0182     		strh	r1, [r0, #16]	@ movhi
 729:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 727              		.loc 1 729 0
 728 0014 7047     		bx	lr
 729              		.cfi_endproc
 730              	.LFE124:
 732              		.section	.text.USART_LINCmd,"ax",%progbits
 733              		.align	1
 734              		.global	USART_LINCmd
 735              		.thumb
 736              		.thumb_func
 738              	USART_LINCmd:
 739              	.LFB125:
 730:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 731:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 732:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's LIN mode.
 733:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 734:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 735:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART LIN mode.
 736:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 737:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 738:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 739:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 740:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 740              		.loc 1 740 0
 741              		.cfi_startproc
 742              		@ args = 0, pretend = 0, frame = 0
 743              		@ frame_needed = 0, uses_anonymous_args = 0
 744              		@ link register save eliminated.
 745              	.LVL59:
 741:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 742:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 743:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 744:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 745:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 746:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 747:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
 748:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR2 |= USART_CR2_LINEN;
 746              		.loc 1 748 0
 747 0000 038A     		ldrh	r3, [r0, #16]
 745:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 748              		.loc 1 745 0
 749 0002 19B1     		cbz	r1, .L49
 750              		.loc 1 748 0
 751 0004 9BB2     		uxth	r3, r3
 752 0006 43F48043 		orr	r3, r3, #16384
 753 000a 03E0     		b	.L51
 754              	.L49:
 749:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 750:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 751:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 752:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
 753:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
 755              		.loc 1 753 0
 756 000c 23F48043 		bic	r3, r3, #16384
 757 0010 1B04     		lsls	r3, r3, #16
 758 0012 1B0C     		lsrs	r3, r3, #16
 759              	.L51:
 760 0014 0382     		strh	r3, [r0, #16]	@ movhi
 761 0016 7047     		bx	lr
 762              		.cfi_endproc
 763              	.LFE125:
 765              		.section	.text.USART_SendBreak,"ax",%progbits
 766              		.align	1
 767              		.global	USART_SendBreak
 768              		.thumb
 769              		.thumb_func
 771              	USART_SendBreak:
 772              	.LFB126:
 754:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 755:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 756:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 757:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 758:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Transmits break characters.
 759:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 760:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 761:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 762:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 763:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SendBreak(USART_TypeDef* USARTx)
 764:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 773              		.loc 1 764 0
 774              		.cfi_startproc
 775              		@ args = 0, pretend = 0, frame = 0
 776              		@ frame_needed = 0, uses_anonymous_args = 0
 777              		@ link register save eliminated.
 778              	.LVL60:
 765:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 766:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 767:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 768:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Send break characters */
 769:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR1 |= USART_CR1_SBK;
 779              		.loc 1 769 0
 780 0000 8389     		ldrh	r3, [r0, #12]
 781 0002 9BB2     		uxth	r3, r3
 782 0004 43F00103 		orr	r3, r3, #1
 783 0008 8381     		strh	r3, [r0, #12]	@ movhi
 770:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 784              		.loc 1 770 0
 785 000a 7047     		bx	lr
 786              		.cfi_endproc
 787              	.LFE126:
 789              		.section	.text.USART_HalfDuplexCmd,"ax",%progbits
 790              		.align	1
 791              		.global	USART_HalfDuplexCmd
 792              		.thumb
 793              		.thumb_func
 795              	USART_HalfDuplexCmd:
 796              	.LFB127:
 771:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 772:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 773:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 774:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 775:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 776:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group5 Halfduplex mode function
 777:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Half-duplex mode function 
 778:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 779:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 780:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 781:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                          Half-duplex mode function
 782:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 783:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 784:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART 
 785:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Half-duplex communication.
 786:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 787:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The USART can be configured to follow a single-wire half-duplex protocol where 
 788:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the TX and RX lines are internally connected.
 789:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 790:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USART Half duplex communication is possible through the following procedure:
 791:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
 792:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         or Mode receiver and hardware flow control values using the USART_Init()
 793:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         function.
 794:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Configures the USART address using the USART_SetAddress() function.
 795:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Enable the USART using the USART_Cmd() function.
 796:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
 797:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 798:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 799:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note The RX pin is no longer used
 800:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note In Half-duplex mode the following bits must be kept cleared:
 801:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - LINEN and CLKEN bits in the USART_CR2 register.
 802:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - SCEN and IREN bits in the USART_CR3 register.
 803:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 804:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 805:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 806:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 807:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 808:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 809:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's Half Duplex communication.
 810:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
 811:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 812:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART Communication.
 813:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 814:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 815:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 816:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 817:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 797              		.loc 1 817 0
 798              		.cfi_startproc
 799              		@ args = 0, pretend = 0, frame = 0
 800              		@ frame_needed = 0, uses_anonymous_args = 0
 801              		@ link register save eliminated.
 802              	.LVL61:
 818:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 819:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 820:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 821:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 822:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 823:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 824:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
 825:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_HDSEL;
 803              		.loc 1 825 0
 804 0000 838A     		ldrh	r3, [r0, #20]
 822:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 805              		.loc 1 822 0
 806 0002 19B1     		cbz	r1, .L54
 807              		.loc 1 825 0
 808 0004 9BB2     		uxth	r3, r3
 809 0006 43F00803 		orr	r3, r3, #8
 810 000a 03E0     		b	.L56
 811              	.L54:
 826:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 827:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 828:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 829:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
 830:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
 812              		.loc 1 830 0
 813 000c 23F00803 		bic	r3, r3, #8
 814 0010 1B04     		lsls	r3, r3, #16
 815 0012 1B0C     		lsrs	r3, r3, #16
 816              	.L56:
 817 0014 8382     		strh	r3, [r0, #20]	@ movhi
 818 0016 7047     		bx	lr
 819              		.cfi_endproc
 820              	.LFE127:
 822              		.section	.text.USART_SetGuardTime,"ax",%progbits
 823              		.align	1
 824              		.global	USART_SetGuardTime
 825              		.thumb
 826              		.thumb_func
 828              	USART_SetGuardTime:
 829              	.LFB128:
 831:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 832:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 833:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 834:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 835:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 836:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 837:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 838:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 839:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group6 Smartcard mode functions
 840:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Smartcard mode functions 
 841:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 842:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 843:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 844:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                Smartcard mode functions
 845:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 846:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 847:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART 
 848:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Smartcard communication.
 849:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 850:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The Smartcard interface is designed to support asynchronous protocol Smartcards as
 851:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   defined in the ISO 7816-3 standard.
 852:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 853:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The USART can provide a clock to the smartcard through the SCLK output.
 854:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In smartcard mode, SCLK is not associated to the communication but is simply derived 
 855:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   from the internal peripheral input clock through a 5-bit prescaler.
 856:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 857:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Smartcard communication is possible through the following procedure:
 858:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
 859:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
 860:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Program the USART clock using the USART_ClockInit() function as following:
 861:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART Clock enabled
 862:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART CPOL Low
 863:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART CPHA on first edge
 864:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - USART Last Bit Clock Enabled
 865:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Program the Smartcard interface using the USART_Init() function as following:
 866:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Word Length = 9 Bits
 867:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - 1.5 Stop Bit
 868:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Even parity
 869:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - BaudRate = 12096 baud
 870:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Hardware flow control disabled (RTS and CTS signals)
 871:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - Tx and Rx enabled
 872:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
 873:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         function
 874:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      6. Enable the USART using the USART_Cmd() function.
 875:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
 876:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
 877:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 878:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Please refer to the ISO 7816-3 specification for more details.
 879:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 880:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 881:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note It is also possible to choose 0.5 stop bit for receiving but it is recommended 
 882:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       to use 1.5 stop bits for both transmitting and receiving to avoid switching 
 883:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       between the two configurations.
 884:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note In smartcard mode, the following bits must be kept cleared:
 885:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - LINEN bit in the USART_CR2 register.
 886:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - HDSEL and IREN bits in the USART_CR3 register.
 887:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note Smartcard mode is available on USART peripherals only (not available on UART4 
 888:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       and UART5 peripherals).
 889:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 890:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
 891:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
 892:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 893:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 894:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 895:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Sets the specified USART guard time.
 896:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 897:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 898:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_GuardTime: specifies the guard time.   
 899:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 900:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 901:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
 902:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {    
 830              		.loc 1 902 0
 831              		.cfi_startproc
 832              		@ args = 0, pretend = 0, frame = 0
 833              		@ frame_needed = 0, uses_anonymous_args = 0
 834              		@ link register save eliminated.
 835              	.LVL62:
 903:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 904:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 905:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 906:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Clear the USART Guard time */
 907:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->GTPR &= USART_GTPR_PSC;
 836              		.loc 1 907 0
 837 0000 038B     		ldrh	r3, [r0, #24]
 838 0002 DBB2     		uxtb	r3, r3
 839 0004 0383     		strh	r3, [r0, #24]	@ movhi
 908:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Set the USART guard time */
 909:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 840              		.loc 1 909 0
 841 0006 038B     		ldrh	r3, [r0, #24]
 842 0008 9BB2     		uxth	r3, r3
 843 000a 43EA0121 		orr	r1, r3, r1, lsl #8
 844              	.LVL63:
 845 000e 0183     		strh	r1, [r0, #24]	@ movhi
 910:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 846              		.loc 1 910 0
 847 0010 7047     		bx	lr
 848              		.cfi_endproc
 849              	.LFE128:
 851              		.section	.text.USART_SmartCardCmd,"ax",%progbits
 852              		.align	1
 853              		.global	USART_SmartCardCmd
 854              		.thumb
 855              		.thumb_func
 857              	USART_SmartCardCmd:
 858              	.LFB129:
 911:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 912:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 913:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's Smart Card mode.
 914:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 915:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 916:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the Smart Card mode.
 917:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.      
 918:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 919:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 920:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 921:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 859              		.loc 1 921 0
 860              		.cfi_startproc
 861              		@ args = 0, pretend = 0, frame = 0
 862              		@ frame_needed = 0, uses_anonymous_args = 0
 863              		@ link register save eliminated.
 864              	.LVL64:
 922:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 923:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 924:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 925:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 926:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 927:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
 928:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_SCEN;
 865              		.loc 1 928 0
 866 0000 838A     		ldrh	r3, [r0, #20]
 925:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 867              		.loc 1 925 0
 868 0002 19B1     		cbz	r1, .L59
 869              		.loc 1 928 0
 870 0004 9BB2     		uxth	r3, r3
 871 0006 43F02003 		orr	r3, r3, #32
 872 000a 03E0     		b	.L61
 873              	.L59:
 929:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 930:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 931:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 932:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
 933:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
 874              		.loc 1 933 0
 875 000c 23F02003 		bic	r3, r3, #32
 876 0010 1B04     		lsls	r3, r3, #16
 877 0012 1B0C     		lsrs	r3, r3, #16
 878              	.L61:
 879 0014 8382     		strh	r3, [r0, #20]	@ movhi
 880 0016 7047     		bx	lr
 881              		.cfi_endproc
 882              	.LFE129:
 884              		.section	.text.USART_SmartCardNACKCmd,"ax",%progbits
 885              		.align	1
 886              		.global	USART_SmartCardNACKCmd
 887              		.thumb
 888              		.thumb_func
 890              	USART_SmartCardNACKCmd:
 891              	.LFB130:
 934:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 935:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 936:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 937:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 938:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables NACK transmission.
 939:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 940:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
 941:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the NACK transmission.
 942:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.  
 943:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
 944:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 945:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 946:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 892              		.loc 1 946 0
 893              		.cfi_startproc
 894              		@ args = 0, pretend = 0, frame = 0
 895              		@ frame_needed = 0, uses_anonymous_args = 0
 896              		@ link register save eliminated.
 897              	.LVL65:
 947:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
 948:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx)); 
 949:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 950:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 951:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 952:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
 953:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_NACK;
 898              		.loc 1 953 0
 899 0000 838A     		ldrh	r3, [r0, #20]
 950:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 900              		.loc 1 950 0
 901 0002 19B1     		cbz	r1, .L63
 902              		.loc 1 953 0
 903 0004 9BB2     		uxth	r3, r3
 904 0006 43F01003 		orr	r3, r3, #16
 905 000a 03E0     		b	.L65
 906              	.L63:
 954:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 955:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
 956:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
 957:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
 958:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
 907              		.loc 1 958 0
 908 000c 23F01003 		bic	r3, r3, #16
 909 0010 1B04     		lsls	r3, r3, #16
 910 0012 1B0C     		lsrs	r3, r3, #16
 911              	.L65:
 912 0014 8382     		strh	r3, [r0, #20]	@ movhi
 913 0016 7047     		bx	lr
 914              		.cfi_endproc
 915              	.LFE130:
 917              		.section	.text.USART_IrDAConfig,"ax",%progbits
 918              		.align	1
 919              		.global	USART_IrDAConfig
 920              		.thumb
 921              		.thumb_func
 923              	USART_IrDAConfig:
 924              	.LFB131:
 959:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
 960:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 961:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 962:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
 963:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
 964:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
 965:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 966:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group7 IrDA mode functions
 967:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   IrDA mode functions 
 968:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
 969:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
 970:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
 971:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                                 IrDA mode functions
 972:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
 973:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 974:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to manage the USART 
 975:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   IrDA communication.
 976:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
 977:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
 978:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
 979:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
 980:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   While receiving data, transmission should be avoided as the data to be transmitted
 981:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   could be corrupted.
 982:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 983:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   IrDA communication is possible through the following procedure:
 984:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
 985:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         modes and hardware flow control values using the USART_Init() function.
 986:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. Enable the USART using the USART_Cmd() function.
 987:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. Configures the IrDA pulse width by configuring the prescaler using  
 988:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         the USART_SetPrescaler() function.
 989:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
 990:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         using the USART_IrDAConfig() function.
 991:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. Enable the IrDA using the USART_IrDACmd() function.
 992:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
 993:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note A pulse of width less than two and greater than one PSC period(s) may or may
 994:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       not be rejected.
 995:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note The receiver set up time should be managed by software. The IrDA physical layer
 996:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       specification specifies a minimum of 10 ms delay between transmission and 
 997:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       reception (IrDA is a half duplex protocol).
 998:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note In IrDA mode, the following bits must be kept cleared:
 999:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - LINEN, STOP and CLKEN bits in the USART_CR2 register.
1000:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****         - SCEN and HDSEL bits in the USART_CR3 register.
1001:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1002:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
1003:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
1004:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1005:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1006:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1007:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Configures the USART's IrDA interface.
1008:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1009:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1010:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_IrDAMode: specifies the IrDA mode.
1011:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1012:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IrDAMode_LowPower
1013:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IrDAMode_Normal
1014:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1015:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1016:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
1017:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 925              		.loc 1 1017 0
 926              		.cfi_startproc
 927              		@ args = 0, pretend = 0, frame = 0
 928              		@ frame_needed = 0, uses_anonymous_args = 0
 929              		@ link register save eliminated.
 930              	.LVL66:
1018:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1019:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1020:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
1021:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1022:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
 931              		.loc 1 1022 0
 932 0000 838A     		ldrh	r3, [r0, #20]
 933 0002 23F00403 		bic	r3, r3, #4
 934 0006 1B04     		lsls	r3, r3, #16
 935 0008 1B0C     		lsrs	r3, r3, #16
 936 000a 8382     		strh	r3, [r0, #20]	@ movhi
1023:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 937              		.loc 1 1023 0
 938 000c 838A     		ldrh	r3, [r0, #20]
 939 000e 9BB2     		uxth	r3, r3
 940 0010 1943     		orrs	r1, r1, r3
 941              	.LVL67:
 942 0012 8182     		strh	r1, [r0, #20]	@ movhi
1024:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 943              		.loc 1 1024 0
 944 0014 7047     		bx	lr
 945              		.cfi_endproc
 946              	.LFE131:
 948              		.section	.text.USART_IrDACmd,"ax",%progbits
 949              		.align	1
 950              		.global	USART_IrDACmd
 951              		.thumb
 952              		.thumb_func
 954              	USART_IrDACmd:
 955              	.LFB132:
1025:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1026:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1027:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's IrDA interface.
1028:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1029:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1030:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the IrDA mode.
1031:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1032:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1033:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1034:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
1035:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 956              		.loc 1 1035 0
 957              		.cfi_startproc
 958              		@ args = 0, pretend = 0, frame = 0
 959              		@ frame_needed = 0, uses_anonymous_args = 0
 960              		@ link register save eliminated.
 961              	.LVL68:
1036:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1037:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1038:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1039:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1040:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
1041:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1042:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
1043:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_IREN;
 962              		.loc 1 1043 0
 963 0000 838A     		ldrh	r3, [r0, #20]
1040:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 964              		.loc 1 1040 0
 965 0002 19B1     		cbz	r1, .L68
 966              		.loc 1 1043 0
 967 0004 9BB2     		uxth	r3, r3
 968 0006 43F00203 		orr	r3, r3, #2
 969 000a 03E0     		b	.L70
 970              	.L68:
1044:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1045:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1046:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1047:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
1048:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
 971              		.loc 1 1048 0
 972 000c 23F00203 		bic	r3, r3, #2
 973 0010 1B04     		lsls	r3, r3, #16
 974 0012 1B0C     		lsrs	r3, r3, #16
 975              	.L70:
 976 0014 8382     		strh	r3, [r0, #20]	@ movhi
 977 0016 7047     		bx	lr
 978              		.cfi_endproc
 979              	.LFE132:
 981              		.section	.text.USART_DMACmd,"ax",%progbits
 982              		.align	1
 983              		.global	USART_DMACmd
 984              		.thumb
 985              		.thumb_func
 987              	USART_DMACmd:
 988              	.LFB133:
1049:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1050:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
1051:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1052:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1053:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
1054:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1055:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1056:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group8 DMA transfers management functions
1057:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   DMA transfers management functions
1058:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
1059:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
1060:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
1061:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                       DMA transfers management functions
1062:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
1063:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1064:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
1065:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
1066:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1067:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1068:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1069:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's DMA interface.
1070:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1071:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1072:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_DMAReq: specifies the DMA request.
1073:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be any combination of the following values:
1074:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_DMAReq_Tx: USART DMA transmit request
1075:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_DMAReq_Rx: USART DMA receive request
1076:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the DMA Request sources.
1077:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.   
1078:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1079:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1080:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
1081:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 989              		.loc 1 1081 0
 990              		.cfi_startproc
 991              		@ args = 0, pretend = 0, frame = 0
 992              		@ frame_needed = 0, uses_anonymous_args = 0
 993              		@ link register save eliminated.
 994              	.LVL69:
1082:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1083:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1084:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
1085:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1086:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1087:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
1088:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1089:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
1090:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****        DMAR bits in the USART CR3 register */
1091:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_DMAReq;
 995              		.loc 1 1091 0
 996 0000 838A     		ldrh	r3, [r0, #20]
 997 0002 9BB2     		uxth	r3, r3
1087:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 998              		.loc 1 1087 0
 999 0004 0AB1     		cbz	r2, .L72
 1000              		.loc 1 1091 0
 1001 0006 1943     		orrs	r1, r1, r3
 1002              	.LVL70:
 1003 0008 01E0     		b	.L74
 1004              	.LVL71:
 1005              	.L72:
1092:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1093:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1094:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1095:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
1096:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****        DMAR bits in the USART CR3 register */
1097:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 1006              		.loc 1 1097 0
 1007 000a 23EA0101 		bic	r1, r3, r1
 1008              	.LVL72:
 1009              	.L74:
 1010 000e 8182     		strh	r1, [r0, #20]	@ movhi
 1011 0010 7047     		bx	lr
 1012              		.cfi_endproc
 1013              	.LFE133:
 1015              		.section	.text.USART_ITConfig,"ax",%progbits
 1016              		.align	1
 1017              		.global	USART_ITConfig
 1018              		.thumb
 1019              		.thumb_func
 1021              	USART_ITConfig:
 1022              	.LFB134:
1098:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1099:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
1100:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1101:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1102:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @}
1103:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1104:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1105:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /** @defgroup USART_Group9 Interrupts and flags management functions
1106:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *  @brief   Interrupts and flags management functions 
1107:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  *
1108:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @verbatim   
1109:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================
1110:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                    Interrupts and flags management functions
1111:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****  ===============================================================================  
1112:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1113:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   This subsection provides a set of functions allowing to configure the USART 
1114:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Interrupts sources, DMA channels requests and check or clear the flags or 
1115:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   pending bits status.
1116:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   The user should identify which mode will be used in his application to manage 
1117:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   the communication: Polling mode, Interrupt mode or DMA mode. 
1118:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1119:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Polling Mode
1120:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   =============
1121:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In Polling Mode, the SPI communication can be managed by 10 flags:
1122:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
1123:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
1124:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. USART_FLAG_TC : to indicate the status of the transmit operation
1125:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
1126:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. USART_FLAG_CTS : to indicate the status of the nCTS input
1127:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      6. USART_FLAG_LBD : to indicate the status of the LIN break detection
1128:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      7. USART_FLAG_NE : to indicate if a noise error occur
1129:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      8. USART_FLAG_FE : to indicate if a frame error occur
1130:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      9. USART_FLAG_PE : to indicate if a parity error occur
1131:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      10. USART_FLAG_ORE : to indicate if an Overrun error occur
1132:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1133:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In this Mode it is advised to use the following functions:
1134:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
1135:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****       - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
1136:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1137:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Interrupt Mode
1138:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ===============
1139:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
1140:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   and 10 pending bits: 
1141:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1142:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Pending Bits:
1143:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ------------- 
1144:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. USART_IT_TXE : to indicate the status of the transmit buffer register
1145:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. USART_IT_RXNE : to indicate the status of the receive buffer register
1146:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. USART_IT_TC : to indicate the status of the transmit operation
1147:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. USART_IT_IDLE : to indicate the status of the Idle Line             
1148:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. USART_IT_CTS : to indicate the status of the nCTS input
1149:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      6. USART_IT_LBD : to indicate the status of the LIN break detection
1150:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      7. USART_IT_NE : to indicate if a noise error occur
1151:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      8. USART_IT_FE : to indicate if a frame error occur
1152:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      9. USART_IT_PE : to indicate if a parity error occur
1153:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      10. USART_IT_ORE : to indicate if an Overrun error occur
1154:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1155:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   Interrupt Source:
1156:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   -----------------
1157:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
1158:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                        interrupt. 
1159:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
1160:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                         empty interrupt.
1161:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
1162:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                        interrupt. 
1163:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
1164:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
1165:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
1166:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****                        interrupt. 
1167:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      7. USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
1168:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
1169:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1170:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @note Some parameters are coded in order to use them as interrupt source or as pending bits.
1171:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1172:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In this Mode it is advised to use the following functions:
1173:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
1174:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
1175:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
1176:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1177:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   DMA Mode
1178:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ========
1179:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
1180:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
1181:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
1182:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1183:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   In this Mode it is advised to use the following function:
1184:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****      - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
1185:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1186:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** @endverbatim
1187:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @{
1188:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1189:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1190:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1191:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Enables or disables the specified USART interrupts.
1192:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1193:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1194:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
1195:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1196:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt
1197:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1198:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
1199:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt
1200:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
1201:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_IDLE: Idle line detection interrupt
1202:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_PE:   Parity Error interrupt
1203:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
1204:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  NewState: new state of the specified USARTx interrupts.
1205:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1206:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1207:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1208:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
1209:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1023              		.loc 1 1209 0
 1024              		.cfi_startproc
 1025              		@ args = 0, pretend = 0, frame = 0
 1026              		@ frame_needed = 0, uses_anonymous_args = 0
 1027              	.LVL73:
1210:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
1211:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t usartxbase = 0x00;
1212:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1213:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1214:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
1215:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1216:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1217:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1218:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1219:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1220:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1221:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1222:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1223:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   usartxbase = (uint32_t)USARTx;
1224:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1225:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Get the USART register index */
1226:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 1028              		.loc 1 1226 0
 1029 0000 C1F34213 		ubfx	r3, r1, #5, #3
 1030              	.LVL74:
1209:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1031              		.loc 1 1209 0
 1032 0004 10B5     		push	{r4, lr}
 1033              	.LCFI4:
 1034              		.cfi_def_cfa_offset 8
 1035              		.cfi_offset 14, -4
 1036              		.cfi_offset 4, -8
1227:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1228:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Get the interrupt position */
1229:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itpos = USART_IT & IT_MASK;
 1037              		.loc 1 1229 0
 1038 0006 01F01F01 		and	r1, r1, #31
 1039              	.LVL75:
1230:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itmask = (((uint32_t)0x01) << itpos);
 1040              		.loc 1 1230 0
 1041 000a 0124     		movs	r4, #1
 1042 000c 14FA01F1 		lsls	r1, r4, r1
 1043              	.LVL76:
1231:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1232:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (usartreg == 0x01) /* The IT is in CR1 register */
 1044              		.loc 1 1232 0
 1045 0010 A342     		cmp	r3, r4
 1046 0012 01D1     		bne	.L76
 1047              	.LVL77:
1233:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1234:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     usartxbase += 0x0C;
 1048              		.loc 1 1234 0
 1049 0014 0C30     		adds	r0, r0, #12
 1050              	.LVL78:
 1051 0016 04E0     		b	.L77
 1052              	.LVL79:
 1053              	.L76:
1235:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1236:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (usartreg == 0x02) /* The IT is in CR2 register */
 1054              		.loc 1 1236 0
 1055 0018 022B     		cmp	r3, #2
 1056 001a 01D1     		bne	.L78
1237:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1238:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     usartxbase += 0x10;
 1057              		.loc 1 1238 0
 1058 001c 1030     		adds	r0, r0, #16
 1059              	.LVL80:
 1060 001e 00E0     		b	.L77
 1061              	.LVL81:
 1062              	.L78:
1239:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1240:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else /* The IT is in CR3 register */
1241:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1242:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     usartxbase += 0x14; 
 1063              		.loc 1 1242 0
 1064 0020 1430     		adds	r0, r0, #20
 1065              	.LVL82:
 1066              	.L77:
1243:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1244:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
1245:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1246:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     *(__IO uint32_t*)usartxbase  |= itmask;
 1067              		.loc 1 1246 0
 1068 0022 0368     		ldr	r3, [r0, #0]
 1069              	.LVL83:
1244:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1070              		.loc 1 1244 0
 1071 0024 0AB1     		cbz	r2, .L79
 1072              		.loc 1 1246 0
 1073 0026 1943     		orrs	r1, r1, r3
 1074              	.LVL84:
 1075 0028 01E0     		b	.L81
 1076              	.LVL85:
 1077              	.L79:
1247:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1248:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1249:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1250:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     *(__IO uint32_t*)usartxbase &= ~itmask;
 1078              		.loc 1 1250 0
 1079 002a 23EA0101 		bic	r1, r3, r1
 1080              	.LVL86:
 1081              	.L81:
 1082 002e 0160     		str	r1, [r0, #0]
 1083 0030 10BD     		pop	{r4, pc}
 1084              		.cfi_endproc
 1085              	.LFE134:
 1087              		.section	.text.USART_GetFlagStatus,"ax",%progbits
 1088              		.align	1
 1089              		.global	USART_GetFlagStatus
 1090              		.thumb
 1091              		.thumb_func
 1093              	USART_GetFlagStatus:
 1094              	.LFB135:
1251:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1252:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
1253:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1254:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1255:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Checks whether the specified USART flag is set or not.
1256:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1257:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1258:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_FLAG: specifies the flag to check.
1259:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1260:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
1261:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag
1262:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TXE:  Transmit data register empty flag
1263:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TC:   Transmission Complete flag
1264:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_RXNE: Receive data register not empty flag
1265:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_IDLE: Idle Line detection flag
1266:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_ORE:  OverRun Error flag
1267:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_NE:   Noise Error flag
1268:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_FE:   Framing Error flag
1269:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_PE:   Parity Error flag
1270:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval The new state of USART_FLAG (SET or RESET).
1271:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1272:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
1273:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1095              		.loc 1 1273 0
 1096              		.cfi_startproc
 1097              		@ args = 0, pretend = 0, frame = 0
 1098              		@ frame_needed = 0, uses_anonymous_args = 0
 1099              		@ link register save eliminated.
 1100              	.LVL87:
1274:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   FlagStatus bitstatus = RESET;
1275:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1276:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1277:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
1278:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1279:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
1280:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_FLAG == USART_FLAG_CTS)
1281:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1282:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1283:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1284:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1285:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 1101              		.loc 1 1285 0
 1102 0000 0388     		ldrh	r3, [r0, #0]
 1103              	.LVL88:
1286:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1287:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     bitstatus = SET;
 1104              		.loc 1 1287 0
 1105 0002 1942     		tst	r1, r3
1288:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1289:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1290:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1291:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     bitstatus = RESET;
1292:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1293:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   return bitstatus;
 1106              		.loc 1 1293 0
 1107 0004 0CBF     		ite	eq
 1108 0006 0020     		moveq	r0, #0
 1109 0008 0120     		movne	r0, #1
 1110              	.LVL89:
1294:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 1111              		.loc 1 1294 0
 1112 000a 7047     		bx	lr
 1113              		.cfi_endproc
 1114              	.LFE135:
 1116              		.section	.text.USART_ClearFlag,"ax",%progbits
 1117              		.align	1
 1118              		.global	USART_ClearFlag
 1119              		.thumb
 1120              		.thumb_func
 1122              	USART_ClearFlag:
 1123              	.LFB136:
1295:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1296:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1297:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Clears the USARTx's pending flags.
1298:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1299:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1300:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_FLAG: specifies the flag to clear.
1301:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be any combination of the following values:
1302:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
1303:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag.
1304:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TC:   Transmission Complete flag.
1305:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
1306:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *   
1307:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1308:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          error) and IDLE (Idle line detected) flags are cleared by software 
1309:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
1310:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          followed by a read operation to USART_DR register (USART_ReceiveData()).
1311:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   RXNE flag can be also cleared by a read to the USART_DR register 
1312:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1313:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   TC flag can be also cleared by software sequence: a read operation to 
1314:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
1315:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          to USART_DR register (USART_SendData()).
1316:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   TXE flag is cleared only by a write to the USART_DR register 
1317:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_SendData()).
1318:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *   
1319:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1320:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1321:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
1322:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1124              		.loc 1 1322 0
 1125              		.cfi_startproc
 1126              		@ args = 0, pretend = 0, frame = 0
 1127              		@ frame_needed = 0, uses_anonymous_args = 0
 1128              		@ link register save eliminated.
 1129              	.LVL90:
1323:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1324:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1325:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
1326:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1327:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
1328:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
1329:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1330:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1331:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1332:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****        
1333:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->SR = (uint16_t)~USART_FLAG;
 1130              		.loc 1 1333 0
 1131 0000 C943     		mvns	r1, r1
 1132              	.LVL91:
 1133 0002 89B2     		uxth	r1, r1
 1134 0004 0180     		strh	r1, [r0, #0]	@ movhi
1334:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 1135              		.loc 1 1334 0
 1136 0006 7047     		bx	lr
 1137              		.cfi_endproc
 1138              	.LFE136:
 1140              		.section	.text.USART_GetITStatus,"ax",%progbits
 1141              		.align	1
 1142              		.global	USART_GetITStatus
 1143              		.thumb
 1144              		.thumb_func
 1146              	USART_GetITStatus:
 1147              	.LFB137:
1335:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1336:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1337:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Checks whether the specified USART interrupt has occurred or not.
1338:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1339:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1340:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt source to check.
1341:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1342:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1343:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1344:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
1345:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt
1346:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
1347:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_IDLE: Idle line detection interrupt
1348:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_ORE:  OverRun Error interrupt
1349:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_NE:   Noise Error interrupt
1350:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_FE:   Framing Error interrupt
1351:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_PE:   Parity Error interrupt
1352:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval The new state of USART_IT (SET or RESET).
1353:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1354:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
1355:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1148              		.loc 1 1355 0
 1149              		.cfi_startproc
 1150              		@ args = 0, pretend = 0, frame = 0
 1151              		@ frame_needed = 0, uses_anonymous_args = 0
 1152              	.LVL92:
 1153 0000 10B5     		push	{r4, lr}
 1154              	.LCFI5:
 1155              		.cfi_def_cfa_offset 8
 1156              		.cfi_offset 14, -4
 1157              		.cfi_offset 4, -8
1356:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
1357:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   ITStatus bitstatus = RESET;
1358:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1359:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1360:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT)); 
1361:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1362:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */ 
1363:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1364:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1365:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1366:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1367:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1368:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Get the USART register index */
1369:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
1370:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Get the interrupt position */
1371:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itmask = USART_IT & IT_MASK;
 1158              		.loc 1 1371 0
 1159 0002 01F01F03 		and	r3, r1, #31
1372:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itmask = (uint32_t)0x01 << itmask;
 1160              		.loc 1 1372 0
 1161 0006 0122     		movs	r2, #1
1369:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 1162              		.loc 1 1369 0
 1163 0008 C1F34214 		ubfx	r4, r1, #5, #3
 1164              	.LVL93:
 1165              		.loc 1 1372 0
 1166 000c 9A40     		lsls	r2, r2, r3
 1167              	.LVL94:
1373:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1374:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 1168              		.loc 1 1374 0
 1169 000e 012C     		cmp	r4, #1
1375:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1376:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     itmask &= USARTx->CR1;
 1170              		.loc 1 1376 0
 1171 0010 08BF     		it	eq
 1172 0012 8389     		ldrheq	r3, [r0, #12]
1374:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 1173              		.loc 1 1374 0
 1174 0014 03D0     		beq	.L88
1377:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1378:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 1175              		.loc 1 1378 0
 1176 0016 022C     		cmp	r4, #2
1379:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1380:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     itmask &= USARTx->CR2;
 1177              		.loc 1 1380 0
 1178 0018 0CBF     		ite	eq
 1179 001a 038A     		ldrheq	r3, [r0, #16]
1381:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1382:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else /* The IT  is in CR3 register */
1383:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1384:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     itmask &= USARTx->CR3;
 1180              		.loc 1 1384 0
 1181 001c 838A     		ldrhne	r3, [r0, #20]
 1182              	.L88:
 1183 001e 9BB2     		uxth	r3, r3
 1184 0020 1340     		ands	r3, r3, r2
 1185              	.LVL95:
1385:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1386:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1387:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   bitpos = USART_IT >> 0x08;
 1186              		.loc 1 1387 0
 1187 0022 090A     		lsrs	r1, r1, #8
 1188              	.LVL96:
1388:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
 1189              		.loc 1 1388 0
 1190 0024 0122     		movs	r2, #1
 1191 0026 12FA01F1 		lsls	r1, r2, r1
 1192              	.LVL97:
1389:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   bitpos &= USARTx->SR;
 1193              		.loc 1 1389 0
 1194 002a 0288     		ldrh	r2, [r0, #0]
 1195 002c 92B2     		uxth	r2, r2
 1196              	.LVL98:
1390:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 1197              		.loc 1 1390 0
 1198 002e 1142     		tst	r1, r2
 1199 0030 0CBF     		ite	eq
 1200 0032 0020     		moveq	r0, #0
 1201 0034 0120     		movne	r0, #1
 1202              	.LVL99:
1391:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1392:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     bitstatus = SET;
1393:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1394:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   else
1395:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1396:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     bitstatus = RESET;
1397:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   }
1398:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   
1399:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   return bitstatus;  
 1203              		.loc 1 1399 0
 1204 0036 002B     		cmp	r3, #0
 1205 0038 0CBF     		ite	eq
 1206 003a 0020     		moveq	r0, #0
 1207 003c 00F00100 		andne	r0, r0, #1
1400:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 1208              		.loc 1 1400 0
 1209 0040 10BD     		pop	{r4, pc}
 1210              		.cfi_endproc
 1211              	.LFE137:
 1213              		.section	.text.USART_ClearITPendingBit,"ax",%progbits
 1214              		.align	1
 1215              		.global	USART_ClearITPendingBit
 1216              		.thumb
 1217              		.thumb_func
 1219              	USART_ClearITPendingBit:
 1220              	.LFB138:
1401:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1402:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** /**
1403:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @brief  Clears the USARTx's interrupt pending bits.
1404:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
1405:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *         UART peripheral.
1406:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the interrupt pending bit to clear.
1407:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1408:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1409:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1410:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt. 
1411:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
1412:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *
1413:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1414:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          error) and IDLE (Idle line detected) pending bits are cleared by 
1415:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          software sequence: a read operation to USART_SR register 
1416:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
1417:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1418:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
1419:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1420:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   TC pending bit can be also cleared by software sequence: a read 
1421:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
1422:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          operation to USART_DR register (USART_SendData()).
1423:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @note   TXE pending bit is cleared only by a write to the USART_DR register 
1424:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *          (USART_SendData()).
1425:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   *  
1426:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   * @retval None
1427:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   */
1428:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
1429:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** {
 1221              		.loc 1 1429 0
 1222              		.cfi_startproc
 1223              		@ args = 0, pretend = 0, frame = 0
 1224              		@ frame_needed = 0, uses_anonymous_args = 0
 1225              		@ link register save eliminated.
 1226              	.LVL100:
1430:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   uint16_t bitpos = 0x00, itmask = 0x00;
1431:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* Check the parameters */
1432:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1433:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT)); 
1434:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** 
1435:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1436:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1437:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   {
1438:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1439:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   } 
1440:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****     
1441:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   bitpos = USART_IT >> 0x08;
1442:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 1227              		.loc 1 1442 0
 1228 0000 090A     		lsrs	r1, r1, #8
 1229              	.LVL101:
 1230 0002 0123     		movs	r3, #1
 1231 0004 8B40     		lsls	r3, r3, r1
1443:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c ****   USARTx->SR = (uint16_t)~itmask;
 1232              		.loc 1 1443 0
 1233 0006 DB43     		mvns	r3, r3
 1234 0008 9BB2     		uxth	r3, r3
 1235 000a 0380     		strh	r3, [r0, #0]	@ movhi
1444:../STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c **** }
 1236              		.loc 1 1444 0
 1237 000c 7047     		bx	lr
 1238              		.cfi_endproc
 1239              	.LFE138:
 1241              		.text
 1242              	.Letext0:
 1243              		.file 2 "d:/elektronik/ides/eclipse/yagarto/lib/gcc/../../arm-none-eabi/sys-include/stdint.h"
 1244              		.file 3 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\CMSIS\\Device\\STM32F4xx\\Include/stm32f4x
 1245              		.file 4 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\STM32F4xx_StdPeriph_Driver\\inc/stm32f4xx_
 1246              		.file 5 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\STM32F4xx_StdPeriph_Driver\\inc/stm32f4xx_
 1247              		.file 6 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\CMSIS\\Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f4xx_usart.c
  C:\Temp\ccBVKlHI.s:19     .text.USART_DeInit:00000000 $t
  C:\Temp\ccBVKlHI.s:24     .text.USART_DeInit:00000000 USART_DeInit
  C:\Temp\ccBVKlHI.s:135    .text.USART_DeInit:00000090 $d
  C:\Temp\ccBVKlHI.s:145    .text.USART_Init:00000000 $t
  C:\Temp\ccBVKlHI.s:150    .text.USART_Init:00000000 USART_Init
  C:\Temp\ccBVKlHI.s:314    .text.USART_Init:000000bc $d
  C:\Temp\ccBVKlHI.s:320    .text.USART_StructInit:00000000 $t
  C:\Temp\ccBVKlHI.s:325    .text.USART_StructInit:00000000 USART_StructInit
  C:\Temp\ccBVKlHI.s:355    .text.USART_ClockInit:00000000 $t
  C:\Temp\ccBVKlHI.s:360    .text.USART_ClockInit:00000000 USART_ClockInit
  C:\Temp\ccBVKlHI.s:403    .text.USART_ClockStructInit:00000000 $t
  C:\Temp\ccBVKlHI.s:408    .text.USART_ClockStructInit:00000000 USART_ClockStructInit
  C:\Temp\ccBVKlHI.s:431    .text.USART_Cmd:00000000 $t
  C:\Temp\ccBVKlHI.s:436    .text.USART_Cmd:00000000 USART_Cmd
  C:\Temp\ccBVKlHI.s:464    .text.USART_SetPrescaler:00000000 $t
  C:\Temp\ccBVKlHI.s:469    .text.USART_SetPrescaler:00000000 USART_SetPrescaler
  C:\Temp\ccBVKlHI.s:493    .text.USART_OverSampling8Cmd:00000000 $t
  C:\Temp\ccBVKlHI.s:498    .text.USART_OverSampling8Cmd:00000000 USART_OverSampling8Cmd
  C:\Temp\ccBVKlHI.s:526    .text.USART_OneBitMethodCmd:00000000 $t
  C:\Temp\ccBVKlHI.s:531    .text.USART_OneBitMethodCmd:00000000 USART_OneBitMethodCmd
  C:\Temp\ccBVKlHI.s:559    .text.USART_SendData:00000000 $t
  C:\Temp\ccBVKlHI.s:564    .text.USART_SendData:00000000 USART_SendData
  C:\Temp\ccBVKlHI.s:583    .text.USART_ReceiveData:00000000 $t
  C:\Temp\ccBVKlHI.s:588    .text.USART_ReceiveData:00000000 USART_ReceiveData
  C:\Temp\ccBVKlHI.s:607    .text.USART_SetAddress:00000000 $t
  C:\Temp\ccBVKlHI.s:612    .text.USART_SetAddress:00000000 USART_SetAddress
  C:\Temp\ccBVKlHI.s:638    .text.USART_ReceiverWakeUpCmd:00000000 $t
  C:\Temp\ccBVKlHI.s:643    .text.USART_ReceiverWakeUpCmd:00000000 USART_ReceiverWakeUpCmd
  C:\Temp\ccBVKlHI.s:671    .text.USART_WakeUpConfig:00000000 $t
  C:\Temp\ccBVKlHI.s:676    .text.USART_WakeUpConfig:00000000 USART_WakeUpConfig
  C:\Temp\ccBVKlHI.s:702    .text.USART_LINBreakDetectLengthConfig:00000000 $t
  C:\Temp\ccBVKlHI.s:707    .text.USART_LINBreakDetectLengthConfig:00000000 USART_LINBreakDetectLengthConfig
  C:\Temp\ccBVKlHI.s:733    .text.USART_LINCmd:00000000 $t
  C:\Temp\ccBVKlHI.s:738    .text.USART_LINCmd:00000000 USART_LINCmd
  C:\Temp\ccBVKlHI.s:766    .text.USART_SendBreak:00000000 $t
  C:\Temp\ccBVKlHI.s:771    .text.USART_SendBreak:00000000 USART_SendBreak
  C:\Temp\ccBVKlHI.s:790    .text.USART_HalfDuplexCmd:00000000 $t
  C:\Temp\ccBVKlHI.s:795    .text.USART_HalfDuplexCmd:00000000 USART_HalfDuplexCmd
  C:\Temp\ccBVKlHI.s:823    .text.USART_SetGuardTime:00000000 $t
  C:\Temp\ccBVKlHI.s:828    .text.USART_SetGuardTime:00000000 USART_SetGuardTime
  C:\Temp\ccBVKlHI.s:852    .text.USART_SmartCardCmd:00000000 $t
  C:\Temp\ccBVKlHI.s:857    .text.USART_SmartCardCmd:00000000 USART_SmartCardCmd
  C:\Temp\ccBVKlHI.s:885    .text.USART_SmartCardNACKCmd:00000000 $t
  C:\Temp\ccBVKlHI.s:890    .text.USART_SmartCardNACKCmd:00000000 USART_SmartCardNACKCmd
  C:\Temp\ccBVKlHI.s:918    .text.USART_IrDAConfig:00000000 $t
  C:\Temp\ccBVKlHI.s:923    .text.USART_IrDAConfig:00000000 USART_IrDAConfig
  C:\Temp\ccBVKlHI.s:949    .text.USART_IrDACmd:00000000 $t
  C:\Temp\ccBVKlHI.s:954    .text.USART_IrDACmd:00000000 USART_IrDACmd
  C:\Temp\ccBVKlHI.s:982    .text.USART_DMACmd:00000000 $t
  C:\Temp\ccBVKlHI.s:987    .text.USART_DMACmd:00000000 USART_DMACmd
  C:\Temp\ccBVKlHI.s:1016   .text.USART_ITConfig:00000000 $t
  C:\Temp\ccBVKlHI.s:1021   .text.USART_ITConfig:00000000 USART_ITConfig
  C:\Temp\ccBVKlHI.s:1088   .text.USART_GetFlagStatus:00000000 $t
  C:\Temp\ccBVKlHI.s:1093   .text.USART_GetFlagStatus:00000000 USART_GetFlagStatus
  C:\Temp\ccBVKlHI.s:1117   .text.USART_ClearFlag:00000000 $t
  C:\Temp\ccBVKlHI.s:1122   .text.USART_ClearFlag:00000000 USART_ClearFlag
  C:\Temp\ccBVKlHI.s:1141   .text.USART_GetITStatus:00000000 $t
  C:\Temp\ccBVKlHI.s:1146   .text.USART_GetITStatus:00000000 USART_GetITStatus
  C:\Temp\ccBVKlHI.s:1214   .text.USART_ClearITPendingBit:00000000 $t
  C:\Temp\ccBVKlHI.s:1219   .text.USART_ClearITPendingBit:00000000 USART_ClearITPendingBit
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
RCC_GetClocksFreq
