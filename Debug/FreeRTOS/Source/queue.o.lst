   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"queue.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.xQueueCreate,"ax",%progbits
  19              		.align	2
  20              		.global	xQueueCreate
  21              		.thumb
  22              		.thumb_func
  24              	xQueueCreate:
  25              	.LFB110:
  26              		.file 1 "../FreeRTOS/Source/queue.c"
   1:../FreeRTOS/Source/queue.c **** /*
   2:../FreeRTOS/Source/queue.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS/Source/queue.c **** 
   4:../FreeRTOS/Source/queue.c **** 
   5:../FreeRTOS/Source/queue.c ****     ***************************************************************************
   6:../FreeRTOS/Source/queue.c ****      *                                                                       *
   7:../FreeRTOS/Source/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS/Source/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS/Source/queue.c ****      *    available.                                                         *
  10:../FreeRTOS/Source/queue.c ****      *                                                                       *
  11:../FreeRTOS/Source/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS/Source/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS/Source/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS/Source/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS/Source/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS/Source/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS/Source/queue.c ****      *                                                                       *
  18:../FreeRTOS/Source/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS/Source/queue.c ****      *                                                                       *
  20:../FreeRTOS/Source/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS/Source/queue.c ****      *                                                                       *
  22:../FreeRTOS/Source/queue.c ****     ***************************************************************************
  23:../FreeRTOS/Source/queue.c **** 
  24:../FreeRTOS/Source/queue.c **** 
  25:../FreeRTOS/Source/queue.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS/Source/queue.c **** 
  27:../FreeRTOS/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS/Source/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS/Source/queue.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS/Source/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS/Source/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS/Source/queue.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS/Source/queue.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS/Source/queue.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS/Source/queue.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS/Source/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS/Source/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS/Source/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS/Source/queue.c ****     FreeRTOS WEB site.
  41:../FreeRTOS/Source/queue.c **** 
  42:../FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  43:../FreeRTOS/Source/queue.c **** 
  44:../FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS/Source/queue.c ****     contact details.
  46:../FreeRTOS/Source/queue.c **** 
  47:../FreeRTOS/Source/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS/Source/queue.c ****     critical systems.
  49:../FreeRTOS/Source/queue.c **** 
  50:../FreeRTOS/Source/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS/Source/queue.c ****     licensing and training services.
  52:../FreeRTOS/Source/queue.c **** */
  53:../FreeRTOS/Source/queue.c **** 
  54:../FreeRTOS/Source/queue.c **** #include <stdlib.h>
  55:../FreeRTOS/Source/queue.c **** #include <string.h>
  56:../FreeRTOS/Source/queue.c **** 
  57:../FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:../FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:../FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  60:../FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:../FreeRTOS/Source/queue.c **** 
  62:../FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  63:../FreeRTOS/Source/queue.c **** #include "task.h"
  64:../FreeRTOS/Source/queue.c **** 
  65:../FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  66:../FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  67:../FreeRTOS/Source/queue.c **** #endif
  68:../FreeRTOS/Source/queue.c **** 
  69:../FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../FreeRTOS/Source/queue.c **** 
  71:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------
  72:../FreeRTOS/Source/queue.c ****  * PUBLIC LIST API documented in list.h
  73:../FreeRTOS/Source/queue.c ****  *----------------------------------------------------------*/
  74:../FreeRTOS/Source/queue.c **** 
  75:../FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  76:../FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  77:../FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  78:../FreeRTOS/Source/queue.c **** 
  79:../FreeRTOS/Source/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  80:../FreeRTOS/Source/queue.c **** 
  81:../FreeRTOS/Source/queue.c **** /* For internal use only. */
  82:../FreeRTOS/Source/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  83:../FreeRTOS/Source/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  84:../FreeRTOS/Source/queue.c **** 
  85:../FreeRTOS/Source/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  86:../FreeRTOS/Source/queue.c **** #define pxMutexHolder					pcTail
  87:../FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
  88:../FreeRTOS/Source/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  89:../FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  90:../FreeRTOS/Source/queue.c **** 
  91:../FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  92:../FreeRTOS/Source/queue.c **** zero. */
  93:../FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
  94:../FreeRTOS/Source/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
  95:../FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
  96:../FreeRTOS/Source/queue.c **** 
  97:../FreeRTOS/Source/queue.c **** /*
  98:../FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  99:../FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.
 100:../FreeRTOS/Source/queue.c ****  */
 101:../FreeRTOS/Source/queue.c **** typedef struct QueueDefinition
 102:../FreeRTOS/Source/queue.c **** {
 103:../FreeRTOS/Source/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 104:../FreeRTOS/Source/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 105:../FreeRTOS/Source/queue.c **** 
 106:../FreeRTOS/Source/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 107:../FreeRTOS/Source/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 108:../FreeRTOS/Source/queue.c **** 
 109:../FreeRTOS/Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 110:../FreeRTOS/Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 111:../FreeRTOS/Source/queue.c **** 
 112:../FreeRTOS/Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 113:../FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 114:../FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 115:../FreeRTOS/Source/queue.c **** 
 116:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 117:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 118:../FreeRTOS/Source/queue.c **** 
 119:../FreeRTOS/Source/queue.c **** } xQUEUE;
 120:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 121:../FreeRTOS/Source/queue.c **** 
 122:../FreeRTOS/Source/queue.c **** /*
 123:../FreeRTOS/Source/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 124:../FreeRTOS/Source/queue.c ****  * To keep the definition private the API header file defines it as a
 125:../FreeRTOS/Source/queue.c ****  * pointer to void.
 126:../FreeRTOS/Source/queue.c ****  */
 127:../FreeRTOS/Source/queue.c **** typedef xQUEUE * xQueueHandle;
 128:../FreeRTOS/Source/queue.c **** 
 129:../FreeRTOS/Source/queue.c **** /*
 130:../FreeRTOS/Source/queue.c ****  * Prototypes for public functions are included here so we don't have to
 131:../FreeRTOS/Source/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 132:../FreeRTOS/Source/queue.c ****  * functions are documented in the API header file.
 133:../FreeRTOS/Source/queue.c ****  */
 134:../FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 135:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 136:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 137:../FreeRTOS/Source/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 138:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 139:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 140:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 141:../FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreateMutex( void ) PRIVILEGED_FUNCTION;
 142:../FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 143:../FreeRTOS/Source/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 144:../FreeRTOS/Source/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 145:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 146:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 147:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 148:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 149:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 150:../FreeRTOS/Source/queue.c **** void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_F
 151:../FreeRTOS/Source/queue.c **** 
 152:../FreeRTOS/Source/queue.c **** /*
 153:../FreeRTOS/Source/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 154:../FreeRTOS/Source/queue.c ****  * an optional component.
 155:../FreeRTOS/Source/queue.c ****  */
 156:../FreeRTOS/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
 157:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 158:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 159:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 160:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 161:../FreeRTOS/Source/queue.c **** #endif
 162:../FreeRTOS/Source/queue.c **** 
 163:../FreeRTOS/Source/queue.c **** /*
 164:../FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 165:../FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 166:../FreeRTOS/Source/queue.c ****  */
 167:../FreeRTOS/Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 168:../FreeRTOS/Source/queue.c **** 
 169:../FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 170:../FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 171:../FreeRTOS/Source/queue.c **** 	more user friendly. */
 172:../FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 173:../FreeRTOS/Source/queue.c **** 	{
 174:../FreeRTOS/Source/queue.c **** 		signed char *pcQueueName;
 175:../FreeRTOS/Source/queue.c **** 		xQueueHandle xHandle;
 176:../FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 177:../FreeRTOS/Source/queue.c **** 
 178:../FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 179:../FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 180:../FreeRTOS/Source/queue.c **** 	array position being vacant. */
 181:../FreeRTOS/Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 182:../FreeRTOS/Source/queue.c **** 
 183:../FreeRTOS/Source/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 184:../FreeRTOS/Source/queue.c **** 	member to NULL. */
 185:../FreeRTOS/Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 186:../FreeRTOS/Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 187:../FreeRTOS/Source/queue.c **** #endif
 188:../FreeRTOS/Source/queue.c **** 
 189:../FreeRTOS/Source/queue.c **** /*
 190:../FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 191:../FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 192:../FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 193:../FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 194:../FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 195:../FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 196:../FreeRTOS/Source/queue.c ****  */
 197:../FreeRTOS/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 198:../FreeRTOS/Source/queue.c **** 
 199:../FreeRTOS/Source/queue.c **** /*
 200:../FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 201:../FreeRTOS/Source/queue.c ****  *
 202:../FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 203:../FreeRTOS/Source/queue.c ****  */
 204:../FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 205:../FreeRTOS/Source/queue.c **** 
 206:../FreeRTOS/Source/queue.c **** /*
 207:../FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 208:../FreeRTOS/Source/queue.c ****  *
 209:../FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 210:../FreeRTOS/Source/queue.c ****  */
 211:../FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 212:../FreeRTOS/Source/queue.c **** 
 213:../FreeRTOS/Source/queue.c **** /*
 214:../FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 215:../FreeRTOS/Source/queue.c ****  * back of the queue.
 216:../FreeRTOS/Source/queue.c ****  */
 217:../FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 218:../FreeRTOS/Source/queue.c **** 
 219:../FreeRTOS/Source/queue.c **** /*
 220:../FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 221:../FreeRTOS/Source/queue.c ****  */
 222:../FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 223:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 224:../FreeRTOS/Source/queue.c **** 
 225:../FreeRTOS/Source/queue.c **** /*
 226:../FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 227:../FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 228:../FreeRTOS/Source/queue.c ****  */
 229:../FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 230:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 231:../FreeRTOS/Source/queue.c **** 	{														\
 232:../FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 233:../FreeRTOS/Source/queue.c **** 		{													\
 234:../FreeRTOS/Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 235:../FreeRTOS/Source/queue.c **** 		}													\
 236:../FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 237:../FreeRTOS/Source/queue.c **** 		{													\
 238:../FreeRTOS/Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 239:../FreeRTOS/Source/queue.c **** 		}													\
 240:../FreeRTOS/Source/queue.c **** 	}														\
 241:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 242:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 243:../FreeRTOS/Source/queue.c **** 
 244:../FreeRTOS/Source/queue.c **** 
 245:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------
 246:../FreeRTOS/Source/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 247:../FreeRTOS/Source/queue.c ****  *----------------------------------------------------------*/
 248:../FreeRTOS/Source/queue.c **** 
 249:../FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 250:../FreeRTOS/Source/queue.c **** {
  27              		.loc 1 250 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 24
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 14, -4
  35              		.cfi_offset 7, -8
  36 0002 86B0     		sub	sp, sp, #24
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 32
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
  43 0008 3960     		str	r1, [r7, #0]
 251:../FreeRTOS/Source/queue.c **** xQUEUE *pxNewQueue;
 252:../FreeRTOS/Source/queue.c **** size_t xQueueSizeInBytes;
 253:../FreeRTOS/Source/queue.c **** xQueueHandle xReturn = NULL;
  44              		.loc 1 253 0
  45 000a 4FF00003 		mov	r3, #0
  46 000e 7B61     		str	r3, [r7, #20]
 254:../FreeRTOS/Source/queue.c **** 
 255:../FreeRTOS/Source/queue.c **** 	/* Allocate the new queue structure. */
 256:../FreeRTOS/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  47              		.loc 1 256 0
  48 0010 7B68     		ldr	r3, [r7, #4]
  49 0012 002B     		cmp	r3, #0
  50 0014 56D0     		beq	.L2
 257:../FreeRTOS/Source/queue.c **** 	{
 258:../FreeRTOS/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  51              		.loc 1 258 0
  52 0016 4FF04C00 		mov	r0, #76
  53 001a FFF7FEFF 		bl	malloc
  54 001e 0346     		mov	r3, r0
  55 0020 3B61     		str	r3, [r7, #16]
 259:../FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
  56              		.loc 1 259 0
  57 0022 3B69     		ldr	r3, [r7, #16]
  58 0024 002B     		cmp	r3, #0
  59 0026 4DD0     		beq	.L2
 260:../FreeRTOS/Source/queue.c **** 		{
 261:../FreeRTOS/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 262:../FreeRTOS/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 263:../FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  60              		.loc 1 263 0
  61 0028 7B68     		ldr	r3, [r7, #4]
  62 002a 3A68     		ldr	r2, [r7, #0]
  63 002c 02FB03F3 		mul	r3, r2, r3
  64 0030 03F10103 		add	r3, r3, #1
  65 0034 FB60     		str	r3, [r7, #12]
 264:../FreeRTOS/Source/queue.c **** 
 265:../FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  66              		.loc 1 265 0
  67 0036 F868     		ldr	r0, [r7, #12]
  68 0038 FFF7FEFF 		bl	malloc
  69 003c 0346     		mov	r3, r0
  70 003e 1A46     		mov	r2, r3
  71 0040 3B69     		ldr	r3, [r7, #16]
  72 0042 1A60     		str	r2, [r3, #0]
 266:../FreeRTOS/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
  73              		.loc 1 266 0
  74 0044 3B69     		ldr	r3, [r7, #16]
  75 0046 1B68     		ldr	r3, [r3, #0]
  76 0048 002B     		cmp	r3, #0
  77 004a 38D0     		beq	.L3
 267:../FreeRTOS/Source/queue.c **** 			{
 268:../FreeRTOS/Source/queue.c **** 				/* Initialise the queue members as described above where the
 269:../FreeRTOS/Source/queue.c **** 				queue type is defined. */
 270:../FreeRTOS/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
  78              		.loc 1 270 0
  79 004c 3B69     		ldr	r3, [r7, #16]
  80 004e 1A68     		ldr	r2, [r3, #0]
  81 0050 7B68     		ldr	r3, [r7, #4]
  82 0052 3968     		ldr	r1, [r7, #0]
  83 0054 01FB03F3 		mul	r3, r1, r3
  84 0058 D218     		adds	r2, r2, r3
  85 005a 3B69     		ldr	r3, [r7, #16]
  86 005c 5A60     		str	r2, [r3, #4]
 271:../FreeRTOS/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  87              		.loc 1 271 0
  88 005e 3B69     		ldr	r3, [r7, #16]
  89 0060 4FF00002 		mov	r2, #0
  90 0064 9A63     		str	r2, [r3, #56]
 272:../FreeRTOS/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
  91              		.loc 1 272 0
  92 0066 3B69     		ldr	r3, [r7, #16]
  93 0068 1A68     		ldr	r2, [r3, #0]
  94 006a 3B69     		ldr	r3, [r7, #16]
  95 006c 9A60     		str	r2, [r3, #8]
 273:../FreeRTOS/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U
  96              		.loc 1 273 0
  97 006e 3B69     		ldr	r3, [r7, #16]
  98 0070 1A68     		ldr	r2, [r3, #0]
  99 0072 7B68     		ldr	r3, [r7, #4]
 100 0074 03F1FF33 		add	r3, r3, #-1
 101 0078 3968     		ldr	r1, [r7, #0]
 102 007a 01FB03F3 		mul	r3, r1, r3
 103 007e D218     		adds	r2, r2, r3
 104 0080 3B69     		ldr	r3, [r7, #16]
 105 0082 DA60     		str	r2, [r3, #12]
 274:../FreeRTOS/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 106              		.loc 1 274 0
 107 0084 3B69     		ldr	r3, [r7, #16]
 108 0086 7A68     		ldr	r2, [r7, #4]
 109 0088 DA63     		str	r2, [r3, #60]
 275:../FreeRTOS/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 110              		.loc 1 275 0
 111 008a 3B69     		ldr	r3, [r7, #16]
 112 008c 3A68     		ldr	r2, [r7, #0]
 113 008e 1A64     		str	r2, [r3, #64]
 276:../FreeRTOS/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 114              		.loc 1 276 0
 115 0090 3B69     		ldr	r3, [r7, #16]
 116 0092 4FF0FF32 		mov	r2, #-1
 117 0096 5A64     		str	r2, [r3, #68]
 277:../FreeRTOS/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 118              		.loc 1 277 0
 119 0098 3B69     		ldr	r3, [r7, #16]
 120 009a 4FF0FF32 		mov	r2, #-1
 121 009e 9A64     		str	r2, [r3, #72]
 278:../FreeRTOS/Source/queue.c **** 
 279:../FreeRTOS/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 280:../FreeRTOS/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 122              		.loc 1 280 0
 123 00a0 3B69     		ldr	r3, [r7, #16]
 124 00a2 03F11003 		add	r3, r3, #16
 125 00a6 1846     		mov	r0, r3
 126 00a8 FFF7FEFF 		bl	vListInitialise
 281:../FreeRTOS/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 127              		.loc 1 281 0
 128 00ac 3B69     		ldr	r3, [r7, #16]
 129 00ae 03F12403 		add	r3, r3, #36
 130 00b2 1846     		mov	r0, r3
 131 00b4 FFF7FEFF 		bl	vListInitialise
 282:../FreeRTOS/Source/queue.c **** 
 283:../FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 284:../FreeRTOS/Source/queue.c **** 				xReturn = pxNewQueue;
 132              		.loc 1 284 0
 133 00b8 3B69     		ldr	r3, [r7, #16]
 134 00ba 7B61     		str	r3, [r7, #20]
 135 00bc 02E0     		b	.L2
 136              	.L3:
 285:../FreeRTOS/Source/queue.c **** 			}
 286:../FreeRTOS/Source/queue.c **** 			else
 287:../FreeRTOS/Source/queue.c **** 			{
 288:../FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 289:../FreeRTOS/Source/queue.c **** 				vPortFree( pxNewQueue );
 137              		.loc 1 289 0
 138 00be 3869     		ldr	r0, [r7, #16]
 139 00c0 FFF7FEFF 		bl	free
 140              	.L2:
 290:../FreeRTOS/Source/queue.c **** 			}
 291:../FreeRTOS/Source/queue.c **** 		}
 292:../FreeRTOS/Source/queue.c **** 	}
 293:../FreeRTOS/Source/queue.c **** 
 294:../FreeRTOS/Source/queue.c **** 	configASSERT( xReturn );
 295:../FreeRTOS/Source/queue.c **** 
 296:../FreeRTOS/Source/queue.c **** 	return xReturn;
 141              		.loc 1 296 0
 142 00c4 7B69     		ldr	r3, [r7, #20]
 297:../FreeRTOS/Source/queue.c **** }
 143              		.loc 1 297 0
 144 00c6 1846     		mov	r0, r3
 145 00c8 07F11807 		add	r7, r7, #24
 146 00cc BD46     		mov	sp, r7
 147 00ce 80BD     		pop	{r7, pc}
 148              		.cfi_endproc
 149              	.LFE110:
 151              		.section	.text.xQueueCreateMutex,"ax",%progbits
 152              		.align	2
 153              		.global	xQueueCreateMutex
 154              		.thumb
 155              		.thumb_func
 157              	xQueueCreateMutex:
 158              	.LFB111:
 298:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 299:../FreeRTOS/Source/queue.c **** 
 300:../FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 301:../FreeRTOS/Source/queue.c **** 
 302:../FreeRTOS/Source/queue.c **** 	xQueueHandle xQueueCreateMutex( void )
 303:../FreeRTOS/Source/queue.c **** 	{
 159              		.loc 1 303 0
 160              		.cfi_startproc
 161              		@ args = 0, pretend = 0, frame = 8
 162              		@ frame_needed = 1, uses_anonymous_args = 0
 163 0000 80B5     		push	{r7, lr}
 164              	.LCFI3:
 165              		.cfi_def_cfa_offset 8
 166              		.cfi_offset 14, -4
 167              		.cfi_offset 7, -8
 168 0002 82B0     		sub	sp, sp, #8
 169              	.LCFI4:
 170              		.cfi_def_cfa_offset 16
 171 0004 00AF     		add	r7, sp, #0
 172              	.LCFI5:
 173              		.cfi_def_cfa_register 7
 304:../FreeRTOS/Source/queue.c **** 	xQUEUE *pxNewQueue;
 305:../FreeRTOS/Source/queue.c **** 
 306:../FreeRTOS/Source/queue.c **** 		/* Allocate the new queue structure. */
 307:../FreeRTOS/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 174              		.loc 1 307 0
 175 0006 4FF04C00 		mov	r0, #76
 176 000a FFF7FEFF 		bl	malloc
 177 000e 0346     		mov	r3, r0
 178 0010 7B60     		str	r3, [r7, #4]
 308:../FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 179              		.loc 1 308 0
 180 0012 7B68     		ldr	r3, [r7, #4]
 181 0014 002B     		cmp	r3, #0
 182 0016 38D0     		beq	.L5
 309:../FreeRTOS/Source/queue.c **** 		{
 310:../FreeRTOS/Source/queue.c **** 			/* Information required for priority inheritance. */
 311:../FreeRTOS/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 183              		.loc 1 311 0
 184 0018 7B68     		ldr	r3, [r7, #4]
 185 001a 4FF00002 		mov	r2, #0
 186 001e 5A60     		str	r2, [r3, #4]
 312:../FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 187              		.loc 1 312 0
 188 0020 7B68     		ldr	r3, [r7, #4]
 189 0022 4FF00002 		mov	r2, #0
 190 0026 1A60     		str	r2, [r3, #0]
 313:../FreeRTOS/Source/queue.c **** 
 314:../FreeRTOS/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 315:../FreeRTOS/Source/queue.c **** 			of the queue. */
 316:../FreeRTOS/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 191              		.loc 1 316 0
 192 0028 7B68     		ldr	r3, [r7, #4]
 193 002a 4FF00002 		mov	r2, #0
 194 002e 9A60     		str	r2, [r3, #8]
 317:../FreeRTOS/Source/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 195              		.loc 1 317 0
 196 0030 7B68     		ldr	r3, [r7, #4]
 197 0032 4FF00002 		mov	r2, #0
 198 0036 DA60     		str	r2, [r3, #12]
 318:../FreeRTOS/Source/queue.c **** 
 319:../FreeRTOS/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 320:../FreeRTOS/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 321:../FreeRTOS/Source/queue.c **** 			of the mutex. */
 322:../FreeRTOS/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 199              		.loc 1 322 0
 200 0038 7B68     		ldr	r3, [r7, #4]
 201 003a 4FF00002 		mov	r2, #0
 202 003e 9A63     		str	r2, [r3, #56]
 323:../FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 203              		.loc 1 323 0
 204 0040 7B68     		ldr	r3, [r7, #4]
 205 0042 4FF00102 		mov	r2, #1
 206 0046 DA63     		str	r2, [r3, #60]
 324:../FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 207              		.loc 1 324 0
 208 0048 7B68     		ldr	r3, [r7, #4]
 209 004a 4FF00002 		mov	r2, #0
 210 004e 1A64     		str	r2, [r3, #64]
 325:../FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 211              		.loc 1 325 0
 212 0050 7B68     		ldr	r3, [r7, #4]
 213 0052 4FF0FF32 		mov	r2, #-1
 214 0056 5A64     		str	r2, [r3, #68]
 326:../FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 215              		.loc 1 326 0
 216 0058 7B68     		ldr	r3, [r7, #4]
 217 005a 4FF0FF32 		mov	r2, #-1
 218 005e 9A64     		str	r2, [r3, #72]
 327:../FreeRTOS/Source/queue.c **** 
 328:../FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 329:../FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 219              		.loc 1 329 0
 220 0060 7B68     		ldr	r3, [r7, #4]
 221 0062 03F11003 		add	r3, r3, #16
 222 0066 1846     		mov	r0, r3
 223 0068 FFF7FEFF 		bl	vListInitialise
 330:../FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 224              		.loc 1 330 0
 225 006c 7B68     		ldr	r3, [r7, #4]
 226 006e 03F12403 		add	r3, r3, #36
 227 0072 1846     		mov	r0, r3
 228 0074 FFF7FEFF 		bl	vListInitialise
 331:../FreeRTOS/Source/queue.c **** 
 332:../FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 333:../FreeRTOS/Source/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 229              		.loc 1 333 0
 230 0078 7868     		ldr	r0, [r7, #4]
 231 007a 4FF00001 		mov	r1, #0
 232 007e 4FF00002 		mov	r2, #0
 233 0082 4FF00003 		mov	r3, #0
 234 0086 FFF7FEFF 		bl	xQueueGenericSend
 235              	.L5:
 334:../FreeRTOS/Source/queue.c **** 
 335:../FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 336:../FreeRTOS/Source/queue.c **** 		}
 337:../FreeRTOS/Source/queue.c **** 		else
 338:../FreeRTOS/Source/queue.c **** 		{
 339:../FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 340:../FreeRTOS/Source/queue.c **** 		}
 341:../FreeRTOS/Source/queue.c **** 
 342:../FreeRTOS/Source/queue.c **** 		configASSERT( pxNewQueue );
 343:../FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 236              		.loc 1 343 0
 237 008a 7B68     		ldr	r3, [r7, #4]
 344:../FreeRTOS/Source/queue.c **** 	}
 238              		.loc 1 344 0
 239 008c 1846     		mov	r0, r3
 240 008e 07F10807 		add	r7, r7, #8
 241 0092 BD46     		mov	sp, r7
 242 0094 80BD     		pop	{r7, pc}
 243              		.cfi_endproc
 244              	.LFE111:
 246 0096 00BF     		.section	.text.xQueueGenericSend,"ax",%progbits
 247              		.align	2
 248              		.global	xQueueGenericSend
 249              		.thumb
 250              		.thumb_func
 252              	xQueueGenericSend:
 253              	.LFB112:
 345:../FreeRTOS/Source/queue.c **** 
 346:../FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 347:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 348:../FreeRTOS/Source/queue.c **** 
 349:../FreeRTOS/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 350:../FreeRTOS/Source/queue.c **** 
 351:../FreeRTOS/Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 352:../FreeRTOS/Source/queue.c **** 	{
 353:../FreeRTOS/Source/queue.c **** 	portBASE_TYPE xReturn;
 354:../FreeRTOS/Source/queue.c **** 
 355:../FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 356:../FreeRTOS/Source/queue.c **** 
 357:../FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 358:../FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 359:../FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 360:../FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 361:../FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 362:../FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 363:../FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 364:../FreeRTOS/Source/queue.c **** 		{
 365:../FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 366:../FreeRTOS/Source/queue.c **** 
 367:../FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 368:../FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 369:../FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 370:../FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 371:../FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 372:../FreeRTOS/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 373:../FreeRTOS/Source/queue.c **** 
 374:../FreeRTOS/Source/queue.c **** 			/* Have we unwound the call count? */
 375:../FreeRTOS/Source/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 376:../FreeRTOS/Source/queue.c **** 			{
 377:../FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 378:../FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 379:../FreeRTOS/Source/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 380:../FreeRTOS/Source/queue.c **** 			}
 381:../FreeRTOS/Source/queue.c **** 
 382:../FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 383:../FreeRTOS/Source/queue.c **** 		}
 384:../FreeRTOS/Source/queue.c **** 		else
 385:../FreeRTOS/Source/queue.c **** 		{
 386:../FreeRTOS/Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 387:../FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 388:../FreeRTOS/Source/queue.c **** 
 389:../FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 390:../FreeRTOS/Source/queue.c **** 		}
 391:../FreeRTOS/Source/queue.c **** 
 392:../FreeRTOS/Source/queue.c **** 		return xReturn;
 393:../FreeRTOS/Source/queue.c **** 	}
 394:../FreeRTOS/Source/queue.c **** 
 395:../FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 396:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 397:../FreeRTOS/Source/queue.c **** 
 398:../FreeRTOS/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 399:../FreeRTOS/Source/queue.c **** 
 400:../FreeRTOS/Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 401:../FreeRTOS/Source/queue.c **** 	{
 402:../FreeRTOS/Source/queue.c **** 	portBASE_TYPE xReturn;
 403:../FreeRTOS/Source/queue.c **** 
 404:../FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 405:../FreeRTOS/Source/queue.c **** 
 406:../FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 407:../FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 408:../FreeRTOS/Source/queue.c **** 
 409:../FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 410:../FreeRTOS/Source/queue.c **** 
 411:../FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 412:../FreeRTOS/Source/queue.c **** 		{
 413:../FreeRTOS/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 414:../FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 415:../FreeRTOS/Source/queue.c **** 		}
 416:../FreeRTOS/Source/queue.c **** 		else
 417:../FreeRTOS/Source/queue.c **** 		{
 418:../FreeRTOS/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 419:../FreeRTOS/Source/queue.c **** 
 420:../FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 421:../FreeRTOS/Source/queue.c **** 			we may have blocked to reach here. */
 422:../FreeRTOS/Source/queue.c **** 			if( xReturn == pdPASS )
 423:../FreeRTOS/Source/queue.c **** 			{
 424:../FreeRTOS/Source/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 425:../FreeRTOS/Source/queue.c **** 			}
 426:../FreeRTOS/Source/queue.c **** 			else
 427:../FreeRTOS/Source/queue.c **** 			{
 428:../FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 429:../FreeRTOS/Source/queue.c **** 			}
 430:../FreeRTOS/Source/queue.c **** 		}
 431:../FreeRTOS/Source/queue.c **** 
 432:../FreeRTOS/Source/queue.c **** 		return xReturn;
 433:../FreeRTOS/Source/queue.c **** 	}
 434:../FreeRTOS/Source/queue.c **** 
 435:../FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 436:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 437:../FreeRTOS/Source/queue.c **** 
 438:../FreeRTOS/Source/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 439:../FreeRTOS/Source/queue.c **** 
 440:../FreeRTOS/Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 441:../FreeRTOS/Source/queue.c **** 	{
 442:../FreeRTOS/Source/queue.c **** 	xQueueHandle pxHandle;
 443:../FreeRTOS/Source/queue.c **** 
 444:../FreeRTOS/Source/queue.c **** 		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGT
 445:../FreeRTOS/Source/queue.c **** 
 446:../FreeRTOS/Source/queue.c **** 		if( pxHandle != NULL )
 447:../FreeRTOS/Source/queue.c **** 		{
 448:../FreeRTOS/Source/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 449:../FreeRTOS/Source/queue.c **** 
 450:../FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 451:../FreeRTOS/Source/queue.c **** 		}
 452:../FreeRTOS/Source/queue.c **** 		else
 453:../FreeRTOS/Source/queue.c **** 		{
 454:../FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 455:../FreeRTOS/Source/queue.c **** 		}
 456:../FreeRTOS/Source/queue.c **** 
 457:../FreeRTOS/Source/queue.c **** 		configASSERT( pxHandle );
 458:../FreeRTOS/Source/queue.c **** 		return pxHandle;
 459:../FreeRTOS/Source/queue.c **** 	}
 460:../FreeRTOS/Source/queue.c **** 
 461:../FreeRTOS/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 462:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 463:../FreeRTOS/Source/queue.c **** 
 464:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 465:../FreeRTOS/Source/queue.c **** {
 254              		.loc 1 465 0
 255              		.cfi_startproc
 256              		@ args = 0, pretend = 0, frame = 32
 257              		@ frame_needed = 1, uses_anonymous_args = 0
 258 0000 80B5     		push	{r7, lr}
 259              	.LCFI6:
 260              		.cfi_def_cfa_offset 8
 261              		.cfi_offset 14, -4
 262              		.cfi_offset 7, -8
 263 0002 88B0     		sub	sp, sp, #32
 264              	.LCFI7:
 265              		.cfi_def_cfa_offset 40
 266 0004 00AF     		add	r7, sp, #0
 267              	.LCFI8:
 268              		.cfi_def_cfa_register 7
 269 0006 F860     		str	r0, [r7, #12]
 270 0008 B960     		str	r1, [r7, #8]
 271 000a 7A60     		str	r2, [r7, #4]
 272 000c 3B60     		str	r3, [r7, #0]
 466:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 273              		.loc 1 466 0
 274 000e 4FF00003 		mov	r3, #0
 275 0012 FB61     		str	r3, [r7, #28]
 276 0014 00E0     		b	.L17
 277              	.L18:
 467:../FreeRTOS/Source/queue.c **** xTimeOutType xTimeOut;
 468:../FreeRTOS/Source/queue.c **** 
 469:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 470:../FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 471:../FreeRTOS/Source/queue.c **** 
 472:../FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 473:../FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 474:../FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 475:../FreeRTOS/Source/queue.c **** 	for( ;; )
 476:../FreeRTOS/Source/queue.c **** 	{
 477:../FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 478:../FreeRTOS/Source/queue.c **** 		{
 479:../FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 480:../FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 481:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 482:../FreeRTOS/Source/queue.c **** 			{
 483:../FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 484:../FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 485:../FreeRTOS/Source/queue.c **** 
 486:../FreeRTOS/Source/queue.c **** 				/* If there was a task waiting for data to arrive on the
 487:../FreeRTOS/Source/queue.c **** 				queue then unblock it now. */
 488:../FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 489:../FreeRTOS/Source/queue.c **** 				{
 490:../FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 491:../FreeRTOS/Source/queue.c **** 					{
 492:../FreeRTOS/Source/queue.c **** 						/* The unblocked task has a priority higher than
 493:../FreeRTOS/Source/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 494:../FreeRTOS/Source/queue.c **** 						this from within the critical section - the kernel
 495:../FreeRTOS/Source/queue.c **** 						takes care of that. */
 496:../FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 497:../FreeRTOS/Source/queue.c **** 					}
 498:../FreeRTOS/Source/queue.c **** 				}
 499:../FreeRTOS/Source/queue.c **** 
 500:../FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 501:../FreeRTOS/Source/queue.c **** 
 502:../FreeRTOS/Source/queue.c **** 				/* Return to the original privilege level before exiting the
 503:../FreeRTOS/Source/queue.c **** 				function. */
 504:../FreeRTOS/Source/queue.c **** 				return pdPASS;
 505:../FreeRTOS/Source/queue.c **** 			}
 506:../FreeRTOS/Source/queue.c **** 			else
 507:../FreeRTOS/Source/queue.c **** 			{
 508:../FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 509:../FreeRTOS/Source/queue.c **** 				{
 510:../FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 511:../FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 512:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 513:../FreeRTOS/Source/queue.c **** 
 514:../FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 515:../FreeRTOS/Source/queue.c **** 					the function. */
 516:../FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 517:../FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 518:../FreeRTOS/Source/queue.c **** 				}
 519:../FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 520:../FreeRTOS/Source/queue.c **** 				{
 521:../FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 522:../FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 523:../FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 524:../FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 525:../FreeRTOS/Source/queue.c **** 				}
 526:../FreeRTOS/Source/queue.c **** 			}
 527:../FreeRTOS/Source/queue.c **** 		}
 528:../FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 529:../FreeRTOS/Source/queue.c **** 
 530:../FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 531:../FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 532:../FreeRTOS/Source/queue.c **** 
 533:../FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 535:../FreeRTOS/Source/queue.c **** 
 536:../FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 537:../FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 538:../FreeRTOS/Source/queue.c **** 		{
 539:../FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 540:../FreeRTOS/Source/queue.c **** 			{
 541:../FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 542:../FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 543:../FreeRTOS/Source/queue.c **** 
 544:../FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 545:../FreeRTOS/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 546:../FreeRTOS/Source/queue.c **** 				remove this task from the event	list again - but as the
 547:../FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 548:../FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 549:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 550:../FreeRTOS/Source/queue.c **** 
 551:../FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 552:../FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 553:../FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 554:../FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 555:../FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 556:../FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 557:../FreeRTOS/Source/queue.c **** 				{
 558:../FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 559:../FreeRTOS/Source/queue.c **** 				}
 560:../FreeRTOS/Source/queue.c **** 			}
 561:../FreeRTOS/Source/queue.c **** 			else
 562:../FreeRTOS/Source/queue.c **** 			{
 563:../FreeRTOS/Source/queue.c **** 				/* Try again. */
 564:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 565:../FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 566:../FreeRTOS/Source/queue.c **** 			}
 567:../FreeRTOS/Source/queue.c **** 		}
 568:../FreeRTOS/Source/queue.c **** 		else
 569:../FreeRTOS/Source/queue.c **** 		{
 570:../FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 571:../FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 572:../FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 573:../FreeRTOS/Source/queue.c **** 
 574:../FreeRTOS/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 575:../FreeRTOS/Source/queue.c **** 			function. */
 576:../FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 577:../FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 578:../FreeRTOS/Source/queue.c **** 		}
 579:../FreeRTOS/Source/queue.c **** 	}
 278              		.loc 1 579 0
 279 0016 00BF     		nop
 280              	.L17:
 477:../FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 281              		.loc 1 477 0
 282 0018 FFF7FEFF 		bl	vPortEnterCritical
 481:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 283              		.loc 1 481 0
 284 001c FB68     		ldr	r3, [r7, #12]
 285 001e 9B6B     		ldr	r3, [r3, #56]
 286 0020 1A46     		mov	r2, r3
 287 0022 FB68     		ldr	r3, [r7, #12]
 288 0024 DB6B     		ldr	r3, [r3, #60]
 289 0026 9A42     		cmp	r2, r3
 290 0028 18D2     		bcs	.L7
 484:../FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 291              		.loc 1 484 0
 292 002a F868     		ldr	r0, [r7, #12]
 293 002c B968     		ldr	r1, [r7, #8]
 294 002e 3A68     		ldr	r2, [r7, #0]
 295 0030 FFF7FEFF 		bl	prvCopyDataToQueue
 488:../FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 296              		.loc 1 488 0
 297 0034 FB68     		ldr	r3, [r7, #12]
 298 0036 5B6A     		ldr	r3, [r3, #36]
 299 0038 002B     		cmp	r3, #0
 300 003a 0AD0     		beq	.L8
 490:../FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 301              		.loc 1 490 0
 302 003c FB68     		ldr	r3, [r7, #12]
 303 003e 03F12403 		add	r3, r3, #36
 304 0042 1846     		mov	r0, r3
 305 0044 FFF7FEFF 		bl	xTaskRemoveFromEventList
 306 0048 0346     		mov	r3, r0
 307 004a 012B     		cmp	r3, #1
 308 004c 01D1     		bne	.L8
 496:../FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 309              		.loc 1 496 0
 310 004e FFF7FEFF 		bl	vPortYieldFromISR
 311              	.L8:
 500:../FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 312              		.loc 1 500 0
 313 0052 FFF7FEFF 		bl	vPortExitCritical
 504:../FreeRTOS/Source/queue.c **** 				return pdPASS;
 314              		.loc 1 504 0
 315 0056 4FF00103 		mov	r3, #1
 316 005a 5DE0     		b	.L9
 317              	.L7:
 508:../FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 318              		.loc 1 508 0
 319 005c 7B68     		ldr	r3, [r7, #4]
 320 005e 002B     		cmp	r3, #0
 321 0060 04D1     		bne	.L10
 512:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 322              		.loc 1 512 0
 323 0062 FFF7FEFF 		bl	vPortExitCritical
 517:../FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 324              		.loc 1 517 0
 325 0066 4FF00003 		mov	r3, #0
 326 006a 55E0     		b	.L9
 327              	.L10:
 519:../FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 328              		.loc 1 519 0
 329 006c FB69     		ldr	r3, [r7, #28]
 330 006e 002B     		cmp	r3, #0
 331 0070 07D1     		bne	.L11
 523:../FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 332              		.loc 1 523 0
 333 0072 07F11403 		add	r3, r7, #20
 334 0076 1846     		mov	r0, r3
 335 0078 FFF7FEFF 		bl	vTaskSetTimeOutState
 524:../FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 336              		.loc 1 524 0
 337 007c 4FF00103 		mov	r3, #1
 338 0080 FB61     		str	r3, [r7, #28]
 339              	.L11:
 528:../FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 340              		.loc 1 528 0
 341 0082 FFF7FEFF 		bl	vPortExitCritical
 533:../FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 342              		.loc 1 533 0
 343 0086 FFF7FEFF 		bl	vTaskSuspendAll
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 344              		.loc 1 534 0
 345 008a FFF7FEFF 		bl	vPortEnterCritical
 346 008e FB68     		ldr	r3, [r7, #12]
 347 0090 5B6C     		ldr	r3, [r3, #68]
 348 0092 B3F1FF3F 		cmp	r3, #-1
 349 0096 03D1     		bne	.L12
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 350              		.loc 1 534 0 is_stmt 0 discriminator 1
 351 0098 FB68     		ldr	r3, [r7, #12]
 352 009a 4FF00002 		mov	r2, #0
 353 009e 5A64     		str	r2, [r3, #68]
 354              	.L12:
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 355              		.loc 1 534 0 discriminator 2
 356 00a0 FB68     		ldr	r3, [r7, #12]
 357 00a2 9B6C     		ldr	r3, [r3, #72]
 358 00a4 B3F1FF3F 		cmp	r3, #-1
 359 00a8 03D1     		bne	.L13
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 360              		.loc 1 534 0 discriminator 3
 361 00aa FB68     		ldr	r3, [r7, #12]
 362 00ac 4FF00002 		mov	r2, #0
 363 00b0 9A64     		str	r2, [r3, #72]
 364              	.L13:
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 365              		.loc 1 534 0 discriminator 4
 366 00b2 FFF7FEFF 		bl	vPortExitCritical
 537:../FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 367              		.loc 1 537 0 is_stmt 1 discriminator 4
 368 00b6 07F11402 		add	r2, r7, #20
 369 00ba 07F10403 		add	r3, r7, #4
 370 00be 1046     		mov	r0, r2
 371 00c0 1946     		mov	r1, r3
 372 00c2 FFF7FEFF 		bl	xTaskCheckForTimeOut
 373 00c6 0346     		mov	r3, r0
 374 00c8 002B     		cmp	r3, #0
 375 00ca 1ED1     		bne	.L14
 539:../FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 376              		.loc 1 539 0
 377 00cc F868     		ldr	r0, [r7, #12]
 378 00ce FFF7FEFF 		bl	prvIsQueueFull
 379 00d2 0346     		mov	r3, r0
 380 00d4 002B     		cmp	r3, #0
 381 00d6 12D0     		beq	.L15
 542:../FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 382              		.loc 1 542 0
 383 00d8 FB68     		ldr	r3, [r7, #12]
 384 00da 03F11002 		add	r2, r3, #16
 385 00de 7B68     		ldr	r3, [r7, #4]
 386 00e0 1046     		mov	r0, r2
 387 00e2 1946     		mov	r1, r3
 388 00e4 FFF7FEFF 		bl	vTaskPlaceOnEventList
 549:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 389              		.loc 1 549 0
 390 00e8 F868     		ldr	r0, [r7, #12]
 391 00ea FFF7FEFF 		bl	prvUnlockQueue
 556:../FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 392              		.loc 1 556 0
 393 00ee FFF7FEFF 		bl	xTaskResumeAll
 394 00f2 0346     		mov	r3, r0
 395 00f4 002B     		cmp	r3, #0
 396 00f6 8ED1     		bne	.L18
 558:../FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 397              		.loc 1 558 0
 398 00f8 FFF7FEFF 		bl	vPortYieldFromISR
 399              		.loc 1 579 0
 400 00fc 8BE7     		b	.L18
 401              	.L15:
 564:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 402              		.loc 1 564 0
 403 00fe F868     		ldr	r0, [r7, #12]
 404 0100 FFF7FEFF 		bl	prvUnlockQueue
 565:../FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 405              		.loc 1 565 0
 406 0104 FFF7FEFF 		bl	xTaskResumeAll
 407              		.loc 1 579 0
 408 0108 85E7     		b	.L18
 409              	.L14:
 571:../FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 410              		.loc 1 571 0
 411 010a F868     		ldr	r0, [r7, #12]
 412 010c FFF7FEFF 		bl	prvUnlockQueue
 572:../FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 413              		.loc 1 572 0
 414 0110 FFF7FEFF 		bl	xTaskResumeAll
 577:../FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 415              		.loc 1 577 0
 416 0114 4FF00003 		mov	r3, #0
 417              	.L9:
 580:../FreeRTOS/Source/queue.c **** }
 418              		.loc 1 580 0
 419 0118 1846     		mov	r0, r3
 420 011a 07F12007 		add	r7, r7, #32
 421 011e BD46     		mov	sp, r7
 422 0120 80BD     		pop	{r7, pc}
 423              		.cfi_endproc
 424              	.LFE112:
 426 0122 00BF     		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 427              		.align	2
 428              		.global	xQueueGenericSendFromISR
 429              		.thumb
 430              		.thumb_func
 432              	xQueueGenericSendFromISR:
 433              	.LFB113:
 581:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 582:../FreeRTOS/Source/queue.c **** 
 583:../FreeRTOS/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 584:../FreeRTOS/Source/queue.c **** 
 585:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 586:../FreeRTOS/Source/queue.c **** 	{
 587:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 588:../FreeRTOS/Source/queue.c **** 	xTimeOutType xTimeOut;
 589:../FreeRTOS/Source/queue.c **** 
 590:../FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 591:../FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 592:../FreeRTOS/Source/queue.c **** 
 593:../FreeRTOS/Source/queue.c **** 		for( ;; )
 594:../FreeRTOS/Source/queue.c **** 		{
 595:../FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 596:../FreeRTOS/Source/queue.c **** 			{
 597:../FreeRTOS/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 598:../FreeRTOS/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 599:../FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 600:../FreeRTOS/Source/queue.c **** 				{
 601:../FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 602:../FreeRTOS/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 603:../FreeRTOS/Source/queue.c **** 
 604:../FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 605:../FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 606:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 607:../FreeRTOS/Source/queue.c **** 					{
 608:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 609:../FreeRTOS/Source/queue.c **** 						{
 610:../FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 611:../FreeRTOS/Source/queue.c **** 							our own so yield immediately. */
 612:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 613:../FreeRTOS/Source/queue.c **** 						}
 614:../FreeRTOS/Source/queue.c **** 					}
 615:../FreeRTOS/Source/queue.c **** 
 616:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 617:../FreeRTOS/Source/queue.c **** 					return pdPASS;
 618:../FreeRTOS/Source/queue.c **** 				}
 619:../FreeRTOS/Source/queue.c **** 				else
 620:../FreeRTOS/Source/queue.c **** 				{
 621:../FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 622:../FreeRTOS/Source/queue.c **** 					{
 623:../FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 624:../FreeRTOS/Source/queue.c **** 						return errQUEUE_FULL;
 625:../FreeRTOS/Source/queue.c **** 					}
 626:../FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 627:../FreeRTOS/Source/queue.c **** 					{
 628:../FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 629:../FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 630:../FreeRTOS/Source/queue.c **** 					}
 631:../FreeRTOS/Source/queue.c **** 				}
 632:../FreeRTOS/Source/queue.c **** 			}
 633:../FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 634:../FreeRTOS/Source/queue.c **** 
 635:../FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 636:../FreeRTOS/Source/queue.c **** 			{
 637:../FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 638:../FreeRTOS/Source/queue.c **** 				{
 639:../FreeRTOS/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 640:../FreeRTOS/Source/queue.c **** 					{
 641:../FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 642:../FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 643:../FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 644:../FreeRTOS/Source/queue.c **** 					}
 645:../FreeRTOS/Source/queue.c **** 				}
 646:../FreeRTOS/Source/queue.c **** 				else
 647:../FreeRTOS/Source/queue.c **** 				{
 648:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 649:../FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 650:../FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 651:../FreeRTOS/Source/queue.c **** 				}
 652:../FreeRTOS/Source/queue.c **** 			}
 653:../FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 654:../FreeRTOS/Source/queue.c **** 		}
 655:../FreeRTOS/Source/queue.c **** 	}
 656:../FreeRTOS/Source/queue.c **** 
 657:../FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 658:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 659:../FreeRTOS/Source/queue.c **** 
 660:../FreeRTOS/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 661:../FreeRTOS/Source/queue.c **** 
 662:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 663:../FreeRTOS/Source/queue.c **** 	{
 664:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 665:../FreeRTOS/Source/queue.c **** 	xTimeOutType xTimeOut;
 666:../FreeRTOS/Source/queue.c **** 	signed char *pcOriginalReadPosition;
 667:../FreeRTOS/Source/queue.c **** 
 668:../FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 669:../FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 670:../FreeRTOS/Source/queue.c **** 
 671:../FreeRTOS/Source/queue.c **** 		for( ;; )
 672:../FreeRTOS/Source/queue.c **** 		{
 673:../FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 674:../FreeRTOS/Source/queue.c **** 			{
 675:../FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 676:../FreeRTOS/Source/queue.c **** 				{
 677:../FreeRTOS/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 678:../FreeRTOS/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 679:../FreeRTOS/Source/queue.c **** 
 680:../FreeRTOS/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 681:../FreeRTOS/Source/queue.c **** 
 682:../FreeRTOS/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 683:../FreeRTOS/Source/queue.c **** 					{
 684:../FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 685:../FreeRTOS/Source/queue.c **** 
 686:../FreeRTOS/Source/queue.c **** 						/* We are actually removing data. */
 687:../FreeRTOS/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 688:../FreeRTOS/Source/queue.c **** 
 689:../FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 690:../FreeRTOS/Source/queue.c **** 						{
 691:../FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 692:../FreeRTOS/Source/queue.c **** 							{
 693:../FreeRTOS/Source/queue.c **** 								/* Record the information required to implement
 694:../FreeRTOS/Source/queue.c **** 								priority inheritance should it become necessary. */
 695:../FreeRTOS/Source/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 696:../FreeRTOS/Source/queue.c **** 							}
 697:../FreeRTOS/Source/queue.c **** 						}
 698:../FreeRTOS/Source/queue.c **** 						#endif
 699:../FreeRTOS/Source/queue.c **** 
 700:../FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 701:../FreeRTOS/Source/queue.c **** 						{
 702:../FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 703:../FreeRTOS/Source/queue.c **** 							{
 704:../FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 705:../FreeRTOS/Source/queue.c **** 							}
 706:../FreeRTOS/Source/queue.c **** 						}
 707:../FreeRTOS/Source/queue.c **** 					}
 708:../FreeRTOS/Source/queue.c **** 					else
 709:../FreeRTOS/Source/queue.c **** 					{
 710:../FreeRTOS/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 711:../FreeRTOS/Source/queue.c **** 
 712:../FreeRTOS/Source/queue.c **** 						/* We are not removing the data, so reset our read
 713:../FreeRTOS/Source/queue.c **** 						pointer. */
 714:../FreeRTOS/Source/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 715:../FreeRTOS/Source/queue.c **** 
 716:../FreeRTOS/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 717:../FreeRTOS/Source/queue.c **** 						any other tasks waiting for the data. */
 718:../FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 719:../FreeRTOS/Source/queue.c **** 						{
 720:../FreeRTOS/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 721:../FreeRTOS/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 722:../FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 723:../FreeRTOS/Source/queue.c **** 							{
 724:../FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 725:../FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 726:../FreeRTOS/Source/queue.c **** 							}
 727:../FreeRTOS/Source/queue.c **** 						}
 728:../FreeRTOS/Source/queue.c **** 
 729:../FreeRTOS/Source/queue.c **** 					}
 730:../FreeRTOS/Source/queue.c **** 
 731:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 732:../FreeRTOS/Source/queue.c **** 					return pdPASS;
 733:../FreeRTOS/Source/queue.c **** 				}
 734:../FreeRTOS/Source/queue.c **** 				else
 735:../FreeRTOS/Source/queue.c **** 				{
 736:../FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 737:../FreeRTOS/Source/queue.c **** 					{
 738:../FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 739:../FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 740:../FreeRTOS/Source/queue.c **** 						return errQUEUE_EMPTY;
 741:../FreeRTOS/Source/queue.c **** 					}
 742:../FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 743:../FreeRTOS/Source/queue.c **** 					{
 744:../FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 745:../FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 746:../FreeRTOS/Source/queue.c **** 					}
 747:../FreeRTOS/Source/queue.c **** 				}
 748:../FreeRTOS/Source/queue.c **** 			}
 749:../FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 750:../FreeRTOS/Source/queue.c **** 
 751:../FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 752:../FreeRTOS/Source/queue.c **** 			{
 753:../FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 754:../FreeRTOS/Source/queue.c **** 				{
 755:../FreeRTOS/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 756:../FreeRTOS/Source/queue.c **** 					{
 757:../FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 758:../FreeRTOS/Source/queue.c **** 
 759:../FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 760:../FreeRTOS/Source/queue.c **** 						{
 761:../FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 762:../FreeRTOS/Source/queue.c **** 							{
 763:../FreeRTOS/Source/queue.c **** 								portENTER_CRITICAL();
 764:../FreeRTOS/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 765:../FreeRTOS/Source/queue.c **** 								portEXIT_CRITICAL();
 766:../FreeRTOS/Source/queue.c **** 							}
 767:../FreeRTOS/Source/queue.c **** 						}
 768:../FreeRTOS/Source/queue.c **** 						#endif
 769:../FreeRTOS/Source/queue.c **** 
 770:../FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 771:../FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 772:../FreeRTOS/Source/queue.c **** 					}
 773:../FreeRTOS/Source/queue.c **** 				}
 774:../FreeRTOS/Source/queue.c **** 				else
 775:../FreeRTOS/Source/queue.c **** 				{
 776:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 777:../FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 778:../FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 779:../FreeRTOS/Source/queue.c **** 				}
 780:../FreeRTOS/Source/queue.c **** 			}
 781:../FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 782:../FreeRTOS/Source/queue.c **** 		}
 783:../FreeRTOS/Source/queue.c **** 	}
 784:../FreeRTOS/Source/queue.c **** 
 785:../FreeRTOS/Source/queue.c **** 
 786:../FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 787:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 788:../FreeRTOS/Source/queue.c **** 
 789:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 790:../FreeRTOS/Source/queue.c **** {
 434              		.loc 1 790 0
 435              		.cfi_startproc
 436              		@ args = 0, pretend = 0, frame = 24
 437              		@ frame_needed = 1, uses_anonymous_args = 0
 438 0000 80B5     		push	{r7, lr}
 439              	.LCFI9:
 440              		.cfi_def_cfa_offset 8
 441              		.cfi_offset 14, -4
 442              		.cfi_offset 7, -8
 443 0002 86B0     		sub	sp, sp, #24
 444              	.LCFI10:
 445              		.cfi_def_cfa_offset 32
 446 0004 00AF     		add	r7, sp, #0
 447              	.LCFI11:
 448              		.cfi_def_cfa_register 7
 449 0006 F860     		str	r0, [r7, #12]
 450 0008 B960     		str	r1, [r7, #8]
 451 000a 7A60     		str	r2, [r7, #4]
 452 000c 3B60     		str	r3, [r7, #0]
 791:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
 792:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 793:../FreeRTOS/Source/queue.c **** 
 794:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 795:../FreeRTOS/Source/queue.c **** 	configASSERT( pxHigherPriorityTaskWoken );
 796:../FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 797:../FreeRTOS/Source/queue.c **** 
 798:../FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 799:../FreeRTOS/Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 800:../FreeRTOS/Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 801:../FreeRTOS/Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 802:../FreeRTOS/Source/queue.c **** 	by this	post). */
 803:../FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 453              		.loc 1 803 0
 454 000e 4FF00003 		mov	r3, #0
 455 0012 3B61     		str	r3, [r7, #16]
 456              	@ 803 "../FreeRTOS/Source/queue.c" 1
 457 0014 4FF0BF00 			mov r0, #191								
 458 0018 80F31188 		msr basepri, r0							
 459              	
 460              	@ 0 "" 2
 804:../FreeRTOS/Source/queue.c **** 	{
 805:../FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 461              		.loc 1 805 0
 462              		.thumb
 463 001c FB68     		ldr	r3, [r7, #12]
 464 001e 9B6B     		ldr	r3, [r3, #56]
 465 0020 1A46     		mov	r2, r3
 466 0022 FB68     		ldr	r3, [r7, #12]
 467 0024 DB6B     		ldr	r3, [r3, #60]
 468 0026 9A42     		cmp	r2, r3
 469 0028 25D2     		bcs	.L20
 806:../FreeRTOS/Source/queue.c **** 		{
 807:../FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 808:../FreeRTOS/Source/queue.c **** 
 809:../FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 470              		.loc 1 809 0
 471 002a F868     		ldr	r0, [r7, #12]
 472 002c B968     		ldr	r1, [r7, #8]
 473 002e 3A68     		ldr	r2, [r7, #0]
 474 0030 FFF7FEFF 		bl	prvCopyDataToQueue
 810:../FreeRTOS/Source/queue.c **** 
 811:../FreeRTOS/Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 812:../FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
 813:../FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 475              		.loc 1 813 0
 476 0034 FB68     		ldr	r3, [r7, #12]
 477 0036 9B6C     		ldr	r3, [r3, #72]
 478 0038 B3F1FF3F 		cmp	r3, #-1
 479 003c 11D1     		bne	.L21
 814:../FreeRTOS/Source/queue.c **** 			{
 815:../FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 480              		.loc 1 815 0
 481 003e FB68     		ldr	r3, [r7, #12]
 482 0040 5B6A     		ldr	r3, [r3, #36]
 483 0042 002B     		cmp	r3, #0
 484 0044 13D0     		beq	.L22
 816:../FreeRTOS/Source/queue.c **** 				{
 817:../FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 485              		.loc 1 817 0
 486 0046 FB68     		ldr	r3, [r7, #12]
 487 0048 03F12403 		add	r3, r3, #36
 488 004c 1846     		mov	r0, r3
 489 004e FFF7FEFF 		bl	xTaskRemoveFromEventList
 490 0052 0346     		mov	r3, r0
 491 0054 002B     		cmp	r3, #0
 492 0056 0AD0     		beq	.L22
 818:../FreeRTOS/Source/queue.c **** 					{
 819:../FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
 820:../FreeRTOS/Source/queue.c **** 						context	switch is required. */
 821:../FreeRTOS/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 493              		.loc 1 821 0
 494 0058 7B68     		ldr	r3, [r7, #4]
 495 005a 4FF00102 		mov	r2, #1
 496 005e 1A60     		str	r2, [r3, #0]
 497 0060 05E0     		b	.L22
 498              	.L21:
 822:../FreeRTOS/Source/queue.c **** 					}
 823:../FreeRTOS/Source/queue.c **** 				}
 824:../FreeRTOS/Source/queue.c **** 			}
 825:../FreeRTOS/Source/queue.c **** 			else
 826:../FreeRTOS/Source/queue.c **** 			{
 827:../FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 828:../FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
 829:../FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
 499              		.loc 1 829 0
 500 0062 FB68     		ldr	r3, [r7, #12]
 501 0064 9B6C     		ldr	r3, [r3, #72]
 502 0066 03F10102 		add	r2, r3, #1
 503 006a FB68     		ldr	r3, [r7, #12]
 504 006c 9A64     		str	r2, [r3, #72]
 505              	.L22:
 830:../FreeRTOS/Source/queue.c **** 			}
 831:../FreeRTOS/Source/queue.c **** 
 832:../FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 506              		.loc 1 832 0
 507 006e 4FF00103 		mov	r3, #1
 508 0072 7B61     		str	r3, [r7, #20]
 509 0074 02E0     		b	.L23
 510              	.L20:
 833:../FreeRTOS/Source/queue.c **** 		}
 834:../FreeRTOS/Source/queue.c **** 		else
 835:../FreeRTOS/Source/queue.c **** 		{
 836:../FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 837:../FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 511              		.loc 1 837 0
 512 0076 4FF00003 		mov	r3, #0
 513 007a 7B61     		str	r3, [r7, #20]
 514              	.L23:
 838:../FreeRTOS/Source/queue.c **** 		}
 839:../FreeRTOS/Source/queue.c **** 	}
 840:../FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 515              		.loc 1 840 0
 516              	@ 840 "../FreeRTOS/Source/queue.c" 1
 517 007c 4FF00000 			mov r0, #0					
 518 0080 80F31188 		msr basepri, r0				
 519              	
 520              	@ 0 "" 2
 841:../FreeRTOS/Source/queue.c **** 
 842:../FreeRTOS/Source/queue.c **** 	return xReturn;
 521              		.loc 1 842 0
 522              		.thumb
 523 0084 7B69     		ldr	r3, [r7, #20]
 843:../FreeRTOS/Source/queue.c **** }
 524              		.loc 1 843 0
 525 0086 1846     		mov	r0, r3
 526 0088 07F11807 		add	r7, r7, #24
 527 008c BD46     		mov	sp, r7
 528 008e 80BD     		pop	{r7, pc}
 529              		.cfi_endproc
 530              	.LFE113:
 532              		.section	.text.xQueueGenericReceive,"ax",%progbits
 533              		.align	2
 534              		.global	xQueueGenericReceive
 535              		.thumb
 536              		.thumb_func
 538              	xQueueGenericReceive:
 539              	.LFB114:
 844:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 845:../FreeRTOS/Source/queue.c **** 
 846:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 847:../FreeRTOS/Source/queue.c **** {
 540              		.loc 1 847 0
 541              		.cfi_startproc
 542              		@ args = 0, pretend = 0, frame = 32
 543              		@ frame_needed = 1, uses_anonymous_args = 0
 544 0000 80B5     		push	{r7, lr}
 545              	.LCFI12:
 546              		.cfi_def_cfa_offset 8
 547              		.cfi_offset 14, -4
 548              		.cfi_offset 7, -8
 549 0002 88B0     		sub	sp, sp, #32
 550              	.LCFI13:
 551              		.cfi_def_cfa_offset 40
 552 0004 00AF     		add	r7, sp, #0
 553              	.LCFI14:
 554              		.cfi_def_cfa_register 7
 555 0006 F860     		str	r0, [r7, #12]
 556 0008 B960     		str	r1, [r7, #8]
 557 000a 7A60     		str	r2, [r7, #4]
 558 000c 3B60     		str	r3, [r7, #0]
 848:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 559              		.loc 1 848 0
 560 000e 4FF00003 		mov	r3, #0
 561 0012 FB61     		str	r3, [r7, #28]
 562 0014 00E0     		b	.L38
 563              	.L39:
 849:../FreeRTOS/Source/queue.c **** xTimeOutType xTimeOut;
 850:../FreeRTOS/Source/queue.c **** signed char *pcOriginalReadPosition;
 851:../FreeRTOS/Source/queue.c **** 
 852:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 853:../FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 854:../FreeRTOS/Source/queue.c **** 
 855:../FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 856:../FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 857:../FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 858:../FreeRTOS/Source/queue.c **** 
 859:../FreeRTOS/Source/queue.c **** 	for( ;; )
 860:../FreeRTOS/Source/queue.c **** 	{
 861:../FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 862:../FreeRTOS/Source/queue.c **** 		{
 863:../FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 864:../FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 865:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 866:../FreeRTOS/Source/queue.c **** 			{
 867:../FreeRTOS/Source/queue.c **** 				/* Remember our read position in case we are just peeking. */
 868:../FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 869:../FreeRTOS/Source/queue.c **** 
 870:../FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 871:../FreeRTOS/Source/queue.c **** 
 872:../FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 873:../FreeRTOS/Source/queue.c **** 				{
 874:../FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 875:../FreeRTOS/Source/queue.c **** 
 876:../FreeRTOS/Source/queue.c **** 					/* We are actually removing data. */
 877:../FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 878:../FreeRTOS/Source/queue.c **** 
 879:../FreeRTOS/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 880:../FreeRTOS/Source/queue.c **** 					{
 881:../FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 882:../FreeRTOS/Source/queue.c **** 						{
 883:../FreeRTOS/Source/queue.c **** 							/* Record the information required to implement
 884:../FreeRTOS/Source/queue.c **** 							priority inheritance should it become necessary. */
 885:../FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 886:../FreeRTOS/Source/queue.c **** 						}
 887:../FreeRTOS/Source/queue.c **** 					}
 888:../FreeRTOS/Source/queue.c **** 					#endif
 889:../FreeRTOS/Source/queue.c **** 
 890:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 891:../FreeRTOS/Source/queue.c **** 					{
 892:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 893:../FreeRTOS/Source/queue.c **** 						{
 894:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 895:../FreeRTOS/Source/queue.c **** 						}
 896:../FreeRTOS/Source/queue.c **** 					}
 897:../FreeRTOS/Source/queue.c **** 				}
 898:../FreeRTOS/Source/queue.c **** 				else
 899:../FreeRTOS/Source/queue.c **** 				{
 900:../FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 901:../FreeRTOS/Source/queue.c **** 
 902:../FreeRTOS/Source/queue.c **** 					/* We are not removing the data, so reset our read
 903:../FreeRTOS/Source/queue.c **** 					pointer. */
 904:../FreeRTOS/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 905:../FreeRTOS/Source/queue.c **** 
 906:../FreeRTOS/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
 907:../FreeRTOS/Source/queue.c **** 					any other tasks waiting for the data. */
 908:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 909:../FreeRTOS/Source/queue.c **** 					{
 910:../FreeRTOS/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
 911:../FreeRTOS/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 912:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 913:../FreeRTOS/Source/queue.c **** 						{
 914:../FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
 915:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 916:../FreeRTOS/Source/queue.c **** 						}
 917:../FreeRTOS/Source/queue.c **** 					}
 918:../FreeRTOS/Source/queue.c **** 
 919:../FreeRTOS/Source/queue.c **** 				}
 920:../FreeRTOS/Source/queue.c **** 
 921:../FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 922:../FreeRTOS/Source/queue.c **** 				return pdPASS;
 923:../FreeRTOS/Source/queue.c **** 			}
 924:../FreeRTOS/Source/queue.c **** 			else
 925:../FreeRTOS/Source/queue.c **** 			{
 926:../FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 927:../FreeRTOS/Source/queue.c **** 				{
 928:../FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
 929:../FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 930:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 931:../FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 932:../FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 933:../FreeRTOS/Source/queue.c **** 				}
 934:../FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 935:../FreeRTOS/Source/queue.c **** 				{
 936:../FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
 937:../FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 938:../FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 939:../FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 940:../FreeRTOS/Source/queue.c **** 				}
 941:../FreeRTOS/Source/queue.c **** 			}
 942:../FreeRTOS/Source/queue.c **** 		}
 943:../FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 944:../FreeRTOS/Source/queue.c **** 
 945:../FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 946:../FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 947:../FreeRTOS/Source/queue.c **** 
 948:../FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 950:../FreeRTOS/Source/queue.c **** 
 951:../FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 952:../FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 953:../FreeRTOS/Source/queue.c **** 		{
 954:../FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 955:../FreeRTOS/Source/queue.c **** 			{
 956:../FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 957:../FreeRTOS/Source/queue.c **** 
 958:../FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 959:../FreeRTOS/Source/queue.c **** 				{
 960:../FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 961:../FreeRTOS/Source/queue.c **** 					{
 962:../FreeRTOS/Source/queue.c **** 						portENTER_CRITICAL();
 963:../FreeRTOS/Source/queue.c **** 						{
 964:../FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 965:../FreeRTOS/Source/queue.c **** 						}
 966:../FreeRTOS/Source/queue.c **** 						portEXIT_CRITICAL();
 967:../FreeRTOS/Source/queue.c **** 					}
 968:../FreeRTOS/Source/queue.c **** 				}
 969:../FreeRTOS/Source/queue.c **** 				#endif
 970:../FreeRTOS/Source/queue.c **** 
 971:../FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 972:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 973:../FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 974:../FreeRTOS/Source/queue.c **** 				{
 975:../FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 976:../FreeRTOS/Source/queue.c **** 				}
 977:../FreeRTOS/Source/queue.c **** 			}
 978:../FreeRTOS/Source/queue.c **** 			else
 979:../FreeRTOS/Source/queue.c **** 			{
 980:../FreeRTOS/Source/queue.c **** 				/* Try again. */
 981:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 982:../FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 983:../FreeRTOS/Source/queue.c **** 			}
 984:../FreeRTOS/Source/queue.c **** 		}
 985:../FreeRTOS/Source/queue.c **** 		else
 986:../FreeRTOS/Source/queue.c **** 		{
 987:../FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 988:../FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 989:../FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
 990:../FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
 991:../FreeRTOS/Source/queue.c **** 		}
 992:../FreeRTOS/Source/queue.c **** 	}
 564              		.loc 1 992 0
 565 0016 00BF     		nop
 566              	.L38:
 861:../FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 567              		.loc 1 861 0
 568 0018 FFF7FEFF 		bl	vPortEnterCritical
 865:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 569              		.loc 1 865 0
 570 001c FB68     		ldr	r3, [r7, #12]
 571 001e 9B6B     		ldr	r3, [r3, #56]
 572 0020 002B     		cmp	r3, #0
 573 0022 3FD0     		beq	.L25
 868:../FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 574              		.loc 1 868 0
 575 0024 FB68     		ldr	r3, [r7, #12]
 576 0026 DB68     		ldr	r3, [r3, #12]
 577 0028 BB61     		str	r3, [r7, #24]
 870:../FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 578              		.loc 1 870 0
 579 002a F868     		ldr	r0, [r7, #12]
 580 002c B968     		ldr	r1, [r7, #8]
 581 002e FFF7FEFF 		bl	prvCopyDataFromQueue
 872:../FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 582              		.loc 1 872 0
 583 0032 3B68     		ldr	r3, [r7, #0]
 584 0034 002B     		cmp	r3, #0
 585 0036 1ED1     		bne	.L26
 877:../FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 586              		.loc 1 877 0
 587 0038 FB68     		ldr	r3, [r7, #12]
 588 003a 9B6B     		ldr	r3, [r3, #56]
 589 003c 03F1FF32 		add	r2, r3, #-1
 590 0040 FB68     		ldr	r3, [r7, #12]
 591 0042 9A63     		str	r2, [r3, #56]
 881:../FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 592              		.loc 1 881 0
 593 0044 FB68     		ldr	r3, [r7, #12]
 594 0046 1B68     		ldr	r3, [r3, #0]
 595 0048 002B     		cmp	r3, #0
 596 004a 04D1     		bne	.L27
 885:../FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 597              		.loc 1 885 0
 598 004c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 599 0050 0246     		mov	r2, r0
 600 0052 FB68     		ldr	r3, [r7, #12]
 601 0054 5A60     		str	r2, [r3, #4]
 602              	.L27:
 890:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 603              		.loc 1 890 0
 604 0056 FB68     		ldr	r3, [r7, #12]
 605 0058 1B69     		ldr	r3, [r3, #16]
 606 005a 002B     		cmp	r3, #0
 607 005c 1DD0     		beq	.L28
 892:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 608              		.loc 1 892 0
 609 005e FB68     		ldr	r3, [r7, #12]
 610 0060 03F11003 		add	r3, r3, #16
 611 0064 1846     		mov	r0, r3
 612 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 613 006a 0346     		mov	r3, r0
 614 006c 012B     		cmp	r3, #1
 615 006e 14D1     		bne	.L28
 894:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 616              		.loc 1 894 0
 617 0070 FFF7FEFF 		bl	vPortYieldFromISR
 618 0074 11E0     		b	.L28
 619              	.L26:
 904:../FreeRTOS/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 620              		.loc 1 904 0
 621 0076 FB68     		ldr	r3, [r7, #12]
 622 0078 BA69     		ldr	r2, [r7, #24]
 623 007a DA60     		str	r2, [r3, #12]
 908:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 624              		.loc 1 908 0
 625 007c FB68     		ldr	r3, [r7, #12]
 626 007e 5B6A     		ldr	r3, [r3, #36]
 627 0080 002B     		cmp	r3, #0
 628 0082 0AD0     		beq	.L28
 912:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 629              		.loc 1 912 0
 630 0084 FB68     		ldr	r3, [r7, #12]
 631 0086 03F12403 		add	r3, r3, #36
 632 008a 1846     		mov	r0, r3
 633 008c FFF7FEFF 		bl	xTaskRemoveFromEventList
 634 0090 0346     		mov	r3, r0
 635 0092 002B     		cmp	r3, #0
 636 0094 01D0     		beq	.L28
 915:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 637              		.loc 1 915 0
 638 0096 FFF7FEFF 		bl	vPortYieldFromISR
 639              	.L28:
 921:../FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 640              		.loc 1 921 0
 641 009a FFF7FEFF 		bl	vPortExitCritical
 922:../FreeRTOS/Source/queue.c **** 				return pdPASS;
 642              		.loc 1 922 0
 643 009e 4FF00103 		mov	r3, #1
 644 00a2 6BE0     		b	.L29
 645              	.L25:
 926:../FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 646              		.loc 1 926 0
 647 00a4 7B68     		ldr	r3, [r7, #4]
 648 00a6 002B     		cmp	r3, #0
 649 00a8 04D1     		bne	.L30
 930:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 650              		.loc 1 930 0
 651 00aa FFF7FEFF 		bl	vPortExitCritical
 932:../FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 652              		.loc 1 932 0
 653 00ae 4FF00003 		mov	r3, #0
 654 00b2 63E0     		b	.L29
 655              	.L30:
 934:../FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 656              		.loc 1 934 0
 657 00b4 FB69     		ldr	r3, [r7, #28]
 658 00b6 002B     		cmp	r3, #0
 659 00b8 07D1     		bne	.L31
 938:../FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 660              		.loc 1 938 0
 661 00ba 07F11003 		add	r3, r7, #16
 662 00be 1846     		mov	r0, r3
 663 00c0 FFF7FEFF 		bl	vTaskSetTimeOutState
 939:../FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 664              		.loc 1 939 0
 665 00c4 4FF00103 		mov	r3, #1
 666 00c8 FB61     		str	r3, [r7, #28]
 667              	.L31:
 943:../FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 668              		.loc 1 943 0
 669 00ca FFF7FEFF 		bl	vPortExitCritical
 948:../FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 670              		.loc 1 948 0
 671 00ce FFF7FEFF 		bl	vTaskSuspendAll
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 672              		.loc 1 949 0
 673 00d2 FFF7FEFF 		bl	vPortEnterCritical
 674 00d6 FB68     		ldr	r3, [r7, #12]
 675 00d8 5B6C     		ldr	r3, [r3, #68]
 676 00da B3F1FF3F 		cmp	r3, #-1
 677 00de 03D1     		bne	.L32
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 678              		.loc 1 949 0 is_stmt 0 discriminator 1
 679 00e0 FB68     		ldr	r3, [r7, #12]
 680 00e2 4FF00002 		mov	r2, #0
 681 00e6 5A64     		str	r2, [r3, #68]
 682              	.L32:
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 683              		.loc 1 949 0 discriminator 2
 684 00e8 FB68     		ldr	r3, [r7, #12]
 685 00ea 9B6C     		ldr	r3, [r3, #72]
 686 00ec B3F1FF3F 		cmp	r3, #-1
 687 00f0 03D1     		bne	.L33
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 688              		.loc 1 949 0 discriminator 3
 689 00f2 FB68     		ldr	r3, [r7, #12]
 690 00f4 4FF00002 		mov	r2, #0
 691 00f8 9A64     		str	r2, [r3, #72]
 692              	.L33:
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 693              		.loc 1 949 0 discriminator 4
 694 00fa FFF7FEFF 		bl	vPortExitCritical
 952:../FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 695              		.loc 1 952 0 is_stmt 1 discriminator 4
 696 00fe 07F11002 		add	r2, r7, #16
 697 0102 07F10403 		add	r3, r7, #4
 698 0106 1046     		mov	r0, r2
 699 0108 1946     		mov	r1, r3
 700 010a FFF7FEFF 		bl	xTaskCheckForTimeOut
 701 010e 0346     		mov	r3, r0
 702 0110 002B     		cmp	r3, #0
 703 0112 2CD1     		bne	.L34
 954:../FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 704              		.loc 1 954 0
 705 0114 F868     		ldr	r0, [r7, #12]
 706 0116 FFF7FEFF 		bl	prvIsQueueEmpty
 707 011a 0346     		mov	r3, r0
 708 011c 002B     		cmp	r3, #0
 709 011e 20D0     		beq	.L35
 960:../FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 710              		.loc 1 960 0
 711 0120 FB68     		ldr	r3, [r7, #12]
 712 0122 1B68     		ldr	r3, [r3, #0]
 713 0124 002B     		cmp	r3, #0
 714 0126 08D1     		bne	.L36
 962:../FreeRTOS/Source/queue.c **** 						portENTER_CRITICAL();
 715              		.loc 1 962 0
 716 0128 FFF7FEFF 		bl	vPortEnterCritical
 964:../FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 717              		.loc 1 964 0
 718 012c FB68     		ldr	r3, [r7, #12]
 719 012e 5B68     		ldr	r3, [r3, #4]
 720 0130 1846     		mov	r0, r3
 721 0132 FFF7FEFF 		bl	vTaskPriorityInherit
 966:../FreeRTOS/Source/queue.c **** 						portEXIT_CRITICAL();
 722              		.loc 1 966 0
 723 0136 FFF7FEFF 		bl	vPortExitCritical
 724              	.L36:
 971:../FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 725              		.loc 1 971 0
 726 013a FB68     		ldr	r3, [r7, #12]
 727 013c 03F12402 		add	r2, r3, #36
 728 0140 7B68     		ldr	r3, [r7, #4]
 729 0142 1046     		mov	r0, r2
 730 0144 1946     		mov	r1, r3
 731 0146 FFF7FEFF 		bl	vTaskPlaceOnEventList
 972:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 732              		.loc 1 972 0
 733 014a F868     		ldr	r0, [r7, #12]
 734 014c FFF7FEFF 		bl	prvUnlockQueue
 973:../FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 735              		.loc 1 973 0
 736 0150 FFF7FEFF 		bl	xTaskResumeAll
 737 0154 0346     		mov	r3, r0
 738 0156 002B     		cmp	r3, #0
 739 0158 7FF45DAF 		bne	.L39
 975:../FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 740              		.loc 1 975 0
 741 015c FFF7FEFF 		bl	vPortYieldFromISR
 742              		.loc 1 992 0
 743 0160 59E7     		b	.L39
 744              	.L35:
 981:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 745              		.loc 1 981 0
 746 0162 F868     		ldr	r0, [r7, #12]
 747 0164 FFF7FEFF 		bl	prvUnlockQueue
 982:../FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 748              		.loc 1 982 0
 749 0168 FFF7FEFF 		bl	xTaskResumeAll
 750              		.loc 1 992 0
 751 016c 53E7     		b	.L39
 752              	.L34:
 987:../FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 753              		.loc 1 987 0
 754 016e F868     		ldr	r0, [r7, #12]
 755 0170 FFF7FEFF 		bl	prvUnlockQueue
 988:../FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 756              		.loc 1 988 0
 757 0174 FFF7FEFF 		bl	xTaskResumeAll
 990:../FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
 758              		.loc 1 990 0
 759 0178 4FF00003 		mov	r3, #0
 760              	.L29:
 993:../FreeRTOS/Source/queue.c **** }
 761              		.loc 1 993 0
 762 017c 1846     		mov	r0, r3
 763 017e 07F12007 		add	r7, r7, #32
 764 0182 BD46     		mov	sp, r7
 765 0184 80BD     		pop	{r7, pc}
 766              		.cfi_endproc
 767              	.LFE114:
 769 0186 00BF     		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 770              		.align	2
 771              		.global	xQueueReceiveFromISR
 772              		.thumb
 773              		.thumb_func
 775              	xQueueReceiveFromISR:
 776              	.LFB115:
 994:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 995:../FreeRTOS/Source/queue.c **** 
 996:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 997:../FreeRTOS/Source/queue.c **** {
 777              		.loc 1 997 0
 778              		.cfi_startproc
 779              		@ args = 0, pretend = 0, frame = 24
 780              		@ frame_needed = 1, uses_anonymous_args = 0
 781 0000 80B5     		push	{r7, lr}
 782              	.LCFI15:
 783              		.cfi_def_cfa_offset 8
 784              		.cfi_offset 14, -4
 785              		.cfi_offset 7, -8
 786 0002 86B0     		sub	sp, sp, #24
 787              	.LCFI16:
 788              		.cfi_def_cfa_offset 32
 789 0004 00AF     		add	r7, sp, #0
 790              	.LCFI17:
 791              		.cfi_def_cfa_register 7
 792 0006 F860     		str	r0, [r7, #12]
 793 0008 B960     		str	r1, [r7, #8]
 794 000a 7A60     		str	r2, [r7, #4]
 998:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
 999:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1000:../FreeRTOS/Source/queue.c **** 
1001:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1002:../FreeRTOS/Source/queue.c **** 	configASSERT( pxTaskWoken );
1003:../FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1004:../FreeRTOS/Source/queue.c **** 
1005:../FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 795              		.loc 1 1005 0
 796 000c 4FF00003 		mov	r3, #0
 797 0010 3B61     		str	r3, [r7, #16]
 798              	@ 1005 "../FreeRTOS/Source/queue.c" 1
 799 0012 4FF0BF00 			mov r0, #191								
 800 0016 80F31188 		msr basepri, r0							
 801              	
 802              	@ 0 "" 2
1006:../FreeRTOS/Source/queue.c **** 	{
1007:../FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1008:../FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 803              		.loc 1 1008 0
 804              		.thumb
 805 001a FB68     		ldr	r3, [r7, #12]
 806 001c 9B6B     		ldr	r3, [r3, #56]
 807 001e 002B     		cmp	r3, #0
 808 0020 2AD0     		beq	.L41
1009:../FreeRTOS/Source/queue.c **** 		{
1010:../FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1011:../FreeRTOS/Source/queue.c **** 
1012:../FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 809              		.loc 1 1012 0
 810 0022 F868     		ldr	r0, [r7, #12]
 811 0024 B968     		ldr	r1, [r7, #8]
 812 0026 FFF7FEFF 		bl	prvCopyDataFromQueue
1013:../FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 813              		.loc 1 1013 0
 814 002a FB68     		ldr	r3, [r7, #12]
 815 002c 9B6B     		ldr	r3, [r3, #56]
 816 002e 03F1FF32 		add	r2, r3, #-1
 817 0032 FB68     		ldr	r3, [r7, #12]
 818 0034 9A63     		str	r2, [r3, #56]
1014:../FreeRTOS/Source/queue.c **** 
1015:../FreeRTOS/Source/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1016:../FreeRTOS/Source/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1017:../FreeRTOS/Source/queue.c **** 			that an ISR has removed data while the queue was locked. */
1018:../FreeRTOS/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 819              		.loc 1 1018 0
 820 0036 FB68     		ldr	r3, [r7, #12]
 821 0038 5B6C     		ldr	r3, [r3, #68]
 822 003a B3F1FF3F 		cmp	r3, #-1
 823 003e 11D1     		bne	.L42
1019:../FreeRTOS/Source/queue.c **** 			{
1020:../FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 824              		.loc 1 1020 0
 825 0040 FB68     		ldr	r3, [r7, #12]
 826 0042 1B69     		ldr	r3, [r3, #16]
 827 0044 002B     		cmp	r3, #0
 828 0046 13D0     		beq	.L43
1021:../FreeRTOS/Source/queue.c **** 				{
1022:../FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 829              		.loc 1 1022 0
 830 0048 FB68     		ldr	r3, [r7, #12]
 831 004a 03F11003 		add	r3, r3, #16
 832 004e 1846     		mov	r0, r3
 833 0050 FFF7FEFF 		bl	xTaskRemoveFromEventList
 834 0054 0346     		mov	r3, r0
 835 0056 002B     		cmp	r3, #0
 836 0058 0AD0     		beq	.L43
1023:../FreeRTOS/Source/queue.c **** 					{
1024:../FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1025:../FreeRTOS/Source/queue.c **** 						force a context switch. */
1026:../FreeRTOS/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
 837              		.loc 1 1026 0
 838 005a 7B68     		ldr	r3, [r7, #4]
 839 005c 4FF00102 		mov	r2, #1
 840 0060 1A60     		str	r2, [r3, #0]
 841 0062 05E0     		b	.L43
 842              	.L42:
1027:../FreeRTOS/Source/queue.c **** 					}
1028:../FreeRTOS/Source/queue.c **** 				}
1029:../FreeRTOS/Source/queue.c **** 			}
1030:../FreeRTOS/Source/queue.c **** 			else
1031:../FreeRTOS/Source/queue.c **** 			{
1032:../FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1033:../FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1034:../FreeRTOS/Source/queue.c **** 				++( pxQueue->xRxLock );
 843              		.loc 1 1034 0
 844 0064 FB68     		ldr	r3, [r7, #12]
 845 0066 5B6C     		ldr	r3, [r3, #68]
 846 0068 03F10102 		add	r2, r3, #1
 847 006c FB68     		ldr	r3, [r7, #12]
 848 006e 5A64     		str	r2, [r3, #68]
 849              	.L43:
1035:../FreeRTOS/Source/queue.c **** 			}
1036:../FreeRTOS/Source/queue.c **** 
1037:../FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 850              		.loc 1 1037 0
 851 0070 4FF00103 		mov	r3, #1
 852 0074 7B61     		str	r3, [r7, #20]
 853 0076 02E0     		b	.L44
 854              	.L41:
1038:../FreeRTOS/Source/queue.c **** 		}
1039:../FreeRTOS/Source/queue.c **** 		else
1040:../FreeRTOS/Source/queue.c **** 		{
1041:../FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 855              		.loc 1 1041 0
 856 0078 4FF00003 		mov	r3, #0
 857 007c 7B61     		str	r3, [r7, #20]
 858              	.L44:
1042:../FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1043:../FreeRTOS/Source/queue.c **** 		}
1044:../FreeRTOS/Source/queue.c **** 	}
1045:../FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 859              		.loc 1 1045 0
 860              	@ 1045 "../FreeRTOS/Source/queue.c" 1
 861 007e 4FF00000 			mov r0, #0					
 862 0082 80F31188 		msr basepri, r0				
 863              	
 864              	@ 0 "" 2
1046:../FreeRTOS/Source/queue.c **** 
1047:../FreeRTOS/Source/queue.c **** 	return xReturn;
 865              		.loc 1 1047 0
 866              		.thumb
 867 0086 7B69     		ldr	r3, [r7, #20]
1048:../FreeRTOS/Source/queue.c **** }
 868              		.loc 1 1048 0
 869 0088 1846     		mov	r0, r3
 870 008a 07F11807 		add	r7, r7, #24
 871 008e BD46     		mov	sp, r7
 872 0090 80BD     		pop	{r7, pc}
 873              		.cfi_endproc
 874              	.LFE115:
 876 0092 00BF     		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 877              		.align	2
 878              		.global	uxQueueMessagesWaiting
 879              		.thumb
 880              		.thumb_func
 882              	uxQueueMessagesWaiting:
 883              	.LFB116:
1049:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1050:../FreeRTOS/Source/queue.c **** 
1051:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1052:../FreeRTOS/Source/queue.c **** {
 884              		.loc 1 1052 0
 885              		.cfi_startproc
 886              		@ args = 0, pretend = 0, frame = 16
 887              		@ frame_needed = 1, uses_anonymous_args = 0
 888 0000 80B5     		push	{r7, lr}
 889              	.LCFI18:
 890              		.cfi_def_cfa_offset 8
 891              		.cfi_offset 14, -4
 892              		.cfi_offset 7, -8
 893 0002 84B0     		sub	sp, sp, #16
 894              	.LCFI19:
 895              		.cfi_def_cfa_offset 24
 896 0004 00AF     		add	r7, sp, #0
 897              	.LCFI20:
 898              		.cfi_def_cfa_register 7
 899 0006 7860     		str	r0, [r7, #4]
1053:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1054:../FreeRTOS/Source/queue.c **** 
1055:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1056:../FreeRTOS/Source/queue.c **** 
1057:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 900              		.loc 1 1057 0
 901 0008 FFF7FEFF 		bl	vPortEnterCritical
1058:../FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 902              		.loc 1 1058 0
 903 000c 7B68     		ldr	r3, [r7, #4]
 904 000e 9B6B     		ldr	r3, [r3, #56]
 905 0010 FB60     		str	r3, [r7, #12]
1059:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 906              		.loc 1 1059 0
 907 0012 FFF7FEFF 		bl	vPortExitCritical
1060:../FreeRTOS/Source/queue.c **** 
1061:../FreeRTOS/Source/queue.c **** 	return uxReturn;
 908              		.loc 1 1061 0
 909 0016 FB68     		ldr	r3, [r7, #12]
1062:../FreeRTOS/Source/queue.c **** }
 910              		.loc 1 1062 0
 911 0018 1846     		mov	r0, r3
 912 001a 07F11007 		add	r7, r7, #16
 913 001e BD46     		mov	sp, r7
 914 0020 80BD     		pop	{r7, pc}
 915              		.cfi_endproc
 916              	.LFE116:
 918 0022 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 919              		.align	2
 920              		.global	uxQueueMessagesWaitingFromISR
 921              		.thumb
 922              		.thumb_func
 924              	uxQueueMessagesWaitingFromISR:
 925              	.LFB117:
1063:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1064:../FreeRTOS/Source/queue.c **** 
1065:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1066:../FreeRTOS/Source/queue.c **** {
 926              		.loc 1 1066 0
 927              		.cfi_startproc
 928              		@ args = 0, pretend = 0, frame = 16
 929              		@ frame_needed = 1, uses_anonymous_args = 0
 930              		@ link register save eliminated.
 931 0000 80B4     		push	{r7}
 932              	.LCFI21:
 933              		.cfi_def_cfa_offset 4
 934              		.cfi_offset 7, -4
 935 0002 85B0     		sub	sp, sp, #20
 936              	.LCFI22:
 937              		.cfi_def_cfa_offset 24
 938 0004 00AF     		add	r7, sp, #0
 939              	.LCFI23:
 940              		.cfi_def_cfa_register 7
 941 0006 7860     		str	r0, [r7, #4]
1067:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1068:../FreeRTOS/Source/queue.c **** 
1069:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1070:../FreeRTOS/Source/queue.c **** 
1071:../FreeRTOS/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 942              		.loc 1 1071 0
 943 0008 7B68     		ldr	r3, [r7, #4]
 944 000a 9B6B     		ldr	r3, [r3, #56]
 945 000c FB60     		str	r3, [r7, #12]
1072:../FreeRTOS/Source/queue.c **** 
1073:../FreeRTOS/Source/queue.c **** 	return uxReturn;
 946              		.loc 1 1073 0
 947 000e FB68     		ldr	r3, [r7, #12]
1074:../FreeRTOS/Source/queue.c **** }
 948              		.loc 1 1074 0
 949 0010 1846     		mov	r0, r3
 950 0012 07F11407 		add	r7, r7, #20
 951 0016 BD46     		mov	sp, r7
 952 0018 80BC     		pop	{r7}
 953 001a 7047     		bx	lr
 954              		.cfi_endproc
 955              	.LFE117:
 957              		.section	.text.vQueueDelete,"ax",%progbits
 958              		.align	2
 959              		.global	vQueueDelete
 960              		.thumb
 961              		.thumb_func
 963              	vQueueDelete:
 964              	.LFB118:
1075:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1076:../FreeRTOS/Source/queue.c **** 
1077:../FreeRTOS/Source/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1078:../FreeRTOS/Source/queue.c **** {
 965              		.loc 1 1078 0
 966              		.cfi_startproc
 967              		@ args = 0, pretend = 0, frame = 8
 968              		@ frame_needed = 1, uses_anonymous_args = 0
 969 0000 80B5     		push	{r7, lr}
 970              	.LCFI24:
 971              		.cfi_def_cfa_offset 8
 972              		.cfi_offset 14, -4
 973              		.cfi_offset 7, -8
 974 0002 82B0     		sub	sp, sp, #8
 975              	.LCFI25:
 976              		.cfi_def_cfa_offset 16
 977 0004 00AF     		add	r7, sp, #0
 978              	.LCFI26:
 979              		.cfi_def_cfa_register 7
 980 0006 7860     		str	r0, [r7, #4]
1079:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1080:../FreeRTOS/Source/queue.c **** 
1081:../FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1082:../FreeRTOS/Source/queue.c **** 	vQueueUnregisterQueue( pxQueue );
1083:../FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 981              		.loc 1 1083 0
 982 0008 7B68     		ldr	r3, [r7, #4]
 983 000a 1B68     		ldr	r3, [r3, #0]
 984 000c 1846     		mov	r0, r3
 985 000e FFF7FEFF 		bl	free
1084:../FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue );
 986              		.loc 1 1084 0
 987 0012 7868     		ldr	r0, [r7, #4]
 988 0014 FFF7FEFF 		bl	free
1085:../FreeRTOS/Source/queue.c **** }
 989              		.loc 1 1085 0
 990 0018 07F10807 		add	r7, r7, #8
 991 001c BD46     		mov	sp, r7
 992 001e 80BD     		pop	{r7, pc}
 993              		.cfi_endproc
 994              	.LFE118:
 996              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 997              		.align	2
 998              		.thumb
 999              		.thumb_func
 1001              	prvCopyDataToQueue:
 1002              	.LFB119:
1086:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1087:../FreeRTOS/Source/queue.c **** 
1088:../FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1089:../FreeRTOS/Source/queue.c **** {
 1003              		.loc 1 1089 0
 1004              		.cfi_startproc
 1005              		@ args = 0, pretend = 0, frame = 16
 1006              		@ frame_needed = 1, uses_anonymous_args = 0
 1007 0000 80B5     		push	{r7, lr}
 1008              	.LCFI27:
 1009              		.cfi_def_cfa_offset 8
 1010              		.cfi_offset 14, -4
 1011              		.cfi_offset 7, -8
 1012 0002 84B0     		sub	sp, sp, #16
 1013              	.LCFI28:
 1014              		.cfi_def_cfa_offset 24
 1015 0004 00AF     		add	r7, sp, #0
 1016              	.LCFI29:
 1017              		.cfi_def_cfa_register 7
 1018 0006 F860     		str	r0, [r7, #12]
 1019 0008 B960     		str	r1, [r7, #8]
 1020 000a 7A60     		str	r2, [r7, #4]
1090:../FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1021              		.loc 1 1090 0
 1022 000c FB68     		ldr	r3, [r7, #12]
 1023 000e 1B6C     		ldr	r3, [r3, #64]
 1024 0010 002B     		cmp	r3, #0
 1025 0012 0DD1     		bne	.L49
1091:../FreeRTOS/Source/queue.c **** 	{
1092:../FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1093:../FreeRTOS/Source/queue.c **** 		{
1094:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1026              		.loc 1 1094 0
 1027 0014 FB68     		ldr	r3, [r7, #12]
 1028 0016 1B68     		ldr	r3, [r3, #0]
 1029 0018 002B     		cmp	r3, #0
 1030 001a 4AD1     		bne	.L50
1095:../FreeRTOS/Source/queue.c **** 			{
1096:../FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
1097:../FreeRTOS/Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1031              		.loc 1 1097 0
 1032 001c FB68     		ldr	r3, [r7, #12]
 1033 001e 5B68     		ldr	r3, [r3, #4]
 1034 0020 1846     		mov	r0, r3
 1035 0022 FFF7FEFF 		bl	vTaskPriorityDisinherit
1098:../FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1036              		.loc 1 1098 0
 1037 0026 FB68     		ldr	r3, [r7, #12]
 1038 0028 4FF00002 		mov	r2, #0
 1039 002c 5A60     		str	r2, [r3, #4]
 1040 002e 40E0     		b	.L50
 1041              	.L49:
1099:../FreeRTOS/Source/queue.c **** 			}
1100:../FreeRTOS/Source/queue.c **** 		}
1101:../FreeRTOS/Source/queue.c **** 		#endif
1102:../FreeRTOS/Source/queue.c **** 	}
1103:../FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1042              		.loc 1 1103 0
 1043 0030 7B68     		ldr	r3, [r7, #4]
 1044 0032 002B     		cmp	r3, #0
 1045 0034 1BD1     		bne	.L51
1104:../FreeRTOS/Source/queue.c **** 	{
1105:../FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1046              		.loc 1 1105 0
 1047 0036 FB68     		ldr	r3, [r7, #12]
 1048 0038 9968     		ldr	r1, [r3, #8]
 1049 003a FB68     		ldr	r3, [r7, #12]
 1050 003c 1B6C     		ldr	r3, [r3, #64]
 1051 003e BA68     		ldr	r2, [r7, #8]
 1052 0040 0846     		mov	r0, r1
 1053 0042 1146     		mov	r1, r2
 1054 0044 1A46     		mov	r2, r3
 1055 0046 FFF7FEFF 		bl	memcpy
1106:../FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1056              		.loc 1 1106 0
 1057 004a FB68     		ldr	r3, [r7, #12]
 1058 004c 9A68     		ldr	r2, [r3, #8]
 1059 004e FB68     		ldr	r3, [r7, #12]
 1060 0050 1B6C     		ldr	r3, [r3, #64]
 1061 0052 D218     		adds	r2, r2, r3
 1062 0054 FB68     		ldr	r3, [r7, #12]
 1063 0056 9A60     		str	r2, [r3, #8]
1107:../FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 1064              		.loc 1 1107 0
 1065 0058 FB68     		ldr	r3, [r7, #12]
 1066 005a 9A68     		ldr	r2, [r3, #8]
 1067 005c FB68     		ldr	r3, [r7, #12]
 1068 005e 5B68     		ldr	r3, [r3, #4]
 1069 0060 9A42     		cmp	r2, r3
 1070 0062 26D3     		bcc	.L50
1108:../FreeRTOS/Source/queue.c **** 		{
1109:../FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1071              		.loc 1 1109 0
 1072 0064 FB68     		ldr	r3, [r7, #12]
 1073 0066 1A68     		ldr	r2, [r3, #0]
 1074 0068 FB68     		ldr	r3, [r7, #12]
 1075 006a 9A60     		str	r2, [r3, #8]
 1076 006c 21E0     		b	.L50
 1077              	.L51:
1110:../FreeRTOS/Source/queue.c **** 		}
1111:../FreeRTOS/Source/queue.c **** 	}
1112:../FreeRTOS/Source/queue.c **** 	else
1113:../FreeRTOS/Source/queue.c **** 	{
1114:../FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1078              		.loc 1 1114 0
 1079 006e FB68     		ldr	r3, [r7, #12]
 1080 0070 D968     		ldr	r1, [r3, #12]
 1081 0072 FB68     		ldr	r3, [r7, #12]
 1082 0074 1B6C     		ldr	r3, [r3, #64]
 1083 0076 BA68     		ldr	r2, [r7, #8]
 1084 0078 0846     		mov	r0, r1
 1085 007a 1146     		mov	r1, r2
 1086 007c 1A46     		mov	r2, r3
 1087 007e FFF7FEFF 		bl	memcpy
1115:../FreeRTOS/Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 1088              		.loc 1 1115 0
 1089 0082 FB68     		ldr	r3, [r7, #12]
 1090 0084 DA68     		ldr	r2, [r3, #12]
 1091 0086 FB68     		ldr	r3, [r7, #12]
 1092 0088 1B6C     		ldr	r3, [r3, #64]
 1093 008a C3F10003 		rsb	r3, r3, #0
 1094 008e D218     		adds	r2, r2, r3
 1095 0090 FB68     		ldr	r3, [r7, #12]
 1096 0092 DA60     		str	r2, [r3, #12]
1116:../FreeRTOS/Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 1097              		.loc 1 1116 0
 1098 0094 FB68     		ldr	r3, [r7, #12]
 1099 0096 DA68     		ldr	r2, [r3, #12]
 1100 0098 FB68     		ldr	r3, [r7, #12]
 1101 009a 1B68     		ldr	r3, [r3, #0]
 1102 009c 9A42     		cmp	r2, r3
 1103 009e 08D2     		bcs	.L50
1117:../FreeRTOS/Source/queue.c **** 		{
1118:../FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1104              		.loc 1 1118 0
 1105 00a0 FB68     		ldr	r3, [r7, #12]
 1106 00a2 5A68     		ldr	r2, [r3, #4]
 1107 00a4 FB68     		ldr	r3, [r7, #12]
 1108 00a6 1B6C     		ldr	r3, [r3, #64]
 1109 00a8 C3F10003 		rsb	r3, r3, #0
 1110 00ac D218     		adds	r2, r2, r3
 1111 00ae FB68     		ldr	r3, [r7, #12]
 1112 00b0 DA60     		str	r2, [r3, #12]
 1113              	.L50:
1119:../FreeRTOS/Source/queue.c **** 		}
1120:../FreeRTOS/Source/queue.c **** 	}
1121:../FreeRTOS/Source/queue.c **** 
1122:../FreeRTOS/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1114              		.loc 1 1122 0
 1115 00b2 FB68     		ldr	r3, [r7, #12]
 1116 00b4 9B6B     		ldr	r3, [r3, #56]
 1117 00b6 03F10102 		add	r2, r3, #1
 1118 00ba FB68     		ldr	r3, [r7, #12]
 1119 00bc 9A63     		str	r2, [r3, #56]
1123:../FreeRTOS/Source/queue.c **** }
 1120              		.loc 1 1123 0
 1121 00be 07F11007 		add	r7, r7, #16
 1122 00c2 BD46     		mov	sp, r7
 1123 00c4 80BD     		pop	{r7, pc}
 1124              		.cfi_endproc
 1125              	.LFE119:
 1127 00c6 00BF     		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1128              		.align	2
 1129              		.thumb
 1130              		.thumb_func
 1132              	prvCopyDataFromQueue:
 1133              	.LFB120:
1124:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1125:../FreeRTOS/Source/queue.c **** 
1126:../FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1127:../FreeRTOS/Source/queue.c **** {
 1134              		.loc 1 1127 0
 1135              		.cfi_startproc
 1136              		@ args = 0, pretend = 0, frame = 8
 1137              		@ frame_needed = 1, uses_anonymous_args = 0
 1138 0000 80B5     		push	{r7, lr}
 1139              	.LCFI30:
 1140              		.cfi_def_cfa_offset 8
 1141              		.cfi_offset 14, -4
 1142              		.cfi_offset 7, -8
 1143 0002 82B0     		sub	sp, sp, #8
 1144              	.LCFI31:
 1145              		.cfi_def_cfa_offset 16
 1146 0004 00AF     		add	r7, sp, #0
 1147              	.LCFI32:
 1148              		.cfi_def_cfa_register 7
 1149 0006 7860     		str	r0, [r7, #4]
 1150 0008 3960     		str	r1, [r7, #0]
1128:../FreeRTOS/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 1151              		.loc 1 1128 0
 1152 000a 7B68     		ldr	r3, [r7, #4]
 1153 000c 1B68     		ldr	r3, [r3, #0]
 1154 000e 002B     		cmp	r3, #0
 1155 0010 1AD0     		beq	.L52
1129:../FreeRTOS/Source/queue.c **** 	{
1130:../FreeRTOS/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 1156              		.loc 1 1130 0
 1157 0012 7B68     		ldr	r3, [r7, #4]
 1158 0014 DA68     		ldr	r2, [r3, #12]
 1159 0016 7B68     		ldr	r3, [r7, #4]
 1160 0018 1B6C     		ldr	r3, [r3, #64]
 1161 001a D218     		adds	r2, r2, r3
 1162 001c 7B68     		ldr	r3, [r7, #4]
 1163 001e DA60     		str	r2, [r3, #12]
1131:../FreeRTOS/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 1164              		.loc 1 1131 0
 1165 0020 7B68     		ldr	r3, [r7, #4]
 1166 0022 DA68     		ldr	r2, [r3, #12]
 1167 0024 7B68     		ldr	r3, [r7, #4]
 1168 0026 5B68     		ldr	r3, [r3, #4]
 1169 0028 9A42     		cmp	r2, r3
 1170 002a 03D3     		bcc	.L54
1132:../FreeRTOS/Source/queue.c **** 		{
1133:../FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 1171              		.loc 1 1133 0
 1172 002c 7B68     		ldr	r3, [r7, #4]
 1173 002e 1A68     		ldr	r2, [r3, #0]
 1174 0030 7B68     		ldr	r3, [r7, #4]
 1175 0032 DA60     		str	r2, [r3, #12]
 1176              	.L54:
1134:../FreeRTOS/Source/queue.c **** 		}
1135:../FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 1177              		.loc 1 1135 0
 1178 0034 7B68     		ldr	r3, [r7, #4]
 1179 0036 DA68     		ldr	r2, [r3, #12]
 1180 0038 7B68     		ldr	r3, [r7, #4]
 1181 003a 1B6C     		ldr	r3, [r3, #64]
 1182 003c 3968     		ldr	r1, [r7, #0]
 1183 003e 0846     		mov	r0, r1
 1184 0040 1146     		mov	r1, r2
 1185 0042 1A46     		mov	r2, r3
 1186 0044 FFF7FEFF 		bl	memcpy
 1187              	.L52:
1136:../FreeRTOS/Source/queue.c **** 	}
1137:../FreeRTOS/Source/queue.c **** }
 1188              		.loc 1 1137 0
 1189 0048 07F10807 		add	r7, r7, #8
 1190 004c BD46     		mov	sp, r7
 1191 004e 80BD     		pop	{r7, pc}
 1192              		.cfi_endproc
 1193              	.LFE120:
 1195              		.section	.text.prvUnlockQueue,"ax",%progbits
 1196              		.align	2
 1197              		.thumb
 1198              		.thumb_func
 1200              	prvUnlockQueue:
 1201              	.LFB121:
1138:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1139:../FreeRTOS/Source/queue.c **** 
1140:../FreeRTOS/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1141:../FreeRTOS/Source/queue.c **** {
 1202              		.loc 1 1141 0
 1203              		.cfi_startproc
 1204              		@ args = 0, pretend = 0, frame = 8
 1205              		@ frame_needed = 1, uses_anonymous_args = 0
 1206 0000 80B5     		push	{r7, lr}
 1207              	.LCFI33:
 1208              		.cfi_def_cfa_offset 8
 1209              		.cfi_offset 14, -4
 1210              		.cfi_offset 7, -8
 1211 0002 82B0     		sub	sp, sp, #8
 1212              	.LCFI34:
 1213              		.cfi_def_cfa_offset 16
 1214 0004 00AF     		add	r7, sp, #0
 1215              	.LCFI35:
 1216              		.cfi_def_cfa_register 7
 1217 0006 7860     		str	r0, [r7, #4]
1142:../FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1143:../FreeRTOS/Source/queue.c **** 
1144:../FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1145:../FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1146:../FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1147:../FreeRTOS/Source/queue.c **** 	updated. */
1148:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1218              		.loc 1 1148 0
 1219 0008 FFF7FEFF 		bl	vPortEnterCritical
1149:../FreeRTOS/Source/queue.c **** 	{
1150:../FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1151:../FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1220              		.loc 1 1151 0
 1221 000c 14E0     		b	.L56
 1222              	.L60:
1152:../FreeRTOS/Source/queue.c **** 		{
1153:../FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1154:../FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
1155:../FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1223              		.loc 1 1155 0
 1224 000e 7B68     		ldr	r3, [r7, #4]
 1225 0010 5B6A     		ldr	r3, [r3, #36]
 1226 0012 002B     		cmp	r3, #0
 1227 0014 15D0     		beq	.L66
1156:../FreeRTOS/Source/queue.c **** 			{
1157:../FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1158:../FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1159:../FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1228              		.loc 1 1159 0
 1229 0016 7B68     		ldr	r3, [r7, #4]
 1230 0018 03F12403 		add	r3, r3, #36
 1231 001c 1846     		mov	r0, r3
 1232 001e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1233 0022 0346     		mov	r3, r0
 1234 0024 002B     		cmp	r3, #0
 1235 0026 01D0     		beq	.L58
1160:../FreeRTOS/Source/queue.c **** 				{
1161:../FreeRTOS/Source/queue.c **** 					/* The task waiting has a higher priority so record that a
1162:../FreeRTOS/Source/queue.c **** 					context	switch is required. */
1163:../FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 1236              		.loc 1 1163 0
 1237 0028 FFF7FEFF 		bl	vTaskMissedYield
 1238              	.L58:
1164:../FreeRTOS/Source/queue.c **** 				}
1165:../FreeRTOS/Source/queue.c **** 
1166:../FreeRTOS/Source/queue.c **** 				--( pxQueue->xTxLock );
 1239              		.loc 1 1166 0
 1240 002c 7B68     		ldr	r3, [r7, #4]
 1241 002e 9B6C     		ldr	r3, [r3, #72]
 1242 0030 03F1FF32 		add	r2, r3, #-1
 1243 0034 7B68     		ldr	r3, [r7, #4]
 1244 0036 9A64     		str	r2, [r3, #72]
 1245              	.L56:
1151:../FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1246              		.loc 1 1151 0 discriminator 1
 1247 0038 7B68     		ldr	r3, [r7, #4]
 1248 003a 9B6C     		ldr	r3, [r3, #72]
 1249 003c 002B     		cmp	r3, #0
 1250 003e E6DC     		bgt	.L60
 1251 0040 00E0     		b	.L59
 1252              	.L66:
1167:../FreeRTOS/Source/queue.c **** 			}
1168:../FreeRTOS/Source/queue.c **** 			else
1169:../FreeRTOS/Source/queue.c **** 			{
1170:../FreeRTOS/Source/queue.c **** 				break;
 1253              		.loc 1 1170 0
 1254 0042 00BF     		nop
 1255              	.L59:
1171:../FreeRTOS/Source/queue.c **** 			}
1172:../FreeRTOS/Source/queue.c **** 		}
1173:../FreeRTOS/Source/queue.c **** 
1174:../FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 1256              		.loc 1 1174 0
 1257 0044 7B68     		ldr	r3, [r7, #4]
 1258 0046 4FF0FF32 		mov	r2, #-1
 1259 004a 9A64     		str	r2, [r3, #72]
1175:../FreeRTOS/Source/queue.c **** 	}
1176:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1260              		.loc 1 1176 0
 1261 004c FFF7FEFF 		bl	vPortExitCritical
1177:../FreeRTOS/Source/queue.c **** 
1178:../FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
1179:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1262              		.loc 1 1179 0
 1263 0050 FFF7FEFF 		bl	vPortEnterCritical
1180:../FreeRTOS/Source/queue.c **** 	{
1181:../FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1264              		.loc 1 1181 0
 1265 0054 14E0     		b	.L61
 1266              	.L65:
1182:../FreeRTOS/Source/queue.c **** 		{
1183:../FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1267              		.loc 1 1183 0
 1268 0056 7B68     		ldr	r3, [r7, #4]
 1269 0058 1B69     		ldr	r3, [r3, #16]
 1270 005a 002B     		cmp	r3, #0
 1271 005c 15D0     		beq	.L67
1184:../FreeRTOS/Source/queue.c **** 			{
1185:../FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1272              		.loc 1 1185 0
 1273 005e 7B68     		ldr	r3, [r7, #4]
 1274 0060 03F11003 		add	r3, r3, #16
 1275 0064 1846     		mov	r0, r3
 1276 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1277 006a 0346     		mov	r3, r0
 1278 006c 002B     		cmp	r3, #0
 1279 006e 01D0     		beq	.L63
1186:../FreeRTOS/Source/queue.c **** 				{
1187:../FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 1280              		.loc 1 1187 0
 1281 0070 FFF7FEFF 		bl	vTaskMissedYield
 1282              	.L63:
1188:../FreeRTOS/Source/queue.c **** 				}
1189:../FreeRTOS/Source/queue.c **** 
1190:../FreeRTOS/Source/queue.c **** 				--( pxQueue->xRxLock );
 1283              		.loc 1 1190 0
 1284 0074 7B68     		ldr	r3, [r7, #4]
 1285 0076 5B6C     		ldr	r3, [r3, #68]
 1286 0078 03F1FF32 		add	r2, r3, #-1
 1287 007c 7B68     		ldr	r3, [r7, #4]
 1288 007e 5A64     		str	r2, [r3, #68]
 1289              	.L61:
1181:../FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1290              		.loc 1 1181 0 discriminator 1
 1291 0080 7B68     		ldr	r3, [r7, #4]
 1292 0082 5B6C     		ldr	r3, [r3, #68]
 1293 0084 002B     		cmp	r3, #0
 1294 0086 E6DC     		bgt	.L65
 1295 0088 00E0     		b	.L64
 1296              	.L67:
1191:../FreeRTOS/Source/queue.c **** 			}
1192:../FreeRTOS/Source/queue.c **** 			else
1193:../FreeRTOS/Source/queue.c **** 			{
1194:../FreeRTOS/Source/queue.c **** 				break;
 1297              		.loc 1 1194 0
 1298 008a 00BF     		nop
 1299              	.L64:
1195:../FreeRTOS/Source/queue.c **** 			}
1196:../FreeRTOS/Source/queue.c **** 		}
1197:../FreeRTOS/Source/queue.c **** 
1198:../FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 1300              		.loc 1 1198 0
 1301 008c 7B68     		ldr	r3, [r7, #4]
 1302 008e 4FF0FF32 		mov	r2, #-1
 1303 0092 5A64     		str	r2, [r3, #68]
1199:../FreeRTOS/Source/queue.c **** 	}
1200:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1304              		.loc 1 1200 0
 1305 0094 FFF7FEFF 		bl	vPortExitCritical
1201:../FreeRTOS/Source/queue.c **** }
 1306              		.loc 1 1201 0
 1307 0098 07F10807 		add	r7, r7, #8
 1308 009c BD46     		mov	sp, r7
 1309 009e 80BD     		pop	{r7, pc}
 1310              		.cfi_endproc
 1311              	.LFE121:
 1313              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 1314              		.align	2
 1315              		.thumb
 1316              		.thumb_func
 1318              	prvIsQueueEmpty:
 1319              	.LFB122:
1202:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1203:../FreeRTOS/Source/queue.c **** 
1204:../FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1205:../FreeRTOS/Source/queue.c **** {
 1320              		.loc 1 1205 0
 1321              		.cfi_startproc
 1322              		@ args = 0, pretend = 0, frame = 16
 1323              		@ frame_needed = 1, uses_anonymous_args = 0
 1324 0000 80B5     		push	{r7, lr}
 1325              	.LCFI36:
 1326              		.cfi_def_cfa_offset 8
 1327              		.cfi_offset 14, -4
 1328              		.cfi_offset 7, -8
 1329 0002 84B0     		sub	sp, sp, #16
 1330              	.LCFI37:
 1331              		.cfi_def_cfa_offset 24
 1332 0004 00AF     		add	r7, sp, #0
 1333              	.LCFI38:
 1334              		.cfi_def_cfa_register 7
 1335 0006 7860     		str	r0, [r7, #4]
1206:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1207:../FreeRTOS/Source/queue.c **** 
1208:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1336              		.loc 1 1208 0
 1337 0008 FFF7FEFF 		bl	vPortEnterCritical
1209:../FreeRTOS/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1338              		.loc 1 1209 0
 1339 000c 7B68     		ldr	r3, [r7, #4]
 1340 000e 9B6B     		ldr	r3, [r3, #56]
 1341 0010 002B     		cmp	r3, #0
 1342 0012 14BF     		ite	ne
 1343 0014 0023     		movne	r3, #0
 1344 0016 0123     		moveq	r3, #1
 1345 0018 FB60     		str	r3, [r7, #12]
1210:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1346              		.loc 1 1210 0
 1347 001a FFF7FEFF 		bl	vPortExitCritical
1211:../FreeRTOS/Source/queue.c **** 
1212:../FreeRTOS/Source/queue.c **** 	return xReturn;
 1348              		.loc 1 1212 0
 1349 001e FB68     		ldr	r3, [r7, #12]
1213:../FreeRTOS/Source/queue.c **** }
 1350              		.loc 1 1213 0
 1351 0020 1846     		mov	r0, r3
 1352 0022 07F11007 		add	r7, r7, #16
 1353 0026 BD46     		mov	sp, r7
 1354 0028 80BD     		pop	{r7, pc}
 1355              		.cfi_endproc
 1356              	.LFE122:
 1358 002a 00BF     		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 1359              		.align	2
 1360              		.global	xQueueIsQueueEmptyFromISR
 1361              		.thumb
 1362              		.thumb_func
 1364              	xQueueIsQueueEmptyFromISR:
 1365              	.LFB123:
1214:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1215:../FreeRTOS/Source/queue.c **** 
1216:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1217:../FreeRTOS/Source/queue.c **** {
 1366              		.loc 1 1217 0
 1367              		.cfi_startproc
 1368              		@ args = 0, pretend = 0, frame = 16
 1369              		@ frame_needed = 1, uses_anonymous_args = 0
 1370              		@ link register save eliminated.
 1371 0000 80B4     		push	{r7}
 1372              	.LCFI39:
 1373              		.cfi_def_cfa_offset 4
 1374              		.cfi_offset 7, -4
 1375 0002 85B0     		sub	sp, sp, #20
 1376              	.LCFI40:
 1377              		.cfi_def_cfa_offset 24
 1378 0004 00AF     		add	r7, sp, #0
 1379              	.LCFI41:
 1380              		.cfi_def_cfa_register 7
 1381 0006 7860     		str	r0, [r7, #4]
1218:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1219:../FreeRTOS/Source/queue.c **** 
1220:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1221:../FreeRTOS/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1382              		.loc 1 1221 0
 1383 0008 7B68     		ldr	r3, [r7, #4]
 1384 000a 9B6B     		ldr	r3, [r3, #56]
 1385 000c 002B     		cmp	r3, #0
 1386 000e 14BF     		ite	ne
 1387 0010 0023     		movne	r3, #0
 1388 0012 0123     		moveq	r3, #1
 1389 0014 FB60     		str	r3, [r7, #12]
1222:../FreeRTOS/Source/queue.c **** 
1223:../FreeRTOS/Source/queue.c **** 	return xReturn;
 1390              		.loc 1 1223 0
 1391 0016 FB68     		ldr	r3, [r7, #12]
1224:../FreeRTOS/Source/queue.c **** }
 1392              		.loc 1 1224 0
 1393 0018 1846     		mov	r0, r3
 1394 001a 07F11407 		add	r7, r7, #20
 1395 001e BD46     		mov	sp, r7
 1396 0020 80BC     		pop	{r7}
 1397 0022 7047     		bx	lr
 1398              		.cfi_endproc
 1399              	.LFE123:
 1401              		.section	.text.prvIsQueueFull,"ax",%progbits
 1402              		.align	2
 1403              		.thumb
 1404              		.thumb_func
 1406              	prvIsQueueFull:
 1407              	.LFB124:
1225:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1226:../FreeRTOS/Source/queue.c **** 
1227:../FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1228:../FreeRTOS/Source/queue.c **** {
 1408              		.loc 1 1228 0
 1409              		.cfi_startproc
 1410              		@ args = 0, pretend = 0, frame = 16
 1411              		@ frame_needed = 1, uses_anonymous_args = 0
 1412 0000 80B5     		push	{r7, lr}
 1413              	.LCFI42:
 1414              		.cfi_def_cfa_offset 8
 1415              		.cfi_offset 14, -4
 1416              		.cfi_offset 7, -8
 1417 0002 84B0     		sub	sp, sp, #16
 1418              	.LCFI43:
 1419              		.cfi_def_cfa_offset 24
 1420 0004 00AF     		add	r7, sp, #0
 1421              	.LCFI44:
 1422              		.cfi_def_cfa_register 7
 1423 0006 7860     		str	r0, [r7, #4]
1229:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1230:../FreeRTOS/Source/queue.c **** 
1231:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1424              		.loc 1 1231 0
 1425 0008 FFF7FEFF 		bl	vPortEnterCritical
1232:../FreeRTOS/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1426              		.loc 1 1232 0
 1427 000c 7B68     		ldr	r3, [r7, #4]
 1428 000e 9B6B     		ldr	r3, [r3, #56]
 1429 0010 1A46     		mov	r2, r3
 1430 0012 7B68     		ldr	r3, [r7, #4]
 1431 0014 DB6B     		ldr	r3, [r3, #60]
 1432 0016 9A42     		cmp	r2, r3
 1433 0018 14BF     		ite	ne
 1434 001a 0023     		movne	r3, #0
 1435 001c 0123     		moveq	r3, #1
 1436 001e FB60     		str	r3, [r7, #12]
1233:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1437              		.loc 1 1233 0
 1438 0020 FFF7FEFF 		bl	vPortExitCritical
1234:../FreeRTOS/Source/queue.c **** 
1235:../FreeRTOS/Source/queue.c **** 	return xReturn;
 1439              		.loc 1 1235 0
 1440 0024 FB68     		ldr	r3, [r7, #12]
1236:../FreeRTOS/Source/queue.c **** }
 1441              		.loc 1 1236 0
 1442 0026 1846     		mov	r0, r3
 1443 0028 07F11007 		add	r7, r7, #16
 1444 002c BD46     		mov	sp, r7
 1445 002e 80BD     		pop	{r7, pc}
 1446              		.cfi_endproc
 1447              	.LFE124:
 1449              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 1450              		.align	2
 1451              		.global	xQueueIsQueueFullFromISR
 1452              		.thumb
 1453              		.thumb_func
 1455              	xQueueIsQueueFullFromISR:
 1456              	.LFB125:
1237:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1238:../FreeRTOS/Source/queue.c **** 
1239:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1240:../FreeRTOS/Source/queue.c **** {
 1457              		.loc 1 1240 0
 1458              		.cfi_startproc
 1459              		@ args = 0, pretend = 0, frame = 16
 1460              		@ frame_needed = 1, uses_anonymous_args = 0
 1461              		@ link register save eliminated.
 1462 0000 80B4     		push	{r7}
 1463              	.LCFI45:
 1464              		.cfi_def_cfa_offset 4
 1465              		.cfi_offset 7, -4
 1466 0002 85B0     		sub	sp, sp, #20
 1467              	.LCFI46:
 1468              		.cfi_def_cfa_offset 24
 1469 0004 00AF     		add	r7, sp, #0
 1470              	.LCFI47:
 1471              		.cfi_def_cfa_register 7
 1472 0006 7860     		str	r0, [r7, #4]
1241:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1242:../FreeRTOS/Source/queue.c **** 
1243:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1244:../FreeRTOS/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1473              		.loc 1 1244 0
 1474 0008 7B68     		ldr	r3, [r7, #4]
 1475 000a 9B6B     		ldr	r3, [r3, #56]
 1476 000c 1A46     		mov	r2, r3
 1477 000e 7B68     		ldr	r3, [r7, #4]
 1478 0010 DB6B     		ldr	r3, [r3, #60]
 1479 0012 9A42     		cmp	r2, r3
 1480 0014 14BF     		ite	ne
 1481 0016 0023     		movne	r3, #0
 1482 0018 0123     		moveq	r3, #1
 1483 001a FB60     		str	r3, [r7, #12]
1245:../FreeRTOS/Source/queue.c **** 
1246:../FreeRTOS/Source/queue.c **** 	return xReturn;
 1484              		.loc 1 1246 0
 1485 001c FB68     		ldr	r3, [r7, #12]
1247:../FreeRTOS/Source/queue.c **** }
 1486              		.loc 1 1247 0
 1487 001e 1846     		mov	r0, r3
 1488 0020 07F11407 		add	r7, r7, #20
 1489 0024 BD46     		mov	sp, r7
 1490 0026 80BC     		pop	{r7}
 1491 0028 7047     		bx	lr
 1492              		.cfi_endproc
 1493              	.LFE125:
 1495 002a 00BF     		.text
 1496              	.Letext0:
 1497              		.file 2 "e:\\elektronik\\toolchain\\yagarto\\bin\\../lib/gcc/arm-none-eabi/4.6.2/include/stddef.h"
 1498              		.file 3 "e:/elektronik/toolchain/yagarto/lib/gcc/../../arm-none-eabi/sys-include/stdint.h"
 1499              		.file 4 "C:\\Users\\Alex\\git\\thundercyer-the-alarm-clock\\FreeRTOS\\Source\\include/../../Source
 1500              		.file 5 "C:\\Users\\Alex\\git\\thundercyer-the-alarm-clock\\FreeRTOS\\Source\\include/list.h"
 1501              		.file 6 "C:\\Users\\Alex\\git\\thundercyer-the-alarm-clock\\FreeRTOS\\Source\\include/task.h"
 1502              		.file 7 "C:\\Users\\Alex\\git\\thundercyer-the-alarm-clock\\CMSIS\\Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:19     .text.xQueueCreate:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:24     .text.xQueueCreate:00000000 xQueueCreate
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:152    .text.xQueueCreateMutex:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:157    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:252    .text.xQueueGenericSend:00000000 xQueueGenericSend
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:247    .text.xQueueGenericSend:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1001   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1406   .text.prvIsQueueFull:00000000 prvIsQueueFull
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1200   .text.prvUnlockQueue:00000000 prvUnlockQueue
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:427    .text.xQueueGenericSendFromISR:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:432    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:533    .text.xQueueGenericReceive:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:538    .text.xQueueGenericReceive:00000000 xQueueGenericReceive
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1132   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1318   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:770    .text.xQueueReceiveFromISR:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:775    .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:877    .text.uxQueueMessagesWaiting:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:882    .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:919    .text.uxQueueMessagesWaitingFromISR:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:924    .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:958    .text.vQueueDelete:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:963    .text.vQueueDelete:00000000 vQueueDelete
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:997    .text.prvCopyDataToQueue:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1128   .text.prvCopyDataFromQueue:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1196   .text.prvUnlockQueue:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1314   .text.prvIsQueueEmpty:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1359   .text.xQueueIsQueueEmptyFromISR:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1364   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1402   .text.prvIsQueueFull:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1450   .text.xQueueIsQueueFullFromISR:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccnBFHX4.s:1455   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
malloc
vListInitialise
free
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vPortExitCritical
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
xTaskGetCurrentTaskHandle
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
