   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"queue.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.align	2
  19              		.global	xQueueCreate
  20              		.thumb
  21              		.thumb_func
  23              	xQueueCreate:
  24              	.LFB110:
  25              		.file 1 "../FreeRTOS/Source/queue.c"
   1:../FreeRTOS/Source/queue.c **** /*
   2:../FreeRTOS/Source/queue.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS/Source/queue.c **** 
   4:../FreeRTOS/Source/queue.c **** 
   5:../FreeRTOS/Source/queue.c ****     ***************************************************************************
   6:../FreeRTOS/Source/queue.c ****      *                                                                       *
   7:../FreeRTOS/Source/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS/Source/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS/Source/queue.c ****      *    available.                                                         *
  10:../FreeRTOS/Source/queue.c ****      *                                                                       *
  11:../FreeRTOS/Source/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS/Source/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS/Source/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS/Source/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS/Source/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS/Source/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS/Source/queue.c ****      *                                                                       *
  18:../FreeRTOS/Source/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS/Source/queue.c ****      *                                                                       *
  20:../FreeRTOS/Source/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS/Source/queue.c ****      *                                                                       *
  22:../FreeRTOS/Source/queue.c ****     ***************************************************************************
  23:../FreeRTOS/Source/queue.c **** 
  24:../FreeRTOS/Source/queue.c **** 
  25:../FreeRTOS/Source/queue.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS/Source/queue.c **** 
  27:../FreeRTOS/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS/Source/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS/Source/queue.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS/Source/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS/Source/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS/Source/queue.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS/Source/queue.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS/Source/queue.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS/Source/queue.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS/Source/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS/Source/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS/Source/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS/Source/queue.c ****     FreeRTOS WEB site.
  41:../FreeRTOS/Source/queue.c **** 
  42:../FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  43:../FreeRTOS/Source/queue.c **** 
  44:../FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS/Source/queue.c ****     contact details.
  46:../FreeRTOS/Source/queue.c **** 
  47:../FreeRTOS/Source/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS/Source/queue.c ****     critical systems.
  49:../FreeRTOS/Source/queue.c **** 
  50:../FreeRTOS/Source/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS/Source/queue.c ****     licensing and training services.
  52:../FreeRTOS/Source/queue.c **** */
  53:../FreeRTOS/Source/queue.c **** 
  54:../FreeRTOS/Source/queue.c **** #include <stdlib.h>
  55:../FreeRTOS/Source/queue.c **** #include <string.h>
  56:../FreeRTOS/Source/queue.c **** 
  57:../FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:../FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:../FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  60:../FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:../FreeRTOS/Source/queue.c **** 
  62:../FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  63:../FreeRTOS/Source/queue.c **** #include "task.h"
  64:../FreeRTOS/Source/queue.c **** 
  65:../FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  66:../FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  67:../FreeRTOS/Source/queue.c **** #endif
  68:../FreeRTOS/Source/queue.c **** 
  69:../FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../FreeRTOS/Source/queue.c **** 
  71:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------
  72:../FreeRTOS/Source/queue.c ****  * PUBLIC LIST API documented in list.h
  73:../FreeRTOS/Source/queue.c ****  *----------------------------------------------------------*/
  74:../FreeRTOS/Source/queue.c **** 
  75:../FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  76:../FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  77:../FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  78:../FreeRTOS/Source/queue.c **** 
  79:../FreeRTOS/Source/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  80:../FreeRTOS/Source/queue.c **** 
  81:../FreeRTOS/Source/queue.c **** /* For internal use only. */
  82:../FreeRTOS/Source/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  83:../FreeRTOS/Source/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  84:../FreeRTOS/Source/queue.c **** 
  85:../FreeRTOS/Source/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  86:../FreeRTOS/Source/queue.c **** #define pxMutexHolder					pcTail
  87:../FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
  88:../FreeRTOS/Source/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  89:../FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  90:../FreeRTOS/Source/queue.c **** 
  91:../FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  92:../FreeRTOS/Source/queue.c **** zero. */
  93:../FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
  94:../FreeRTOS/Source/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
  95:../FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
  96:../FreeRTOS/Source/queue.c **** 
  97:../FreeRTOS/Source/queue.c **** /*
  98:../FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  99:../FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.
 100:../FreeRTOS/Source/queue.c ****  */
 101:../FreeRTOS/Source/queue.c **** typedef struct QueueDefinition
 102:../FreeRTOS/Source/queue.c **** {
 103:../FreeRTOS/Source/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 104:../FreeRTOS/Source/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 105:../FreeRTOS/Source/queue.c **** 
 106:../FreeRTOS/Source/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 107:../FreeRTOS/Source/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 108:../FreeRTOS/Source/queue.c **** 
 109:../FreeRTOS/Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 110:../FreeRTOS/Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 111:../FreeRTOS/Source/queue.c **** 
 112:../FreeRTOS/Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 113:../FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 114:../FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 115:../FreeRTOS/Source/queue.c **** 
 116:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 117:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 118:../FreeRTOS/Source/queue.c **** 
 119:../FreeRTOS/Source/queue.c **** } xQUEUE;
 120:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 121:../FreeRTOS/Source/queue.c **** 
 122:../FreeRTOS/Source/queue.c **** /*
 123:../FreeRTOS/Source/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 124:../FreeRTOS/Source/queue.c ****  * To keep the definition private the API header file defines it as a
 125:../FreeRTOS/Source/queue.c ****  * pointer to void.
 126:../FreeRTOS/Source/queue.c ****  */
 127:../FreeRTOS/Source/queue.c **** typedef xQUEUE * xQueueHandle;
 128:../FreeRTOS/Source/queue.c **** 
 129:../FreeRTOS/Source/queue.c **** /*
 130:../FreeRTOS/Source/queue.c ****  * Prototypes for public functions are included here so we don't have to
 131:../FreeRTOS/Source/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 132:../FreeRTOS/Source/queue.c ****  * functions are documented in the API header file.
 133:../FreeRTOS/Source/queue.c ****  */
 134:../FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 135:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 136:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 137:../FreeRTOS/Source/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 138:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 139:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 140:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 141:../FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreateMutex( void ) PRIVILEGED_FUNCTION;
 142:../FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 143:../FreeRTOS/Source/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 144:../FreeRTOS/Source/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 145:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 146:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 147:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 148:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 149:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 150:../FreeRTOS/Source/queue.c **** void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_F
 151:../FreeRTOS/Source/queue.c **** 
 152:../FreeRTOS/Source/queue.c **** /*
 153:../FreeRTOS/Source/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 154:../FreeRTOS/Source/queue.c ****  * an optional component.
 155:../FreeRTOS/Source/queue.c ****  */
 156:../FreeRTOS/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
 157:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 158:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 159:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 160:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 161:../FreeRTOS/Source/queue.c **** #endif
 162:../FreeRTOS/Source/queue.c **** 
 163:../FreeRTOS/Source/queue.c **** /*
 164:../FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 165:../FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 166:../FreeRTOS/Source/queue.c ****  */
 167:../FreeRTOS/Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 168:../FreeRTOS/Source/queue.c **** 
 169:../FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 170:../FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 171:../FreeRTOS/Source/queue.c **** 	more user friendly. */
 172:../FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 173:../FreeRTOS/Source/queue.c **** 	{
 174:../FreeRTOS/Source/queue.c **** 		signed char *pcQueueName;
 175:../FreeRTOS/Source/queue.c **** 		xQueueHandle xHandle;
 176:../FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 177:../FreeRTOS/Source/queue.c **** 
 178:../FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 179:../FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 180:../FreeRTOS/Source/queue.c **** 	array position being vacant. */
 181:../FreeRTOS/Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 182:../FreeRTOS/Source/queue.c **** 
 183:../FreeRTOS/Source/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 184:../FreeRTOS/Source/queue.c **** 	member to NULL. */
 185:../FreeRTOS/Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 186:../FreeRTOS/Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 187:../FreeRTOS/Source/queue.c **** #endif
 188:../FreeRTOS/Source/queue.c **** 
 189:../FreeRTOS/Source/queue.c **** /*
 190:../FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 191:../FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 192:../FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 193:../FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 194:../FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 195:../FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 196:../FreeRTOS/Source/queue.c ****  */
 197:../FreeRTOS/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 198:../FreeRTOS/Source/queue.c **** 
 199:../FreeRTOS/Source/queue.c **** /*
 200:../FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 201:../FreeRTOS/Source/queue.c ****  *
 202:../FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 203:../FreeRTOS/Source/queue.c ****  */
 204:../FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 205:../FreeRTOS/Source/queue.c **** 
 206:../FreeRTOS/Source/queue.c **** /*
 207:../FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 208:../FreeRTOS/Source/queue.c ****  *
 209:../FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 210:../FreeRTOS/Source/queue.c ****  */
 211:../FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 212:../FreeRTOS/Source/queue.c **** 
 213:../FreeRTOS/Source/queue.c **** /*
 214:../FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 215:../FreeRTOS/Source/queue.c ****  * back of the queue.
 216:../FreeRTOS/Source/queue.c ****  */
 217:../FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 218:../FreeRTOS/Source/queue.c **** 
 219:../FreeRTOS/Source/queue.c **** /*
 220:../FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 221:../FreeRTOS/Source/queue.c ****  */
 222:../FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 223:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 224:../FreeRTOS/Source/queue.c **** 
 225:../FreeRTOS/Source/queue.c **** /*
 226:../FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 227:../FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 228:../FreeRTOS/Source/queue.c ****  */
 229:../FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 230:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 231:../FreeRTOS/Source/queue.c **** 	{														\
 232:../FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 233:../FreeRTOS/Source/queue.c **** 		{													\
 234:../FreeRTOS/Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 235:../FreeRTOS/Source/queue.c **** 		}													\
 236:../FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 237:../FreeRTOS/Source/queue.c **** 		{													\
 238:../FreeRTOS/Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 239:../FreeRTOS/Source/queue.c **** 		}													\
 240:../FreeRTOS/Source/queue.c **** 	}														\
 241:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 242:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 243:../FreeRTOS/Source/queue.c **** 
 244:../FreeRTOS/Source/queue.c **** 
 245:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------
 246:../FreeRTOS/Source/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 247:../FreeRTOS/Source/queue.c ****  *----------------------------------------------------------*/
 248:../FreeRTOS/Source/queue.c **** 
 249:../FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 250:../FreeRTOS/Source/queue.c **** {
  26              		.loc 1 250 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 24
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30 0000 80B5     		push	{r7, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 14, -4
  34              		.cfi_offset 7, -8
  35 0002 86B0     		sub	sp, sp, #24
  36              	.LCFI1:
  37              		.cfi_def_cfa_offset 32
  38 0004 00AF     		add	r7, sp, #0
  39              	.LCFI2:
  40              		.cfi_def_cfa_register 7
  41 0006 7860     		str	r0, [r7, #4]
  42 0008 3960     		str	r1, [r7, #0]
 251:../FreeRTOS/Source/queue.c **** xQUEUE *pxNewQueue;
 252:../FreeRTOS/Source/queue.c **** size_t xQueueSizeInBytes;
 253:../FreeRTOS/Source/queue.c **** xQueueHandle xReturn = NULL;
  43              		.loc 1 253 0
  44 000a 4FF00003 		mov	r3, #0
  45 000e 7B61     		str	r3, [r7, #20]
 254:../FreeRTOS/Source/queue.c **** 
 255:../FreeRTOS/Source/queue.c **** 	/* Allocate the new queue structure. */
 256:../FreeRTOS/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  46              		.loc 1 256 0
  47 0010 7B68     		ldr	r3, [r7, #4]
  48 0012 002B     		cmp	r3, #0
  49 0014 56D0     		beq	.L2
 257:../FreeRTOS/Source/queue.c **** 	{
 258:../FreeRTOS/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  50              		.loc 1 258 0
  51 0016 4FF04C00 		mov	r0, #76
  52 001a FFF7FEFF 		bl	malloc
  53 001e 0346     		mov	r3, r0
  54 0020 3B61     		str	r3, [r7, #16]
 259:../FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
  55              		.loc 1 259 0
  56 0022 3B69     		ldr	r3, [r7, #16]
  57 0024 002B     		cmp	r3, #0
  58 0026 4DD0     		beq	.L2
 260:../FreeRTOS/Source/queue.c **** 		{
 261:../FreeRTOS/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 262:../FreeRTOS/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 263:../FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  59              		.loc 1 263 0
  60 0028 7B68     		ldr	r3, [r7, #4]
  61 002a 3A68     		ldr	r2, [r7, #0]
  62 002c 02FB03F3 		mul	r3, r2, r3
  63 0030 03F10103 		add	r3, r3, #1
  64 0034 FB60     		str	r3, [r7, #12]
 264:../FreeRTOS/Source/queue.c **** 
 265:../FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  65              		.loc 1 265 0
  66 0036 F868     		ldr	r0, [r7, #12]
  67 0038 FFF7FEFF 		bl	malloc
  68 003c 0346     		mov	r3, r0
  69 003e 1A46     		mov	r2, r3
  70 0040 3B69     		ldr	r3, [r7, #16]
  71 0042 1A60     		str	r2, [r3, #0]
 266:../FreeRTOS/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
  72              		.loc 1 266 0
  73 0044 3B69     		ldr	r3, [r7, #16]
  74 0046 1B68     		ldr	r3, [r3, #0]
  75 0048 002B     		cmp	r3, #0
  76 004a 38D0     		beq	.L3
 267:../FreeRTOS/Source/queue.c **** 			{
 268:../FreeRTOS/Source/queue.c **** 				/* Initialise the queue members as described above where the
 269:../FreeRTOS/Source/queue.c **** 				queue type is defined. */
 270:../FreeRTOS/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
  77              		.loc 1 270 0
  78 004c 3B69     		ldr	r3, [r7, #16]
  79 004e 1A68     		ldr	r2, [r3, #0]
  80 0050 7B68     		ldr	r3, [r7, #4]
  81 0052 3968     		ldr	r1, [r7, #0]
  82 0054 01FB03F3 		mul	r3, r1, r3
  83 0058 D218     		adds	r2, r2, r3
  84 005a 3B69     		ldr	r3, [r7, #16]
  85 005c 5A60     		str	r2, [r3, #4]
 271:../FreeRTOS/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  86              		.loc 1 271 0
  87 005e 3B69     		ldr	r3, [r7, #16]
  88 0060 4FF00002 		mov	r2, #0
  89 0064 9A63     		str	r2, [r3, #56]
 272:../FreeRTOS/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
  90              		.loc 1 272 0
  91 0066 3B69     		ldr	r3, [r7, #16]
  92 0068 1A68     		ldr	r2, [r3, #0]
  93 006a 3B69     		ldr	r3, [r7, #16]
  94 006c 9A60     		str	r2, [r3, #8]
 273:../FreeRTOS/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U
  95              		.loc 1 273 0
  96 006e 3B69     		ldr	r3, [r7, #16]
  97 0070 1A68     		ldr	r2, [r3, #0]
  98 0072 7B68     		ldr	r3, [r7, #4]
  99 0074 03F1FF33 		add	r3, r3, #-1
 100 0078 3968     		ldr	r1, [r7, #0]
 101 007a 01FB03F3 		mul	r3, r1, r3
 102 007e D218     		adds	r2, r2, r3
 103 0080 3B69     		ldr	r3, [r7, #16]
 104 0082 DA60     		str	r2, [r3, #12]
 274:../FreeRTOS/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 105              		.loc 1 274 0
 106 0084 3B69     		ldr	r3, [r7, #16]
 107 0086 7A68     		ldr	r2, [r7, #4]
 108 0088 DA63     		str	r2, [r3, #60]
 275:../FreeRTOS/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 109              		.loc 1 275 0
 110 008a 3B69     		ldr	r3, [r7, #16]
 111 008c 3A68     		ldr	r2, [r7, #0]
 112 008e 1A64     		str	r2, [r3, #64]
 276:../FreeRTOS/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 113              		.loc 1 276 0
 114 0090 3B69     		ldr	r3, [r7, #16]
 115 0092 4FF0FF32 		mov	r2, #-1
 116 0096 5A64     		str	r2, [r3, #68]
 277:../FreeRTOS/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 117              		.loc 1 277 0
 118 0098 3B69     		ldr	r3, [r7, #16]
 119 009a 4FF0FF32 		mov	r2, #-1
 120 009e 9A64     		str	r2, [r3, #72]
 278:../FreeRTOS/Source/queue.c **** 
 279:../FreeRTOS/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 280:../FreeRTOS/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 121              		.loc 1 280 0
 122 00a0 3B69     		ldr	r3, [r7, #16]
 123 00a2 03F11003 		add	r3, r3, #16
 124 00a6 1846     		mov	r0, r3
 125 00a8 FFF7FEFF 		bl	vListInitialise
 281:../FreeRTOS/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 126              		.loc 1 281 0
 127 00ac 3B69     		ldr	r3, [r7, #16]
 128 00ae 03F12403 		add	r3, r3, #36
 129 00b2 1846     		mov	r0, r3
 130 00b4 FFF7FEFF 		bl	vListInitialise
 282:../FreeRTOS/Source/queue.c **** 
 283:../FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 284:../FreeRTOS/Source/queue.c **** 				xReturn = pxNewQueue;
 131              		.loc 1 284 0
 132 00b8 3B69     		ldr	r3, [r7, #16]
 133 00ba 7B61     		str	r3, [r7, #20]
 134 00bc 02E0     		b	.L2
 135              	.L3:
 285:../FreeRTOS/Source/queue.c **** 			}
 286:../FreeRTOS/Source/queue.c **** 			else
 287:../FreeRTOS/Source/queue.c **** 			{
 288:../FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 289:../FreeRTOS/Source/queue.c **** 				vPortFree( pxNewQueue );
 136              		.loc 1 289 0
 137 00be 3869     		ldr	r0, [r7, #16]
 138 00c0 FFF7FEFF 		bl	free
 139              	.L2:
 290:../FreeRTOS/Source/queue.c **** 			}
 291:../FreeRTOS/Source/queue.c **** 		}
 292:../FreeRTOS/Source/queue.c **** 	}
 293:../FreeRTOS/Source/queue.c **** 
 294:../FreeRTOS/Source/queue.c **** 	configASSERT( xReturn );
 295:../FreeRTOS/Source/queue.c **** 
 296:../FreeRTOS/Source/queue.c **** 	return xReturn;
 140              		.loc 1 296 0
 141 00c4 7B69     		ldr	r3, [r7, #20]
 297:../FreeRTOS/Source/queue.c **** }
 142              		.loc 1 297 0
 143 00c6 1846     		mov	r0, r3
 144 00c8 07F11807 		add	r7, r7, #24
 145 00cc BD46     		mov	sp, r7
 146 00ce 80BD     		pop	{r7, pc}
 147              		.cfi_endproc
 148              	.LFE110:
 150              		.align	2
 151              		.global	xQueueCreateMutex
 152              		.thumb
 153              		.thumb_func
 155              	xQueueCreateMutex:
 156              	.LFB111:
 298:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 299:../FreeRTOS/Source/queue.c **** 
 300:../FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 301:../FreeRTOS/Source/queue.c **** 
 302:../FreeRTOS/Source/queue.c **** 	xQueueHandle xQueueCreateMutex( void )
 303:../FreeRTOS/Source/queue.c **** 	{
 157              		.loc 1 303 0
 158              		.cfi_startproc
 159              		@ args = 0, pretend = 0, frame = 8
 160              		@ frame_needed = 1, uses_anonymous_args = 0
 161 00d0 80B5     		push	{r7, lr}
 162              	.LCFI3:
 163              		.cfi_def_cfa_offset 8
 164              		.cfi_offset 14, -4
 165              		.cfi_offset 7, -8
 166 00d2 82B0     		sub	sp, sp, #8
 167              	.LCFI4:
 168              		.cfi_def_cfa_offset 16
 169 00d4 00AF     		add	r7, sp, #0
 170              	.LCFI5:
 171              		.cfi_def_cfa_register 7
 304:../FreeRTOS/Source/queue.c **** 	xQUEUE *pxNewQueue;
 305:../FreeRTOS/Source/queue.c **** 
 306:../FreeRTOS/Source/queue.c **** 		/* Allocate the new queue structure. */
 307:../FreeRTOS/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 172              		.loc 1 307 0
 173 00d6 4FF04C00 		mov	r0, #76
 174 00da FFF7FEFF 		bl	malloc
 175 00de 0346     		mov	r3, r0
 176 00e0 7B60     		str	r3, [r7, #4]
 308:../FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 177              		.loc 1 308 0
 178 00e2 7B68     		ldr	r3, [r7, #4]
 179 00e4 002B     		cmp	r3, #0
 180 00e6 38D0     		beq	.L5
 309:../FreeRTOS/Source/queue.c **** 		{
 310:../FreeRTOS/Source/queue.c **** 			/* Information required for priority inheritance. */
 311:../FreeRTOS/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 181              		.loc 1 311 0
 182 00e8 7B68     		ldr	r3, [r7, #4]
 183 00ea 4FF00002 		mov	r2, #0
 184 00ee 5A60     		str	r2, [r3, #4]
 312:../FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 185              		.loc 1 312 0
 186 00f0 7B68     		ldr	r3, [r7, #4]
 187 00f2 4FF00002 		mov	r2, #0
 188 00f6 1A60     		str	r2, [r3, #0]
 313:../FreeRTOS/Source/queue.c **** 
 314:../FreeRTOS/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 315:../FreeRTOS/Source/queue.c **** 			of the queue. */
 316:../FreeRTOS/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 189              		.loc 1 316 0
 190 00f8 7B68     		ldr	r3, [r7, #4]
 191 00fa 4FF00002 		mov	r2, #0
 192 00fe 9A60     		str	r2, [r3, #8]
 317:../FreeRTOS/Source/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 193              		.loc 1 317 0
 194 0100 7B68     		ldr	r3, [r7, #4]
 195 0102 4FF00002 		mov	r2, #0
 196 0106 DA60     		str	r2, [r3, #12]
 318:../FreeRTOS/Source/queue.c **** 
 319:../FreeRTOS/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 320:../FreeRTOS/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 321:../FreeRTOS/Source/queue.c **** 			of the mutex. */
 322:../FreeRTOS/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 197              		.loc 1 322 0
 198 0108 7B68     		ldr	r3, [r7, #4]
 199 010a 4FF00002 		mov	r2, #0
 200 010e 9A63     		str	r2, [r3, #56]
 323:../FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 201              		.loc 1 323 0
 202 0110 7B68     		ldr	r3, [r7, #4]
 203 0112 4FF00102 		mov	r2, #1
 204 0116 DA63     		str	r2, [r3, #60]
 324:../FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 205              		.loc 1 324 0
 206 0118 7B68     		ldr	r3, [r7, #4]
 207 011a 4FF00002 		mov	r2, #0
 208 011e 1A64     		str	r2, [r3, #64]
 325:../FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 209              		.loc 1 325 0
 210 0120 7B68     		ldr	r3, [r7, #4]
 211 0122 4FF0FF32 		mov	r2, #-1
 212 0126 5A64     		str	r2, [r3, #68]
 326:../FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 213              		.loc 1 326 0
 214 0128 7B68     		ldr	r3, [r7, #4]
 215 012a 4FF0FF32 		mov	r2, #-1
 216 012e 9A64     		str	r2, [r3, #72]
 327:../FreeRTOS/Source/queue.c **** 
 328:../FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 329:../FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 217              		.loc 1 329 0
 218 0130 7B68     		ldr	r3, [r7, #4]
 219 0132 03F11003 		add	r3, r3, #16
 220 0136 1846     		mov	r0, r3
 221 0138 FFF7FEFF 		bl	vListInitialise
 330:../FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 222              		.loc 1 330 0
 223 013c 7B68     		ldr	r3, [r7, #4]
 224 013e 03F12403 		add	r3, r3, #36
 225 0142 1846     		mov	r0, r3
 226 0144 FFF7FEFF 		bl	vListInitialise
 331:../FreeRTOS/Source/queue.c **** 
 332:../FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 333:../FreeRTOS/Source/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 227              		.loc 1 333 0
 228 0148 7868     		ldr	r0, [r7, #4]
 229 014a 4FF00001 		mov	r1, #0
 230 014e 4FF00002 		mov	r2, #0
 231 0152 4FF00003 		mov	r3, #0
 232 0156 FFF7FEFF 		bl	xQueueGenericSend
 233              	.L5:
 334:../FreeRTOS/Source/queue.c **** 
 335:../FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 336:../FreeRTOS/Source/queue.c **** 		}
 337:../FreeRTOS/Source/queue.c **** 		else
 338:../FreeRTOS/Source/queue.c **** 		{
 339:../FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 340:../FreeRTOS/Source/queue.c **** 		}
 341:../FreeRTOS/Source/queue.c **** 
 342:../FreeRTOS/Source/queue.c **** 		configASSERT( pxNewQueue );
 343:../FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 234              		.loc 1 343 0
 235 015a 7B68     		ldr	r3, [r7, #4]
 344:../FreeRTOS/Source/queue.c **** 	}
 236              		.loc 1 344 0
 237 015c 1846     		mov	r0, r3
 238 015e 07F10807 		add	r7, r7, #8
 239 0162 BD46     		mov	sp, r7
 240 0164 80BD     		pop	{r7, pc}
 241              		.cfi_endproc
 242              	.LFE111:
 244 0166 00BF     		.align	2
 245              		.global	xQueueGenericSend
 246              		.thumb
 247              		.thumb_func
 249              	xQueueGenericSend:
 250              	.LFB112:
 345:../FreeRTOS/Source/queue.c **** 
 346:../FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 347:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 348:../FreeRTOS/Source/queue.c **** 
 349:../FreeRTOS/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 350:../FreeRTOS/Source/queue.c **** 
 351:../FreeRTOS/Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 352:../FreeRTOS/Source/queue.c **** 	{
 353:../FreeRTOS/Source/queue.c **** 	portBASE_TYPE xReturn;
 354:../FreeRTOS/Source/queue.c **** 
 355:../FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 356:../FreeRTOS/Source/queue.c **** 
 357:../FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 358:../FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 359:../FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 360:../FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 361:../FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 362:../FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 363:../FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 364:../FreeRTOS/Source/queue.c **** 		{
 365:../FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 366:../FreeRTOS/Source/queue.c **** 
 367:../FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 368:../FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 369:../FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 370:../FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 371:../FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 372:../FreeRTOS/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 373:../FreeRTOS/Source/queue.c **** 
 374:../FreeRTOS/Source/queue.c **** 			/* Have we unwound the call count? */
 375:../FreeRTOS/Source/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 376:../FreeRTOS/Source/queue.c **** 			{
 377:../FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 378:../FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 379:../FreeRTOS/Source/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 380:../FreeRTOS/Source/queue.c **** 			}
 381:../FreeRTOS/Source/queue.c **** 
 382:../FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 383:../FreeRTOS/Source/queue.c **** 		}
 384:../FreeRTOS/Source/queue.c **** 		else
 385:../FreeRTOS/Source/queue.c **** 		{
 386:../FreeRTOS/Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 387:../FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 388:../FreeRTOS/Source/queue.c **** 
 389:../FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 390:../FreeRTOS/Source/queue.c **** 		}
 391:../FreeRTOS/Source/queue.c **** 
 392:../FreeRTOS/Source/queue.c **** 		return xReturn;
 393:../FreeRTOS/Source/queue.c **** 	}
 394:../FreeRTOS/Source/queue.c **** 
 395:../FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 396:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 397:../FreeRTOS/Source/queue.c **** 
 398:../FreeRTOS/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 399:../FreeRTOS/Source/queue.c **** 
 400:../FreeRTOS/Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 401:../FreeRTOS/Source/queue.c **** 	{
 402:../FreeRTOS/Source/queue.c **** 	portBASE_TYPE xReturn;
 403:../FreeRTOS/Source/queue.c **** 
 404:../FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 405:../FreeRTOS/Source/queue.c **** 
 406:../FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 407:../FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 408:../FreeRTOS/Source/queue.c **** 
 409:../FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 410:../FreeRTOS/Source/queue.c **** 
 411:../FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 412:../FreeRTOS/Source/queue.c **** 		{
 413:../FreeRTOS/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 414:../FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 415:../FreeRTOS/Source/queue.c **** 		}
 416:../FreeRTOS/Source/queue.c **** 		else
 417:../FreeRTOS/Source/queue.c **** 		{
 418:../FreeRTOS/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 419:../FreeRTOS/Source/queue.c **** 
 420:../FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 421:../FreeRTOS/Source/queue.c **** 			we may have blocked to reach here. */
 422:../FreeRTOS/Source/queue.c **** 			if( xReturn == pdPASS )
 423:../FreeRTOS/Source/queue.c **** 			{
 424:../FreeRTOS/Source/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 425:../FreeRTOS/Source/queue.c **** 			}
 426:../FreeRTOS/Source/queue.c **** 			else
 427:../FreeRTOS/Source/queue.c **** 			{
 428:../FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 429:../FreeRTOS/Source/queue.c **** 			}
 430:../FreeRTOS/Source/queue.c **** 		}
 431:../FreeRTOS/Source/queue.c **** 
 432:../FreeRTOS/Source/queue.c **** 		return xReturn;
 433:../FreeRTOS/Source/queue.c **** 	}
 434:../FreeRTOS/Source/queue.c **** 
 435:../FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 436:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 437:../FreeRTOS/Source/queue.c **** 
 438:../FreeRTOS/Source/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 439:../FreeRTOS/Source/queue.c **** 
 440:../FreeRTOS/Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 441:../FreeRTOS/Source/queue.c **** 	{
 442:../FreeRTOS/Source/queue.c **** 	xQueueHandle pxHandle;
 443:../FreeRTOS/Source/queue.c **** 
 444:../FreeRTOS/Source/queue.c **** 		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGT
 445:../FreeRTOS/Source/queue.c **** 
 446:../FreeRTOS/Source/queue.c **** 		if( pxHandle != NULL )
 447:../FreeRTOS/Source/queue.c **** 		{
 448:../FreeRTOS/Source/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 449:../FreeRTOS/Source/queue.c **** 
 450:../FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 451:../FreeRTOS/Source/queue.c **** 		}
 452:../FreeRTOS/Source/queue.c **** 		else
 453:../FreeRTOS/Source/queue.c **** 		{
 454:../FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 455:../FreeRTOS/Source/queue.c **** 		}
 456:../FreeRTOS/Source/queue.c **** 
 457:../FreeRTOS/Source/queue.c **** 		configASSERT( pxHandle );
 458:../FreeRTOS/Source/queue.c **** 		return pxHandle;
 459:../FreeRTOS/Source/queue.c **** 	}
 460:../FreeRTOS/Source/queue.c **** 
 461:../FreeRTOS/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 462:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 463:../FreeRTOS/Source/queue.c **** 
 464:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 465:../FreeRTOS/Source/queue.c **** {
 251              		.loc 1 465 0
 252              		.cfi_startproc
 253              		@ args = 0, pretend = 0, frame = 32
 254              		@ frame_needed = 1, uses_anonymous_args = 0
 255 0168 80B5     		push	{r7, lr}
 256              	.LCFI6:
 257              		.cfi_def_cfa_offset 8
 258              		.cfi_offset 14, -4
 259              		.cfi_offset 7, -8
 260 016a 88B0     		sub	sp, sp, #32
 261              	.LCFI7:
 262              		.cfi_def_cfa_offset 40
 263 016c 00AF     		add	r7, sp, #0
 264              	.LCFI8:
 265              		.cfi_def_cfa_register 7
 266 016e F860     		str	r0, [r7, #12]
 267 0170 B960     		str	r1, [r7, #8]
 268 0172 7A60     		str	r2, [r7, #4]
 269 0174 3B60     		str	r3, [r7, #0]
 466:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 270              		.loc 1 466 0
 271 0176 4FF00003 		mov	r3, #0
 272 017a FB61     		str	r3, [r7, #28]
 273 017c 00E0     		b	.L17
 274              	.L18:
 467:../FreeRTOS/Source/queue.c **** xTimeOutType xTimeOut;
 468:../FreeRTOS/Source/queue.c **** 
 469:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 470:../FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 471:../FreeRTOS/Source/queue.c **** 
 472:../FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 473:../FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 474:../FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 475:../FreeRTOS/Source/queue.c **** 	for( ;; )
 476:../FreeRTOS/Source/queue.c **** 	{
 477:../FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 478:../FreeRTOS/Source/queue.c **** 		{
 479:../FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 480:../FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 481:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 482:../FreeRTOS/Source/queue.c **** 			{
 483:../FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 484:../FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 485:../FreeRTOS/Source/queue.c **** 
 486:../FreeRTOS/Source/queue.c **** 				/* If there was a task waiting for data to arrive on the
 487:../FreeRTOS/Source/queue.c **** 				queue then unblock it now. */
 488:../FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 489:../FreeRTOS/Source/queue.c **** 				{
 490:../FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 491:../FreeRTOS/Source/queue.c **** 					{
 492:../FreeRTOS/Source/queue.c **** 						/* The unblocked task has a priority higher than
 493:../FreeRTOS/Source/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 494:../FreeRTOS/Source/queue.c **** 						this from within the critical section - the kernel
 495:../FreeRTOS/Source/queue.c **** 						takes care of that. */
 496:../FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 497:../FreeRTOS/Source/queue.c **** 					}
 498:../FreeRTOS/Source/queue.c **** 				}
 499:../FreeRTOS/Source/queue.c **** 
 500:../FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 501:../FreeRTOS/Source/queue.c **** 
 502:../FreeRTOS/Source/queue.c **** 				/* Return to the original privilege level before exiting the
 503:../FreeRTOS/Source/queue.c **** 				function. */
 504:../FreeRTOS/Source/queue.c **** 				return pdPASS;
 505:../FreeRTOS/Source/queue.c **** 			}
 506:../FreeRTOS/Source/queue.c **** 			else
 507:../FreeRTOS/Source/queue.c **** 			{
 508:../FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 509:../FreeRTOS/Source/queue.c **** 				{
 510:../FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 511:../FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 512:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 513:../FreeRTOS/Source/queue.c **** 
 514:../FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 515:../FreeRTOS/Source/queue.c **** 					the function. */
 516:../FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 517:../FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 518:../FreeRTOS/Source/queue.c **** 				}
 519:../FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 520:../FreeRTOS/Source/queue.c **** 				{
 521:../FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 522:../FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 523:../FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 524:../FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 525:../FreeRTOS/Source/queue.c **** 				}
 526:../FreeRTOS/Source/queue.c **** 			}
 527:../FreeRTOS/Source/queue.c **** 		}
 528:../FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 529:../FreeRTOS/Source/queue.c **** 
 530:../FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 531:../FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 532:../FreeRTOS/Source/queue.c **** 
 533:../FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 535:../FreeRTOS/Source/queue.c **** 
 536:../FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 537:../FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 538:../FreeRTOS/Source/queue.c **** 		{
 539:../FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 540:../FreeRTOS/Source/queue.c **** 			{
 541:../FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 542:../FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 543:../FreeRTOS/Source/queue.c **** 
 544:../FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 545:../FreeRTOS/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 546:../FreeRTOS/Source/queue.c **** 				remove this task from the event	list again - but as the
 547:../FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 548:../FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 549:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 550:../FreeRTOS/Source/queue.c **** 
 551:../FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 552:../FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 553:../FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 554:../FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 555:../FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 556:../FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 557:../FreeRTOS/Source/queue.c **** 				{
 558:../FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 559:../FreeRTOS/Source/queue.c **** 				}
 560:../FreeRTOS/Source/queue.c **** 			}
 561:../FreeRTOS/Source/queue.c **** 			else
 562:../FreeRTOS/Source/queue.c **** 			{
 563:../FreeRTOS/Source/queue.c **** 				/* Try again. */
 564:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 565:../FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 566:../FreeRTOS/Source/queue.c **** 			}
 567:../FreeRTOS/Source/queue.c **** 		}
 568:../FreeRTOS/Source/queue.c **** 		else
 569:../FreeRTOS/Source/queue.c **** 		{
 570:../FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 571:../FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 572:../FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 573:../FreeRTOS/Source/queue.c **** 
 574:../FreeRTOS/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 575:../FreeRTOS/Source/queue.c **** 			function. */
 576:../FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 577:../FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 578:../FreeRTOS/Source/queue.c **** 		}
 579:../FreeRTOS/Source/queue.c **** 	}
 275              		.loc 1 579 0
 276 017e 00BF     		nop
 277              	.L17:
 477:../FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 278              		.loc 1 477 0
 279 0180 FFF7FEFF 		bl	vPortEnterCritical
 481:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 280              		.loc 1 481 0
 281 0184 FB68     		ldr	r3, [r7, #12]
 282 0186 9B6B     		ldr	r3, [r3, #56]
 283 0188 1A46     		mov	r2, r3
 284 018a FB68     		ldr	r3, [r7, #12]
 285 018c DB6B     		ldr	r3, [r3, #60]
 286 018e 9A42     		cmp	r2, r3
 287 0190 18D2     		bcs	.L7
 484:../FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 288              		.loc 1 484 0
 289 0192 F868     		ldr	r0, [r7, #12]
 290 0194 B968     		ldr	r1, [r7, #8]
 291 0196 3A68     		ldr	r2, [r7, #0]
 292 0198 00F0FEF9 		bl	prvCopyDataToQueue
 488:../FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 293              		.loc 1 488 0
 294 019c FB68     		ldr	r3, [r7, #12]
 295 019e 5B6A     		ldr	r3, [r3, #36]
 296 01a0 002B     		cmp	r3, #0
 297 01a2 0AD0     		beq	.L8
 490:../FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 298              		.loc 1 490 0
 299 01a4 FB68     		ldr	r3, [r7, #12]
 300 01a6 03F12403 		add	r3, r3, #36
 301 01aa 1846     		mov	r0, r3
 302 01ac FFF7FEFF 		bl	xTaskRemoveFromEventList
 303 01b0 0346     		mov	r3, r0
 304 01b2 012B     		cmp	r3, #1
 305 01b4 01D1     		bne	.L8
 496:../FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 306              		.loc 1 496 0
 307 01b6 FFF7FEFF 		bl	vPortYieldFromISR
 308              	.L8:
 500:../FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 309              		.loc 1 500 0
 310 01ba FFF7FEFF 		bl	vPortExitCritical
 504:../FreeRTOS/Source/queue.c **** 				return pdPASS;
 311              		.loc 1 504 0
 312 01be 4FF00103 		mov	r3, #1
 313 01c2 5DE0     		b	.L9
 314              	.L7:
 508:../FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 315              		.loc 1 508 0
 316 01c4 7B68     		ldr	r3, [r7, #4]
 317 01c6 002B     		cmp	r3, #0
 318 01c8 04D1     		bne	.L10
 512:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 319              		.loc 1 512 0
 320 01ca FFF7FEFF 		bl	vPortExitCritical
 517:../FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 321              		.loc 1 517 0
 322 01ce 4FF00003 		mov	r3, #0
 323 01d2 55E0     		b	.L9
 324              	.L10:
 519:../FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 325              		.loc 1 519 0
 326 01d4 FB69     		ldr	r3, [r7, #28]
 327 01d6 002B     		cmp	r3, #0
 328 01d8 07D1     		bne	.L11
 523:../FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 329              		.loc 1 523 0
 330 01da 07F11403 		add	r3, r7, #20
 331 01de 1846     		mov	r0, r3
 332 01e0 FFF7FEFF 		bl	vTaskSetTimeOutState
 524:../FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 333              		.loc 1 524 0
 334 01e4 4FF00103 		mov	r3, #1
 335 01e8 FB61     		str	r3, [r7, #28]
 336              	.L11:
 528:../FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 337              		.loc 1 528 0
 338 01ea FFF7FEFF 		bl	vPortExitCritical
 533:../FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 339              		.loc 1 533 0
 340 01ee FFF7FEFF 		bl	vTaskSuspendAll
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 341              		.loc 1 534 0
 342 01f2 FFF7FEFF 		bl	vPortEnterCritical
 343 01f6 FB68     		ldr	r3, [r7, #12]
 344 01f8 5B6C     		ldr	r3, [r3, #68]
 345 01fa B3F1FF3F 		cmp	r3, #-1
 346 01fe 03D1     		bne	.L12
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 347              		.loc 1 534 0 is_stmt 0 discriminator 1
 348 0200 FB68     		ldr	r3, [r7, #12]
 349 0202 4FF00002 		mov	r2, #0
 350 0206 5A64     		str	r2, [r3, #68]
 351              	.L12:
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 352              		.loc 1 534 0 discriminator 2
 353 0208 FB68     		ldr	r3, [r7, #12]
 354 020a 9B6C     		ldr	r3, [r3, #72]
 355 020c B3F1FF3F 		cmp	r3, #-1
 356 0210 03D1     		bne	.L13
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 357              		.loc 1 534 0 discriminator 3
 358 0212 FB68     		ldr	r3, [r7, #12]
 359 0214 4FF00002 		mov	r2, #0
 360 0218 9A64     		str	r2, [r3, #72]
 361              	.L13:
 534:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 362              		.loc 1 534 0 discriminator 4
 363 021a FFF7FEFF 		bl	vPortExitCritical
 537:../FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 364              		.loc 1 537 0 is_stmt 1 discriminator 4
 365 021e 07F11402 		add	r2, r7, #20
 366 0222 07F10403 		add	r3, r7, #4
 367 0226 1046     		mov	r0, r2
 368 0228 1946     		mov	r1, r3
 369 022a FFF7FEFF 		bl	xTaskCheckForTimeOut
 370 022e 0346     		mov	r3, r0
 371 0230 002B     		cmp	r3, #0
 372 0232 1ED1     		bne	.L14
 539:../FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 373              		.loc 1 539 0
 374 0234 F868     		ldr	r0, [r7, #12]
 375 0236 00F0B3FA 		bl	prvIsQueueFull
 376 023a 0346     		mov	r3, r0
 377 023c 002B     		cmp	r3, #0
 378 023e 12D0     		beq	.L15
 542:../FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 379              		.loc 1 542 0
 380 0240 FB68     		ldr	r3, [r7, #12]
 381 0242 03F11002 		add	r2, r3, #16
 382 0246 7B68     		ldr	r3, [r7, #4]
 383 0248 1046     		mov	r0, r2
 384 024a 1946     		mov	r1, r3
 385 024c FFF7FEFF 		bl	vTaskPlaceOnEventList
 549:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 386              		.loc 1 549 0
 387 0250 F868     		ldr	r0, [r7, #12]
 388 0252 00F02DFA 		bl	prvUnlockQueue
 556:../FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 389              		.loc 1 556 0
 390 0256 FFF7FEFF 		bl	xTaskResumeAll
 391 025a 0346     		mov	r3, r0
 392 025c 002B     		cmp	r3, #0
 393 025e 8ED1     		bne	.L18
 558:../FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 394              		.loc 1 558 0
 395 0260 FFF7FEFF 		bl	vPortYieldFromISR
 396              		.loc 1 579 0
 397 0264 8BE7     		b	.L18
 398              	.L15:
 564:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 399              		.loc 1 564 0
 400 0266 F868     		ldr	r0, [r7, #12]
 401 0268 00F022FA 		bl	prvUnlockQueue
 565:../FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 402              		.loc 1 565 0
 403 026c FFF7FEFF 		bl	xTaskResumeAll
 404              		.loc 1 579 0
 405 0270 85E7     		b	.L18
 406              	.L14:
 571:../FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 407              		.loc 1 571 0
 408 0272 F868     		ldr	r0, [r7, #12]
 409 0274 00F01CFA 		bl	prvUnlockQueue
 572:../FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 410              		.loc 1 572 0
 411 0278 FFF7FEFF 		bl	xTaskResumeAll
 577:../FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 412              		.loc 1 577 0
 413 027c 4FF00003 		mov	r3, #0
 414              	.L9:
 580:../FreeRTOS/Source/queue.c **** }
 415              		.loc 1 580 0
 416 0280 1846     		mov	r0, r3
 417 0282 07F12007 		add	r7, r7, #32
 418 0286 BD46     		mov	sp, r7
 419 0288 80BD     		pop	{r7, pc}
 420              		.cfi_endproc
 421              	.LFE112:
 423 028a 00BF     		.align	2
 424              		.global	xQueueGenericSendFromISR
 425              		.thumb
 426              		.thumb_func
 428              	xQueueGenericSendFromISR:
 429              	.LFB113:
 581:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 582:../FreeRTOS/Source/queue.c **** 
 583:../FreeRTOS/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 584:../FreeRTOS/Source/queue.c **** 
 585:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 586:../FreeRTOS/Source/queue.c **** 	{
 587:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 588:../FreeRTOS/Source/queue.c **** 	xTimeOutType xTimeOut;
 589:../FreeRTOS/Source/queue.c **** 
 590:../FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 591:../FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 592:../FreeRTOS/Source/queue.c **** 
 593:../FreeRTOS/Source/queue.c **** 		for( ;; )
 594:../FreeRTOS/Source/queue.c **** 		{
 595:../FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 596:../FreeRTOS/Source/queue.c **** 			{
 597:../FreeRTOS/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 598:../FreeRTOS/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 599:../FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 600:../FreeRTOS/Source/queue.c **** 				{
 601:../FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 602:../FreeRTOS/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 603:../FreeRTOS/Source/queue.c **** 
 604:../FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 605:../FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 606:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 607:../FreeRTOS/Source/queue.c **** 					{
 608:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 609:../FreeRTOS/Source/queue.c **** 						{
 610:../FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 611:../FreeRTOS/Source/queue.c **** 							our own so yield immediately. */
 612:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 613:../FreeRTOS/Source/queue.c **** 						}
 614:../FreeRTOS/Source/queue.c **** 					}
 615:../FreeRTOS/Source/queue.c **** 
 616:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 617:../FreeRTOS/Source/queue.c **** 					return pdPASS;
 618:../FreeRTOS/Source/queue.c **** 				}
 619:../FreeRTOS/Source/queue.c **** 				else
 620:../FreeRTOS/Source/queue.c **** 				{
 621:../FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 622:../FreeRTOS/Source/queue.c **** 					{
 623:../FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 624:../FreeRTOS/Source/queue.c **** 						return errQUEUE_FULL;
 625:../FreeRTOS/Source/queue.c **** 					}
 626:../FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 627:../FreeRTOS/Source/queue.c **** 					{
 628:../FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 629:../FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 630:../FreeRTOS/Source/queue.c **** 					}
 631:../FreeRTOS/Source/queue.c **** 				}
 632:../FreeRTOS/Source/queue.c **** 			}
 633:../FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 634:../FreeRTOS/Source/queue.c **** 
 635:../FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 636:../FreeRTOS/Source/queue.c **** 			{
 637:../FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 638:../FreeRTOS/Source/queue.c **** 				{
 639:../FreeRTOS/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 640:../FreeRTOS/Source/queue.c **** 					{
 641:../FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 642:../FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 643:../FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 644:../FreeRTOS/Source/queue.c **** 					}
 645:../FreeRTOS/Source/queue.c **** 				}
 646:../FreeRTOS/Source/queue.c **** 				else
 647:../FreeRTOS/Source/queue.c **** 				{
 648:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 649:../FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 650:../FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 651:../FreeRTOS/Source/queue.c **** 				}
 652:../FreeRTOS/Source/queue.c **** 			}
 653:../FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 654:../FreeRTOS/Source/queue.c **** 		}
 655:../FreeRTOS/Source/queue.c **** 	}
 656:../FreeRTOS/Source/queue.c **** 
 657:../FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 658:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 659:../FreeRTOS/Source/queue.c **** 
 660:../FreeRTOS/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 661:../FreeRTOS/Source/queue.c **** 
 662:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 663:../FreeRTOS/Source/queue.c **** 	{
 664:../FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 665:../FreeRTOS/Source/queue.c **** 	xTimeOutType xTimeOut;
 666:../FreeRTOS/Source/queue.c **** 	signed char *pcOriginalReadPosition;
 667:../FreeRTOS/Source/queue.c **** 
 668:../FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 669:../FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 670:../FreeRTOS/Source/queue.c **** 
 671:../FreeRTOS/Source/queue.c **** 		for( ;; )
 672:../FreeRTOS/Source/queue.c **** 		{
 673:../FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 674:../FreeRTOS/Source/queue.c **** 			{
 675:../FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 676:../FreeRTOS/Source/queue.c **** 				{
 677:../FreeRTOS/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 678:../FreeRTOS/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 679:../FreeRTOS/Source/queue.c **** 
 680:../FreeRTOS/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 681:../FreeRTOS/Source/queue.c **** 
 682:../FreeRTOS/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 683:../FreeRTOS/Source/queue.c **** 					{
 684:../FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 685:../FreeRTOS/Source/queue.c **** 
 686:../FreeRTOS/Source/queue.c **** 						/* We are actually removing data. */
 687:../FreeRTOS/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 688:../FreeRTOS/Source/queue.c **** 
 689:../FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 690:../FreeRTOS/Source/queue.c **** 						{
 691:../FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 692:../FreeRTOS/Source/queue.c **** 							{
 693:../FreeRTOS/Source/queue.c **** 								/* Record the information required to implement
 694:../FreeRTOS/Source/queue.c **** 								priority inheritance should it become necessary. */
 695:../FreeRTOS/Source/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 696:../FreeRTOS/Source/queue.c **** 							}
 697:../FreeRTOS/Source/queue.c **** 						}
 698:../FreeRTOS/Source/queue.c **** 						#endif
 699:../FreeRTOS/Source/queue.c **** 
 700:../FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 701:../FreeRTOS/Source/queue.c **** 						{
 702:../FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 703:../FreeRTOS/Source/queue.c **** 							{
 704:../FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 705:../FreeRTOS/Source/queue.c **** 							}
 706:../FreeRTOS/Source/queue.c **** 						}
 707:../FreeRTOS/Source/queue.c **** 					}
 708:../FreeRTOS/Source/queue.c **** 					else
 709:../FreeRTOS/Source/queue.c **** 					{
 710:../FreeRTOS/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 711:../FreeRTOS/Source/queue.c **** 
 712:../FreeRTOS/Source/queue.c **** 						/* We are not removing the data, so reset our read
 713:../FreeRTOS/Source/queue.c **** 						pointer. */
 714:../FreeRTOS/Source/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 715:../FreeRTOS/Source/queue.c **** 
 716:../FreeRTOS/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 717:../FreeRTOS/Source/queue.c **** 						any other tasks waiting for the data. */
 718:../FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 719:../FreeRTOS/Source/queue.c **** 						{
 720:../FreeRTOS/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 721:../FreeRTOS/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 722:../FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 723:../FreeRTOS/Source/queue.c **** 							{
 724:../FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 725:../FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 726:../FreeRTOS/Source/queue.c **** 							}
 727:../FreeRTOS/Source/queue.c **** 						}
 728:../FreeRTOS/Source/queue.c **** 
 729:../FreeRTOS/Source/queue.c **** 					}
 730:../FreeRTOS/Source/queue.c **** 
 731:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 732:../FreeRTOS/Source/queue.c **** 					return pdPASS;
 733:../FreeRTOS/Source/queue.c **** 				}
 734:../FreeRTOS/Source/queue.c **** 				else
 735:../FreeRTOS/Source/queue.c **** 				{
 736:../FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 737:../FreeRTOS/Source/queue.c **** 					{
 738:../FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 739:../FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 740:../FreeRTOS/Source/queue.c **** 						return errQUEUE_EMPTY;
 741:../FreeRTOS/Source/queue.c **** 					}
 742:../FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 743:../FreeRTOS/Source/queue.c **** 					{
 744:../FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 745:../FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 746:../FreeRTOS/Source/queue.c **** 					}
 747:../FreeRTOS/Source/queue.c **** 				}
 748:../FreeRTOS/Source/queue.c **** 			}
 749:../FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 750:../FreeRTOS/Source/queue.c **** 
 751:../FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 752:../FreeRTOS/Source/queue.c **** 			{
 753:../FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 754:../FreeRTOS/Source/queue.c **** 				{
 755:../FreeRTOS/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 756:../FreeRTOS/Source/queue.c **** 					{
 757:../FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 758:../FreeRTOS/Source/queue.c **** 
 759:../FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 760:../FreeRTOS/Source/queue.c **** 						{
 761:../FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 762:../FreeRTOS/Source/queue.c **** 							{
 763:../FreeRTOS/Source/queue.c **** 								portENTER_CRITICAL();
 764:../FreeRTOS/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 765:../FreeRTOS/Source/queue.c **** 								portEXIT_CRITICAL();
 766:../FreeRTOS/Source/queue.c **** 							}
 767:../FreeRTOS/Source/queue.c **** 						}
 768:../FreeRTOS/Source/queue.c **** 						#endif
 769:../FreeRTOS/Source/queue.c **** 
 770:../FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 771:../FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 772:../FreeRTOS/Source/queue.c **** 					}
 773:../FreeRTOS/Source/queue.c **** 				}
 774:../FreeRTOS/Source/queue.c **** 				else
 775:../FreeRTOS/Source/queue.c **** 				{
 776:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 777:../FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 778:../FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 779:../FreeRTOS/Source/queue.c **** 				}
 780:../FreeRTOS/Source/queue.c **** 			}
 781:../FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 782:../FreeRTOS/Source/queue.c **** 		}
 783:../FreeRTOS/Source/queue.c **** 	}
 784:../FreeRTOS/Source/queue.c **** 
 785:../FreeRTOS/Source/queue.c **** 
 786:../FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 787:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 788:../FreeRTOS/Source/queue.c **** 
 789:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 790:../FreeRTOS/Source/queue.c **** {
 430              		.loc 1 790 0
 431              		.cfi_startproc
 432              		@ args = 0, pretend = 0, frame = 24
 433              		@ frame_needed = 1, uses_anonymous_args = 0
 434 028c 80B5     		push	{r7, lr}
 435              	.LCFI9:
 436              		.cfi_def_cfa_offset 8
 437              		.cfi_offset 14, -4
 438              		.cfi_offset 7, -8
 439 028e 86B0     		sub	sp, sp, #24
 440              	.LCFI10:
 441              		.cfi_def_cfa_offset 32
 442 0290 00AF     		add	r7, sp, #0
 443              	.LCFI11:
 444              		.cfi_def_cfa_register 7
 445 0292 F860     		str	r0, [r7, #12]
 446 0294 B960     		str	r1, [r7, #8]
 447 0296 7A60     		str	r2, [r7, #4]
 448 0298 3B60     		str	r3, [r7, #0]
 791:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
 792:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 793:../FreeRTOS/Source/queue.c **** 
 794:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 795:../FreeRTOS/Source/queue.c **** 	configASSERT( pxHigherPriorityTaskWoken );
 796:../FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 797:../FreeRTOS/Source/queue.c **** 
 798:../FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 799:../FreeRTOS/Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 800:../FreeRTOS/Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 801:../FreeRTOS/Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 802:../FreeRTOS/Source/queue.c **** 	by this	post). */
 803:../FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 449              		.loc 1 803 0
 450 029a 4FF00003 		mov	r3, #0
 451 029e 3B61     		str	r3, [r7, #16]
 452              	@ 803 "../FreeRTOS/Source/queue.c" 1
 453 02a0 4FF0BF00 			mov r0, #191								
 454 02a4 80F31188 		msr basepri, r0							
 455              	
 456              	@ 0 "" 2
 804:../FreeRTOS/Source/queue.c **** 	{
 805:../FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 457              		.loc 1 805 0
 458              		.thumb
 459 02a8 FB68     		ldr	r3, [r7, #12]
 460 02aa 9B6B     		ldr	r3, [r3, #56]
 461 02ac 1A46     		mov	r2, r3
 462 02ae FB68     		ldr	r3, [r7, #12]
 463 02b0 DB6B     		ldr	r3, [r3, #60]
 464 02b2 9A42     		cmp	r2, r3
 465 02b4 25D2     		bcs	.L20
 806:../FreeRTOS/Source/queue.c **** 		{
 807:../FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 808:../FreeRTOS/Source/queue.c **** 
 809:../FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 466              		.loc 1 809 0
 467 02b6 F868     		ldr	r0, [r7, #12]
 468 02b8 B968     		ldr	r1, [r7, #8]
 469 02ba 3A68     		ldr	r2, [r7, #0]
 470 02bc 00F06CF9 		bl	prvCopyDataToQueue
 810:../FreeRTOS/Source/queue.c **** 
 811:../FreeRTOS/Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 812:../FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
 813:../FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 471              		.loc 1 813 0
 472 02c0 FB68     		ldr	r3, [r7, #12]
 473 02c2 9B6C     		ldr	r3, [r3, #72]
 474 02c4 B3F1FF3F 		cmp	r3, #-1
 475 02c8 11D1     		bne	.L21
 814:../FreeRTOS/Source/queue.c **** 			{
 815:../FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 476              		.loc 1 815 0
 477 02ca FB68     		ldr	r3, [r7, #12]
 478 02cc 5B6A     		ldr	r3, [r3, #36]
 479 02ce 002B     		cmp	r3, #0
 480 02d0 13D0     		beq	.L22
 816:../FreeRTOS/Source/queue.c **** 				{
 817:../FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 481              		.loc 1 817 0
 482 02d2 FB68     		ldr	r3, [r7, #12]
 483 02d4 03F12403 		add	r3, r3, #36
 484 02d8 1846     		mov	r0, r3
 485 02da FFF7FEFF 		bl	xTaskRemoveFromEventList
 486 02de 0346     		mov	r3, r0
 487 02e0 002B     		cmp	r3, #0
 488 02e2 0AD0     		beq	.L22
 818:../FreeRTOS/Source/queue.c **** 					{
 819:../FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
 820:../FreeRTOS/Source/queue.c **** 						context	switch is required. */
 821:../FreeRTOS/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 489              		.loc 1 821 0
 490 02e4 7B68     		ldr	r3, [r7, #4]
 491 02e6 4FF00102 		mov	r2, #1
 492 02ea 1A60     		str	r2, [r3, #0]
 493 02ec 05E0     		b	.L22
 494              	.L21:
 822:../FreeRTOS/Source/queue.c **** 					}
 823:../FreeRTOS/Source/queue.c **** 				}
 824:../FreeRTOS/Source/queue.c **** 			}
 825:../FreeRTOS/Source/queue.c **** 			else
 826:../FreeRTOS/Source/queue.c **** 			{
 827:../FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 828:../FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
 829:../FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
 495              		.loc 1 829 0
 496 02ee FB68     		ldr	r3, [r7, #12]
 497 02f0 9B6C     		ldr	r3, [r3, #72]
 498 02f2 03F10102 		add	r2, r3, #1
 499 02f6 FB68     		ldr	r3, [r7, #12]
 500 02f8 9A64     		str	r2, [r3, #72]
 501              	.L22:
 830:../FreeRTOS/Source/queue.c **** 			}
 831:../FreeRTOS/Source/queue.c **** 
 832:../FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 502              		.loc 1 832 0
 503 02fa 4FF00103 		mov	r3, #1
 504 02fe 7B61     		str	r3, [r7, #20]
 505 0300 02E0     		b	.L23
 506              	.L20:
 833:../FreeRTOS/Source/queue.c **** 		}
 834:../FreeRTOS/Source/queue.c **** 		else
 835:../FreeRTOS/Source/queue.c **** 		{
 836:../FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 837:../FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 507              		.loc 1 837 0
 508 0302 4FF00003 		mov	r3, #0
 509 0306 7B61     		str	r3, [r7, #20]
 510              	.L23:
 838:../FreeRTOS/Source/queue.c **** 		}
 839:../FreeRTOS/Source/queue.c **** 	}
 840:../FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 511              		.loc 1 840 0
 512              	@ 840 "../FreeRTOS/Source/queue.c" 1
 513 0308 4FF00000 			mov r0, #0					
 514 030c 80F31188 		msr basepri, r0				
 515              	
 516              	@ 0 "" 2
 841:../FreeRTOS/Source/queue.c **** 
 842:../FreeRTOS/Source/queue.c **** 	return xReturn;
 517              		.loc 1 842 0
 518              		.thumb
 519 0310 7B69     		ldr	r3, [r7, #20]
 843:../FreeRTOS/Source/queue.c **** }
 520              		.loc 1 843 0
 521 0312 1846     		mov	r0, r3
 522 0314 07F11807 		add	r7, r7, #24
 523 0318 BD46     		mov	sp, r7
 524 031a 80BD     		pop	{r7, pc}
 525              		.cfi_endproc
 526              	.LFE113:
 528              		.align	2
 529              		.global	xQueueGenericReceive
 530              		.thumb
 531              		.thumb_func
 533              	xQueueGenericReceive:
 534              	.LFB114:
 844:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 845:../FreeRTOS/Source/queue.c **** 
 846:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 847:../FreeRTOS/Source/queue.c **** {
 535              		.loc 1 847 0
 536              		.cfi_startproc
 537              		@ args = 0, pretend = 0, frame = 32
 538              		@ frame_needed = 1, uses_anonymous_args = 0
 539 031c 80B5     		push	{r7, lr}
 540              	.LCFI12:
 541              		.cfi_def_cfa_offset 8
 542              		.cfi_offset 14, -4
 543              		.cfi_offset 7, -8
 544 031e 88B0     		sub	sp, sp, #32
 545              	.LCFI13:
 546              		.cfi_def_cfa_offset 40
 547 0320 00AF     		add	r7, sp, #0
 548              	.LCFI14:
 549              		.cfi_def_cfa_register 7
 550 0322 F860     		str	r0, [r7, #12]
 551 0324 B960     		str	r1, [r7, #8]
 552 0326 7A60     		str	r2, [r7, #4]
 553 0328 3B60     		str	r3, [r7, #0]
 848:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 554              		.loc 1 848 0
 555 032a 4FF00003 		mov	r3, #0
 556 032e FB61     		str	r3, [r7, #28]
 557 0330 00E0     		b	.L38
 558              	.L39:
 849:../FreeRTOS/Source/queue.c **** xTimeOutType xTimeOut;
 850:../FreeRTOS/Source/queue.c **** signed char *pcOriginalReadPosition;
 851:../FreeRTOS/Source/queue.c **** 
 852:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 853:../FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 854:../FreeRTOS/Source/queue.c **** 
 855:../FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 856:../FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 857:../FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 858:../FreeRTOS/Source/queue.c **** 
 859:../FreeRTOS/Source/queue.c **** 	for( ;; )
 860:../FreeRTOS/Source/queue.c **** 	{
 861:../FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 862:../FreeRTOS/Source/queue.c **** 		{
 863:../FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 864:../FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 865:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 866:../FreeRTOS/Source/queue.c **** 			{
 867:../FreeRTOS/Source/queue.c **** 				/* Remember our read position in case we are just peeking. */
 868:../FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 869:../FreeRTOS/Source/queue.c **** 
 870:../FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 871:../FreeRTOS/Source/queue.c **** 
 872:../FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 873:../FreeRTOS/Source/queue.c **** 				{
 874:../FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 875:../FreeRTOS/Source/queue.c **** 
 876:../FreeRTOS/Source/queue.c **** 					/* We are actually removing data. */
 877:../FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 878:../FreeRTOS/Source/queue.c **** 
 879:../FreeRTOS/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 880:../FreeRTOS/Source/queue.c **** 					{
 881:../FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 882:../FreeRTOS/Source/queue.c **** 						{
 883:../FreeRTOS/Source/queue.c **** 							/* Record the information required to implement
 884:../FreeRTOS/Source/queue.c **** 							priority inheritance should it become necessary. */
 885:../FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 886:../FreeRTOS/Source/queue.c **** 						}
 887:../FreeRTOS/Source/queue.c **** 					}
 888:../FreeRTOS/Source/queue.c **** 					#endif
 889:../FreeRTOS/Source/queue.c **** 
 890:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 891:../FreeRTOS/Source/queue.c **** 					{
 892:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 893:../FreeRTOS/Source/queue.c **** 						{
 894:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 895:../FreeRTOS/Source/queue.c **** 						}
 896:../FreeRTOS/Source/queue.c **** 					}
 897:../FreeRTOS/Source/queue.c **** 				}
 898:../FreeRTOS/Source/queue.c **** 				else
 899:../FreeRTOS/Source/queue.c **** 				{
 900:../FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 901:../FreeRTOS/Source/queue.c **** 
 902:../FreeRTOS/Source/queue.c **** 					/* We are not removing the data, so reset our read
 903:../FreeRTOS/Source/queue.c **** 					pointer. */
 904:../FreeRTOS/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 905:../FreeRTOS/Source/queue.c **** 
 906:../FreeRTOS/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
 907:../FreeRTOS/Source/queue.c **** 					any other tasks waiting for the data. */
 908:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 909:../FreeRTOS/Source/queue.c **** 					{
 910:../FreeRTOS/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
 911:../FreeRTOS/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 912:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 913:../FreeRTOS/Source/queue.c **** 						{
 914:../FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
 915:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 916:../FreeRTOS/Source/queue.c **** 						}
 917:../FreeRTOS/Source/queue.c **** 					}
 918:../FreeRTOS/Source/queue.c **** 
 919:../FreeRTOS/Source/queue.c **** 				}
 920:../FreeRTOS/Source/queue.c **** 
 921:../FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 922:../FreeRTOS/Source/queue.c **** 				return pdPASS;
 923:../FreeRTOS/Source/queue.c **** 			}
 924:../FreeRTOS/Source/queue.c **** 			else
 925:../FreeRTOS/Source/queue.c **** 			{
 926:../FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 927:../FreeRTOS/Source/queue.c **** 				{
 928:../FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
 929:../FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 930:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 931:../FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 932:../FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 933:../FreeRTOS/Source/queue.c **** 				}
 934:../FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 935:../FreeRTOS/Source/queue.c **** 				{
 936:../FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
 937:../FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 938:../FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 939:../FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 940:../FreeRTOS/Source/queue.c **** 				}
 941:../FreeRTOS/Source/queue.c **** 			}
 942:../FreeRTOS/Source/queue.c **** 		}
 943:../FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 944:../FreeRTOS/Source/queue.c **** 
 945:../FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 946:../FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 947:../FreeRTOS/Source/queue.c **** 
 948:../FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 950:../FreeRTOS/Source/queue.c **** 
 951:../FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 952:../FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 953:../FreeRTOS/Source/queue.c **** 		{
 954:../FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 955:../FreeRTOS/Source/queue.c **** 			{
 956:../FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 957:../FreeRTOS/Source/queue.c **** 
 958:../FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 959:../FreeRTOS/Source/queue.c **** 				{
 960:../FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 961:../FreeRTOS/Source/queue.c **** 					{
 962:../FreeRTOS/Source/queue.c **** 						portENTER_CRITICAL();
 963:../FreeRTOS/Source/queue.c **** 						{
 964:../FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 965:../FreeRTOS/Source/queue.c **** 						}
 966:../FreeRTOS/Source/queue.c **** 						portEXIT_CRITICAL();
 967:../FreeRTOS/Source/queue.c **** 					}
 968:../FreeRTOS/Source/queue.c **** 				}
 969:../FreeRTOS/Source/queue.c **** 				#endif
 970:../FreeRTOS/Source/queue.c **** 
 971:../FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 972:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 973:../FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 974:../FreeRTOS/Source/queue.c **** 				{
 975:../FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 976:../FreeRTOS/Source/queue.c **** 				}
 977:../FreeRTOS/Source/queue.c **** 			}
 978:../FreeRTOS/Source/queue.c **** 			else
 979:../FreeRTOS/Source/queue.c **** 			{
 980:../FreeRTOS/Source/queue.c **** 				/* Try again. */
 981:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 982:../FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 983:../FreeRTOS/Source/queue.c **** 			}
 984:../FreeRTOS/Source/queue.c **** 		}
 985:../FreeRTOS/Source/queue.c **** 		else
 986:../FreeRTOS/Source/queue.c **** 		{
 987:../FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 988:../FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 989:../FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
 990:../FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
 991:../FreeRTOS/Source/queue.c **** 		}
 992:../FreeRTOS/Source/queue.c **** 	}
 559              		.loc 1 992 0
 560 0332 00BF     		nop
 561              	.L38:
 861:../FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 562              		.loc 1 861 0
 563 0334 FFF7FEFF 		bl	vPortEnterCritical
 865:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 564              		.loc 1 865 0
 565 0338 FB68     		ldr	r3, [r7, #12]
 566 033a 9B6B     		ldr	r3, [r3, #56]
 567 033c 002B     		cmp	r3, #0
 568 033e 3FD0     		beq	.L25
 868:../FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 569              		.loc 1 868 0
 570 0340 FB68     		ldr	r3, [r7, #12]
 571 0342 DB68     		ldr	r3, [r3, #12]
 572 0344 BB61     		str	r3, [r7, #24]
 870:../FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 573              		.loc 1 870 0
 574 0346 F868     		ldr	r0, [r7, #12]
 575 0348 B968     		ldr	r1, [r7, #8]
 576 034a 00F089F9 		bl	prvCopyDataFromQueue
 872:../FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 577              		.loc 1 872 0
 578 034e 3B68     		ldr	r3, [r7, #0]
 579 0350 002B     		cmp	r3, #0
 580 0352 1ED1     		bne	.L26
 877:../FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 581              		.loc 1 877 0
 582 0354 FB68     		ldr	r3, [r7, #12]
 583 0356 9B6B     		ldr	r3, [r3, #56]
 584 0358 03F1FF32 		add	r2, r3, #-1
 585 035c FB68     		ldr	r3, [r7, #12]
 586 035e 9A63     		str	r2, [r3, #56]
 881:../FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 587              		.loc 1 881 0
 588 0360 FB68     		ldr	r3, [r7, #12]
 589 0362 1B68     		ldr	r3, [r3, #0]
 590 0364 002B     		cmp	r3, #0
 591 0366 04D1     		bne	.L27
 885:../FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 592              		.loc 1 885 0
 593 0368 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 594 036c 0246     		mov	r2, r0
 595 036e FB68     		ldr	r3, [r7, #12]
 596 0370 5A60     		str	r2, [r3, #4]
 597              	.L27:
 890:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 598              		.loc 1 890 0
 599 0372 FB68     		ldr	r3, [r7, #12]
 600 0374 1B69     		ldr	r3, [r3, #16]
 601 0376 002B     		cmp	r3, #0
 602 0378 1DD0     		beq	.L28
 892:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 603              		.loc 1 892 0
 604 037a FB68     		ldr	r3, [r7, #12]
 605 037c 03F11003 		add	r3, r3, #16
 606 0380 1846     		mov	r0, r3
 607 0382 FFF7FEFF 		bl	xTaskRemoveFromEventList
 608 0386 0346     		mov	r3, r0
 609 0388 012B     		cmp	r3, #1
 610 038a 14D1     		bne	.L28
 894:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 611              		.loc 1 894 0
 612 038c FFF7FEFF 		bl	vPortYieldFromISR
 613 0390 11E0     		b	.L28
 614              	.L26:
 904:../FreeRTOS/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 615              		.loc 1 904 0
 616 0392 FB68     		ldr	r3, [r7, #12]
 617 0394 BA69     		ldr	r2, [r7, #24]
 618 0396 DA60     		str	r2, [r3, #12]
 908:../FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 619              		.loc 1 908 0
 620 0398 FB68     		ldr	r3, [r7, #12]
 621 039a 5B6A     		ldr	r3, [r3, #36]
 622 039c 002B     		cmp	r3, #0
 623 039e 0AD0     		beq	.L28
 912:../FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 624              		.loc 1 912 0
 625 03a0 FB68     		ldr	r3, [r7, #12]
 626 03a2 03F12403 		add	r3, r3, #36
 627 03a6 1846     		mov	r0, r3
 628 03a8 FFF7FEFF 		bl	xTaskRemoveFromEventList
 629 03ac 0346     		mov	r3, r0
 630 03ae 002B     		cmp	r3, #0
 631 03b0 01D0     		beq	.L28
 915:../FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 632              		.loc 1 915 0
 633 03b2 FFF7FEFF 		bl	vPortYieldFromISR
 634              	.L28:
 921:../FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 635              		.loc 1 921 0
 636 03b6 FFF7FEFF 		bl	vPortExitCritical
 922:../FreeRTOS/Source/queue.c **** 				return pdPASS;
 637              		.loc 1 922 0
 638 03ba 4FF00103 		mov	r3, #1
 639 03be 6BE0     		b	.L29
 640              	.L25:
 926:../FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 641              		.loc 1 926 0
 642 03c0 7B68     		ldr	r3, [r7, #4]
 643 03c2 002B     		cmp	r3, #0
 644 03c4 04D1     		bne	.L30
 930:../FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 645              		.loc 1 930 0
 646 03c6 FFF7FEFF 		bl	vPortExitCritical
 932:../FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 647              		.loc 1 932 0
 648 03ca 4FF00003 		mov	r3, #0
 649 03ce 63E0     		b	.L29
 650              	.L30:
 934:../FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 651              		.loc 1 934 0
 652 03d0 FB69     		ldr	r3, [r7, #28]
 653 03d2 002B     		cmp	r3, #0
 654 03d4 07D1     		bne	.L31
 938:../FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 655              		.loc 1 938 0
 656 03d6 07F11003 		add	r3, r7, #16
 657 03da 1846     		mov	r0, r3
 658 03dc FFF7FEFF 		bl	vTaskSetTimeOutState
 939:../FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 659              		.loc 1 939 0
 660 03e0 4FF00103 		mov	r3, #1
 661 03e4 FB61     		str	r3, [r7, #28]
 662              	.L31:
 943:../FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 663              		.loc 1 943 0
 664 03e6 FFF7FEFF 		bl	vPortExitCritical
 948:../FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 665              		.loc 1 948 0
 666 03ea FFF7FEFF 		bl	vTaskSuspendAll
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 667              		.loc 1 949 0
 668 03ee FFF7FEFF 		bl	vPortEnterCritical
 669 03f2 FB68     		ldr	r3, [r7, #12]
 670 03f4 5B6C     		ldr	r3, [r3, #68]
 671 03f6 B3F1FF3F 		cmp	r3, #-1
 672 03fa 03D1     		bne	.L32
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 673              		.loc 1 949 0 is_stmt 0 discriminator 1
 674 03fc FB68     		ldr	r3, [r7, #12]
 675 03fe 4FF00002 		mov	r2, #0
 676 0402 5A64     		str	r2, [r3, #68]
 677              	.L32:
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 678              		.loc 1 949 0 discriminator 2
 679 0404 FB68     		ldr	r3, [r7, #12]
 680 0406 9B6C     		ldr	r3, [r3, #72]
 681 0408 B3F1FF3F 		cmp	r3, #-1
 682 040c 03D1     		bne	.L33
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 683              		.loc 1 949 0 discriminator 3
 684 040e FB68     		ldr	r3, [r7, #12]
 685 0410 4FF00002 		mov	r2, #0
 686 0414 9A64     		str	r2, [r3, #72]
 687              	.L33:
 949:../FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 688              		.loc 1 949 0 discriminator 4
 689 0416 FFF7FEFF 		bl	vPortExitCritical
 952:../FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 690              		.loc 1 952 0 is_stmt 1 discriminator 4
 691 041a 07F11002 		add	r2, r7, #16
 692 041e 07F10403 		add	r3, r7, #4
 693 0422 1046     		mov	r0, r2
 694 0424 1946     		mov	r1, r3
 695 0426 FFF7FEFF 		bl	xTaskCheckForTimeOut
 696 042a 0346     		mov	r3, r0
 697 042c 002B     		cmp	r3, #0
 698 042e 2CD1     		bne	.L34
 954:../FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 699              		.loc 1 954 0
 700 0430 F868     		ldr	r0, [r7, #12]
 701 0432 00F08DF9 		bl	prvIsQueueEmpty
 702 0436 0346     		mov	r3, r0
 703 0438 002B     		cmp	r3, #0
 704 043a 20D0     		beq	.L35
 960:../FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 705              		.loc 1 960 0
 706 043c FB68     		ldr	r3, [r7, #12]
 707 043e 1B68     		ldr	r3, [r3, #0]
 708 0440 002B     		cmp	r3, #0
 709 0442 08D1     		bne	.L36
 962:../FreeRTOS/Source/queue.c **** 						portENTER_CRITICAL();
 710              		.loc 1 962 0
 711 0444 FFF7FEFF 		bl	vPortEnterCritical
 964:../FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 712              		.loc 1 964 0
 713 0448 FB68     		ldr	r3, [r7, #12]
 714 044a 5B68     		ldr	r3, [r3, #4]
 715 044c 1846     		mov	r0, r3
 716 044e FFF7FEFF 		bl	vTaskPriorityInherit
 966:../FreeRTOS/Source/queue.c **** 						portEXIT_CRITICAL();
 717              		.loc 1 966 0
 718 0452 FFF7FEFF 		bl	vPortExitCritical
 719              	.L36:
 971:../FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 720              		.loc 1 971 0
 721 0456 FB68     		ldr	r3, [r7, #12]
 722 0458 03F12402 		add	r2, r3, #36
 723 045c 7B68     		ldr	r3, [r7, #4]
 724 045e 1046     		mov	r0, r2
 725 0460 1946     		mov	r1, r3
 726 0462 FFF7FEFF 		bl	vTaskPlaceOnEventList
 972:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 727              		.loc 1 972 0
 728 0466 F868     		ldr	r0, [r7, #12]
 729 0468 00F022F9 		bl	prvUnlockQueue
 973:../FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 730              		.loc 1 973 0
 731 046c FFF7FEFF 		bl	xTaskResumeAll
 732 0470 0346     		mov	r3, r0
 733 0472 002B     		cmp	r3, #0
 734 0474 7FF45DAF 		bne	.L39
 975:../FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 735              		.loc 1 975 0
 736 0478 FFF7FEFF 		bl	vPortYieldFromISR
 737              		.loc 1 992 0
 738 047c 59E7     		b	.L39
 739              	.L35:
 981:../FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 740              		.loc 1 981 0
 741 047e F868     		ldr	r0, [r7, #12]
 742 0480 00F016F9 		bl	prvUnlockQueue
 982:../FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 743              		.loc 1 982 0
 744 0484 FFF7FEFF 		bl	xTaskResumeAll
 745              		.loc 1 992 0
 746 0488 53E7     		b	.L39
 747              	.L34:
 987:../FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 748              		.loc 1 987 0
 749 048a F868     		ldr	r0, [r7, #12]
 750 048c 00F010F9 		bl	prvUnlockQueue
 988:../FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 751              		.loc 1 988 0
 752 0490 FFF7FEFF 		bl	xTaskResumeAll
 990:../FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
 753              		.loc 1 990 0
 754 0494 4FF00003 		mov	r3, #0
 755              	.L29:
 993:../FreeRTOS/Source/queue.c **** }
 756              		.loc 1 993 0
 757 0498 1846     		mov	r0, r3
 758 049a 07F12007 		add	r7, r7, #32
 759 049e BD46     		mov	sp, r7
 760 04a0 80BD     		pop	{r7, pc}
 761              		.cfi_endproc
 762              	.LFE114:
 764 04a2 00BF     		.align	2
 765              		.global	xQueueReceiveFromISR
 766              		.thumb
 767              		.thumb_func
 769              	xQueueReceiveFromISR:
 770              	.LFB115:
 994:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 995:../FreeRTOS/Source/queue.c **** 
 996:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 997:../FreeRTOS/Source/queue.c **** {
 771              		.loc 1 997 0
 772              		.cfi_startproc
 773              		@ args = 0, pretend = 0, frame = 24
 774              		@ frame_needed = 1, uses_anonymous_args = 0
 775 04a4 80B5     		push	{r7, lr}
 776              	.LCFI15:
 777              		.cfi_def_cfa_offset 8
 778              		.cfi_offset 14, -4
 779              		.cfi_offset 7, -8
 780 04a6 86B0     		sub	sp, sp, #24
 781              	.LCFI16:
 782              		.cfi_def_cfa_offset 32
 783 04a8 00AF     		add	r7, sp, #0
 784              	.LCFI17:
 785              		.cfi_def_cfa_register 7
 786 04aa F860     		str	r0, [r7, #12]
 787 04ac B960     		str	r1, [r7, #8]
 788 04ae 7A60     		str	r2, [r7, #4]
 998:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
 999:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1000:../FreeRTOS/Source/queue.c **** 
1001:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1002:../FreeRTOS/Source/queue.c **** 	configASSERT( pxTaskWoken );
1003:../FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1004:../FreeRTOS/Source/queue.c **** 
1005:../FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 789              		.loc 1 1005 0
 790 04b0 4FF00003 		mov	r3, #0
 791 04b4 3B61     		str	r3, [r7, #16]
 792              	@ 1005 "../FreeRTOS/Source/queue.c" 1
 793 04b6 4FF0BF00 			mov r0, #191								
 794 04ba 80F31188 		msr basepri, r0							
 795              	
 796              	@ 0 "" 2
1006:../FreeRTOS/Source/queue.c **** 	{
1007:../FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1008:../FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 797              		.loc 1 1008 0
 798              		.thumb
 799 04be FB68     		ldr	r3, [r7, #12]
 800 04c0 9B6B     		ldr	r3, [r3, #56]
 801 04c2 002B     		cmp	r3, #0
 802 04c4 2AD0     		beq	.L41
1009:../FreeRTOS/Source/queue.c **** 		{
1010:../FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1011:../FreeRTOS/Source/queue.c **** 
1012:../FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 803              		.loc 1 1012 0
 804 04c6 F868     		ldr	r0, [r7, #12]
 805 04c8 B968     		ldr	r1, [r7, #8]
 806 04ca 00F0C9F8 		bl	prvCopyDataFromQueue
1013:../FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 807              		.loc 1 1013 0
 808 04ce FB68     		ldr	r3, [r7, #12]
 809 04d0 9B6B     		ldr	r3, [r3, #56]
 810 04d2 03F1FF32 		add	r2, r3, #-1
 811 04d6 FB68     		ldr	r3, [r7, #12]
 812 04d8 9A63     		str	r2, [r3, #56]
1014:../FreeRTOS/Source/queue.c **** 
1015:../FreeRTOS/Source/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1016:../FreeRTOS/Source/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1017:../FreeRTOS/Source/queue.c **** 			that an ISR has removed data while the queue was locked. */
1018:../FreeRTOS/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 813              		.loc 1 1018 0
 814 04da FB68     		ldr	r3, [r7, #12]
 815 04dc 5B6C     		ldr	r3, [r3, #68]
 816 04de B3F1FF3F 		cmp	r3, #-1
 817 04e2 11D1     		bne	.L42
1019:../FreeRTOS/Source/queue.c **** 			{
1020:../FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 818              		.loc 1 1020 0
 819 04e4 FB68     		ldr	r3, [r7, #12]
 820 04e6 1B69     		ldr	r3, [r3, #16]
 821 04e8 002B     		cmp	r3, #0
 822 04ea 13D0     		beq	.L43
1021:../FreeRTOS/Source/queue.c **** 				{
1022:../FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 823              		.loc 1 1022 0
 824 04ec FB68     		ldr	r3, [r7, #12]
 825 04ee 03F11003 		add	r3, r3, #16
 826 04f2 1846     		mov	r0, r3
 827 04f4 FFF7FEFF 		bl	xTaskRemoveFromEventList
 828 04f8 0346     		mov	r3, r0
 829 04fa 002B     		cmp	r3, #0
 830 04fc 0AD0     		beq	.L43
1023:../FreeRTOS/Source/queue.c **** 					{
1024:../FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1025:../FreeRTOS/Source/queue.c **** 						force a context switch. */
1026:../FreeRTOS/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
 831              		.loc 1 1026 0
 832 04fe 7B68     		ldr	r3, [r7, #4]
 833 0500 4FF00102 		mov	r2, #1
 834 0504 1A60     		str	r2, [r3, #0]
 835 0506 05E0     		b	.L43
 836              	.L42:
1027:../FreeRTOS/Source/queue.c **** 					}
1028:../FreeRTOS/Source/queue.c **** 				}
1029:../FreeRTOS/Source/queue.c **** 			}
1030:../FreeRTOS/Source/queue.c **** 			else
1031:../FreeRTOS/Source/queue.c **** 			{
1032:../FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1033:../FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1034:../FreeRTOS/Source/queue.c **** 				++( pxQueue->xRxLock );
 837              		.loc 1 1034 0
 838 0508 FB68     		ldr	r3, [r7, #12]
 839 050a 5B6C     		ldr	r3, [r3, #68]
 840 050c 03F10102 		add	r2, r3, #1
 841 0510 FB68     		ldr	r3, [r7, #12]
 842 0512 5A64     		str	r2, [r3, #68]
 843              	.L43:
1035:../FreeRTOS/Source/queue.c **** 			}
1036:../FreeRTOS/Source/queue.c **** 
1037:../FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 844              		.loc 1 1037 0
 845 0514 4FF00103 		mov	r3, #1
 846 0518 7B61     		str	r3, [r7, #20]
 847 051a 02E0     		b	.L44
 848              	.L41:
1038:../FreeRTOS/Source/queue.c **** 		}
1039:../FreeRTOS/Source/queue.c **** 		else
1040:../FreeRTOS/Source/queue.c **** 		{
1041:../FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 849              		.loc 1 1041 0
 850 051c 4FF00003 		mov	r3, #0
 851 0520 7B61     		str	r3, [r7, #20]
 852              	.L44:
1042:../FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1043:../FreeRTOS/Source/queue.c **** 		}
1044:../FreeRTOS/Source/queue.c **** 	}
1045:../FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 853              		.loc 1 1045 0
 854              	@ 1045 "../FreeRTOS/Source/queue.c" 1
 855 0522 4FF00000 			mov r0, #0					
 856 0526 80F31188 		msr basepri, r0				
 857              	
 858              	@ 0 "" 2
1046:../FreeRTOS/Source/queue.c **** 
1047:../FreeRTOS/Source/queue.c **** 	return xReturn;
 859              		.loc 1 1047 0
 860              		.thumb
 861 052a 7B69     		ldr	r3, [r7, #20]
1048:../FreeRTOS/Source/queue.c **** }
 862              		.loc 1 1048 0
 863 052c 1846     		mov	r0, r3
 864 052e 07F11807 		add	r7, r7, #24
 865 0532 BD46     		mov	sp, r7
 866 0534 80BD     		pop	{r7, pc}
 867              		.cfi_endproc
 868              	.LFE115:
 870 0536 00BF     		.align	2
 871              		.global	uxQueueMessagesWaiting
 872              		.thumb
 873              		.thumb_func
 875              	uxQueueMessagesWaiting:
 876              	.LFB116:
1049:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1050:../FreeRTOS/Source/queue.c **** 
1051:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1052:../FreeRTOS/Source/queue.c **** {
 877              		.loc 1 1052 0
 878              		.cfi_startproc
 879              		@ args = 0, pretend = 0, frame = 16
 880              		@ frame_needed = 1, uses_anonymous_args = 0
 881 0538 80B5     		push	{r7, lr}
 882              	.LCFI18:
 883              		.cfi_def_cfa_offset 8
 884              		.cfi_offset 14, -4
 885              		.cfi_offset 7, -8
 886 053a 84B0     		sub	sp, sp, #16
 887              	.LCFI19:
 888              		.cfi_def_cfa_offset 24
 889 053c 00AF     		add	r7, sp, #0
 890              	.LCFI20:
 891              		.cfi_def_cfa_register 7
 892 053e 7860     		str	r0, [r7, #4]
1053:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1054:../FreeRTOS/Source/queue.c **** 
1055:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1056:../FreeRTOS/Source/queue.c **** 
1057:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 893              		.loc 1 1057 0
 894 0540 FFF7FEFF 		bl	vPortEnterCritical
1058:../FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 895              		.loc 1 1058 0
 896 0544 7B68     		ldr	r3, [r7, #4]
 897 0546 9B6B     		ldr	r3, [r3, #56]
 898 0548 FB60     		str	r3, [r7, #12]
1059:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 899              		.loc 1 1059 0
 900 054a FFF7FEFF 		bl	vPortExitCritical
1060:../FreeRTOS/Source/queue.c **** 
1061:../FreeRTOS/Source/queue.c **** 	return uxReturn;
 901              		.loc 1 1061 0
 902 054e FB68     		ldr	r3, [r7, #12]
1062:../FreeRTOS/Source/queue.c **** }
 903              		.loc 1 1062 0
 904 0550 1846     		mov	r0, r3
 905 0552 07F11007 		add	r7, r7, #16
 906 0556 BD46     		mov	sp, r7
 907 0558 80BD     		pop	{r7, pc}
 908              		.cfi_endproc
 909              	.LFE116:
 911 055a 00BF     		.align	2
 912              		.global	uxQueueMessagesWaitingFromISR
 913              		.thumb
 914              		.thumb_func
 916              	uxQueueMessagesWaitingFromISR:
 917              	.LFB117:
1063:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1064:../FreeRTOS/Source/queue.c **** 
1065:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1066:../FreeRTOS/Source/queue.c **** {
 918              		.loc 1 1066 0
 919              		.cfi_startproc
 920              		@ args = 0, pretend = 0, frame = 16
 921              		@ frame_needed = 1, uses_anonymous_args = 0
 922              		@ link register save eliminated.
 923 055c 80B4     		push	{r7}
 924              	.LCFI21:
 925              		.cfi_def_cfa_offset 4
 926              		.cfi_offset 7, -4
 927 055e 85B0     		sub	sp, sp, #20
 928              	.LCFI22:
 929              		.cfi_def_cfa_offset 24
 930 0560 00AF     		add	r7, sp, #0
 931              	.LCFI23:
 932              		.cfi_def_cfa_register 7
 933 0562 7860     		str	r0, [r7, #4]
1067:../FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1068:../FreeRTOS/Source/queue.c **** 
1069:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1070:../FreeRTOS/Source/queue.c **** 
1071:../FreeRTOS/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 934              		.loc 1 1071 0
 935 0564 7B68     		ldr	r3, [r7, #4]
 936 0566 9B6B     		ldr	r3, [r3, #56]
 937 0568 FB60     		str	r3, [r7, #12]
1072:../FreeRTOS/Source/queue.c **** 
1073:../FreeRTOS/Source/queue.c **** 	return uxReturn;
 938              		.loc 1 1073 0
 939 056a FB68     		ldr	r3, [r7, #12]
1074:../FreeRTOS/Source/queue.c **** }
 940              		.loc 1 1074 0
 941 056c 1846     		mov	r0, r3
 942 056e 07F11407 		add	r7, r7, #20
 943 0572 BD46     		mov	sp, r7
 944 0574 80BC     		pop	{r7}
 945 0576 7047     		bx	lr
 946              		.cfi_endproc
 947              	.LFE117:
 949              		.align	2
 950              		.global	vQueueDelete
 951              		.thumb
 952              		.thumb_func
 954              	vQueueDelete:
 955              	.LFB118:
1075:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1076:../FreeRTOS/Source/queue.c **** 
1077:../FreeRTOS/Source/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1078:../FreeRTOS/Source/queue.c **** {
 956              		.loc 1 1078 0
 957              		.cfi_startproc
 958              		@ args = 0, pretend = 0, frame = 8
 959              		@ frame_needed = 1, uses_anonymous_args = 0
 960 0578 80B5     		push	{r7, lr}
 961              	.LCFI24:
 962              		.cfi_def_cfa_offset 8
 963              		.cfi_offset 14, -4
 964              		.cfi_offset 7, -8
 965 057a 82B0     		sub	sp, sp, #8
 966              	.LCFI25:
 967              		.cfi_def_cfa_offset 16
 968 057c 00AF     		add	r7, sp, #0
 969              	.LCFI26:
 970              		.cfi_def_cfa_register 7
 971 057e 7860     		str	r0, [r7, #4]
1079:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1080:../FreeRTOS/Source/queue.c **** 
1081:../FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1082:../FreeRTOS/Source/queue.c **** 	vQueueUnregisterQueue( pxQueue );
1083:../FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 972              		.loc 1 1083 0
 973 0580 7B68     		ldr	r3, [r7, #4]
 974 0582 1B68     		ldr	r3, [r3, #0]
 975 0584 1846     		mov	r0, r3
 976 0586 FFF7FEFF 		bl	free
1084:../FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue );
 977              		.loc 1 1084 0
 978 058a 7868     		ldr	r0, [r7, #4]
 979 058c FFF7FEFF 		bl	free
1085:../FreeRTOS/Source/queue.c **** }
 980              		.loc 1 1085 0
 981 0590 07F10807 		add	r7, r7, #8
 982 0594 BD46     		mov	sp, r7
 983 0596 80BD     		pop	{r7, pc}
 984              		.cfi_endproc
 985              	.LFE118:
 987              		.align	2
 988              		.thumb
 989              		.thumb_func
 991              	prvCopyDataToQueue:
 992              	.LFB119:
1086:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1087:../FreeRTOS/Source/queue.c **** 
1088:../FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1089:../FreeRTOS/Source/queue.c **** {
 993              		.loc 1 1089 0
 994              		.cfi_startproc
 995              		@ args = 0, pretend = 0, frame = 16
 996              		@ frame_needed = 1, uses_anonymous_args = 0
 997 0598 80B5     		push	{r7, lr}
 998              	.LCFI27:
 999              		.cfi_def_cfa_offset 8
 1000              		.cfi_offset 14, -4
 1001              		.cfi_offset 7, -8
 1002 059a 84B0     		sub	sp, sp, #16
 1003              	.LCFI28:
 1004              		.cfi_def_cfa_offset 24
 1005 059c 00AF     		add	r7, sp, #0
 1006              	.LCFI29:
 1007              		.cfi_def_cfa_register 7
 1008 059e F860     		str	r0, [r7, #12]
 1009 05a0 B960     		str	r1, [r7, #8]
 1010 05a2 7A60     		str	r2, [r7, #4]
1090:../FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1011              		.loc 1 1090 0
 1012 05a4 FB68     		ldr	r3, [r7, #12]
 1013 05a6 1B6C     		ldr	r3, [r3, #64]
 1014 05a8 002B     		cmp	r3, #0
 1015 05aa 0DD1     		bne	.L49
1091:../FreeRTOS/Source/queue.c **** 	{
1092:../FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1093:../FreeRTOS/Source/queue.c **** 		{
1094:../FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1016              		.loc 1 1094 0
 1017 05ac FB68     		ldr	r3, [r7, #12]
 1018 05ae 1B68     		ldr	r3, [r3, #0]
 1019 05b0 002B     		cmp	r3, #0
 1020 05b2 4AD1     		bne	.L50
1095:../FreeRTOS/Source/queue.c **** 			{
1096:../FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
1097:../FreeRTOS/Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1021              		.loc 1 1097 0
 1022 05b4 FB68     		ldr	r3, [r7, #12]
 1023 05b6 5B68     		ldr	r3, [r3, #4]
 1024 05b8 1846     		mov	r0, r3
 1025 05ba FFF7FEFF 		bl	vTaskPriorityDisinherit
1098:../FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1026              		.loc 1 1098 0
 1027 05be FB68     		ldr	r3, [r7, #12]
 1028 05c0 4FF00002 		mov	r2, #0
 1029 05c4 5A60     		str	r2, [r3, #4]
 1030 05c6 40E0     		b	.L50
 1031              	.L49:
1099:../FreeRTOS/Source/queue.c **** 			}
1100:../FreeRTOS/Source/queue.c **** 		}
1101:../FreeRTOS/Source/queue.c **** 		#endif
1102:../FreeRTOS/Source/queue.c **** 	}
1103:../FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1032              		.loc 1 1103 0
 1033 05c8 7B68     		ldr	r3, [r7, #4]
 1034 05ca 002B     		cmp	r3, #0
 1035 05cc 1BD1     		bne	.L51
1104:../FreeRTOS/Source/queue.c **** 	{
1105:../FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1036              		.loc 1 1105 0
 1037 05ce FB68     		ldr	r3, [r7, #12]
 1038 05d0 9968     		ldr	r1, [r3, #8]
 1039 05d2 FB68     		ldr	r3, [r7, #12]
 1040 05d4 1B6C     		ldr	r3, [r3, #64]
 1041 05d6 BA68     		ldr	r2, [r7, #8]
 1042 05d8 0846     		mov	r0, r1
 1043 05da 1146     		mov	r1, r2
 1044 05dc 1A46     		mov	r2, r3
 1045 05de FFF7FEFF 		bl	memcpy
1106:../FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1046              		.loc 1 1106 0
 1047 05e2 FB68     		ldr	r3, [r7, #12]
 1048 05e4 9A68     		ldr	r2, [r3, #8]
 1049 05e6 FB68     		ldr	r3, [r7, #12]
 1050 05e8 1B6C     		ldr	r3, [r3, #64]
 1051 05ea D218     		adds	r2, r2, r3
 1052 05ec FB68     		ldr	r3, [r7, #12]
 1053 05ee 9A60     		str	r2, [r3, #8]
1107:../FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 1054              		.loc 1 1107 0
 1055 05f0 FB68     		ldr	r3, [r7, #12]
 1056 05f2 9A68     		ldr	r2, [r3, #8]
 1057 05f4 FB68     		ldr	r3, [r7, #12]
 1058 05f6 5B68     		ldr	r3, [r3, #4]
 1059 05f8 9A42     		cmp	r2, r3
 1060 05fa 26D3     		bcc	.L50
1108:../FreeRTOS/Source/queue.c **** 		{
1109:../FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1061              		.loc 1 1109 0
 1062 05fc FB68     		ldr	r3, [r7, #12]
 1063 05fe 1A68     		ldr	r2, [r3, #0]
 1064 0600 FB68     		ldr	r3, [r7, #12]
 1065 0602 9A60     		str	r2, [r3, #8]
 1066 0604 21E0     		b	.L50
 1067              	.L51:
1110:../FreeRTOS/Source/queue.c **** 		}
1111:../FreeRTOS/Source/queue.c **** 	}
1112:../FreeRTOS/Source/queue.c **** 	else
1113:../FreeRTOS/Source/queue.c **** 	{
1114:../FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1068              		.loc 1 1114 0
 1069 0606 FB68     		ldr	r3, [r7, #12]
 1070 0608 D968     		ldr	r1, [r3, #12]
 1071 060a FB68     		ldr	r3, [r7, #12]
 1072 060c 1B6C     		ldr	r3, [r3, #64]
 1073 060e BA68     		ldr	r2, [r7, #8]
 1074 0610 0846     		mov	r0, r1
 1075 0612 1146     		mov	r1, r2
 1076 0614 1A46     		mov	r2, r3
 1077 0616 FFF7FEFF 		bl	memcpy
1115:../FreeRTOS/Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 1078              		.loc 1 1115 0
 1079 061a FB68     		ldr	r3, [r7, #12]
 1080 061c DA68     		ldr	r2, [r3, #12]
 1081 061e FB68     		ldr	r3, [r7, #12]
 1082 0620 1B6C     		ldr	r3, [r3, #64]
 1083 0622 C3F10003 		rsb	r3, r3, #0
 1084 0626 D218     		adds	r2, r2, r3
 1085 0628 FB68     		ldr	r3, [r7, #12]
 1086 062a DA60     		str	r2, [r3, #12]
1116:../FreeRTOS/Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 1087              		.loc 1 1116 0
 1088 062c FB68     		ldr	r3, [r7, #12]
 1089 062e DA68     		ldr	r2, [r3, #12]
 1090 0630 FB68     		ldr	r3, [r7, #12]
 1091 0632 1B68     		ldr	r3, [r3, #0]
 1092 0634 9A42     		cmp	r2, r3
 1093 0636 08D2     		bcs	.L50
1117:../FreeRTOS/Source/queue.c **** 		{
1118:../FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1094              		.loc 1 1118 0
 1095 0638 FB68     		ldr	r3, [r7, #12]
 1096 063a 5A68     		ldr	r2, [r3, #4]
 1097 063c FB68     		ldr	r3, [r7, #12]
 1098 063e 1B6C     		ldr	r3, [r3, #64]
 1099 0640 C3F10003 		rsb	r3, r3, #0
 1100 0644 D218     		adds	r2, r2, r3
 1101 0646 FB68     		ldr	r3, [r7, #12]
 1102 0648 DA60     		str	r2, [r3, #12]
 1103              	.L50:
1119:../FreeRTOS/Source/queue.c **** 		}
1120:../FreeRTOS/Source/queue.c **** 	}
1121:../FreeRTOS/Source/queue.c **** 
1122:../FreeRTOS/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1104              		.loc 1 1122 0
 1105 064a FB68     		ldr	r3, [r7, #12]
 1106 064c 9B6B     		ldr	r3, [r3, #56]
 1107 064e 03F10102 		add	r2, r3, #1
 1108 0652 FB68     		ldr	r3, [r7, #12]
 1109 0654 9A63     		str	r2, [r3, #56]
1123:../FreeRTOS/Source/queue.c **** }
 1110              		.loc 1 1123 0
 1111 0656 07F11007 		add	r7, r7, #16
 1112 065a BD46     		mov	sp, r7
 1113 065c 80BD     		pop	{r7, pc}
 1114              		.cfi_endproc
 1115              	.LFE119:
 1117 065e 00BF     		.align	2
 1118              		.thumb
 1119              		.thumb_func
 1121              	prvCopyDataFromQueue:
 1122              	.LFB120:
1124:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1125:../FreeRTOS/Source/queue.c **** 
1126:../FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1127:../FreeRTOS/Source/queue.c **** {
 1123              		.loc 1 1127 0
 1124              		.cfi_startproc
 1125              		@ args = 0, pretend = 0, frame = 8
 1126              		@ frame_needed = 1, uses_anonymous_args = 0
 1127 0660 80B5     		push	{r7, lr}
 1128              	.LCFI30:
 1129              		.cfi_def_cfa_offset 8
 1130              		.cfi_offset 14, -4
 1131              		.cfi_offset 7, -8
 1132 0662 82B0     		sub	sp, sp, #8
 1133              	.LCFI31:
 1134              		.cfi_def_cfa_offset 16
 1135 0664 00AF     		add	r7, sp, #0
 1136              	.LCFI32:
 1137              		.cfi_def_cfa_register 7
 1138 0666 7860     		str	r0, [r7, #4]
 1139 0668 3960     		str	r1, [r7, #0]
1128:../FreeRTOS/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 1140              		.loc 1 1128 0
 1141 066a 7B68     		ldr	r3, [r7, #4]
 1142 066c 1B68     		ldr	r3, [r3, #0]
 1143 066e 002B     		cmp	r3, #0
 1144 0670 1AD0     		beq	.L52
1129:../FreeRTOS/Source/queue.c **** 	{
1130:../FreeRTOS/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 1145              		.loc 1 1130 0
 1146 0672 7B68     		ldr	r3, [r7, #4]
 1147 0674 DA68     		ldr	r2, [r3, #12]
 1148 0676 7B68     		ldr	r3, [r7, #4]
 1149 0678 1B6C     		ldr	r3, [r3, #64]
 1150 067a D218     		adds	r2, r2, r3
 1151 067c 7B68     		ldr	r3, [r7, #4]
 1152 067e DA60     		str	r2, [r3, #12]
1131:../FreeRTOS/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 1153              		.loc 1 1131 0
 1154 0680 7B68     		ldr	r3, [r7, #4]
 1155 0682 DA68     		ldr	r2, [r3, #12]
 1156 0684 7B68     		ldr	r3, [r7, #4]
 1157 0686 5B68     		ldr	r3, [r3, #4]
 1158 0688 9A42     		cmp	r2, r3
 1159 068a 03D3     		bcc	.L54
1132:../FreeRTOS/Source/queue.c **** 		{
1133:../FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 1160              		.loc 1 1133 0
 1161 068c 7B68     		ldr	r3, [r7, #4]
 1162 068e 1A68     		ldr	r2, [r3, #0]
 1163 0690 7B68     		ldr	r3, [r7, #4]
 1164 0692 DA60     		str	r2, [r3, #12]
 1165              	.L54:
1134:../FreeRTOS/Source/queue.c **** 		}
1135:../FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 1166              		.loc 1 1135 0
 1167 0694 7B68     		ldr	r3, [r7, #4]
 1168 0696 DA68     		ldr	r2, [r3, #12]
 1169 0698 7B68     		ldr	r3, [r7, #4]
 1170 069a 1B6C     		ldr	r3, [r3, #64]
 1171 069c 3968     		ldr	r1, [r7, #0]
 1172 069e 0846     		mov	r0, r1
 1173 06a0 1146     		mov	r1, r2
 1174 06a2 1A46     		mov	r2, r3
 1175 06a4 FFF7FEFF 		bl	memcpy
 1176              	.L52:
1136:../FreeRTOS/Source/queue.c **** 	}
1137:../FreeRTOS/Source/queue.c **** }
 1177              		.loc 1 1137 0
 1178 06a8 07F10807 		add	r7, r7, #8
 1179 06ac BD46     		mov	sp, r7
 1180 06ae 80BD     		pop	{r7, pc}
 1181              		.cfi_endproc
 1182              	.LFE120:
 1184              		.align	2
 1185              		.thumb
 1186              		.thumb_func
 1188              	prvUnlockQueue:
 1189              	.LFB121:
1138:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1139:../FreeRTOS/Source/queue.c **** 
1140:../FreeRTOS/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1141:../FreeRTOS/Source/queue.c **** {
 1190              		.loc 1 1141 0
 1191              		.cfi_startproc
 1192              		@ args = 0, pretend = 0, frame = 8
 1193              		@ frame_needed = 1, uses_anonymous_args = 0
 1194 06b0 80B5     		push	{r7, lr}
 1195              	.LCFI33:
 1196              		.cfi_def_cfa_offset 8
 1197              		.cfi_offset 14, -4
 1198              		.cfi_offset 7, -8
 1199 06b2 82B0     		sub	sp, sp, #8
 1200              	.LCFI34:
 1201              		.cfi_def_cfa_offset 16
 1202 06b4 00AF     		add	r7, sp, #0
 1203              	.LCFI35:
 1204              		.cfi_def_cfa_register 7
 1205 06b6 7860     		str	r0, [r7, #4]
1142:../FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1143:../FreeRTOS/Source/queue.c **** 
1144:../FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1145:../FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1146:../FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1147:../FreeRTOS/Source/queue.c **** 	updated. */
1148:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1206              		.loc 1 1148 0
 1207 06b8 FFF7FEFF 		bl	vPortEnterCritical
1149:../FreeRTOS/Source/queue.c **** 	{
1150:../FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1151:../FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1208              		.loc 1 1151 0
 1209 06bc 14E0     		b	.L56
 1210              	.L60:
1152:../FreeRTOS/Source/queue.c **** 		{
1153:../FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1154:../FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
1155:../FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1211              		.loc 1 1155 0
 1212 06be 7B68     		ldr	r3, [r7, #4]
 1213 06c0 5B6A     		ldr	r3, [r3, #36]
 1214 06c2 002B     		cmp	r3, #0
 1215 06c4 15D0     		beq	.L66
1156:../FreeRTOS/Source/queue.c **** 			{
1157:../FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1158:../FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1159:../FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1216              		.loc 1 1159 0
 1217 06c6 7B68     		ldr	r3, [r7, #4]
 1218 06c8 03F12403 		add	r3, r3, #36
 1219 06cc 1846     		mov	r0, r3
 1220 06ce FFF7FEFF 		bl	xTaskRemoveFromEventList
 1221 06d2 0346     		mov	r3, r0
 1222 06d4 002B     		cmp	r3, #0
 1223 06d6 01D0     		beq	.L58
1160:../FreeRTOS/Source/queue.c **** 				{
1161:../FreeRTOS/Source/queue.c **** 					/* The task waiting has a higher priority so record that a
1162:../FreeRTOS/Source/queue.c **** 					context	switch is required. */
1163:../FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 1224              		.loc 1 1163 0
 1225 06d8 FFF7FEFF 		bl	vTaskMissedYield
 1226              	.L58:
1164:../FreeRTOS/Source/queue.c **** 				}
1165:../FreeRTOS/Source/queue.c **** 
1166:../FreeRTOS/Source/queue.c **** 				--( pxQueue->xTxLock );
 1227              		.loc 1 1166 0
 1228 06dc 7B68     		ldr	r3, [r7, #4]
 1229 06de 9B6C     		ldr	r3, [r3, #72]
 1230 06e0 03F1FF32 		add	r2, r3, #-1
 1231 06e4 7B68     		ldr	r3, [r7, #4]
 1232 06e6 9A64     		str	r2, [r3, #72]
 1233              	.L56:
1151:../FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1234              		.loc 1 1151 0 discriminator 1
 1235 06e8 7B68     		ldr	r3, [r7, #4]
 1236 06ea 9B6C     		ldr	r3, [r3, #72]
 1237 06ec 002B     		cmp	r3, #0
 1238 06ee E6DC     		bgt	.L60
 1239 06f0 00E0     		b	.L59
 1240              	.L66:
1167:../FreeRTOS/Source/queue.c **** 			}
1168:../FreeRTOS/Source/queue.c **** 			else
1169:../FreeRTOS/Source/queue.c **** 			{
1170:../FreeRTOS/Source/queue.c **** 				break;
 1241              		.loc 1 1170 0
 1242 06f2 00BF     		nop
 1243              	.L59:
1171:../FreeRTOS/Source/queue.c **** 			}
1172:../FreeRTOS/Source/queue.c **** 		}
1173:../FreeRTOS/Source/queue.c **** 
1174:../FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 1244              		.loc 1 1174 0
 1245 06f4 7B68     		ldr	r3, [r7, #4]
 1246 06f6 4FF0FF32 		mov	r2, #-1
 1247 06fa 9A64     		str	r2, [r3, #72]
1175:../FreeRTOS/Source/queue.c **** 	}
1176:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1248              		.loc 1 1176 0
 1249 06fc FFF7FEFF 		bl	vPortExitCritical
1177:../FreeRTOS/Source/queue.c **** 
1178:../FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
1179:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1250              		.loc 1 1179 0
 1251 0700 FFF7FEFF 		bl	vPortEnterCritical
1180:../FreeRTOS/Source/queue.c **** 	{
1181:../FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1252              		.loc 1 1181 0
 1253 0704 14E0     		b	.L61
 1254              	.L65:
1182:../FreeRTOS/Source/queue.c **** 		{
1183:../FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1255              		.loc 1 1183 0
 1256 0706 7B68     		ldr	r3, [r7, #4]
 1257 0708 1B69     		ldr	r3, [r3, #16]
 1258 070a 002B     		cmp	r3, #0
 1259 070c 15D0     		beq	.L67
1184:../FreeRTOS/Source/queue.c **** 			{
1185:../FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1260              		.loc 1 1185 0
 1261 070e 7B68     		ldr	r3, [r7, #4]
 1262 0710 03F11003 		add	r3, r3, #16
 1263 0714 1846     		mov	r0, r3
 1264 0716 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1265 071a 0346     		mov	r3, r0
 1266 071c 002B     		cmp	r3, #0
 1267 071e 01D0     		beq	.L63
1186:../FreeRTOS/Source/queue.c **** 				{
1187:../FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 1268              		.loc 1 1187 0
 1269 0720 FFF7FEFF 		bl	vTaskMissedYield
 1270              	.L63:
1188:../FreeRTOS/Source/queue.c **** 				}
1189:../FreeRTOS/Source/queue.c **** 
1190:../FreeRTOS/Source/queue.c **** 				--( pxQueue->xRxLock );
 1271              		.loc 1 1190 0
 1272 0724 7B68     		ldr	r3, [r7, #4]
 1273 0726 5B6C     		ldr	r3, [r3, #68]
 1274 0728 03F1FF32 		add	r2, r3, #-1
 1275 072c 7B68     		ldr	r3, [r7, #4]
 1276 072e 5A64     		str	r2, [r3, #68]
 1277              	.L61:
1181:../FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1278              		.loc 1 1181 0 discriminator 1
 1279 0730 7B68     		ldr	r3, [r7, #4]
 1280 0732 5B6C     		ldr	r3, [r3, #68]
 1281 0734 002B     		cmp	r3, #0
 1282 0736 E6DC     		bgt	.L65
 1283 0738 00E0     		b	.L64
 1284              	.L67:
1191:../FreeRTOS/Source/queue.c **** 			}
1192:../FreeRTOS/Source/queue.c **** 			else
1193:../FreeRTOS/Source/queue.c **** 			{
1194:../FreeRTOS/Source/queue.c **** 				break;
 1285              		.loc 1 1194 0
 1286 073a 00BF     		nop
 1287              	.L64:
1195:../FreeRTOS/Source/queue.c **** 			}
1196:../FreeRTOS/Source/queue.c **** 		}
1197:../FreeRTOS/Source/queue.c **** 
1198:../FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 1288              		.loc 1 1198 0
 1289 073c 7B68     		ldr	r3, [r7, #4]
 1290 073e 4FF0FF32 		mov	r2, #-1
 1291 0742 5A64     		str	r2, [r3, #68]
1199:../FreeRTOS/Source/queue.c **** 	}
1200:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1292              		.loc 1 1200 0
 1293 0744 FFF7FEFF 		bl	vPortExitCritical
1201:../FreeRTOS/Source/queue.c **** }
 1294              		.loc 1 1201 0
 1295 0748 07F10807 		add	r7, r7, #8
 1296 074c BD46     		mov	sp, r7
 1297 074e 80BD     		pop	{r7, pc}
 1298              		.cfi_endproc
 1299              	.LFE121:
 1301              		.align	2
 1302              		.thumb
 1303              		.thumb_func
 1305              	prvIsQueueEmpty:
 1306              	.LFB122:
1202:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1203:../FreeRTOS/Source/queue.c **** 
1204:../FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1205:../FreeRTOS/Source/queue.c **** {
 1307              		.loc 1 1205 0
 1308              		.cfi_startproc
 1309              		@ args = 0, pretend = 0, frame = 16
 1310              		@ frame_needed = 1, uses_anonymous_args = 0
 1311 0750 80B5     		push	{r7, lr}
 1312              	.LCFI36:
 1313              		.cfi_def_cfa_offset 8
 1314              		.cfi_offset 14, -4
 1315              		.cfi_offset 7, -8
 1316 0752 84B0     		sub	sp, sp, #16
 1317              	.LCFI37:
 1318              		.cfi_def_cfa_offset 24
 1319 0754 00AF     		add	r7, sp, #0
 1320              	.LCFI38:
 1321              		.cfi_def_cfa_register 7
 1322 0756 7860     		str	r0, [r7, #4]
1206:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1207:../FreeRTOS/Source/queue.c **** 
1208:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1323              		.loc 1 1208 0
 1324 0758 FFF7FEFF 		bl	vPortEnterCritical
1209:../FreeRTOS/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1325              		.loc 1 1209 0
 1326 075c 7B68     		ldr	r3, [r7, #4]
 1327 075e 9B6B     		ldr	r3, [r3, #56]
 1328 0760 002B     		cmp	r3, #0
 1329 0762 14BF     		ite	ne
 1330 0764 0023     		movne	r3, #0
 1331 0766 0123     		moveq	r3, #1
 1332 0768 FB60     		str	r3, [r7, #12]
1210:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1333              		.loc 1 1210 0
 1334 076a FFF7FEFF 		bl	vPortExitCritical
1211:../FreeRTOS/Source/queue.c **** 
1212:../FreeRTOS/Source/queue.c **** 	return xReturn;
 1335              		.loc 1 1212 0
 1336 076e FB68     		ldr	r3, [r7, #12]
1213:../FreeRTOS/Source/queue.c **** }
 1337              		.loc 1 1213 0
 1338 0770 1846     		mov	r0, r3
 1339 0772 07F11007 		add	r7, r7, #16
 1340 0776 BD46     		mov	sp, r7
 1341 0778 80BD     		pop	{r7, pc}
 1342              		.cfi_endproc
 1343              	.LFE122:
 1345 077a 00BF     		.align	2
 1346              		.global	xQueueIsQueueEmptyFromISR
 1347              		.thumb
 1348              		.thumb_func
 1350              	xQueueIsQueueEmptyFromISR:
 1351              	.LFB123:
1214:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1215:../FreeRTOS/Source/queue.c **** 
1216:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1217:../FreeRTOS/Source/queue.c **** {
 1352              		.loc 1 1217 0
 1353              		.cfi_startproc
 1354              		@ args = 0, pretend = 0, frame = 16
 1355              		@ frame_needed = 1, uses_anonymous_args = 0
 1356              		@ link register save eliminated.
 1357 077c 80B4     		push	{r7}
 1358              	.LCFI39:
 1359              		.cfi_def_cfa_offset 4
 1360              		.cfi_offset 7, -4
 1361 077e 85B0     		sub	sp, sp, #20
 1362              	.LCFI40:
 1363              		.cfi_def_cfa_offset 24
 1364 0780 00AF     		add	r7, sp, #0
 1365              	.LCFI41:
 1366              		.cfi_def_cfa_register 7
 1367 0782 7860     		str	r0, [r7, #4]
1218:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1219:../FreeRTOS/Source/queue.c **** 
1220:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1221:../FreeRTOS/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1368              		.loc 1 1221 0
 1369 0784 7B68     		ldr	r3, [r7, #4]
 1370 0786 9B6B     		ldr	r3, [r3, #56]
 1371 0788 002B     		cmp	r3, #0
 1372 078a 14BF     		ite	ne
 1373 078c 0023     		movne	r3, #0
 1374 078e 0123     		moveq	r3, #1
 1375 0790 FB60     		str	r3, [r7, #12]
1222:../FreeRTOS/Source/queue.c **** 
1223:../FreeRTOS/Source/queue.c **** 	return xReturn;
 1376              		.loc 1 1223 0
 1377 0792 FB68     		ldr	r3, [r7, #12]
1224:../FreeRTOS/Source/queue.c **** }
 1378              		.loc 1 1224 0
 1379 0794 1846     		mov	r0, r3
 1380 0796 07F11407 		add	r7, r7, #20
 1381 079a BD46     		mov	sp, r7
 1382 079c 80BC     		pop	{r7}
 1383 079e 7047     		bx	lr
 1384              		.cfi_endproc
 1385              	.LFE123:
 1387              		.align	2
 1388              		.thumb
 1389              		.thumb_func
 1391              	prvIsQueueFull:
 1392              	.LFB124:
1225:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1226:../FreeRTOS/Source/queue.c **** 
1227:../FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1228:../FreeRTOS/Source/queue.c **** {
 1393              		.loc 1 1228 0
 1394              		.cfi_startproc
 1395              		@ args = 0, pretend = 0, frame = 16
 1396              		@ frame_needed = 1, uses_anonymous_args = 0
 1397 07a0 80B5     		push	{r7, lr}
 1398              	.LCFI42:
 1399              		.cfi_def_cfa_offset 8
 1400              		.cfi_offset 14, -4
 1401              		.cfi_offset 7, -8
 1402 07a2 84B0     		sub	sp, sp, #16
 1403              	.LCFI43:
 1404              		.cfi_def_cfa_offset 24
 1405 07a4 00AF     		add	r7, sp, #0
 1406              	.LCFI44:
 1407              		.cfi_def_cfa_register 7
 1408 07a6 7860     		str	r0, [r7, #4]
1229:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1230:../FreeRTOS/Source/queue.c **** 
1231:../FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1409              		.loc 1 1231 0
 1410 07a8 FFF7FEFF 		bl	vPortEnterCritical
1232:../FreeRTOS/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1411              		.loc 1 1232 0
 1412 07ac 7B68     		ldr	r3, [r7, #4]
 1413 07ae 9B6B     		ldr	r3, [r3, #56]
 1414 07b0 1A46     		mov	r2, r3
 1415 07b2 7B68     		ldr	r3, [r7, #4]
 1416 07b4 DB6B     		ldr	r3, [r3, #60]
 1417 07b6 9A42     		cmp	r2, r3
 1418 07b8 14BF     		ite	ne
 1419 07ba 0023     		movne	r3, #0
 1420 07bc 0123     		moveq	r3, #1
 1421 07be FB60     		str	r3, [r7, #12]
1233:../FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1422              		.loc 1 1233 0
 1423 07c0 FFF7FEFF 		bl	vPortExitCritical
1234:../FreeRTOS/Source/queue.c **** 
1235:../FreeRTOS/Source/queue.c **** 	return xReturn;
 1424              		.loc 1 1235 0
 1425 07c4 FB68     		ldr	r3, [r7, #12]
1236:../FreeRTOS/Source/queue.c **** }
 1426              		.loc 1 1236 0
 1427 07c6 1846     		mov	r0, r3
 1428 07c8 07F11007 		add	r7, r7, #16
 1429 07cc BD46     		mov	sp, r7
 1430 07ce 80BD     		pop	{r7, pc}
 1431              		.cfi_endproc
 1432              	.LFE124:
 1434              		.align	2
 1435              		.global	xQueueIsQueueFullFromISR
 1436              		.thumb
 1437              		.thumb_func
 1439              	xQueueIsQueueFullFromISR:
 1440              	.LFB125:
1237:../FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1238:../FreeRTOS/Source/queue.c **** 
1239:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1240:../FreeRTOS/Source/queue.c **** {
 1441              		.loc 1 1240 0
 1442              		.cfi_startproc
 1443              		@ args = 0, pretend = 0, frame = 16
 1444              		@ frame_needed = 1, uses_anonymous_args = 0
 1445              		@ link register save eliminated.
 1446 07d0 80B4     		push	{r7}
 1447              	.LCFI45:
 1448              		.cfi_def_cfa_offset 4
 1449              		.cfi_offset 7, -4
 1450 07d2 85B0     		sub	sp, sp, #20
 1451              	.LCFI46:
 1452              		.cfi_def_cfa_offset 24
 1453 07d4 00AF     		add	r7, sp, #0
 1454              	.LCFI47:
 1455              		.cfi_def_cfa_register 7
 1456 07d6 7860     		str	r0, [r7, #4]
1241:../FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1242:../FreeRTOS/Source/queue.c **** 
1243:../FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1244:../FreeRTOS/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1457              		.loc 1 1244 0
 1458 07d8 7B68     		ldr	r3, [r7, #4]
 1459 07da 9B6B     		ldr	r3, [r3, #56]
 1460 07dc 1A46     		mov	r2, r3
 1461 07de 7B68     		ldr	r3, [r7, #4]
 1462 07e0 DB6B     		ldr	r3, [r3, #60]
 1463 07e2 9A42     		cmp	r2, r3
 1464 07e4 14BF     		ite	ne
 1465 07e6 0023     		movne	r3, #0
 1466 07e8 0123     		moveq	r3, #1
 1467 07ea FB60     		str	r3, [r7, #12]
1245:../FreeRTOS/Source/queue.c **** 
1246:../FreeRTOS/Source/queue.c **** 	return xReturn;
 1468              		.loc 1 1246 0
 1469 07ec FB68     		ldr	r3, [r7, #12]
1247:../FreeRTOS/Source/queue.c **** }
 1470              		.loc 1 1247 0
 1471 07ee 1846     		mov	r0, r3
 1472 07f0 07F11407 		add	r7, r7, #20
 1473 07f4 BD46     		mov	sp, r7
 1474 07f6 80BC     		pop	{r7}
 1475 07f8 7047     		bx	lr
 1476              		.cfi_endproc
 1477              	.LFE125:
 1479              	.Letext0:
 1480              		.file 2 "d:\\elektronik\\ides\\eclipse\\yagarto\\bin\\../lib/gcc/arm-none-eabi/4.6.2/include/stdde
 1481              		.file 3 "d:/elektronik/ides/eclipse/yagarto/lib/gcc/../../arm-none-eabi/sys-include/stdint.h"
 1482              		.file 4 "C:\\Dokumente und Einstellungen\\brand\\Desktop\\thundercyer-the-alarm-clock\\FreeRTOS\\S
 1483              		.file 5 "C:\\Dokumente und Einstellungen\\brand\\Desktop\\thundercyer-the-alarm-clock\\FreeRTOS\\S
 1484              		.file 6 "C:\\Dokumente und Einstellungen\\brand\\Desktop\\thundercyer-the-alarm-clock\\FreeRTOS\\S
 1485              		.file 7 "C:\\Dokumente und Einstellungen\\brand\\Desktop\\thundercyer-the-alarm-clock\\CMSIS\\Incl
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
  C:\Temp\ccsnKVEB.s:18     .text:00000000 $t
  C:\Temp\ccsnKVEB.s:23     .text:00000000 xQueueCreate
  C:\Temp\ccsnKVEB.s:155    .text:000000d0 xQueueCreateMutex
  C:\Temp\ccsnKVEB.s:249    .text:00000168 xQueueGenericSend
  C:\Temp\ccsnKVEB.s:991    .text:00000598 prvCopyDataToQueue
  C:\Temp\ccsnKVEB.s:1391   .text:000007a0 prvIsQueueFull
  C:\Temp\ccsnKVEB.s:1188   .text:000006b0 prvUnlockQueue
  C:\Temp\ccsnKVEB.s:428    .text:0000028c xQueueGenericSendFromISR
  C:\Temp\ccsnKVEB.s:533    .text:0000031c xQueueGenericReceive
  C:\Temp\ccsnKVEB.s:1121   .text:00000660 prvCopyDataFromQueue
  C:\Temp\ccsnKVEB.s:1305   .text:00000750 prvIsQueueEmpty
  C:\Temp\ccsnKVEB.s:769    .text:000004a4 xQueueReceiveFromISR
  C:\Temp\ccsnKVEB.s:875    .text:00000538 uxQueueMessagesWaiting
  C:\Temp\ccsnKVEB.s:916    .text:0000055c uxQueueMessagesWaitingFromISR
  C:\Temp\ccsnKVEB.s:954    .text:00000578 vQueueDelete
  C:\Temp\ccsnKVEB.s:1350   .text:0000077c xQueueIsQueueEmptyFromISR
  C:\Temp\ccsnKVEB.s:1439   .text:000007d0 xQueueIsQueueFullFromISR
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
malloc
vListInitialise
free
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vPortExitCritical
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
xTaskGetCurrentTaskHandle
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
