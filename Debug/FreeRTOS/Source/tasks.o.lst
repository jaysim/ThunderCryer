   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.global	pxCurrentTCB
  20              		.section	.bss.pxCurrentTCB,"aw",%nobits
  21              		.align	2
  24              	pxCurrentTCB:
  25 0000 00000000 		.space	4
  26              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  27              		.align	2
  30              	pxReadyTasksLists:
  31 0000 00000000 		.space	200
  31      00000000 
  31      00000000 
  31      00000000 
  31      00000000 
  32              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  33              		.align	2
  36              	xDelayedTaskList1:
  37 0000 00000000 		.space	20
  37      00000000 
  37      00000000 
  37      00000000 
  37      00000000 
  38              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  39              		.align	2
  42              	xDelayedTaskList2:
  43 0000 00000000 		.space	20
  43      00000000 
  43      00000000 
  43      00000000 
  43      00000000 
  44              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  45              		.align	2
  48              	pxDelayedTaskList:
  49 0000 00000000 		.space	4
  50              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  51              		.align	2
  54              	pxOverflowDelayedTaskList:
  55 0000 00000000 		.space	4
  56              		.section	.bss.xPendingReadyList,"aw",%nobits
  57              		.align	2
  60              	xPendingReadyList:
  61 0000 00000000 		.space	20
  61      00000000 
  61      00000000 
  61      00000000 
  61      00000000 
  62              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  63              		.align	2
  66              	xTasksWaitingTermination:
  67 0000 00000000 		.space	20
  67      00000000 
  67      00000000 
  67      00000000 
  67      00000000 
  68              		.section	.bss.uxTasksDeleted,"aw",%nobits
  69              		.align	2
  72              	uxTasksDeleted:
  73 0000 00000000 		.space	4
  74              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  75              		.align	2
  78              	xSuspendedTaskList:
  79 0000 00000000 		.space	20
  79      00000000 
  79      00000000 
  79      00000000 
  79      00000000 
  80              		.section	.bss.xIdleTaskHandle,"aw",%nobits
  81              		.align	2
  84              	xIdleTaskHandle:
  85 0000 00000000 		.space	4
  86              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  87              		.align	2
  90              	uxCurrentNumberOfTasks:
  91 0000 00000000 		.space	4
  92              		.section	.bss.xTickCount,"aw",%nobits
  93              		.align	2
  96              	xTickCount:
  97 0000 00000000 		.space	4
  98              		.section	.bss.uxTopUsedPriority,"aw",%nobits
  99              		.align	2
 102              	uxTopUsedPriority:
 103 0000 00000000 		.space	4
 104              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 105              		.align	2
 108              	uxTopReadyPriority:
 109 0000 00000000 		.space	4
 110              		.section	.bss.xSchedulerRunning,"aw",%nobits
 111              		.align	2
 114              	xSchedulerRunning:
 115 0000 00000000 		.space	4
 116              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 117              		.align	2
 120              	uxSchedulerSuspended:
 121 0000 00000000 		.space	4
 122              		.section	.bss.uxMissedTicks,"aw",%nobits
 123              		.align	2
 126              	uxMissedTicks:
 127 0000 00000000 		.space	4
 128              		.section	.bss.xMissedYield,"aw",%nobits
 129              		.align	2
 132              	xMissedYield:
 133 0000 00000000 		.space	4
 134              		.section	.bss.xNumOfOverflows,"aw",%nobits
 135              		.align	2
 138              	xNumOfOverflows:
 139 0000 00000000 		.space	4
 140              		.section	.bss.uxTaskNumber,"aw",%nobits
 141              		.align	2
 144              	uxTaskNumber:
 145 0000 00000000 		.space	4
 146              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 147              		.align	2
 150              	xNextTaskUnblockTime:
 151 0000 FFFFFFFF 		.word	-1
 152              		.section	.bss.pcStatsString,"aw",%nobits
 153              		.align	2
 156              	pcStatsString:
 157 0000 00000000 		.space	50
 157      00000000 
 157      00000000 
 157      00000000 
 157      00000000 
 158 0032 0000     		.section	.bss.ulTaskSwitchedInTime,"aw",%nobits
 159              		.align	2
 162              	ulTaskSwitchedInTime:
 163 0000 00000000 		.space	4
 164              		.text
 165              		.align	2
 166              		.global	xTaskGenericCreate
 167              		.thumb
 168              		.thumb_func
 170              	xTaskGenericCreate:
 171              	.LFB110:
 172              		.file 1 "../FreeRTOS/Source/tasks.c"
   1:../FreeRTOS/Source/tasks.c **** /*
   2:../FreeRTOS/Source/tasks.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS/Source/tasks.c **** 	
   4:../FreeRTOS/Source/tasks.c **** 
   5:../FreeRTOS/Source/tasks.c ****     ***************************************************************************
   6:../FreeRTOS/Source/tasks.c ****      *                                                                       *
   7:../FreeRTOS/Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS/Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS/Source/tasks.c ****      *    available.                                                         *
  10:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  11:../FreeRTOS/Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS/Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS/Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS/Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS/Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS/Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  18:../FreeRTOS/Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  20:../FreeRTOS/Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  22:../FreeRTOS/Source/tasks.c ****     ***************************************************************************
  23:../FreeRTOS/Source/tasks.c **** 
  24:../FreeRTOS/Source/tasks.c **** 
  25:../FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS/Source/tasks.c **** 
  27:../FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS/Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS/Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS/Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS/Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS/Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS/Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS/Source/tasks.c ****     FreeRTOS WEB site.
  41:../FreeRTOS/Source/tasks.c **** 
  42:../FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  43:../FreeRTOS/Source/tasks.c **** 
  44:../FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS/Source/tasks.c ****     contact details.
  46:../FreeRTOS/Source/tasks.c **** 
  47:../FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS/Source/tasks.c ****     critical systems.
  49:../FreeRTOS/Source/tasks.c **** 
  50:../FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS/Source/tasks.c ****     licensing and training services.
  52:../FreeRTOS/Source/tasks.c **** */
  53:../FreeRTOS/Source/tasks.c **** 
  54:../FreeRTOS/Source/tasks.c **** 
  55:../FreeRTOS/Source/tasks.c **** #include <stdio.h>
  56:../FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  57:../FreeRTOS/Source/tasks.c **** #include <string.h>
  58:../FreeRTOS/Source/tasks.c **** 
  59:../FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  62:../FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../FreeRTOS/Source/tasks.c **** 
  64:../FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  65:../FreeRTOS/Source/tasks.c **** #include "task.h"
  66:../FreeRTOS/Source/tasks.c **** #include "timers.h"
  67:../FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  68:../FreeRTOS/Source/tasks.c **** 
  69:../FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../FreeRTOS/Source/tasks.c **** 
  71:../FreeRTOS/Source/tasks.c **** /*
  72:../FreeRTOS/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:../FreeRTOS/Source/tasks.c ****  */
  74:../FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:../FreeRTOS/Source/tasks.c **** 
  76:../FreeRTOS/Source/tasks.c **** /*
  77:../FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:../FreeRTOS/Source/tasks.c ****  * and stores the context of the task.
  79:../FreeRTOS/Source/tasks.c ****  */
  80:../FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
  81:../FreeRTOS/Source/tasks.c **** {
  82:../FreeRTOS/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:../FreeRTOS/Source/tasks.c **** 
  84:../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:../FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:../FreeRTOS/Source/tasks.c **** 	#endif	
  87:../FreeRTOS/Source/tasks.c **** 	
  88:../FreeRTOS/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:../FreeRTOS/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:../FreeRTOS/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:../FreeRTOS/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:../FreeRTOS/Source/tasks.c **** 
  94:../FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:../FreeRTOS/Source/tasks.c **** 	#endif
  97:../FreeRTOS/Source/tasks.c **** 
  98:../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:../FreeRTOS/Source/tasks.c **** 	#endif
 101:../FreeRTOS/Source/tasks.c **** 
 102:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 104:../FreeRTOS/Source/tasks.c **** 	#endif
 105:../FreeRTOS/Source/tasks.c **** 
 106:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 107:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 108:../FreeRTOS/Source/tasks.c **** 	#endif
 109:../FreeRTOS/Source/tasks.c **** 
 110:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 111:../FreeRTOS/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 112:../FreeRTOS/Source/tasks.c **** 	#endif
 113:../FreeRTOS/Source/tasks.c **** 
 114:../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 115:../FreeRTOS/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 116:../FreeRTOS/Source/tasks.c **** 	#endif
 117:../FreeRTOS/Source/tasks.c **** 
 118:../FreeRTOS/Source/tasks.c **** } tskTCB;
 119:../FreeRTOS/Source/tasks.c **** 
 120:../FreeRTOS/Source/tasks.c **** 
 121:../FreeRTOS/Source/tasks.c **** /*
 122:../FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 123:../FreeRTOS/Source/tasks.c ****  * than file scope.
 124:../FreeRTOS/Source/tasks.c ****  */
 125:../FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 126:../FreeRTOS/Source/tasks.c **** 	#define static
 127:../FreeRTOS/Source/tasks.c **** #endif
 128:../FreeRTOS/Source/tasks.c **** 
 129:../FreeRTOS/Source/tasks.c **** /*lint -e956 */
 130:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 131:../FreeRTOS/Source/tasks.c **** 
 132:../FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 133:../FreeRTOS/Source/tasks.c **** 
 134:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 135:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 136:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 137:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 138:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 139:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 140:../FreeRTOS/Source/tasks.c **** 
 141:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 142:../FreeRTOS/Source/tasks.c **** 
 143:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 144:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 145:../FreeRTOS/Source/tasks.c **** 
 146:../FreeRTOS/Source/tasks.c **** #endif
 147:../FreeRTOS/Source/tasks.c **** 
 148:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 149:../FreeRTOS/Source/tasks.c **** 
 150:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 151:../FreeRTOS/Source/tasks.c **** 
 152:../FreeRTOS/Source/tasks.c **** #endif
 153:../FreeRTOS/Source/tasks.c **** 
 154:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 155:../FreeRTOS/Source/tasks.c **** 	
 156:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 157:../FreeRTOS/Source/tasks.c **** 	
 158:../FreeRTOS/Source/tasks.c **** #endif
 159:../FreeRTOS/Source/tasks.c **** 
 160:../FreeRTOS/Source/tasks.c **** /* File private variables. --------------------------------*/
 161:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 162:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 163:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 164:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 165:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 166:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 167:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 168:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 169:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 170:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 171:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 172:../FreeRTOS/Source/tasks.c **** 
 173:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 174:../FreeRTOS/Source/tasks.c **** 
 175:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 176:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 177:../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 178:../FreeRTOS/Source/tasks.c **** 
 179:../FreeRTOS/Source/tasks.c **** #endif
 180:../FreeRTOS/Source/tasks.c **** 
 181:../FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 182:../FreeRTOS/Source/tasks.c **** 
 183:../FreeRTOS/Source/tasks.c **** /*
 184:../FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 185:../FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 186:../FreeRTOS/Source/tasks.c ****  */
 187:../FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 188:../FreeRTOS/Source/tasks.c **** 
 189:../FreeRTOS/Source/tasks.c **** /*
 190:../FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 191:../FreeRTOS/Source/tasks.c ****  */
 192:../FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 193:../FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 194:../FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 195:../FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 196:../FreeRTOS/Source/tasks.c **** 
 197:../FreeRTOS/Source/tasks.c **** /*
 198:../FreeRTOS/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 199:../FreeRTOS/Source/tasks.c ****  */
 200:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 201:../FreeRTOS/Source/tasks.c **** 
 202:../FreeRTOS/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 203:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 204:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 205:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 206:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 207:../FreeRTOS/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255U;
 208:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 209:../FreeRTOS/Source/tasks.c **** 
 210:../FreeRTOS/Source/tasks.c **** #endif
 211:../FreeRTOS/Source/tasks.c **** 
 212:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 213:../FreeRTOS/Source/tasks.c **** 
 214:../FreeRTOS/Source/tasks.c **** /*
 215:../FreeRTOS/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 216:../FreeRTOS/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 217:../FreeRTOS/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 218:../FreeRTOS/Source/tasks.c ****  * it if not using the facility.
 219:../FreeRTOS/Source/tasks.c ****  */
 220:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 221:../FreeRTOS/Source/tasks.c **** 
 222:../FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 223:../FreeRTOS/Source/tasks.c **** 	{																								\
 224:../FreeRTOS/Source/tasks.c **** 		if( xTracing != pdFALSE )																	\
 225:../FreeRTOS/Source/tasks.c **** 		{																							\
 226:../FreeRTOS/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 227:../FreeRTOS/Source/tasks.c **** 			{																						\
 228:../FreeRTOS/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 229:../FreeRTOS/Source/tasks.c **** 				{																					\
 230:../FreeRTOS/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 231:../FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;				\
 232:../FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 233:../FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;			\
 234:../FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 235:../FreeRTOS/Source/tasks.c **** 				}																					\
 236:../FreeRTOS/Source/tasks.c **** 				else																				\
 237:../FreeRTOS/Source/tasks.c **** 				{																					\
 238:../FreeRTOS/Source/tasks.c **** 					xTracing = pdFALSE;																\
 239:../FreeRTOS/Source/tasks.c **** 				}																					\
 240:../FreeRTOS/Source/tasks.c **** 			}																						\
 241:../FreeRTOS/Source/tasks.c **** 		}																							\
 242:../FreeRTOS/Source/tasks.c **** 	}
 243:../FreeRTOS/Source/tasks.c **** 
 244:../FreeRTOS/Source/tasks.c **** #else
 245:../FreeRTOS/Source/tasks.c **** 
 246:../FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 247:../FreeRTOS/Source/tasks.c **** 
 248:../FreeRTOS/Source/tasks.c **** #endif
 249:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 250:../FreeRTOS/Source/tasks.c **** 
 251:../FreeRTOS/Source/tasks.c **** /*
 252:../FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 253:../FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 254:../FreeRTOS/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 255:../FreeRTOS/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 256:../FreeRTOS/Source/tasks.c ****  * executing task has been rescheduled.
 257:../FreeRTOS/Source/tasks.c ****  */
 258:../FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 259:../FreeRTOS/Source/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 260:../FreeRTOS/Source/tasks.c **** 	{																													\
 261:../FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 262:../FreeRTOS/Source/tasks.c **** 	}																													\
 263:../FreeRTOS/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 264:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 265:../FreeRTOS/Source/tasks.c **** 
 266:../FreeRTOS/Source/tasks.c **** /*
 267:../FreeRTOS/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 268:../FreeRTOS/Source/tasks.c ****  * any require waking.
 269:../FreeRTOS/Source/tasks.c ****  *
 270:../FreeRTOS/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 271:../FreeRTOS/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 272:../FreeRTOS/Source/tasks.c ****  * any further down the list.
 273:../FreeRTOS/Source/tasks.c ****  */
 274:../FreeRTOS/Source/tasks.c **** #define prvCheckDelayedTasks()															\
 275:../FreeRTOS/Source/tasks.c **** {																						\
 276:../FreeRTOS/Source/tasks.c **** portTickType xItemValue;																\
 277:../FreeRTOS/Source/tasks.c **** 																						\
 278:../FreeRTOS/Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 279:../FreeRTOS/Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 280:../FreeRTOS/Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 281:../FreeRTOS/Source/tasks.c **** 	{																					\
 282:../FreeRTOS/Source/tasks.c **** 		for( ;; )																		\
 283:../FreeRTOS/Source/tasks.c **** 		{																				\
 284:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 285:../FreeRTOS/Source/tasks.c **** 			{																			\
 286:../FreeRTOS/Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 287:../FreeRTOS/Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 288:../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 289:../FreeRTOS/Source/tasks.c **** 				time through. */														\
 290:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 291:../FreeRTOS/Source/tasks.c **** 				break;																	\
 292:../FreeRTOS/Source/tasks.c **** 			}																			\
 293:../FreeRTOS/Source/tasks.c **** 			else																		\
 294:../FreeRTOS/Source/tasks.c **** 			{																			\
 295:../FreeRTOS/Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 296:../FreeRTOS/Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 297:../FreeRTOS/Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 298:../FreeRTOS/Source/tasks.c **** 				the Blocked state. */													\
 299:../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 300:../FreeRTOS/Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 301:../FreeRTOS/Source/tasks.c **** 																						\
 302:../FreeRTOS/Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 303:../FreeRTOS/Source/tasks.c **** 				{																		\
 304:../FreeRTOS/Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 305:../FreeRTOS/Source/tasks.c **** 					value is the time at which the task at the head of the				\
 306:../FreeRTOS/Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 307:../FreeRTOS/Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 308:../FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 309:../FreeRTOS/Source/tasks.c **** 					break;																\
 310:../FreeRTOS/Source/tasks.c **** 				}																		\
 311:../FreeRTOS/Source/tasks.c **** 																						\
 312:../FreeRTOS/Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 313:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 314:../FreeRTOS/Source/tasks.c **** 																						\
 315:../FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 316:../FreeRTOS/Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 317:../FreeRTOS/Source/tasks.c **** 				{																		\
 318:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 319:../FreeRTOS/Source/tasks.c **** 				}																		\
 320:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 321:../FreeRTOS/Source/tasks.c **** 			}																			\
 322:../FreeRTOS/Source/tasks.c **** 		}																				\
 323:../FreeRTOS/Source/tasks.c **** 	}																					\
 324:../FreeRTOS/Source/tasks.c **** }
 325:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 326:../FreeRTOS/Source/tasks.c **** 
 327:../FreeRTOS/Source/tasks.c **** /*
 328:../FreeRTOS/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 329:../FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 330:../FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 331:../FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 332:../FreeRTOS/Source/tasks.c ****  */
 333:../FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 334:../FreeRTOS/Source/tasks.c **** 
 335:../FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 336:../FreeRTOS/Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 337:../FreeRTOS/Source/tasks.c **** extern void vApplicationTickHook( void );
 338:../FreeRTOS/Source/tasks.c **** 		
 339:../FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 340:../FreeRTOS/Source/tasks.c **** 
 341:../FreeRTOS/Source/tasks.c **** /*
 342:../FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 343:../FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 344:../FreeRTOS/Source/tasks.c ****  */
 345:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 346:../FreeRTOS/Source/tasks.c **** 
 347:../FreeRTOS/Source/tasks.c **** /*
 348:../FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 349:../FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 350:../FreeRTOS/Source/tasks.c ****  */
 351:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 352:../FreeRTOS/Source/tasks.c **** 
 353:../FreeRTOS/Source/tasks.c **** /*
 354:../FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 355:../FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 356:../FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 357:../FreeRTOS/Source/tasks.c ****  *
 358:../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 359:../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 360:../FreeRTOS/Source/tasks.c ****  *
 361:../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 362:../FreeRTOS/Source/tasks.c ****  *
 363:../FreeRTOS/Source/tasks.c ****  */
 364:../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 365:../FreeRTOS/Source/tasks.c **** 
 366:../FreeRTOS/Source/tasks.c **** /*
 367:../FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 368:../FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 369:../FreeRTOS/Source/tasks.c ****  *
 370:../FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 371:../FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 372:../FreeRTOS/Source/tasks.c ****  */
 373:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 374:../FreeRTOS/Source/tasks.c **** 
 375:../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 376:../FreeRTOS/Source/tasks.c **** 
 377:../FreeRTOS/Source/tasks.c **** #endif
 378:../FreeRTOS/Source/tasks.c **** 
 379:../FreeRTOS/Source/tasks.c **** /*
 380:../FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 381:../FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 382:../FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 383:../FreeRTOS/Source/tasks.c ****  */
 384:../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 385:../FreeRTOS/Source/tasks.c **** 
 386:../FreeRTOS/Source/tasks.c **** /*
 387:../FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 388:../FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 389:../FreeRTOS/Source/tasks.c ****  */
 390:../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 391:../FreeRTOS/Source/tasks.c **** 
 392:../FreeRTOS/Source/tasks.c **** /*
 393:../FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 394:../FreeRTOS/Source/tasks.c ****  * allocation was successful.
 395:../FreeRTOS/Source/tasks.c ****  */
 396:../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 397:../FreeRTOS/Source/tasks.c **** 
 398:../FreeRTOS/Source/tasks.c **** /*
 399:../FreeRTOS/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 400:../FreeRTOS/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 401:../FreeRTOS/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 402:../FreeRTOS/Source/tasks.c ****  * within just that list.
 403:../FreeRTOS/Source/tasks.c ****  *
 404:../FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 405:../FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 406:../FreeRTOS/Source/tasks.c ****  */
 407:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 408:../FreeRTOS/Source/tasks.c **** 
 409:../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 410:../FreeRTOS/Source/tasks.c **** 
 411:../FreeRTOS/Source/tasks.c **** #endif
 412:../FreeRTOS/Source/tasks.c **** 
 413:../FreeRTOS/Source/tasks.c **** /*
 414:../FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 415:../FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 416:../FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 417:../FreeRTOS/Source/tasks.c ****  */
 418:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 419:../FreeRTOS/Source/tasks.c **** 
 420:../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 421:../FreeRTOS/Source/tasks.c **** 
 422:../FreeRTOS/Source/tasks.c **** #endif
 423:../FreeRTOS/Source/tasks.c **** 
 424:../FreeRTOS/Source/tasks.c **** 
 425:../FreeRTOS/Source/tasks.c **** /*lint +e956 */
 426:../FreeRTOS/Source/tasks.c **** 
 427:../FreeRTOS/Source/tasks.c **** 
 428:../FreeRTOS/Source/tasks.c **** 
 429:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 430:../FreeRTOS/Source/tasks.c ****  * TASK CREATION API documented in task.h
 431:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 432:../FreeRTOS/Source/tasks.c **** 
 433:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 434:../FreeRTOS/Source/tasks.c **** {
 173              		.loc 1 434 0
 174              		.cfi_startproc
 175              		@ args = 16, pretend = 0, frame = 32
 176              		@ frame_needed = 1, uses_anonymous_args = 0
 177 0000 80B5     		push	{r7, lr}
 178              	.LCFI0:
 179              		.cfi_def_cfa_offset 8
 180              		.cfi_offset 14, -4
 181              		.cfi_offset 7, -8
 182 0002 8AB0     		sub	sp, sp, #40
 183              	.LCFI1:
 184              		.cfi_def_cfa_offset 48
 185 0004 02AF     		add	r7, sp, #8
 186              	.LCFI2:
 187              		.cfi_def_cfa 7, 40
 188 0006 F860     		str	r0, [r7, #12]
 189 0008 B960     		str	r1, [r7, #8]
 190 000a 3B60     		str	r3, [r7, #0]
 191 000c 1346     		mov	r3, r2	@ movhi
 192 000e FB80     		strh	r3, [r7, #6]	@ movhi
 435:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 436:../FreeRTOS/Source/tasks.c **** tskTCB * pxNewTCB;
 437:../FreeRTOS/Source/tasks.c **** 
 438:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 439:../FreeRTOS/Source/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 440:../FreeRTOS/Source/tasks.c **** 
 441:../FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 442:../FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 443:../FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 193              		.loc 1 443 0
 194 0010 FB88     		ldrh	r3, [r7, #6]
 195 0012 1846     		mov	r0, r3
 196 0014 396B     		ldr	r1, [r7, #48]
 197 0016 01F0CDF9 		bl	prvAllocateTCBAndStack
 198 001a 0346     		mov	r3, r0
 199 001c BB61     		str	r3, [r7, #24]
 444:../FreeRTOS/Source/tasks.c **** 
 445:../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 200              		.loc 1 445 0
 201 001e BB69     		ldr	r3, [r7, #24]
 202 0020 002B     		cmp	r3, #0
 203 0022 00F0A580 		beq	.L2
 204              	.LBB2:
 446:../FreeRTOS/Source/tasks.c **** 	{
 447:../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 448:../FreeRTOS/Source/tasks.c **** 
 449:../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 450:../FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 451:../FreeRTOS/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 452:../FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 453:../FreeRTOS/Source/tasks.c **** 			{
 454:../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 455:../FreeRTOS/Source/tasks.c **** 			}
 456:../FreeRTOS/Source/tasks.c **** 			else
 457:../FreeRTOS/Source/tasks.c **** 			{
 458:../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 459:../FreeRTOS/Source/tasks.c **** 			}
 460:../FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 461:../FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 462:../FreeRTOS/Source/tasks.c **** 
 463:../FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 464:../FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 465:../FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 466:../FreeRTOS/Source/tasks.c **** 		required by the port. */
 467:../FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 468:../FreeRTOS/Source/tasks.c **** 		{
 469:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 205              		.loc 1 469 0
 206 0026 BB69     		ldr	r3, [r7, #24]
 207 0028 1A6B     		ldr	r2, [r3, #48]
 208 002a FB88     		ldrh	r3, [r7, #6]
 209 002c 03F1FF33 		add	r3, r3, #-1
 210 0030 4FEA8303 		lsl	r3, r3, #2
 211 0034 D318     		adds	r3, r2, r3
 212 0036 7B61     		str	r3, [r7, #20]
 470:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 213              		.loc 1 470 0
 214 0038 7B69     		ldr	r3, [r7, #20]
 215 003a 23F00703 		bic	r3, r3, #7
 216 003e 7B61     		str	r3, [r7, #20]
 471:../FreeRTOS/Source/tasks.c **** 
 472:../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 473:../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 474:../FreeRTOS/Source/tasks.c **** 		}
 475:../FreeRTOS/Source/tasks.c **** 		#else
 476:../FreeRTOS/Source/tasks.c **** 		{
 477:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 478:../FreeRTOS/Source/tasks.c **** 			
 479:../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 480:../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 481:../FreeRTOS/Source/tasks.c **** 
 482:../FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 483:../FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 484:../FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 485:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 486:../FreeRTOS/Source/tasks.c **** 		}
 487:../FreeRTOS/Source/tasks.c **** 		#endif
 488:../FreeRTOS/Source/tasks.c **** 
 489:../FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 490:../FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 217              		.loc 1 490 0
 218 0040 FB88     		ldrh	r3, [r7, #6]
 219 0042 0093     		str	r3, [sp, #0]
 220 0044 B869     		ldr	r0, [r7, #24]
 221 0046 B968     		ldr	r1, [r7, #8]
 222 0048 BA6A     		ldr	r2, [r7, #40]
 223 004a 7B6B     		ldr	r3, [r7, #52]
 224 004c 01F08AF8 		bl	prvInitialiseTCBVariables
 491:../FreeRTOS/Source/tasks.c **** 
 492:../FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 493:../FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 494:../FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 495:../FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 496:../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 497:../FreeRTOS/Source/tasks.c **** 		{
 498:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 499:../FreeRTOS/Source/tasks.c **** 		}
 500:../FreeRTOS/Source/tasks.c **** 		#else
 501:../FreeRTOS/Source/tasks.c **** 		{
 502:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 225              		.loc 1 502 0
 226 0050 7869     		ldr	r0, [r7, #20]
 227 0052 F968     		ldr	r1, [r7, #12]
 228 0054 3A68     		ldr	r2, [r7, #0]
 229 0056 FFF7FEFF 		bl	pxPortInitialiseStack
 230 005a 0246     		mov	r2, r0
 231 005c BB69     		ldr	r3, [r7, #24]
 232 005e 1A60     		str	r2, [r3, #0]
 503:../FreeRTOS/Source/tasks.c **** 		}
 504:../FreeRTOS/Source/tasks.c **** 		#endif
 505:../FreeRTOS/Source/tasks.c **** 
 506:../FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 507:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT
 508:../FreeRTOS/Source/tasks.c **** 
 509:../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 233              		.loc 1 509 0
 234 0060 FB6A     		ldr	r3, [r7, #44]
 235 0062 002B     		cmp	r3, #0
 236 0064 02D0     		beq	.L3
 510:../FreeRTOS/Source/tasks.c **** 		{
 511:../FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 512:../FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 513:../FreeRTOS/Source/tasks.c **** 			required.*/
 514:../FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 237              		.loc 1 514 0
 238 0066 FB6A     		ldr	r3, [r7, #44]
 239 0068 BA69     		ldr	r2, [r7, #24]
 240 006a 1A60     		str	r2, [r3, #0]
 241              	.L3:
 515:../FreeRTOS/Source/tasks.c **** 		}
 516:../FreeRTOS/Source/tasks.c **** 		
 517:../FreeRTOS/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 518:../FreeRTOS/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 519:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 242              		.loc 1 519 0
 243 006c FFF7FEFF 		bl	vPortEnterCritical
 520:../FreeRTOS/Source/tasks.c **** 		{
 521:../FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 244              		.loc 1 521 0
 245 0070 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 246 0074 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 247 0078 1B68     		ldr	r3, [r3, #0]
 248 007a 03F10102 		add	r2, r3, #1
 249 007e 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 250 0082 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 251 0086 1A60     		str	r2, [r3, #0]
 522:../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 252              		.loc 1 522 0
 253 0088 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 254 008c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 255 0090 1B68     		ldr	r3, [r3, #0]
 256 0092 002B     		cmp	r3, #0
 257 0094 0FD1     		bne	.L4
 523:../FreeRTOS/Source/tasks.c **** 			{
 524:../FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 525:../FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 526:../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 258              		.loc 1 526 0
 259 0096 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 260 009a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 261 009e BA69     		ldr	r2, [r7, #24]
 262 00a0 1A60     		str	r2, [r3, #0]
 527:../FreeRTOS/Source/tasks.c **** 
 528:../FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 263              		.loc 1 528 0
 264 00a2 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 265 00a6 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 266 00aa 1B68     		ldr	r3, [r3, #0]
 267 00ac 012B     		cmp	r3, #1
 268 00ae 18D1     		bne	.L5
 529:../FreeRTOS/Source/tasks.c **** 				{
 530:../FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 531:../FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 532:../FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 533:../FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 269              		.loc 1 533 0
 270 00b0 01F09CF8 		bl	prvInitialiseTaskLists
 271 00b4 15E0     		b	.L5
 272              	.L4:
 534:../FreeRTOS/Source/tasks.c **** 				}
 535:../FreeRTOS/Source/tasks.c **** 			}
 536:../FreeRTOS/Source/tasks.c **** 			else
 537:../FreeRTOS/Source/tasks.c **** 			{
 538:../FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 539:../FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 540:../FreeRTOS/Source/tasks.c **** 				so far. */
 541:../FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 273              		.loc 1 541 0
 274 00b6 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 275 00ba C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 276 00be 1B68     		ldr	r3, [r3, #0]
 277 00c0 002B     		cmp	r3, #0
 278 00c2 0ED1     		bne	.L5
 542:../FreeRTOS/Source/tasks.c **** 				{
 543:../FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 279              		.loc 1 543 0
 280 00c4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 281 00c8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 282 00cc 1B68     		ldr	r3, [r3, #0]
 283 00ce DA6A     		ldr	r2, [r3, #44]
 284 00d0 BB6A     		ldr	r3, [r7, #40]
 285 00d2 9A42     		cmp	r2, r3
 286 00d4 05D8     		bhi	.L5
 544:../FreeRTOS/Source/tasks.c **** 					{
 545:../FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 287              		.loc 1 545 0
 288 00d6 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 289 00da C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 290 00de BA69     		ldr	r2, [r7, #24]
 291 00e0 1A60     		str	r2, [r3, #0]
 292              	.L5:
 546:../FreeRTOS/Source/tasks.c **** 					}
 547:../FreeRTOS/Source/tasks.c **** 				}
 548:../FreeRTOS/Source/tasks.c **** 			}
 549:../FreeRTOS/Source/tasks.c **** 
 550:../FreeRTOS/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 551:../FreeRTOS/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 552:../FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 293              		.loc 1 552 0
 294 00e2 BB69     		ldr	r3, [r7, #24]
 295 00e4 DA6A     		ldr	r2, [r3, #44]
 296 00e6 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 297 00ea C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 298 00ee 1B68     		ldr	r3, [r3, #0]
 299 00f0 9A42     		cmp	r2, r3
 300 00f2 06D9     		bls	.L6
 553:../FreeRTOS/Source/tasks.c **** 			{
 554:../FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 301              		.loc 1 554 0
 302 00f4 BB69     		ldr	r3, [r7, #24]
 303 00f6 DA6A     		ldr	r2, [r3, #44]
 304 00f8 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 305 00fc C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 306 0100 1A60     		str	r2, [r3, #0]
 307              	.L6:
 555:../FreeRTOS/Source/tasks.c **** 			}
 556:../FreeRTOS/Source/tasks.c **** 
 557:../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 558:../FreeRTOS/Source/tasks.c **** 			{
 559:../FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 560:../FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 561:../FreeRTOS/Source/tasks.c **** 			}
 562:../FreeRTOS/Source/tasks.c **** 			#endif
 563:../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 308              		.loc 1 563 0
 309 0102 40F20003 		movw	r3, #:lower16:uxTaskNumber
 310 0106 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 311 010a 1B68     		ldr	r3, [r3, #0]
 312 010c 03F10102 		add	r2, r3, #1
 313 0110 40F20003 		movw	r3, #:lower16:uxTaskNumber
 314 0114 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 315 0118 1A60     		str	r2, [r3, #0]
 564:../FreeRTOS/Source/tasks.c **** 
 565:../FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 316              		.loc 1 565 0
 317 011a BB69     		ldr	r3, [r7, #24]
 318 011c DA6A     		ldr	r2, [r3, #44]
 319 011e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 320 0122 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 321 0126 1B68     		ldr	r3, [r3, #0]
 322 0128 9A42     		cmp	r2, r3
 323 012a 06D9     		bls	.L7
 324              		.loc 1 565 0 is_stmt 0 discriminator 1
 325 012c BB69     		ldr	r3, [r7, #24]
 326 012e DA6A     		ldr	r2, [r3, #44]
 327 0130 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 328 0134 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 329 0138 1A60     		str	r2, [r3, #0]
 330              	.L7:
 331              		.loc 1 565 0 discriminator 2
 332 013a BB69     		ldr	r3, [r7, #24]
 333 013c DA6A     		ldr	r2, [r3, #44]
 334 013e 1346     		mov	r3, r2
 335 0140 4FEA8303 		lsl	r3, r3, #2
 336 0144 9B18     		adds	r3, r3, r2
 337 0146 4FEA8303 		lsl	r3, r3, #2
 338 014a 1A46     		mov	r2, r3
 339 014c 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 340 0150 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 341 0154 D218     		adds	r2, r2, r3
 342 0156 BB69     		ldr	r3, [r7, #24]
 343 0158 03F10403 		add	r3, r3, #4
 344 015c 1046     		mov	r0, r2
 345 015e 1946     		mov	r1, r3
 346 0160 FFF7FEFF 		bl	vListInsertEnd
 566:../FreeRTOS/Source/tasks.c **** 
 567:../FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 347              		.loc 1 567 0 is_stmt 1 discriminator 2
 348 0164 4FF00103 		mov	r3, #1
 349 0168 FB61     		str	r3, [r7, #28]
 568:../FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 569:../FreeRTOS/Source/tasks.c **** 		}
 570:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 350              		.loc 1 570 0 discriminator 2
 351 016a FFF7FEFF 		bl	vPortExitCritical
 352 016e 02E0     		b	.L8
 353              	.L2:
 354              	.LBE2:
 571:../FreeRTOS/Source/tasks.c **** 	}
 572:../FreeRTOS/Source/tasks.c **** 	else
 573:../FreeRTOS/Source/tasks.c **** 	{
 574:../FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 355              		.loc 1 574 0
 356 0170 4FF0FF33 		mov	r3, #-1
 357 0174 FB61     		str	r3, [r7, #28]
 358              	.L8:
 575:../FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 576:../FreeRTOS/Source/tasks.c **** 	}
 577:../FreeRTOS/Source/tasks.c **** 
 578:../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 359              		.loc 1 578 0
 360 0176 FB69     		ldr	r3, [r7, #28]
 361 0178 012B     		cmp	r3, #1
 362 017a 11D1     		bne	.L9
 579:../FreeRTOS/Source/tasks.c **** 	{
 580:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 363              		.loc 1 580 0
 364 017c 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 365 0180 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 366 0184 1B68     		ldr	r3, [r3, #0]
 367 0186 002B     		cmp	r3, #0
 368 0188 0AD0     		beq	.L9
 581:../FreeRTOS/Source/tasks.c **** 		{
 582:../FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 583:../FreeRTOS/Source/tasks.c **** 			then it should run now. */
 584:../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 369              		.loc 1 584 0
 370 018a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 371 018e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 372 0192 1B68     		ldr	r3, [r3, #0]
 373 0194 DA6A     		ldr	r2, [r3, #44]
 374 0196 BB6A     		ldr	r3, [r7, #40]
 375 0198 9A42     		cmp	r2, r3
 376 019a 01D2     		bcs	.L9
 585:../FreeRTOS/Source/tasks.c **** 			{
 586:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 377              		.loc 1 586 0
 378 019c FFF7FEFF 		bl	vPortYieldFromISR
 379              	.L9:
 587:../FreeRTOS/Source/tasks.c **** 			}
 588:../FreeRTOS/Source/tasks.c **** 		}
 589:../FreeRTOS/Source/tasks.c **** 	}
 590:../FreeRTOS/Source/tasks.c **** 
 591:../FreeRTOS/Source/tasks.c **** 	return xReturn;
 380              		.loc 1 591 0
 381 01a0 FB69     		ldr	r3, [r7, #28]
 592:../FreeRTOS/Source/tasks.c **** }
 382              		.loc 1 592 0
 383 01a2 1846     		mov	r0, r3
 384 01a4 07F12007 		add	r7, r7, #32
 385 01a8 BD46     		mov	sp, r7
 386 01aa 80BD     		pop	{r7, pc}
 387              		.cfi_endproc
 388              	.LFE110:
 390              		.align	2
 391              		.global	vTaskDelete
 392              		.thumb
 393              		.thumb_func
 395              	vTaskDelete:
 396              	.LFB111:
 593:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 594:../FreeRTOS/Source/tasks.c **** 
 595:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 596:../FreeRTOS/Source/tasks.c **** 
 597:../FreeRTOS/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 598:../FreeRTOS/Source/tasks.c **** 	{
 397              		.loc 1 598 0
 398              		.cfi_startproc
 399              		@ args = 0, pretend = 0, frame = 16
 400              		@ frame_needed = 1, uses_anonymous_args = 0
 401 01ac 80B5     		push	{r7, lr}
 402              	.LCFI3:
 403              		.cfi_def_cfa_offset 8
 404              		.cfi_offset 14, -4
 405              		.cfi_offset 7, -8
 406 01ae 84B0     		sub	sp, sp, #16
 407              	.LCFI4:
 408              		.cfi_def_cfa_offset 24
 409 01b0 00AF     		add	r7, sp, #0
 410              	.LCFI5:
 411              		.cfi_def_cfa_register 7
 412 01b2 7860     		str	r0, [r7, #4]
 599:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 600:../FreeRTOS/Source/tasks.c **** 
 601:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 413              		.loc 1 601 0
 414 01b4 FFF7FEFF 		bl	vPortEnterCritical
 602:../FreeRTOS/Source/tasks.c **** 		{
 603:../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 604:../FreeRTOS/Source/tasks.c **** 			deleted. */
 605:../FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 415              		.loc 1 605 0
 416 01b8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 417 01bc C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 418 01c0 1B68     		ldr	r3, [r3, #0]
 419 01c2 7A68     		ldr	r2, [r7, #4]
 420 01c4 9A42     		cmp	r2, r3
 421 01c6 02D1     		bne	.L11
 606:../FreeRTOS/Source/tasks.c **** 			{
 607:../FreeRTOS/Source/tasks.c **** 				pxTaskToDelete = NULL;
 422              		.loc 1 607 0
 423 01c8 4FF00003 		mov	r3, #0
 424 01cc 7B60     		str	r3, [r7, #4]
 425              	.L11:
 608:../FreeRTOS/Source/tasks.c **** 			}
 609:../FreeRTOS/Source/tasks.c **** 
 610:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 611:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 426              		.loc 1 611 0
 427 01ce 7B68     		ldr	r3, [r7, #4]
 428 01d0 002B     		cmp	r3, #0
 429 01d2 05D1     		bne	.L12
 430              		.loc 1 611 0 is_stmt 0 discriminator 1
 431 01d4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 432 01d8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 433 01dc 1B68     		ldr	r3, [r3, #0]
 434 01de 00E0     		b	.L13
 435              	.L12:
 436              		.loc 1 611 0 discriminator 2
 437 01e0 7B68     		ldr	r3, [r7, #4]
 438              	.L13:
 439              		.loc 1 611 0 discriminator 3
 440 01e2 FB60     		str	r3, [r7, #12]
 612:../FreeRTOS/Source/tasks.c **** 
 613:../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 614:../FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 615:../FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 616:../FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 617:../FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 441              		.loc 1 617 0 is_stmt 1 discriminator 3
 442 01e4 FB68     		ldr	r3, [r7, #12]
 443 01e6 03F10403 		add	r3, r3, #4
 444 01ea 1846     		mov	r0, r3
 445 01ec FFF7FEFF 		bl	vListRemove
 618:../FreeRTOS/Source/tasks.c **** 
 619:../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 620:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 446              		.loc 1 620 0 discriminator 3
 447 01f0 FB68     		ldr	r3, [r7, #12]
 448 01f2 9B6A     		ldr	r3, [r3, #40]
 449 01f4 002B     		cmp	r3, #0
 450 01f6 05D0     		beq	.L14
 621:../FreeRTOS/Source/tasks.c **** 			{
 622:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 451              		.loc 1 622 0
 452 01f8 FB68     		ldr	r3, [r7, #12]
 453 01fa 03F11803 		add	r3, r3, #24
 454 01fe 1846     		mov	r0, r3
 455 0200 FFF7FEFF 		bl	vListRemove
 456              	.L14:
 623:../FreeRTOS/Source/tasks.c **** 			}
 624:../FreeRTOS/Source/tasks.c **** 
 625:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 457              		.loc 1 625 0
 458 0204 FB68     		ldr	r3, [r7, #12]
 459 0206 03F10403 		add	r3, r3, #4
 460 020a 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 461 020e C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 462 0212 1946     		mov	r1, r3
 463 0214 FFF7FEFF 		bl	vListInsertEnd
 626:../FreeRTOS/Source/tasks.c **** 
 627:../FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 628:../FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 629:../FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 630:../FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 464              		.loc 1 630 0
 465 0218 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 466 021c C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 467 0220 1B68     		ldr	r3, [r3, #0]
 468 0222 03F10102 		add	r2, r3, #1
 469 0226 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 470 022a C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 471 022e 1A60     		str	r2, [r3, #0]
 631:../FreeRTOS/Source/tasks.c **** 
 632:../FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 633:../FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 634:../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 472              		.loc 1 634 0
 473 0230 40F20003 		movw	r3, #:lower16:uxTaskNumber
 474 0234 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 475 0238 1B68     		ldr	r3, [r3, #0]
 476 023a 03F10102 		add	r2, r3, #1
 477 023e 40F20003 		movw	r3, #:lower16:uxTaskNumber
 478 0242 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 479 0246 1A60     		str	r2, [r3, #0]
 635:../FreeRTOS/Source/tasks.c **** 
 636:../FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 637:../FreeRTOS/Source/tasks.c **** 		}
 638:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 480              		.loc 1 638 0
 481 0248 FFF7FEFF 		bl	vPortExitCritical
 639:../FreeRTOS/Source/tasks.c **** 
 640:../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 641:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 482              		.loc 1 641 0
 483 024c 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 484 0250 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 485 0254 1B68     		ldr	r3, [r3, #0]
 486 0256 002B     		cmp	r3, #0
 487 0258 04D0     		beq	.L10
 642:../FreeRTOS/Source/tasks.c **** 		{
 643:../FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 488              		.loc 1 643 0
 489 025a 7B68     		ldr	r3, [r7, #4]
 490 025c 002B     		cmp	r3, #0
 491 025e 01D1     		bne	.L10
 644:../FreeRTOS/Source/tasks.c **** 			{
 645:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 492              		.loc 1 645 0
 493 0260 FFF7FEFF 		bl	vPortYieldFromISR
 494              	.L10:
 646:../FreeRTOS/Source/tasks.c **** 			}
 647:../FreeRTOS/Source/tasks.c **** 		}
 648:../FreeRTOS/Source/tasks.c **** 	}
 495              		.loc 1 648 0
 496 0264 07F11007 		add	r7, r7, #16
 497 0268 BD46     		mov	sp, r7
 498 026a 80BD     		pop	{r7, pc}
 499              		.cfi_endproc
 500              	.LFE111:
 502              		.align	2
 503              		.global	vTaskDelayUntil
 504              		.thumb
 505              		.thumb_func
 507              	vTaskDelayUntil:
 508              	.LFB112:
 649:../FreeRTOS/Source/tasks.c **** 
 650:../FreeRTOS/Source/tasks.c **** #endif
 651:../FreeRTOS/Source/tasks.c **** 
 652:../FreeRTOS/Source/tasks.c **** 
 653:../FreeRTOS/Source/tasks.c **** 
 654:../FreeRTOS/Source/tasks.c **** 
 655:../FreeRTOS/Source/tasks.c **** 
 656:../FreeRTOS/Source/tasks.c **** 
 657:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 658:../FreeRTOS/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 659:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 660:../FreeRTOS/Source/tasks.c **** 
 661:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 662:../FreeRTOS/Source/tasks.c **** 
 663:../FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 664:../FreeRTOS/Source/tasks.c **** 	{
 509              		.loc 1 664 0
 510              		.cfi_startproc
 511              		@ args = 0, pretend = 0, frame = 24
 512              		@ frame_needed = 1, uses_anonymous_args = 0
 513 026c 80B5     		push	{r7, lr}
 514              	.LCFI6:
 515              		.cfi_def_cfa_offset 8
 516              		.cfi_offset 14, -4
 517              		.cfi_offset 7, -8
 518 026e 86B0     		sub	sp, sp, #24
 519              	.LCFI7:
 520              		.cfi_def_cfa_offset 32
 521 0270 00AF     		add	r7, sp, #0
 522              	.LCFI8:
 523              		.cfi_def_cfa_register 7
 524 0272 7860     		str	r0, [r7, #4]
 525 0274 3960     		str	r1, [r7, #0]
 665:../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 666:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 526              		.loc 1 666 0
 527 0276 4FF00003 		mov	r3, #0
 528 027a 7B61     		str	r3, [r7, #20]
 667:../FreeRTOS/Source/tasks.c **** 
 668:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 669:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 670:../FreeRTOS/Source/tasks.c **** 
 671:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 529              		.loc 1 671 0
 530 027c FFF7FEFF 		bl	vTaskSuspendAll
 672:../FreeRTOS/Source/tasks.c **** 		{
 673:../FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 674:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 531              		.loc 1 674 0
 532 0280 7B68     		ldr	r3, [r7, #4]
 533 0282 1A68     		ldr	r2, [r3, #0]
 534 0284 3B68     		ldr	r3, [r7, #0]
 535 0286 D318     		adds	r3, r2, r3
 536 0288 3B61     		str	r3, [r7, #16]
 675:../FreeRTOS/Source/tasks.c **** 
 676:../FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 537              		.loc 1 676 0
 538 028a 7B68     		ldr	r3, [r7, #4]
 539 028c 1A68     		ldr	r2, [r3, #0]
 540 028e 40F20003 		movw	r3, #:lower16:xTickCount
 541 0292 C0F20003 		movt	r3, #:upper16:xTickCount
 542 0296 1B68     		ldr	r3, [r3, #0]
 543 0298 9A42     		cmp	r2, r3
 544 029a 10D9     		bls	.L17
 677:../FreeRTOS/Source/tasks.c **** 			{
 678:../FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 679:../FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 680:../FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 681:../FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 682:../FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 683:../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 545              		.loc 1 683 0
 546 029c 7B68     		ldr	r3, [r7, #4]
 547 029e 1A68     		ldr	r2, [r3, #0]
 548 02a0 3B69     		ldr	r3, [r7, #16]
 549 02a2 9A42     		cmp	r2, r3
 550 02a4 1BD9     		bls	.L18
 551              		.loc 1 683 0 is_stmt 0 discriminator 1
 552 02a6 40F20003 		movw	r3, #:lower16:xTickCount
 553 02aa C0F20003 		movt	r3, #:upper16:xTickCount
 554 02ae 1B68     		ldr	r3, [r3, #0]
 555 02b0 3A69     		ldr	r2, [r7, #16]
 556 02b2 9A42     		cmp	r2, r3
 557 02b4 13D9     		bls	.L18
 684:../FreeRTOS/Source/tasks.c **** 				{
 685:../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 558              		.loc 1 685 0 is_stmt 1
 559 02b6 4FF00103 		mov	r3, #1
 560 02ba 7B61     		str	r3, [r7, #20]
 561 02bc 0FE0     		b	.L18
 562              	.L17:
 686:../FreeRTOS/Source/tasks.c **** 				}
 687:../FreeRTOS/Source/tasks.c **** 			}
 688:../FreeRTOS/Source/tasks.c **** 			else
 689:../FreeRTOS/Source/tasks.c **** 			{
 690:../FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 691:../FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 692:../FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 693:../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 563              		.loc 1 693 0
 564 02be 7B68     		ldr	r3, [r7, #4]
 565 02c0 1A68     		ldr	r2, [r3, #0]
 566 02c2 3B69     		ldr	r3, [r7, #16]
 567 02c4 9A42     		cmp	r2, r3
 568 02c6 07D8     		bhi	.L19
 569              		.loc 1 693 0 is_stmt 0 discriminator 1
 570 02c8 40F20003 		movw	r3, #:lower16:xTickCount
 571 02cc C0F20003 		movt	r3, #:upper16:xTickCount
 572 02d0 1B68     		ldr	r3, [r3, #0]
 573 02d2 3A69     		ldr	r2, [r7, #16]
 574 02d4 9A42     		cmp	r2, r3
 575 02d6 02D9     		bls	.L18
 576              	.L19:
 694:../FreeRTOS/Source/tasks.c **** 				{
 695:../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 577              		.loc 1 695 0 is_stmt 1
 578 02d8 4FF00103 		mov	r3, #1
 579 02dc 7B61     		str	r3, [r7, #20]
 580              	.L18:
 696:../FreeRTOS/Source/tasks.c **** 				}
 697:../FreeRTOS/Source/tasks.c **** 			}
 698:../FreeRTOS/Source/tasks.c **** 
 699:../FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 700:../FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 581              		.loc 1 700 0
 582 02de 7B68     		ldr	r3, [r7, #4]
 583 02e0 3A69     		ldr	r2, [r7, #16]
 584 02e2 1A60     		str	r2, [r3, #0]
 701:../FreeRTOS/Source/tasks.c **** 
 702:../FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 585              		.loc 1 702 0
 586 02e4 7B69     		ldr	r3, [r7, #20]
 587 02e6 002B     		cmp	r3, #0
 588 02e8 0CD0     		beq	.L20
 703:../FreeRTOS/Source/tasks.c **** 			{
 704:../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 705:../FreeRTOS/Source/tasks.c **** 
 706:../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 707:../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 708:../FreeRTOS/Source/tasks.c **** 				both lists. */
 709:../FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 589              		.loc 1 709 0
 590 02ea 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 591 02ee C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 592 02f2 1B68     		ldr	r3, [r3, #0]
 593 02f4 03F10403 		add	r3, r3, #4
 594 02f8 1846     		mov	r0, r3
 595 02fa FFF7FEFF 		bl	vListRemove
 710:../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 596              		.loc 1 710 0
 597 02fe 3869     		ldr	r0, [r7, #16]
 598 0300 01F012F8 		bl	prvAddCurrentTaskToDelayedList
 599              	.L20:
 711:../FreeRTOS/Source/tasks.c **** 			}
 712:../FreeRTOS/Source/tasks.c **** 		}
 713:../FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 600              		.loc 1 713 0
 601 0304 FFF7FEFF 		bl	xTaskResumeAll
 602 0308 0346     		mov	r3, r0
 603 030a FB60     		str	r3, [r7, #12]
 714:../FreeRTOS/Source/tasks.c **** 
 715:../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 716:../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 717:../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 604              		.loc 1 717 0
 605 030c FB68     		ldr	r3, [r7, #12]
 606 030e 002B     		cmp	r3, #0
 607 0310 01D1     		bne	.L16
 718:../FreeRTOS/Source/tasks.c **** 		{
 719:../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 608              		.loc 1 719 0
 609 0312 FFF7FEFF 		bl	vPortYieldFromISR
 610              	.L16:
 720:../FreeRTOS/Source/tasks.c **** 		}
 721:../FreeRTOS/Source/tasks.c **** 	}
 611              		.loc 1 721 0
 612 0316 07F11807 		add	r7, r7, #24
 613 031a BD46     		mov	sp, r7
 614 031c 80BD     		pop	{r7, pc}
 615              		.cfi_endproc
 616              	.LFE112:
 618 031e 00BF     		.align	2
 619              		.global	vTaskDelay
 620              		.thumb
 621              		.thumb_func
 623              	vTaskDelay:
 624              	.LFB113:
 722:../FreeRTOS/Source/tasks.c **** 
 723:../FreeRTOS/Source/tasks.c **** #endif
 724:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 725:../FreeRTOS/Source/tasks.c **** 
 726:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 727:../FreeRTOS/Source/tasks.c **** 
 728:../FreeRTOS/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 729:../FreeRTOS/Source/tasks.c **** 	{
 625              		.loc 1 729 0
 626              		.cfi_startproc
 627              		@ args = 0, pretend = 0, frame = 16
 628              		@ frame_needed = 1, uses_anonymous_args = 0
 629 0320 80B5     		push	{r7, lr}
 630              	.LCFI9:
 631              		.cfi_def_cfa_offset 8
 632              		.cfi_offset 14, -4
 633              		.cfi_offset 7, -8
 634 0322 84B0     		sub	sp, sp, #16
 635              	.LCFI10:
 636              		.cfi_def_cfa_offset 24
 637 0324 00AF     		add	r7, sp, #0
 638              	.LCFI11:
 639              		.cfi_def_cfa_register 7
 640 0326 7860     		str	r0, [r7, #4]
 730:../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 731:../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 641              		.loc 1 731 0
 642 0328 4FF00003 		mov	r3, #0
 643 032c FB60     		str	r3, [r7, #12]
 732:../FreeRTOS/Source/tasks.c **** 
 733:../FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 734:../FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 644              		.loc 1 734 0
 645 032e 7B68     		ldr	r3, [r7, #4]
 646 0330 002B     		cmp	r3, #0
 647 0332 1AD0     		beq	.L23
 735:../FreeRTOS/Source/tasks.c **** 		{
 736:../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 648              		.loc 1 736 0
 649 0334 FFF7FEFF 		bl	vTaskSuspendAll
 737:../FreeRTOS/Source/tasks.c **** 			{
 738:../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 739:../FreeRTOS/Source/tasks.c **** 
 740:../FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 741:../FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 742:../FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 743:../FreeRTOS/Source/tasks.c **** 				is resumed.
 744:../FreeRTOS/Source/tasks.c **** 
 745:../FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 746:../FreeRTOS/Source/tasks.c **** 				executing task. */
 747:../FreeRTOS/Source/tasks.c **** 
 748:../FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 749:../FreeRTOS/Source/tasks.c **** 				not a problem. */
 750:../FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 650              		.loc 1 750 0
 651 0338 40F20003 		movw	r3, #:lower16:xTickCount
 652 033c C0F20003 		movt	r3, #:upper16:xTickCount
 653 0340 1A68     		ldr	r2, [r3, #0]
 654 0342 7B68     		ldr	r3, [r7, #4]
 655 0344 D318     		adds	r3, r2, r3
 656 0346 BB60     		str	r3, [r7, #8]
 751:../FreeRTOS/Source/tasks.c **** 
 752:../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 753:../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 754:../FreeRTOS/Source/tasks.c **** 				both lists. */
 755:../FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 657              		.loc 1 755 0
 658 0348 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 659 034c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 660 0350 1B68     		ldr	r3, [r3, #0]
 661 0352 03F10403 		add	r3, r3, #4
 662 0356 1846     		mov	r0, r3
 663 0358 FFF7FEFF 		bl	vListRemove
 756:../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 664              		.loc 1 756 0
 665 035c B868     		ldr	r0, [r7, #8]
 666 035e 00F0E3FF 		bl	prvAddCurrentTaskToDelayedList
 757:../FreeRTOS/Source/tasks.c **** 			}
 758:../FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 667              		.loc 1 758 0
 668 0362 FFF7FEFF 		bl	xTaskResumeAll
 669 0366 0346     		mov	r3, r0
 670 0368 FB60     		str	r3, [r7, #12]
 671              	.L23:
 759:../FreeRTOS/Source/tasks.c **** 		}
 760:../FreeRTOS/Source/tasks.c **** 
 761:../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 762:../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 763:../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 672              		.loc 1 763 0
 673 036a FB68     		ldr	r3, [r7, #12]
 674 036c 002B     		cmp	r3, #0
 675 036e 01D1     		bne	.L22
 764:../FreeRTOS/Source/tasks.c **** 		{
 765:../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 676              		.loc 1 765 0
 677 0370 FFF7FEFF 		bl	vPortYieldFromISR
 678              	.L22:
 766:../FreeRTOS/Source/tasks.c **** 		}
 767:../FreeRTOS/Source/tasks.c **** 	}
 679              		.loc 1 767 0
 680 0374 07F11007 		add	r7, r7, #16
 681 0378 BD46     		mov	sp, r7
 682 037a 80BD     		pop	{r7, pc}
 683              		.cfi_endproc
 684              	.LFE113:
 686              		.align	2
 687              		.global	uxTaskPriorityGet
 688              		.thumb
 689              		.thumb_func
 691              	uxTaskPriorityGet:
 692              	.LFB114:
 768:../FreeRTOS/Source/tasks.c **** 
 769:../FreeRTOS/Source/tasks.c **** #endif
 770:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 771:../FreeRTOS/Source/tasks.c **** 
 772:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 773:../FreeRTOS/Source/tasks.c **** 
 774:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 775:../FreeRTOS/Source/tasks.c **** 	{
 693              		.loc 1 775 0
 694              		.cfi_startproc
 695              		@ args = 0, pretend = 0, frame = 16
 696              		@ frame_needed = 1, uses_anonymous_args = 0
 697 037c 80B5     		push	{r7, lr}
 698              	.LCFI12:
 699              		.cfi_def_cfa_offset 8
 700              		.cfi_offset 14, -4
 701              		.cfi_offset 7, -8
 702 037e 84B0     		sub	sp, sp, #16
 703              	.LCFI13:
 704              		.cfi_def_cfa_offset 24
 705 0380 00AF     		add	r7, sp, #0
 706              	.LCFI14:
 707              		.cfi_def_cfa_register 7
 708 0382 7860     		str	r0, [r7, #4]
 776:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 777:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 778:../FreeRTOS/Source/tasks.c **** 
 779:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 709              		.loc 1 779 0
 710 0384 FFF7FEFF 		bl	vPortEnterCritical
 780:../FreeRTOS/Source/tasks.c **** 		{
 781:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 782:../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 783:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 711              		.loc 1 783 0
 712 0388 7B68     		ldr	r3, [r7, #4]
 713 038a 002B     		cmp	r3, #0
 714 038c 05D1     		bne	.L26
 715              		.loc 1 783 0 is_stmt 0 discriminator 1
 716 038e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 717 0392 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 718 0396 1B68     		ldr	r3, [r3, #0]
 719 0398 00E0     		b	.L27
 720              	.L26:
 721              		.loc 1 783 0 discriminator 2
 722 039a 7B68     		ldr	r3, [r7, #4]
 723              	.L27:
 724              		.loc 1 783 0 discriminator 3
 725 039c FB60     		str	r3, [r7, #12]
 784:../FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 726              		.loc 1 784 0 is_stmt 1 discriminator 3
 727 039e FB68     		ldr	r3, [r7, #12]
 728 03a0 DB6A     		ldr	r3, [r3, #44]
 729 03a2 BB60     		str	r3, [r7, #8]
 785:../FreeRTOS/Source/tasks.c **** 		}
 786:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 730              		.loc 1 786 0 discriminator 3
 731 03a4 FFF7FEFF 		bl	vPortExitCritical
 787:../FreeRTOS/Source/tasks.c **** 
 788:../FreeRTOS/Source/tasks.c **** 		return uxReturn;
 732              		.loc 1 788 0 discriminator 3
 733 03a8 BB68     		ldr	r3, [r7, #8]
 789:../FreeRTOS/Source/tasks.c **** 	}
 734              		.loc 1 789 0 discriminator 3
 735 03aa 1846     		mov	r0, r3
 736 03ac 07F11007 		add	r7, r7, #16
 737 03b0 BD46     		mov	sp, r7
 738 03b2 80BD     		pop	{r7, pc}
 739              		.cfi_endproc
 740              	.LFE114:
 742              		.align	2
 743              		.global	vTaskPrioritySet
 744              		.thumb
 745              		.thumb_func
 747              	vTaskPrioritySet:
 748              	.LFB115:
 790:../FreeRTOS/Source/tasks.c **** 
 791:../FreeRTOS/Source/tasks.c **** #endif
 792:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 793:../FreeRTOS/Source/tasks.c **** 
 794:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 795:../FreeRTOS/Source/tasks.c **** 
 796:../FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 797:../FreeRTOS/Source/tasks.c **** 	{
 749              		.loc 1 797 0
 750              		.cfi_startproc
 751              		@ args = 0, pretend = 0, frame = 24
 752              		@ frame_needed = 1, uses_anonymous_args = 0
 753 03b4 80B5     		push	{r7, lr}
 754              	.LCFI15:
 755              		.cfi_def_cfa_offset 8
 756              		.cfi_offset 14, -4
 757              		.cfi_offset 7, -8
 758 03b6 86B0     		sub	sp, sp, #24
 759              	.LCFI16:
 760              		.cfi_def_cfa_offset 32
 761 03b8 00AF     		add	r7, sp, #0
 762              	.LCFI17:
 763              		.cfi_def_cfa_register 7
 764 03ba 7860     		str	r0, [r7, #4]
 765 03bc 3960     		str	r1, [r7, #0]
 798:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 799:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 800:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 766              		.loc 1 800 0
 767 03be 4FF00003 		mov	r3, #0
 768 03c2 7B61     		str	r3, [r7, #20]
 801:../FreeRTOS/Source/tasks.c **** 
 802:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 803:../FreeRTOS/Source/tasks.c **** 
 804:../FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 805:../FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 769              		.loc 1 805 0
 770 03c4 3B68     		ldr	r3, [r7, #0]
 771 03c6 092B     		cmp	r3, #9
 772 03c8 02D9     		bls	.L29
 806:../FreeRTOS/Source/tasks.c **** 		{
 807:../FreeRTOS/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 773              		.loc 1 807 0
 774 03ca 4FF00903 		mov	r3, #9
 775 03ce 3B60     		str	r3, [r7, #0]
 776              	.L29:
 808:../FreeRTOS/Source/tasks.c **** 		}
 809:../FreeRTOS/Source/tasks.c **** 
 810:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 777              		.loc 1 810 0
 778 03d0 FFF7FEFF 		bl	vPortEnterCritical
 811:../FreeRTOS/Source/tasks.c **** 		{
 812:../FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 779              		.loc 1 812 0
 780 03d4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 781 03d8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 782 03dc 1B68     		ldr	r3, [r3, #0]
 783 03de 7A68     		ldr	r2, [r7, #4]
 784 03e0 9A42     		cmp	r2, r3
 785 03e2 02D1     		bne	.L30
 813:../FreeRTOS/Source/tasks.c **** 			{
 814:../FreeRTOS/Source/tasks.c **** 				pxTask = NULL;
 786              		.loc 1 814 0
 787 03e4 4FF00003 		mov	r3, #0
 788 03e8 7B60     		str	r3, [r7, #4]
 789              	.L30:
 815:../FreeRTOS/Source/tasks.c **** 			}
 816:../FreeRTOS/Source/tasks.c **** 
 817:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 818:../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 819:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 790              		.loc 1 819 0
 791 03ea 7B68     		ldr	r3, [r7, #4]
 792 03ec 002B     		cmp	r3, #0
 793 03ee 05D1     		bne	.L31
 794              		.loc 1 819 0 is_stmt 0 discriminator 1
 795 03f0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 796 03f4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 797 03f8 1B68     		ldr	r3, [r3, #0]
 798 03fa 00E0     		b	.L32
 799              	.L31:
 800              		.loc 1 819 0 discriminator 2
 801 03fc 7B68     		ldr	r3, [r7, #4]
 802              	.L32:
 803              		.loc 1 819 0 discriminator 3
 804 03fe 3B61     		str	r3, [r7, #16]
 820:../FreeRTOS/Source/tasks.c **** 
 821:../FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 822:../FreeRTOS/Source/tasks.c **** 
 823:../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 824:../FreeRTOS/Source/tasks.c **** 			{
 825:../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 805              		.loc 1 825 0 is_stmt 1 discriminator 3
 806 0400 3B69     		ldr	r3, [r7, #16]
 807 0402 5B6C     		ldr	r3, [r3, #68]
 808 0404 FB60     		str	r3, [r7, #12]
 826:../FreeRTOS/Source/tasks.c **** 			}
 827:../FreeRTOS/Source/tasks.c **** 			#else
 828:../FreeRTOS/Source/tasks.c **** 			{
 829:../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 830:../FreeRTOS/Source/tasks.c **** 			}
 831:../FreeRTOS/Source/tasks.c **** 			#endif
 832:../FreeRTOS/Source/tasks.c **** 
 833:../FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 809              		.loc 1 833 0 discriminator 3
 810 0406 FA68     		ldr	r2, [r7, #12]
 811 0408 3B68     		ldr	r3, [r7, #0]
 812 040a 9A42     		cmp	r2, r3
 813 040c 62D0     		beq	.L33
 834:../FreeRTOS/Source/tasks.c **** 			{
 835:../FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 836:../FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
 837:../FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 814              		.loc 1 837 0
 815 040e 3A68     		ldr	r2, [r7, #0]
 816 0410 FB68     		ldr	r3, [r7, #12]
 817 0412 9A42     		cmp	r2, r3
 818 0414 06D9     		bls	.L34
 838:../FreeRTOS/Source/tasks.c **** 				{
 839:../FreeRTOS/Source/tasks.c **** 					if( pxTask != NULL )
 819              		.loc 1 839 0
 820 0416 7B68     		ldr	r3, [r7, #4]
 821 0418 002B     		cmp	r3, #0
 822 041a 09D0     		beq	.L35
 840:../FreeRTOS/Source/tasks.c **** 					{
 841:../FreeRTOS/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 842:../FreeRTOS/Source/tasks.c **** 						were raising the priority of the currently running task
 843:../FreeRTOS/Source/tasks.c **** 						there would be no need to switch as it must have already
 844:../FreeRTOS/Source/tasks.c **** 						been the highest priority task. */
 845:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 823              		.loc 1 845 0
 824 041c 4FF00103 		mov	r3, #1
 825 0420 7B61     		str	r3, [r7, #20]
 826 0422 05E0     		b	.L35
 827              	.L34:
 846:../FreeRTOS/Source/tasks.c **** 					}
 847:../FreeRTOS/Source/tasks.c **** 				}
 848:../FreeRTOS/Source/tasks.c **** 				else if( pxTask == NULL )
 828              		.loc 1 848 0
 829 0424 7B68     		ldr	r3, [r7, #4]
 830 0426 002B     		cmp	r3, #0
 831 0428 02D1     		bne	.L35
 849:../FreeRTOS/Source/tasks.c **** 				{
 850:../FreeRTOS/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 851:../FreeRTOS/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 852:../FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 832              		.loc 1 852 0
 833 042a 4FF00103 		mov	r3, #1
 834 042e 7B61     		str	r3, [r7, #20]
 835              	.L35:
 853:../FreeRTOS/Source/tasks.c **** 				}
 854:../FreeRTOS/Source/tasks.c **** 
 855:../FreeRTOS/Source/tasks.c **** 
 856:../FreeRTOS/Source/tasks.c **** 
 857:../FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 858:../FreeRTOS/Source/tasks.c **** 				{
 859:../FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 860:../FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
 861:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 836              		.loc 1 861 0
 837 0430 3B69     		ldr	r3, [r7, #16]
 838 0432 5A6C     		ldr	r2, [r3, #68]
 839 0434 3B69     		ldr	r3, [r7, #16]
 840 0436 DB6A     		ldr	r3, [r3, #44]
 841 0438 9A42     		cmp	r2, r3
 842 043a 02D1     		bne	.L36
 862:../FreeRTOS/Source/tasks.c **** 					{
 863:../FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 843              		.loc 1 863 0
 844 043c 3B69     		ldr	r3, [r7, #16]
 845 043e 3A68     		ldr	r2, [r7, #0]
 846 0440 DA62     		str	r2, [r3, #44]
 847              	.L36:
 864:../FreeRTOS/Source/tasks.c **** 					}
 865:../FreeRTOS/Source/tasks.c **** 
 866:../FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
 867:../FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 848              		.loc 1 867 0
 849 0442 3B69     		ldr	r3, [r7, #16]
 850 0444 3A68     		ldr	r2, [r7, #0]
 851 0446 5A64     		str	r2, [r3, #68]
 868:../FreeRTOS/Source/tasks.c **** 				}
 869:../FreeRTOS/Source/tasks.c **** 				#else
 870:../FreeRTOS/Source/tasks.c **** 				{
 871:../FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 872:../FreeRTOS/Source/tasks.c **** 				}
 873:../FreeRTOS/Source/tasks.c **** 				#endif
 874:../FreeRTOS/Source/tasks.c **** 
 875:../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 852              		.loc 1 875 0
 853 0448 3B68     		ldr	r3, [r7, #0]
 854 044a C3F10A02 		rsb	r2, r3, #10
 855 044e 3B69     		ldr	r3, [r7, #16]
 856 0450 9A61     		str	r2, [r3, #24]
 876:../FreeRTOS/Source/tasks.c **** 
 877:../FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 878:../FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 879:../FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 880:../FreeRTOS/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 881:../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 857              		.loc 1 881 0
 858 0452 3B69     		ldr	r3, [r7, #16]
 859 0454 5969     		ldr	r1, [r3, #20]
 860 0456 FA68     		ldr	r2, [r7, #12]
 861 0458 1346     		mov	r3, r2
 862 045a 4FEA8303 		lsl	r3, r3, #2
 863 045e 9B18     		adds	r3, r3, r2
 864 0460 4FEA8303 		lsl	r3, r3, #2
 865 0464 1A46     		mov	r2, r3
 866 0466 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 867 046a C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 868 046e D318     		adds	r3, r2, r3
 869 0470 9942     		cmp	r1, r3
 870 0472 2AD1     		bne	.L37
 882:../FreeRTOS/Source/tasks.c **** 				{
 883:../FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 884:../FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 885:../FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 886:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 871              		.loc 1 886 0
 872 0474 3B69     		ldr	r3, [r7, #16]
 873 0476 03F10403 		add	r3, r3, #4
 874 047a 1846     		mov	r0, r3
 875 047c FFF7FEFF 		bl	vListRemove
 887:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 876              		.loc 1 887 0
 877 0480 3B69     		ldr	r3, [r7, #16]
 878 0482 DA6A     		ldr	r2, [r3, #44]
 879 0484 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 880 0488 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 881 048c 1B68     		ldr	r3, [r3, #0]
 882 048e 9A42     		cmp	r2, r3
 883 0490 06D9     		bls	.L38
 884              		.loc 1 887 0 is_stmt 0 discriminator 1
 885 0492 3B69     		ldr	r3, [r7, #16]
 886 0494 DA6A     		ldr	r2, [r3, #44]
 887 0496 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 888 049a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 889 049e 1A60     		str	r2, [r3, #0]
 890              	.L38:
 891              		.loc 1 887 0 discriminator 2
 892 04a0 3B69     		ldr	r3, [r7, #16]
 893 04a2 DA6A     		ldr	r2, [r3, #44]
 894 04a4 1346     		mov	r3, r2
 895 04a6 4FEA8303 		lsl	r3, r3, #2
 896 04aa 9B18     		adds	r3, r3, r2
 897 04ac 4FEA8303 		lsl	r3, r3, #2
 898 04b0 1A46     		mov	r2, r3
 899 04b2 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 900 04b6 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 901 04ba D218     		adds	r2, r2, r3
 902 04bc 3B69     		ldr	r3, [r7, #16]
 903 04be 03F10403 		add	r3, r3, #4
 904 04c2 1046     		mov	r0, r2
 905 04c4 1946     		mov	r1, r3
 906 04c6 FFF7FEFF 		bl	vListInsertEnd
 907              	.L37:
 888:../FreeRTOS/Source/tasks.c **** 				}
 889:../FreeRTOS/Source/tasks.c **** 
 890:../FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 908              		.loc 1 890 0 is_stmt 1
 909 04ca 7B69     		ldr	r3, [r7, #20]
 910 04cc 012B     		cmp	r3, #1
 911 04ce 01D1     		bne	.L33
 891:../FreeRTOS/Source/tasks.c **** 				{
 892:../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 912              		.loc 1 892 0
 913 04d0 FFF7FEFF 		bl	vPortYieldFromISR
 914              	.L33:
 893:../FreeRTOS/Source/tasks.c **** 				}
 894:../FreeRTOS/Source/tasks.c **** 			}
 895:../FreeRTOS/Source/tasks.c **** 		}
 896:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 915              		.loc 1 896 0
 916 04d4 FFF7FEFF 		bl	vPortExitCritical
 897:../FreeRTOS/Source/tasks.c **** 	}
 917              		.loc 1 897 0
 918 04d8 07F11807 		add	r7, r7, #24
 919 04dc BD46     		mov	sp, r7
 920 04de 80BD     		pop	{r7, pc}
 921              		.cfi_endproc
 922              	.LFE115:
 924              		.align	2
 925              		.global	vTaskSuspend
 926              		.thumb
 927              		.thumb_func
 929              	vTaskSuspend:
 930              	.LFB116:
 898:../FreeRTOS/Source/tasks.c **** 
 899:../FreeRTOS/Source/tasks.c **** #endif
 900:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 901:../FreeRTOS/Source/tasks.c **** 
 902:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 903:../FreeRTOS/Source/tasks.c **** 
 904:../FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 905:../FreeRTOS/Source/tasks.c **** 	{
 931              		.loc 1 905 0
 932              		.cfi_startproc
 933              		@ args = 0, pretend = 0, frame = 16
 934              		@ frame_needed = 1, uses_anonymous_args = 0
 935 04e0 80B5     		push	{r7, lr}
 936              	.LCFI18:
 937              		.cfi_def_cfa_offset 8
 938              		.cfi_offset 14, -4
 939              		.cfi_offset 7, -8
 940 04e2 84B0     		sub	sp, sp, #16
 941              	.LCFI19:
 942              		.cfi_def_cfa_offset 24
 943 04e4 00AF     		add	r7, sp, #0
 944              	.LCFI20:
 945              		.cfi_def_cfa_register 7
 946 04e6 7860     		str	r0, [r7, #4]
 906:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 907:../FreeRTOS/Source/tasks.c **** 
 908:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 947              		.loc 1 908 0
 948 04e8 FFF7FEFF 		bl	vPortEnterCritical
 909:../FreeRTOS/Source/tasks.c **** 		{
 910:../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 911:../FreeRTOS/Source/tasks.c **** 			suspended. */
 912:../FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 949              		.loc 1 912 0
 950 04ec 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 951 04f0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 952 04f4 1B68     		ldr	r3, [r3, #0]
 953 04f6 7A68     		ldr	r2, [r7, #4]
 954 04f8 9A42     		cmp	r2, r3
 955 04fa 02D1     		bne	.L40
 913:../FreeRTOS/Source/tasks.c **** 			{
 914:../FreeRTOS/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 956              		.loc 1 914 0
 957 04fc 4FF00003 		mov	r3, #0
 958 0500 7B60     		str	r3, [r7, #4]
 959              	.L40:
 915:../FreeRTOS/Source/tasks.c **** 			}
 916:../FreeRTOS/Source/tasks.c **** 
 917:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 918:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 960              		.loc 1 918 0
 961 0502 7B68     		ldr	r3, [r7, #4]
 962 0504 002B     		cmp	r3, #0
 963 0506 05D1     		bne	.L41
 964              		.loc 1 918 0 is_stmt 0 discriminator 1
 965 0508 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 966 050c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 967 0510 1B68     		ldr	r3, [r3, #0]
 968 0512 00E0     		b	.L42
 969              	.L41:
 970              		.loc 1 918 0 discriminator 2
 971 0514 7B68     		ldr	r3, [r7, #4]
 972              	.L42:
 973              		.loc 1 918 0 discriminator 3
 974 0516 FB60     		str	r3, [r7, #12]
 919:../FreeRTOS/Source/tasks.c **** 
 920:../FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 921:../FreeRTOS/Source/tasks.c **** 
 922:../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 923:../FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 975              		.loc 1 923 0 is_stmt 1 discriminator 3
 976 0518 FB68     		ldr	r3, [r7, #12]
 977 051a 03F10403 		add	r3, r3, #4
 978 051e 1846     		mov	r0, r3
 979 0520 FFF7FEFF 		bl	vListRemove
 924:../FreeRTOS/Source/tasks.c **** 
 925:../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 926:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 980              		.loc 1 926 0 discriminator 3
 981 0524 FB68     		ldr	r3, [r7, #12]
 982 0526 9B6A     		ldr	r3, [r3, #40]
 983 0528 002B     		cmp	r3, #0
 984 052a 05D0     		beq	.L43
 927:../FreeRTOS/Source/tasks.c **** 			{
 928:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 985              		.loc 1 928 0
 986 052c FB68     		ldr	r3, [r7, #12]
 987 052e 03F11803 		add	r3, r3, #24
 988 0532 1846     		mov	r0, r3
 989 0534 FFF7FEFF 		bl	vListRemove
 990              	.L43:
 929:../FreeRTOS/Source/tasks.c **** 			}
 930:../FreeRTOS/Source/tasks.c **** 
 931:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 991              		.loc 1 931 0
 992 0538 FB68     		ldr	r3, [r7, #12]
 993 053a 03F10403 		add	r3, r3, #4
 994 053e 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 995 0542 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 996 0546 1946     		mov	r1, r3
 997 0548 FFF7FEFF 		bl	vListInsertEnd
 932:../FreeRTOS/Source/tasks.c **** 		}
 933:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 998              		.loc 1 933 0
 999 054c FFF7FEFF 		bl	vPortExitCritical
 934:../FreeRTOS/Source/tasks.c **** 
 935:../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1000              		.loc 1 935 0
 1001 0550 7B68     		ldr	r3, [r7, #4]
 1002 0552 002B     		cmp	r3, #0
 1003 0554 20D1     		bne	.L39
 936:../FreeRTOS/Source/tasks.c **** 		{
 937:../FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1004              		.loc 1 937 0
 1005 0556 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1006 055a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1007 055e 1B68     		ldr	r3, [r3, #0]
 1008 0560 002B     		cmp	r3, #0
 1009 0562 02D0     		beq	.L45
 938:../FreeRTOS/Source/tasks.c **** 			{
 939:../FreeRTOS/Source/tasks.c **** 				/* We have just suspended the current task. */
 940:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1010              		.loc 1 940 0
 1011 0564 FFF7FEFF 		bl	vPortYieldFromISR
 1012 0568 16E0     		b	.L39
 1013              	.L45:
 941:../FreeRTOS/Source/tasks.c **** 			}
 942:../FreeRTOS/Source/tasks.c **** 			else
 943:../FreeRTOS/Source/tasks.c **** 			{
 944:../FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 945:../FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 946:../FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
 947:../FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1014              		.loc 1 947 0
 1015 056a 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1016 056e C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1017 0572 1B68     		ldr	r3, [r3, #0]
 1018 0574 1A46     		mov	r2, r3
 1019 0576 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1020 057a C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1021 057e 1B68     		ldr	r3, [r3, #0]
 1022 0580 9A42     		cmp	r2, r3
 1023 0582 07D1     		bne	.L46
 948:../FreeRTOS/Source/tasks.c **** 				{
 949:../FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 950:../FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 951:../FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
 952:../FreeRTOS/Source/tasks.c **** 					is. */
 953:../FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 1024              		.loc 1 953 0
 1025 0584 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1026 0588 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1027 058c 4FF00002 		mov	r2, #0
 1028 0590 1A60     		str	r2, [r3, #0]
 1029 0592 01E0     		b	.L39
 1030              	.L46:
 954:../FreeRTOS/Source/tasks.c **** 				}
 955:../FreeRTOS/Source/tasks.c **** 				else
 956:../FreeRTOS/Source/tasks.c **** 				{
 957:../FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 1031              		.loc 1 957 0
 1032 0594 FFF7FEFF 		bl	vTaskSwitchContext
 1033              	.L39:
 958:../FreeRTOS/Source/tasks.c **** 				}
 959:../FreeRTOS/Source/tasks.c **** 			}
 960:../FreeRTOS/Source/tasks.c **** 		}
 961:../FreeRTOS/Source/tasks.c **** 	}
 1034              		.loc 1 961 0
 1035 0598 07F11007 		add	r7, r7, #16
 1036 059c BD46     		mov	sp, r7
 1037 059e 80BD     		pop	{r7, pc}
 1038              		.cfi_endproc
 1039              	.LFE116:
 1041              		.align	2
 1042              		.global	xTaskIsTaskSuspended
 1043              		.thumb
 1044              		.thumb_func
 1046              	xTaskIsTaskSuspended:
 1047              	.LFB117:
 962:../FreeRTOS/Source/tasks.c **** 
 963:../FreeRTOS/Source/tasks.c **** #endif
 964:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 965:../FreeRTOS/Source/tasks.c **** 
 966:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 967:../FreeRTOS/Source/tasks.c **** 
 968:../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 969:../FreeRTOS/Source/tasks.c **** 	{
 1048              		.loc 1 969 0
 1049              		.cfi_startproc
 1050              		@ args = 0, pretend = 0, frame = 16
 1051              		@ frame_needed = 1, uses_anonymous_args = 0
 1052              		@ link register save eliminated.
 1053 05a0 80B4     		push	{r7}
 1054              	.LCFI21:
 1055              		.cfi_def_cfa_offset 4
 1056              		.cfi_offset 7, -4
 1057 05a2 85B0     		sub	sp, sp, #20
 1058              	.LCFI22:
 1059              		.cfi_def_cfa_offset 24
 1060 05a4 00AF     		add	r7, sp, #0
 1061              	.LCFI23:
 1062              		.cfi_def_cfa_register 7
 1063 05a6 7860     		str	r0, [r7, #4]
 970:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1064              		.loc 1 970 0
 1065 05a8 4FF00003 		mov	r3, #0
 1066 05ac FB60     		str	r3, [r7, #12]
 971:../FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1067              		.loc 1 971 0
 1068 05ae 7B68     		ldr	r3, [r7, #4]
 1069 05b0 BB60     		str	r3, [r7, #8]
 972:../FreeRTOS/Source/tasks.c **** 
 973:../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 974:../FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
 975:../FreeRTOS/Source/tasks.c **** 
 976:../FreeRTOS/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 977:../FreeRTOS/Source/tasks.c **** 		suspended list? */
 978:../FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1070              		.loc 1 978 0
 1071 05b2 BB68     		ldr	r3, [r7, #8]
 1072 05b4 5A69     		ldr	r2, [r3, #20]
 1073 05b6 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1074 05ba C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1075 05be 9A42     		cmp	r2, r3
 1076 05c0 0ED1     		bne	.L48
 979:../FreeRTOS/Source/tasks.c **** 		{
 980:../FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 981:../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1077              		.loc 1 981 0
 1078 05c2 BB68     		ldr	r3, [r7, #8]
 1079 05c4 9A6A     		ldr	r2, [r3, #40]
 1080 05c6 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1081 05ca C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1082 05ce 9A42     		cmp	r2, r3
 1083 05d0 06D0     		beq	.L48
 982:../FreeRTOS/Source/tasks.c **** 			{
 983:../FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 984:../FreeRTOS/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 985:../FreeRTOS/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 986:../FreeRTOS/Source/tasks.c **** 				specified. */
 987:../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1084              		.loc 1 987 0
 1085 05d2 BB68     		ldr	r3, [r7, #8]
 1086 05d4 9B6A     		ldr	r3, [r3, #40]
 1087 05d6 002B     		cmp	r3, #0
 1088 05d8 02D1     		bne	.L48
 988:../FreeRTOS/Source/tasks.c **** 				{
 989:../FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 1089              		.loc 1 989 0
 1090 05da 4FF00103 		mov	r3, #1
 1091 05de FB60     		str	r3, [r7, #12]
 1092              	.L48:
 990:../FreeRTOS/Source/tasks.c **** 				}
 991:../FreeRTOS/Source/tasks.c **** 			}
 992:../FreeRTOS/Source/tasks.c **** 		}
 993:../FreeRTOS/Source/tasks.c **** 
 994:../FreeRTOS/Source/tasks.c **** 		return xReturn;
 1093              		.loc 1 994 0
 1094 05e0 FB68     		ldr	r3, [r7, #12]
 995:../FreeRTOS/Source/tasks.c **** 	}
 1095              		.loc 1 995 0
 1096 05e2 1846     		mov	r0, r3
 1097 05e4 07F11407 		add	r7, r7, #20
 1098 05e8 BD46     		mov	sp, r7
 1099 05ea 80BC     		pop	{r7}
 1100 05ec 7047     		bx	lr
 1101              		.cfi_endproc
 1102              	.LFE117:
 1104 05ee 00BF     		.align	2
 1105              		.global	vTaskResume
 1106              		.thumb
 1107              		.thumb_func
 1109              	vTaskResume:
 1110              	.LFB118:
 996:../FreeRTOS/Source/tasks.c **** 
 997:../FreeRTOS/Source/tasks.c **** #endif
 998:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 999:../FreeRTOS/Source/tasks.c **** 
1000:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1001:../FreeRTOS/Source/tasks.c **** 
1002:../FreeRTOS/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1003:../FreeRTOS/Source/tasks.c **** 	{
 1111              		.loc 1 1003 0
 1112              		.cfi_startproc
 1113              		@ args = 0, pretend = 0, frame = 16
 1114              		@ frame_needed = 1, uses_anonymous_args = 0
 1115 05f0 80B5     		push	{r7, lr}
 1116              	.LCFI24:
 1117              		.cfi_def_cfa_offset 8
 1118              		.cfi_offset 14, -4
 1119              		.cfi_offset 7, -8
 1120 05f2 84B0     		sub	sp, sp, #16
 1121              	.LCFI25:
 1122              		.cfi_def_cfa_offset 24
 1123 05f4 00AF     		add	r7, sp, #0
 1124              	.LCFI26:
 1125              		.cfi_def_cfa_register 7
 1126 05f6 7860     		str	r0, [r7, #4]
1004:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1005:../FreeRTOS/Source/tasks.c **** 
1006:../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1007:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1008:../FreeRTOS/Source/tasks.c **** 
1009:../FreeRTOS/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1010:../FreeRTOS/Source/tasks.c **** 		it in the ready list. */
1011:../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1127              		.loc 1 1011 0
 1128 05f8 7B68     		ldr	r3, [r7, #4]
 1129 05fa FB60     		str	r3, [r7, #12]
1012:../FreeRTOS/Source/tasks.c **** 
1013:../FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1014:../FreeRTOS/Source/tasks.c **** 		currently executing task. */
1015:../FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1130              		.loc 1 1015 0
 1131 05fc FB68     		ldr	r3, [r7, #12]
 1132 05fe 002B     		cmp	r3, #0
 1133 0600 48D0     		beq	.L49
 1134              		.loc 1 1015 0 is_stmt 0 discriminator 1
 1135 0602 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1136 0606 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1137 060a 1B68     		ldr	r3, [r3, #0]
 1138 060c FA68     		ldr	r2, [r7, #12]
 1139 060e 9A42     		cmp	r2, r3
 1140 0610 40D0     		beq	.L49
1016:../FreeRTOS/Source/tasks.c **** 		{
1017:../FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 1141              		.loc 1 1017 0 is_stmt 1
 1142 0612 FFF7FEFF 		bl	vPortEnterCritical
1018:../FreeRTOS/Source/tasks.c **** 			{
1019:../FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1143              		.loc 1 1019 0
 1144 0616 F868     		ldr	r0, [r7, #12]
 1145 0618 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1146 061c 0346     		mov	r3, r0
 1147 061e 012B     		cmp	r3, #1
 1148 0620 36D1     		bne	.L51
1020:../FreeRTOS/Source/tasks.c **** 				{
1021:../FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1022:../FreeRTOS/Source/tasks.c **** 
1023:../FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1024:../FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1025:../FreeRTOS/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1149              		.loc 1 1025 0
 1150 0622 FB68     		ldr	r3, [r7, #12]
 1151 0624 03F10403 		add	r3, r3, #4
 1152 0628 1846     		mov	r0, r3
 1153 062a FFF7FEFF 		bl	vListRemove
1026:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1154              		.loc 1 1026 0
 1155 062e FB68     		ldr	r3, [r7, #12]
 1156 0630 DA6A     		ldr	r2, [r3, #44]
 1157 0632 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1158 0636 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1159 063a 1B68     		ldr	r3, [r3, #0]
 1160 063c 9A42     		cmp	r2, r3
 1161 063e 06D9     		bls	.L52
 1162              		.loc 1 1026 0 is_stmt 0 discriminator 1
 1163 0640 FB68     		ldr	r3, [r7, #12]
 1164 0642 DA6A     		ldr	r2, [r3, #44]
 1165 0644 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1166 0648 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1167 064c 1A60     		str	r2, [r3, #0]
 1168              	.L52:
 1169              		.loc 1 1026 0 discriminator 2
 1170 064e FB68     		ldr	r3, [r7, #12]
 1171 0650 DA6A     		ldr	r2, [r3, #44]
 1172 0652 1346     		mov	r3, r2
 1173 0654 4FEA8303 		lsl	r3, r3, #2
 1174 0658 9B18     		adds	r3, r3, r2
 1175 065a 4FEA8303 		lsl	r3, r3, #2
 1176 065e 1A46     		mov	r2, r3
 1177 0660 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1178 0664 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1179 0668 D218     		adds	r2, r2, r3
 1180 066a FB68     		ldr	r3, [r7, #12]
 1181 066c 03F10403 		add	r3, r3, #4
 1182 0670 1046     		mov	r0, r2
 1183 0672 1946     		mov	r1, r3
 1184 0674 FFF7FEFF 		bl	vListInsertEnd
1027:../FreeRTOS/Source/tasks.c **** 
1028:../FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1029:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1185              		.loc 1 1029 0 is_stmt 1 discriminator 2
 1186 0678 FB68     		ldr	r3, [r7, #12]
 1187 067a DA6A     		ldr	r2, [r3, #44]
 1188 067c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1189 0680 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1190 0684 1B68     		ldr	r3, [r3, #0]
 1191 0686 DB6A     		ldr	r3, [r3, #44]
 1192 0688 9A42     		cmp	r2, r3
 1193 068a 01D3     		bcc	.L51
1030:../FreeRTOS/Source/tasks.c **** 					{
1031:../FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1032:../FreeRTOS/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1033:../FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1194              		.loc 1 1033 0
 1195 068c FFF7FEFF 		bl	vPortYieldFromISR
 1196              	.L51:
1034:../FreeRTOS/Source/tasks.c **** 					}
1035:../FreeRTOS/Source/tasks.c **** 				}
1036:../FreeRTOS/Source/tasks.c **** 			}
1037:../FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1197              		.loc 1 1037 0
 1198 0690 FFF7FEFF 		bl	vPortExitCritical
 1199              	.L49:
1038:../FreeRTOS/Source/tasks.c **** 		}
1039:../FreeRTOS/Source/tasks.c **** 	}
 1200              		.loc 1 1039 0
 1201 0694 07F11007 		add	r7, r7, #16
 1202 0698 BD46     		mov	sp, r7
 1203 069a 80BD     		pop	{r7, pc}
 1204              		.cfi_endproc
 1205              	.LFE118:
 1207              		.align	2
 1208              		.global	xTaskResumeFromISR
 1209              		.thumb
 1210              		.thumb_func
 1212              	xTaskResumeFromISR:
 1213              	.LFB119:
1040:../FreeRTOS/Source/tasks.c **** 
1041:../FreeRTOS/Source/tasks.c **** #endif
1042:../FreeRTOS/Source/tasks.c **** 
1043:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1044:../FreeRTOS/Source/tasks.c **** 
1045:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1046:../FreeRTOS/Source/tasks.c **** 
1047:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1048:../FreeRTOS/Source/tasks.c **** 	{
 1214              		.loc 1 1048 0
 1215              		.cfi_startproc
 1216              		@ args = 0, pretend = 0, frame = 16
 1217              		@ frame_needed = 1, uses_anonymous_args = 0
 1218 069c 80B5     		push	{r7, lr}
 1219              	.LCFI27:
 1220              		.cfi_def_cfa_offset 8
 1221              		.cfi_offset 14, -4
 1222              		.cfi_offset 7, -8
 1223 069e 84B0     		sub	sp, sp, #16
 1224              	.LCFI28:
 1225              		.cfi_def_cfa_offset 24
 1226 06a0 00AF     		add	r7, sp, #0
 1227              	.LCFI29:
 1228              		.cfi_def_cfa_register 7
 1229 06a2 7860     		str	r0, [r7, #4]
1049:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1230              		.loc 1 1049 0
 1231 06a4 4FF00003 		mov	r3, #0
 1232 06a8 FB60     		str	r3, [r7, #12]
1050:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1051:../FreeRTOS/Source/tasks.c **** 
1052:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1053:../FreeRTOS/Source/tasks.c **** 
1054:../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1233              		.loc 1 1054 0
 1234 06aa 7B68     		ldr	r3, [r7, #4]
 1235 06ac BB60     		str	r3, [r7, #8]
1055:../FreeRTOS/Source/tasks.c **** 
1056:../FreeRTOS/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1236              		.loc 1 1056 0
 1237 06ae B868     		ldr	r0, [r7, #8]
 1238 06b0 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1239 06b4 0346     		mov	r3, r0
 1240 06b6 012B     		cmp	r3, #1
 1241 06b8 49D1     		bne	.L54
1057:../FreeRTOS/Source/tasks.c **** 		{
1058:../FreeRTOS/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
1059:../FreeRTOS/Source/tasks.c **** 
1060:../FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1242              		.loc 1 1060 0
 1243 06ba 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1244 06be C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1245 06c2 1B68     		ldr	r3, [r3, #0]
 1246 06c4 002B     		cmp	r3, #0
 1247 06c6 38D1     		bne	.L55
1061:../FreeRTOS/Source/tasks.c **** 			{
1062:../FreeRTOS/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1248              		.loc 1 1062 0
 1249 06c8 BB68     		ldr	r3, [r7, #8]
 1250 06ca DA6A     		ldr	r2, [r3, #44]
 1251 06cc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1252 06d0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1253 06d4 1B68     		ldr	r3, [r3, #0]
 1254 06d6 DB6A     		ldr	r3, [r3, #44]
 1255 06d8 9A42     		cmp	r2, r3
 1256 06da 34BF     		ite	cc
 1257 06dc 0023     		movcc	r3, #0
 1258 06de 0123     		movcs	r3, #1
 1259 06e0 FB60     		str	r3, [r7, #12]
1063:../FreeRTOS/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1260              		.loc 1 1063 0
 1261 06e2 BB68     		ldr	r3, [r7, #8]
 1262 06e4 03F10403 		add	r3, r3, #4
 1263 06e8 1846     		mov	r0, r3
 1264 06ea FFF7FEFF 		bl	vListRemove
1064:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1265              		.loc 1 1064 0
 1266 06ee BB68     		ldr	r3, [r7, #8]
 1267 06f0 DA6A     		ldr	r2, [r3, #44]
 1268 06f2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1269 06f6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1270 06fa 1B68     		ldr	r3, [r3, #0]
 1271 06fc 9A42     		cmp	r2, r3
 1272 06fe 06D9     		bls	.L56
 1273              		.loc 1 1064 0 is_stmt 0 discriminator 1
 1274 0700 BB68     		ldr	r3, [r7, #8]
 1275 0702 DA6A     		ldr	r2, [r3, #44]
 1276 0704 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1277 0708 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1278 070c 1A60     		str	r2, [r3, #0]
 1279              	.L56:
 1280              		.loc 1 1064 0 discriminator 2
 1281 070e BB68     		ldr	r3, [r7, #8]
 1282 0710 DA6A     		ldr	r2, [r3, #44]
 1283 0712 1346     		mov	r3, r2
 1284 0714 4FEA8303 		lsl	r3, r3, #2
 1285 0718 9B18     		adds	r3, r3, r2
 1286 071a 4FEA8303 		lsl	r3, r3, #2
 1287 071e 1A46     		mov	r2, r3
 1288 0720 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1289 0724 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1290 0728 D218     		adds	r2, r2, r3
 1291 072a BB68     		ldr	r3, [r7, #8]
 1292 072c 03F10403 		add	r3, r3, #4
 1293 0730 1046     		mov	r0, r2
 1294 0732 1946     		mov	r1, r3
 1295 0734 FFF7FEFF 		bl	vListInsertEnd
 1296 0738 09E0     		b	.L54
 1297              	.L55:
1065:../FreeRTOS/Source/tasks.c **** 			}
1066:../FreeRTOS/Source/tasks.c **** 			else
1067:../FreeRTOS/Source/tasks.c **** 			{
1068:../FreeRTOS/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1069:../FreeRTOS/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1070:../FreeRTOS/Source/tasks.c **** 				yield will be performed if necessary. */
1071:../FreeRTOS/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1298              		.loc 1 1071 0 is_stmt 1
 1299 073a BB68     		ldr	r3, [r7, #8]
 1300 073c 03F11803 		add	r3, r3, #24
 1301 0740 40F20000 		movw	r0, #:lower16:xPendingReadyList
 1302 0744 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 1303 0748 1946     		mov	r1, r3
 1304 074a FFF7FEFF 		bl	vListInsertEnd
 1305              	.L54:
1072:../FreeRTOS/Source/tasks.c **** 			}
1073:../FreeRTOS/Source/tasks.c **** 		}
1074:../FreeRTOS/Source/tasks.c **** 
1075:../FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
 1306              		.loc 1 1075 0
 1307 074e FB68     		ldr	r3, [r7, #12]
1076:../FreeRTOS/Source/tasks.c **** 	}
 1308              		.loc 1 1076 0
 1309 0750 1846     		mov	r0, r3
 1310 0752 07F11007 		add	r7, r7, #16
 1311 0756 BD46     		mov	sp, r7
 1312 0758 80BD     		pop	{r7, pc}
 1313              		.cfi_endproc
 1314              	.LFE119:
 1316              		.section	.rodata
 1317              		.align	2
 1318              	.LC0:
 1319 0000 49444C45 		.ascii	"IDLE\000"
 1319      00
 1320              		.text
 1321 075a 00BF     		.align	2
 1322              		.global	vTaskStartScheduler
 1323              		.thumb
 1324              		.thumb_func
 1326              	vTaskStartScheduler:
 1327              	.LFB120:
1077:../FreeRTOS/Source/tasks.c **** 
1078:../FreeRTOS/Source/tasks.c **** #endif
1079:../FreeRTOS/Source/tasks.c **** 
1080:../FreeRTOS/Source/tasks.c **** 
1081:../FreeRTOS/Source/tasks.c **** 
1082:../FreeRTOS/Source/tasks.c **** 
1083:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1084:../FreeRTOS/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1085:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1086:../FreeRTOS/Source/tasks.c **** 
1087:../FreeRTOS/Source/tasks.c **** 
1088:../FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1089:../FreeRTOS/Source/tasks.c **** {
 1328              		.loc 1 1089 0
 1329              		.cfi_startproc
 1330              		@ args = 0, pretend = 0, frame = 8
 1331              		@ frame_needed = 1, uses_anonymous_args = 0
 1332 075c 80B5     		push	{r7, lr}
 1333              	.LCFI30:
 1334              		.cfi_def_cfa_offset 8
 1335              		.cfi_offset 14, -4
 1336              		.cfi_offset 7, -8
 1337 075e 86B0     		sub	sp, sp, #24
 1338              	.LCFI31:
 1339              		.cfi_def_cfa_offset 32
 1340 0760 04AF     		add	r7, sp, #16
 1341              	.LCFI32:
 1342              		.cfi_def_cfa 7, 16
1090:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1091:../FreeRTOS/Source/tasks.c **** 
1092:../FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1093:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1094:../FreeRTOS/Source/tasks.c **** 	{
1095:../FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1096:../FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1097:../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1343              		.loc 1 1097 0
 1344 0762 4FF00003 		mov	r3, #0
 1345 0766 0093     		str	r3, [sp, #0]
 1346 0768 40F20003 		movw	r3, #:lower16:xIdleTaskHandle
 1347 076c C0F20003 		movt	r3, #:upper16:xIdleTaskHandle
 1348 0770 0193     		str	r3, [sp, #4]
 1349 0772 4FF00003 		mov	r3, #0
 1350 0776 0293     		str	r3, [sp, #8]
 1351 0778 4FF00003 		mov	r3, #0
 1352 077c 0393     		str	r3, [sp, #12]
 1353 077e 40F20000 		movw	r0, #:lower16:prvIdleTask
 1354 0782 C0F20000 		movt	r0, #:upper16:prvIdleTask
 1355 0786 40F20001 		movw	r1, #:lower16:.LC0
 1356 078a C0F20001 		movt	r1, #:upper16:.LC0
 1357 078e 4FF48072 		mov	r2, #256
 1358 0792 4FF00003 		mov	r3, #0
 1359 0796 FFF7FEFF 		bl	xTaskGenericCreate
 1360 079a 0346     		mov	r3, r0
 1361 079c 7B60     		str	r3, [r7, #4]
1098:../FreeRTOS/Source/tasks.c **** 	}
1099:../FreeRTOS/Source/tasks.c **** 	#else
1100:../FreeRTOS/Source/tasks.c **** 	{
1101:../FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1102:../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1103:../FreeRTOS/Source/tasks.c **** 	}
1104:../FreeRTOS/Source/tasks.c **** 	#endif
1105:../FreeRTOS/Source/tasks.c **** 
1106:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1107:../FreeRTOS/Source/tasks.c **** 	{
1108:../FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1109:../FreeRTOS/Source/tasks.c **** 		{
1110:../FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1111:../FreeRTOS/Source/tasks.c **** 		}
1112:../FreeRTOS/Source/tasks.c **** 	}
1113:../FreeRTOS/Source/tasks.c **** 	#endif
1114:../FreeRTOS/Source/tasks.c **** 
1115:../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1362              		.loc 1 1115 0
 1363 079e 7B68     		ldr	r3, [r7, #4]
 1364 07a0 012B     		cmp	r3, #1
 1365 07a2 15D1     		bne	.L57
1116:../FreeRTOS/Source/tasks.c **** 	{
1117:../FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1118:../FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1119:../FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1120:../FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1121:../FreeRTOS/Source/tasks.c **** 		starts to run.
1122:../FreeRTOS/Source/tasks.c **** 
1123:../FreeRTOS/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1124:../FreeRTOS/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1125:../FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1366              		.loc 1 1125 0
 1367              	@ 1125 "../FreeRTOS/Source/tasks.c" 1
 1368 07a4 4FF0BF00 			mov r0, #191								
 1369 07a8 80F31188 		msr basepri, r0							
 1370              	
 1371              	@ 0 "" 2
1126:../FreeRTOS/Source/tasks.c **** 
1127:../FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1372              		.loc 1 1127 0
 1373              		.thumb
 1374 07ac 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1375 07b0 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1376 07b4 4FF00102 		mov	r2, #1
 1377 07b8 1A60     		str	r2, [r3, #0]
1128:../FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1378              		.loc 1 1128 0
 1379 07ba 40F20003 		movw	r3, #:lower16:xTickCount
 1380 07be C0F20003 		movt	r3, #:upper16:xTickCount
 1381 07c2 4FF00002 		mov	r2, #0
 1382 07c6 1A60     		str	r2, [r3, #0]
1129:../FreeRTOS/Source/tasks.c **** 
1130:../FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1131:../FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1132:../FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1133:../FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 1383              		.loc 1 1133 0
 1384 07c8 FFF7FEFF 		bl	init_us_timer
1134:../FreeRTOS/Source/tasks.c **** 		
1135:../FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1136:../FreeRTOS/Source/tasks.c **** 		portable interface. */
1137:../FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1385              		.loc 1 1137 0
 1386 07cc FFF7FEFF 		bl	xPortStartScheduler
 1387              	.L57:
1138:../FreeRTOS/Source/tasks.c **** 		{
1139:../FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1140:../FreeRTOS/Source/tasks.c **** 			function will not return. */
1141:../FreeRTOS/Source/tasks.c **** 		}
1142:../FreeRTOS/Source/tasks.c **** 		else
1143:../FreeRTOS/Source/tasks.c **** 		{
1144:../FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1145:../FreeRTOS/Source/tasks.c **** 		}
1146:../FreeRTOS/Source/tasks.c **** 	}
1147:../FreeRTOS/Source/tasks.c **** 
1148:../FreeRTOS/Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1149:../FreeRTOS/Source/tasks.c **** 	configASSERT( xReturn );
1150:../FreeRTOS/Source/tasks.c **** }
 1388              		.loc 1 1150 0
 1389 07d0 07F10807 		add	r7, r7, #8
 1390 07d4 BD46     		mov	sp, r7
 1391 07d6 80BD     		pop	{r7, pc}
 1392              		.cfi_endproc
 1393              	.LFE120:
 1395              		.align	2
 1396              		.global	vTaskEndScheduler
 1397              		.thumb
 1398              		.thumb_func
 1400              	vTaskEndScheduler:
 1401              	.LFB121:
1151:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1152:../FreeRTOS/Source/tasks.c **** 
1153:../FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1154:../FreeRTOS/Source/tasks.c **** {
 1402              		.loc 1 1154 0
 1403              		.cfi_startproc
 1404              		@ args = 0, pretend = 0, frame = 0
 1405              		@ frame_needed = 1, uses_anonymous_args = 0
 1406 07d8 80B5     		push	{r7, lr}
 1407              	.LCFI33:
 1408              		.cfi_def_cfa_offset 8
 1409              		.cfi_offset 14, -4
 1410              		.cfi_offset 7, -8
 1411 07da 00AF     		add	r7, sp, #0
 1412              	.LCFI34:
 1413              		.cfi_def_cfa_register 7
1155:../FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1156:../FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1157:../FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1158:../FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1414              		.loc 1 1158 0
 1415              	@ 1158 "../FreeRTOS/Source/tasks.c" 1
 1416 07dc 4FF0BF00 			mov r0, #191								
 1417 07e0 80F31188 		msr basepri, r0							
 1418              	
 1419              	@ 0 "" 2
1159:../FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1420              		.loc 1 1159 0
 1421              		.thumb
 1422 07e4 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1423 07e8 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1424 07ec 4FF00002 		mov	r2, #0
 1425 07f0 1A60     		str	r2, [r3, #0]
1160:../FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1426              		.loc 1 1160 0
 1427 07f2 FFF7FEFF 		bl	vPortEndScheduler
1161:../FreeRTOS/Source/tasks.c **** }
 1428              		.loc 1 1161 0
 1429 07f6 80BD     		pop	{r7, pc}
 1430              		.cfi_endproc
 1431              	.LFE121:
 1433              		.align	2
 1434              		.global	vTaskSuspendAll
 1435              		.thumb
 1436              		.thumb_func
 1438              	vTaskSuspendAll:
 1439              	.LFB122:
1162:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1163:../FreeRTOS/Source/tasks.c **** 
1164:../FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1165:../FreeRTOS/Source/tasks.c **** {
 1440              		.loc 1 1165 0
 1441              		.cfi_startproc
 1442              		@ args = 0, pretend = 0, frame = 0
 1443              		@ frame_needed = 1, uses_anonymous_args = 0
 1444              		@ link register save eliminated.
 1445 07f8 80B4     		push	{r7}
 1446              	.LCFI35:
 1447              		.cfi_def_cfa_offset 4
 1448              		.cfi_offset 7, -4
 1449 07fa 00AF     		add	r7, sp, #0
 1450              	.LCFI36:
 1451              		.cfi_def_cfa_register 7
1166:../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1167:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1168:../FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1452              		.loc 1 1168 0
 1453 07fc 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1454 0800 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1455 0804 1B68     		ldr	r3, [r3, #0]
 1456 0806 03F10102 		add	r2, r3, #1
 1457 080a 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1458 080e C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1459 0812 1A60     		str	r2, [r3, #0]
1169:../FreeRTOS/Source/tasks.c **** }
 1460              		.loc 1 1169 0
 1461 0814 BD46     		mov	sp, r7
 1462 0816 80BC     		pop	{r7}
 1463 0818 7047     		bx	lr
 1464              		.cfi_endproc
 1465              	.LFE122:
 1467 081a 00BF     		.align	2
 1468              		.global	xTaskResumeAll
 1469              		.thumb
 1470              		.thumb_func
 1472              	xTaskResumeAll:
 1473              	.LFB123:
1170:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1171:../FreeRTOS/Source/tasks.c **** 
1172:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1173:../FreeRTOS/Source/tasks.c **** {
 1474              		.loc 1 1173 0
 1475              		.cfi_startproc
 1476              		@ args = 0, pretend = 0, frame = 8
 1477              		@ frame_needed = 1, uses_anonymous_args = 0
 1478 081c 90B5     		push	{r4, r7, lr}
 1479              	.LCFI37:
 1480              		.cfi_def_cfa_offset 12
 1481              		.cfi_offset 14, -4
 1482              		.cfi_offset 7, -8
 1483              		.cfi_offset 4, -12
 1484 081e 83B0     		sub	sp, sp, #12
 1485              	.LCFI38:
 1486              		.cfi_def_cfa_offset 24
 1487 0820 00AF     		add	r7, sp, #0
 1488              	.LCFI39:
 1489              		.cfi_def_cfa_register 7
1174:../FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
1175:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1490              		.loc 1 1175 0
 1491 0822 4FF00003 		mov	r3, #0
 1492 0826 7B60     		str	r3, [r7, #4]
1176:../FreeRTOS/Source/tasks.c **** 
1177:../FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1178:../FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1179:../FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1180:../FreeRTOS/Source/tasks.c **** 
1181:../FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1182:../FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1183:../FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1184:../FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1185:../FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1186:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1493              		.loc 1 1186 0
 1494 0828 FFF7FEFF 		bl	vPortEnterCritical
1187:../FreeRTOS/Source/tasks.c **** 	{
1188:../FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1495              		.loc 1 1188 0
 1496 082c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1497 0830 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1498 0834 1B68     		ldr	r3, [r3, #0]
 1499 0836 03F1FF32 		add	r2, r3, #-1
 1500 083a 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1501 083e C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1502 0842 1A60     		str	r2, [r3, #0]
1189:../FreeRTOS/Source/tasks.c **** 
1190:../FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1503              		.loc 1 1190 0
 1504 0844 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1505 0848 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1506 084c 1B68     		ldr	r3, [r3, #0]
 1507 084e 002B     		cmp	r3, #0
 1508 0850 40F08680 		bne	.L62
1191:../FreeRTOS/Source/tasks.c **** 		{
1192:../FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1509              		.loc 1 1192 0
 1510 0854 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1511 0858 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1512 085c 1B68     		ldr	r3, [r3, #0]
 1513 085e 002B     		cmp	r3, #0
 1514 0860 7ED0     		beq	.L62
 1515              	.LBB3:
1193:../FreeRTOS/Source/tasks.c **** 			{
1194:../FreeRTOS/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1516              		.loc 1 1194 0
 1517 0862 4FF00003 		mov	r3, #0
 1518 0866 3B60     		str	r3, [r7, #0]
1195:../FreeRTOS/Source/tasks.c **** 
1196:../FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1197:../FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1198:../FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1519              		.loc 1 1198 0
 1520 0868 3DE0     		b	.L63
 1521              	.L65:
1199:../FreeRTOS/Source/tasks.c **** 				{
1200:../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1522              		.loc 1 1200 0
 1523 086a 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1524 086e C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1525 0872 DB68     		ldr	r3, [r3, #12]
 1526 0874 DB68     		ldr	r3, [r3, #12]
 1527 0876 1C46     		mov	r4, r3
1201:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1528              		.loc 1 1201 0
 1529 0878 04F11803 		add	r3, r4, #24
 1530 087c 1846     		mov	r0, r3
 1531 087e FFF7FEFF 		bl	vListRemove
1202:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1532              		.loc 1 1202 0
 1533 0882 04F10403 		add	r3, r4, #4
 1534 0886 1846     		mov	r0, r3
 1535 0888 FFF7FEFF 		bl	vListRemove
1203:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1536              		.loc 1 1203 0
 1537 088c E26A     		ldr	r2, [r4, #44]
 1538 088e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1539 0892 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1540 0896 1B68     		ldr	r3, [r3, #0]
 1541 0898 9A42     		cmp	r2, r3
 1542 089a 05D9     		bls	.L64
 1543              		.loc 1 1203 0 is_stmt 0 discriminator 1
 1544 089c E26A     		ldr	r2, [r4, #44]
 1545 089e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1546 08a2 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1547 08a6 1A60     		str	r2, [r3, #0]
 1548              	.L64:
 1549              		.loc 1 1203 0 discriminator 2
 1550 08a8 E26A     		ldr	r2, [r4, #44]
 1551 08aa 1346     		mov	r3, r2
 1552 08ac 4FEA8303 		lsl	r3, r3, #2
 1553 08b0 9B18     		adds	r3, r3, r2
 1554 08b2 4FEA8303 		lsl	r3, r3, #2
 1555 08b6 1A46     		mov	r2, r3
 1556 08b8 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1557 08bc C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1558 08c0 D218     		adds	r2, r2, r3
 1559 08c2 04F10403 		add	r3, r4, #4
 1560 08c6 1046     		mov	r0, r2
 1561 08c8 1946     		mov	r1, r3
 1562 08ca FFF7FEFF 		bl	vListInsertEnd
1204:../FreeRTOS/Source/tasks.c **** 
1205:../FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1206:../FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1207:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1563              		.loc 1 1207 0 is_stmt 1 discriminator 2
 1564 08ce E26A     		ldr	r2, [r4, #44]
 1565 08d0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1566 08d4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1567 08d8 1B68     		ldr	r3, [r3, #0]
 1568 08da DB6A     		ldr	r3, [r3, #44]
 1569 08dc 9A42     		cmp	r2, r3
 1570 08de 02D3     		bcc	.L63
1208:../FreeRTOS/Source/tasks.c **** 					{
1209:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1571              		.loc 1 1209 0
 1572 08e0 4FF00103 		mov	r3, #1
 1573 08e4 3B60     		str	r3, [r7, #0]
 1574              	.L63:
1198:../FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1575              		.loc 1 1198 0 discriminator 1
 1576 08e6 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1577 08ea C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1578 08ee 1B68     		ldr	r3, [r3, #0]
 1579 08f0 002B     		cmp	r3, #0
 1580 08f2 BAD1     		bne	.L65
1210:../FreeRTOS/Source/tasks.c **** 					}
1211:../FreeRTOS/Source/tasks.c **** 				}
1212:../FreeRTOS/Source/tasks.c **** 
1213:../FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1214:../FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1215:../FreeRTOS/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1216:../FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1581              		.loc 1 1216 0
 1582 08f4 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1583 08f8 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1584 08fc 1B68     		ldr	r3, [r3, #0]
 1585 08fe 002B     		cmp	r3, #0
 1586 0900 18D0     		beq	.L66
1217:../FreeRTOS/Source/tasks.c **** 				{
1218:../FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1587              		.loc 1 1218 0
 1588 0902 0DE0     		b	.L67
 1589              	.L68:
1219:../FreeRTOS/Source/tasks.c **** 					{
1220:../FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
 1590              		.loc 1 1220 0
 1591 0904 FFF7FEFF 		bl	vTaskIncrementTick
1221:../FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
 1592              		.loc 1 1221 0
 1593 0908 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1594 090c C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1595 0910 1B68     		ldr	r3, [r3, #0]
 1596 0912 03F1FF32 		add	r2, r3, #-1
 1597 0916 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1598 091a C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1599 091e 1A60     		str	r2, [r3, #0]
 1600              	.L67:
1218:../FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1601              		.loc 1 1218 0 discriminator 1
 1602 0920 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1603 0924 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1604 0928 1B68     		ldr	r3, [r3, #0]
 1605 092a 002B     		cmp	r3, #0
 1606 092c EAD1     		bne	.L68
1222:../FreeRTOS/Source/tasks.c **** 					}
1223:../FreeRTOS/Source/tasks.c **** 
1224:../FreeRTOS/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1225:../FreeRTOS/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1226:../FreeRTOS/Source/tasks.c **** 					the task actually running. */
1227:../FreeRTOS/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1228:../FreeRTOS/Source/tasks.c **** 					{
1229:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1607              		.loc 1 1229 0
 1608 092e 4FF00103 		mov	r3, #1
 1609 0932 3B60     		str	r3, [r7, #0]
 1610              	.L66:
1230:../FreeRTOS/Source/tasks.c **** 					}
1231:../FreeRTOS/Source/tasks.c **** 					#endif
1232:../FreeRTOS/Source/tasks.c **** 				}
1233:../FreeRTOS/Source/tasks.c **** 
1234:../FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1611              		.loc 1 1234 0
 1612 0934 3B68     		ldr	r3, [r7, #0]
 1613 0936 012B     		cmp	r3, #1
 1614 0938 06D0     		beq	.L69
 1615              		.loc 1 1234 0 is_stmt 0 discriminator 1
 1616 093a 40F20003 		movw	r3, #:lower16:xMissedYield
 1617 093e C0F20003 		movt	r3, #:upper16:xMissedYield
 1618 0942 1B68     		ldr	r3, [r3, #0]
 1619 0944 012B     		cmp	r3, #1
 1620 0946 0BD1     		bne	.L62
 1621              	.L69:
1235:../FreeRTOS/Source/tasks.c **** 				{
1236:../FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1622              		.loc 1 1236 0 is_stmt 1
 1623 0948 4FF00103 		mov	r3, #1
 1624 094c 7B60     		str	r3, [r7, #4]
1237:../FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1625              		.loc 1 1237 0
 1626 094e 40F20003 		movw	r3, #:lower16:xMissedYield
 1627 0952 C0F20003 		movt	r3, #:upper16:xMissedYield
 1628 0956 4FF00002 		mov	r2, #0
 1629 095a 1A60     		str	r2, [r3, #0]
1238:../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1630              		.loc 1 1238 0
 1631 095c FFF7FEFF 		bl	vPortYieldFromISR
 1632              	.L62:
 1633              	.LBE3:
1239:../FreeRTOS/Source/tasks.c **** 				}
1240:../FreeRTOS/Source/tasks.c **** 			}
1241:../FreeRTOS/Source/tasks.c **** 		}
1242:../FreeRTOS/Source/tasks.c **** 	}
1243:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1634              		.loc 1 1243 0
 1635 0960 FFF7FEFF 		bl	vPortExitCritical
1244:../FreeRTOS/Source/tasks.c **** 
1245:../FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
 1636              		.loc 1 1245 0
 1637 0964 7B68     		ldr	r3, [r7, #4]
1246:../FreeRTOS/Source/tasks.c **** }
 1638              		.loc 1 1246 0
 1639 0966 1846     		mov	r0, r3
 1640 0968 07F10C07 		add	r7, r7, #12
 1641 096c BD46     		mov	sp, r7
 1642 096e 90BD     		pop	{r4, r7, pc}
 1643              		.cfi_endproc
 1644              	.LFE123:
 1646              		.align	2
 1647              		.global	xTaskGetTickCount
 1648              		.thumb
 1649              		.thumb_func
 1651              	xTaskGetTickCount:
 1652              	.LFB124:
1247:../FreeRTOS/Source/tasks.c **** 
1248:../FreeRTOS/Source/tasks.c **** 
1249:../FreeRTOS/Source/tasks.c **** 
1250:../FreeRTOS/Source/tasks.c **** 
1251:../FreeRTOS/Source/tasks.c **** 
1252:../FreeRTOS/Source/tasks.c **** 
1253:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1254:../FreeRTOS/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1255:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1256:../FreeRTOS/Source/tasks.c **** 
1257:../FreeRTOS/Source/tasks.c **** 
1258:../FreeRTOS/Source/tasks.c **** 
1259:../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1260:../FreeRTOS/Source/tasks.c **** {
 1653              		.loc 1 1260 0
 1654              		.cfi_startproc
 1655              		@ args = 0, pretend = 0, frame = 8
 1656              		@ frame_needed = 1, uses_anonymous_args = 0
 1657 0970 80B5     		push	{r7, lr}
 1658              	.LCFI40:
 1659              		.cfi_def_cfa_offset 8
 1660              		.cfi_offset 14, -4
 1661              		.cfi_offset 7, -8
 1662 0972 82B0     		sub	sp, sp, #8
 1663              	.LCFI41:
 1664              		.cfi_def_cfa_offset 16
 1665 0974 00AF     		add	r7, sp, #0
 1666              	.LCFI42:
 1667              		.cfi_def_cfa_register 7
1261:../FreeRTOS/Source/tasks.c **** portTickType xTicks;
1262:../FreeRTOS/Source/tasks.c **** 
1263:../FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1264:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1668              		.loc 1 1264 0
 1669 0976 FFF7FEFF 		bl	vPortEnterCritical
1265:../FreeRTOS/Source/tasks.c **** 	{
1266:../FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 1670              		.loc 1 1266 0
 1671 097a 40F20003 		movw	r3, #:lower16:xTickCount
 1672 097e C0F20003 		movt	r3, #:upper16:xTickCount
 1673 0982 1B68     		ldr	r3, [r3, #0]
 1674 0984 7B60     		str	r3, [r7, #4]
1267:../FreeRTOS/Source/tasks.c **** 	}
1268:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1675              		.loc 1 1268 0
 1676 0986 FFF7FEFF 		bl	vPortExitCritical
1269:../FreeRTOS/Source/tasks.c **** 
1270:../FreeRTOS/Source/tasks.c **** 	return xTicks;
 1677              		.loc 1 1270 0
 1678 098a 7B68     		ldr	r3, [r7, #4]
1271:../FreeRTOS/Source/tasks.c **** }
 1679              		.loc 1 1271 0
 1680 098c 1846     		mov	r0, r3
 1681 098e 07F10807 		add	r7, r7, #8
 1682 0992 BD46     		mov	sp, r7
 1683 0994 80BD     		pop	{r7, pc}
 1684              		.cfi_endproc
 1685              	.LFE124:
 1687 0996 00BF     		.align	2
 1688              		.global	xTaskGetTickCountFromISR
 1689              		.thumb
 1690              		.thumb_func
 1692              	xTaskGetTickCountFromISR:
 1693              	.LFB125:
1272:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1273:../FreeRTOS/Source/tasks.c **** 
1274:../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1275:../FreeRTOS/Source/tasks.c **** {
 1694              		.loc 1 1275 0
 1695              		.cfi_startproc
 1696              		@ args = 0, pretend = 0, frame = 8
 1697              		@ frame_needed = 1, uses_anonymous_args = 0
 1698              		@ link register save eliminated.
 1699 0998 80B4     		push	{r7}
 1700              	.LCFI43:
 1701              		.cfi_def_cfa_offset 4
 1702              		.cfi_offset 7, -4
 1703 099a 83B0     		sub	sp, sp, #12
 1704              	.LCFI44:
 1705              		.cfi_def_cfa_offset 16
 1706 099c 00AF     		add	r7, sp, #0
 1707              	.LCFI45:
 1708              		.cfi_def_cfa_register 7
1276:../FreeRTOS/Source/tasks.c **** portTickType xReturn;
1277:../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1278:../FreeRTOS/Source/tasks.c **** 
1279:../FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1709              		.loc 1 1279 0
 1710 099e 4FF00003 		mov	r3, #0
 1711 09a2 7B60     		str	r3, [r7, #4]
 1712              	@ 1279 "../FreeRTOS/Source/tasks.c" 1
 1713 09a4 4FF0BF00 			mov r0, #191								
 1714 09a8 80F31188 		msr basepri, r0							
 1715              	
 1716              	@ 0 "" 2
1280:../FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
 1717              		.loc 1 1280 0
 1718              		.thumb
 1719 09ac 40F20003 		movw	r3, #:lower16:xTickCount
 1720 09b0 C0F20003 		movt	r3, #:upper16:xTickCount
 1721 09b4 1B68     		ldr	r3, [r3, #0]
 1722 09b6 3B60     		str	r3, [r7, #0]
1281:../FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1723              		.loc 1 1281 0
 1724              	@ 1281 "../FreeRTOS/Source/tasks.c" 1
 1725 09b8 4FF00000 			mov r0, #0					
 1726 09bc 80F31188 		msr basepri, r0				
 1727              	
 1728              	@ 0 "" 2
1282:../FreeRTOS/Source/tasks.c **** 
1283:../FreeRTOS/Source/tasks.c **** 	return xReturn;
 1729              		.loc 1 1283 0
 1730              		.thumb
 1731 09c0 3B68     		ldr	r3, [r7, #0]
1284:../FreeRTOS/Source/tasks.c **** }
 1732              		.loc 1 1284 0
 1733 09c2 1846     		mov	r0, r3
 1734 09c4 07F10C07 		add	r7, r7, #12
 1735 09c8 BD46     		mov	sp, r7
 1736 09ca 80BC     		pop	{r7}
 1737 09cc 7047     		bx	lr
 1738              		.cfi_endproc
 1739              	.LFE125:
 1741 09ce 00BF     		.align	2
 1742              		.global	uxTaskGetNumberOfTasks
 1743              		.thumb
 1744              		.thumb_func
 1746              	uxTaskGetNumberOfTasks:
 1747              	.LFB126:
1285:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1286:../FreeRTOS/Source/tasks.c **** 
1287:../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1288:../FreeRTOS/Source/tasks.c **** {
 1748              		.loc 1 1288 0
 1749              		.cfi_startproc
 1750              		@ args = 0, pretend = 0, frame = 0
 1751              		@ frame_needed = 1, uses_anonymous_args = 0
 1752              		@ link register save eliminated.
 1753 09d0 80B4     		push	{r7}
 1754              	.LCFI46:
 1755              		.cfi_def_cfa_offset 4
 1756              		.cfi_offset 7, -4
 1757 09d2 00AF     		add	r7, sp, #0
 1758              	.LCFI47:
 1759              		.cfi_def_cfa_register 7
1289:../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1290:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1291:../FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1760              		.loc 1 1291 0
 1761 09d4 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1762 09d8 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1763 09dc 1B68     		ldr	r3, [r3, #0]
1292:../FreeRTOS/Source/tasks.c **** }
 1764              		.loc 1 1292 0
 1765 09de 1846     		mov	r0, r3
 1766 09e0 BD46     		mov	sp, r7
 1767 09e2 80BC     		pop	{r7}
 1768 09e4 7047     		bx	lr
 1769              		.cfi_endproc
 1770              	.LFE126:
 1772              		.section	.rodata
 1773 0005 000000   		.align	2
 1774              	.LC1:
 1775 0008 0D0A00   		.ascii	"\015\012\000"
 1776              		.text
 1777 09e6 00BF     		.align	2
 1778              		.global	vTaskGetRunTimeStats
 1779              		.thumb
 1780              		.thumb_func
 1782              	vTaskGetRunTimeStats:
 1783              	.LFB127:
1293:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1294:../FreeRTOS/Source/tasks.c **** 
1295:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1296:../FreeRTOS/Source/tasks.c **** 
1297:../FreeRTOS/Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1298:../FreeRTOS/Source/tasks.c **** 	{
1299:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1300:../FreeRTOS/Source/tasks.c **** 
1301:../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1302:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1303:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1304:../FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1305:../FreeRTOS/Source/tasks.c **** 	}
1306:../FreeRTOS/Source/tasks.c **** 
1307:../FreeRTOS/Source/tasks.c **** #endif
1308:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1309:../FreeRTOS/Source/tasks.c **** 
1310:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1311:../FreeRTOS/Source/tasks.c **** 
1312:../FreeRTOS/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1313:../FreeRTOS/Source/tasks.c **** 	{
1314:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1315:../FreeRTOS/Source/tasks.c **** 
1316:../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1317:../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1318:../FreeRTOS/Source/tasks.c **** 
1319:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1320:../FreeRTOS/Source/tasks.c **** 		{
1321:../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1322:../FreeRTOS/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1323:../FreeRTOS/Source/tasks.c **** 
1324:../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1325:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1326:../FreeRTOS/Source/tasks.c **** 
1327:../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1328:../FreeRTOS/Source/tasks.c **** 
1329:../FreeRTOS/Source/tasks.c **** 			do
1330:../FreeRTOS/Source/tasks.c **** 			{
1331:../FreeRTOS/Source/tasks.c **** 				uxQueue--;
1332:../FreeRTOS/Source/tasks.c **** 
1333:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1334:../FreeRTOS/Source/tasks.c **** 				{
1335:../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1336:../FreeRTOS/Source/tasks.c **** 				}
1337:../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1338:../FreeRTOS/Source/tasks.c **** 
1339:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1340:../FreeRTOS/Source/tasks.c **** 			{
1341:../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1342:../FreeRTOS/Source/tasks.c **** 			}
1343:../FreeRTOS/Source/tasks.c **** 
1344:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1345:../FreeRTOS/Source/tasks.c **** 			{
1346:../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1347:../FreeRTOS/Source/tasks.c **** 			}
1348:../FreeRTOS/Source/tasks.c **** 
1349:../FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1350:../FreeRTOS/Source/tasks.c **** 			{
1351:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1352:../FreeRTOS/Source/tasks.c **** 				{
1353:../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1354:../FreeRTOS/Source/tasks.c **** 				}
1355:../FreeRTOS/Source/tasks.c **** 			}
1356:../FreeRTOS/Source/tasks.c **** 			#endif
1357:../FreeRTOS/Source/tasks.c **** 
1358:../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1359:../FreeRTOS/Source/tasks.c **** 			{
1360:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1361:../FreeRTOS/Source/tasks.c **** 				{
1362:../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1363:../FreeRTOS/Source/tasks.c **** 				}
1364:../FreeRTOS/Source/tasks.c **** 			}
1365:../FreeRTOS/Source/tasks.c **** 			#endif
1366:../FreeRTOS/Source/tasks.c **** 		}
1367:../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1368:../FreeRTOS/Source/tasks.c **** 	}
1369:../FreeRTOS/Source/tasks.c **** 
1370:../FreeRTOS/Source/tasks.c **** #endif
1371:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1372:../FreeRTOS/Source/tasks.c **** 
1373:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1374:../FreeRTOS/Source/tasks.c **** 
1375:../FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1376:../FreeRTOS/Source/tasks.c **** 	{
 1784              		.loc 1 1376 0
 1785              		.cfi_startproc
 1786              		@ args = 0, pretend = 0, frame = 16
 1787              		@ frame_needed = 1, uses_anonymous_args = 0
 1788 09e8 90B5     		push	{r4, r7, lr}
 1789              	.LCFI48:
 1790              		.cfi_def_cfa_offset 12
 1791              		.cfi_offset 14, -4
 1792              		.cfi_offset 7, -8
 1793              		.cfi_offset 4, -12
 1794 09ea 85B0     		sub	sp, sp, #20
 1795              	.LCFI49:
 1796              		.cfi_def_cfa_offset 32
 1797 09ec 00AF     		add	r7, sp, #0
 1798              	.LCFI50:
 1799              		.cfi_def_cfa_register 7
 1800 09ee 7860     		str	r0, [r7, #4]
1377:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1378:../FreeRTOS/Source/tasks.c **** 	unsigned long ulTotalRunTime;
1379:../FreeRTOS/Source/tasks.c **** 
1380:../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1381:../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1382:../FreeRTOS/Source/tasks.c **** 
1383:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 1801              		.loc 1 1383 0
 1802 09f0 FFF7FEFF 		bl	vTaskSuspendAll
1384:../FreeRTOS/Source/tasks.c **** 		{
1385:../FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1386:../FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1387:../FreeRTOS/Source/tasks.c **** 			#else
1388:../FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 1803              		.loc 1 1388 0
 1804 09f4 FFF7FEFF 		bl	get_us_time
 1805 09f8 0246     		mov	r2, r0
 1806 09fa 0B46     		mov	r3, r1
 1807 09fc 1346     		mov	r3, r2
 1808 09fe BB60     		str	r3, [r7, #8]
1389:../FreeRTOS/Source/tasks.c **** 			#endif
1390:../FreeRTOS/Source/tasks.c **** 
1391:../FreeRTOS/Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1392:../FreeRTOS/Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1393:../FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
 1809              		.loc 1 1393 0
 1810 0a00 BA68     		ldr	r2, [r7, #8]
 1811 0a02 48F21F53 		movw	r3, #34079
 1812 0a06 C5F2EB13 		movt	r3, 20971
 1813 0a0a A3FB0213 		umull	r1, r3, r3, r2
 1814 0a0e 4FEA5313 		lsr	r3, r3, #5
 1815 0a12 BB60     		str	r3, [r7, #8]
1394:../FreeRTOS/Source/tasks.c **** 			
1395:../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1396:../FreeRTOS/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1397:../FreeRTOS/Source/tasks.c **** 			buffer. */
1398:../FreeRTOS/Source/tasks.c **** 
1399:../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 1816              		.loc 1 1399 0
 1817 0a14 7B68     		ldr	r3, [r7, #4]
 1818 0a16 4FF00002 		mov	r2, #0
 1819 0a1a 1A70     		strb	r2, [r3, #0]
1400:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 1820              		.loc 1 1400 0
 1821 0a1c 7C68     		ldr	r4, [r7, #4]
 1822 0a1e 2046     		mov	r0, r4
 1823 0a20 FFF7FEFF 		bl	strlen
 1824 0a24 0346     		mov	r3, r0
 1825 0a26 E218     		adds	r2, r4, r3
 1826 0a28 40F20003 		movw	r3, #:lower16:.LC1
 1827 0a2c C0F20003 		movt	r3, #:upper16:.LC1
 1828 0a30 1146     		mov	r1, r2
 1829 0a32 1A46     		mov	r2, r3
 1830 0a34 4FF00303 		mov	r3, #3
 1831 0a38 0846     		mov	r0, r1
 1832 0a3a 1146     		mov	r1, r2
 1833 0a3c 1A46     		mov	r2, r3
 1834 0a3e FFF7FEFF 		bl	memcpy
1401:../FreeRTOS/Source/tasks.c **** 
1402:../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 1835              		.loc 1 1402 0
 1836 0a42 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 1837 0a46 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 1838 0a4a 1B68     		ldr	r3, [r3, #0]
 1839 0a4c 03F10103 		add	r3, r3, #1
 1840 0a50 FB60     		str	r3, [r7, #12]
 1841              	.L75:
1403:../FreeRTOS/Source/tasks.c **** 
1404:../FreeRTOS/Source/tasks.c **** 			do
1405:../FreeRTOS/Source/tasks.c **** 			{
1406:../FreeRTOS/Source/tasks.c **** 				uxQueue--;
 1842              		.loc 1 1406 0
 1843 0a52 FB68     		ldr	r3, [r7, #12]
 1844 0a54 03F1FF33 		add	r3, r3, #-1
 1845 0a58 FB60     		str	r3, [r7, #12]
1407:../FreeRTOS/Source/tasks.c **** 
1408:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 1846              		.loc 1 1408 0
 1847 0a5a FA68     		ldr	r2, [r7, #12]
 1848 0a5c 1346     		mov	r3, r2
 1849 0a5e 4FEA8303 		lsl	r3, r3, #2
 1850 0a62 9B18     		adds	r3, r3, r2
 1851 0a64 4FEA8303 		lsl	r3, r3, #2
 1852 0a68 1A46     		mov	r2, r3
 1853 0a6a 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1854 0a6e C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1855 0a72 D318     		adds	r3, r2, r3
 1856 0a74 1B68     		ldr	r3, [r3, #0]
 1857 0a76 002B     		cmp	r3, #0
 1858 0a78 13D0     		beq	.L74
1409:../FreeRTOS/Source/tasks.c **** 				{
1410:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
 1859              		.loc 1 1410 0
 1860 0a7a FA68     		ldr	r2, [r7, #12]
 1861 0a7c 1346     		mov	r3, r2
 1862 0a7e 4FEA8303 		lsl	r3, r3, #2
 1863 0a82 9B18     		adds	r3, r3, r2
 1864 0a84 4FEA8303 		lsl	r3, r3, #2
 1865 0a88 1A46     		mov	r2, r3
 1866 0a8a 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1867 0a8e C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1868 0a92 D318     		adds	r3, r2, r3
 1869 0a94 7868     		ldr	r0, [r7, #4]
 1870 0a96 1946     		mov	r1, r3
 1871 0a98 BA68     		ldr	r2, [r7, #8]
 1872 0a9a 4FF05203 		mov	r3, #82
 1873 0a9e 00F0C3FC 		bl	prvGenerateRunTimeStatsForTasksInList
 1874              	.L74:
1411:../FreeRTOS/Source/tasks.c **** 				}
1412:../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 1875              		.loc 1 1412 0
 1876 0aa2 FB68     		ldr	r3, [r7, #12]
 1877 0aa4 002B     		cmp	r3, #0
 1878 0aa6 D4D1     		bne	.L75
1413:../FreeRTOS/Source/tasks.c **** 
1414:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 1879              		.loc 1 1414 0
 1880 0aa8 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1881 0aac C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1882 0ab0 1B68     		ldr	r3, [r3, #0]
 1883 0ab2 1B68     		ldr	r3, [r3, #0]
 1884 0ab4 002B     		cmp	r3, #0
 1885 0ab6 0BD0     		beq	.L76
1415:../FreeRTOS/Source/tasks.c **** 			{
1416:../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
 1886              		.loc 1 1416 0
 1887 0ab8 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1888 0abc C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1889 0ac0 1B68     		ldr	r3, [r3, #0]
 1890 0ac2 7868     		ldr	r0, [r7, #4]
 1891 0ac4 1946     		mov	r1, r3
 1892 0ac6 BA68     		ldr	r2, [r7, #8]
 1893 0ac8 4FF04203 		mov	r3, #66
 1894 0acc 00F0ACFC 		bl	prvGenerateRunTimeStatsForTasksInList
 1895              	.L76:
1417:../FreeRTOS/Source/tasks.c **** 			}
1418:../FreeRTOS/Source/tasks.c **** 
1419:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 1896              		.loc 1 1419 0
 1897 0ad0 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1898 0ad4 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1899 0ad8 1B68     		ldr	r3, [r3, #0]
 1900 0ada 1B68     		ldr	r3, [r3, #0]
 1901 0adc 002B     		cmp	r3, #0
 1902 0ade 0BD0     		beq	.L77
1420:../FreeRTOS/Source/tasks.c **** 			{
1421:../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
 1903              		.loc 1 1421 0
 1904 0ae0 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1905 0ae4 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1906 0ae8 1B68     		ldr	r3, [r3, #0]
 1907 0aea 7868     		ldr	r0, [r7, #4]
 1908 0aec 1946     		mov	r1, r3
 1909 0aee BA68     		ldr	r2, [r7, #8]
 1910 0af0 4FF04203 		mov	r3, #66
 1911 0af4 00F098FC 		bl	prvGenerateRunTimeStatsForTasksInList
 1912              	.L77:
1422:../FreeRTOS/Source/tasks.c **** 			}
1423:../FreeRTOS/Source/tasks.c **** 
1424:../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1425:../FreeRTOS/Source/tasks.c **** 			{
1426:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 1913              		.loc 1 1426 0
 1914 0af8 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 1915 0afc C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 1916 0b00 1B68     		ldr	r3, [r3, #0]
 1917 0b02 002B     		cmp	r3, #0
 1918 0b04 09D0     		beq	.L78
1427:../FreeRTOS/Source/tasks.c **** 				{
1428:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
 1919              		.loc 1 1428 0
 1920 0b06 7868     		ldr	r0, [r7, #4]
 1921 0b08 40F20001 		movw	r1, #:lower16:xTasksWaitingTermination
 1922 0b0c C0F20001 		movt	r1, #:upper16:xTasksWaitingTermination
 1923 0b10 BA68     		ldr	r2, [r7, #8]
 1924 0b12 4FF04403 		mov	r3, #68
 1925 0b16 00F087FC 		bl	prvGenerateRunTimeStatsForTasksInList
 1926              	.L78:
1429:../FreeRTOS/Source/tasks.c **** 				}
1430:../FreeRTOS/Source/tasks.c **** 			}
1431:../FreeRTOS/Source/tasks.c **** 			#endif
1432:../FreeRTOS/Source/tasks.c **** 
1433:../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1434:../FreeRTOS/Source/tasks.c **** 			{
1435:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 1927              		.loc 1 1435 0
 1928 0b1a 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1929 0b1e C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1930 0b22 1B68     		ldr	r3, [r3, #0]
 1931 0b24 002B     		cmp	r3, #0
 1932 0b26 09D0     		beq	.L79
1436:../FreeRTOS/Source/tasks.c **** 				{
1437:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime, tsk
 1933              		.loc 1 1437 0
 1934 0b28 7868     		ldr	r0, [r7, #4]
 1935 0b2a 40F20001 		movw	r1, #:lower16:xSuspendedTaskList
 1936 0b2e C0F20001 		movt	r1, #:upper16:xSuspendedTaskList
 1937 0b32 BA68     		ldr	r2, [r7, #8]
 1938 0b34 4FF05303 		mov	r3, #83
 1939 0b38 00F076FC 		bl	prvGenerateRunTimeStatsForTasksInList
 1940              	.L79:
1438:../FreeRTOS/Source/tasks.c **** 				}
1439:../FreeRTOS/Source/tasks.c **** 			}
1440:../FreeRTOS/Source/tasks.c **** 			#endif
1441:../FreeRTOS/Source/tasks.c **** 		}
1442:../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
 1941              		.loc 1 1442 0
 1942 0b3c FFF7FEFF 		bl	xTaskResumeAll
1443:../FreeRTOS/Source/tasks.c **** 	}
 1943              		.loc 1 1443 0
 1944 0b40 07F11407 		add	r7, r7, #20
 1945 0b44 BD46     		mov	sp, r7
 1946 0b46 90BD     		pop	{r4, r7, pc}
 1947              		.cfi_endproc
 1948              	.LFE127:
 1950              		.align	2
 1951              		.global	xTaskGetIdleTaskHandle
 1952              		.thumb
 1953              		.thumb_func
 1955              	xTaskGetIdleTaskHandle:
 1956              	.LFB128:
1444:../FreeRTOS/Source/tasks.c **** 
1445:../FreeRTOS/Source/tasks.c **** #endif
1446:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1447:../FreeRTOS/Source/tasks.c **** 
1448:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1449:../FreeRTOS/Source/tasks.c **** 
1450:../FreeRTOS/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1451:../FreeRTOS/Source/tasks.c **** 	{
1452:../FreeRTOS/Source/tasks.c **** 		configASSERT( pcBuffer );
1453:../FreeRTOS/Source/tasks.c **** 		configASSERT( ulBufferSize );
1454:../FreeRTOS/Source/tasks.c **** 
1455:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1456:../FreeRTOS/Source/tasks.c **** 		{
1457:../FreeRTOS/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1458:../FreeRTOS/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1459:../FreeRTOS/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1460:../FreeRTOS/Source/tasks.c **** 			xTracing = pdTRUE;
1461:../FreeRTOS/Source/tasks.c **** 		}
1462:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1463:../FreeRTOS/Source/tasks.c **** 	}
1464:../FreeRTOS/Source/tasks.c **** 
1465:../FreeRTOS/Source/tasks.c **** #endif
1466:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1467:../FreeRTOS/Source/tasks.c **** 
1468:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1469:../FreeRTOS/Source/tasks.c **** 
1470:../FreeRTOS/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1471:../FreeRTOS/Source/tasks.c **** 	{
1472:../FreeRTOS/Source/tasks.c **** 	unsigned long ulBufferLength;
1473:../FreeRTOS/Source/tasks.c **** 
1474:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1475:../FreeRTOS/Source/tasks.c **** 			xTracing = pdFALSE;
1476:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1477:../FreeRTOS/Source/tasks.c **** 
1478:../FreeRTOS/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1479:../FreeRTOS/Source/tasks.c **** 
1480:../FreeRTOS/Source/tasks.c **** 		return ulBufferLength;
1481:../FreeRTOS/Source/tasks.c **** 	}
1482:../FreeRTOS/Source/tasks.c **** 
1483:../FreeRTOS/Source/tasks.c **** #endif
1484:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1485:../FreeRTOS/Source/tasks.c **** 
1486:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1487:../FreeRTOS/Source/tasks.c **** 
1488:../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1489:../FreeRTOS/Source/tasks.c **** 	{
 1957              		.loc 1 1489 0
 1958              		.cfi_startproc
 1959              		@ args = 0, pretend = 0, frame = 0
 1960              		@ frame_needed = 1, uses_anonymous_args = 0
 1961              		@ link register save eliminated.
 1962 0b48 80B4     		push	{r7}
 1963              	.LCFI51:
 1964              		.cfi_def_cfa_offset 4
 1965              		.cfi_offset 7, -4
 1966 0b4a 00AF     		add	r7, sp, #0
 1967              	.LCFI52:
 1968              		.cfi_def_cfa_register 7
1490:../FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1491:../FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1492:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1493:../FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
 1969              		.loc 1 1493 0
 1970 0b4c 40F20003 		movw	r3, #:lower16:xIdleTaskHandle
 1971 0b50 C0F20003 		movt	r3, #:upper16:xIdleTaskHandle
 1972 0b54 1B68     		ldr	r3, [r3, #0]
1494:../FreeRTOS/Source/tasks.c **** 	}
 1973              		.loc 1 1494 0
 1974 0b56 1846     		mov	r0, r3
 1975 0b58 BD46     		mov	sp, r7
 1976 0b5a 80BC     		pop	{r7}
 1977 0b5c 7047     		bx	lr
 1978              		.cfi_endproc
 1979              	.LFE128:
 1981 0b5e 00BF     		.align	2
 1982              		.global	vTaskIncrementTick
 1983              		.thumb
 1984              		.thumb_func
 1986              	vTaskIncrementTick:
 1987              	.LFB129:
1495:../FreeRTOS/Source/tasks.c **** 	
1496:../FreeRTOS/Source/tasks.c **** #endif
1497:../FreeRTOS/Source/tasks.c **** 
1498:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1499:../FreeRTOS/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1500:../FreeRTOS/Source/tasks.c ****  * documented in task.h
1501:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1502:../FreeRTOS/Source/tasks.c **** 
1503:../FreeRTOS/Source/tasks.c **** void vTaskIncrementTick( void )
1504:../FreeRTOS/Source/tasks.c **** {
 1988              		.loc 1 1504 0
 1989              		.cfi_startproc
 1990              		@ args = 0, pretend = 0, frame = 16
 1991              		@ frame_needed = 1, uses_anonymous_args = 0
 1992 0b60 80B5     		push	{r7, lr}
 1993              	.LCFI53:
 1994              		.cfi_def_cfa_offset 8
 1995              		.cfi_offset 14, -4
 1996              		.cfi_offset 7, -8
 1997 0b62 84B0     		sub	sp, sp, #16
 1998              	.LCFI54:
 1999              		.cfi_def_cfa_offset 24
 2000 0b64 00AF     		add	r7, sp, #0
 2001              	.LCFI55:
 2002              		.cfi_def_cfa_register 7
1505:../FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
1506:../FreeRTOS/Source/tasks.c **** 
1507:../FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1508:../FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1509:../FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1510:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2003              		.loc 1 1510 0
 2004 0b66 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2005 0b6a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2006 0b6e 1B68     		ldr	r3, [r3, #0]
 2007 0b70 002B     		cmp	r3, #0
 2008 0b72 40F0C080 		bne	.L82
1511:../FreeRTOS/Source/tasks.c **** 	{
1512:../FreeRTOS/Source/tasks.c **** 		++xTickCount;
 2009              		.loc 1 1512 0
 2010 0b76 40F20003 		movw	r3, #:lower16:xTickCount
 2011 0b7a C0F20003 		movt	r3, #:upper16:xTickCount
 2012 0b7e 1B68     		ldr	r3, [r3, #0]
 2013 0b80 03F10102 		add	r2, r3, #1
 2014 0b84 40F20003 		movw	r3, #:lower16:xTickCount
 2015 0b88 C0F20003 		movt	r3, #:upper16:xTickCount
 2016 0b8c 1A60     		str	r2, [r3, #0]
1513:../FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 2017              		.loc 1 1513 0
 2018 0b8e 40F20003 		movw	r3, #:lower16:xTickCount
 2019 0b92 C0F20003 		movt	r3, #:upper16:xTickCount
 2020 0b96 1B68     		ldr	r3, [r3, #0]
 2021 0b98 002B     		cmp	r3, #0
 2022 0b9a 40D1     		bne	.L83
 2023              	.LBB4:
1514:../FreeRTOS/Source/tasks.c **** 		{
1515:../FreeRTOS/Source/tasks.c **** 			xList *pxTemp;
1516:../FreeRTOS/Source/tasks.c **** 
1517:../FreeRTOS/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1518:../FreeRTOS/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1519:../FreeRTOS/Source/tasks.c **** 			an error! */
1520:../FreeRTOS/Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1521:../FreeRTOS/Source/tasks.c **** 			
1522:../FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 2024              		.loc 1 1522 0
 2025 0b9c 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2026 0ba0 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2027 0ba4 1B68     		ldr	r3, [r3, #0]
 2028 0ba6 FB60     		str	r3, [r7, #12]
1523:../FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 2029              		.loc 1 1523 0
 2030 0ba8 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2031 0bac C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2032 0bb0 1A68     		ldr	r2, [r3, #0]
 2033 0bb2 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2034 0bb6 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2035 0bba 1A60     		str	r2, [r3, #0]
1524:../FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 2036              		.loc 1 1524 0
 2037 0bbc 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2038 0bc0 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2039 0bc4 FA68     		ldr	r2, [r7, #12]
 2040 0bc6 1A60     		str	r2, [r3, #0]
1525:../FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
 2041              		.loc 1 1525 0
 2042 0bc8 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2043 0bcc C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2044 0bd0 1B68     		ldr	r3, [r3, #0]
 2045 0bd2 03F10102 		add	r2, r3, #1
 2046 0bd6 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2047 0bda C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2048 0bde 1A60     		str	r2, [r3, #0]
1526:../FreeRTOS/Source/tasks.c **** 	
1527:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2049              		.loc 1 1527 0
 2050 0be0 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2051 0be4 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2052 0be8 1B68     		ldr	r3, [r3, #0]
 2053 0bea 1B68     		ldr	r3, [r3, #0]
 2054 0bec 002B     		cmp	r3, #0
 2055 0bee 07D1     		bne	.L84
1528:../FreeRTOS/Source/tasks.c **** 			{
1529:../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1530:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1531:../FreeRTOS/Source/tasks.c **** 				extremely unlikely that the	
1532:../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1533:../FreeRTOS/Source/tasks.c **** 				there is an item in the delayed list. */
1534:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 2056              		.loc 1 1534 0
 2057 0bf0 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2058 0bf4 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2059 0bf8 4FF0FF32 		mov	r2, #-1
 2060 0bfc 1A60     		str	r2, [r3, #0]
 2061 0bfe 0EE0     		b	.L83
 2062              	.L84:
1535:../FreeRTOS/Source/tasks.c **** 			}
1536:../FreeRTOS/Source/tasks.c **** 			else
1537:../FreeRTOS/Source/tasks.c **** 			{
1538:../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1539:../FreeRTOS/Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1540:../FreeRTOS/Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1541:../FreeRTOS/Source/tasks.c **** 				from the Blocked state. */
1542:../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2063              		.loc 1 1542 0
 2064 0c00 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2065 0c04 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2066 0c08 1B68     		ldr	r3, [r3, #0]
 2067 0c0a DB68     		ldr	r3, [r3, #12]
 2068 0c0c DB68     		ldr	r3, [r3, #12]
 2069 0c0e BB60     		str	r3, [r7, #8]
1543:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2070              		.loc 1 1543 0
 2071 0c10 BB68     		ldr	r3, [r7, #8]
 2072 0c12 5A68     		ldr	r2, [r3, #4]
 2073 0c14 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2074 0c18 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2075 0c1c 1A60     		str	r2, [r3, #0]
 2076              	.L83:
 2077              	.LBE4:
 2078              	.LBB5:
1544:../FreeRTOS/Source/tasks.c **** 			}
1545:../FreeRTOS/Source/tasks.c **** 		}
1546:../FreeRTOS/Source/tasks.c **** 
1547:../FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 2079              		.loc 1 1548 0
 2080 0c1e 40F20003 		movw	r3, #:lower16:xTickCount
 2081 0c22 C0F20003 		movt	r3, #:upper16:xTickCount
 2082 0c26 1A68     		ldr	r2, [r3, #0]
 2083 0c28 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2084 0c2c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2085 0c30 1B68     		ldr	r3, [r3, #0]
 2086 0c32 9A42     		cmp	r2, r3
 2087 0c34 6BD3     		bcc	.L81
 2088              	.L90:
 2089              		.loc 1 1548 0 is_stmt 0 discriminator 1
 2090 0c36 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2091 0c3a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2092 0c3e 1B68     		ldr	r3, [r3, #0]
 2093 0c40 1B68     		ldr	r3, [r3, #0]
 2094 0c42 002B     		cmp	r3, #0
 2095 0c44 07D1     		bne	.L86
 2096              		.loc 1 1548 0 discriminator 2
 2097 0c46 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2098 0c4a C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2099 0c4e 4FF0FF32 		mov	r2, #-1
 2100 0c52 1A60     		str	r2, [r3, #0]
 2101 0c54 5BE0     		b	.L81
 2102              	.L86:
 2103              		.loc 1 1548 0 discriminator 3
 2104 0c56 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2105 0c5a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2106 0c5e 1B68     		ldr	r3, [r3, #0]
 2107 0c60 DB68     		ldr	r3, [r3, #12]
 2108 0c62 DB68     		ldr	r3, [r3, #12]
 2109 0c64 BB60     		str	r3, [r7, #8]
 2110 0c66 BB68     		ldr	r3, [r7, #8]
 2111 0c68 5B68     		ldr	r3, [r3, #4]
 2112 0c6a 7B60     		str	r3, [r7, #4]
 2113 0c6c 40F20003 		movw	r3, #:lower16:xTickCount
 2114 0c70 C0F20003 		movt	r3, #:upper16:xTickCount
 2115 0c74 1A68     		ldr	r2, [r3, #0]
 2116 0c76 7B68     		ldr	r3, [r7, #4]
 2117 0c78 9A42     		cmp	r2, r3
 2118 0c7a 06D2     		bcs	.L87
 2119              		.loc 1 1548 0 discriminator 4
 2120 0c7c 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2121 0c80 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2122 0c84 7A68     		ldr	r2, [r7, #4]
 2123 0c86 1A60     		str	r2, [r3, #0]
 2124 0c88 41E0     		b	.L81
 2125              	.L87:
 2126              		.loc 1 1548 0 discriminator 5
 2127 0c8a BB68     		ldr	r3, [r7, #8]
 2128 0c8c 03F10403 		add	r3, r3, #4
 2129 0c90 1846     		mov	r0, r3
 2130 0c92 FFF7FEFF 		bl	vListRemove
 2131 0c96 BB68     		ldr	r3, [r7, #8]
 2132 0c98 9B6A     		ldr	r3, [r3, #40]
 2133 0c9a 002B     		cmp	r3, #0
 2134 0c9c 05D0     		beq	.L88
 2135              		.loc 1 1548 0 discriminator 6
 2136 0c9e BB68     		ldr	r3, [r7, #8]
 2137 0ca0 03F11803 		add	r3, r3, #24
 2138 0ca4 1846     		mov	r0, r3
 2139 0ca6 FFF7FEFF 		bl	vListRemove
 2140              	.L88:
 2141              		.loc 1 1548 0 discriminator 7
 2142 0caa BB68     		ldr	r3, [r7, #8]
 2143 0cac DA6A     		ldr	r2, [r3, #44]
 2144 0cae 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2145 0cb2 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2146 0cb6 1B68     		ldr	r3, [r3, #0]
 2147 0cb8 9A42     		cmp	r2, r3
 2148 0cba 06D9     		bls	.L89
 2149              		.loc 1 1548 0 discriminator 8
 2150 0cbc BB68     		ldr	r3, [r7, #8]
 2151 0cbe DA6A     		ldr	r2, [r3, #44]
 2152 0cc0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2153 0cc4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2154 0cc8 1A60     		str	r2, [r3, #0]
 2155              	.L89:
 2156              		.loc 1 1548 0 discriminator 9
 2157 0cca BB68     		ldr	r3, [r7, #8]
 2158 0ccc DA6A     		ldr	r2, [r3, #44]
 2159 0cce 1346     		mov	r3, r2
 2160 0cd0 4FEA8303 		lsl	r3, r3, #2
 2161 0cd4 9B18     		adds	r3, r3, r2
 2162 0cd6 4FEA8303 		lsl	r3, r3, #2
 2163 0cda 1A46     		mov	r2, r3
 2164 0cdc 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2165 0ce0 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2166 0ce4 D218     		adds	r2, r2, r3
 2167 0ce6 BB68     		ldr	r3, [r7, #8]
 2168 0ce8 03F10403 		add	r3, r3, #4
 2169 0cec 1046     		mov	r0, r2
 2170 0cee 1946     		mov	r1, r3
 2171 0cf0 FFF7FEFF 		bl	vListInsertEnd
 2172 0cf4 9FE7     		b	.L90
 2173              	.L82:
 2174              	.LBE5:
1549:../FreeRTOS/Source/tasks.c **** 	}
1550:../FreeRTOS/Source/tasks.c **** 	else
1551:../FreeRTOS/Source/tasks.c **** 	{
1552:../FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
 2175              		.loc 1 1552 0 is_stmt 1
 2176 0cf6 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2177 0cfa C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2178 0cfe 1B68     		ldr	r3, [r3, #0]
 2179 0d00 03F10102 		add	r2, r3, #1
 2180 0d04 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2181 0d08 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2182 0d0c 1A60     		str	r2, [r3, #0]
 2183              	.L81:
1553:../FreeRTOS/Source/tasks.c **** 
1554:../FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1555:../FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
1556:../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1557:../FreeRTOS/Source/tasks.c **** 		{
1558:../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1559:../FreeRTOS/Source/tasks.c **** 		}
1560:../FreeRTOS/Source/tasks.c **** 		#endif
1561:../FreeRTOS/Source/tasks.c **** 	}
1562:../FreeRTOS/Source/tasks.c **** 
1563:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1564:../FreeRTOS/Source/tasks.c **** 	{
1565:../FreeRTOS/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1566:../FreeRTOS/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1567:../FreeRTOS/Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1568:../FreeRTOS/Source/tasks.c **** 		{
1569:../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1570:../FreeRTOS/Source/tasks.c **** 		}
1571:../FreeRTOS/Source/tasks.c **** 	}
1572:../FreeRTOS/Source/tasks.c **** 	#endif
1573:../FreeRTOS/Source/tasks.c **** 
1574:../FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1575:../FreeRTOS/Source/tasks.c **** }
 2184              		.loc 1 1575 0
 2185 0d0e 07F11007 		add	r7, r7, #16
 2186 0d12 BD46     		mov	sp, r7
 2187 0d14 80BD     		pop	{r7, pc}
 2188              		.cfi_endproc
 2189              	.LFE129:
 2191 0d16 00BF     		.align	2
 2192              		.global	vTaskSetApplicationTaskTag
 2193              		.thumb
 2194              		.thumb_func
 2196              	vTaskSetApplicationTaskTag:
 2197              	.LFB130:
1576:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1577:../FreeRTOS/Source/tasks.c **** 
1578:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1579:../FreeRTOS/Source/tasks.c **** 
1580:../FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1581:../FreeRTOS/Source/tasks.c **** 	{
 2198              		.loc 1 1581 0
 2199              		.cfi_startproc
 2200              		@ args = 0, pretend = 0, frame = 16
 2201              		@ frame_needed = 1, uses_anonymous_args = 0
 2202 0d18 80B5     		push	{r7, lr}
 2203              	.LCFI56:
 2204              		.cfi_def_cfa_offset 8
 2205              		.cfi_offset 14, -4
 2206              		.cfi_offset 7, -8
 2207 0d1a 84B0     		sub	sp, sp, #16
 2208              	.LCFI57:
 2209              		.cfi_def_cfa_offset 24
 2210 0d1c 00AF     		add	r7, sp, #0
 2211              	.LCFI58:
 2212              		.cfi_def_cfa_register 7
 2213 0d1e 7860     		str	r0, [r7, #4]
 2214 0d20 3960     		str	r1, [r7, #0]
1582:../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1583:../FreeRTOS/Source/tasks.c **** 
1584:../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1585:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2215              		.loc 1 1585 0
 2216 0d22 7B68     		ldr	r3, [r7, #4]
 2217 0d24 002B     		cmp	r3, #0
 2218 0d26 06D1     		bne	.L93
1586:../FreeRTOS/Source/tasks.c **** 		{
1587:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2219              		.loc 1 1587 0
 2220 0d28 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2221 0d2c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2222 0d30 1B68     		ldr	r3, [r3, #0]
 2223 0d32 FB60     		str	r3, [r7, #12]
 2224 0d34 01E0     		b	.L94
 2225              	.L93:
1588:../FreeRTOS/Source/tasks.c **** 		}
1589:../FreeRTOS/Source/tasks.c **** 		else
1590:../FreeRTOS/Source/tasks.c **** 		{
1591:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2226              		.loc 1 1591 0
 2227 0d36 7B68     		ldr	r3, [r7, #4]
 2228 0d38 FB60     		str	r3, [r7, #12]
 2229              	.L94:
1592:../FreeRTOS/Source/tasks.c **** 		}
1593:../FreeRTOS/Source/tasks.c **** 
1594:../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1595:../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1596:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2230              		.loc 1 1596 0
 2231 0d3a FFF7FEFF 		bl	vPortEnterCritical
1597:../FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
 2232              		.loc 1 1597 0
 2233 0d3e FB68     		ldr	r3, [r7, #12]
 2234 0d40 3A68     		ldr	r2, [r7, #0]
 2235 0d42 9A64     		str	r2, [r3, #72]
1598:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2236              		.loc 1 1598 0
 2237 0d44 FFF7FEFF 		bl	vPortExitCritical
1599:../FreeRTOS/Source/tasks.c **** 	}
 2238              		.loc 1 1599 0
 2239 0d48 07F11007 		add	r7, r7, #16
 2240 0d4c BD46     		mov	sp, r7
 2241 0d4e 80BD     		pop	{r7, pc}
 2242              		.cfi_endproc
 2243              	.LFE130:
 2245              		.align	2
 2246              		.global	xTaskGetApplicationTaskTag
 2247              		.thumb
 2248              		.thumb_func
 2250              	xTaskGetApplicationTaskTag:
 2251              	.LFB131:
1600:../FreeRTOS/Source/tasks.c **** 
1601:../FreeRTOS/Source/tasks.c **** #endif
1602:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1603:../FreeRTOS/Source/tasks.c **** 
1604:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1605:../FreeRTOS/Source/tasks.c **** 
1606:../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1607:../FreeRTOS/Source/tasks.c **** 	{
 2252              		.loc 1 1607 0
 2253              		.cfi_startproc
 2254              		@ args = 0, pretend = 0, frame = 16
 2255              		@ frame_needed = 1, uses_anonymous_args = 0
 2256 0d50 80B5     		push	{r7, lr}
 2257              	.LCFI59:
 2258              		.cfi_def_cfa_offset 8
 2259              		.cfi_offset 14, -4
 2260              		.cfi_offset 7, -8
 2261 0d52 84B0     		sub	sp, sp, #16
 2262              	.LCFI60:
 2263              		.cfi_def_cfa_offset 24
 2264 0d54 00AF     		add	r7, sp, #0
 2265              	.LCFI61:
 2266              		.cfi_def_cfa_register 7
 2267 0d56 7860     		str	r0, [r7, #4]
1608:../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1609:../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1610:../FreeRTOS/Source/tasks.c **** 
1611:../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1612:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2268              		.loc 1 1612 0
 2269 0d58 7B68     		ldr	r3, [r7, #4]
 2270 0d5a 002B     		cmp	r3, #0
 2271 0d5c 06D1     		bne	.L96
1613:../FreeRTOS/Source/tasks.c **** 		{
1614:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2272              		.loc 1 1614 0
 2273 0d5e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2274 0d62 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2275 0d66 1B68     		ldr	r3, [r3, #0]
 2276 0d68 FB60     		str	r3, [r7, #12]
 2277 0d6a 01E0     		b	.L97
 2278              	.L96:
1615:../FreeRTOS/Source/tasks.c **** 		}
1616:../FreeRTOS/Source/tasks.c **** 		else
1617:../FreeRTOS/Source/tasks.c **** 		{
1618:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2279              		.loc 1 1618 0
 2280 0d6c 7B68     		ldr	r3, [r7, #4]
 2281 0d6e FB60     		str	r3, [r7, #12]
 2282              	.L97:
1619:../FreeRTOS/Source/tasks.c **** 		}
1620:../FreeRTOS/Source/tasks.c **** 
1621:../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1622:../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1623:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2283              		.loc 1 1623 0
 2284 0d70 FFF7FEFF 		bl	vPortEnterCritical
1624:../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
 2285              		.loc 1 1624 0
 2286 0d74 FB68     		ldr	r3, [r7, #12]
 2287 0d76 9B6C     		ldr	r3, [r3, #72]
 2288 0d78 BB60     		str	r3, [r7, #8]
1625:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2289              		.loc 1 1625 0
 2290 0d7a FFF7FEFF 		bl	vPortExitCritical
1626:../FreeRTOS/Source/tasks.c **** 
1627:../FreeRTOS/Source/tasks.c **** 		return xReturn;
 2291              		.loc 1 1627 0
 2292 0d7e BB68     		ldr	r3, [r7, #8]
1628:../FreeRTOS/Source/tasks.c **** 	}
 2293              		.loc 1 1628 0
 2294 0d80 1846     		mov	r0, r3
 2295 0d82 07F11007 		add	r7, r7, #16
 2296 0d86 BD46     		mov	sp, r7
 2297 0d88 80BD     		pop	{r7, pc}
 2298              		.cfi_endproc
 2299              	.LFE131:
 2301 0d8a 00BF     		.align	2
 2302              		.global	xTaskCallApplicationTaskHook
 2303              		.thumb
 2304              		.thumb_func
 2306              	xTaskCallApplicationTaskHook:
 2307              	.LFB132:
1629:../FreeRTOS/Source/tasks.c **** 
1630:../FreeRTOS/Source/tasks.c **** #endif
1631:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1632:../FreeRTOS/Source/tasks.c **** 
1633:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1634:../FreeRTOS/Source/tasks.c **** 
1635:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1636:../FreeRTOS/Source/tasks.c **** 	{
 2308              		.loc 1 1636 0
 2309              		.cfi_startproc
 2310              		@ args = 0, pretend = 0, frame = 16
 2311              		@ frame_needed = 1, uses_anonymous_args = 0
 2312 0d8c 80B5     		push	{r7, lr}
 2313              	.LCFI62:
 2314              		.cfi_def_cfa_offset 8
 2315              		.cfi_offset 14, -4
 2316              		.cfi_offset 7, -8
 2317 0d8e 84B0     		sub	sp, sp, #16
 2318              	.LCFI63:
 2319              		.cfi_def_cfa_offset 24
 2320 0d90 00AF     		add	r7, sp, #0
 2321              	.LCFI64:
 2322              		.cfi_def_cfa_register 7
 2323 0d92 7860     		str	r0, [r7, #4]
 2324 0d94 3960     		str	r1, [r7, #0]
1637:../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1638:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
1639:../FreeRTOS/Source/tasks.c **** 
1640:../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1641:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2325              		.loc 1 1641 0
 2326 0d96 7B68     		ldr	r3, [r7, #4]
 2327 0d98 002B     		cmp	r3, #0
 2328 0d9a 06D1     		bne	.L99
1642:../FreeRTOS/Source/tasks.c **** 		{
1643:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2329              		.loc 1 1643 0
 2330 0d9c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2331 0da0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2332 0da4 1B68     		ldr	r3, [r3, #0]
 2333 0da6 FB60     		str	r3, [r7, #12]
 2334 0da8 01E0     		b	.L100
 2335              	.L99:
1644:../FreeRTOS/Source/tasks.c **** 		}
1645:../FreeRTOS/Source/tasks.c **** 		else
1646:../FreeRTOS/Source/tasks.c **** 		{
1647:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2336              		.loc 1 1647 0
 2337 0daa 7B68     		ldr	r3, [r7, #4]
 2338 0dac FB60     		str	r3, [r7, #12]
 2339              	.L100:
1648:../FreeRTOS/Source/tasks.c **** 		}
1649:../FreeRTOS/Source/tasks.c **** 
1650:../FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
 2340              		.loc 1 1650 0
 2341 0dae FB68     		ldr	r3, [r7, #12]
 2342 0db0 9B6C     		ldr	r3, [r3, #72]
 2343 0db2 002B     		cmp	r3, #0
 2344 0db4 06D0     		beq	.L101
1651:../FreeRTOS/Source/tasks.c **** 		{
1652:../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
 2345              		.loc 1 1652 0
 2346 0db6 FB68     		ldr	r3, [r7, #12]
 2347 0db8 9B6C     		ldr	r3, [r3, #72]
 2348 0dba 3868     		ldr	r0, [r7, #0]
 2349 0dbc 9847     		blx	r3
 2350 0dbe 0346     		mov	r3, r0
 2351 0dc0 BB60     		str	r3, [r7, #8]
 2352 0dc2 02E0     		b	.L102
 2353              	.L101:
1653:../FreeRTOS/Source/tasks.c **** 		}
1654:../FreeRTOS/Source/tasks.c **** 		else
1655:../FreeRTOS/Source/tasks.c **** 		{
1656:../FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
 2354              		.loc 1 1656 0
 2355 0dc4 4FF00003 		mov	r3, #0
 2356 0dc8 BB60     		str	r3, [r7, #8]
 2357              	.L102:
1657:../FreeRTOS/Source/tasks.c **** 		}
1658:../FreeRTOS/Source/tasks.c **** 
1659:../FreeRTOS/Source/tasks.c **** 		return xReturn;
 2358              		.loc 1 1659 0
 2359 0dca BB68     		ldr	r3, [r7, #8]
1660:../FreeRTOS/Source/tasks.c **** 	}
 2360              		.loc 1 1660 0
 2361 0dcc 1846     		mov	r0, r3
 2362 0dce 07F11007 		add	r7, r7, #16
 2363 0dd2 BD46     		mov	sp, r7
 2364 0dd4 80BD     		pop	{r7, pc}
 2365              		.cfi_endproc
 2366              	.LFE132:
 2368 0dd6 00BF     		.align	2
 2369              		.global	vTaskSwitchContext
 2370              		.thumb
 2371              		.thumb_func
 2373              	vTaskSwitchContext:
 2374              	.LFB133:
1661:../FreeRTOS/Source/tasks.c **** 
1662:../FreeRTOS/Source/tasks.c **** #endif
1663:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1664:../FreeRTOS/Source/tasks.c **** 
1665:../FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
1666:../FreeRTOS/Source/tasks.c **** {
 2375              		.loc 1 1666 0
 2376              		.cfi_startproc
 2377              		@ args = 0, pretend = 0, frame = 8
 2378              		@ frame_needed = 1, uses_anonymous_args = 0
 2379 0dd8 80B5     		push	{r7, lr}
 2380              	.LCFI65:
 2381              		.cfi_def_cfa_offset 8
 2382              		.cfi_offset 14, -4
 2383              		.cfi_offset 7, -8
 2384 0dda 82B0     		sub	sp, sp, #8
 2385              	.LCFI66:
 2386              		.cfi_def_cfa_offset 16
 2387 0ddc 00AF     		add	r7, sp, #0
 2388              	.LCFI67:
 2389              		.cfi_def_cfa_register 7
1667:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2390              		.loc 1 1667 0
 2391 0dde 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2392 0de2 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2393 0de6 1B68     		ldr	r3, [r3, #0]
 2394 0de8 002B     		cmp	r3, #0
 2395 0dea 07D0     		beq	.L104
1668:../FreeRTOS/Source/tasks.c **** 	{
1669:../FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1670:../FreeRTOS/Source/tasks.c **** 		switch. */
1671:../FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2396              		.loc 1 1671 0
 2397 0dec 40F20003 		movw	r3, #:lower16:xMissedYield
 2398 0df0 C0F20003 		movt	r3, #:upper16:xMissedYield
 2399 0df4 4FF00102 		mov	r2, #1
 2400 0df8 1A60     		str	r2, [r3, #0]
 2401 0dfa 89E0     		b	.L103
 2402              	.L104:
 2403              	.LBB6:
1672:../FreeRTOS/Source/tasks.c **** 	}
1673:../FreeRTOS/Source/tasks.c **** 	else
1674:../FreeRTOS/Source/tasks.c **** 	{
1675:../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1676:../FreeRTOS/Source/tasks.c **** 	
1677:../FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1678:../FreeRTOS/Source/tasks.c **** 		{
1679:../FreeRTOS/Source/tasks.c **** 			unsigned long ulTempCounter;
1680:../FreeRTOS/Source/tasks.c **** 			
1681:../FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1682:../FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1683:../FreeRTOS/Source/tasks.c **** 				#else
1684:../FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 2404              		.loc 1 1684 0
 2405 0dfc FFF7FEFF 		bl	get_us_time
 2406 0e00 0246     		mov	r2, r0
 2407 0e02 0B46     		mov	r3, r1
 2408 0e04 1346     		mov	r3, r2
 2409 0e06 7B60     		str	r3, [r7, #4]
1685:../FreeRTOS/Source/tasks.c **** 				#endif
1686:../FreeRTOS/Source/tasks.c **** 	
1687:../FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1688:../FreeRTOS/Source/tasks.c **** 				time so far.  The time the task started running was stored in
1689:../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1690:../FreeRTOS/Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1691:../FreeRTOS/Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1692:../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 2410              		.loc 1 1692 0
 2411 0e08 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2412 0e0c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2413 0e10 1A68     		ldr	r2, [r3, #0]
 2414 0e12 D16C     		ldr	r1, [r2, #76]
 2415 0e14 40F20003 		movw	r3, #:lower16:ulTaskSwitchedInTime
 2416 0e18 C0F20003 		movt	r3, #:upper16:ulTaskSwitchedInTime
 2417 0e1c 1B68     		ldr	r3, [r3, #0]
 2418 0e1e 7868     		ldr	r0, [r7, #4]
 2419 0e20 C31A     		subs	r3, r0, r3
 2420 0e22 CB18     		adds	r3, r1, r3
 2421 0e24 D364     		str	r3, [r2, #76]
1693:../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
 2422              		.loc 1 1693 0
 2423 0e26 40F20003 		movw	r3, #:lower16:ulTaskSwitchedInTime
 2424 0e2a C0F20003 		movt	r3, #:upper16:ulTaskSwitchedInTime
 2425 0e2e 7A68     		ldr	r2, [r7, #4]
 2426 0e30 1A60     		str	r2, [r3, #0]
 2427              	.LBE6:
1694:../FreeRTOS/Source/tasks.c **** 		}
1695:../FreeRTOS/Source/tasks.c **** 		#endif
1696:../FreeRTOS/Source/tasks.c **** 	
1697:../FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2428              		.loc 1 1697 0
 2429 0e32 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2430 0e36 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2431 0e3a 1B68     		ldr	r3, [r3, #0]
 2432 0e3c 1A68     		ldr	r2, [r3, #0]
 2433 0e3e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2434 0e42 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2435 0e46 1B68     		ldr	r3, [r3, #0]
 2436 0e48 1B6B     		ldr	r3, [r3, #48]
 2437 0e4a 9A42     		cmp	r2, r3
 2438 0e4c 1DD8     		bhi	.L110
 2439              		.loc 1 1697 0 is_stmt 0 discriminator 1
 2440 0e4e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2441 0e52 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2442 0e56 1A68     		ldr	r2, [r3, #0]
 2443 0e58 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2444 0e5c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2445 0e60 1B68     		ldr	r3, [r3, #0]
 2446 0e62 03F13403 		add	r3, r3, #52
 2447 0e66 1046     		mov	r0, r2
 2448 0e68 1946     		mov	r1, r3
 2449 0e6a FFF7FEFF 		bl	vApplicationStackOverflowHook
1698:../FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1699:../FreeRTOS/Source/tasks.c **** 	
1700:../FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1701:../FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2450              		.loc 1 1701 0 is_stmt 1 discriminator 1
 2451 0e6e 0CE0     		b	.L110
 2452              	.L108:
1702:../FreeRTOS/Source/tasks.c **** 		{
1703:../FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );
1704:../FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;
 2453              		.loc 1 1704 0
 2454 0e70 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2455 0e74 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2456 0e78 1B68     		ldr	r3, [r3, #0]
 2457 0e7a 03F1FF32 		add	r2, r3, #-1
 2458 0e7e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2459 0e82 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2460 0e86 1A60     		str	r2, [r3, #0]
 2461 0e88 00E0     		b	.L107
 2462              	.L110:
1701:../FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2463              		.loc 1 1701 0
 2464 0e8a 00BF     		nop
 2465              	.L107:
1701:../FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2466              		.loc 1 1701 0 is_stmt 0 discriminator 1
 2467 0e8c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2468 0e90 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2469 0e94 1A68     		ldr	r2, [r3, #0]
 2470 0e96 1346     		mov	r3, r2
 2471 0e98 4FEA8303 		lsl	r3, r3, #2
 2472 0e9c 9B18     		adds	r3, r3, r2
 2473 0e9e 4FEA8303 		lsl	r3, r3, #2
 2474 0ea2 1A46     		mov	r2, r3
 2475 0ea4 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2476 0ea8 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2477 0eac D318     		adds	r3, r2, r3
 2478 0eae 1B68     		ldr	r3, [r3, #0]
 2479 0eb0 002B     		cmp	r3, #0
 2480 0eb2 DDD0     		beq	.L108
 2481              	.LBB7:
1705:../FreeRTOS/Source/tasks.c **** 		}
1706:../FreeRTOS/Source/tasks.c **** 	
1707:../FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1708:../FreeRTOS/Source/tasks.c **** 		same priority get an equal share of the processor time. */
1709:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2482              		.loc 1 1709 0 is_stmt 1
 2483 0eb4 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2484 0eb8 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2485 0ebc 1A68     		ldr	r2, [r3, #0]
 2486 0ebe 1346     		mov	r3, r2
 2487 0ec0 4FEA8303 		lsl	r3, r3, #2
 2488 0ec4 9B18     		adds	r3, r3, r2
 2489 0ec6 4FEA8303 		lsl	r3, r3, #2
 2490 0eca 1A46     		mov	r2, r3
 2491 0ecc 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2492 0ed0 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2493 0ed4 D318     		adds	r3, r2, r3
 2494 0ed6 3B60     		str	r3, [r7, #0]
 2495 0ed8 3B68     		ldr	r3, [r7, #0]
 2496 0eda 5B68     		ldr	r3, [r3, #4]
 2497 0edc 5B68     		ldr	r3, [r3, #4]
 2498 0ede 1A46     		mov	r2, r3
 2499 0ee0 3B68     		ldr	r3, [r7, #0]
 2500 0ee2 5A60     		str	r2, [r3, #4]
 2501 0ee4 3B68     		ldr	r3, [r7, #0]
 2502 0ee6 5A68     		ldr	r2, [r3, #4]
 2503 0ee8 3B68     		ldr	r3, [r7, #0]
 2504 0eea 03F10803 		add	r3, r3, #8
 2505 0eee 9A42     		cmp	r2, r3
 2506 0ef0 05D1     		bne	.L109
 2507              		.loc 1 1709 0 is_stmt 0 discriminator 1
 2508 0ef2 3B68     		ldr	r3, [r7, #0]
 2509 0ef4 5B68     		ldr	r3, [r3, #4]
 2510 0ef6 5B68     		ldr	r3, [r3, #4]
 2511 0ef8 1A46     		mov	r2, r3
 2512 0efa 3B68     		ldr	r3, [r7, #0]
 2513 0efc 5A60     		str	r2, [r3, #4]
 2514              	.L109:
 2515              		.loc 1 1709 0 discriminator 2
 2516 0efe 3B68     		ldr	r3, [r7, #0]
 2517 0f00 5B68     		ldr	r3, [r3, #4]
 2518 0f02 DB68     		ldr	r3, [r3, #12]
 2519 0f04 1A46     		mov	r2, r3
 2520 0f06 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2521 0f0a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2522 0f0e 1A60     		str	r2, [r3, #0]
 2523              	.L103:
 2524              	.LBE7:
1710:../FreeRTOS/Source/tasks.c **** 	
1711:../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1712:../FreeRTOS/Source/tasks.c **** 		vWriteTraceToBuffer();
1713:../FreeRTOS/Source/tasks.c **** 	}
1714:../FreeRTOS/Source/tasks.c **** }
 2525              		.loc 1 1714 0 is_stmt 1
 2526 0f10 07F10807 		add	r7, r7, #8
 2527 0f14 BD46     		mov	sp, r7
 2528 0f16 80BD     		pop	{r7, pc}
 2529              		.cfi_endproc
 2530              	.LFE133:
 2532              		.align	2
 2533              		.global	vTaskPlaceOnEventList
 2534              		.thumb
 2535              		.thumb_func
 2537              	vTaskPlaceOnEventList:
 2538              	.LFB134:
1715:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1716:../FreeRTOS/Source/tasks.c **** 
1717:../FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1718:../FreeRTOS/Source/tasks.c **** {
 2539              		.loc 1 1718 0
 2540              		.cfi_startproc
 2541              		@ args = 0, pretend = 0, frame = 16
 2542              		@ frame_needed = 1, uses_anonymous_args = 0
 2543 0f18 80B5     		push	{r7, lr}
 2544              	.LCFI68:
 2545              		.cfi_def_cfa_offset 8
 2546              		.cfi_offset 14, -4
 2547              		.cfi_offset 7, -8
 2548 0f1a 84B0     		sub	sp, sp, #16
 2549              	.LCFI69:
 2550              		.cfi_def_cfa_offset 24
 2551 0f1c 00AF     		add	r7, sp, #0
 2552              	.LCFI70:
 2553              		.cfi_def_cfa_register 7
 2554 0f1e 7860     		str	r0, [r7, #4]
 2555 0f20 3960     		str	r1, [r7, #0]
1719:../FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
1720:../FreeRTOS/Source/tasks.c **** 
1721:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
1722:../FreeRTOS/Source/tasks.c **** 
1723:../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1724:../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1725:../FreeRTOS/Source/tasks.c **** 
1726:../FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1727:../FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1728:../FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event. */
1729:../FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2556              		.loc 1 1729 0
 2557 0f22 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2558 0f26 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2559 0f2a 1B68     		ldr	r3, [r3, #0]
 2560 0f2c 03F11803 		add	r3, r3, #24
 2561 0f30 7868     		ldr	r0, [r7, #4]
 2562 0f32 1946     		mov	r1, r3
 2563 0f34 FFF7FEFF 		bl	vListInsert
1730:../FreeRTOS/Source/tasks.c **** 
1731:../FreeRTOS/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1732:../FreeRTOS/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1733:../FreeRTOS/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1734:../FreeRTOS/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2564              		.loc 1 1734 0
 2565 0f38 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2566 0f3c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2567 0f40 1B68     		ldr	r3, [r3, #0]
 2568 0f42 03F10403 		add	r3, r3, #4
 2569 0f46 1846     		mov	r0, r3
 2570 0f48 FFF7FEFF 		bl	vListRemove
1735:../FreeRTOS/Source/tasks.c **** 
1736:../FreeRTOS/Source/tasks.c **** 
1737:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1738:../FreeRTOS/Source/tasks.c **** 	{
1739:../FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2571              		.loc 1 1739 0
 2572 0f4c 3B68     		ldr	r3, [r7, #0]
 2573 0f4e B3F1FF3F 		cmp	r3, #-1
 2574 0f52 0ED1     		bne	.L112
1740:../FreeRTOS/Source/tasks.c **** 		{
1741:../FreeRTOS/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1742:../FreeRTOS/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1743:../FreeRTOS/Source/tasks.c **** 			indefinitely. */
1744:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2575              		.loc 1 1744 0
 2576 0f54 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2577 0f58 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2578 0f5c 1B68     		ldr	r3, [r3, #0]
 2579 0f5e 03F10403 		add	r3, r3, #4
 2580 0f62 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2581 0f66 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2582 0f6a 1946     		mov	r1, r3
 2583 0f6c FFF7FEFF 		bl	vListInsertEnd
 2584 0f70 0AE0     		b	.L111
 2585              	.L112:
1745:../FreeRTOS/Source/tasks.c **** 		}
1746:../FreeRTOS/Source/tasks.c **** 		else
1747:../FreeRTOS/Source/tasks.c **** 		{
1748:../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1749:../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1750:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2586              		.loc 1 1750 0
 2587 0f72 40F20003 		movw	r3, #:lower16:xTickCount
 2588 0f76 C0F20003 		movt	r3, #:upper16:xTickCount
 2589 0f7a 1A68     		ldr	r2, [r3, #0]
 2590 0f7c 3B68     		ldr	r3, [r7, #0]
 2591 0f7e D318     		adds	r3, r2, r3
 2592 0f80 FB60     		str	r3, [r7, #12]
1751:../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2593              		.loc 1 1751 0
 2594 0f82 F868     		ldr	r0, [r7, #12]
 2595 0f84 00F0D0F9 		bl	prvAddCurrentTaskToDelayedList
 2596              	.L111:
1752:../FreeRTOS/Source/tasks.c **** 		}
1753:../FreeRTOS/Source/tasks.c **** 	}
1754:../FreeRTOS/Source/tasks.c **** 	#else
1755:../FreeRTOS/Source/tasks.c **** 	{
1756:../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1757:../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1758:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1759:../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1760:../FreeRTOS/Source/tasks.c **** 	}
1761:../FreeRTOS/Source/tasks.c **** 	#endif
1762:../FreeRTOS/Source/tasks.c **** }
 2597              		.loc 1 1762 0
 2598 0f88 07F11007 		add	r7, r7, #16
 2599 0f8c BD46     		mov	sp, r7
 2600 0f8e 80BD     		pop	{r7, pc}
 2601              		.cfi_endproc
 2602              	.LFE134:
 2604              		.align	2
 2605              		.global	xTaskRemoveFromEventList
 2606              		.thumb
 2607              		.thumb_func
 2609              	xTaskRemoveFromEventList:
 2610              	.LFB135:
1763:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1764:../FreeRTOS/Source/tasks.c **** 
1765:../FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
1766:../FreeRTOS/Source/tasks.c **** 
1767:../FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1768:../FreeRTOS/Source/tasks.c **** 	{
1769:../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
1770:../FreeRTOS/Source/tasks.c **** 
1771:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
1772:../FreeRTOS/Source/tasks.c **** 
1773:../FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
1774:../FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1775:../FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1776:../FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
1777:../FreeRTOS/Source/tasks.c **** 
1778:../FreeRTOS/Source/tasks.c **** 	
1779:../FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1780:../FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1781:../FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1782:../FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
1783:../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1784:../FreeRTOS/Source/tasks.c **** 
1785:../FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1786:../FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1787:../FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
1788:../FreeRTOS/Source/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1789:../FreeRTOS/Source/tasks.c **** 
1790:../FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1791:../FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1792:../FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1793:../FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1794:../FreeRTOS/Source/tasks.c **** 	}
1795:../FreeRTOS/Source/tasks.c **** 	
1796:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
1797:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1798:../FreeRTOS/Source/tasks.c **** 
1799:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1800:../FreeRTOS/Source/tasks.c **** {
 2611              		.loc 1 1800 0
 2612              		.cfi_startproc
 2613              		@ args = 0, pretend = 0, frame = 16
 2614              		@ frame_needed = 1, uses_anonymous_args = 0
 2615 0f90 80B5     		push	{r7, lr}
 2616              	.LCFI71:
 2617              		.cfi_def_cfa_offset 8
 2618              		.cfi_offset 14, -4
 2619              		.cfi_offset 7, -8
 2620 0f92 84B0     		sub	sp, sp, #16
 2621              	.LCFI72:
 2622              		.cfi_def_cfa_offset 24
 2623 0f94 00AF     		add	r7, sp, #0
 2624              	.LCFI73:
 2625              		.cfi_def_cfa_register 7
 2626 0f96 7860     		str	r0, [r7, #4]
1801:../FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1802:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1803:../FreeRTOS/Source/tasks.c **** 
1804:../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1805:../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1806:../FreeRTOS/Source/tasks.c **** 
1807:../FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1808:../FreeRTOS/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1809:../FreeRTOS/Source/tasks.c **** 	it to the ready list.
1810:../FreeRTOS/Source/tasks.c **** 
1811:../FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1812:../FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1813:../FreeRTOS/Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1814:../FreeRTOS/Source/tasks.c **** 	
1815:../FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1816:../FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
1817:../FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2627              		.loc 1 1817 0
 2628 0f98 7B68     		ldr	r3, [r7, #4]
 2629 0f9a DB68     		ldr	r3, [r3, #12]
 2630 0f9c DB68     		ldr	r3, [r3, #12]
 2631 0f9e BB60     		str	r3, [r7, #8]
1818:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
1819:../FreeRTOS/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2632              		.loc 1 1819 0
 2633 0fa0 BB68     		ldr	r3, [r7, #8]
 2634 0fa2 03F11803 		add	r3, r3, #24
 2635 0fa6 1846     		mov	r0, r3
 2636 0fa8 FFF7FEFF 		bl	vListRemove
1820:../FreeRTOS/Source/tasks.c **** 
1821:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2637              		.loc 1 1821 0
 2638 0fac 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2639 0fb0 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2640 0fb4 1B68     		ldr	r3, [r3, #0]
 2641 0fb6 002B     		cmp	r3, #0
 2642 0fb8 2BD1     		bne	.L115
1822:../FreeRTOS/Source/tasks.c **** 	{
1823:../FreeRTOS/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2643              		.loc 1 1823 0
 2644 0fba BB68     		ldr	r3, [r7, #8]
 2645 0fbc 03F10403 		add	r3, r3, #4
 2646 0fc0 1846     		mov	r0, r3
 2647 0fc2 FFF7FEFF 		bl	vListRemove
1824:../FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2648              		.loc 1 1824 0
 2649 0fc6 BB68     		ldr	r3, [r7, #8]
 2650 0fc8 DA6A     		ldr	r2, [r3, #44]
 2651 0fca 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2652 0fce C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2653 0fd2 1B68     		ldr	r3, [r3, #0]
 2654 0fd4 9A42     		cmp	r2, r3
 2655 0fd6 06D9     		bls	.L116
 2656              		.loc 1 1824 0 is_stmt 0 discriminator 1
 2657 0fd8 BB68     		ldr	r3, [r7, #8]
 2658 0fda DA6A     		ldr	r2, [r3, #44]
 2659 0fdc 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2660 0fe0 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2661 0fe4 1A60     		str	r2, [r3, #0]
 2662              	.L116:
 2663              		.loc 1 1824 0 discriminator 2
 2664 0fe6 BB68     		ldr	r3, [r7, #8]
 2665 0fe8 DA6A     		ldr	r2, [r3, #44]
 2666 0fea 1346     		mov	r3, r2
 2667 0fec 4FEA8303 		lsl	r3, r3, #2
 2668 0ff0 9B18     		adds	r3, r3, r2
 2669 0ff2 4FEA8303 		lsl	r3, r3, #2
 2670 0ff6 1A46     		mov	r2, r3
 2671 0ff8 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2672 0ffc C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2673 1000 D218     		adds	r2, r2, r3
 2674 1002 BB68     		ldr	r3, [r7, #8]
 2675 1004 03F10403 		add	r3, r3, #4
 2676 1008 1046     		mov	r0, r2
 2677 100a 1946     		mov	r1, r3
 2678 100c FFF7FEFF 		bl	vListInsertEnd
 2679 1010 09E0     		b	.L117
 2680              	.L115:
1825:../FreeRTOS/Source/tasks.c **** 	}
1826:../FreeRTOS/Source/tasks.c **** 	else
1827:../FreeRTOS/Source/tasks.c **** 	{
1828:../FreeRTOS/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1829:../FreeRTOS/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1830:../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2681              		.loc 1 1830 0 is_stmt 1
 2682 1012 BB68     		ldr	r3, [r7, #8]
 2683 1014 03F11803 		add	r3, r3, #24
 2684 1018 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2685 101c C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2686 1020 1946     		mov	r1, r3
 2687 1022 FFF7FEFF 		bl	vListInsertEnd
 2688              	.L117:
1831:../FreeRTOS/Source/tasks.c **** 	}
1832:../FreeRTOS/Source/tasks.c **** 
1833:../FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2689              		.loc 1 1833 0
 2690 1026 BB68     		ldr	r3, [r7, #8]
 2691 1028 DA6A     		ldr	r2, [r3, #44]
 2692 102a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2693 102e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2694 1032 1B68     		ldr	r3, [r3, #0]
 2695 1034 DB6A     		ldr	r3, [r3, #44]
 2696 1036 9A42     		cmp	r2, r3
 2697 1038 03D3     		bcc	.L118
1834:../FreeRTOS/Source/tasks.c **** 	{
1835:../FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1836:../FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1837:../FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
1838:../FreeRTOS/Source/tasks.c **** 		switch now. */
1839:../FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2698              		.loc 1 1839 0
 2699 103a 4FF00103 		mov	r3, #1
 2700 103e FB60     		str	r3, [r7, #12]
 2701 1040 02E0     		b	.L119
 2702              	.L118:
1840:../FreeRTOS/Source/tasks.c **** 	}
1841:../FreeRTOS/Source/tasks.c **** 	else
1842:../FreeRTOS/Source/tasks.c **** 	{
1843:../FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2703              		.loc 1 1843 0
 2704 1042 4FF00003 		mov	r3, #0
 2705 1046 FB60     		str	r3, [r7, #12]
 2706              	.L119:
1844:../FreeRTOS/Source/tasks.c **** 	}
1845:../FreeRTOS/Source/tasks.c **** 
1846:../FreeRTOS/Source/tasks.c **** 	return xReturn;
 2707              		.loc 1 1846 0
 2708 1048 FB68     		ldr	r3, [r7, #12]
1847:../FreeRTOS/Source/tasks.c **** }
 2709              		.loc 1 1847 0
 2710 104a 1846     		mov	r0, r3
 2711 104c 07F11007 		add	r7, r7, #16
 2712 1050 BD46     		mov	sp, r7
 2713 1052 80BD     		pop	{r7, pc}
 2714              		.cfi_endproc
 2715              	.LFE135:
 2717              		.align	2
 2718              		.global	vTaskSetTimeOutState
 2719              		.thumb
 2720              		.thumb_func
 2722              	vTaskSetTimeOutState:
 2723              	.LFB136:
1848:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1849:../FreeRTOS/Source/tasks.c **** 
1850:../FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1851:../FreeRTOS/Source/tasks.c **** {
 2724              		.loc 1 1851 0
 2725              		.cfi_startproc
 2726              		@ args = 0, pretend = 0, frame = 8
 2727              		@ frame_needed = 1, uses_anonymous_args = 0
 2728              		@ link register save eliminated.
 2729 1054 80B4     		push	{r7}
 2730              	.LCFI74:
 2731              		.cfi_def_cfa_offset 4
 2732              		.cfi_offset 7, -4
 2733 1056 83B0     		sub	sp, sp, #12
 2734              	.LCFI75:
 2735              		.cfi_def_cfa_offset 16
 2736 1058 00AF     		add	r7, sp, #0
 2737              	.LCFI76:
 2738              		.cfi_def_cfa_register 7
 2739 105a 7860     		str	r0, [r7, #4]
1852:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1853:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2740              		.loc 1 1853 0
 2741 105c 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2742 1060 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2743 1064 1A68     		ldr	r2, [r3, #0]
 2744 1066 7B68     		ldr	r3, [r7, #4]
 2745 1068 1A60     		str	r2, [r3, #0]
1854:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2746              		.loc 1 1854 0
 2747 106a 40F20003 		movw	r3, #:lower16:xTickCount
 2748 106e C0F20003 		movt	r3, #:upper16:xTickCount
 2749 1072 1A68     		ldr	r2, [r3, #0]
 2750 1074 7B68     		ldr	r3, [r7, #4]
 2751 1076 5A60     		str	r2, [r3, #4]
1855:../FreeRTOS/Source/tasks.c **** }
 2752              		.loc 1 1855 0
 2753 1078 07F10C07 		add	r7, r7, #12
 2754 107c BD46     		mov	sp, r7
 2755 107e 80BC     		pop	{r7}
 2756 1080 7047     		bx	lr
 2757              		.cfi_endproc
 2758              	.LFE136:
 2760 1082 00BF     		.align	2
 2761              		.global	xTaskCheckForTimeOut
 2762              		.thumb
 2763              		.thumb_func
 2765              	xTaskCheckForTimeOut:
 2766              	.LFB137:
1856:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1857:../FreeRTOS/Source/tasks.c **** 
1858:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1859:../FreeRTOS/Source/tasks.c **** {
 2767              		.loc 1 1859 0
 2768              		.cfi_startproc
 2769              		@ args = 0, pretend = 0, frame = 16
 2770              		@ frame_needed = 1, uses_anonymous_args = 0
 2771 1084 80B5     		push	{r7, lr}
 2772              	.LCFI77:
 2773              		.cfi_def_cfa_offset 8
 2774              		.cfi_offset 14, -4
 2775              		.cfi_offset 7, -8
 2776 1086 84B0     		sub	sp, sp, #16
 2777              	.LCFI78:
 2778              		.cfi_def_cfa_offset 24
 2779 1088 00AF     		add	r7, sp, #0
 2780              	.LCFI79:
 2781              		.cfi_def_cfa_register 7
 2782 108a 7860     		str	r0, [r7, #4]
 2783 108c 3960     		str	r1, [r7, #0]
1860:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1861:../FreeRTOS/Source/tasks.c **** 
1862:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1863:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
1864:../FreeRTOS/Source/tasks.c **** 
1865:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 2784              		.loc 1 1865 0
 2785 108e FFF7FEFF 		bl	vPortEnterCritical
1866:../FreeRTOS/Source/tasks.c **** 	{
1867:../FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1868:../FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1869:../FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1870:../FreeRTOS/Source/tasks.c **** 			therefore never time out. */
1871:../FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2786              		.loc 1 1871 0
 2787 1092 3B68     		ldr	r3, [r7, #0]
 2788 1094 1B68     		ldr	r3, [r3, #0]
 2789 1096 B3F1FF3F 		cmp	r3, #-1
 2790 109a 03D1     		bne	.L122
1872:../FreeRTOS/Source/tasks.c **** 			{
1873:../FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 2791              		.loc 1 1873 0
 2792 109c 4FF00003 		mov	r3, #0
 2793 10a0 FB60     		str	r3, [r7, #12]
 2794 10a2 38E0     		b	.L123
 2795              	.L122:
1874:../FreeRTOS/Source/tasks.c **** 			}
1875:../FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1876:../FreeRTOS/Source/tasks.c **** 		#endif
1877:../FreeRTOS/Source/tasks.c **** 
1878:../FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2796              		.loc 1 1878 0
 2797 10a4 7B68     		ldr	r3, [r7, #4]
 2798 10a6 1A68     		ldr	r2, [r3, #0]
 2799 10a8 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2800 10ac C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2801 10b0 1B68     		ldr	r3, [r3, #0]
 2802 10b2 9A42     		cmp	r2, r3
 2803 10b4 0CD0     		beq	.L124
 2804              		.loc 1 1878 0 is_stmt 0 discriminator 1
 2805 10b6 7B68     		ldr	r3, [r7, #4]
 2806 10b8 5A68     		ldr	r2, [r3, #4]
 2807 10ba 40F20003 		movw	r3, #:lower16:xTickCount
 2808 10be C0F20003 		movt	r3, #:upper16:xTickCount
 2809 10c2 1B68     		ldr	r3, [r3, #0]
 2810 10c4 9A42     		cmp	r2, r3
 2811 10c6 03D8     		bhi	.L124
1879:../FreeRTOS/Source/tasks.c **** 		{
1880:../FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1881:../FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1882:../FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1883:../FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1884:../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2812              		.loc 1 1884 0 is_stmt 1
 2813 10c8 4FF00103 		mov	r3, #1
 2814 10cc FB60     		str	r3, [r7, #12]
 2815 10ce 22E0     		b	.L123
 2816              	.L124:
1885:../FreeRTOS/Source/tasks.c **** 		}
1886:../FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2817              		.loc 1 1886 0
 2818 10d0 40F20003 		movw	r3, #:lower16:xTickCount
 2819 10d4 C0F20003 		movt	r3, #:upper16:xTickCount
 2820 10d8 1A68     		ldr	r2, [r3, #0]
 2821 10da 7B68     		ldr	r3, [r7, #4]
 2822 10dc 5B68     		ldr	r3, [r3, #4]
 2823 10de D21A     		subs	r2, r2, r3
 2824 10e0 3B68     		ldr	r3, [r7, #0]
 2825 10e2 1B68     		ldr	r3, [r3, #0]
 2826 10e4 9A42     		cmp	r2, r3
 2827 10e6 13D2     		bcs	.L125
1887:../FreeRTOS/Source/tasks.c **** 		{
1888:../FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1889:../FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2828              		.loc 1 1889 0
 2829 10e8 3B68     		ldr	r3, [r7, #0]
 2830 10ea 1A68     		ldr	r2, [r3, #0]
 2831 10ec 7B68     		ldr	r3, [r7, #4]
 2832 10ee 5968     		ldr	r1, [r3, #4]
 2833 10f0 40F20003 		movw	r3, #:lower16:xTickCount
 2834 10f4 C0F20003 		movt	r3, #:upper16:xTickCount
 2835 10f8 1B68     		ldr	r3, [r3, #0]
 2836 10fa CB1A     		subs	r3, r1, r3
 2837 10fc D218     		adds	r2, r2, r3
 2838 10fe 3B68     		ldr	r3, [r7, #0]
 2839 1100 1A60     		str	r2, [r3, #0]
1890:../FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2840              		.loc 1 1890 0
 2841 1102 7868     		ldr	r0, [r7, #4]
 2842 1104 FFF7FEFF 		bl	vTaskSetTimeOutState
1891:../FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2843              		.loc 1 1891 0
 2844 1108 4FF00003 		mov	r3, #0
 2845 110c FB60     		str	r3, [r7, #12]
 2846 110e 02E0     		b	.L123
 2847              	.L125:
1892:../FreeRTOS/Source/tasks.c **** 		}
1893:../FreeRTOS/Source/tasks.c **** 		else
1894:../FreeRTOS/Source/tasks.c **** 		{
1895:../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2848              		.loc 1 1895 0
 2849 1110 4FF00103 		mov	r3, #1
 2850 1114 FB60     		str	r3, [r7, #12]
 2851              	.L123:
1896:../FreeRTOS/Source/tasks.c **** 		}
1897:../FreeRTOS/Source/tasks.c **** 	}
1898:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2852              		.loc 1 1898 0
 2853 1116 FFF7FEFF 		bl	vPortExitCritical
1899:../FreeRTOS/Source/tasks.c **** 
1900:../FreeRTOS/Source/tasks.c **** 	return xReturn;
 2854              		.loc 1 1900 0
 2855 111a FB68     		ldr	r3, [r7, #12]
1901:../FreeRTOS/Source/tasks.c **** }
 2856              		.loc 1 1901 0
 2857 111c 1846     		mov	r0, r3
 2858 111e 07F11007 		add	r7, r7, #16
 2859 1122 BD46     		mov	sp, r7
 2860 1124 80BD     		pop	{r7, pc}
 2861              		.cfi_endproc
 2862              	.LFE137:
 2864 1126 00BF     		.align	2
 2865              		.global	vTaskMissedYield
 2866              		.thumb
 2867              		.thumb_func
 2869              	vTaskMissedYield:
 2870              	.LFB138:
1902:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1903:../FreeRTOS/Source/tasks.c **** 
1904:../FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
1905:../FreeRTOS/Source/tasks.c **** {
 2871              		.loc 1 1905 0
 2872              		.cfi_startproc
 2873              		@ args = 0, pretend = 0, frame = 0
 2874              		@ frame_needed = 1, uses_anonymous_args = 0
 2875              		@ link register save eliminated.
 2876 1128 80B4     		push	{r7}
 2877              	.LCFI80:
 2878              		.cfi_def_cfa_offset 4
 2879              		.cfi_offset 7, -4
 2880 112a 00AF     		add	r7, sp, #0
 2881              	.LCFI81:
 2882              		.cfi_def_cfa_register 7
1906:../FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2883              		.loc 1 1906 0
 2884 112c 40F20003 		movw	r3, #:lower16:xMissedYield
 2885 1130 C0F20003 		movt	r3, #:upper16:xMissedYield
 2886 1134 4FF00102 		mov	r2, #1
 2887 1138 1A60     		str	r2, [r3, #0]
1907:../FreeRTOS/Source/tasks.c **** }
 2888              		.loc 1 1907 0
 2889 113a BD46     		mov	sp, r7
 2890 113c 80BC     		pop	{r7}
 2891 113e 7047     		bx	lr
 2892              		.cfi_endproc
 2893              	.LFE138:
 2895              		.align	2
 2896              		.thumb
 2897              		.thumb_func
 2899              	prvIdleTask:
 2900              	.LFB139:
1908:../FreeRTOS/Source/tasks.c **** 
1909:../FreeRTOS/Source/tasks.c **** /*
1910:../FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
1911:../FreeRTOS/Source/tasks.c ****  * The Idle task.
1912:../FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
1913:../FreeRTOS/Source/tasks.c ****  *
1914:../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1915:../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1916:../FreeRTOS/Source/tasks.c ****  *
1917:../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1918:../FreeRTOS/Source/tasks.c ****  *
1919:../FreeRTOS/Source/tasks.c ****  */
1920:../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1921:../FreeRTOS/Source/tasks.c **** {
 2901              		.loc 1 1921 0
 2902              		.cfi_startproc
 2903              		@ args = 0, pretend = 0, frame = 8
 2904              		@ frame_needed = 1, uses_anonymous_args = 0
 2905 1140 80B5     		push	{r7, lr}
 2906              	.LCFI82:
 2907              		.cfi_def_cfa_offset 8
 2908              		.cfi_offset 14, -4
 2909              		.cfi_offset 7, -8
 2910 1142 82B0     		sub	sp, sp, #8
 2911              	.LCFI83:
 2912              		.cfi_def_cfa_offset 16
 2913 1144 00AF     		add	r7, sp, #0
 2914              	.LCFI84:
 2915              		.cfi_def_cfa_register 7
 2916 1146 7860     		str	r0, [r7, #4]
 2917 1148 00E0     		b	.L129
 2918              	.L130:
1922:../FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
1923:../FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
1924:../FreeRTOS/Source/tasks.c **** 
1925:../FreeRTOS/Source/tasks.c **** 	for( ;; )
1926:../FreeRTOS/Source/tasks.c **** 	{
1927:../FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1928:../FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1929:../FreeRTOS/Source/tasks.c **** 
1930:../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1931:../FreeRTOS/Source/tasks.c **** 		{
1932:../FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1933:../FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
1934:../FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1935:../FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
1936:../FreeRTOS/Source/tasks.c **** 			taskYIELD();
1937:../FreeRTOS/Source/tasks.c **** 		}
1938:../FreeRTOS/Source/tasks.c **** 		#endif
1939:../FreeRTOS/Source/tasks.c **** 
1940:../FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1941:../FreeRTOS/Source/tasks.c **** 		{
1942:../FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1943:../FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1944:../FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1945:../FreeRTOS/Source/tasks.c **** 			timeslice.
1946:../FreeRTOS/Source/tasks.c **** 
1947:../FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1948:../FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1949:../FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1950:../FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1951:../FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1952:../FreeRTOS/Source/tasks.c **** 			{
1953:../FreeRTOS/Source/tasks.c **** 				taskYIELD();
1954:../FreeRTOS/Source/tasks.c **** 			}
1955:../FreeRTOS/Source/tasks.c **** 		}
1956:../FreeRTOS/Source/tasks.c **** 		#endif
1957:../FreeRTOS/Source/tasks.c **** 
1958:../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1959:../FreeRTOS/Source/tasks.c **** 		{
1960:../FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1961:../FreeRTOS/Source/tasks.c **** 
1962:../FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1963:../FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
1964:../FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
1965:../FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1966:../FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1967:../FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
1968:../FreeRTOS/Source/tasks.c **** 		}
1969:../FreeRTOS/Source/tasks.c **** 		#endif
1970:../FreeRTOS/Source/tasks.c **** 	}
 2919              		.loc 1 1970 0
 2920 114a 00BF     		nop
 2921              	.L129:
1928:../FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 2922              		.loc 1 1928 0
 2923 114c 00F0A0F8 		bl	prvCheckTasksWaitingTermination
1951:../FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2924              		.loc 1 1951 0
 2925 1150 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2926 1154 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2927 1158 1B68     		ldr	r3, [r3, #0]
 2928 115a 012B     		cmp	r3, #1
 2929 115c F5D9     		bls	.L130
1953:../FreeRTOS/Source/tasks.c **** 				taskYIELD();
 2930              		.loc 1 1953 0
 2931 115e FFF7FEFF 		bl	vPortYieldFromISR
 2932              		.loc 1 1970 0
 2933 1162 F2E7     		b	.L130
 2934              		.cfi_endproc
 2935              	.LFE139:
 2937              		.align	2
 2938              		.thumb
 2939              		.thumb_func
 2941              	prvInitialiseTCBVariables:
 2942              	.LFB140:
1971:../FreeRTOS/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1972:../FreeRTOS/Source/tasks.c **** 
1973:../FreeRTOS/Source/tasks.c **** 
1974:../FreeRTOS/Source/tasks.c **** 
1975:../FreeRTOS/Source/tasks.c **** 
1976:../FreeRTOS/Source/tasks.c **** 
1977:../FreeRTOS/Source/tasks.c **** 
1978:../FreeRTOS/Source/tasks.c **** 
1979:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1980:../FreeRTOS/Source/tasks.c ****  * File private functions documented at the top of the file.
1981:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1982:../FreeRTOS/Source/tasks.c **** 
1983:../FreeRTOS/Source/tasks.c **** 
1984:../FreeRTOS/Source/tasks.c **** 
1985:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1986:../FreeRTOS/Source/tasks.c **** {
 2943              		.loc 1 1986 0
 2944              		.cfi_startproc
 2945              		@ args = 4, pretend = 0, frame = 16
 2946              		@ frame_needed = 1, uses_anonymous_args = 0
 2947 1164 80B5     		push	{r7, lr}
 2948              	.LCFI85:
 2949              		.cfi_def_cfa_offset 8
 2950              		.cfi_offset 14, -4
 2951              		.cfi_offset 7, -8
 2952 1166 84B0     		sub	sp, sp, #16
 2953              	.LCFI86:
 2954              		.cfi_def_cfa_offset 24
 2955 1168 00AF     		add	r7, sp, #0
 2956              	.LCFI87:
 2957              		.cfi_def_cfa_register 7
 2958 116a F860     		str	r0, [r7, #12]
 2959 116c B960     		str	r1, [r7, #8]
 2960 116e 7A60     		str	r2, [r7, #4]
 2961 1170 3B60     		str	r3, [r7, #0]
1987:../FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
1988:../FreeRTOS/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1989:../FreeRTOS/Source/tasks.c **** 	{
1990:../FreeRTOS/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1991:../FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2962              		.loc 1 1991 0
 2963 1172 FB68     		ldr	r3, [r7, #12]
 2964 1174 03F13403 		add	r3, r3, #52
 2965 1178 1846     		mov	r0, r3
 2966 117a B968     		ldr	r1, [r7, #8]
 2967 117c 4FF01002 		mov	r2, #16
 2968 1180 FFF7FEFF 		bl	strncpy
1992:../FreeRTOS/Source/tasks.c **** 	}
1993:../FreeRTOS/Source/tasks.c **** 	#endif
1994:../FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 2969              		.loc 1 1994 0
 2970 1184 FB68     		ldr	r3, [r7, #12]
 2971 1186 4FF00002 		mov	r2, #0
 2972 118a 83F84320 		strb	r2, [r3, #67]
1995:../FreeRTOS/Source/tasks.c **** 
1996:../FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1997:../FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
1998:../FreeRTOS/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 2973              		.loc 1 1998 0
 2974 118e 7B68     		ldr	r3, [r7, #4]
 2975 1190 092B     		cmp	r3, #9
 2976 1192 02D9     		bls	.L132
1999:../FreeRTOS/Source/tasks.c **** 	{
2000:../FreeRTOS/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 2977              		.loc 1 2000 0
 2978 1194 4FF00903 		mov	r3, #9
 2979 1198 7B60     		str	r3, [r7, #4]
 2980              	.L132:
2001:../FreeRTOS/Source/tasks.c **** 	}
2002:../FreeRTOS/Source/tasks.c **** 
2003:../FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 2981              		.loc 1 2003 0
 2982 119a FB68     		ldr	r3, [r7, #12]
 2983 119c 7A68     		ldr	r2, [r7, #4]
 2984 119e DA62     		str	r2, [r3, #44]
2004:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2005:../FreeRTOS/Source/tasks.c **** 	{
2006:../FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 2985              		.loc 1 2006 0
 2986 11a0 FB68     		ldr	r3, [r7, #12]
 2987 11a2 7A68     		ldr	r2, [r7, #4]
 2988 11a4 5A64     		str	r2, [r3, #68]
2007:../FreeRTOS/Source/tasks.c **** 	}
2008:../FreeRTOS/Source/tasks.c **** 	#endif
2009:../FreeRTOS/Source/tasks.c **** 
2010:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2989              		.loc 1 2010 0
 2990 11a6 FB68     		ldr	r3, [r7, #12]
 2991 11a8 03F10403 		add	r3, r3, #4
 2992 11ac 1846     		mov	r0, r3
 2993 11ae FFF7FEFF 		bl	vListInitialiseItem
2011:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2994              		.loc 1 2011 0
 2995 11b2 FB68     		ldr	r3, [r7, #12]
 2996 11b4 03F11803 		add	r3, r3, #24
 2997 11b8 1846     		mov	r0, r3
 2998 11ba FFF7FEFF 		bl	vListInitialiseItem
2012:../FreeRTOS/Source/tasks.c **** 
2013:../FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2014:../FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2015:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2999              		.loc 1 2015 0
 3000 11be FB68     		ldr	r3, [r7, #12]
 3001 11c0 FA68     		ldr	r2, [r7, #12]
 3002 11c2 1A61     		str	r2, [r3, #16]
2016:../FreeRTOS/Source/tasks.c **** 
2017:../FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2018:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 3003              		.loc 1 2018 0
 3004 11c4 7B68     		ldr	r3, [r7, #4]
 3005 11c6 C3F10A02 		rsb	r2, r3, #10
 3006 11ca FB68     		ldr	r3, [r7, #12]
 3007 11cc 9A61     		str	r2, [r3, #24]
2019:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3008              		.loc 1 2019 0
 3009 11ce FB68     		ldr	r3, [r7, #12]
 3010 11d0 FA68     		ldr	r2, [r7, #12]
 3011 11d2 5A62     		str	r2, [r3, #36]
2020:../FreeRTOS/Source/tasks.c **** 
2021:../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2022:../FreeRTOS/Source/tasks.c **** 	{
2023:../FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2024:../FreeRTOS/Source/tasks.c **** 	}
2025:../FreeRTOS/Source/tasks.c **** 	#endif
2026:../FreeRTOS/Source/tasks.c **** 
2027:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2028:../FreeRTOS/Source/tasks.c **** 	{
2029:../FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
 3012              		.loc 1 2029 0
 3013 11d4 FB68     		ldr	r3, [r7, #12]
 3014 11d6 4FF00002 		mov	r2, #0
 3015 11da 9A64     		str	r2, [r3, #72]
2030:../FreeRTOS/Source/tasks.c **** 	}
2031:../FreeRTOS/Source/tasks.c **** 	#endif
2032:../FreeRTOS/Source/tasks.c **** 
2033:../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2034:../FreeRTOS/Source/tasks.c **** 	{
2035:../FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
 3016              		.loc 1 2035 0
 3017 11dc FB68     		ldr	r3, [r7, #12]
 3018 11de 4FF00002 		mov	r2, #0
 3019 11e2 DA64     		str	r2, [r3, #76]
2036:../FreeRTOS/Source/tasks.c **** 	}
2037:../FreeRTOS/Source/tasks.c **** 	#endif
2038:../FreeRTOS/Source/tasks.c **** 
2039:../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2040:../FreeRTOS/Source/tasks.c **** 	{
2041:../FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2042:../FreeRTOS/Source/tasks.c **** 	}
2043:../FreeRTOS/Source/tasks.c **** 	#else
2044:../FreeRTOS/Source/tasks.c **** 	{
2045:../FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2046:../FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2047:../FreeRTOS/Source/tasks.c **** 	}
2048:../FreeRTOS/Source/tasks.c **** 	#endif
2049:../FreeRTOS/Source/tasks.c **** }
 3020              		.loc 1 2049 0
 3021 11e4 07F11007 		add	r7, r7, #16
 3022 11e8 BD46     		mov	sp, r7
 3023 11ea 80BD     		pop	{r7, pc}
 3024              		.cfi_endproc
 3025              	.LFE140:
 3027              		.align	2
 3028              		.thumb
 3029              		.thumb_func
 3031              	prvInitialiseTaskLists:
 3032              	.LFB141:
2050:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2051:../FreeRTOS/Source/tasks.c **** 
2052:../FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2053:../FreeRTOS/Source/tasks.c **** 
2054:../FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2055:../FreeRTOS/Source/tasks.c **** 	{
2056:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2057:../FreeRTOS/Source/tasks.c **** 	
2058:../FreeRTOS/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2059:../FreeRTOS/Source/tasks.c **** 		{
2060:../FreeRTOS/Source/tasks.c **** 			xTaskToModify = NULL;
2061:../FreeRTOS/Source/tasks.c **** 		}
2062:../FreeRTOS/Source/tasks.c **** 
2063:../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2064:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2065:../FreeRTOS/Source/tasks.c **** 
2066:../FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2067:../FreeRTOS/Source/tasks.c **** 	}
2068:../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
2069:../FreeRTOS/Source/tasks.c **** #endif
2070:../FreeRTOS/Source/tasks.c **** 
2071:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2072:../FreeRTOS/Source/tasks.c **** {
 3033              		.loc 1 2072 0
 3034              		.cfi_startproc
 3035              		@ args = 0, pretend = 0, frame = 8
 3036              		@ frame_needed = 1, uses_anonymous_args = 0
 3037 11ec 80B5     		push	{r7, lr}
 3038              	.LCFI88:
 3039              		.cfi_def_cfa_offset 8
 3040              		.cfi_offset 14, -4
 3041              		.cfi_offset 7, -8
 3042 11ee 82B0     		sub	sp, sp, #8
 3043              	.LCFI89:
 3044              		.cfi_def_cfa_offset 16
 3045 11f0 00AF     		add	r7, sp, #0
 3046              	.LCFI90:
 3047              		.cfi_def_cfa_register 7
2073:../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2074:../FreeRTOS/Source/tasks.c **** 
2075:../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3048              		.loc 1 2075 0
 3049 11f2 4FF00003 		mov	r3, #0
 3050 11f6 7B60     		str	r3, [r7, #4]
 3051 11f8 13E0     		b	.L134
 3052              	.L135:
2076:../FreeRTOS/Source/tasks.c **** 	{
2077:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 3053              		.loc 1 2077 0 discriminator 2
 3054 11fa 7A68     		ldr	r2, [r7, #4]
 3055 11fc 1346     		mov	r3, r2
 3056 11fe 4FEA8303 		lsl	r3, r3, #2
 3057 1202 9B18     		adds	r3, r3, r2
 3058 1204 4FEA8303 		lsl	r3, r3, #2
 3059 1208 1A46     		mov	r2, r3
 3060 120a 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3061 120e C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3062 1212 D318     		adds	r3, r2, r3
 3063 1214 1846     		mov	r0, r3
 3064 1216 FFF7FEFF 		bl	vListInitialise
2075:../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3065              		.loc 1 2075 0 discriminator 2
 3066 121a 7B68     		ldr	r3, [r7, #4]
 3067 121c 03F10103 		add	r3, r3, #1
 3068 1220 7B60     		str	r3, [r7, #4]
 3069              	.L134:
2075:../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3070              		.loc 1 2075 0 is_stmt 0 discriminator 1
 3071 1222 7B68     		ldr	r3, [r7, #4]
 3072 1224 092B     		cmp	r3, #9
 3073 1226 E8D9     		bls	.L135
2078:../FreeRTOS/Source/tasks.c **** 	}
2079:../FreeRTOS/Source/tasks.c **** 
2080:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 3074              		.loc 1 2080 0 is_stmt 1
 3075 1228 40F20000 		movw	r0, #:lower16:xDelayedTaskList1
 3076 122c C0F20000 		movt	r0, #:upper16:xDelayedTaskList1
 3077 1230 FFF7FEFF 		bl	vListInitialise
2081:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 3078              		.loc 1 2081 0
 3079 1234 40F20000 		movw	r0, #:lower16:xDelayedTaskList2
 3080 1238 C0F20000 		movt	r0, #:upper16:xDelayedTaskList2
 3081 123c FFF7FEFF 		bl	vListInitialise
2082:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 3082              		.loc 1 2082 0
 3083 1240 40F20000 		movw	r0, #:lower16:xPendingReadyList
 3084 1244 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 3085 1248 FFF7FEFF 		bl	vListInitialise
2083:../FreeRTOS/Source/tasks.c **** 
2084:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2085:../FreeRTOS/Source/tasks.c **** 	{
2086:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 3086              		.loc 1 2086 0
 3087 124c 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 3088 1250 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 3089 1254 FFF7FEFF 		bl	vListInitialise
2087:../FreeRTOS/Source/tasks.c **** 	}
2088:../FreeRTOS/Source/tasks.c **** 	#endif
2089:../FreeRTOS/Source/tasks.c **** 
2090:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2091:../FreeRTOS/Source/tasks.c **** 	{
2092:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 3090              		.loc 1 2092 0
 3091 1258 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 3092 125c C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 3093 1260 FFF7FEFF 		bl	vListInitialise
2093:../FreeRTOS/Source/tasks.c **** 	}
2094:../FreeRTOS/Source/tasks.c **** 	#endif
2095:../FreeRTOS/Source/tasks.c **** 
2096:../FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2097:../FreeRTOS/Source/tasks.c **** 	using list2. */
2098:../FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3094              		.loc 1 2098 0
 3095 1264 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3096 1268 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3097 126c 40F20002 		movw	r2, #:lower16:xDelayedTaskList1
 3098 1270 C0F20002 		movt	r2, #:upper16:xDelayedTaskList1
 3099 1274 1A60     		str	r2, [r3, #0]
2099:../FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3100              		.loc 1 2099 0
 3101 1276 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3102 127a C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3103 127e 40F20002 		movw	r2, #:lower16:xDelayedTaskList2
 3104 1282 C0F20002 		movt	r2, #:upper16:xDelayedTaskList2
 3105 1286 1A60     		str	r2, [r3, #0]
2100:../FreeRTOS/Source/tasks.c **** }
 3106              		.loc 1 2100 0
 3107 1288 07F10807 		add	r7, r7, #8
 3108 128c BD46     		mov	sp, r7
 3109 128e 80BD     		pop	{r7, pc}
 3110              		.cfi_endproc
 3111              	.LFE141:
 3113              		.align	2
 3114              		.thumb
 3115              		.thumb_func
 3117              	prvCheckTasksWaitingTermination:
 3118              	.LFB142:
2101:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2102:../FreeRTOS/Source/tasks.c **** 
2103:../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2104:../FreeRTOS/Source/tasks.c **** {
 3119              		.loc 1 2104 0
 3120              		.cfi_startproc
 3121              		@ args = 0, pretend = 0, frame = 8
 3122              		@ frame_needed = 1, uses_anonymous_args = 0
 3123 1290 80B5     		push	{r7, lr}
 3124              	.LCFI91:
 3125              		.cfi_def_cfa_offset 8
 3126              		.cfi_offset 14, -4
 3127              		.cfi_offset 7, -8
 3128 1292 82B0     		sub	sp, sp, #8
 3129              	.LCFI92:
 3130              		.cfi_def_cfa_offset 16
 3131 1294 00AF     		add	r7, sp, #0
 3132              	.LCFI93:
 3133              		.cfi_def_cfa_register 7
 3134              	.LBB8:
2105:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2106:../FreeRTOS/Source/tasks.c **** 	{
2107:../FreeRTOS/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2108:../FreeRTOS/Source/tasks.c **** 
2109:../FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2110:../FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2111:../FreeRTOS/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3135              		.loc 1 2111 0
 3136 1296 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3137 129a C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3138 129e 1B68     		ldr	r3, [r3, #0]
 3139 12a0 002B     		cmp	r3, #0
 3140 12a2 3CD0     		beq	.L136
2112:../FreeRTOS/Source/tasks.c **** 		{
2113:../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 3141              		.loc 1 2113 0
 3142 12a4 FFF7FEFF 		bl	vTaskSuspendAll
2114:../FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3143              		.loc 1 2114 0
 3144 12a8 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3145 12ac C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3146 12b0 1B68     		ldr	r3, [r3, #0]
 3147 12b2 002B     		cmp	r3, #0
 3148 12b4 14BF     		ite	ne
 3149 12b6 0023     		movne	r3, #0
 3150 12b8 0123     		moveq	r3, #1
 3151 12ba 7B60     		str	r3, [r7, #4]
2115:../FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
 3152              		.loc 1 2115 0
 3153 12bc FFF7FEFF 		bl	xTaskResumeAll
2116:../FreeRTOS/Source/tasks.c **** 
2117:../FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3154              		.loc 1 2117 0
 3155 12c0 7B68     		ldr	r3, [r7, #4]
 3156 12c2 002B     		cmp	r3, #0
 3157 12c4 2BD1     		bne	.L136
 3158              	.LBB9:
2118:../FreeRTOS/Source/tasks.c **** 			{
2119:../FreeRTOS/Source/tasks.c **** 				tskTCB *pxTCB;
2120:../FreeRTOS/Source/tasks.c **** 
2121:../FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 3159              		.loc 1 2121 0
 3160 12c6 FFF7FEFF 		bl	vPortEnterCritical
2122:../FreeRTOS/Source/tasks.c **** 				{
2123:../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 3161              		.loc 1 2123 0
 3162 12ca 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3163 12ce C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3164 12d2 DB68     		ldr	r3, [r3, #12]
 3165 12d4 DB68     		ldr	r3, [r3, #12]
 3166 12d6 3B60     		str	r3, [r7, #0]
2124:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 3167              		.loc 1 2124 0
 3168 12d8 3B68     		ldr	r3, [r7, #0]
 3169 12da 03F10403 		add	r3, r3, #4
 3170 12de 1846     		mov	r0, r3
 3171 12e0 FFF7FEFF 		bl	vListRemove
2125:../FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3172              		.loc 1 2125 0
 3173 12e4 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3174 12e8 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3175 12ec 1B68     		ldr	r3, [r3, #0]
 3176 12ee 03F1FF32 		add	r2, r3, #-1
 3177 12f2 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3178 12f6 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3179 12fa 1A60     		str	r2, [r3, #0]
2126:../FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 3180              		.loc 1 2126 0
 3181 12fc 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3182 1300 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3183 1304 1B68     		ldr	r3, [r3, #0]
 3184 1306 03F1FF32 		add	r2, r3, #-1
 3185 130a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3186 130e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3187 1312 1A60     		str	r2, [r3, #0]
2127:../FreeRTOS/Source/tasks.c **** 				}
2128:../FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 3188              		.loc 1 2128 0
 3189 1314 FFF7FEFF 		bl	vPortExitCritical
2129:../FreeRTOS/Source/tasks.c **** 
2130:../FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3190              		.loc 1 2130 0
 3191 1318 3868     		ldr	r0, [r7, #0]
 3192 131a 00F07DF9 		bl	prvDeleteTCB
 3193              	.L136:
 3194              	.LBE9:
 3195              	.LBE8:
2131:../FreeRTOS/Source/tasks.c **** 			}
2132:../FreeRTOS/Source/tasks.c **** 		}
2133:../FreeRTOS/Source/tasks.c **** 	}
2134:../FreeRTOS/Source/tasks.c **** 	#endif
2135:../FreeRTOS/Source/tasks.c **** }
 3196              		.loc 1 2135 0
 3197 131e 07F10807 		add	r7, r7, #8
 3198 1322 BD46     		mov	sp, r7
 3199 1324 80BD     		pop	{r7, pc}
 3200              		.cfi_endproc
 3201              	.LFE142:
 3203 1326 00BF     		.align	2
 3204              		.thumb
 3205              		.thumb_func
 3207              	prvAddCurrentTaskToDelayedList:
 3208              	.LFB143:
2136:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2137:../FreeRTOS/Source/tasks.c **** 
2138:../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2139:../FreeRTOS/Source/tasks.c **** {
 3209              		.loc 1 2139 0
 3210              		.cfi_startproc
 3211              		@ args = 0, pretend = 0, frame = 8
 3212              		@ frame_needed = 1, uses_anonymous_args = 0
 3213 1328 80B5     		push	{r7, lr}
 3214              	.LCFI94:
 3215              		.cfi_def_cfa_offset 8
 3216              		.cfi_offset 14, -4
 3217              		.cfi_offset 7, -8
 3218 132a 82B0     		sub	sp, sp, #8
 3219              	.LCFI95:
 3220              		.cfi_def_cfa_offset 16
 3221 132c 00AF     		add	r7, sp, #0
 3222              	.LCFI96:
 3223              		.cfi_def_cfa_register 7
 3224 132e 7860     		str	r0, [r7, #4]
2140:../FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2141:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3225              		.loc 1 2141 0
 3226 1330 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3227 1334 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3228 1338 1B68     		ldr	r3, [r3, #0]
 3229 133a 7A68     		ldr	r2, [r7, #4]
 3230 133c 5A60     		str	r2, [r3, #4]
2142:../FreeRTOS/Source/tasks.c **** 
2143:../FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3231              		.loc 1 2143 0
 3232 133e 40F20003 		movw	r3, #:lower16:xTickCount
 3233 1342 C0F20003 		movt	r3, #:upper16:xTickCount
 3234 1346 1B68     		ldr	r3, [r3, #0]
 3235 1348 7A68     		ldr	r2, [r7, #4]
 3236 134a 9A42     		cmp	r2, r3
 3237 134c 10D2     		bcs	.L139
2144:../FreeRTOS/Source/tasks.c **** 	{
2145:../FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2146:../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3238              		.loc 1 2146 0
 3239 134e 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3240 1352 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3241 1356 1A68     		ldr	r2, [r3, #0]
 3242 1358 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3243 135c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3244 1360 1B68     		ldr	r3, [r3, #0]
 3245 1362 03F10403 		add	r3, r3, #4
 3246 1366 1046     		mov	r0, r2
 3247 1368 1946     		mov	r1, r3
 3248 136a FFF7FEFF 		bl	vListInsert
 3249 136e 1DE0     		b	.L138
 3250              	.L139:
2147:../FreeRTOS/Source/tasks.c **** 	}
2148:../FreeRTOS/Source/tasks.c **** 	else
2149:../FreeRTOS/Source/tasks.c **** 	{
2150:../FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2151:../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3251              		.loc 1 2151 0
 3252 1370 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3253 1374 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3254 1378 1A68     		ldr	r2, [r3, #0]
 3255 137a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3256 137e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3257 1382 1B68     		ldr	r3, [r3, #0]
 3258 1384 03F10403 		add	r3, r3, #4
 3259 1388 1046     		mov	r0, r2
 3260 138a 1946     		mov	r1, r3
 3261 138c FFF7FEFF 		bl	vListInsert
2152:../FreeRTOS/Source/tasks.c **** 
2153:../FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2154:../FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2155:../FreeRTOS/Source/tasks.c **** 		too. */
2156:../FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3262              		.loc 1 2156 0
 3263 1390 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3264 1394 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3265 1398 1B68     		ldr	r3, [r3, #0]
 3266 139a 7A68     		ldr	r2, [r7, #4]
 3267 139c 9A42     		cmp	r2, r3
 3268 139e 05D2     		bcs	.L138
2157:../FreeRTOS/Source/tasks.c **** 		{
2158:../FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3269              		.loc 1 2158 0
 3270 13a0 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3271 13a4 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3272 13a8 7A68     		ldr	r2, [r7, #4]
 3273 13aa 1A60     		str	r2, [r3, #0]
 3274              	.L138:
2159:../FreeRTOS/Source/tasks.c **** 		}
2160:../FreeRTOS/Source/tasks.c **** 	}
2161:../FreeRTOS/Source/tasks.c **** }
 3275              		.loc 1 2161 0
 3276 13ac 07F10807 		add	r7, r7, #8
 3277 13b0 BD46     		mov	sp, r7
 3278 13b2 80BD     		pop	{r7, pc}
 3279              		.cfi_endproc
 3280              	.LFE143:
 3282              		.align	2
 3283              		.thumb
 3284              		.thumb_func
 3286              	prvAllocateTCBAndStack:
 3287              	.LFB144:
2162:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2163:../FreeRTOS/Source/tasks.c **** 
2164:../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2165:../FreeRTOS/Source/tasks.c **** {
 3288              		.loc 1 2165 0
 3289              		.cfi_startproc
 3290              		@ args = 0, pretend = 0, frame = 16
 3291              		@ frame_needed = 1, uses_anonymous_args = 0
 3292 13b4 80B5     		push	{r7, lr}
 3293              	.LCFI97:
 3294              		.cfi_def_cfa_offset 8
 3295              		.cfi_offset 14, -4
 3296              		.cfi_offset 7, -8
 3297 13b6 84B0     		sub	sp, sp, #16
 3298              	.LCFI98:
 3299              		.cfi_def_cfa_offset 24
 3300 13b8 00AF     		add	r7, sp, #0
 3301              	.LCFI99:
 3302              		.cfi_def_cfa_register 7
 3303 13ba 0346     		mov	r3, r0
 3304 13bc 3960     		str	r1, [r7, #0]
 3305 13be FB80     		strh	r3, [r7, #6]	@ movhi
2166:../FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
2167:../FreeRTOS/Source/tasks.c **** 
2168:../FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2169:../FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2170:../FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3306              		.loc 1 2170 0
 3307 13c0 4FF05000 		mov	r0, #80
 3308 13c4 FFF7FEFF 		bl	malloc
 3309 13c8 0346     		mov	r3, r0
 3310 13ca FB60     		str	r3, [r7, #12]
2171:../FreeRTOS/Source/tasks.c **** 
2172:../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 3311              		.loc 1 2172 0
 3312 13cc FB68     		ldr	r3, [r7, #12]
 3313 13ce 002B     		cmp	r3, #0
 3314 13d0 23D0     		beq	.L142
2173:../FreeRTOS/Source/tasks.c **** 	{
2174:../FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2175:../FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2176:../FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2177:../FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3315              		.loc 1 2177 0
 3316 13d2 3B68     		ldr	r3, [r7, #0]
 3317 13d4 002B     		cmp	r3, #0
 3318 13d6 07D1     		bne	.L143
 3319              		.loc 1 2177 0 is_stmt 0 discriminator 1
 3320 13d8 FB88     		ldrh	r3, [r7, #6]
 3321 13da 4FEA8303 		lsl	r3, r3, #2
 3322 13de 1846     		mov	r0, r3
 3323 13e0 FFF7FEFF 		bl	malloc
 3324 13e4 0346     		mov	r3, r0
 3325 13e6 00E0     		b	.L144
 3326              	.L143:
 3327              		.loc 1 2177 0 discriminator 2
 3328 13e8 3B68     		ldr	r3, [r7, #0]
 3329              	.L144:
 3330              		.loc 1 2177 0 discriminator 3
 3331 13ea FA68     		ldr	r2, [r7, #12]
 3332 13ec 1363     		str	r3, [r2, #48]
2178:../FreeRTOS/Source/tasks.c **** 
2179:../FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3333              		.loc 1 2179 0 is_stmt 1 discriminator 3
 3334 13ee FB68     		ldr	r3, [r7, #12]
 3335 13f0 1B6B     		ldr	r3, [r3, #48]
 3336 13f2 002B     		cmp	r3, #0
 3337 13f4 06D1     		bne	.L145
2180:../FreeRTOS/Source/tasks.c **** 		{
2181:../FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2182:../FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 3338              		.loc 1 2182 0
 3339 13f6 F868     		ldr	r0, [r7, #12]
 3340 13f8 FFF7FEFF 		bl	free
2183:../FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 3341              		.loc 1 2183 0
 3342 13fc 4FF00003 		mov	r3, #0
 3343 1400 FB60     		str	r3, [r7, #12]
 3344 1402 0AE0     		b	.L142
 3345              	.L145:
2184:../FreeRTOS/Source/tasks.c **** 		}
2185:../FreeRTOS/Source/tasks.c **** 		else
2186:../FreeRTOS/Source/tasks.c **** 		{
2187:../FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
2188:../FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3346              		.loc 1 2188 0
 3347 1404 FB68     		ldr	r3, [r7, #12]
 3348 1406 1A6B     		ldr	r2, [r3, #48]
 3349 1408 FB88     		ldrh	r3, [r7, #6]
 3350 140a 4FEA8303 		lsl	r3, r3, #2
 3351 140e 1046     		mov	r0, r2
 3352 1410 4FF0A501 		mov	r1, #165
 3353 1414 1A46     		mov	r2, r3
 3354 1416 FFF7FEFF 		bl	memset
 3355              	.L142:
2189:../FreeRTOS/Source/tasks.c **** 		}
2190:../FreeRTOS/Source/tasks.c **** 	}
2191:../FreeRTOS/Source/tasks.c **** 
2192:../FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
 3356              		.loc 1 2192 0
 3357 141a FB68     		ldr	r3, [r7, #12]
2193:../FreeRTOS/Source/tasks.c **** }
 3358              		.loc 1 2193 0
 3359 141c 1846     		mov	r0, r3
 3360 141e 07F11007 		add	r7, r7, #16
 3361 1422 BD46     		mov	sp, r7
 3362 1424 80BD     		pop	{r7, pc}
 3363              		.cfi_endproc
 3364              	.LFE144:
 3366              		.section	.rodata
 3367 000b 00       		.align	2
 3368              	.LC2:
 3369 000c 25752020 		.ascii	"%u  %c  %-16s          0   0%%  %5u\015\012\000"
 3369      25632020 
 3369      252D3136 
 3369      73202020 
 3369      20202020 
 3370 0032 0000     		.align	2
 3371              	.LC3:
 3372 0034 25752020 		.ascii	"%u  %c  %-16s %10u %3u%%  %5u\015\012\000"
 3372      25632020 
 3372      252D3136 
 3372      73202531 
 3372      30752025 
 3373              		.align	2
 3374              	.LC4:
 3375 0054 25752020 		.ascii	"%u  %c  %-16s %10u  <1%%  %5u\015\012\000"
 3375      25632020 
 3375      252D3136 
 3375      73202531 
 3375      30752020 
 3376              		.text
 3377 1426 00BF     		.align	2
 3378              		.thumb
 3379              		.thumb_func
 3381              	prvGenerateRunTimeStatsForTasksInList:
 3382              	.LFB145:
2194:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2195:../FreeRTOS/Source/tasks.c **** 
2196:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2197:../FreeRTOS/Source/tasks.c **** 
2198:../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2199:../FreeRTOS/Source/tasks.c **** 	{
2200:../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2201:../FreeRTOS/Source/tasks.c **** 	unsigned short usStackRemaining;
2202:../FreeRTOS/Source/tasks.c **** 
2203:../FreeRTOS/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2204:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2205:../FreeRTOS/Source/tasks.c **** 		do
2206:../FreeRTOS/Source/tasks.c **** 		{
2207:../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2208:../FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2209:../FreeRTOS/Source/tasks.c **** 			{
2210:../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2211:../FreeRTOS/Source/tasks.c **** 			}
2212:../FreeRTOS/Source/tasks.c **** 			#else
2213:../FreeRTOS/Source/tasks.c **** 			{
2214:../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2215:../FreeRTOS/Source/tasks.c **** 			}
2216:../FreeRTOS/Source/tasks.c **** 			#endif			
2217:../FreeRTOS/Source/tasks.c **** 			
2218:../FreeRTOS/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2219:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2220:../FreeRTOS/Source/tasks.c **** 
2221:../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2222:../FreeRTOS/Source/tasks.c **** 	}
2223:../FreeRTOS/Source/tasks.c **** 
2224:../FreeRTOS/Source/tasks.c **** #endif
2225:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2226:../FreeRTOS/Source/tasks.c **** 
2227:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2228:../FreeRTOS/Source/tasks.c **** 
2229:../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2230:../FreeRTOS/Source/tasks.c **** 	{
 3383              		.loc 1 2230 0
 3384              		.cfi_startproc
 3385              		@ args = 0, pretend = 0, frame = 40
 3386              		@ frame_needed = 1, uses_anonymous_args = 0
 3387 1428 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3388              	.LCFI100:
 3389              		.cfi_def_cfa_offset 24
 3390              		.cfi_offset 14, -4
 3391              		.cfi_offset 8, -8
 3392              		.cfi_offset 7, -12
 3393              		.cfi_offset 6, -16
 3394              		.cfi_offset 5, -20
 3395              		.cfi_offset 4, -24
 3396 142c 8EB0     		sub	sp, sp, #56
 3397              	.LCFI101:
 3398              		.cfi_def_cfa_offset 80
 3399 142e 04AF     		add	r7, sp, #16
 3400              	.LCFI102:
 3401              		.cfi_def_cfa 7, 64
 3402 1430 F860     		str	r0, [r7, #12]
 3403 1432 B960     		str	r1, [r7, #8]
 3404 1434 7A60     		str	r2, [r7, #4]
 3405 1436 FB70     		strb	r3, [r7, #3]
 3406              	.LBB10:
2231:../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2232:../FreeRTOS/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2233:../FreeRTOS/Source/tasks.c **** 
2234:../FreeRTOS/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2235:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 3407              		.loc 1 2235 0
 3408 1438 BB68     		ldr	r3, [r7, #8]
 3409 143a 7B62     		str	r3, [r7, #36]
 3410 143c 7B6A     		ldr	r3, [r7, #36]
 3411 143e 5B68     		ldr	r3, [r3, #4]
 3412 1440 5B68     		ldr	r3, [r3, #4]
 3413 1442 1A46     		mov	r2, r3
 3414 1444 7B6A     		ldr	r3, [r7, #36]
 3415 1446 5A60     		str	r2, [r3, #4]
 3416 1448 7B6A     		ldr	r3, [r7, #36]
 3417 144a 5A68     		ldr	r2, [r3, #4]
 3418 144c 7B6A     		ldr	r3, [r7, #36]
 3419 144e 03F10803 		add	r3, r3, #8
 3420 1452 9A42     		cmp	r2, r3
 3421 1454 05D1     		bne	.L147
 3422              		.loc 1 2235 0 is_stmt 0 discriminator 1
 3423 1456 7B6A     		ldr	r3, [r7, #36]
 3424 1458 5B68     		ldr	r3, [r3, #4]
 3425 145a 5B68     		ldr	r3, [r3, #4]
 3426 145c 1A46     		mov	r2, r3
 3427 145e 7B6A     		ldr	r3, [r7, #36]
 3428 1460 5A60     		str	r2, [r3, #4]
 3429              	.L147:
 3430              		.loc 1 2235 0 discriminator 2
 3431 1462 7B6A     		ldr	r3, [r7, #36]
 3432 1464 5B68     		ldr	r3, [r3, #4]
 3433 1466 DB68     		ldr	r3, [r3, #12]
 3434 1468 3B62     		str	r3, [r7, #32]
 3435              	.L153:
 3436              	.LBE10:
 3437              	.LBB11:
2236:../FreeRTOS/Source/tasks.c **** 		do
2237:../FreeRTOS/Source/tasks.c **** 		{
2238:../FreeRTOS/Source/tasks.c **** 			/* Get next TCB in from the list. */
2239:../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 3438              		.loc 1 2239 0 is_stmt 1
 3439 146a BB68     		ldr	r3, [r7, #8]
 3440 146c FB61     		str	r3, [r7, #28]
 3441 146e FB69     		ldr	r3, [r7, #28]
 3442 1470 5B68     		ldr	r3, [r3, #4]
 3443 1472 5B68     		ldr	r3, [r3, #4]
 3444 1474 1A46     		mov	r2, r3
 3445 1476 FB69     		ldr	r3, [r7, #28]
 3446 1478 5A60     		str	r2, [r3, #4]
 3447 147a FB69     		ldr	r3, [r7, #28]
 3448 147c 5A68     		ldr	r2, [r3, #4]
 3449 147e FB69     		ldr	r3, [r7, #28]
 3450 1480 03F10803 		add	r3, r3, #8
 3451 1484 9A42     		cmp	r2, r3
 3452 1486 05D1     		bne	.L148
 3453              		.loc 1 2239 0 is_stmt 0 discriminator 1
 3454 1488 FB69     		ldr	r3, [r7, #28]
 3455 148a 5B68     		ldr	r3, [r3, #4]
 3456 148c 5B68     		ldr	r3, [r3, #4]
 3457 148e 1A46     		mov	r2, r3
 3458 1490 FB69     		ldr	r3, [r7, #28]
 3459 1492 5A60     		str	r2, [r3, #4]
 3460              	.L148:
 3461              		.loc 1 2239 0 discriminator 2
 3462 1494 FB69     		ldr	r3, [r7, #28]
 3463 1496 5B68     		ldr	r3, [r3, #4]
 3464 1498 DB68     		ldr	r3, [r3, #12]
 3465 149a BB61     		str	r3, [r7, #24]
 3466              	.LBE11:
2240:../FreeRTOS/Source/tasks.c **** 
2241:../FreeRTOS/Source/tasks.c **** 			/* Divide by zero check. */
2242:../FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
 3467              		.loc 1 2242 0 is_stmt 1 discriminator 2
 3468 149c 7B68     		ldr	r3, [r7, #4]
 3469 149e 002B     		cmp	r3, #0
 3470 14a0 76D0     		beq	.L149
2243:../FreeRTOS/Source/tasks.c **** 			{
2244:../FreeRTOS/Source/tasks.c **** 				/* Has the task run at all? */
2245:../FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
 3471              		.loc 1 2245 0
 3472 14a2 BB69     		ldr	r3, [r7, #24]
 3473 14a4 DB6C     		ldr	r3, [r3, #76]
 3474 14a6 002B     		cmp	r3, #0
 3475 14a8 1CD1     		bne	.L150
2246:../FreeRTOS/Source/tasks.c **** 				{
2247:../FreeRTOS/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2248:../FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%u  %c  %-16s          0   0%%  %5u\r\n", (unsigned int) p
 3476              		.loc 1 2248 0
 3477 14aa BB69     		ldr	r3, [r7, #24]
 3478 14ac DB6A     		ldr	r3, [r3, #44]
 3479 14ae 1D46     		mov	r5, r3
 3480 14b0 97F90340 		ldrsb	r4, [r7, #3]
 3481 14b4 BB69     		ldr	r3, [r7, #24]
 3482 14b6 03F13406 		add	r6, r3, #52
 3483 14ba BB69     		ldr	r3, [r7, #24]
 3484 14bc 1B6B     		ldr	r3, [r3, #48]
 3485 14be 1846     		mov	r0, r3
 3486 14c0 00F070F8 		bl	usTaskCheckFreeStackSpace
 3487 14c4 0346     		mov	r3, r0
 3488 14c6 0096     		str	r6, [sp, #0]
 3489 14c8 0193     		str	r3, [sp, #4]
 3490 14ca 40F20000 		movw	r0, #:lower16:pcStatsString
 3491 14ce C0F20000 		movt	r0, #:upper16:pcStatsString
 3492 14d2 40F20001 		movw	r1, #:lower16:.LC2
 3493 14d6 C0F20001 		movt	r1, #:upper16:.LC2
 3494 14da 2A46     		mov	r2, r5
 3495 14dc 2346     		mov	r3, r4
 3496 14de FFF7FEFF 		bl	sprintf
 3497 14e2 4EE0     		b	.L151
 3498              	.L150:
2249:../FreeRTOS/Source/tasks.c **** 				}
2250:../FreeRTOS/Source/tasks.c **** 				else
2251:../FreeRTOS/Source/tasks.c **** 				{
2252:../FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2253:../FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2254:../FreeRTOS/Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2255:../FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 3499              		.loc 1 2255 0
 3500 14e4 BB69     		ldr	r3, [r7, #24]
 3501 14e6 DB6C     		ldr	r3, [r3, #76]
 3502 14e8 1A46     		mov	r2, r3
 3503 14ea 7B68     		ldr	r3, [r7, #4]
 3504 14ec B2FBF3F3 		udiv	r3, r2, r3
 3505 14f0 7B61     		str	r3, [r7, #20]
2256:../FreeRTOS/Source/tasks.c **** 
2257:../FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
 3506              		.loc 1 2257 0
 3507 14f2 7B69     		ldr	r3, [r7, #20]
 3508 14f4 002B     		cmp	r3, #0
 3509 14f6 23D0     		beq	.L152
2258:../FreeRTOS/Source/tasks.c **** 					{
2259:../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2260:../FreeRTOS/Source/tasks.c **** 						{
2261:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2262:../FreeRTOS/Source/tasks.c **** 						}
2263:../FreeRTOS/Source/tasks.c **** 						#else
2264:../FreeRTOS/Source/tasks.c **** 						{
2265:../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2266:../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2267:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u %3u%%  %5u\r\n", (unsigned int) pxNex
 3510              		.loc 1 2267 0
 3511 14f8 BB69     		ldr	r3, [r7, #24]
 3512 14fa DB6A     		ldr	r3, [r3, #44]
 3513 14fc 1D46     		mov	r5, r3
 3514 14fe 97F90340 		ldrsb	r4, [r7, #3]
 3515 1502 BB69     		ldr	r3, [r7, #24]
 3516 1504 03F13408 		add	r8, r3, #52
 3517 1508 BB69     		ldr	r3, [r7, #24]
 3518 150a DB6C     		ldr	r3, [r3, #76]
 3519 150c 1E46     		mov	r6, r3
 3520 150e BB69     		ldr	r3, [r7, #24]
 3521 1510 1B6B     		ldr	r3, [r3, #48]
 3522 1512 1846     		mov	r0, r3
 3523 1514 00F046F8 		bl	usTaskCheckFreeStackSpace
 3524 1518 0346     		mov	r3, r0
 3525 151a CDF80080 		str	r8, [sp, #0]
 3526 151e 0196     		str	r6, [sp, #4]
 3527 1520 7A69     		ldr	r2, [r7, #20]
 3528 1522 0292     		str	r2, [sp, #8]
 3529 1524 0393     		str	r3, [sp, #12]
 3530 1526 40F20000 		movw	r0, #:lower16:pcStatsString
 3531 152a C0F20000 		movt	r0, #:upper16:pcStatsString
 3532 152e 40F20001 		movw	r1, #:lower16:.LC3
 3533 1532 C0F20001 		movt	r1, #:upper16:.LC3
 3534 1536 2A46     		mov	r2, r5
 3535 1538 2346     		mov	r3, r4
 3536 153a FFF7FEFF 		bl	sprintf
 3537 153e 20E0     		b	.L151
 3538              	.L152:
2268:../FreeRTOS/Source/tasks.c **** 						}
2269:../FreeRTOS/Source/tasks.c **** 						#endif
2270:../FreeRTOS/Source/tasks.c **** 					}
2271:../FreeRTOS/Source/tasks.c **** 					else
2272:../FreeRTOS/Source/tasks.c **** 					{
2273:../FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2274:../FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2275:../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2276:../FreeRTOS/Source/tasks.c **** 						{
2277:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2278:../FreeRTOS/Source/tasks.c **** 						}
2279:../FreeRTOS/Source/tasks.c **** 						#else
2280:../FreeRTOS/Source/tasks.c **** 						{
2281:../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2282:../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2283:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u  <1%%  %5u\r\n",  (unsigned int) pxNe
 3539              		.loc 1 2283 0
 3540 1540 BB69     		ldr	r3, [r7, #24]
 3541 1542 DB6A     		ldr	r3, [r3, #44]
 3542 1544 1D46     		mov	r5, r3
 3543 1546 97F90340 		ldrsb	r4, [r7, #3]
 3544 154a BB69     		ldr	r3, [r7, #24]
 3545 154c 03F13408 		add	r8, r3, #52
 3546 1550 BB69     		ldr	r3, [r7, #24]
 3547 1552 DB6C     		ldr	r3, [r3, #76]
 3548 1554 1E46     		mov	r6, r3
 3549 1556 BB69     		ldr	r3, [r7, #24]
 3550 1558 1B6B     		ldr	r3, [r3, #48]
 3551 155a 1846     		mov	r0, r3
 3552 155c 00F022F8 		bl	usTaskCheckFreeStackSpace
 3553 1560 0346     		mov	r3, r0
 3554 1562 CDF80080 		str	r8, [sp, #0]
 3555 1566 0196     		str	r6, [sp, #4]
 3556 1568 0293     		str	r3, [sp, #8]
 3557 156a 40F20000 		movw	r0, #:lower16:pcStatsString
 3558 156e C0F20000 		movt	r0, #:upper16:pcStatsString
 3559 1572 40F20001 		movw	r1, #:lower16:.LC4
 3560 1576 C0F20001 		movt	r1, #:upper16:.LC4
 3561 157a 2A46     		mov	r2, r5
 3562 157c 2346     		mov	r3, r4
 3563 157e FFF7FEFF 		bl	sprintf
 3564              	.L151:
2284:../FreeRTOS/Source/tasks.c **** 						}
2285:../FreeRTOS/Source/tasks.c **** 						#endif
2286:../FreeRTOS/Source/tasks.c **** 					}
2287:../FreeRTOS/Source/tasks.c **** 				}
2288:../FreeRTOS/Source/tasks.c **** 
2289:../FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
 3565              		.loc 1 2289 0
 3566 1582 F868     		ldr	r0, [r7, #12]
 3567 1584 40F20001 		movw	r1, #:lower16:pcStatsString
 3568 1588 C0F20001 		movt	r1, #:upper16:pcStatsString
 3569 158c FFF7FEFF 		bl	strcat
 3570              	.L149:
2290:../FreeRTOS/Source/tasks.c **** 			}
2291:../FreeRTOS/Source/tasks.c **** 
2292:../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 3571              		.loc 1 2292 0
 3572 1590 BA69     		ldr	r2, [r7, #24]
 3573 1592 3B6A     		ldr	r3, [r7, #32]
 3574 1594 9A42     		cmp	r2, r3
 3575 1596 7FF468AF 		bne	.L153
2293:../FreeRTOS/Source/tasks.c **** 	}
 3576              		.loc 1 2293 0
 3577 159a 07F12807 		add	r7, r7, #40
 3578 159e BD46     		mov	sp, r7
 3579 15a0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3580              		.cfi_endproc
 3581              	.LFE145:
 3583              		.align	2
 3584              		.thumb
 3585              		.thumb_func
 3587              	usTaskCheckFreeStackSpace:
 3588              	.LFB146:
2294:../FreeRTOS/Source/tasks.c **** 
2295:../FreeRTOS/Source/tasks.c **** #endif
2296:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2297:../FreeRTOS/Source/tasks.c **** 
2298:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2299:../FreeRTOS/Source/tasks.c **** 
2300:../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2301:../FreeRTOS/Source/tasks.c **** 	{
 3589              		.loc 1 2301 0
 3590              		.cfi_startproc
 3591              		@ args = 0, pretend = 0, frame = 8
 3592              		@ frame_needed = 1, uses_anonymous_args = 0
 3593              		@ link register save eliminated.
 3594 15a4 90B4     		push	{r4, r7}
 3595              	.LCFI103:
 3596              		.cfi_def_cfa_offset 8
 3597              		.cfi_offset 7, -4
 3598              		.cfi_offset 4, -8
 3599 15a6 82B0     		sub	sp, sp, #8
 3600              	.LCFI104:
 3601              		.cfi_def_cfa_offset 16
 3602 15a8 00AF     		add	r7, sp, #0
 3603              	.LCFI105:
 3604              		.cfi_def_cfa_register 7
 3605 15aa 7860     		str	r0, [r7, #4]
2302:../FreeRTOS/Source/tasks.c **** 	register unsigned short usCount = 0U;
 3606              		.loc 1 2302 0
 3607 15ac 4FF00004 		mov	r4, #0
2303:../FreeRTOS/Source/tasks.c **** 
2304:../FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3608              		.loc 1 2304 0
 3609 15b0 06E0     		b	.L155
 3610              	.L156:
2305:../FreeRTOS/Source/tasks.c **** 		{
2306:../FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3611              		.loc 1 2306 0
 3612 15b2 7B68     		ldr	r3, [r7, #4]
 3613 15b4 03F10103 		add	r3, r3, #1
 3614 15b8 7B60     		str	r3, [r7, #4]
2307:../FreeRTOS/Source/tasks.c **** 			usCount++;
 3615              		.loc 1 2307 0
 3616 15ba 04F10103 		add	r3, r4, #1
 3617 15be 9CB2     		uxth	r4, r3
 3618              	.L155:
2304:../FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3619              		.loc 1 2304 0 discriminator 1
 3620 15c0 7B68     		ldr	r3, [r7, #4]
 3621 15c2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3622 15c4 A52B     		cmp	r3, #165
 3623 15c6 F4D0     		beq	.L156
2308:../FreeRTOS/Source/tasks.c **** 		}
2309:../FreeRTOS/Source/tasks.c **** 
2310:../FreeRTOS/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 3624              		.loc 1 2310 0
 3625 15c8 4FEA9403 		lsr	r3, r4, #2
 3626 15cc 9CB2     		uxth	r4, r3
2311:../FreeRTOS/Source/tasks.c **** 
2312:../FreeRTOS/Source/tasks.c **** 		return usCount;
 3627              		.loc 1 2312 0
 3628 15ce 2346     		mov	r3, r4
2313:../FreeRTOS/Source/tasks.c **** 	}
 3629              		.loc 1 2313 0
 3630 15d0 1846     		mov	r0, r3
 3631 15d2 07F10807 		add	r7, r7, #8
 3632 15d6 BD46     		mov	sp, r7
 3633 15d8 90BC     		pop	{r4, r7}
 3634 15da 7047     		bx	lr
 3635              		.cfi_endproc
 3636              	.LFE146:
 3638              		.align	2
 3639              		.global	uxTaskGetStackHighWaterMark
 3640              		.thumb
 3641              		.thumb_func
 3643              	uxTaskGetStackHighWaterMark:
 3644              	.LFB147:
2314:../FreeRTOS/Source/tasks.c **** 
2315:../FreeRTOS/Source/tasks.c **** #endif
2316:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2317:../FreeRTOS/Source/tasks.c **** 
2318:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2319:../FreeRTOS/Source/tasks.c **** 
2320:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2321:../FreeRTOS/Source/tasks.c **** 	{
 3645              		.loc 1 2321 0
 3646              		.cfi_startproc
 3647              		@ args = 0, pretend = 0, frame = 24
 3648              		@ frame_needed = 1, uses_anonymous_args = 0
 3649 15dc 80B5     		push	{r7, lr}
 3650              	.LCFI106:
 3651              		.cfi_def_cfa_offset 8
 3652              		.cfi_offset 14, -4
 3653              		.cfi_offset 7, -8
 3654 15de 86B0     		sub	sp, sp, #24
 3655              	.LCFI107:
 3656              		.cfi_def_cfa_offset 32
 3657 15e0 00AF     		add	r7, sp, #0
 3658              	.LCFI108:
 3659              		.cfi_def_cfa_register 7
 3660 15e2 7860     		str	r0, [r7, #4]
2322:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2323:../FreeRTOS/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2324:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2325:../FreeRTOS/Source/tasks.c **** 
2326:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3661              		.loc 1 2326 0
 3662 15e4 7B68     		ldr	r3, [r7, #4]
 3663 15e6 002B     		cmp	r3, #0
 3664 15e8 05D1     		bne	.L158
 3665              		.loc 1 2326 0 is_stmt 0 discriminator 1
 3666 15ea 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3667 15ee C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3668 15f2 1B68     		ldr	r3, [r3, #0]
 3669 15f4 00E0     		b	.L159
 3670              	.L158:
 3671              		.loc 1 2326 0 discriminator 2
 3672 15f6 7B68     		ldr	r3, [r7, #4]
 3673              	.L159:
 3674              		.loc 1 2326 0 discriminator 3
 3675 15f8 7B61     		str	r3, [r7, #20]
2327:../FreeRTOS/Source/tasks.c **** 
2328:../FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2329:../FreeRTOS/Source/tasks.c **** 		{
2330:../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 3676              		.loc 1 2330 0 is_stmt 1 discriminator 3
 3677 15fa 7B69     		ldr	r3, [r7, #20]
 3678 15fc 1B6B     		ldr	r3, [r3, #48]
 3679 15fe 3B61     		str	r3, [r7, #16]
2331:../FreeRTOS/Source/tasks.c **** 		}
2332:../FreeRTOS/Source/tasks.c **** 		#else
2333:../FreeRTOS/Source/tasks.c **** 		{
2334:../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2335:../FreeRTOS/Source/tasks.c **** 		}
2336:../FreeRTOS/Source/tasks.c **** 		#endif
2337:../FreeRTOS/Source/tasks.c **** 
2338:../FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 3680              		.loc 1 2338 0 discriminator 3
 3681 1600 3869     		ldr	r0, [r7, #16]
 3682 1602 FFF7CFFF 		bl	usTaskCheckFreeStackSpace
 3683 1606 0346     		mov	r3, r0
 3684 1608 FB60     		str	r3, [r7, #12]
2339:../FreeRTOS/Source/tasks.c **** 
2340:../FreeRTOS/Source/tasks.c **** 		return uxReturn;
 3685              		.loc 1 2340 0 discriminator 3
 3686 160a FB68     		ldr	r3, [r7, #12]
2341:../FreeRTOS/Source/tasks.c **** 	}
 3687              		.loc 1 2341 0 discriminator 3
 3688 160c 1846     		mov	r0, r3
 3689 160e 07F11807 		add	r7, r7, #24
 3690 1612 BD46     		mov	sp, r7
 3691 1614 80BD     		pop	{r7, pc}
 3692              		.cfi_endproc
 3693              	.LFE147:
 3695 1616 00BF     		.align	2
 3696              		.thumb
 3697              		.thumb_func
 3699              	prvDeleteTCB:
 3700              	.LFB148:
2342:../FreeRTOS/Source/tasks.c **** 
2343:../FreeRTOS/Source/tasks.c **** #endif
2344:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2345:../FreeRTOS/Source/tasks.c **** 
2346:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2347:../FreeRTOS/Source/tasks.c **** 
2348:../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2349:../FreeRTOS/Source/tasks.c **** 	{
 3701              		.loc 1 2349 0
 3702              		.cfi_startproc
 3703              		@ args = 0, pretend = 0, frame = 8
 3704              		@ frame_needed = 1, uses_anonymous_args = 0
 3705 1618 80B5     		push	{r7, lr}
 3706              	.LCFI109:
 3707              		.cfi_def_cfa_offset 8
 3708              		.cfi_offset 14, -4
 3709              		.cfi_offset 7, -8
 3710 161a 82B0     		sub	sp, sp, #8
 3711              	.LCFI110:
 3712              		.cfi_def_cfa_offset 16
 3713 161c 00AF     		add	r7, sp, #0
 3714              	.LCFI111:
 3715              		.cfi_def_cfa_register 7
 3716 161e 7860     		str	r0, [r7, #4]
2350:../FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2351:../FreeRTOS/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2352:../FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3717              		.loc 1 2352 0
 3718 1620 7B68     		ldr	r3, [r7, #4]
 3719 1622 1B6B     		ldr	r3, [r3, #48]
 3720 1624 1846     		mov	r0, r3
 3721 1626 FFF7FEFF 		bl	free
2353:../FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
 3722              		.loc 1 2353 0
 3723 162a 7868     		ldr	r0, [r7, #4]
 3724 162c FFF7FEFF 		bl	free
2354:../FreeRTOS/Source/tasks.c **** 	}
 3725              		.loc 1 2354 0
 3726 1630 07F10807 		add	r7, r7, #8
 3727 1634 BD46     		mov	sp, r7
 3728 1636 80BD     		pop	{r7, pc}
 3729              		.cfi_endproc
 3730              	.LFE148:
 3732              		.align	2
 3733              		.global	xTaskGetCurrentTaskHandle
 3734              		.thumb
 3735              		.thumb_func
 3737              	xTaskGetCurrentTaskHandle:
 3738              	.LFB149:
2355:../FreeRTOS/Source/tasks.c **** 
2356:../FreeRTOS/Source/tasks.c **** #endif
2357:../FreeRTOS/Source/tasks.c **** 
2358:../FreeRTOS/Source/tasks.c **** 
2359:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2360:../FreeRTOS/Source/tasks.c **** 
2361:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2362:../FreeRTOS/Source/tasks.c **** 
2363:../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2364:../FreeRTOS/Source/tasks.c **** 	{
 3739              		.loc 1 2364 0
 3740              		.cfi_startproc
 3741              		@ args = 0, pretend = 0, frame = 8
 3742              		@ frame_needed = 1, uses_anonymous_args = 0
 3743              		@ link register save eliminated.
 3744 1638 80B4     		push	{r7}
 3745              	.LCFI112:
 3746              		.cfi_def_cfa_offset 4
 3747              		.cfi_offset 7, -4
 3748 163a 83B0     		sub	sp, sp, #12
 3749              	.LCFI113:
 3750              		.cfi_def_cfa_offset 16
 3751 163c 00AF     		add	r7, sp, #0
 3752              	.LCFI114:
 3753              		.cfi_def_cfa_register 7
2365:../FreeRTOS/Source/tasks.c **** 	xTaskHandle xReturn;
2366:../FreeRTOS/Source/tasks.c **** 
2367:../FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
2368:../FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2369:../FreeRTOS/Source/tasks.c **** 		individual execution thread. */
2370:../FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3754              		.loc 1 2370 0
 3755 163e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3756 1642 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3757 1646 1B68     		ldr	r3, [r3, #0]
 3758 1648 7B60     		str	r3, [r7, #4]
2371:../FreeRTOS/Source/tasks.c **** 
2372:../FreeRTOS/Source/tasks.c **** 		return xReturn;
 3759              		.loc 1 2372 0
 3760 164a 7B68     		ldr	r3, [r7, #4]
2373:../FreeRTOS/Source/tasks.c **** 	}
 3761              		.loc 1 2373 0
 3762 164c 1846     		mov	r0, r3
 3763 164e 07F10C07 		add	r7, r7, #12
 3764 1652 BD46     		mov	sp, r7
 3765 1654 80BC     		pop	{r7}
 3766 1656 7047     		bx	lr
 3767              		.cfi_endproc
 3768              	.LFE149:
 3770              		.align	2
 3771              		.global	vTaskPriorityInherit
 3772              		.thumb
 3773              		.thumb_func
 3775              	vTaskPriorityInherit:
 3776              	.LFB150:
2374:../FreeRTOS/Source/tasks.c **** 
2375:../FreeRTOS/Source/tasks.c **** #endif
2376:../FreeRTOS/Source/tasks.c **** 
2377:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2378:../FreeRTOS/Source/tasks.c **** 
2379:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2380:../FreeRTOS/Source/tasks.c **** 
2381:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2382:../FreeRTOS/Source/tasks.c **** 	{
2383:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
2384:../FreeRTOS/Source/tasks.c **** 
2385:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2386:../FreeRTOS/Source/tasks.c **** 		{
2387:../FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2388:../FreeRTOS/Source/tasks.c **** 		}
2389:../FreeRTOS/Source/tasks.c **** 		else
2390:../FreeRTOS/Source/tasks.c **** 		{
2391:../FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2392:../FreeRTOS/Source/tasks.c **** 			{
2393:../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2394:../FreeRTOS/Source/tasks.c **** 			}
2395:../FreeRTOS/Source/tasks.c **** 			else
2396:../FreeRTOS/Source/tasks.c **** 			{
2397:../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2398:../FreeRTOS/Source/tasks.c **** 			}
2399:../FreeRTOS/Source/tasks.c **** 		}
2400:../FreeRTOS/Source/tasks.c **** 
2401:../FreeRTOS/Source/tasks.c **** 		return xReturn;
2402:../FreeRTOS/Source/tasks.c **** 	}
2403:../FreeRTOS/Source/tasks.c **** 
2404:../FreeRTOS/Source/tasks.c **** #endif
2405:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2406:../FreeRTOS/Source/tasks.c **** 
2407:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2408:../FreeRTOS/Source/tasks.c **** 
2409:../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2410:../FreeRTOS/Source/tasks.c **** 	{
 3777              		.loc 1 2410 0
 3778              		.cfi_startproc
 3779              		@ args = 0, pretend = 0, frame = 16
 3780              		@ frame_needed = 1, uses_anonymous_args = 0
 3781 1658 80B5     		push	{r7, lr}
 3782              	.LCFI115:
 3783              		.cfi_def_cfa_offset 8
 3784              		.cfi_offset 14, -4
 3785              		.cfi_offset 7, -8
 3786 165a 84B0     		sub	sp, sp, #16
 3787              	.LCFI116:
 3788              		.cfi_def_cfa_offset 24
 3789 165c 00AF     		add	r7, sp, #0
 3790              	.LCFI117:
 3791              		.cfi_def_cfa_register 7
 3792 165e 7860     		str	r0, [r7, #4]
2411:../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3793              		.loc 1 2411 0
 3794 1660 7B68     		ldr	r3, [r7, #4]
 3795 1662 FB60     		str	r3, [r7, #12]
2412:../FreeRTOS/Source/tasks.c **** 
2413:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxMutexHolder );
2414:../FreeRTOS/Source/tasks.c **** 
2415:../FreeRTOS/Source/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3796              		.loc 1 2415 0
 3797 1664 FB68     		ldr	r3, [r7, #12]
 3798 1666 DA6A     		ldr	r2, [r3, #44]
 3799 1668 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3800 166c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3801 1670 1B68     		ldr	r3, [r3, #0]
 3802 1672 DB6A     		ldr	r3, [r3, #44]
 3803 1674 9A42     		cmp	r2, r3
 3804 1676 57D2     		bcs	.L162
2416:../FreeRTOS/Source/tasks.c **** 		{
2417:../FreeRTOS/Source/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2418:../FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 3805              		.loc 1 2418 0
 3806 1678 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3807 167c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3808 1680 1B68     		ldr	r3, [r3, #0]
 3809 1682 DB6A     		ldr	r3, [r3, #44]
 3810 1684 C3F10A02 		rsb	r2, r3, #10
 3811 1688 FB68     		ldr	r3, [r7, #12]
 3812 168a 9A61     		str	r2, [r3, #24]
2419:../FreeRTOS/Source/tasks.c **** 
2420:../FreeRTOS/Source/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2421:../FreeRTOS/Source/tasks.c **** 			be moved in to a new list. */
2422:../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 3813              		.loc 1 2422 0
 3814 168c FB68     		ldr	r3, [r7, #12]
 3815 168e 5969     		ldr	r1, [r3, #20]
 3816 1690 FB68     		ldr	r3, [r7, #12]
 3817 1692 DA6A     		ldr	r2, [r3, #44]
 3818 1694 1346     		mov	r3, r2
 3819 1696 4FEA8303 		lsl	r3, r3, #2
 3820 169a 9B18     		adds	r3, r3, r2
 3821 169c 4FEA8303 		lsl	r3, r3, #2
 3822 16a0 1A46     		mov	r2, r3
 3823 16a2 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3824 16a6 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3825 16aa D318     		adds	r3, r2, r3
 3826 16ac 9942     		cmp	r1, r3
 3827 16ae 33D1     		bne	.L164
2423:../FreeRTOS/Source/tasks.c **** 			{
2424:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3828              		.loc 1 2424 0
 3829 16b0 FB68     		ldr	r3, [r7, #12]
 3830 16b2 03F10403 		add	r3, r3, #4
 3831 16b6 1846     		mov	r0, r3
 3832 16b8 FFF7FEFF 		bl	vListRemove
2425:../FreeRTOS/Source/tasks.c **** 
2426:../FreeRTOS/Source/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2427:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3833              		.loc 1 2427 0
 3834 16bc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3835 16c0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3836 16c4 1B68     		ldr	r3, [r3, #0]
 3837 16c6 DA6A     		ldr	r2, [r3, #44]
 3838 16c8 FB68     		ldr	r3, [r7, #12]
 3839 16ca DA62     		str	r2, [r3, #44]
2428:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3840              		.loc 1 2428 0
 3841 16cc FB68     		ldr	r3, [r7, #12]
 3842 16ce DA6A     		ldr	r2, [r3, #44]
 3843 16d0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3844 16d4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3845 16d8 1B68     		ldr	r3, [r3, #0]
 3846 16da 9A42     		cmp	r2, r3
 3847 16dc 06D9     		bls	.L165
 3848              		.loc 1 2428 0 is_stmt 0 discriminator 1
 3849 16de FB68     		ldr	r3, [r7, #12]
 3850 16e0 DA6A     		ldr	r2, [r3, #44]
 3851 16e2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3852 16e6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3853 16ea 1A60     		str	r2, [r3, #0]
 3854              	.L165:
 3855              		.loc 1 2428 0 discriminator 2
 3856 16ec FB68     		ldr	r3, [r7, #12]
 3857 16ee DA6A     		ldr	r2, [r3, #44]
 3858 16f0 1346     		mov	r3, r2
 3859 16f2 4FEA8303 		lsl	r3, r3, #2
 3860 16f6 9B18     		adds	r3, r3, r2
 3861 16f8 4FEA8303 		lsl	r3, r3, #2
 3862 16fc 1A46     		mov	r2, r3
 3863 16fe 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3864 1702 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3865 1706 D218     		adds	r2, r2, r3
 3866 1708 FB68     		ldr	r3, [r7, #12]
 3867 170a 03F10403 		add	r3, r3, #4
 3868 170e 1046     		mov	r0, r2
 3869 1710 1946     		mov	r1, r3
 3870 1712 FFF7FEFF 		bl	vListInsertEnd
 3871 1716 07E0     		b	.L162
 3872              	.L164:
2429:../FreeRTOS/Source/tasks.c **** 			}
2430:../FreeRTOS/Source/tasks.c **** 			else
2431:../FreeRTOS/Source/tasks.c **** 			{
2432:../FreeRTOS/Source/tasks.c **** 				/* Just inherit the priority. */
2433:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3873              		.loc 1 2433 0 is_stmt 1
 3874 1718 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3875 171c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3876 1720 1B68     		ldr	r3, [r3, #0]
 3877 1722 DA6A     		ldr	r2, [r3, #44]
 3878 1724 FB68     		ldr	r3, [r7, #12]
 3879 1726 DA62     		str	r2, [r3, #44]
 3880              	.L162:
2434:../FreeRTOS/Source/tasks.c **** 			}
2435:../FreeRTOS/Source/tasks.c **** 		}
2436:../FreeRTOS/Source/tasks.c **** 	}
 3881              		.loc 1 2436 0
 3882 1728 07F11007 		add	r7, r7, #16
 3883 172c BD46     		mov	sp, r7
 3884 172e 80BD     		pop	{r7, pc}
 3885              		.cfi_endproc
 3886              	.LFE150:
 3888              		.align	2
 3889              		.global	vTaskPriorityDisinherit
 3890              		.thumb
 3891              		.thumb_func
 3893              	vTaskPriorityDisinherit:
 3894              	.LFB151:
2437:../FreeRTOS/Source/tasks.c **** 
2438:../FreeRTOS/Source/tasks.c **** #endif
2439:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2440:../FreeRTOS/Source/tasks.c **** 
2441:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2442:../FreeRTOS/Source/tasks.c **** 
2443:../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2444:../FreeRTOS/Source/tasks.c **** 	{
 3895              		.loc 1 2444 0
 3896              		.cfi_startproc
 3897              		@ args = 0, pretend = 0, frame = 16
 3898              		@ frame_needed = 1, uses_anonymous_args = 0
 3899 1730 80B5     		push	{r7, lr}
 3900              	.LCFI118:
 3901              		.cfi_def_cfa_offset 8
 3902              		.cfi_offset 14, -4
 3903              		.cfi_offset 7, -8
 3904 1732 84B0     		sub	sp, sp, #16
 3905              	.LCFI119:
 3906              		.cfi_def_cfa_offset 24
 3907 1734 00AF     		add	r7, sp, #0
 3908              	.LCFI120:
 3909              		.cfi_def_cfa_register 7
 3910 1736 7860     		str	r0, [r7, #4]
2445:../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3911              		.loc 1 2445 0
 3912 1738 7B68     		ldr	r3, [r7, #4]
 3913 173a FB60     		str	r3, [r7, #12]
2446:../FreeRTOS/Source/tasks.c **** 
2447:../FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3914              		.loc 1 2447 0
 3915 173c 7B68     		ldr	r3, [r7, #4]
 3916 173e 002B     		cmp	r3, #0
 3917 1740 3AD0     		beq	.L166
2448:../FreeRTOS/Source/tasks.c **** 		{
2449:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3918              		.loc 1 2449 0
 3919 1742 FB68     		ldr	r3, [r7, #12]
 3920 1744 DA6A     		ldr	r2, [r3, #44]
 3921 1746 FB68     		ldr	r3, [r7, #12]
 3922 1748 5B6C     		ldr	r3, [r3, #68]
 3923 174a 9A42     		cmp	r2, r3
 3924 174c 34D0     		beq	.L166
2450:../FreeRTOS/Source/tasks.c **** 			{
2451:../FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2452:../FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2453:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3925              		.loc 1 2453 0
 3926 174e FB68     		ldr	r3, [r7, #12]
 3927 1750 03F10403 		add	r3, r3, #4
 3928 1754 1846     		mov	r0, r3
 3929 1756 FFF7FEFF 		bl	vListRemove
2454:../FreeRTOS/Source/tasks.c **** 
2455:../FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding ourselves into the new
2456:../FreeRTOS/Source/tasks.c **** 				ready list. */
2457:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3930              		.loc 1 2457 0
 3931 175a FB68     		ldr	r3, [r7, #12]
 3932 175c 5A6C     		ldr	r2, [r3, #68]
 3933 175e FB68     		ldr	r3, [r7, #12]
 3934 1760 DA62     		str	r2, [r3, #44]
2458:../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3935              		.loc 1 2458 0
 3936 1762 FB68     		ldr	r3, [r7, #12]
 3937 1764 DB6A     		ldr	r3, [r3, #44]
 3938 1766 C3F10A02 		rsb	r2, r3, #10
 3939 176a FB68     		ldr	r3, [r7, #12]
 3940 176c 9A61     		str	r2, [r3, #24]
2459:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3941              		.loc 1 2459 0
 3942 176e FB68     		ldr	r3, [r7, #12]
 3943 1770 DA6A     		ldr	r2, [r3, #44]
 3944 1772 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3945 1776 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3946 177a 1B68     		ldr	r3, [r3, #0]
 3947 177c 9A42     		cmp	r2, r3
 3948 177e 06D9     		bls	.L168
 3949              		.loc 1 2459 0 is_stmt 0 discriminator 1
 3950 1780 FB68     		ldr	r3, [r7, #12]
 3951 1782 DA6A     		ldr	r2, [r3, #44]
 3952 1784 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3953 1788 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3954 178c 1A60     		str	r2, [r3, #0]
 3955              	.L168:
 3956              		.loc 1 2459 0 discriminator 2
 3957 178e FB68     		ldr	r3, [r7, #12]
 3958 1790 DA6A     		ldr	r2, [r3, #44]
 3959 1792 1346     		mov	r3, r2
 3960 1794 4FEA8303 		lsl	r3, r3, #2
 3961 1798 9B18     		adds	r3, r3, r2
 3962 179a 4FEA8303 		lsl	r3, r3, #2
 3963 179e 1A46     		mov	r2, r3
 3964 17a0 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3965 17a4 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3966 17a8 D218     		adds	r2, r2, r3
 3967 17aa FB68     		ldr	r3, [r7, #12]
 3968 17ac 03F10403 		add	r3, r3, #4
 3969 17b0 1046     		mov	r0, r2
 3970 17b2 1946     		mov	r1, r3
 3971 17b4 FFF7FEFF 		bl	vListInsertEnd
 3972              	.L166:
2460:../FreeRTOS/Source/tasks.c **** 			}
2461:../FreeRTOS/Source/tasks.c **** 		}
2462:../FreeRTOS/Source/tasks.c **** 	}
 3973              		.loc 1 2462 0 is_stmt 1
 3974 17b8 07F11007 		add	r7, r7, #16
 3975 17bc BD46     		mov	sp, r7
 3976 17be 80BD     		pop	{r7, pc}
 3977              		.cfi_endproc
 3978              	.LFE151:
 3980              	.Letext0:
 3981              		.file 2 "c:\\chibistudio\\tools\\gnu tools arm embedded\\4.6 2012q2\\bin\\../lib/gcc/arm-none-eabi
 3982              		.file 3 "E:\\Desktop\\thundercyer-the-alarm-clock\\FreeRTOS\\Source\\include/projdefs.h"
 3983              		.file 4 "c:\\chibistudio\\tools\\gnu tools arm embedded\\4.6 2012q2\\bin\\../lib/gcc/arm-none-eabi
 3984              		.file 5 "E:\\Desktop\\thundercyer-the-alarm-clock\\FreeRTOS\\Source\\include/../../Source/portable
 3985              		.file 6 "E:\\Desktop\\thundercyer-the-alarm-clock\\FreeRTOS\\Source\\include/FreeRTOS.h"
 3986              		.file 7 "E:\\Desktop\\thundercyer-the-alarm-clock\\FreeRTOS\\Source\\include/list.h"
 3987              		.file 8 "E:\\Desktop\\thundercyer-the-alarm-clock\\FreeRTOS\\Source\\include/task.h"
 3988              		.file 9 "E:\\Desktop\\thundercyer-the-alarm-clock\\CMSIS\\Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:24     .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:21     .bss.pxCurrentTCB:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:27     .bss.pxReadyTasksLists:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:30     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:33     .bss.xDelayedTaskList1:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:36     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:39     .bss.xDelayedTaskList2:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:42     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:45     .bss.pxDelayedTaskList:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:48     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:51     .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:54     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:57     .bss.xPendingReadyList:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:60     .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:63     .bss.xTasksWaitingTermination:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:66     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:69     .bss.uxTasksDeleted:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:72     .bss.uxTasksDeleted:00000000 uxTasksDeleted
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:75     .bss.xSuspendedTaskList:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:78     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:81     .bss.xIdleTaskHandle:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:84     .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:87     .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:90     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:93     .bss.xTickCount:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:96     .bss.xTickCount:00000000 xTickCount
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:99     .bss.uxTopUsedPriority:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:102    .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:105    .bss.uxTopReadyPriority:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:108    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:111    .bss.xSchedulerRunning:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:114    .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:117    .bss.uxSchedulerSuspended:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:120    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:123    .bss.uxMissedTicks:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:126    .bss.uxMissedTicks:00000000 uxMissedTicks
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:129    .bss.xMissedYield:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:132    .bss.xMissedYield:00000000 xMissedYield
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:135    .bss.xNumOfOverflows:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:138    .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:141    .bss.uxTaskNumber:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:144    .bss.uxTaskNumber:00000000 uxTaskNumber
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:147    .data.xNextTaskUnblockTime:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:150    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:153    .bss.pcStatsString:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:156    .bss.pcStatsString:00000000 pcStatsString
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:159    .bss.ulTaskSwitchedInTime:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:162    .bss.ulTaskSwitchedInTime:00000000 ulTaskSwitchedInTime
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:165    .text:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:170    .text:00000000 xTaskGenericCreate
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3286   .text:000013b4 prvAllocateTCBAndStack
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2941   .text:00001164 prvInitialiseTCBVariables
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3031   .text:000011ec prvInitialiseTaskLists
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:395    .text:000001ac vTaskDelete
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:507    .text:0000026c vTaskDelayUntil
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1438   .text:000007f8 vTaskSuspendAll
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3207   .text:00001328 prvAddCurrentTaskToDelayedList
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1472   .text:0000081c xTaskResumeAll
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:623    .text:00000320 vTaskDelay
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:691    .text:0000037c uxTaskPriorityGet
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:747    .text:000003b4 vTaskPrioritySet
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:929    .text:000004e0 vTaskSuspend
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2373   .text:00000dd8 vTaskSwitchContext
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1046   .text:000005a0 xTaskIsTaskSuspended
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1109   .text:000005f0 vTaskResume
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1212   .text:0000069c xTaskResumeFromISR
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1317   .rodata:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1318   .rodata:00000000 .LC0
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1326   .text:0000075c vTaskStartScheduler
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2899   .text:00001140 prvIdleTask
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1400   .text:000007d8 vTaskEndScheduler
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1986   .text:00000b60 vTaskIncrementTick
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1651   .text:00000970 xTaskGetTickCount
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1692   .text:00000998 xTaskGetTickCountFromISR
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1746   .text:000009d0 uxTaskGetNumberOfTasks
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1774   .rodata:00000008 .LC1
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1782   .text:000009e8 vTaskGetRunTimeStats
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3381   .text:00001428 prvGenerateRunTimeStatsForTasksInList
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:1955   .text:00000b48 xTaskGetIdleTaskHandle
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2196   .text:00000d18 vTaskSetApplicationTaskTag
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2250   .text:00000d50 xTaskGetApplicationTaskTag
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2306   .text:00000d8c xTaskCallApplicationTaskHook
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2537   .text:00000f18 vTaskPlaceOnEventList
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2609   .text:00000f90 xTaskRemoveFromEventList
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2722   .text:00001054 vTaskSetTimeOutState
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2765   .text:00001084 xTaskCheckForTimeOut
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:2869   .text:00001128 vTaskMissedYield
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3117   .text:00001290 prvCheckTasksWaitingTermination
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3699   .text:00001618 prvDeleteTCB
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3368   .rodata:0000000c .LC2
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3371   .rodata:00000034 .LC3
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3374   .rodata:00000054 .LC4
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3587   .text:000015a4 usTaskCheckFreeStackSpace
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3643   .text:000015dc uxTaskGetStackHighWaterMark
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3737   .text:00001638 xTaskGetCurrentTaskHandle
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3775   .text:00001658 vTaskPriorityInherit
C:\Users\Alex\AppData\Local\Temp\ccr5r7ha.s:3893   .text:00001730 vTaskPriorityDisinherit
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
init_us_timer
xPortStartScheduler
vPortEndScheduler
get_us_time
strlen
memcpy
vApplicationStackOverflowHook
vListInsert
strncpy
vListInitialiseItem
vListInitialise
malloc
free
memset
sprintf
strcat
