   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.usTaskCheckFreeStackSpace,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	usTaskCheckFreeStackSpace:
  24              	.LFB146:
  25              		.file 1 "../FreeRTOS/Source/tasks.c"
   1:../FreeRTOS/Source/tasks.c **** /*
   2:../FreeRTOS/Source/tasks.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS/Source/tasks.c **** 	
   4:../FreeRTOS/Source/tasks.c **** 
   5:../FreeRTOS/Source/tasks.c ****     ***************************************************************************
   6:../FreeRTOS/Source/tasks.c ****      *                                                                       *
   7:../FreeRTOS/Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS/Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS/Source/tasks.c ****      *    available.                                                         *
  10:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  11:../FreeRTOS/Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS/Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS/Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS/Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS/Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS/Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  18:../FreeRTOS/Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  20:../FreeRTOS/Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  22:../FreeRTOS/Source/tasks.c ****     ***************************************************************************
  23:../FreeRTOS/Source/tasks.c **** 
  24:../FreeRTOS/Source/tasks.c **** 
  25:../FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS/Source/tasks.c **** 
  27:../FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS/Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS/Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS/Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS/Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS/Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS/Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS/Source/tasks.c ****     FreeRTOS WEB site.
  41:../FreeRTOS/Source/tasks.c **** 
  42:../FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  43:../FreeRTOS/Source/tasks.c **** 
  44:../FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS/Source/tasks.c ****     contact details.
  46:../FreeRTOS/Source/tasks.c **** 
  47:../FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS/Source/tasks.c ****     critical systems.
  49:../FreeRTOS/Source/tasks.c **** 
  50:../FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS/Source/tasks.c ****     licensing and training services.
  52:../FreeRTOS/Source/tasks.c **** */
  53:../FreeRTOS/Source/tasks.c **** 
  54:../FreeRTOS/Source/tasks.c **** 
  55:../FreeRTOS/Source/tasks.c **** #include <stdio.h>
  56:../FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  57:../FreeRTOS/Source/tasks.c **** #include <string.h>
  58:../FreeRTOS/Source/tasks.c **** 
  59:../FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  62:../FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../FreeRTOS/Source/tasks.c **** 
  64:../FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  65:../FreeRTOS/Source/tasks.c **** #include "task.h"
  66:../FreeRTOS/Source/tasks.c **** #include "timers.h"
  67:../FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  68:../FreeRTOS/Source/tasks.c **** 
  69:../FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../FreeRTOS/Source/tasks.c **** 
  71:../FreeRTOS/Source/tasks.c **** /*
  72:../FreeRTOS/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:../FreeRTOS/Source/tasks.c ****  */
  74:../FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:../FreeRTOS/Source/tasks.c **** 
  76:../FreeRTOS/Source/tasks.c **** /*
  77:../FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:../FreeRTOS/Source/tasks.c ****  * and stores the context of the task.
  79:../FreeRTOS/Source/tasks.c ****  */
  80:../FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
  81:../FreeRTOS/Source/tasks.c **** {
  82:../FreeRTOS/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:../FreeRTOS/Source/tasks.c **** 
  84:../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:../FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:../FreeRTOS/Source/tasks.c **** 	#endif	
  87:../FreeRTOS/Source/tasks.c **** 	
  88:../FreeRTOS/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:../FreeRTOS/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:../FreeRTOS/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:../FreeRTOS/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:../FreeRTOS/Source/tasks.c **** 
  94:../FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:../FreeRTOS/Source/tasks.c **** 	#endif
  97:../FreeRTOS/Source/tasks.c **** 
  98:../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:../FreeRTOS/Source/tasks.c **** 	#endif
 101:../FreeRTOS/Source/tasks.c **** 
 102:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 104:../FreeRTOS/Source/tasks.c **** 	#endif
 105:../FreeRTOS/Source/tasks.c **** 
 106:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 107:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 108:../FreeRTOS/Source/tasks.c **** 	#endif
 109:../FreeRTOS/Source/tasks.c **** 
 110:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 111:../FreeRTOS/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 112:../FreeRTOS/Source/tasks.c **** 	#endif
 113:../FreeRTOS/Source/tasks.c **** 
 114:../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 115:../FreeRTOS/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 116:../FreeRTOS/Source/tasks.c **** 	#endif
 117:../FreeRTOS/Source/tasks.c **** 
 118:../FreeRTOS/Source/tasks.c **** } tskTCB;
 119:../FreeRTOS/Source/tasks.c **** 
 120:../FreeRTOS/Source/tasks.c **** 
 121:../FreeRTOS/Source/tasks.c **** /*
 122:../FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 123:../FreeRTOS/Source/tasks.c ****  * than file scope.
 124:../FreeRTOS/Source/tasks.c ****  */
 125:../FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 126:../FreeRTOS/Source/tasks.c **** 	#define static
 127:../FreeRTOS/Source/tasks.c **** #endif
 128:../FreeRTOS/Source/tasks.c **** 
 129:../FreeRTOS/Source/tasks.c **** /*lint -e956 */
 130:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 131:../FreeRTOS/Source/tasks.c **** 
 132:../FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 133:../FreeRTOS/Source/tasks.c **** 
 134:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 135:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 136:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 137:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 138:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 139:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 140:../FreeRTOS/Source/tasks.c **** 
 141:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 142:../FreeRTOS/Source/tasks.c **** 
 143:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 144:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 145:../FreeRTOS/Source/tasks.c **** 
 146:../FreeRTOS/Source/tasks.c **** #endif
 147:../FreeRTOS/Source/tasks.c **** 
 148:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 149:../FreeRTOS/Source/tasks.c **** 
 150:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 151:../FreeRTOS/Source/tasks.c **** 
 152:../FreeRTOS/Source/tasks.c **** #endif
 153:../FreeRTOS/Source/tasks.c **** 
 154:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 155:../FreeRTOS/Source/tasks.c **** 	
 156:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 157:../FreeRTOS/Source/tasks.c **** 	
 158:../FreeRTOS/Source/tasks.c **** #endif
 159:../FreeRTOS/Source/tasks.c **** 
 160:../FreeRTOS/Source/tasks.c **** /* File private variables. --------------------------------*/
 161:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 162:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 163:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 164:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 165:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 166:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 167:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 168:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 169:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 170:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 171:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 172:../FreeRTOS/Source/tasks.c **** 
 173:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 174:../FreeRTOS/Source/tasks.c **** 
 175:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 176:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 177:../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 178:../FreeRTOS/Source/tasks.c **** 
 179:../FreeRTOS/Source/tasks.c **** #endif
 180:../FreeRTOS/Source/tasks.c **** 
 181:../FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 182:../FreeRTOS/Source/tasks.c **** 
 183:../FreeRTOS/Source/tasks.c **** /*
 184:../FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 185:../FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 186:../FreeRTOS/Source/tasks.c ****  */
 187:../FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 188:../FreeRTOS/Source/tasks.c **** 
 189:../FreeRTOS/Source/tasks.c **** /*
 190:../FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 191:../FreeRTOS/Source/tasks.c ****  */
 192:../FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 193:../FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 194:../FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 195:../FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 196:../FreeRTOS/Source/tasks.c **** 
 197:../FreeRTOS/Source/tasks.c **** /*
 198:../FreeRTOS/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 199:../FreeRTOS/Source/tasks.c ****  */
 200:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 201:../FreeRTOS/Source/tasks.c **** 
 202:../FreeRTOS/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 203:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 204:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 205:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 206:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 207:../FreeRTOS/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255U;
 208:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 209:../FreeRTOS/Source/tasks.c **** 
 210:../FreeRTOS/Source/tasks.c **** #endif
 211:../FreeRTOS/Source/tasks.c **** 
 212:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 213:../FreeRTOS/Source/tasks.c **** 
 214:../FreeRTOS/Source/tasks.c **** /*
 215:../FreeRTOS/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 216:../FreeRTOS/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 217:../FreeRTOS/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 218:../FreeRTOS/Source/tasks.c ****  * it if not using the facility.
 219:../FreeRTOS/Source/tasks.c ****  */
 220:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 221:../FreeRTOS/Source/tasks.c **** 
 222:../FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 223:../FreeRTOS/Source/tasks.c **** 	{																								\
 224:../FreeRTOS/Source/tasks.c **** 		if( xTracing != pdFALSE )																	\
 225:../FreeRTOS/Source/tasks.c **** 		{																							\
 226:../FreeRTOS/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 227:../FreeRTOS/Source/tasks.c **** 			{																						\
 228:../FreeRTOS/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 229:../FreeRTOS/Source/tasks.c **** 				{																					\
 230:../FreeRTOS/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 231:../FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;				\
 232:../FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 233:../FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;			\
 234:../FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 235:../FreeRTOS/Source/tasks.c **** 				}																					\
 236:../FreeRTOS/Source/tasks.c **** 				else																				\
 237:../FreeRTOS/Source/tasks.c **** 				{																					\
 238:../FreeRTOS/Source/tasks.c **** 					xTracing = pdFALSE;																\
 239:../FreeRTOS/Source/tasks.c **** 				}																					\
 240:../FreeRTOS/Source/tasks.c **** 			}																						\
 241:../FreeRTOS/Source/tasks.c **** 		}																							\
 242:../FreeRTOS/Source/tasks.c **** 	}
 243:../FreeRTOS/Source/tasks.c **** 
 244:../FreeRTOS/Source/tasks.c **** #else
 245:../FreeRTOS/Source/tasks.c **** 
 246:../FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 247:../FreeRTOS/Source/tasks.c **** 
 248:../FreeRTOS/Source/tasks.c **** #endif
 249:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 250:../FreeRTOS/Source/tasks.c **** 
 251:../FreeRTOS/Source/tasks.c **** /*
 252:../FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 253:../FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 254:../FreeRTOS/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 255:../FreeRTOS/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 256:../FreeRTOS/Source/tasks.c ****  * executing task has been rescheduled.
 257:../FreeRTOS/Source/tasks.c ****  */
 258:../FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 259:../FreeRTOS/Source/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 260:../FreeRTOS/Source/tasks.c **** 	{																													\
 261:../FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 262:../FreeRTOS/Source/tasks.c **** 	}																													\
 263:../FreeRTOS/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 264:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 265:../FreeRTOS/Source/tasks.c **** 
 266:../FreeRTOS/Source/tasks.c **** /*
 267:../FreeRTOS/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 268:../FreeRTOS/Source/tasks.c ****  * any require waking.
 269:../FreeRTOS/Source/tasks.c ****  *
 270:../FreeRTOS/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 271:../FreeRTOS/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 272:../FreeRTOS/Source/tasks.c ****  * any further down the list.
 273:../FreeRTOS/Source/tasks.c ****  */
 274:../FreeRTOS/Source/tasks.c **** #define prvCheckDelayedTasks()															\
 275:../FreeRTOS/Source/tasks.c **** {																						\
 276:../FreeRTOS/Source/tasks.c **** portTickType xItemValue;																\
 277:../FreeRTOS/Source/tasks.c **** 																						\
 278:../FreeRTOS/Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 279:../FreeRTOS/Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 280:../FreeRTOS/Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 281:../FreeRTOS/Source/tasks.c **** 	{																					\
 282:../FreeRTOS/Source/tasks.c **** 		for( ;; )																		\
 283:../FreeRTOS/Source/tasks.c **** 		{																				\
 284:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 285:../FreeRTOS/Source/tasks.c **** 			{																			\
 286:../FreeRTOS/Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 287:../FreeRTOS/Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 288:../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 289:../FreeRTOS/Source/tasks.c **** 				time through. */														\
 290:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 291:../FreeRTOS/Source/tasks.c **** 				break;																	\
 292:../FreeRTOS/Source/tasks.c **** 			}																			\
 293:../FreeRTOS/Source/tasks.c **** 			else																		\
 294:../FreeRTOS/Source/tasks.c **** 			{																			\
 295:../FreeRTOS/Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 296:../FreeRTOS/Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 297:../FreeRTOS/Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 298:../FreeRTOS/Source/tasks.c **** 				the Blocked state. */													\
 299:../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 300:../FreeRTOS/Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 301:../FreeRTOS/Source/tasks.c **** 																						\
 302:../FreeRTOS/Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 303:../FreeRTOS/Source/tasks.c **** 				{																		\
 304:../FreeRTOS/Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 305:../FreeRTOS/Source/tasks.c **** 					value is the time at which the task at the head of the				\
 306:../FreeRTOS/Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 307:../FreeRTOS/Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 308:../FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 309:../FreeRTOS/Source/tasks.c **** 					break;																\
 310:../FreeRTOS/Source/tasks.c **** 				}																		\
 311:../FreeRTOS/Source/tasks.c **** 																						\
 312:../FreeRTOS/Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 313:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 314:../FreeRTOS/Source/tasks.c **** 																						\
 315:../FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 316:../FreeRTOS/Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 317:../FreeRTOS/Source/tasks.c **** 				{																		\
 318:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 319:../FreeRTOS/Source/tasks.c **** 				}																		\
 320:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 321:../FreeRTOS/Source/tasks.c **** 			}																			\
 322:../FreeRTOS/Source/tasks.c **** 		}																				\
 323:../FreeRTOS/Source/tasks.c **** 	}																					\
 324:../FreeRTOS/Source/tasks.c **** }
 325:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 326:../FreeRTOS/Source/tasks.c **** 
 327:../FreeRTOS/Source/tasks.c **** /*
 328:../FreeRTOS/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 329:../FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 330:../FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 331:../FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 332:../FreeRTOS/Source/tasks.c ****  */
 333:../FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 334:../FreeRTOS/Source/tasks.c **** 
 335:../FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 336:../FreeRTOS/Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 337:../FreeRTOS/Source/tasks.c **** extern void vApplicationTickHook( void );
 338:../FreeRTOS/Source/tasks.c **** 		
 339:../FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 340:../FreeRTOS/Source/tasks.c **** 
 341:../FreeRTOS/Source/tasks.c **** /*
 342:../FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 343:../FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 344:../FreeRTOS/Source/tasks.c ****  */
 345:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 346:../FreeRTOS/Source/tasks.c **** 
 347:../FreeRTOS/Source/tasks.c **** /*
 348:../FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 349:../FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 350:../FreeRTOS/Source/tasks.c ****  */
 351:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 352:../FreeRTOS/Source/tasks.c **** 
 353:../FreeRTOS/Source/tasks.c **** /*
 354:../FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 355:../FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 356:../FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 357:../FreeRTOS/Source/tasks.c ****  *
 358:../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 359:../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 360:../FreeRTOS/Source/tasks.c ****  *
 361:../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 362:../FreeRTOS/Source/tasks.c ****  *
 363:../FreeRTOS/Source/tasks.c ****  */
 364:../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 365:../FreeRTOS/Source/tasks.c **** 
 366:../FreeRTOS/Source/tasks.c **** /*
 367:../FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 368:../FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 369:../FreeRTOS/Source/tasks.c ****  *
 370:../FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 371:../FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 372:../FreeRTOS/Source/tasks.c ****  */
 373:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 374:../FreeRTOS/Source/tasks.c **** 
 375:../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 376:../FreeRTOS/Source/tasks.c **** 
 377:../FreeRTOS/Source/tasks.c **** #endif
 378:../FreeRTOS/Source/tasks.c **** 
 379:../FreeRTOS/Source/tasks.c **** /*
 380:../FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 381:../FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 382:../FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 383:../FreeRTOS/Source/tasks.c ****  */
 384:../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 385:../FreeRTOS/Source/tasks.c **** 
 386:../FreeRTOS/Source/tasks.c **** /*
 387:../FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 388:../FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 389:../FreeRTOS/Source/tasks.c ****  */
 390:../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 391:../FreeRTOS/Source/tasks.c **** 
 392:../FreeRTOS/Source/tasks.c **** /*
 393:../FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 394:../FreeRTOS/Source/tasks.c ****  * allocation was successful.
 395:../FreeRTOS/Source/tasks.c ****  */
 396:../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 397:../FreeRTOS/Source/tasks.c **** 
 398:../FreeRTOS/Source/tasks.c **** /*
 399:../FreeRTOS/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 400:../FreeRTOS/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 401:../FreeRTOS/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 402:../FreeRTOS/Source/tasks.c ****  * within just that list.
 403:../FreeRTOS/Source/tasks.c ****  *
 404:../FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 405:../FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 406:../FreeRTOS/Source/tasks.c ****  */
 407:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 408:../FreeRTOS/Source/tasks.c **** 
 409:../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 410:../FreeRTOS/Source/tasks.c **** 
 411:../FreeRTOS/Source/tasks.c **** #endif
 412:../FreeRTOS/Source/tasks.c **** 
 413:../FreeRTOS/Source/tasks.c **** /*
 414:../FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 415:../FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 416:../FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 417:../FreeRTOS/Source/tasks.c ****  */
 418:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 419:../FreeRTOS/Source/tasks.c **** 
 420:../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 421:../FreeRTOS/Source/tasks.c **** 
 422:../FreeRTOS/Source/tasks.c **** #endif
 423:../FreeRTOS/Source/tasks.c **** 
 424:../FreeRTOS/Source/tasks.c **** 
 425:../FreeRTOS/Source/tasks.c **** /*lint +e956 */
 426:../FreeRTOS/Source/tasks.c **** 
 427:../FreeRTOS/Source/tasks.c **** 
 428:../FreeRTOS/Source/tasks.c **** 
 429:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 430:../FreeRTOS/Source/tasks.c ****  * TASK CREATION API documented in task.h
 431:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 432:../FreeRTOS/Source/tasks.c **** 
 433:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 434:../FreeRTOS/Source/tasks.c **** {
 435:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 436:../FreeRTOS/Source/tasks.c **** tskTCB * pxNewTCB;
 437:../FreeRTOS/Source/tasks.c **** 
 438:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 439:../FreeRTOS/Source/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 440:../FreeRTOS/Source/tasks.c **** 
 441:../FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 442:../FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 443:../FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 444:../FreeRTOS/Source/tasks.c **** 
 445:../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 446:../FreeRTOS/Source/tasks.c **** 	{
 447:../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 448:../FreeRTOS/Source/tasks.c **** 
 449:../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 450:../FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 451:../FreeRTOS/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 452:../FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 453:../FreeRTOS/Source/tasks.c **** 			{
 454:../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 455:../FreeRTOS/Source/tasks.c **** 			}
 456:../FreeRTOS/Source/tasks.c **** 			else
 457:../FreeRTOS/Source/tasks.c **** 			{
 458:../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 459:../FreeRTOS/Source/tasks.c **** 			}
 460:../FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 461:../FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 462:../FreeRTOS/Source/tasks.c **** 
 463:../FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 464:../FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 465:../FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 466:../FreeRTOS/Source/tasks.c **** 		required by the port. */
 467:../FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 468:../FreeRTOS/Source/tasks.c **** 		{
 469:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 470:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 471:../FreeRTOS/Source/tasks.c **** 
 472:../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 473:../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 474:../FreeRTOS/Source/tasks.c **** 		}
 475:../FreeRTOS/Source/tasks.c **** 		#else
 476:../FreeRTOS/Source/tasks.c **** 		{
 477:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 478:../FreeRTOS/Source/tasks.c **** 			
 479:../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 480:../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 481:../FreeRTOS/Source/tasks.c **** 
 482:../FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 483:../FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 484:../FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 485:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 486:../FreeRTOS/Source/tasks.c **** 		}
 487:../FreeRTOS/Source/tasks.c **** 		#endif
 488:../FreeRTOS/Source/tasks.c **** 
 489:../FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 490:../FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 491:../FreeRTOS/Source/tasks.c **** 
 492:../FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 493:../FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 494:../FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 495:../FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 496:../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 497:../FreeRTOS/Source/tasks.c **** 		{
 498:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 499:../FreeRTOS/Source/tasks.c **** 		}
 500:../FreeRTOS/Source/tasks.c **** 		#else
 501:../FreeRTOS/Source/tasks.c **** 		{
 502:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 503:../FreeRTOS/Source/tasks.c **** 		}
 504:../FreeRTOS/Source/tasks.c **** 		#endif
 505:../FreeRTOS/Source/tasks.c **** 
 506:../FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 507:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT
 508:../FreeRTOS/Source/tasks.c **** 
 509:../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 510:../FreeRTOS/Source/tasks.c **** 		{
 511:../FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 512:../FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 513:../FreeRTOS/Source/tasks.c **** 			required.*/
 514:../FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 515:../FreeRTOS/Source/tasks.c **** 		}
 516:../FreeRTOS/Source/tasks.c **** 		
 517:../FreeRTOS/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 518:../FreeRTOS/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 519:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 520:../FreeRTOS/Source/tasks.c **** 		{
 521:../FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 522:../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 523:../FreeRTOS/Source/tasks.c **** 			{
 524:../FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 525:../FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 526:../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 527:../FreeRTOS/Source/tasks.c **** 
 528:../FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 529:../FreeRTOS/Source/tasks.c **** 				{
 530:../FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 531:../FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 532:../FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 533:../FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 534:../FreeRTOS/Source/tasks.c **** 				}
 535:../FreeRTOS/Source/tasks.c **** 			}
 536:../FreeRTOS/Source/tasks.c **** 			else
 537:../FreeRTOS/Source/tasks.c **** 			{
 538:../FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 539:../FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 540:../FreeRTOS/Source/tasks.c **** 				so far. */
 541:../FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 542:../FreeRTOS/Source/tasks.c **** 				{
 543:../FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 544:../FreeRTOS/Source/tasks.c **** 					{
 545:../FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 546:../FreeRTOS/Source/tasks.c **** 					}
 547:../FreeRTOS/Source/tasks.c **** 				}
 548:../FreeRTOS/Source/tasks.c **** 			}
 549:../FreeRTOS/Source/tasks.c **** 
 550:../FreeRTOS/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 551:../FreeRTOS/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 552:../FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 553:../FreeRTOS/Source/tasks.c **** 			{
 554:../FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 555:../FreeRTOS/Source/tasks.c **** 			}
 556:../FreeRTOS/Source/tasks.c **** 
 557:../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 558:../FreeRTOS/Source/tasks.c **** 			{
 559:../FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 560:../FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 561:../FreeRTOS/Source/tasks.c **** 			}
 562:../FreeRTOS/Source/tasks.c **** 			#endif
 563:../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 564:../FreeRTOS/Source/tasks.c **** 
 565:../FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 566:../FreeRTOS/Source/tasks.c **** 
 567:../FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 568:../FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 569:../FreeRTOS/Source/tasks.c **** 		}
 570:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 571:../FreeRTOS/Source/tasks.c **** 	}
 572:../FreeRTOS/Source/tasks.c **** 	else
 573:../FreeRTOS/Source/tasks.c **** 	{
 574:../FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 575:../FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 576:../FreeRTOS/Source/tasks.c **** 	}
 577:../FreeRTOS/Source/tasks.c **** 
 578:../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 579:../FreeRTOS/Source/tasks.c **** 	{
 580:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 581:../FreeRTOS/Source/tasks.c **** 		{
 582:../FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 583:../FreeRTOS/Source/tasks.c **** 			then it should run now. */
 584:../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 585:../FreeRTOS/Source/tasks.c **** 			{
 586:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 587:../FreeRTOS/Source/tasks.c **** 			}
 588:../FreeRTOS/Source/tasks.c **** 		}
 589:../FreeRTOS/Source/tasks.c **** 	}
 590:../FreeRTOS/Source/tasks.c **** 
 591:../FreeRTOS/Source/tasks.c **** 	return xReturn;
 592:../FreeRTOS/Source/tasks.c **** }
 593:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 594:../FreeRTOS/Source/tasks.c **** 
 595:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 596:../FreeRTOS/Source/tasks.c **** 
 597:../FreeRTOS/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 598:../FreeRTOS/Source/tasks.c **** 	{
 599:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 600:../FreeRTOS/Source/tasks.c **** 
 601:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 602:../FreeRTOS/Source/tasks.c **** 		{
 603:../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 604:../FreeRTOS/Source/tasks.c **** 			deleted. */
 605:../FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 606:../FreeRTOS/Source/tasks.c **** 			{
 607:../FreeRTOS/Source/tasks.c **** 				pxTaskToDelete = NULL;
 608:../FreeRTOS/Source/tasks.c **** 			}
 609:../FreeRTOS/Source/tasks.c **** 
 610:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 611:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 612:../FreeRTOS/Source/tasks.c **** 
 613:../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 614:../FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 615:../FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 616:../FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 617:../FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 618:../FreeRTOS/Source/tasks.c **** 
 619:../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 620:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 621:../FreeRTOS/Source/tasks.c **** 			{
 622:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 623:../FreeRTOS/Source/tasks.c **** 			}
 624:../FreeRTOS/Source/tasks.c **** 
 625:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 626:../FreeRTOS/Source/tasks.c **** 
 627:../FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 628:../FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 629:../FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 630:../FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 631:../FreeRTOS/Source/tasks.c **** 
 632:../FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 633:../FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 634:../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 635:../FreeRTOS/Source/tasks.c **** 
 636:../FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 637:../FreeRTOS/Source/tasks.c **** 		}
 638:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 639:../FreeRTOS/Source/tasks.c **** 
 640:../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 641:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 642:../FreeRTOS/Source/tasks.c **** 		{
 643:../FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 644:../FreeRTOS/Source/tasks.c **** 			{
 645:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 646:../FreeRTOS/Source/tasks.c **** 			}
 647:../FreeRTOS/Source/tasks.c **** 		}
 648:../FreeRTOS/Source/tasks.c **** 	}
 649:../FreeRTOS/Source/tasks.c **** 
 650:../FreeRTOS/Source/tasks.c **** #endif
 651:../FreeRTOS/Source/tasks.c **** 
 652:../FreeRTOS/Source/tasks.c **** 
 653:../FreeRTOS/Source/tasks.c **** 
 654:../FreeRTOS/Source/tasks.c **** 
 655:../FreeRTOS/Source/tasks.c **** 
 656:../FreeRTOS/Source/tasks.c **** 
 657:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 658:../FreeRTOS/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 659:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 660:../FreeRTOS/Source/tasks.c **** 
 661:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 662:../FreeRTOS/Source/tasks.c **** 
 663:../FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 664:../FreeRTOS/Source/tasks.c **** 	{
 665:../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 666:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 667:../FreeRTOS/Source/tasks.c **** 
 668:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 669:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 670:../FreeRTOS/Source/tasks.c **** 
 671:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 672:../FreeRTOS/Source/tasks.c **** 		{
 673:../FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 674:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 675:../FreeRTOS/Source/tasks.c **** 
 676:../FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 677:../FreeRTOS/Source/tasks.c **** 			{
 678:../FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 679:../FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 680:../FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 681:../FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 682:../FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 683:../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 684:../FreeRTOS/Source/tasks.c **** 				{
 685:../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 686:../FreeRTOS/Source/tasks.c **** 				}
 687:../FreeRTOS/Source/tasks.c **** 			}
 688:../FreeRTOS/Source/tasks.c **** 			else
 689:../FreeRTOS/Source/tasks.c **** 			{
 690:../FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 691:../FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 692:../FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 693:../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 694:../FreeRTOS/Source/tasks.c **** 				{
 695:../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 696:../FreeRTOS/Source/tasks.c **** 				}
 697:../FreeRTOS/Source/tasks.c **** 			}
 698:../FreeRTOS/Source/tasks.c **** 
 699:../FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 700:../FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 701:../FreeRTOS/Source/tasks.c **** 
 702:../FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 703:../FreeRTOS/Source/tasks.c **** 			{
 704:../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 705:../FreeRTOS/Source/tasks.c **** 
 706:../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 707:../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 708:../FreeRTOS/Source/tasks.c **** 				both lists. */
 709:../FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 710:../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 711:../FreeRTOS/Source/tasks.c **** 			}
 712:../FreeRTOS/Source/tasks.c **** 		}
 713:../FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 714:../FreeRTOS/Source/tasks.c **** 
 715:../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 716:../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 717:../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 718:../FreeRTOS/Source/tasks.c **** 		{
 719:../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 720:../FreeRTOS/Source/tasks.c **** 		}
 721:../FreeRTOS/Source/tasks.c **** 	}
 722:../FreeRTOS/Source/tasks.c **** 
 723:../FreeRTOS/Source/tasks.c **** #endif
 724:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 725:../FreeRTOS/Source/tasks.c **** 
 726:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 727:../FreeRTOS/Source/tasks.c **** 
 728:../FreeRTOS/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 729:../FreeRTOS/Source/tasks.c **** 	{
 730:../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 731:../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 732:../FreeRTOS/Source/tasks.c **** 
 733:../FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 734:../FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 735:../FreeRTOS/Source/tasks.c **** 		{
 736:../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 737:../FreeRTOS/Source/tasks.c **** 			{
 738:../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 739:../FreeRTOS/Source/tasks.c **** 
 740:../FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 741:../FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 742:../FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 743:../FreeRTOS/Source/tasks.c **** 				is resumed.
 744:../FreeRTOS/Source/tasks.c **** 
 745:../FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 746:../FreeRTOS/Source/tasks.c **** 				executing task. */
 747:../FreeRTOS/Source/tasks.c **** 
 748:../FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 749:../FreeRTOS/Source/tasks.c **** 				not a problem. */
 750:../FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 751:../FreeRTOS/Source/tasks.c **** 
 752:../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 753:../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 754:../FreeRTOS/Source/tasks.c **** 				both lists. */
 755:../FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 756:../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 757:../FreeRTOS/Source/tasks.c **** 			}
 758:../FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 759:../FreeRTOS/Source/tasks.c **** 		}
 760:../FreeRTOS/Source/tasks.c **** 
 761:../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 762:../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 763:../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 764:../FreeRTOS/Source/tasks.c **** 		{
 765:../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 766:../FreeRTOS/Source/tasks.c **** 		}
 767:../FreeRTOS/Source/tasks.c **** 	}
 768:../FreeRTOS/Source/tasks.c **** 
 769:../FreeRTOS/Source/tasks.c **** #endif
 770:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 771:../FreeRTOS/Source/tasks.c **** 
 772:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 773:../FreeRTOS/Source/tasks.c **** 
 774:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 775:../FreeRTOS/Source/tasks.c **** 	{
 776:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 777:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 778:../FreeRTOS/Source/tasks.c **** 
 779:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 780:../FreeRTOS/Source/tasks.c **** 		{
 781:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 782:../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 783:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 784:../FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 785:../FreeRTOS/Source/tasks.c **** 		}
 786:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 787:../FreeRTOS/Source/tasks.c **** 
 788:../FreeRTOS/Source/tasks.c **** 		return uxReturn;
 789:../FreeRTOS/Source/tasks.c **** 	}
 790:../FreeRTOS/Source/tasks.c **** 
 791:../FreeRTOS/Source/tasks.c **** #endif
 792:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 793:../FreeRTOS/Source/tasks.c **** 
 794:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 795:../FreeRTOS/Source/tasks.c **** 
 796:../FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 797:../FreeRTOS/Source/tasks.c **** 	{
 798:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 799:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 800:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 801:../FreeRTOS/Source/tasks.c **** 
 802:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 803:../FreeRTOS/Source/tasks.c **** 
 804:../FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 805:../FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 806:../FreeRTOS/Source/tasks.c **** 		{
 807:../FreeRTOS/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 808:../FreeRTOS/Source/tasks.c **** 		}
 809:../FreeRTOS/Source/tasks.c **** 
 810:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 811:../FreeRTOS/Source/tasks.c **** 		{
 812:../FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 813:../FreeRTOS/Source/tasks.c **** 			{
 814:../FreeRTOS/Source/tasks.c **** 				pxTask = NULL;
 815:../FreeRTOS/Source/tasks.c **** 			}
 816:../FreeRTOS/Source/tasks.c **** 
 817:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 818:../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 819:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 820:../FreeRTOS/Source/tasks.c **** 
 821:../FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 822:../FreeRTOS/Source/tasks.c **** 
 823:../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 824:../FreeRTOS/Source/tasks.c **** 			{
 825:../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 826:../FreeRTOS/Source/tasks.c **** 			}
 827:../FreeRTOS/Source/tasks.c **** 			#else
 828:../FreeRTOS/Source/tasks.c **** 			{
 829:../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 830:../FreeRTOS/Source/tasks.c **** 			}
 831:../FreeRTOS/Source/tasks.c **** 			#endif
 832:../FreeRTOS/Source/tasks.c **** 
 833:../FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 834:../FreeRTOS/Source/tasks.c **** 			{
 835:../FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 836:../FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
 837:../FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 838:../FreeRTOS/Source/tasks.c **** 				{
 839:../FreeRTOS/Source/tasks.c **** 					if( pxTask != NULL )
 840:../FreeRTOS/Source/tasks.c **** 					{
 841:../FreeRTOS/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 842:../FreeRTOS/Source/tasks.c **** 						were raising the priority of the currently running task
 843:../FreeRTOS/Source/tasks.c **** 						there would be no need to switch as it must have already
 844:../FreeRTOS/Source/tasks.c **** 						been the highest priority task. */
 845:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 846:../FreeRTOS/Source/tasks.c **** 					}
 847:../FreeRTOS/Source/tasks.c **** 				}
 848:../FreeRTOS/Source/tasks.c **** 				else if( pxTask == NULL )
 849:../FreeRTOS/Source/tasks.c **** 				{
 850:../FreeRTOS/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 851:../FreeRTOS/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 852:../FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 853:../FreeRTOS/Source/tasks.c **** 				}
 854:../FreeRTOS/Source/tasks.c **** 
 855:../FreeRTOS/Source/tasks.c **** 
 856:../FreeRTOS/Source/tasks.c **** 
 857:../FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 858:../FreeRTOS/Source/tasks.c **** 				{
 859:../FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 860:../FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
 861:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 862:../FreeRTOS/Source/tasks.c **** 					{
 863:../FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 864:../FreeRTOS/Source/tasks.c **** 					}
 865:../FreeRTOS/Source/tasks.c **** 
 866:../FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
 867:../FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 868:../FreeRTOS/Source/tasks.c **** 				}
 869:../FreeRTOS/Source/tasks.c **** 				#else
 870:../FreeRTOS/Source/tasks.c **** 				{
 871:../FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 872:../FreeRTOS/Source/tasks.c **** 				}
 873:../FreeRTOS/Source/tasks.c **** 				#endif
 874:../FreeRTOS/Source/tasks.c **** 
 875:../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 876:../FreeRTOS/Source/tasks.c **** 
 877:../FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 878:../FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 879:../FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 880:../FreeRTOS/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 881:../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 882:../FreeRTOS/Source/tasks.c **** 				{
 883:../FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 884:../FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 885:../FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 886:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 887:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 888:../FreeRTOS/Source/tasks.c **** 				}
 889:../FreeRTOS/Source/tasks.c **** 
 890:../FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 891:../FreeRTOS/Source/tasks.c **** 				{
 892:../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 893:../FreeRTOS/Source/tasks.c **** 				}
 894:../FreeRTOS/Source/tasks.c **** 			}
 895:../FreeRTOS/Source/tasks.c **** 		}
 896:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 897:../FreeRTOS/Source/tasks.c **** 	}
 898:../FreeRTOS/Source/tasks.c **** 
 899:../FreeRTOS/Source/tasks.c **** #endif
 900:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 901:../FreeRTOS/Source/tasks.c **** 
 902:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 903:../FreeRTOS/Source/tasks.c **** 
 904:../FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 905:../FreeRTOS/Source/tasks.c **** 	{
 906:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 907:../FreeRTOS/Source/tasks.c **** 
 908:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 909:../FreeRTOS/Source/tasks.c **** 		{
 910:../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 911:../FreeRTOS/Source/tasks.c **** 			suspended. */
 912:../FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 913:../FreeRTOS/Source/tasks.c **** 			{
 914:../FreeRTOS/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 915:../FreeRTOS/Source/tasks.c **** 			}
 916:../FreeRTOS/Source/tasks.c **** 
 917:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 918:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 919:../FreeRTOS/Source/tasks.c **** 
 920:../FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 921:../FreeRTOS/Source/tasks.c **** 
 922:../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 923:../FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 924:../FreeRTOS/Source/tasks.c **** 
 925:../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 926:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 927:../FreeRTOS/Source/tasks.c **** 			{
 928:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 929:../FreeRTOS/Source/tasks.c **** 			}
 930:../FreeRTOS/Source/tasks.c **** 
 931:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 932:../FreeRTOS/Source/tasks.c **** 		}
 933:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 934:../FreeRTOS/Source/tasks.c **** 
 935:../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 936:../FreeRTOS/Source/tasks.c **** 		{
 937:../FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 938:../FreeRTOS/Source/tasks.c **** 			{
 939:../FreeRTOS/Source/tasks.c **** 				/* We have just suspended the current task. */
 940:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 941:../FreeRTOS/Source/tasks.c **** 			}
 942:../FreeRTOS/Source/tasks.c **** 			else
 943:../FreeRTOS/Source/tasks.c **** 			{
 944:../FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 945:../FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 946:../FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
 947:../FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 948:../FreeRTOS/Source/tasks.c **** 				{
 949:../FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 950:../FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 951:../FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
 952:../FreeRTOS/Source/tasks.c **** 					is. */
 953:../FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 954:../FreeRTOS/Source/tasks.c **** 				}
 955:../FreeRTOS/Source/tasks.c **** 				else
 956:../FreeRTOS/Source/tasks.c **** 				{
 957:../FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 958:../FreeRTOS/Source/tasks.c **** 				}
 959:../FreeRTOS/Source/tasks.c **** 			}
 960:../FreeRTOS/Source/tasks.c **** 		}
 961:../FreeRTOS/Source/tasks.c **** 	}
 962:../FreeRTOS/Source/tasks.c **** 
 963:../FreeRTOS/Source/tasks.c **** #endif
 964:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 965:../FreeRTOS/Source/tasks.c **** 
 966:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 967:../FreeRTOS/Source/tasks.c **** 
 968:../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 969:../FreeRTOS/Source/tasks.c **** 	{
 970:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 971:../FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 972:../FreeRTOS/Source/tasks.c **** 
 973:../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 974:../FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
 975:../FreeRTOS/Source/tasks.c **** 
 976:../FreeRTOS/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 977:../FreeRTOS/Source/tasks.c **** 		suspended list? */
 978:../FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 979:../FreeRTOS/Source/tasks.c **** 		{
 980:../FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 981:../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 982:../FreeRTOS/Source/tasks.c **** 			{
 983:../FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 984:../FreeRTOS/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 985:../FreeRTOS/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 986:../FreeRTOS/Source/tasks.c **** 				specified. */
 987:../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 988:../FreeRTOS/Source/tasks.c **** 				{
 989:../FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 990:../FreeRTOS/Source/tasks.c **** 				}
 991:../FreeRTOS/Source/tasks.c **** 			}
 992:../FreeRTOS/Source/tasks.c **** 		}
 993:../FreeRTOS/Source/tasks.c **** 
 994:../FreeRTOS/Source/tasks.c **** 		return xReturn;
 995:../FreeRTOS/Source/tasks.c **** 	}
 996:../FreeRTOS/Source/tasks.c **** 
 997:../FreeRTOS/Source/tasks.c **** #endif
 998:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 999:../FreeRTOS/Source/tasks.c **** 
1000:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1001:../FreeRTOS/Source/tasks.c **** 
1002:../FreeRTOS/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1003:../FreeRTOS/Source/tasks.c **** 	{
1004:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1005:../FreeRTOS/Source/tasks.c **** 
1006:../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1007:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1008:../FreeRTOS/Source/tasks.c **** 
1009:../FreeRTOS/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1010:../FreeRTOS/Source/tasks.c **** 		it in the ready list. */
1011:../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
1012:../FreeRTOS/Source/tasks.c **** 
1013:../FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1014:../FreeRTOS/Source/tasks.c **** 		currently executing task. */
1015:../FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1016:../FreeRTOS/Source/tasks.c **** 		{
1017:../FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1018:../FreeRTOS/Source/tasks.c **** 			{
1019:../FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1020:../FreeRTOS/Source/tasks.c **** 				{
1021:../FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1022:../FreeRTOS/Source/tasks.c **** 
1023:../FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1024:../FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1025:../FreeRTOS/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
1026:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1027:../FreeRTOS/Source/tasks.c **** 
1028:../FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1029:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1030:../FreeRTOS/Source/tasks.c **** 					{
1031:../FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1032:../FreeRTOS/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1033:../FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
1034:../FreeRTOS/Source/tasks.c **** 					}
1035:../FreeRTOS/Source/tasks.c **** 				}
1036:../FreeRTOS/Source/tasks.c **** 			}
1037:../FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1038:../FreeRTOS/Source/tasks.c **** 		}
1039:../FreeRTOS/Source/tasks.c **** 	}
1040:../FreeRTOS/Source/tasks.c **** 
1041:../FreeRTOS/Source/tasks.c **** #endif
1042:../FreeRTOS/Source/tasks.c **** 
1043:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1044:../FreeRTOS/Source/tasks.c **** 
1045:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1046:../FreeRTOS/Source/tasks.c **** 
1047:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1048:../FreeRTOS/Source/tasks.c **** 	{
1049:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
1050:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1051:../FreeRTOS/Source/tasks.c **** 
1052:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1053:../FreeRTOS/Source/tasks.c **** 
1054:../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
1055:../FreeRTOS/Source/tasks.c **** 
1056:../FreeRTOS/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1057:../FreeRTOS/Source/tasks.c **** 		{
1058:../FreeRTOS/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
1059:../FreeRTOS/Source/tasks.c **** 
1060:../FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1061:../FreeRTOS/Source/tasks.c **** 			{
1062:../FreeRTOS/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
1063:../FreeRTOS/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
1064:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
1065:../FreeRTOS/Source/tasks.c **** 			}
1066:../FreeRTOS/Source/tasks.c **** 			else
1067:../FreeRTOS/Source/tasks.c **** 			{
1068:../FreeRTOS/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1069:../FreeRTOS/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1070:../FreeRTOS/Source/tasks.c **** 				yield will be performed if necessary. */
1071:../FreeRTOS/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1072:../FreeRTOS/Source/tasks.c **** 			}
1073:../FreeRTOS/Source/tasks.c **** 		}
1074:../FreeRTOS/Source/tasks.c **** 
1075:../FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1076:../FreeRTOS/Source/tasks.c **** 	}
1077:../FreeRTOS/Source/tasks.c **** 
1078:../FreeRTOS/Source/tasks.c **** #endif
1079:../FreeRTOS/Source/tasks.c **** 
1080:../FreeRTOS/Source/tasks.c **** 
1081:../FreeRTOS/Source/tasks.c **** 
1082:../FreeRTOS/Source/tasks.c **** 
1083:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1084:../FreeRTOS/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1085:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1086:../FreeRTOS/Source/tasks.c **** 
1087:../FreeRTOS/Source/tasks.c **** 
1088:../FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1089:../FreeRTOS/Source/tasks.c **** {
1090:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1091:../FreeRTOS/Source/tasks.c **** 
1092:../FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1093:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1094:../FreeRTOS/Source/tasks.c **** 	{
1095:../FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1096:../FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1097:../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1098:../FreeRTOS/Source/tasks.c **** 	}
1099:../FreeRTOS/Source/tasks.c **** 	#else
1100:../FreeRTOS/Source/tasks.c **** 	{
1101:../FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1102:../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1103:../FreeRTOS/Source/tasks.c **** 	}
1104:../FreeRTOS/Source/tasks.c **** 	#endif
1105:../FreeRTOS/Source/tasks.c **** 
1106:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1107:../FreeRTOS/Source/tasks.c **** 	{
1108:../FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1109:../FreeRTOS/Source/tasks.c **** 		{
1110:../FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1111:../FreeRTOS/Source/tasks.c **** 		}
1112:../FreeRTOS/Source/tasks.c **** 	}
1113:../FreeRTOS/Source/tasks.c **** 	#endif
1114:../FreeRTOS/Source/tasks.c **** 
1115:../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
1116:../FreeRTOS/Source/tasks.c **** 	{
1117:../FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1118:../FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1119:../FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1120:../FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1121:../FreeRTOS/Source/tasks.c **** 		starts to run.
1122:../FreeRTOS/Source/tasks.c **** 
1123:../FreeRTOS/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1124:../FreeRTOS/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1125:../FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1126:../FreeRTOS/Source/tasks.c **** 
1127:../FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1128:../FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
1129:../FreeRTOS/Source/tasks.c **** 
1130:../FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1131:../FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1132:../FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1133:../FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1134:../FreeRTOS/Source/tasks.c **** 		
1135:../FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1136:../FreeRTOS/Source/tasks.c **** 		portable interface. */
1137:../FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1138:../FreeRTOS/Source/tasks.c **** 		{
1139:../FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1140:../FreeRTOS/Source/tasks.c **** 			function will not return. */
1141:../FreeRTOS/Source/tasks.c **** 		}
1142:../FreeRTOS/Source/tasks.c **** 		else
1143:../FreeRTOS/Source/tasks.c **** 		{
1144:../FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1145:../FreeRTOS/Source/tasks.c **** 		}
1146:../FreeRTOS/Source/tasks.c **** 	}
1147:../FreeRTOS/Source/tasks.c **** 
1148:../FreeRTOS/Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1149:../FreeRTOS/Source/tasks.c **** 	configASSERT( xReturn );
1150:../FreeRTOS/Source/tasks.c **** }
1151:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1152:../FreeRTOS/Source/tasks.c **** 
1153:../FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1154:../FreeRTOS/Source/tasks.c **** {
1155:../FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1156:../FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1157:../FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1158:../FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1159:../FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1160:../FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
1161:../FreeRTOS/Source/tasks.c **** }
1162:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1163:../FreeRTOS/Source/tasks.c **** 
1164:../FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1165:../FreeRTOS/Source/tasks.c **** {
1166:../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1167:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1168:../FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
1169:../FreeRTOS/Source/tasks.c **** }
1170:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1171:../FreeRTOS/Source/tasks.c **** 
1172:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1173:../FreeRTOS/Source/tasks.c **** {
1174:../FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
1175:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1176:../FreeRTOS/Source/tasks.c **** 
1177:../FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1178:../FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1179:../FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1180:../FreeRTOS/Source/tasks.c **** 
1181:../FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1182:../FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1183:../FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1184:../FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1185:../FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1186:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1187:../FreeRTOS/Source/tasks.c **** 	{
1188:../FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
1189:../FreeRTOS/Source/tasks.c **** 
1190:../FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1191:../FreeRTOS/Source/tasks.c **** 		{
1192:../FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
1193:../FreeRTOS/Source/tasks.c **** 			{
1194:../FreeRTOS/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1195:../FreeRTOS/Source/tasks.c **** 
1196:../FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1197:../FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1198:../FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
1199:../FreeRTOS/Source/tasks.c **** 				{
1200:../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
1201:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
1202:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1203:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1204:../FreeRTOS/Source/tasks.c **** 
1205:../FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1206:../FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1207:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1208:../FreeRTOS/Source/tasks.c **** 					{
1209:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1210:../FreeRTOS/Source/tasks.c **** 					}
1211:../FreeRTOS/Source/tasks.c **** 				}
1212:../FreeRTOS/Source/tasks.c **** 
1213:../FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1214:../FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1215:../FreeRTOS/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1216:../FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
1217:../FreeRTOS/Source/tasks.c **** 				{
1218:../FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
1219:../FreeRTOS/Source/tasks.c **** 					{
1220:../FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
1221:../FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
1222:../FreeRTOS/Source/tasks.c **** 					}
1223:../FreeRTOS/Source/tasks.c **** 
1224:../FreeRTOS/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1225:../FreeRTOS/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1226:../FreeRTOS/Source/tasks.c **** 					the task actually running. */
1227:../FreeRTOS/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1228:../FreeRTOS/Source/tasks.c **** 					{
1229:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1230:../FreeRTOS/Source/tasks.c **** 					}
1231:../FreeRTOS/Source/tasks.c **** 					#endif
1232:../FreeRTOS/Source/tasks.c **** 				}
1233:../FreeRTOS/Source/tasks.c **** 
1234:../FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1235:../FreeRTOS/Source/tasks.c **** 				{
1236:../FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
1237:../FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
1238:../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
1239:../FreeRTOS/Source/tasks.c **** 				}
1240:../FreeRTOS/Source/tasks.c **** 			}
1241:../FreeRTOS/Source/tasks.c **** 		}
1242:../FreeRTOS/Source/tasks.c **** 	}
1243:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1244:../FreeRTOS/Source/tasks.c **** 
1245:../FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
1246:../FreeRTOS/Source/tasks.c **** }
1247:../FreeRTOS/Source/tasks.c **** 
1248:../FreeRTOS/Source/tasks.c **** 
1249:../FreeRTOS/Source/tasks.c **** 
1250:../FreeRTOS/Source/tasks.c **** 
1251:../FreeRTOS/Source/tasks.c **** 
1252:../FreeRTOS/Source/tasks.c **** 
1253:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1254:../FreeRTOS/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1255:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1256:../FreeRTOS/Source/tasks.c **** 
1257:../FreeRTOS/Source/tasks.c **** 
1258:../FreeRTOS/Source/tasks.c **** 
1259:../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1260:../FreeRTOS/Source/tasks.c **** {
1261:../FreeRTOS/Source/tasks.c **** portTickType xTicks;
1262:../FreeRTOS/Source/tasks.c **** 
1263:../FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1264:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1265:../FreeRTOS/Source/tasks.c **** 	{
1266:../FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
1267:../FreeRTOS/Source/tasks.c **** 	}
1268:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1269:../FreeRTOS/Source/tasks.c **** 
1270:../FreeRTOS/Source/tasks.c **** 	return xTicks;
1271:../FreeRTOS/Source/tasks.c **** }
1272:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1273:../FreeRTOS/Source/tasks.c **** 
1274:../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1275:../FreeRTOS/Source/tasks.c **** {
1276:../FreeRTOS/Source/tasks.c **** portTickType xReturn;
1277:../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1278:../FreeRTOS/Source/tasks.c **** 
1279:../FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1280:../FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
1281:../FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1282:../FreeRTOS/Source/tasks.c **** 
1283:../FreeRTOS/Source/tasks.c **** 	return xReturn;
1284:../FreeRTOS/Source/tasks.c **** }
1285:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1286:../FreeRTOS/Source/tasks.c **** 
1287:../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1288:../FreeRTOS/Source/tasks.c **** {
1289:../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1290:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1291:../FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1292:../FreeRTOS/Source/tasks.c **** }
1293:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1294:../FreeRTOS/Source/tasks.c **** 
1295:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1296:../FreeRTOS/Source/tasks.c **** 
1297:../FreeRTOS/Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1298:../FreeRTOS/Source/tasks.c **** 	{
1299:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1300:../FreeRTOS/Source/tasks.c **** 
1301:../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1302:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1303:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1304:../FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1305:../FreeRTOS/Source/tasks.c **** 	}
1306:../FreeRTOS/Source/tasks.c **** 
1307:../FreeRTOS/Source/tasks.c **** #endif
1308:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1309:../FreeRTOS/Source/tasks.c **** 
1310:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1311:../FreeRTOS/Source/tasks.c **** 
1312:../FreeRTOS/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1313:../FreeRTOS/Source/tasks.c **** 	{
1314:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1315:../FreeRTOS/Source/tasks.c **** 
1316:../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1317:../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1318:../FreeRTOS/Source/tasks.c **** 
1319:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1320:../FreeRTOS/Source/tasks.c **** 		{
1321:../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1322:../FreeRTOS/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1323:../FreeRTOS/Source/tasks.c **** 
1324:../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1325:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1326:../FreeRTOS/Source/tasks.c **** 
1327:../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1328:../FreeRTOS/Source/tasks.c **** 
1329:../FreeRTOS/Source/tasks.c **** 			do
1330:../FreeRTOS/Source/tasks.c **** 			{
1331:../FreeRTOS/Source/tasks.c **** 				uxQueue--;
1332:../FreeRTOS/Source/tasks.c **** 
1333:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1334:../FreeRTOS/Source/tasks.c **** 				{
1335:../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1336:../FreeRTOS/Source/tasks.c **** 				}
1337:../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1338:../FreeRTOS/Source/tasks.c **** 
1339:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1340:../FreeRTOS/Source/tasks.c **** 			{
1341:../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1342:../FreeRTOS/Source/tasks.c **** 			}
1343:../FreeRTOS/Source/tasks.c **** 
1344:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1345:../FreeRTOS/Source/tasks.c **** 			{
1346:../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1347:../FreeRTOS/Source/tasks.c **** 			}
1348:../FreeRTOS/Source/tasks.c **** 
1349:../FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1350:../FreeRTOS/Source/tasks.c **** 			{
1351:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1352:../FreeRTOS/Source/tasks.c **** 				{
1353:../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1354:../FreeRTOS/Source/tasks.c **** 				}
1355:../FreeRTOS/Source/tasks.c **** 			}
1356:../FreeRTOS/Source/tasks.c **** 			#endif
1357:../FreeRTOS/Source/tasks.c **** 
1358:../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1359:../FreeRTOS/Source/tasks.c **** 			{
1360:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1361:../FreeRTOS/Source/tasks.c **** 				{
1362:../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1363:../FreeRTOS/Source/tasks.c **** 				}
1364:../FreeRTOS/Source/tasks.c **** 			}
1365:../FreeRTOS/Source/tasks.c **** 			#endif
1366:../FreeRTOS/Source/tasks.c **** 		}
1367:../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1368:../FreeRTOS/Source/tasks.c **** 	}
1369:../FreeRTOS/Source/tasks.c **** 
1370:../FreeRTOS/Source/tasks.c **** #endif
1371:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1372:../FreeRTOS/Source/tasks.c **** 
1373:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1374:../FreeRTOS/Source/tasks.c **** 
1375:../FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1376:../FreeRTOS/Source/tasks.c **** 	{
1377:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1378:../FreeRTOS/Source/tasks.c **** 	unsigned long ulTotalRunTime;
1379:../FreeRTOS/Source/tasks.c **** 
1380:../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1381:../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1382:../FreeRTOS/Source/tasks.c **** 
1383:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1384:../FreeRTOS/Source/tasks.c **** 		{
1385:../FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1386:../FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1387:../FreeRTOS/Source/tasks.c **** 			#else
1388:../FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1389:../FreeRTOS/Source/tasks.c **** 			#endif
1390:../FreeRTOS/Source/tasks.c **** 
1391:../FreeRTOS/Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1392:../FreeRTOS/Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1393:../FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
1394:../FreeRTOS/Source/tasks.c **** 			
1395:../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1396:../FreeRTOS/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1397:../FreeRTOS/Source/tasks.c **** 			buffer. */
1398:../FreeRTOS/Source/tasks.c **** 
1399:../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1400:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1401:../FreeRTOS/Source/tasks.c **** 
1402:../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1403:../FreeRTOS/Source/tasks.c **** 
1404:../FreeRTOS/Source/tasks.c **** 			do
1405:../FreeRTOS/Source/tasks.c **** 			{
1406:../FreeRTOS/Source/tasks.c **** 				uxQueue--;
1407:../FreeRTOS/Source/tasks.c **** 
1408:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1409:../FreeRTOS/Source/tasks.c **** 				{
1410:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1411:../FreeRTOS/Source/tasks.c **** 				}
1412:../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1413:../FreeRTOS/Source/tasks.c **** 
1414:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1415:../FreeRTOS/Source/tasks.c **** 			{
1416:../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1417:../FreeRTOS/Source/tasks.c **** 			}
1418:../FreeRTOS/Source/tasks.c **** 
1419:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1420:../FreeRTOS/Source/tasks.c **** 			{
1421:../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1422:../FreeRTOS/Source/tasks.c **** 			}
1423:../FreeRTOS/Source/tasks.c **** 
1424:../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1425:../FreeRTOS/Source/tasks.c **** 			{
1426:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1427:../FreeRTOS/Source/tasks.c **** 				{
1428:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1429:../FreeRTOS/Source/tasks.c **** 				}
1430:../FreeRTOS/Source/tasks.c **** 			}
1431:../FreeRTOS/Source/tasks.c **** 			#endif
1432:../FreeRTOS/Source/tasks.c **** 
1433:../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1434:../FreeRTOS/Source/tasks.c **** 			{
1435:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1436:../FreeRTOS/Source/tasks.c **** 				{
1437:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime, tsk
1438:../FreeRTOS/Source/tasks.c **** 				}
1439:../FreeRTOS/Source/tasks.c **** 			}
1440:../FreeRTOS/Source/tasks.c **** 			#endif
1441:../FreeRTOS/Source/tasks.c **** 		}
1442:../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1443:../FreeRTOS/Source/tasks.c **** 	}
1444:../FreeRTOS/Source/tasks.c **** 
1445:../FreeRTOS/Source/tasks.c **** #endif
1446:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1447:../FreeRTOS/Source/tasks.c **** 
1448:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1449:../FreeRTOS/Source/tasks.c **** 
1450:../FreeRTOS/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1451:../FreeRTOS/Source/tasks.c **** 	{
1452:../FreeRTOS/Source/tasks.c **** 		configASSERT( pcBuffer );
1453:../FreeRTOS/Source/tasks.c **** 		configASSERT( ulBufferSize );
1454:../FreeRTOS/Source/tasks.c **** 
1455:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1456:../FreeRTOS/Source/tasks.c **** 		{
1457:../FreeRTOS/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1458:../FreeRTOS/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1459:../FreeRTOS/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1460:../FreeRTOS/Source/tasks.c **** 			xTracing = pdTRUE;
1461:../FreeRTOS/Source/tasks.c **** 		}
1462:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1463:../FreeRTOS/Source/tasks.c **** 	}
1464:../FreeRTOS/Source/tasks.c **** 
1465:../FreeRTOS/Source/tasks.c **** #endif
1466:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1467:../FreeRTOS/Source/tasks.c **** 
1468:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1469:../FreeRTOS/Source/tasks.c **** 
1470:../FreeRTOS/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1471:../FreeRTOS/Source/tasks.c **** 	{
1472:../FreeRTOS/Source/tasks.c **** 	unsigned long ulBufferLength;
1473:../FreeRTOS/Source/tasks.c **** 
1474:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1475:../FreeRTOS/Source/tasks.c **** 			xTracing = pdFALSE;
1476:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1477:../FreeRTOS/Source/tasks.c **** 
1478:../FreeRTOS/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1479:../FreeRTOS/Source/tasks.c **** 
1480:../FreeRTOS/Source/tasks.c **** 		return ulBufferLength;
1481:../FreeRTOS/Source/tasks.c **** 	}
1482:../FreeRTOS/Source/tasks.c **** 
1483:../FreeRTOS/Source/tasks.c **** #endif
1484:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1485:../FreeRTOS/Source/tasks.c **** 
1486:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1487:../FreeRTOS/Source/tasks.c **** 
1488:../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1489:../FreeRTOS/Source/tasks.c **** 	{
1490:../FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1491:../FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1492:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1493:../FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
1494:../FreeRTOS/Source/tasks.c **** 	}
1495:../FreeRTOS/Source/tasks.c **** 	
1496:../FreeRTOS/Source/tasks.c **** #endif
1497:../FreeRTOS/Source/tasks.c **** 
1498:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1499:../FreeRTOS/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1500:../FreeRTOS/Source/tasks.c ****  * documented in task.h
1501:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1502:../FreeRTOS/Source/tasks.c **** 
1503:../FreeRTOS/Source/tasks.c **** void vTaskIncrementTick( void )
1504:../FreeRTOS/Source/tasks.c **** {
1505:../FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
1506:../FreeRTOS/Source/tasks.c **** 
1507:../FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1508:../FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1509:../FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1510:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1511:../FreeRTOS/Source/tasks.c **** 	{
1512:../FreeRTOS/Source/tasks.c **** 		++xTickCount;
1513:../FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
1514:../FreeRTOS/Source/tasks.c **** 		{
1515:../FreeRTOS/Source/tasks.c **** 			xList *pxTemp;
1516:../FreeRTOS/Source/tasks.c **** 
1517:../FreeRTOS/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1518:../FreeRTOS/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1519:../FreeRTOS/Source/tasks.c **** 			an error! */
1520:../FreeRTOS/Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1521:../FreeRTOS/Source/tasks.c **** 			
1522:../FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
1523:../FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1524:../FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
1525:../FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
1526:../FreeRTOS/Source/tasks.c **** 	
1527:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1528:../FreeRTOS/Source/tasks.c **** 			{
1529:../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1530:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1531:../FreeRTOS/Source/tasks.c **** 				extremely unlikely that the	
1532:../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1533:../FreeRTOS/Source/tasks.c **** 				there is an item in the delayed list. */
1534:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
1535:../FreeRTOS/Source/tasks.c **** 			}
1536:../FreeRTOS/Source/tasks.c **** 			else
1537:../FreeRTOS/Source/tasks.c **** 			{
1538:../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1539:../FreeRTOS/Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1540:../FreeRTOS/Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1541:../FreeRTOS/Source/tasks.c **** 				from the Blocked state. */
1542:../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1543:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1544:../FreeRTOS/Source/tasks.c **** 			}
1545:../FreeRTOS/Source/tasks.c **** 		}
1546:../FreeRTOS/Source/tasks.c **** 
1547:../FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
1549:../FreeRTOS/Source/tasks.c **** 	}
1550:../FreeRTOS/Source/tasks.c **** 	else
1551:../FreeRTOS/Source/tasks.c **** 	{
1552:../FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
1553:../FreeRTOS/Source/tasks.c **** 
1554:../FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1555:../FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
1556:../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1557:../FreeRTOS/Source/tasks.c **** 		{
1558:../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1559:../FreeRTOS/Source/tasks.c **** 		}
1560:../FreeRTOS/Source/tasks.c **** 		#endif
1561:../FreeRTOS/Source/tasks.c **** 	}
1562:../FreeRTOS/Source/tasks.c **** 
1563:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1564:../FreeRTOS/Source/tasks.c **** 	{
1565:../FreeRTOS/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1566:../FreeRTOS/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1567:../FreeRTOS/Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1568:../FreeRTOS/Source/tasks.c **** 		{
1569:../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1570:../FreeRTOS/Source/tasks.c **** 		}
1571:../FreeRTOS/Source/tasks.c **** 	}
1572:../FreeRTOS/Source/tasks.c **** 	#endif
1573:../FreeRTOS/Source/tasks.c **** 
1574:../FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1575:../FreeRTOS/Source/tasks.c **** }
1576:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1577:../FreeRTOS/Source/tasks.c **** 
1578:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1579:../FreeRTOS/Source/tasks.c **** 
1580:../FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1581:../FreeRTOS/Source/tasks.c **** 	{
1582:../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1583:../FreeRTOS/Source/tasks.c **** 
1584:../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1585:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1586:../FreeRTOS/Source/tasks.c **** 		{
1587:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1588:../FreeRTOS/Source/tasks.c **** 		}
1589:../FreeRTOS/Source/tasks.c **** 		else
1590:../FreeRTOS/Source/tasks.c **** 		{
1591:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1592:../FreeRTOS/Source/tasks.c **** 		}
1593:../FreeRTOS/Source/tasks.c **** 
1594:../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1595:../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1596:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1597:../FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1598:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1599:../FreeRTOS/Source/tasks.c **** 	}
1600:../FreeRTOS/Source/tasks.c **** 
1601:../FreeRTOS/Source/tasks.c **** #endif
1602:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1603:../FreeRTOS/Source/tasks.c **** 
1604:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1605:../FreeRTOS/Source/tasks.c **** 
1606:../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1607:../FreeRTOS/Source/tasks.c **** 	{
1608:../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1609:../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1610:../FreeRTOS/Source/tasks.c **** 
1611:../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1612:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1613:../FreeRTOS/Source/tasks.c **** 		{
1614:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1615:../FreeRTOS/Source/tasks.c **** 		}
1616:../FreeRTOS/Source/tasks.c **** 		else
1617:../FreeRTOS/Source/tasks.c **** 		{
1618:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1619:../FreeRTOS/Source/tasks.c **** 		}
1620:../FreeRTOS/Source/tasks.c **** 
1621:../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1622:../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1623:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1624:../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1625:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1626:../FreeRTOS/Source/tasks.c **** 
1627:../FreeRTOS/Source/tasks.c **** 		return xReturn;
1628:../FreeRTOS/Source/tasks.c **** 	}
1629:../FreeRTOS/Source/tasks.c **** 
1630:../FreeRTOS/Source/tasks.c **** #endif
1631:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1632:../FreeRTOS/Source/tasks.c **** 
1633:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1634:../FreeRTOS/Source/tasks.c **** 
1635:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1636:../FreeRTOS/Source/tasks.c **** 	{
1637:../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1638:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
1639:../FreeRTOS/Source/tasks.c **** 
1640:../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1641:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1642:../FreeRTOS/Source/tasks.c **** 		{
1643:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1644:../FreeRTOS/Source/tasks.c **** 		}
1645:../FreeRTOS/Source/tasks.c **** 		else
1646:../FreeRTOS/Source/tasks.c **** 		{
1647:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1648:../FreeRTOS/Source/tasks.c **** 		}
1649:../FreeRTOS/Source/tasks.c **** 
1650:../FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1651:../FreeRTOS/Source/tasks.c **** 		{
1652:../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1653:../FreeRTOS/Source/tasks.c **** 		}
1654:../FreeRTOS/Source/tasks.c **** 		else
1655:../FreeRTOS/Source/tasks.c **** 		{
1656:../FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
1657:../FreeRTOS/Source/tasks.c **** 		}
1658:../FreeRTOS/Source/tasks.c **** 
1659:../FreeRTOS/Source/tasks.c **** 		return xReturn;
1660:../FreeRTOS/Source/tasks.c **** 	}
1661:../FreeRTOS/Source/tasks.c **** 
1662:../FreeRTOS/Source/tasks.c **** #endif
1663:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1664:../FreeRTOS/Source/tasks.c **** 
1665:../FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
1666:../FreeRTOS/Source/tasks.c **** {
1667:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1668:../FreeRTOS/Source/tasks.c **** 	{
1669:../FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1670:../FreeRTOS/Source/tasks.c **** 		switch. */
1671:../FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
1672:../FreeRTOS/Source/tasks.c **** 	}
1673:../FreeRTOS/Source/tasks.c **** 	else
1674:../FreeRTOS/Source/tasks.c **** 	{
1675:../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1676:../FreeRTOS/Source/tasks.c **** 	
1677:../FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1678:../FreeRTOS/Source/tasks.c **** 		{
1679:../FreeRTOS/Source/tasks.c **** 			unsigned long ulTempCounter;
1680:../FreeRTOS/Source/tasks.c **** 			
1681:../FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1682:../FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1683:../FreeRTOS/Source/tasks.c **** 				#else
1684:../FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1685:../FreeRTOS/Source/tasks.c **** 				#endif
1686:../FreeRTOS/Source/tasks.c **** 	
1687:../FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1688:../FreeRTOS/Source/tasks.c **** 				time so far.  The time the task started running was stored in
1689:../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1690:../FreeRTOS/Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1691:../FreeRTOS/Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1692:../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1693:../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
1694:../FreeRTOS/Source/tasks.c **** 		}
1695:../FreeRTOS/Source/tasks.c **** 		#endif
1696:../FreeRTOS/Source/tasks.c **** 	
1697:../FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1698:../FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1699:../FreeRTOS/Source/tasks.c **** 	
1700:../FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1701:../FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1702:../FreeRTOS/Source/tasks.c **** 		{
1703:../FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );
1704:../FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;
1705:../FreeRTOS/Source/tasks.c **** 		}
1706:../FreeRTOS/Source/tasks.c **** 	
1707:../FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1708:../FreeRTOS/Source/tasks.c **** 		same priority get an equal share of the processor time. */
1709:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
1710:../FreeRTOS/Source/tasks.c **** 	
1711:../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1712:../FreeRTOS/Source/tasks.c **** 		vWriteTraceToBuffer();
1713:../FreeRTOS/Source/tasks.c **** 	}
1714:../FreeRTOS/Source/tasks.c **** }
1715:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1716:../FreeRTOS/Source/tasks.c **** 
1717:../FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1718:../FreeRTOS/Source/tasks.c **** {
1719:../FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
1720:../FreeRTOS/Source/tasks.c **** 
1721:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
1722:../FreeRTOS/Source/tasks.c **** 
1723:../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1724:../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1725:../FreeRTOS/Source/tasks.c **** 
1726:../FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1727:../FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1728:../FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event. */
1729:../FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1730:../FreeRTOS/Source/tasks.c **** 
1731:../FreeRTOS/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1732:../FreeRTOS/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1733:../FreeRTOS/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1734:../FreeRTOS/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1735:../FreeRTOS/Source/tasks.c **** 
1736:../FreeRTOS/Source/tasks.c **** 
1737:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1738:../FreeRTOS/Source/tasks.c **** 	{
1739:../FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1740:../FreeRTOS/Source/tasks.c **** 		{
1741:../FreeRTOS/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1742:../FreeRTOS/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1743:../FreeRTOS/Source/tasks.c **** 			indefinitely. */
1744:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1745:../FreeRTOS/Source/tasks.c **** 		}
1746:../FreeRTOS/Source/tasks.c **** 		else
1747:../FreeRTOS/Source/tasks.c **** 		{
1748:../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1749:../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1750:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1751:../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1752:../FreeRTOS/Source/tasks.c **** 		}
1753:../FreeRTOS/Source/tasks.c **** 	}
1754:../FreeRTOS/Source/tasks.c **** 	#else
1755:../FreeRTOS/Source/tasks.c **** 	{
1756:../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1757:../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1758:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1759:../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1760:../FreeRTOS/Source/tasks.c **** 	}
1761:../FreeRTOS/Source/tasks.c **** 	#endif
1762:../FreeRTOS/Source/tasks.c **** }
1763:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1764:../FreeRTOS/Source/tasks.c **** 
1765:../FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
1766:../FreeRTOS/Source/tasks.c **** 
1767:../FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1768:../FreeRTOS/Source/tasks.c **** 	{
1769:../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
1770:../FreeRTOS/Source/tasks.c **** 
1771:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
1772:../FreeRTOS/Source/tasks.c **** 
1773:../FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
1774:../FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1775:../FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1776:../FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
1777:../FreeRTOS/Source/tasks.c **** 
1778:../FreeRTOS/Source/tasks.c **** 	
1779:../FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1780:../FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1781:../FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1782:../FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
1783:../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1784:../FreeRTOS/Source/tasks.c **** 
1785:../FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1786:../FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1787:../FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
1788:../FreeRTOS/Source/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1789:../FreeRTOS/Source/tasks.c **** 
1790:../FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1791:../FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1792:../FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1793:../FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1794:../FreeRTOS/Source/tasks.c **** 	}
1795:../FreeRTOS/Source/tasks.c **** 	
1796:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
1797:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1798:../FreeRTOS/Source/tasks.c **** 
1799:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1800:../FreeRTOS/Source/tasks.c **** {
1801:../FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1802:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1803:../FreeRTOS/Source/tasks.c **** 
1804:../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1805:../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1806:../FreeRTOS/Source/tasks.c **** 
1807:../FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1808:../FreeRTOS/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1809:../FreeRTOS/Source/tasks.c **** 	it to the ready list.
1810:../FreeRTOS/Source/tasks.c **** 
1811:../FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1812:../FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1813:../FreeRTOS/Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1814:../FreeRTOS/Source/tasks.c **** 	
1815:../FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1816:../FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
1817:../FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1818:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
1819:../FreeRTOS/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
1820:../FreeRTOS/Source/tasks.c **** 
1821:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1822:../FreeRTOS/Source/tasks.c **** 	{
1823:../FreeRTOS/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1824:../FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1825:../FreeRTOS/Source/tasks.c **** 	}
1826:../FreeRTOS/Source/tasks.c **** 	else
1827:../FreeRTOS/Source/tasks.c **** 	{
1828:../FreeRTOS/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1829:../FreeRTOS/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1830:../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1831:../FreeRTOS/Source/tasks.c **** 	}
1832:../FreeRTOS/Source/tasks.c **** 
1833:../FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1834:../FreeRTOS/Source/tasks.c **** 	{
1835:../FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1836:../FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1837:../FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
1838:../FreeRTOS/Source/tasks.c **** 		switch now. */
1839:../FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
1840:../FreeRTOS/Source/tasks.c **** 	}
1841:../FreeRTOS/Source/tasks.c **** 	else
1842:../FreeRTOS/Source/tasks.c **** 	{
1843:../FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
1844:../FreeRTOS/Source/tasks.c **** 	}
1845:../FreeRTOS/Source/tasks.c **** 
1846:../FreeRTOS/Source/tasks.c **** 	return xReturn;
1847:../FreeRTOS/Source/tasks.c **** }
1848:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1849:../FreeRTOS/Source/tasks.c **** 
1850:../FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1851:../FreeRTOS/Source/tasks.c **** {
1852:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1853:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
1854:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
1855:../FreeRTOS/Source/tasks.c **** }
1856:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1857:../FreeRTOS/Source/tasks.c **** 
1858:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1859:../FreeRTOS/Source/tasks.c **** {
1860:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1861:../FreeRTOS/Source/tasks.c **** 
1862:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1863:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
1864:../FreeRTOS/Source/tasks.c **** 
1865:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1866:../FreeRTOS/Source/tasks.c **** 	{
1867:../FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1868:../FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1869:../FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1870:../FreeRTOS/Source/tasks.c **** 			therefore never time out. */
1871:../FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
1872:../FreeRTOS/Source/tasks.c **** 			{
1873:../FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
1874:../FreeRTOS/Source/tasks.c **** 			}
1875:../FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1876:../FreeRTOS/Source/tasks.c **** 		#endif
1877:../FreeRTOS/Source/tasks.c **** 
1878:../FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
1879:../FreeRTOS/Source/tasks.c **** 		{
1880:../FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1881:../FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1882:../FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1883:../FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1884:../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
1885:../FreeRTOS/Source/tasks.c **** 		}
1886:../FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
1887:../FreeRTOS/Source/tasks.c **** 		{
1888:../FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1889:../FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
1890:../FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
1891:../FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
1892:../FreeRTOS/Source/tasks.c **** 		}
1893:../FreeRTOS/Source/tasks.c **** 		else
1894:../FreeRTOS/Source/tasks.c **** 		{
1895:../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
1896:../FreeRTOS/Source/tasks.c **** 		}
1897:../FreeRTOS/Source/tasks.c **** 	}
1898:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1899:../FreeRTOS/Source/tasks.c **** 
1900:../FreeRTOS/Source/tasks.c **** 	return xReturn;
1901:../FreeRTOS/Source/tasks.c **** }
1902:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1903:../FreeRTOS/Source/tasks.c **** 
1904:../FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
1905:../FreeRTOS/Source/tasks.c **** {
1906:../FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
1907:../FreeRTOS/Source/tasks.c **** }
1908:../FreeRTOS/Source/tasks.c **** 
1909:../FreeRTOS/Source/tasks.c **** /*
1910:../FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
1911:../FreeRTOS/Source/tasks.c ****  * The Idle task.
1912:../FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
1913:../FreeRTOS/Source/tasks.c ****  *
1914:../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1915:../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1916:../FreeRTOS/Source/tasks.c ****  *
1917:../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1918:../FreeRTOS/Source/tasks.c ****  *
1919:../FreeRTOS/Source/tasks.c ****  */
1920:../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1921:../FreeRTOS/Source/tasks.c **** {
1922:../FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
1923:../FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
1924:../FreeRTOS/Source/tasks.c **** 
1925:../FreeRTOS/Source/tasks.c **** 	for( ;; )
1926:../FreeRTOS/Source/tasks.c **** 	{
1927:../FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1928:../FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1929:../FreeRTOS/Source/tasks.c **** 
1930:../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1931:../FreeRTOS/Source/tasks.c **** 		{
1932:../FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1933:../FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
1934:../FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1935:../FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
1936:../FreeRTOS/Source/tasks.c **** 			taskYIELD();
1937:../FreeRTOS/Source/tasks.c **** 		}
1938:../FreeRTOS/Source/tasks.c **** 		#endif
1939:../FreeRTOS/Source/tasks.c **** 
1940:../FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1941:../FreeRTOS/Source/tasks.c **** 		{
1942:../FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1943:../FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1944:../FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1945:../FreeRTOS/Source/tasks.c **** 			timeslice.
1946:../FreeRTOS/Source/tasks.c **** 
1947:../FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1948:../FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1949:../FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1950:../FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1951:../FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1952:../FreeRTOS/Source/tasks.c **** 			{
1953:../FreeRTOS/Source/tasks.c **** 				taskYIELD();
1954:../FreeRTOS/Source/tasks.c **** 			}
1955:../FreeRTOS/Source/tasks.c **** 		}
1956:../FreeRTOS/Source/tasks.c **** 		#endif
1957:../FreeRTOS/Source/tasks.c **** 
1958:../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1959:../FreeRTOS/Source/tasks.c **** 		{
1960:../FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1961:../FreeRTOS/Source/tasks.c **** 
1962:../FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1963:../FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
1964:../FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
1965:../FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1966:../FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1967:../FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
1968:../FreeRTOS/Source/tasks.c **** 		}
1969:../FreeRTOS/Source/tasks.c **** 		#endif
1970:../FreeRTOS/Source/tasks.c **** 	}
1971:../FreeRTOS/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1972:../FreeRTOS/Source/tasks.c **** 
1973:../FreeRTOS/Source/tasks.c **** 
1974:../FreeRTOS/Source/tasks.c **** 
1975:../FreeRTOS/Source/tasks.c **** 
1976:../FreeRTOS/Source/tasks.c **** 
1977:../FreeRTOS/Source/tasks.c **** 
1978:../FreeRTOS/Source/tasks.c **** 
1979:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1980:../FreeRTOS/Source/tasks.c ****  * File private functions documented at the top of the file.
1981:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1982:../FreeRTOS/Source/tasks.c **** 
1983:../FreeRTOS/Source/tasks.c **** 
1984:../FreeRTOS/Source/tasks.c **** 
1985:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1986:../FreeRTOS/Source/tasks.c **** {
1987:../FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
1988:../FreeRTOS/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1989:../FreeRTOS/Source/tasks.c **** 	{
1990:../FreeRTOS/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1991:../FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
1992:../FreeRTOS/Source/tasks.c **** 	}
1993:../FreeRTOS/Source/tasks.c **** 	#endif
1994:../FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
1995:../FreeRTOS/Source/tasks.c **** 
1996:../FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1997:../FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
1998:../FreeRTOS/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
1999:../FreeRTOS/Source/tasks.c **** 	{
2000:../FreeRTOS/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
2001:../FreeRTOS/Source/tasks.c **** 	}
2002:../FreeRTOS/Source/tasks.c **** 
2003:../FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
2004:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2005:../FreeRTOS/Source/tasks.c **** 	{
2006:../FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
2007:../FreeRTOS/Source/tasks.c **** 	}
2008:../FreeRTOS/Source/tasks.c **** 	#endif
2009:../FreeRTOS/Source/tasks.c **** 
2010:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
2011:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
2012:../FreeRTOS/Source/tasks.c **** 
2013:../FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2014:../FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2015:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
2016:../FreeRTOS/Source/tasks.c **** 
2017:../FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2018:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
2019:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
2020:../FreeRTOS/Source/tasks.c **** 
2021:../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2022:../FreeRTOS/Source/tasks.c **** 	{
2023:../FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2024:../FreeRTOS/Source/tasks.c **** 	}
2025:../FreeRTOS/Source/tasks.c **** 	#endif
2026:../FreeRTOS/Source/tasks.c **** 
2027:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2028:../FreeRTOS/Source/tasks.c **** 	{
2029:../FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2030:../FreeRTOS/Source/tasks.c **** 	}
2031:../FreeRTOS/Source/tasks.c **** 	#endif
2032:../FreeRTOS/Source/tasks.c **** 
2033:../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2034:../FreeRTOS/Source/tasks.c **** 	{
2035:../FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2036:../FreeRTOS/Source/tasks.c **** 	}
2037:../FreeRTOS/Source/tasks.c **** 	#endif
2038:../FreeRTOS/Source/tasks.c **** 
2039:../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2040:../FreeRTOS/Source/tasks.c **** 	{
2041:../FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2042:../FreeRTOS/Source/tasks.c **** 	}
2043:../FreeRTOS/Source/tasks.c **** 	#else
2044:../FreeRTOS/Source/tasks.c **** 	{
2045:../FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2046:../FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2047:../FreeRTOS/Source/tasks.c **** 	}
2048:../FreeRTOS/Source/tasks.c **** 	#endif
2049:../FreeRTOS/Source/tasks.c **** }
2050:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2051:../FreeRTOS/Source/tasks.c **** 
2052:../FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2053:../FreeRTOS/Source/tasks.c **** 
2054:../FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2055:../FreeRTOS/Source/tasks.c **** 	{
2056:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2057:../FreeRTOS/Source/tasks.c **** 	
2058:../FreeRTOS/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2059:../FreeRTOS/Source/tasks.c **** 		{
2060:../FreeRTOS/Source/tasks.c **** 			xTaskToModify = NULL;
2061:../FreeRTOS/Source/tasks.c **** 		}
2062:../FreeRTOS/Source/tasks.c **** 
2063:../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2064:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2065:../FreeRTOS/Source/tasks.c **** 
2066:../FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2067:../FreeRTOS/Source/tasks.c **** 	}
2068:../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
2069:../FreeRTOS/Source/tasks.c **** #endif
2070:../FreeRTOS/Source/tasks.c **** 
2071:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2072:../FreeRTOS/Source/tasks.c **** {
2073:../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2074:../FreeRTOS/Source/tasks.c **** 
2075:../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
2076:../FreeRTOS/Source/tasks.c **** 	{
2077:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
2078:../FreeRTOS/Source/tasks.c **** 	}
2079:../FreeRTOS/Source/tasks.c **** 
2080:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
2081:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
2082:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
2083:../FreeRTOS/Source/tasks.c **** 
2084:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2085:../FreeRTOS/Source/tasks.c **** 	{
2086:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
2087:../FreeRTOS/Source/tasks.c **** 	}
2088:../FreeRTOS/Source/tasks.c **** 	#endif
2089:../FreeRTOS/Source/tasks.c **** 
2090:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2091:../FreeRTOS/Source/tasks.c **** 	{
2092:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
2093:../FreeRTOS/Source/tasks.c **** 	}
2094:../FreeRTOS/Source/tasks.c **** 	#endif
2095:../FreeRTOS/Source/tasks.c **** 
2096:../FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2097:../FreeRTOS/Source/tasks.c **** 	using list2. */
2098:../FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
2099:../FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
2100:../FreeRTOS/Source/tasks.c **** }
2101:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2102:../FreeRTOS/Source/tasks.c **** 
2103:../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2104:../FreeRTOS/Source/tasks.c **** {
2105:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2106:../FreeRTOS/Source/tasks.c **** 	{
2107:../FreeRTOS/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2108:../FreeRTOS/Source/tasks.c **** 
2109:../FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2110:../FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2111:../FreeRTOS/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2112:../FreeRTOS/Source/tasks.c **** 		{
2113:../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
2114:../FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2115:../FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
2116:../FreeRTOS/Source/tasks.c **** 
2117:../FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2118:../FreeRTOS/Source/tasks.c **** 			{
2119:../FreeRTOS/Source/tasks.c **** 				tskTCB *pxTCB;
2120:../FreeRTOS/Source/tasks.c **** 
2121:../FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2122:../FreeRTOS/Source/tasks.c **** 				{
2123:../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2124:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
2125:../FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
2126:../FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
2127:../FreeRTOS/Source/tasks.c **** 				}
2128:../FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2129:../FreeRTOS/Source/tasks.c **** 
2130:../FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
2131:../FreeRTOS/Source/tasks.c **** 			}
2132:../FreeRTOS/Source/tasks.c **** 		}
2133:../FreeRTOS/Source/tasks.c **** 	}
2134:../FreeRTOS/Source/tasks.c **** 	#endif
2135:../FreeRTOS/Source/tasks.c **** }
2136:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2137:../FreeRTOS/Source/tasks.c **** 
2138:../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2139:../FreeRTOS/Source/tasks.c **** {
2140:../FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2141:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
2142:../FreeRTOS/Source/tasks.c **** 
2143:../FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
2144:../FreeRTOS/Source/tasks.c **** 	{
2145:../FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2146:../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
2147:../FreeRTOS/Source/tasks.c **** 	}
2148:../FreeRTOS/Source/tasks.c **** 	else
2149:../FreeRTOS/Source/tasks.c **** 	{
2150:../FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2151:../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
2152:../FreeRTOS/Source/tasks.c **** 
2153:../FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2154:../FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2155:../FreeRTOS/Source/tasks.c **** 		too. */
2156:../FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
2157:../FreeRTOS/Source/tasks.c **** 		{
2158:../FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
2159:../FreeRTOS/Source/tasks.c **** 		}
2160:../FreeRTOS/Source/tasks.c **** 	}
2161:../FreeRTOS/Source/tasks.c **** }
2162:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2163:../FreeRTOS/Source/tasks.c **** 
2164:../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2165:../FreeRTOS/Source/tasks.c **** {
2166:../FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
2167:../FreeRTOS/Source/tasks.c **** 
2168:../FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2169:../FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2170:../FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
2171:../FreeRTOS/Source/tasks.c **** 
2172:../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
2173:../FreeRTOS/Source/tasks.c **** 	{
2174:../FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2175:../FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2176:../FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2177:../FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
2178:../FreeRTOS/Source/tasks.c **** 
2179:../FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
2180:../FreeRTOS/Source/tasks.c **** 		{
2181:../FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2182:../FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
2183:../FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
2184:../FreeRTOS/Source/tasks.c **** 		}
2185:../FreeRTOS/Source/tasks.c **** 		else
2186:../FreeRTOS/Source/tasks.c **** 		{
2187:../FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
2188:../FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
2189:../FreeRTOS/Source/tasks.c **** 		}
2190:../FreeRTOS/Source/tasks.c **** 	}
2191:../FreeRTOS/Source/tasks.c **** 
2192:../FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
2193:../FreeRTOS/Source/tasks.c **** }
2194:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2195:../FreeRTOS/Source/tasks.c **** 
2196:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2197:../FreeRTOS/Source/tasks.c **** 
2198:../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2199:../FreeRTOS/Source/tasks.c **** 	{
2200:../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2201:../FreeRTOS/Source/tasks.c **** 	unsigned short usStackRemaining;
2202:../FreeRTOS/Source/tasks.c **** 
2203:../FreeRTOS/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2204:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2205:../FreeRTOS/Source/tasks.c **** 		do
2206:../FreeRTOS/Source/tasks.c **** 		{
2207:../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2208:../FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2209:../FreeRTOS/Source/tasks.c **** 			{
2210:../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2211:../FreeRTOS/Source/tasks.c **** 			}
2212:../FreeRTOS/Source/tasks.c **** 			#else
2213:../FreeRTOS/Source/tasks.c **** 			{
2214:../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2215:../FreeRTOS/Source/tasks.c **** 			}
2216:../FreeRTOS/Source/tasks.c **** 			#endif			
2217:../FreeRTOS/Source/tasks.c **** 			
2218:../FreeRTOS/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2219:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2220:../FreeRTOS/Source/tasks.c **** 
2221:../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2222:../FreeRTOS/Source/tasks.c **** 	}
2223:../FreeRTOS/Source/tasks.c **** 
2224:../FreeRTOS/Source/tasks.c **** #endif
2225:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2226:../FreeRTOS/Source/tasks.c **** 
2227:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2228:../FreeRTOS/Source/tasks.c **** 
2229:../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2230:../FreeRTOS/Source/tasks.c **** 	{
2231:../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2232:../FreeRTOS/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2233:../FreeRTOS/Source/tasks.c **** 
2234:../FreeRTOS/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2235:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2236:../FreeRTOS/Source/tasks.c **** 		do
2237:../FreeRTOS/Source/tasks.c **** 		{
2238:../FreeRTOS/Source/tasks.c **** 			/* Get next TCB in from the list. */
2239:../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2240:../FreeRTOS/Source/tasks.c **** 
2241:../FreeRTOS/Source/tasks.c **** 			/* Divide by zero check. */
2242:../FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2243:../FreeRTOS/Source/tasks.c **** 			{
2244:../FreeRTOS/Source/tasks.c **** 				/* Has the task run at all? */
2245:../FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2246:../FreeRTOS/Source/tasks.c **** 				{
2247:../FreeRTOS/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2248:../FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%u  %c  %-16s          0   0%%  %5u\r\n", (unsigned int) p
2249:../FreeRTOS/Source/tasks.c **** 				}
2250:../FreeRTOS/Source/tasks.c **** 				else
2251:../FreeRTOS/Source/tasks.c **** 				{
2252:../FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2253:../FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2254:../FreeRTOS/Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2255:../FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2256:../FreeRTOS/Source/tasks.c **** 
2257:../FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2258:../FreeRTOS/Source/tasks.c **** 					{
2259:../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2260:../FreeRTOS/Source/tasks.c **** 						{
2261:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2262:../FreeRTOS/Source/tasks.c **** 						}
2263:../FreeRTOS/Source/tasks.c **** 						#else
2264:../FreeRTOS/Source/tasks.c **** 						{
2265:../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2266:../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2267:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u %3u%%  %5u\r\n", (unsigned int) pxNex
2268:../FreeRTOS/Source/tasks.c **** 						}
2269:../FreeRTOS/Source/tasks.c **** 						#endif
2270:../FreeRTOS/Source/tasks.c **** 					}
2271:../FreeRTOS/Source/tasks.c **** 					else
2272:../FreeRTOS/Source/tasks.c **** 					{
2273:../FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2274:../FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2275:../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2276:../FreeRTOS/Source/tasks.c **** 						{
2277:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2278:../FreeRTOS/Source/tasks.c **** 						}
2279:../FreeRTOS/Source/tasks.c **** 						#else
2280:../FreeRTOS/Source/tasks.c **** 						{
2281:../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2282:../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2283:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u  <1%%  %5u\r\n",  (unsigned int) pxNe
2284:../FreeRTOS/Source/tasks.c **** 						}
2285:../FreeRTOS/Source/tasks.c **** 						#endif
2286:../FreeRTOS/Source/tasks.c **** 					}
2287:../FreeRTOS/Source/tasks.c **** 				}
2288:../FreeRTOS/Source/tasks.c **** 
2289:../FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2290:../FreeRTOS/Source/tasks.c **** 			}
2291:../FreeRTOS/Source/tasks.c **** 
2292:../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2293:../FreeRTOS/Source/tasks.c **** 	}
2294:../FreeRTOS/Source/tasks.c **** 
2295:../FreeRTOS/Source/tasks.c **** #endif
2296:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2297:../FreeRTOS/Source/tasks.c **** 
2298:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2299:../FreeRTOS/Source/tasks.c **** 
2300:../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2301:../FreeRTOS/Source/tasks.c **** 	{
  26              		.loc 1 2301 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
2302:../FreeRTOS/Source/tasks.c **** 	register unsigned short usCount = 0U;
2303:../FreeRTOS/Source/tasks.c **** 
2304:../FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
  32              		.loc 1 2304 0
  33 0000 0023     		movs	r3, #0
  34              	.LVL1:
  35              	.L2:
  36              		.loc 1 2304 0 is_stmt 0 discriminator 1
  37 0002 9AB2     		uxth	r2, r3
  38              	.LVL2:
  39 0004 0133     		adds	r3, r3, #1
2300:../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
  40              		.loc 1 2300 0 is_stmt 1 discriminator 1
  41 0006 C118     		adds	r1, r0, r3
  42              		.loc 1 2304 0 discriminator 1
  43 0008 11F8011C 		ldrb	r1, [r1, #-1]	@ zero_extendqisi2
  44 000c A529     		cmp	r1, #165
  45 000e F8D0     		beq	.L2
  46              	.LVL3:
2305:../FreeRTOS/Source/tasks.c **** 		{
2306:../FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2307:../FreeRTOS/Source/tasks.c **** 			usCount++;
2308:../FreeRTOS/Source/tasks.c **** 		}
2309:../FreeRTOS/Source/tasks.c **** 
2310:../FreeRTOS/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2311:../FreeRTOS/Source/tasks.c **** 
2312:../FreeRTOS/Source/tasks.c **** 		return usCount;
  47              		.loc 1 2312 0
  48 0010 9008     		lsrs	r0, r2, #2
2313:../FreeRTOS/Source/tasks.c **** 	}
  49              		.loc 1 2313 0
  50 0012 7047     		bx	lr
  51              		.cfi_endproc
  52              	.LFE146:
  54              		.section	.text.prvGenerateRunTimeStatsForTasksInList,"ax",%progbits
  55              		.align	1
  56              		.thumb
  57              		.thumb_func
  59              	prvGenerateRunTimeStatsForTasksInList:
  60              	.LFB145:
2230:../FreeRTOS/Source/tasks.c **** 	{
  61              		.loc 1 2230 0
  62              		.cfi_startproc
  63              		@ args = 0, pretend = 0, frame = 16
  64              		@ frame_needed = 0, uses_anonymous_args = 0
  65              	.LVL4:
  66 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  67              	.LCFI0:
  68              		.cfi_def_cfa_offset 36
  69              		.cfi_offset 14, -4
  70              		.cfi_offset 11, -8
  71              		.cfi_offset 10, -12
  72              		.cfi_offset 9, -16
  73              		.cfi_offset 8, -20
  74              		.cfi_offset 7, -24
  75              		.cfi_offset 6, -28
  76              		.cfi_offset 5, -32
  77              		.cfi_offset 4, -36
  78 0004 1E46     		mov	r6, r3
  79              	.LBB19:
2235:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
  80              		.loc 1 2235 0
  81 0006 4B68     		ldr	r3, [r1, #4]
  82              	.LVL5:
  83 0008 5B68     		ldr	r3, [r3, #4]
  84              	.LBE19:
2230:../FreeRTOS/Source/tasks.c **** 	{
  85              		.loc 1 2230 0
  86 000a 9046     		mov	r8, r2
  87              	.LBB20:
2235:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
  88              		.loc 1 2235 0
  89 000c 01F10802 		add	r2, r1, #8
  90              	.LVL6:
  91 0010 4B60     		str	r3, [r1, #4]
  92 0012 9342     		cmp	r3, r2
  93 0014 04BF     		itt	eq
  94 0016 5B68     		ldreq	r3, [r3, #4]
  95 0018 4B60     		streq	r3, [r1, #4]
  96 001a 4B68     		ldr	r3, [r1, #4]
  97              	.LBE20:
2230:../FreeRTOS/Source/tasks.c **** 	{
  98              		.loc 1 2230 0
  99 001c 89B0     		sub	sp, sp, #36
 100              	.LCFI1:
 101              		.cfi_def_cfa_offset 72
 102              	.LBB21:
2235:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 103              		.loc 1 2235 0
 104 001e DB68     		ldr	r3, [r3, #12]
 105              	.LBE21:
2230:../FreeRTOS/Source/tasks.c **** 	{
 106              		.loc 1 2230 0
 107 0020 8146     		mov	r9, r0
 108 0022 0D46     		mov	r5, r1
 109              	.LBB22:
2235:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 110              		.loc 1 2235 0
 111 0024 0793     		str	r3, [sp, #28]
 112              	.LVL7:
 113              	.LBE22:
 114              	.LBB23:
2239:../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 115              		.loc 1 2239 0
 116 0026 01F10807 		add	r7, r1, #8
 117              	.LVL8:
 118              	.L11:
 119 002a 6B68     		ldr	r3, [r5, #4]
 120 002c 5B68     		ldr	r3, [r3, #4]
 121 002e 6B60     		str	r3, [r5, #4]
 122 0030 BB42     		cmp	r3, r7
 123 0032 04BF     		itt	eq
 124 0034 7B68     		ldreq	r3, [r7, #4]
 125 0036 6B60     		streq	r3, [r5, #4]
 126 0038 6B68     		ldr	r3, [r5, #4]
 127 003a DC68     		ldr	r4, [r3, #12]
 128              	.LVL9:
 129              	.LBE23:
2242:../FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
 130              		.loc 1 2242 0
 131 003c B8F1000F 		cmp	r8, #0
 132 0040 3ED0     		beq	.L7
2245:../FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
 133              		.loc 1 2245 0
 134 0042 E36C     		ldr	r3, [r4, #76]
 135 0044 83B9     		cbnz	r3, .L8
2248:../FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%u  %c  %-16s          0   0%%  %5u\r\n", (unsigned int) p
 136              		.loc 1 2248 0
 137 0046 D4F82CA0 		ldr	sl, [r4, #44]
 138 004a 206B     		ldr	r0, [r4, #48]
 139 004c FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 140 0050 04F1340B 		add	fp, r4, #52
 141 0054 0190     		str	r0, [sp, #4]
 142 0056 1D49     		ldr	r1, .L14
 143 0058 1D48     		ldr	r0, .L14+4
 144 005a CDF800B0 		str	fp, [sp, #0]
 145 005e 5246     		mov	r2, sl
 146 0060 3346     		mov	r3, r6
 147 0062 FFF7FEFF 		bl	sprintf
 148 0066 27E0     		b	.L9
 149              	.L8:
2255:../FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 150              		.loc 1 2255 0
 151 0068 E36C     		ldr	r3, [r4, #76]
2267:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u %3u%%  %5u\r\n", (unsigned int) pxNex
 152              		.loc 1 2267 0
 153 006a D4F82CA0 		ldr	sl, [r4, #44]
2255:../FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 154              		.loc 1 2255 0
 155 006e B3FBF8F3 		udiv	r3, r3, r8
 156              	.LVL10:
 157 0072 04F1340B 		add	fp, r4, #52
2257:../FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
 158              		.loc 1 2257 0
 159 0076 7BB1     		cbz	r3, .L10
2267:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u %3u%%  %5u\r\n", (unsigned int) pxNex
 160              		.loc 1 2267 0
 161 0078 E26C     		ldr	r2, [r4, #76]
 162 007a 206B     		ldr	r0, [r4, #48]
 163 007c 0692     		str	r2, [sp, #24]
 164 007e 0593     		str	r3, [sp, #20]
 165 0080 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 166              	.LVL11:
 167 0084 069A     		ldr	r2, [sp, #24]
 168 0086 059B     		ldr	r3, [sp, #20]
 169 0088 0390     		str	r0, [sp, #12]
 170 008a CDF800B0 		str	fp, [sp, #0]
 171 008e 0192     		str	r2, [sp, #4]
 172 0090 0293     		str	r3, [sp, #8]
 173 0092 0F48     		ldr	r0, .L14+4
 174 0094 0F49     		ldr	r1, .L14+8
 175 0096 0BE0     		b	.L13
 176              	.LVL12:
 177              	.L10:
2283:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u  <1%%  %5u\r\n",  (unsigned int) pxNe
 178              		.loc 1 2283 0
 179 0098 E36C     		ldr	r3, [r4, #76]
 180              	.LVL13:
 181 009a 206B     		ldr	r0, [r4, #48]
 182 009c 0593     		str	r3, [sp, #20]
 183 009e FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 184 00a2 059B     		ldr	r3, [sp, #20]
 185 00a4 0290     		str	r0, [sp, #8]
 186 00a6 0C49     		ldr	r1, .L14+12
 187 00a8 0948     		ldr	r0, .L14+4
 188 00aa CDF800B0 		str	fp, [sp, #0]
 189 00ae 0193     		str	r3, [sp, #4]
 190              	.L13:
 191 00b0 5246     		mov	r2, sl
 192 00b2 3346     		mov	r3, r6
 193 00b4 FFF7FEFF 		bl	sprintf
 194              	.L9:
2289:../FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
 195              		.loc 1 2289 0
 196 00b8 4846     		mov	r0, r9
 197 00ba 0549     		ldr	r1, .L14+4
 198 00bc FFF7FEFF 		bl	strcat
 199              	.L7:
2292:../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 200              		.loc 1 2292 0
 201 00c0 079B     		ldr	r3, [sp, #28]
 202 00c2 9C42     		cmp	r4, r3
 203 00c4 B1D1     		bne	.L11
2293:../FreeRTOS/Source/tasks.c **** 	}
 204              		.loc 1 2293 0
 205 00c6 09B0     		add	sp, sp, #36
 206 00c8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
 207              	.L15:
 208              		.align	2
 209              	.L14:
 210 00cc 00000000 		.word	.LC0
 211 00d0 00000000 		.word	.LANCHOR0
 212 00d4 26000000 		.word	.LC1
 213 00d8 46000000 		.word	.LC2
 214              		.cfi_endproc
 215              	.LFE145:
 217              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 218              		.align	1
 219              		.thumb
 220              		.thumb_func
 222              	prvAddCurrentTaskToDelayedList:
 223              	.LFB143:
2139:../FreeRTOS/Source/tasks.c **** {
 224              		.loc 1 2139 0
 225              		.cfi_startproc
 226              		@ args = 0, pretend = 0, frame = 0
 227              		@ frame_needed = 0, uses_anonymous_args = 0
 228              	.LVL14:
2141:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 229              		.loc 1 2141 0
 230 0000 0C4B     		ldr	r3, .L19
 231 0002 5A6B     		ldr	r2, [r3, #52]
2139:../FreeRTOS/Source/tasks.c **** {
 232              		.loc 1 2139 0
 233 0004 10B5     		push	{r4, lr}
 234              	.LCFI2:
 235              		.cfi_def_cfa_offset 8
 236              		.cfi_offset 14, -4
 237              		.cfi_offset 4, -8
2141:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 238              		.loc 1 2141 0
 239 0006 5060     		str	r0, [r2, #4]
2143:../FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 240              		.loc 1 2143 0
 241 0008 9A6B     		ldr	r2, [r3, #56]
 242 000a 9042     		cmp	r0, r2
2139:../FreeRTOS/Source/tasks.c **** {
 243              		.loc 1 2139 0
 244 000c 0446     		mov	r4, r0
2143:../FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 245              		.loc 1 2143 0
 246 000e 06D2     		bcs	.L17
 247              	.LBB26:
 248              	.LBB27:
2146:../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 249              		.loc 1 2146 0
 250 0010 D86B     		ldr	r0, [r3, #60]
 251              	.LVL15:
 252 0012 596B     		ldr	r1, [r3, #52]
 253 0014 0431     		adds	r1, r1, #4
 254              	.LBE27:
 255              	.LBE26:
2161:../FreeRTOS/Source/tasks.c **** }
 256              		.loc 1 2161 0
 257 0016 BDE81040 		pop	{r4, lr}
 258              	.LBB29:
 259              	.LBB28:
2146:../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 260              		.loc 1 2146 0
 261 001a FFF7FEBF 		b	vListInsert
 262              	.L17:
 263              	.LBE28:
 264              	.LBE29:
2151:../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 265              		.loc 1 2151 0
 266 001e 186C     		ldr	r0, [r3, #64]
 267 0020 596B     		ldr	r1, [r3, #52]
 268 0022 0431     		adds	r1, r1, #4
 269 0024 FFF7FEFF 		bl	vListInsert
2156:../FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 270              		.loc 1 2156 0
 271 0028 034B     		ldr	r3, .L19+4
 272 002a 1A68     		ldr	r2, [r3, #0]
 273 002c 9442     		cmp	r4, r2
2158:../FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 274              		.loc 1 2158 0
 275 002e 38BF     		it	cc
 276 0030 1C60     		strcc	r4, [r3, #0]
 277 0032 10BD     		pop	{r4, pc}
 278              	.L20:
 279              		.align	2
 280              	.L19:
 281 0034 00000000 		.word	.LANCHOR0
 282 0038 00000000 		.word	.LANCHOR1
 283              		.cfi_endproc
 284              	.LFE143:
 286              		.section	.text.xTaskGenericCreate,"ax",%progbits
 287              		.align	1
 288              		.global	xTaskGenericCreate
 289              		.thumb
 290              		.thumb_func
 292              	xTaskGenericCreate:
 293              	.LFB110:
 434:../FreeRTOS/Source/tasks.c **** {
 294              		.loc 1 434 0
 295              		.cfi_startproc
 296              		@ args = 16, pretend = 0, frame = 8
 297              		@ frame_needed = 0, uses_anonymous_args = 0
 298              	.LVL16:
 299 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 300              	.LCFI3:
 301              		.cfi_def_cfa_offset 48
 302              		.cfi_offset 14, -4
 303              		.cfi_offset 11, -8
 304              		.cfi_offset 10, -12
 305              		.cfi_offset 9, -16
 306              		.cfi_offset 8, -20
 307              		.cfi_offset 7, -24
 308              		.cfi_offset 6, -28
 309              		.cfi_offset 5, -32
 310              		.cfi_offset 4, -36
 311              		.cfi_offset 2, -40
 312              		.cfi_offset 1, -44
 313              		.cfi_offset 0, -48
 434:../FreeRTOS/Source/tasks.c **** {
 314              		.loc 1 434 0
 315 0004 8246     		mov	sl, r0
 316 0006 0CAF     		add	r7, sp, #48
 317              	.LBB30:
 318              	.LBB31:
2170:../FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 319              		.loc 1 2170 0
 320 0008 5020     		movs	r0, #80
 321              	.LVL17:
 322              	.LBE31:
 323              	.LBE30:
 434:../FreeRTOS/Source/tasks.c **** {
 324              		.loc 1 434 0
 325 000a 0D46     		mov	r5, r1
 326 000c 1446     		mov	r4, r2
 327              	.LVL18:
 328 000e 9946     		mov	r9, r3
 329 0010 97E88009 		ldmia	r7, {r7, r8, fp}
 330              	.LVL19:
 331              	.LBB34:
 332              	.LBB32:
2170:../FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 333              		.loc 1 2170 0
 334 0014 FFF7FEFF 		bl	malloc
 335              	.LVL20:
 336 0018 0646     		mov	r6, r0
 337              	.LVL21:
2172:../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 338              		.loc 1 2172 0
 339 001a 0028     		cmp	r0, #0
 340 001c 00F0B080 		beq	.L31
2177:../FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 341              		.loc 1 2177 0
 342 0020 BBF1000F 		cmp	fp, #0
 343 0024 03D1     		bne	.L23
 344 0026 A000     		lsls	r0, r4, #2
 345              	.LVL22:
 346 0028 FFF7FEFF 		bl	malloc
 347 002c 8346     		mov	fp, r0
 348              	.L23:
 349 002e C6F830B0 		str	fp, [r6, #48]
2179:../FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 350              		.loc 1 2179 0
 351 0032 BBF1000F 		cmp	fp, #0
 352 0036 03D1     		bne	.L24
2182:../FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 353              		.loc 1 2182 0
 354 0038 3046     		mov	r0, r6
 355 003a FFF7FEFF 		bl	free
 356              	.LVL23:
 357 003e 9FE0     		b	.L31
 358              	.LVL24:
 359              	.L24:
2188:../FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 360              		.loc 1 2188 0
 361 0040 A200     		lsls	r2, r4, #2
 362 0042 5846     		mov	r0, fp
 363 0044 A521     		movs	r1, #165
 364 0046 FFF7FEFF 		bl	memset
 365              	.LVL25:
 366              	.LBE32:
 367              	.LBE34:
 368              	.LBB35:
 469:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 369              		.loc 1 469 0
 370 004a 336B     		ldr	r3, [r6, #48]
 371              	.LBB36:
 372              	.LBB37:
1991:../FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 373              		.loc 1 1991 0
 374 004c 2946     		mov	r1, r5
 375 004e 1022     		movs	r2, #16
 376              	.LBE37:
 377              	.LBE36:
 469:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 378              		.loc 1 469 0
 379 0050 013C     		subs	r4, r4, #1
 380              	.LVL26:
 381              	.LBB42:
 382              	.LBB38:
1991:../FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 383              		.loc 1 1991 0
 384 0052 06F13400 		add	r0, r6, #52
2010:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 385              		.loc 1 2010 0
 386 0056 351D     		adds	r5, r6, #4
 387              	.LVL27:
 388              	.LBE38:
 389              	.LBE42:
 469:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 390              		.loc 1 469 0
 391 0058 03EB8404 		add	r4, r3, r4, lsl #2
 392              	.LVL28:
 393              	.LBB43:
 394              	.LBB39:
1994:../FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 395              		.loc 1 1994 0
 396 005c 4FF0000B 		mov	fp, #0
1991:../FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 397              		.loc 1 1991 0
 398 0060 FFF7FEFF 		bl	strncpy
 399              	.LVL29:
1994:../FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 400              		.loc 1 1994 0
 401 0064 042F     		cmp	r7, #4
 402 0066 34BF     		ite	cc
 403 0068 3B46     		movcc	r3, r7
 404 006a 0423     		movcs	r3, #4
2010:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 405              		.loc 1 2010 0
 406 006c 2846     		mov	r0, r5
2003:../FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 407              		.loc 1 2003 0
 408 006e F362     		str	r3, [r6, #44]
2006:../FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 409              		.loc 1 2006 0
 410 0070 7364     		str	r3, [r6, #68]
2010:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 411              		.loc 1 2010 0
 412 0072 0193     		str	r3, [sp, #4]
1994:../FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 413              		.loc 1 1994 0
 414 0074 86F843B0 		strb	fp, [r6, #67]
2010:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 415              		.loc 1 2010 0
 416 0078 FFF7FEFF 		bl	vListInitialiseItem
2011:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 417              		.loc 1 2011 0
 418 007c 06F11800 		add	r0, r6, #24
 419 0080 FFF7FEFF 		bl	vListInitialiseItem
2018:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 420              		.loc 1 2018 0
 421 0084 019B     		ldr	r3, [sp, #4]
2015:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 422              		.loc 1 2015 0
 423 0086 3661     		str	r6, [r6, #16]
 424              	.LBE39:
 425              	.LBE43:
 470:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 426              		.loc 1 470 0
 427 0088 24F00704 		bic	r4, r4, #7
 428              	.LVL30:
 429              	.LBB44:
 430              	.LBB40:
2018:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 431              		.loc 1 2018 0
 432 008c C3F10503 		rsb	r3, r3, #5
 433              	.LBE40:
 434              	.LBE44:
 502:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 435              		.loc 1 502 0
 436 0090 2046     		mov	r0, r4
 437 0092 5146     		mov	r1, sl
 438 0094 4A46     		mov	r2, r9
 439              	.LBB45:
 440              	.LBB41:
2018:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 441              		.loc 1 2018 0
 442 0096 B361     		str	r3, [r6, #24]
2019:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 443              		.loc 1 2019 0
 444 0098 7662     		str	r6, [r6, #36]
2029:../FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
 445              		.loc 1 2029 0
 446 009a C6F848B0 		str	fp, [r6, #72]
2035:../FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
 447              		.loc 1 2035 0
 448 009e C6F84CB0 		str	fp, [r6, #76]
 449              	.LBE41:
 450              	.LBE45:
 502:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 451              		.loc 1 502 0
 452 00a2 FFF7FEFF 		bl	pxPortInitialiseStack
 453 00a6 3060     		str	r0, [r6, #0]
 509:../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 454              		.loc 1 509 0
 455 00a8 B8F1000F 		cmp	r8, #0
 456 00ac 01D0     		beq	.L25
 514:../FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 457              		.loc 1 514 0
 458 00ae C8F80060 		str	r6, [r8, #0]
 459              	.L25:
 519:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 460              		.loc 1 519 0
 461 00b2 FFF7FEFF 		bl	vPortEnterCritical
 521:../FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 462              		.loc 1 521 0
 463 00b6 354B     		ldr	r3, .L35
 464 00b8 5A6C     		ldr	r2, [r3, #68]
 465 00ba 0132     		adds	r2, r2, #1
 466 00bc 5A64     		str	r2, [r3, #68]
 522:../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 467              		.loc 1 522 0
 468 00be 5A6B     		ldr	r2, [r3, #52]
 469 00c0 6ABB     		cbnz	r2, .L26
 526:../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 470              		.loc 1 526 0
 471 00c2 5E63     		str	r6, [r3, #52]
 528:../FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 472              		.loc 1 528 0
 473 00c4 596C     		ldr	r1, [r3, #68]
 474 00c6 0129     		cmp	r1, #1
 475 00c8 31D1     		bne	.L27
 476 00ca 9046     		mov	r8, r2
 477              	.LBB46:
 478              	.LBB47:
2077:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 479              		.loc 1 2077 0
 480 00cc 03F1480A 		add	sl, r3, #72
 481              	.LVL31:
 482 00d0 4FF01409 		mov	r9, #20
 483              	.LVL32:
 484              	.L28:
 485 00d4 09FB08A0 		mla	r0, r9, r8, sl
2075:../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 486              		.loc 1 2075 0
 487 00d8 08F10108 		add	r8, r8, #1
2077:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 488              		.loc 1 2077 0
 489 00dc FFF7FEFF 		bl	vListInitialise
 490              	.LVL33:
2075:../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 491              		.loc 1 2075 0
 492 00e0 B8F1050F 		cmp	r8, #5
2077:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 493              		.loc 1 2077 0
 494 00e4 294C     		ldr	r4, .L35
2075:../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 495              		.loc 1 2075 0
 496 00e6 F5D1     		bne	.L28
2080:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 497              		.loc 1 2080 0
 498 00e8 04F1AC09 		add	r9, r4, #172
 499 00ec 4846     		mov	r0, r9
2081:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 500              		.loc 1 2081 0
 501 00ee 04F1C008 		add	r8, r4, #192
 502              	.LVL34:
2080:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 503              		.loc 1 2080 0
 504 00f2 FFF7FEFF 		bl	vListInitialise
2081:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 505              		.loc 1 2081 0
 506 00f6 4046     		mov	r0, r8
 507 00f8 FFF7FEFF 		bl	vListInitialise
2082:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 508              		.loc 1 2082 0
 509 00fc 04F1D400 		add	r0, r4, #212
 510 0100 FFF7FEFF 		bl	vListInitialise
2086:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 511              		.loc 1 2086 0
 512 0104 04F1E800 		add	r0, r4, #232
 513 0108 FFF7FEFF 		bl	vListInitialise
2092:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 514              		.loc 1 2092 0
 515 010c 04F1FC00 		add	r0, r4, #252
 516 0110 FFF7FEFF 		bl	vListInitialise
2098:../FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 517              		.loc 1 2098 0
 518 0114 C4F84090 		str	r9, [r4, #64]
2099:../FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 519              		.loc 1 2099 0
 520 0118 C4F83C80 		str	r8, [r4, #60]
 521 011c 07E0     		b	.L27
 522              	.LVL35:
 523              	.L26:
 524              	.LBE47:
 525              	.LBE46:
 541:../FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 526              		.loc 1 541 0
 527 011e D3F81021 		ldr	r2, [r3, #272]
 528 0122 22B9     		cbnz	r2, .L27
 543:../FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 529              		.loc 1 543 0
 530 0124 5A6B     		ldr	r2, [r3, #52]
 531 0126 D26A     		ldr	r2, [r2, #44]
 532 0128 BA42     		cmp	r2, r7
 545:../FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 533              		.loc 1 545 0
 534 012a 98BF     		it	ls
 535 012c 5E63     		strls	r6, [r3, #52]
 536              	.LVL36:
 537              	.L27:
 552:../FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 538              		.loc 1 552 0
 539 012e 174A     		ldr	r2, .L35
 540 0130 F36A     		ldr	r3, [r6, #44]
 541 0132 D2F81411 		ldr	r1, [r2, #276]
 565:../FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 542              		.loc 1 565 0
 543 0136 154C     		ldr	r4, .L35
 552:../FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 544              		.loc 1 552 0
 545 0138 8B42     		cmp	r3, r1
 563:../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 546              		.loc 1 563 0
 547 013a D2F81811 		ldr	r1, [r2, #280]
 554:../FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 548              		.loc 1 554 0
 549 013e 88BF     		it	hi
 550 0140 C2F81431 		strhi	r3, [r2, #276]
 563:../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 551              		.loc 1 563 0
 552 0144 0131     		adds	r1, r1, #1
 553 0146 C2F81811 		str	r1, [r2, #280]
 565:../FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 554              		.loc 1 565 0
 555 014a D2F81C21 		ldr	r2, [r2, #284]
 556 014e 9342     		cmp	r3, r2
 557 0150 84BF     		itt	hi
 558 0152 0E4A     		ldrhi	r2, .L35
 559 0154 C2F81C31 		strhi	r3, [r2, #284]
 560 0158 04F14802 		add	r2, r4, #72
 561 015c 1420     		movs	r0, #20
 562 015e 00FB0320 		mla	r0, r0, r3, r2
 563 0162 2946     		mov	r1, r5
 564 0164 FFF7FEFF 		bl	vListInsertEnd
 565              	.LVL37:
 570:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 566              		.loc 1 570 0
 567 0168 FFF7FEFF 		bl	vPortExitCritical
 568              	.LBE35:
 580:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 569              		.loc 1 580 0
 570 016c D4F81031 		ldr	r3, [r4, #272]
 571 0170 4BB1     		cbz	r3, .L33
 584:../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 572              		.loc 1 584 0
 573 0172 636B     		ldr	r3, [r4, #52]
 574 0174 DB6A     		ldr	r3, [r3, #44]
 575 0176 BB42     		cmp	r3, r7
 576 0178 05D2     		bcs	.L33
 586:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 577              		.loc 1 586 0
 578 017a FFF7FEFF 		bl	vPortYieldFromISR
 579 017e 02E0     		b	.L33
 580              	.LVL38:
 581              	.L31:
 582              	.LBB48:
 583              	.LBB33:
 574:../FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 584              		.loc 1 574 0
 585 0180 4FF0FF30 		mov	r0, #-1
 586 0184 00E0     		b	.L22
 587              	.LVL39:
 588              	.L33:
 589              	.LBE33:
 590              	.LBE48:
 567:../FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 591              		.loc 1 567 0
 592 0186 0120     		movs	r0, #1
 593              	.LVL40:
 594              	.L22:
 592:../FreeRTOS/Source/tasks.c **** }
 595              		.loc 1 592 0
 596 0188 BDE8FE8F 		pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 597              	.L36:
 598              		.align	2
 599              	.L35:
 600 018c 00000000 		.word	.LANCHOR0
 601              		.cfi_endproc
 602              	.LFE110:
 604              		.section	.text.vTaskDelete,"ax",%progbits
 605              		.align	1
 606              		.global	vTaskDelete
 607              		.thumb
 608              		.thumb_func
 610              	vTaskDelete:
 611              	.LFB111:
 598:../FreeRTOS/Source/tasks.c **** 	{
 612              		.loc 1 598 0
 613              		.cfi_startproc
 614              		@ args = 0, pretend = 0, frame = 0
 615              		@ frame_needed = 0, uses_anonymous_args = 0
 616              	.LVL41:
 617 0000 70B5     		push	{r4, r5, r6, lr}
 618              	.LCFI4:
 619              		.cfi_def_cfa_offset 16
 620              		.cfi_offset 14, -4
 621              		.cfi_offset 6, -8
 622              		.cfi_offset 5, -12
 623              		.cfi_offset 4, -16
 598:../FreeRTOS/Source/tasks.c **** 	{
 624              		.loc 1 598 0
 625 0002 0546     		mov	r5, r0
 601:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 626              		.loc 1 601 0
 627 0004 FFF7FEFF 		bl	vPortEnterCritical
 628              	.LVL42:
 605:../FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 629              		.loc 1 605 0
 630 0008 164B     		ldr	r3, .L43
 631 000a 5A6B     		ldr	r2, [r3, #52]
 632 000c 9542     		cmp	r5, r2
 633 000e 01D0     		beq	.L38
 611:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 634              		.loc 1 611 0
 635 0010 2C46     		mov	r4, r5
 636 0012 0DB9     		cbnz	r5, .L39
 637              	.L38:
 611:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 638              		.loc 1 611 0 is_stmt 0 discriminator 1
 639 0014 5C6B     		ldr	r4, [r3, #52]
 640 0016 0025     		movs	r5, #0
 641              	.LVL43:
 642              	.L39:
 617:../FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 643              		.loc 1 617 0 is_stmt 1 discriminator 3
 644 0018 261D     		adds	r6, r4, #4
 645 001a 3046     		mov	r0, r6
 646 001c FFF7FEFF 		bl	vListRemove
 620:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 647              		.loc 1 620 0 discriminator 3
 648 0020 A36A     		ldr	r3, [r4, #40]
 649 0022 1BB1     		cbz	r3, .L40
 622:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 650              		.loc 1 622 0
 651 0024 04F11800 		add	r0, r4, #24
 652 0028 FFF7FEFF 		bl	vListRemove
 653              	.L40:
 625:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 654              		.loc 1 625 0
 655 002c 0D4C     		ldr	r4, .L43
 656              	.LVL44:
 657 002e 3146     		mov	r1, r6
 658 0030 04F1E800 		add	r0, r4, #232
 659 0034 FFF7FEFF 		bl	vListInsertEnd
 630:../FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 660              		.loc 1 630 0
 661 0038 D4F82031 		ldr	r3, [r4, #288]
 662 003c 0133     		adds	r3, r3, #1
 663 003e C4F82031 		str	r3, [r4, #288]
 634:../FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 664              		.loc 1 634 0
 665 0042 D4F81831 		ldr	r3, [r4, #280]
 666 0046 0133     		adds	r3, r3, #1
 667 0048 C4F81831 		str	r3, [r4, #280]
 638:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 668              		.loc 1 638 0
 669 004c FFF7FEFF 		bl	vPortExitCritical
 641:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 670              		.loc 1 641 0
 671 0050 D4F81031 		ldr	r3, [r4, #272]
 672 0054 23B1     		cbz	r3, .L37
 643:../FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 673              		.loc 1 643 0
 674 0056 1DB9     		cbnz	r5, .L37
 648:../FreeRTOS/Source/tasks.c **** 	}
 675              		.loc 1 648 0
 676 0058 BDE87040 		pop	{r4, r5, r6, lr}
 645:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 677              		.loc 1 645 0
 678 005c FFF7FEBF 		b	vPortYieldFromISR
 679              	.L37:
 680 0060 70BD     		pop	{r4, r5, r6, pc}
 681              	.L44:
 682 0062 00BF     		.align	2
 683              	.L43:
 684 0064 00000000 		.word	.LANCHOR0
 685              		.cfi_endproc
 686              	.LFE111:
 688              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 689              		.align	1
 690              		.global	uxTaskPriorityGet
 691              		.thumb
 692              		.thumb_func
 694              	uxTaskPriorityGet:
 695              	.LFB114:
 775:../FreeRTOS/Source/tasks.c **** 	{
 696              		.loc 1 775 0
 697              		.cfi_startproc
 698              		@ args = 0, pretend = 0, frame = 0
 699              		@ frame_needed = 0, uses_anonymous_args = 0
 700              	.LVL45:
 701 0000 10B5     		push	{r4, lr}
 702              	.LCFI5:
 703              		.cfi_def_cfa_offset 8
 704              		.cfi_offset 14, -4
 705              		.cfi_offset 4, -8
 775:../FreeRTOS/Source/tasks.c **** 	{
 706              		.loc 1 775 0
 707 0002 0446     		mov	r4, r0
 779:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 708              		.loc 1 779 0
 709 0004 FFF7FEFF 		bl	vPortEnterCritical
 710              	.LVL46:
 783:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 711              		.loc 1 783 0
 712 0008 0CB9     		cbnz	r4, .L46
 783:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 713              		.loc 1 783 0 is_stmt 0 discriminator 1
 714 000a 034B     		ldr	r3, .L48
 715 000c 5C6B     		ldr	r4, [r3, #52]
 716              	.LVL47:
 717              	.L46:
 784:../FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 718              		.loc 1 784 0 is_stmt 1 discriminator 3
 719 000e E46A     		ldr	r4, [r4, #44]
 720              	.LVL48:
 786:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 721              		.loc 1 786 0 discriminator 3
 722 0010 FFF7FEFF 		bl	vPortExitCritical
 789:../FreeRTOS/Source/tasks.c **** 	}
 723              		.loc 1 789 0 discriminator 3
 724 0014 2046     		mov	r0, r4
 725 0016 10BD     		pop	{r4, pc}
 726              	.L49:
 727              		.align	2
 728              	.L48:
 729 0018 00000000 		.word	.LANCHOR0
 730              		.cfi_endproc
 731              	.LFE114:
 733              		.section	.text.vTaskPrioritySet,"ax",%progbits
 734              		.align	1
 735              		.global	vTaskPrioritySet
 736              		.thumb
 737              		.thumb_func
 739              	vTaskPrioritySet:
 740              	.LFB115:
 797:../FreeRTOS/Source/tasks.c **** 	{
 741              		.loc 1 797 0
 742              		.cfi_startproc
 743              		@ args = 0, pretend = 0, frame = 0
 744              		@ frame_needed = 0, uses_anonymous_args = 0
 745              	.LVL49:
 746 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 747              	.LCFI6:
 748              		.cfi_def_cfa_offset 24
 749              		.cfi_offset 14, -4
 750              		.cfi_offset 8, -8
 751              		.cfi_offset 7, -12
 752              		.cfi_offset 6, -16
 753              		.cfi_offset 5, -20
 754              		.cfi_offset 4, -24
 797:../FreeRTOS/Source/tasks.c **** 	{
 755              		.loc 1 797 0
 756 0004 0446     		mov	r4, r0
 819:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 757              		.loc 1 819 0
 758 0006 0429     		cmp	r1, #4
 759 0008 34BF     		ite	cc
 760 000a 0E46     		movcc	r6, r1
 761 000c 0426     		movcs	r6, #4
 762              	.LVL50:
 810:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 763              		.loc 1 810 0
 764 000e FFF7FEFF 		bl	vPortEnterCritical
 765              	.LVL51:
 812:../FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 766              		.loc 1 812 0
 767 0012 1F4B     		ldr	r3, .L60
 768 0014 5A6B     		ldr	r2, [r3, #52]
 769 0016 9442     		cmp	r4, r2
 770 0018 01D0     		beq	.L51
 819:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 771              		.loc 1 819 0
 772 001a 2546     		mov	r5, r4
 773 001c 0CB9     		cbnz	r4, .L52
 774              	.L51:
 819:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 775              		.loc 1 819 0 is_stmt 0 discriminator 1
 776 001e 5D6B     		ldr	r5, [r3, #52]
 777 0020 0024     		movs	r4, #0
 778              	.LVL52:
 779              	.L52:
 825:../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 780              		.loc 1 825 0 is_stmt 1 discriminator 3
 781 0022 6B6C     		ldr	r3, [r5, #68]
 782              	.LVL53:
 833:../FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 783              		.loc 1 833 0 discriminator 3
 784 0024 B342     		cmp	r3, r6
 785 0026 2ED0     		beq	.L53
 837:../FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 786              		.loc 1 837 0
 787 0028 9E42     		cmp	r6, r3
 788 002a 03D9     		bls	.L54
 845:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 789              		.loc 1 845 0
 790 002c 0034     		adds	r4, r4, #0
 791 002e 18BF     		it	ne
 792 0030 0124     		movne	r4, #1
 793 0032 03E0     		b	.L55
 794              	.L54:
 795 0034 D4F10104 		rsbs	r4, r4, #1
 796 0038 38BF     		it	cc
 797 003a 0024     		movcc	r4, #0
 798              	.L55:
 799              	.LVL54:
 861:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 800              		.loc 1 861 0
 801 003c EA6A     		ldr	r2, [r5, #44]
 867:../FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 802              		.loc 1 867 0
 803 003e 6E64     		str	r6, [r5, #68]
 861:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 804              		.loc 1 861 0
 805 0040 9342     		cmp	r3, r2
 863:../FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 806              		.loc 1 863 0
 807 0042 08BF     		it	eq
 808 0044 EE62     		streq	r6, [r5, #44]
 875:../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 809              		.loc 1 875 0
 810 0046 C6F10506 		rsb	r6, r6, #5
 811              	.LVL55:
 812 004a AE61     		str	r6, [r5, #24]
 881:../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 813              		.loc 1 881 0
 814 004c 104E     		ldr	r6, .L60
 815 004e 1422     		movs	r2, #20
 816 0050 06F14808 		add	r8, r6, #72
 817 0054 02FB0383 		mla	r3, r2, r3, r8
 818 0058 6A69     		ldr	r2, [r5, #20]
 819 005a 9A42     		cmp	r2, r3
 820 005c 10D1     		bne	.L57
 886:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 821              		.loc 1 886 0
 822 005e 2F1D     		adds	r7, r5, #4
 823 0060 3846     		mov	r0, r7
 824 0062 FFF7FEFF 		bl	vListRemove
 825              	.LVL56:
 887:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 826              		.loc 1 887 0
 827 0066 EB6A     		ldr	r3, [r5, #44]
 828 0068 D6F81C21 		ldr	r2, [r6, #284]
 829 006c 9342     		cmp	r3, r2
 830 006e 88BF     		it	hi
 831 0070 C6F81C31 		strhi	r3, [r6, #284]
 832 0074 1420     		movs	r0, #20
 833 0076 00FB0380 		mla	r0, r0, r3, r8
 834 007a 3946     		mov	r1, r7
 835 007c FFF7FEFF 		bl	vListInsertEnd
 836              	.L57:
 890:../FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 837              		.loc 1 890 0
 838 0080 0CB1     		cbz	r4, .L53
 892:../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 839              		.loc 1 892 0
 840 0082 FFF7FEFF 		bl	vPortYieldFromISR
 841              	.LVL57:
 842              	.L53:
 897:../FreeRTOS/Source/tasks.c **** 	}
 843              		.loc 1 897 0
 844 0086 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 896:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 845              		.loc 1 896 0
 846 008a FFF7FEBF 		b	vPortExitCritical
 847              	.L61:
 848 008e 00BF     		.align	2
 849              	.L60:
 850 0090 00000000 		.word	.LANCHOR0
 851              		.cfi_endproc
 852              	.LFE115:
 854              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 855              		.align	1
 856              		.global	xTaskIsTaskSuspended
 857              		.thumb
 858              		.thumb_func
 860              	xTaskIsTaskSuspended:
 861              	.LFB117:
 969:../FreeRTOS/Source/tasks.c **** 	{
 862              		.loc 1 969 0
 863              		.cfi_startproc
 864              		@ args = 0, pretend = 0, frame = 0
 865              		@ frame_needed = 0, uses_anonymous_args = 0
 866              		@ link register save eliminated.
 867              	.LVL58:
 978:../FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 868              		.loc 1 978 0
 869 0000 4269     		ldr	r2, [r0, #20]
 870 0002 084B     		ldr	r3, .L67
 871 0004 9A42     		cmp	r2, r3
 872 0006 0AD1     		bne	.L65
 873              	.LVL59:
 874              	.LBB51:
 875              	.LBB52:
 981:../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 876              		.loc 1 981 0
 877 0008 806A     		ldr	r0, [r0, #40]
 878              	.LVL60:
 879 000a 283B     		subs	r3, r3, #40
 880 000c 9842     		cmp	r0, r3
 881 000e 04D0     		beq	.L66
 970:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 882              		.loc 1 970 0
 883 0010 D0F10100 		rsbs	r0, r0, #1
 884 0014 38BF     		it	cc
 885 0016 0020     		movcc	r0, #0
 886 0018 7047     		bx	lr
 887              	.L66:
 888 001a 0020     		movs	r0, #0
 889              	.LVL61:
 890 001c 7047     		bx	lr
 891              	.LVL62:
 892              	.L65:
 893              	.LBE52:
 894              	.LBE51:
 895 001e 0020     		movs	r0, #0
 896              	.LVL63:
 995:../FreeRTOS/Source/tasks.c **** 	}
 897              		.loc 1 995 0
 898 0020 7047     		bx	lr
 899              	.L68:
 900 0022 00BF     		.align	2
 901              	.L67:
 902 0024 FC000000 		.word	.LANCHOR0+252
 903              		.cfi_endproc
 904              	.LFE117:
 906              		.section	.text.vTaskResume,"ax",%progbits
 907              		.align	1
 908              		.global	vTaskResume
 909              		.thumb
 910              		.thumb_func
 912              	vTaskResume:
 913              	.LFB118:
1003:../FreeRTOS/Source/tasks.c **** 	{
 914              		.loc 1 1003 0
 915              		.cfi_startproc
 916              		@ args = 0, pretend = 0, frame = 0
 917              		@ frame_needed = 0, uses_anonymous_args = 0
 918              	.LVL64:
 919 0000 70B5     		push	{r4, r5, r6, lr}
 920              	.LCFI7:
 921              		.cfi_def_cfa_offset 16
 922              		.cfi_offset 14, -4
 923              		.cfi_offset 6, -8
 924              		.cfi_offset 5, -12
 925              		.cfi_offset 4, -16
1003:../FreeRTOS/Source/tasks.c **** 	{
 926              		.loc 1 1003 0
 927 0002 0446     		mov	r4, r0
1015:../FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 928              		.loc 1 1015 0
 929 0004 0028     		cmp	r0, #0
 930 0006 29D0     		beq	.L69
 931              	.LVL65:
1015:../FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 932              		.loc 1 1015 0 is_stmt 0 discriminator 1
 933 0008 154D     		ldr	r5, .L73
 934 000a 6B6B     		ldr	r3, [r5, #52]
 935 000c 9842     		cmp	r0, r3
 936 000e 25D0     		beq	.L69
1017:../FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 937              		.loc 1 1017 0 is_stmt 1
 938 0010 FFF7FEFF 		bl	vPortEnterCritical
 939              	.LVL66:
1019:../FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 940              		.loc 1 1019 0
 941 0014 2046     		mov	r0, r4
 942 0016 FFF7FEFF 		bl	xTaskIsTaskSuspended
 943 001a 0128     		cmp	r0, #1
 944 001c 1AD1     		bne	.L71
1025:../FreeRTOS/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 945              		.loc 1 1025 0
 946 001e 261D     		adds	r6, r4, #4
 947 0020 3046     		mov	r0, r6
 948 0022 FFF7FEFF 		bl	vListRemove
1026:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 949              		.loc 1 1026 0
 950 0026 E36A     		ldr	r3, [r4, #44]
 951 0028 D5F81C21 		ldr	r2, [r5, #284]
 952 002c 9342     		cmp	r3, r2
 953 002e 88BF     		it	hi
 954 0030 C5F81C31 		strhi	r3, [r5, #284]
 955 0034 0A4D     		ldr	r5, .L73
 956 0036 1420     		movs	r0, #20
 957 0038 05F14802 		add	r2, r5, #72
 958 003c 00FB0320 		mla	r0, r0, r3, r2
 959 0040 3146     		mov	r1, r6
 960 0042 FFF7FEFF 		bl	vListInsertEnd
1029:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 961              		.loc 1 1029 0
 962 0046 6B6B     		ldr	r3, [r5, #52]
 963 0048 E26A     		ldr	r2, [r4, #44]
 964 004a DB6A     		ldr	r3, [r3, #44]
 965 004c 9A42     		cmp	r2, r3
 966 004e 01D3     		bcc	.L71
1033:../FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
 967              		.loc 1 1033 0
 968 0050 FFF7FEFF 		bl	vPortYieldFromISR
 969              	.L71:
1039:../FreeRTOS/Source/tasks.c **** 	}
 970              		.loc 1 1039 0
 971 0054 BDE87040 		pop	{r4, r5, r6, lr}
1037:../FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 972              		.loc 1 1037 0
 973 0058 FFF7FEBF 		b	vPortExitCritical
 974              	.L69:
 975 005c 70BD     		pop	{r4, r5, r6, pc}
 976              	.L74:
 977 005e 00BF     		.align	2
 978              	.L73:
 979 0060 00000000 		.word	.LANCHOR0
 980              		.cfi_endproc
 981              	.LFE118:
 983              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 984              		.align	1
 985              		.global	xTaskResumeFromISR
 986              		.thumb
 987              		.thumb_func
 989              	xTaskResumeFromISR:
 990              	.LFB119:
1048:../FreeRTOS/Source/tasks.c **** 	{
 991              		.loc 1 1048 0
 992              		.cfi_startproc
 993              		@ args = 0, pretend = 0, frame = 0
 994              		@ frame_needed = 0, uses_anonymous_args = 0
 995              	.LVL67:
 996 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 997              	.LCFI8:
 998              		.cfi_def_cfa_offset 24
 999              		.cfi_offset 14, -4
 1000              		.cfi_offset 7, -8
 1001              		.cfi_offset 6, -12
 1002              		.cfi_offset 5, -16
 1003              		.cfi_offset 4, -20
 1004              		.cfi_offset 3, -24
1048:../FreeRTOS/Source/tasks.c **** 	{
 1005              		.loc 1 1048 0
 1006 0002 0646     		mov	r6, r0
1056:../FreeRTOS/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1007              		.loc 1 1056 0
 1008 0004 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1009              	.LVL68:
 1010 0008 0128     		cmp	r0, #1
 1011 000a 23D1     		bne	.L79
1060:../FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1012              		.loc 1 1060 0
 1013 000c 134D     		ldr	r5, .L80
 1014 000e D5F82431 		ldr	r3, [r5, #292]
 1015 0012 CBB9     		cbnz	r3, .L77
1062:../FreeRTOS/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1016              		.loc 1 1062 0
 1017 0014 6B6B     		ldr	r3, [r5, #52]
 1018 0016 F46A     		ldr	r4, [r6, #44]
 1019 0018 DB6A     		ldr	r3, [r3, #44]
 1020 001a 9C42     		cmp	r4, r3
 1021 001c 34BF     		ite	cc
 1022 001e 0024     		movcc	r4, #0
 1023 0020 0124     		movcs	r4, #1
 1024              	.LVL69:
1063:../FreeRTOS/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1025              		.loc 1 1063 0
 1026 0022 371D     		adds	r7, r6, #4
 1027 0024 3846     		mov	r0, r7
 1028 0026 FFF7FEFF 		bl	vListRemove
1064:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1029              		.loc 1 1064 0
 1030 002a F36A     		ldr	r3, [r6, #44]
 1031 002c D5F81C21 		ldr	r2, [r5, #284]
 1032 0030 9342     		cmp	r3, r2
 1033 0032 0B4A     		ldr	r2, .L80+4
 1034 0034 88BF     		it	hi
 1035 0036 C5F81C31 		strhi	r3, [r5, #284]
 1036 003a 1420     		movs	r0, #20
 1037 003c 00FB0320 		mla	r0, r0, r3, r2
 1038 0040 3946     		mov	r1, r7
 1039 0042 FFF7FEFF 		bl	vListInsertEnd
 1040 0046 06E0     		b	.L76
 1041              	.LVL70:
 1042              	.L77:
1071:../FreeRTOS/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1043              		.loc 1 1071 0
 1044 0048 06F11801 		add	r1, r6, #24
 1045 004c 05F1D400 		add	r0, r5, #212
 1046 0050 FFF7FEFF 		bl	vListInsertEnd
 1047              	.L79:
1049:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1048              		.loc 1 1049 0
 1049 0054 0024     		movs	r4, #0
 1050              	.LVL71:
 1051              	.L76:
1076:../FreeRTOS/Source/tasks.c **** 	}
 1052              		.loc 1 1076 0
 1053 0056 2046     		mov	r0, r4
 1054 0058 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1055              	.L81:
 1056 005a 00BF     		.align	2
 1057              	.L80:
 1058 005c 00000000 		.word	.LANCHOR0
 1059 0060 48000000 		.word	.LANCHOR0+72
 1060              		.cfi_endproc
 1061              	.LFE119:
 1063              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1064              		.align	1
 1065              		.global	vTaskStartScheduler
 1066              		.thumb
 1067              		.thumb_func
 1069              	vTaskStartScheduler:
 1070              	.LFB120:
1089:../FreeRTOS/Source/tasks.c **** {
 1071              		.loc 1 1089 0
 1072              		.cfi_startproc
 1073              		@ args = 0, pretend = 0, frame = 0
 1074              		@ frame_needed = 0, uses_anonymous_args = 0
 1075 0000 30B5     		push	{r4, r5, lr}
 1076              	.LCFI9:
 1077              		.cfi_def_cfa_offset 12
 1078              		.cfi_offset 14, -4
 1079              		.cfi_offset 5, -8
 1080              		.cfi_offset 4, -12
1097:../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1081              		.loc 1 1097 0
 1082 0002 114D     		ldr	r5, .L84
 1083 0004 1148     		ldr	r0, .L84+4
 1084 0006 1249     		ldr	r1, .L84+8
1089:../FreeRTOS/Source/tasks.c **** {
 1085              		.loc 1 1089 0
 1086 0008 85B0     		sub	sp, sp, #20
 1087              	.LCFI10:
 1088              		.cfi_def_cfa_offset 32
1097:../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1089              		.loc 1 1097 0
 1090 000a 0024     		movs	r4, #0
 1091 000c 05F59473 		add	r3, r5, #296
 1092 0010 0193     		str	r3, [sp, #4]
 1093 0012 4FF48072 		mov	r2, #256
 1094 0016 2346     		mov	r3, r4
 1095 0018 0094     		str	r4, [sp, #0]
 1096 001a 0294     		str	r4, [sp, #8]
 1097 001c 0394     		str	r4, [sp, #12]
 1098 001e FFF7FEFF 		bl	xTaskGenericCreate
1115:../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1099              		.loc 1 1115 0
 1100 0022 0128     		cmp	r0, #1
1097:../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1101              		.loc 1 1097 0
 1102 0024 0346     		mov	r3, r0
 1103              	.LVL72:
1115:../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1104              		.loc 1 1115 0
 1105 0026 0DD1     		bne	.L82
1125:../FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1106              		.loc 1 1125 0
 1107              	@ 1125 "../FreeRTOS/Source/tasks.c" 1
 1108 0028 4FF0BF00 			mov r0, #191								
 1109 002c 80F31188 		msr basepri, r0							
 1110              	
 1111              	@ 0 "" 2
 1112              	.LVL73:
1127:../FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1113              		.loc 1 1127 0
 1114              		.thumb
 1115 0030 C5F81031 		str	r3, [r5, #272]
1128:../FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1116              		.loc 1 1128 0
 1117 0034 AC63     		str	r4, [r5, #56]
1133:../FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 1118              		.loc 1 1133 0
 1119 0036 FFF7FEFF 		bl	init_us_timer
 1120              	.LVL74:
1150:../FreeRTOS/Source/tasks.c **** }
 1121              		.loc 1 1150 0
 1122 003a 05B0     		add	sp, sp, #20
 1123 003c BDE83040 		pop	{r4, r5, lr}
1137:../FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1124              		.loc 1 1137 0
 1125 0040 FFF7FEBF 		b	xPortStartScheduler
 1126              	.LVL75:
 1127              	.L82:
1150:../FreeRTOS/Source/tasks.c **** }
 1128              		.loc 1 1150 0
 1129 0044 05B0     		add	sp, sp, #20
 1130 0046 30BD     		pop	{r4, r5, pc}
 1131              	.L85:
 1132              		.align	2
 1133              	.L84:
 1134 0048 00000000 		.word	.LANCHOR0
 1135 004c 00000000 		.word	prvIdleTask
 1136 0050 66000000 		.word	.LC3
 1137              		.cfi_endproc
 1138              	.LFE120:
 1140              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1141              		.align	1
 1142              		.global	vTaskEndScheduler
 1143              		.thumb
 1144              		.thumb_func
 1146              	vTaskEndScheduler:
 1147              	.LFB121:
1154:../FreeRTOS/Source/tasks.c **** {
 1148              		.loc 1 1154 0
 1149              		.cfi_startproc
 1150              		@ args = 0, pretend = 0, frame = 0
 1151              		@ frame_needed = 0, uses_anonymous_args = 0
 1152              		@ link register save eliminated.
1158:../FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1153              		.loc 1 1158 0
 1154              	@ 1158 "../FreeRTOS/Source/tasks.c" 1
 1155 0000 4FF0BF00 			mov r0, #191								
 1156 0004 80F31188 		msr basepri, r0							
 1157              	
 1158              	@ 0 "" 2
1159:../FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1159              		.loc 1 1159 0
 1160              		.thumb
 1161 0008 024B     		ldr	r3, .L87
 1162 000a 0022     		movs	r2, #0
 1163 000c C3F81021 		str	r2, [r3, #272]
1161:../FreeRTOS/Source/tasks.c **** }
 1164              		.loc 1 1161 0
1160:../FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1165              		.loc 1 1160 0
 1166 0010 FFF7FEBF 		b	vPortEndScheduler
 1167              	.L88:
 1168              		.align	2
 1169              	.L87:
 1170 0014 00000000 		.word	.LANCHOR0
 1171              		.cfi_endproc
 1172              	.LFE121:
 1174              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1175              		.align	1
 1176              		.global	vTaskSuspendAll
 1177              		.thumb
 1178              		.thumb_func
 1180              	vTaskSuspendAll:
 1181              	.LFB122:
1165:../FreeRTOS/Source/tasks.c **** {
 1182              		.loc 1 1165 0
 1183              		.cfi_startproc
 1184              		@ args = 0, pretend = 0, frame = 0
 1185              		@ frame_needed = 0, uses_anonymous_args = 0
 1186              		@ link register save eliminated.
1168:../FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1187              		.loc 1 1168 0
 1188 0000 034B     		ldr	r3, .L90
 1189 0002 D3F82421 		ldr	r2, [r3, #292]
 1190 0006 0132     		adds	r2, r2, #1
 1191 0008 C3F82421 		str	r2, [r3, #292]
1169:../FreeRTOS/Source/tasks.c **** }
 1192              		.loc 1 1169 0
 1193 000c 7047     		bx	lr
 1194              	.L91:
 1195 000e 00BF     		.align	2
 1196              	.L90:
 1197 0010 00000000 		.word	.LANCHOR0
 1198              		.cfi_endproc
 1199              	.LFE122:
 1201              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1202              		.align	1
 1203              		.global	xTaskGetTickCount
 1204              		.thumb
 1205              		.thumb_func
 1207              	xTaskGetTickCount:
 1208              	.LFB124:
1260:../FreeRTOS/Source/tasks.c **** {
 1209              		.loc 1 1260 0
 1210              		.cfi_startproc
 1211              		@ args = 0, pretend = 0, frame = 0
 1212              		@ frame_needed = 0, uses_anonymous_args = 0
 1213 0000 10B5     		push	{r4, lr}
 1214              	.LCFI11:
 1215              		.cfi_def_cfa_offset 8
 1216              		.cfi_offset 14, -4
 1217              		.cfi_offset 4, -8
1264:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1218              		.loc 1 1264 0
 1219 0002 FFF7FEFF 		bl	vPortEnterCritical
1266:../FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 1220              		.loc 1 1266 0
 1221 0006 034B     		ldr	r3, .L93
 1222 0008 9C6B     		ldr	r4, [r3, #56]
 1223              	.LVL76:
1268:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1224              		.loc 1 1268 0
 1225 000a FFF7FEFF 		bl	vPortExitCritical
1271:../FreeRTOS/Source/tasks.c **** }
 1226              		.loc 1 1271 0
 1227 000e 2046     		mov	r0, r4
 1228 0010 10BD     		pop	{r4, pc}
 1229              	.L94:
 1230 0012 00BF     		.align	2
 1231              	.L93:
 1232 0014 00000000 		.word	.LANCHOR0
 1233              		.cfi_endproc
 1234              	.LFE124:
 1236              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1237              		.align	1
 1238              		.global	xTaskGetTickCountFromISR
 1239              		.thumb
 1240              		.thumb_func
 1242              	xTaskGetTickCountFromISR:
 1243              	.LFB125:
1275:../FreeRTOS/Source/tasks.c **** {
 1244              		.loc 1 1275 0
 1245              		.cfi_startproc
 1246              		@ args = 0, pretend = 0, frame = 0
 1247              		@ frame_needed = 0, uses_anonymous_args = 0
 1248              		@ link register save eliminated.
 1249              	.LVL77:
1279:../FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1250              		.loc 1 1279 0
 1251              	@ 1279 "../FreeRTOS/Source/tasks.c" 1
 1252 0000 4FF0BF00 			mov r0, #191								
 1253 0004 80F31188 		msr basepri, r0							
 1254              	
 1255              	@ 0 "" 2
1280:../FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
 1256              		.loc 1 1280 0
 1257              		.thumb
 1258 0008 034B     		ldr	r3, .L96
 1259 000a 9B6B     		ldr	r3, [r3, #56]
 1260              	.LVL78:
1281:../FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1261              		.loc 1 1281 0
 1262              	@ 1281 "../FreeRTOS/Source/tasks.c" 1
 1263 000c 4FF00000 			mov r0, #0					
 1264 0010 80F31188 		msr basepri, r0				
 1265              	
 1266              	@ 0 "" 2
1284:../FreeRTOS/Source/tasks.c **** }
 1267              		.loc 1 1284 0
 1268              		.thumb
 1269 0014 1846     		mov	r0, r3
 1270 0016 7047     		bx	lr
 1271              	.L97:
 1272              		.align	2
 1273              	.L96:
 1274 0018 00000000 		.word	.LANCHOR0
 1275              		.cfi_endproc
 1276              	.LFE125:
 1278              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1279              		.align	1
 1280              		.global	uxTaskGetNumberOfTasks
 1281              		.thumb
 1282              		.thumb_func
 1284              	uxTaskGetNumberOfTasks:
 1285              	.LFB126:
1288:../FreeRTOS/Source/tasks.c **** {
 1286              		.loc 1 1288 0
 1287              		.cfi_startproc
 1288              		@ args = 0, pretend = 0, frame = 0
 1289              		@ frame_needed = 0, uses_anonymous_args = 0
 1290              		@ link register save eliminated.
1291:../FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1291              		.loc 1 1291 0
 1292 0000 014B     		ldr	r3, .L99
 1293 0002 586C     		ldr	r0, [r3, #68]
1292:../FreeRTOS/Source/tasks.c **** }
 1294              		.loc 1 1292 0
 1295 0004 7047     		bx	lr
 1296              	.L100:
 1297 0006 00BF     		.align	2
 1298              	.L99:
 1299 0008 00000000 		.word	.LANCHOR0
 1300              		.cfi_endproc
 1301              	.LFE126:
 1303              		.section	.text.xTaskGetIdleTaskHandle,"ax",%progbits
 1304              		.align	1
 1305              		.global	xTaskGetIdleTaskHandle
 1306              		.thumb
 1307              		.thumb_func
 1309              	xTaskGetIdleTaskHandle:
 1310              	.LFB128:
1489:../FreeRTOS/Source/tasks.c **** 	{
 1311              		.loc 1 1489 0
 1312              		.cfi_startproc
 1313              		@ args = 0, pretend = 0, frame = 0
 1314              		@ frame_needed = 0, uses_anonymous_args = 0
 1315              		@ link register save eliminated.
1493:../FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
 1316              		.loc 1 1493 0
 1317 0000 014B     		ldr	r3, .L102
 1318 0002 D3F82801 		ldr	r0, [r3, #296]
1494:../FreeRTOS/Source/tasks.c **** 	}
 1319              		.loc 1 1494 0
 1320 0006 7047     		bx	lr
 1321              	.L103:
 1322              		.align	2
 1323              	.L102:
 1324 0008 00000000 		.word	.LANCHOR0
 1325              		.cfi_endproc
 1326              	.LFE128:
 1328              		.section	.text.vTaskIncrementTick,"ax",%progbits
 1329              		.align	1
 1330              		.global	vTaskIncrementTick
 1331              		.thumb
 1332              		.thumb_func
 1334              	vTaskIncrementTick:
 1335              	.LFB129:
1504:../FreeRTOS/Source/tasks.c **** {
 1336              		.loc 1 1504 0
 1337              		.cfi_startproc
 1338              		@ args = 0, pretend = 0, frame = 0
 1339              		@ frame_needed = 0, uses_anonymous_args = 0
1510:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1340              		.loc 1 1510 0
 1341 0000 2E4B     		ldr	r3, .L116
 1342 0002 D3F82421 		ldr	r2, [r3, #292]
1504:../FreeRTOS/Source/tasks.c **** {
 1343              		.loc 1 1504 0
 1344 0006 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1345              	.LCFI12:
 1346              		.cfi_def_cfa_offset 24
 1347              		.cfi_offset 14, -4
 1348              		.cfi_offset 8, -8
 1349              		.cfi_offset 7, -12
 1350              		.cfi_offset 6, -16
 1351              		.cfi_offset 5, -20
 1352              		.cfi_offset 4, -24
1510:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1353              		.loc 1 1510 0
 1354 000a 002A     		cmp	r2, #0
 1355 000c 4ED1     		bne	.L105
1512:../FreeRTOS/Source/tasks.c **** 		++xTickCount;
 1356              		.loc 1 1512 0
 1357 000e 9A6B     		ldr	r2, [r3, #56]
 1358 0010 0132     		adds	r2, r2, #1
 1359 0012 9A63     		str	r2, [r3, #56]
1513:../FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 1360              		.loc 1 1513 0
 1361 0014 9A6B     		ldr	r2, [r3, #56]
 1362 0016 A2B9     		cbnz	r2, .L106
 1363              	.LBB53:
1522:../FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1364              		.loc 1 1522 0
 1365 0018 1A6C     		ldr	r2, [r3, #64]
 1366              	.LVL79:
1523:../FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1367              		.loc 1 1523 0
 1368 001a D96B     		ldr	r1, [r3, #60]
 1369 001c 1964     		str	r1, [r3, #64]
1524:../FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1370              		.loc 1 1524 0
 1371 001e DA63     		str	r2, [r3, #60]
1525:../FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
 1372              		.loc 1 1525 0
 1373 0020 D3F82C21 		ldr	r2, [r3, #300]
 1374              	.LVL80:
 1375 0024 0132     		adds	r2, r2, #1
 1376 0026 C3F82C21 		str	r2, [r3, #300]
1527:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1377              		.loc 1 1527 0
 1378 002a 1A6C     		ldr	r2, [r3, #64]
 1379 002c 1168     		ldr	r1, [r2, #0]
 1380 002e 244A     		ldr	r2, .L116+4
 1381 0030 11B9     		cbnz	r1, .L107
1534:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 1382              		.loc 1 1534 0
 1383 0032 4FF0FF33 		mov	r3, #-1
 1384 0036 03E0     		b	.L115
 1385              	.L107:
1542:../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1386              		.loc 1 1542 0
 1387 0038 1B6C     		ldr	r3, [r3, #64]
 1388 003a DB68     		ldr	r3, [r3, #12]
 1389 003c DB68     		ldr	r3, [r3, #12]
 1390              	.LVL81:
1543:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1391              		.loc 1 1543 0
 1392 003e 5B68     		ldr	r3, [r3, #4]
 1393              	.LVL82:
 1394              	.L115:
 1395 0040 1360     		str	r3, [r2, #0]
 1396              	.LVL83:
 1397              	.L106:
 1398              	.LBE53:
 1399              	.LBB54:
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1400              		.loc 1 1548 0
 1401 0042 1E4C     		ldr	r4, .L116
 1402 0044 1E4B     		ldr	r3, .L116+4
 1403 0046 A26B     		ldr	r2, [r4, #56]
 1404 0048 1B68     		ldr	r3, [r3, #0]
 1405 004a 9A42     		cmp	r2, r3
 1406 004c 33D3     		bcc	.L104
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1407              		.loc 1 1548 0 is_stmt 0 discriminator 1
 1408 004e 04F14806 		add	r6, r4, #72
 1409 0052 1425     		movs	r5, #20
 1410              	.L114:
 1411 0054 236C     		ldr	r3, [r4, #64]
 1412 0056 1B68     		ldr	r3, [r3, #0]
 1413 0058 2BB9     		cbnz	r3, .L109
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1414              		.loc 1 1548 0 discriminator 2
 1415 005a 194B     		ldr	r3, .L116+4
 1416 005c 4FF0FF32 		mov	r2, #-1
 1417 0060 1A60     		str	r2, [r3, #0]
 1418 0062 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1419              	.L109:
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1420              		.loc 1 1548 0 discriminator 3
 1421 0066 236C     		ldr	r3, [r4, #64]
 1422 0068 DB68     		ldr	r3, [r3, #12]
 1423 006a DF68     		ldr	r7, [r3, #12]
 1424              	.LVL84:
 1425 006c A26B     		ldr	r2, [r4, #56]
 1426 006e 7B68     		ldr	r3, [r7, #4]
 1427              	.LVL85:
 1428 0070 9A42     		cmp	r2, r3
 1429 0072 03D2     		bcs	.L110
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1430              		.loc 1 1548 0
 1431 0074 124A     		ldr	r2, .L116+4
 1432 0076 1360     		str	r3, [r2, #0]
 1433 0078 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1434              	.L110:
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1435              		.loc 1 1548 0 discriminator 5
 1436 007c 07F10408 		add	r8, r7, #4
 1437 0080 4046     		mov	r0, r8
 1438 0082 FFF7FEFF 		bl	vListRemove
 1439              	.LVL86:
 1440 0086 BB6A     		ldr	r3, [r7, #40]
 1441 0088 1BB1     		cbz	r3, .L111
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1442              		.loc 1 1548 0 discriminator 6
 1443 008a 07F11800 		add	r0, r7, #24
 1444 008e FFF7FEFF 		bl	vListRemove
 1445              	.L111:
1548:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 1446              		.loc 1 1548 0 discriminator 7
 1447 0092 F86A     		ldr	r0, [r7, #44]
 1448 0094 D4F81C31 		ldr	r3, [r4, #284]
 1449 0098 9842     		cmp	r0, r3
 1450 009a 88BF     		it	hi
 1451 009c C4F81C01 		strhi	r0, [r4, #284]
 1452 00a0 4146     		mov	r1, r8
 1453 00a2 05FB0060 		mla	r0, r5, r0, r6
 1454 00a6 FFF7FEFF 		bl	vListInsertEnd
 1455 00aa D3E7     		b	.L114
 1456              	.LVL87:
 1457              	.L105:
 1458              	.LBE54:
1552:../FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
 1459              		.loc 1 1552 0 is_stmt 1
 1460 00ac D3F83021 		ldr	r2, [r3, #304]
 1461 00b0 0132     		adds	r2, r2, #1
 1462 00b2 C3F83021 		str	r2, [r3, #304]
 1463              	.L104:
 1464 00b6 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1465              	.L117:
 1466 00ba 00BF     		.align	2
 1467              	.L116:
 1468 00bc 00000000 		.word	.LANCHOR0
 1469 00c0 00000000 		.word	.LANCHOR1
 1470              		.cfi_endproc
 1471              	.LFE129:
 1473              		.section	.text.xTaskResumeAll,"ax",%progbits
 1474              		.align	1
 1475              		.global	xTaskResumeAll
 1476              		.thumb
 1477              		.thumb_func
 1479              	xTaskResumeAll:
 1480              	.LFB123:
1173:../FreeRTOS/Source/tasks.c **** {
 1481              		.loc 1 1173 0
 1482              		.cfi_startproc
 1483              		@ args = 0, pretend = 0, frame = 0
 1484              		@ frame_needed = 0, uses_anonymous_args = 0
 1485              	.LVL88:
 1486 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1487              	.LCFI13:
 1488              		.cfi_def_cfa_offset 32
 1489              		.cfi_offset 14, -4
 1490              		.cfi_offset 9, -8
 1491              		.cfi_offset 8, -12
 1492              		.cfi_offset 7, -16
 1493              		.cfi_offset 6, -20
 1494              		.cfi_offset 5, -24
 1495              		.cfi_offset 4, -28
 1496              		.cfi_offset 3, -32
1186:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1497              		.loc 1 1186 0
 1498 0004 FFF7FEFF 		bl	vPortEnterCritical
1188:../FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1499              		.loc 1 1188 0
 1500 0008 2C4B     		ldr	r3, .L136
 1501 000a D3F82421 		ldr	r2, [r3, #292]
 1502 000e 013A     		subs	r2, r2, #1
 1503 0010 C3F82421 		str	r2, [r3, #292]
1190:../FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1504              		.loc 1 1190 0
 1505 0014 D3F82461 		ldr	r6, [r3, #292]
1175:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1506              		.loc 1 1175 0
 1507 0018 0024     		movs	r4, #0
1190:../FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1508              		.loc 1 1190 0
 1509 001a 002E     		cmp	r6, #0
 1510 001c 49D1     		bne	.L119
1192:../FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1511              		.loc 1 1192 0
 1512 001e 5C6C     		ldr	r4, [r3, #68]
 1513 0020 FCB9     		cbnz	r4, .L129
 1514 0022 46E0     		b	.L119
 1515              	.LVL89:
 1516              	.L123:
 1517              	.LBB55:
1200:../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1518              		.loc 1 1200 0
 1519 0024 D4F8E030 		ldr	r3, [r4, #224]
 1520 0028 DD68     		ldr	r5, [r3, #12]
 1521              	.LVL90:
1201:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1522              		.loc 1 1201 0
 1523 002a 05F11800 		add	r0, r5, #24
1202:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1524              		.loc 1 1202 0
 1525 002e 05F10409 		add	r9, r5, #4
1201:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1526              		.loc 1 1201 0
 1527 0032 FFF7FEFF 		bl	vListRemove
1202:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1528              		.loc 1 1202 0
 1529 0036 4846     		mov	r0, r9
 1530 0038 FFF7FEFF 		bl	vListRemove
1203:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1531              		.loc 1 1203 0
 1532 003c E86A     		ldr	r0, [r5, #44]
 1533 003e D4F81C31 		ldr	r3, [r4, #284]
 1534 0042 9842     		cmp	r0, r3
 1535 0044 88BF     		it	hi
 1536 0046 C4F81C01 		strhi	r0, [r4, #284]
 1537 004a 4946     		mov	r1, r9
 1538 004c 07FB0080 		mla	r0, r7, r0, r8
 1539 0050 FFF7FEFF 		bl	vListInsertEnd
1207:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1540              		.loc 1 1207 0
 1541 0054 636B     		ldr	r3, [r4, #52]
 1542 0056 EA6A     		ldr	r2, [r5, #44]
 1543 0058 DB6A     		ldr	r3, [r3, #44]
1209:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1544              		.loc 1 1209 0
 1545 005a 9A42     		cmp	r2, r3
 1546 005c 28BF     		it	cs
 1547 005e 0126     		movcs	r6, #1
 1548              	.LVL91:
 1549 0060 03E0     		b	.L132
 1550              	.LVL92:
 1551              	.L129:
1198:../FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1552              		.loc 1 1198 0
 1553 0062 1C46     		mov	r4, r3
1203:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1554              		.loc 1 1203 0
 1555 0064 03F14808 		add	r8, r3, #72
 1556 0068 1427     		movs	r7, #20
 1557              	.L132:
 1558              	.LVL93:
1198:../FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1559              		.loc 1 1198 0 discriminator 1
 1560 006a D4F8D420 		ldr	r2, [r4, #212]
 1561 006e 134B     		ldr	r3, .L136
 1562 0070 002A     		cmp	r2, #0
 1563 0072 D7D1     		bne	.L123
1216:../FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1564              		.loc 1 1216 0
 1565 0074 D3F83041 		ldr	r4, [r3, #304]
 1566 0078 44B9     		cbnz	r4, .L124
 1567 007a 0DE0     		b	.L135
 1568              	.L126:
1220:../FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
 1569              		.loc 1 1220 0
 1570 007c FFF7FEFF 		bl	vTaskIncrementTick
1221:../FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
 1571              		.loc 1 1221 0
 1572 0080 D4F83031 		ldr	r3, [r4, #304]
 1573 0084 013B     		subs	r3, r3, #1
 1574 0086 C4F83031 		str	r3, [r4, #304]
 1575 008a 00E0     		b	.L134
 1576              	.L124:
1218:../FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1577              		.loc 1 1218 0 discriminator 1
 1578 008c 1C46     		mov	r4, r3
 1579              	.L134:
 1580 008e D4F83031 		ldr	r3, [r4, #304]
 1581 0092 002B     		cmp	r3, #0
 1582 0094 F2D1     		bne	.L126
 1583 0096 05E0     		b	.L127
 1584              	.L135:
1234:../FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1585              		.loc 1 1234 0
 1586 0098 012E     		cmp	r6, #1
 1587 009a 03D0     		beq	.L127
1234:../FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1588              		.loc 1 1234 0 is_stmt 0 discriminator 1
 1589 009c D3F83431 		ldr	r3, [r3, #308]
 1590 00a0 012B     		cmp	r3, #1
 1591 00a2 06D1     		bne	.L119
 1592              	.L127:
 1593              	.LVL94:
1237:../FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1594              		.loc 1 1237 0 is_stmt 1
 1595 00a4 054B     		ldr	r3, .L136
 1596 00a6 0022     		movs	r2, #0
 1597 00a8 C3F83421 		str	r2, [r3, #308]
1238:../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1598              		.loc 1 1238 0
 1599 00ac FFF7FEFF 		bl	vPortYieldFromISR
1236:../FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1600              		.loc 1 1236 0
 1601 00b0 0124     		movs	r4, #1
 1602              	.LVL95:
 1603              	.L119:
 1604              	.LBE55:
1243:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1605              		.loc 1 1243 0
 1606 00b2 FFF7FEFF 		bl	vPortExitCritical
1246:../FreeRTOS/Source/tasks.c **** }
 1607              		.loc 1 1246 0
 1608 00b6 2046     		mov	r0, r4
 1609 00b8 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1610              	.L137:
 1611              		.align	2
 1612              	.L136:
 1613 00bc 00000000 		.word	.LANCHOR0
 1614              		.cfi_endproc
 1615              	.LFE123:
 1617              		.section	.text.vTaskGetRunTimeStats,"ax",%progbits
 1618              		.align	1
 1619              		.global	vTaskGetRunTimeStats
 1620              		.thumb
 1621              		.thumb_func
 1623              	vTaskGetRunTimeStats:
 1624              	.LFB127:
1376:../FreeRTOS/Source/tasks.c **** 	{
 1625              		.loc 1 1376 0
 1626              		.cfi_startproc
 1627              		@ args = 0, pretend = 0, frame = 0
 1628              		@ frame_needed = 0, uses_anonymous_args = 0
 1629              	.LVL96:
 1630 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1631              	.LCFI14:
 1632              		.cfi_def_cfa_offset 24
 1633              		.cfi_offset 14, -4
 1634              		.cfi_offset 8, -8
 1635              		.cfi_offset 7, -12
 1636              		.cfi_offset 6, -16
 1637              		.cfi_offset 5, -20
 1638              		.cfi_offset 4, -24
1376:../FreeRTOS/Source/tasks.c **** 	{
 1639              		.loc 1 1376 0
 1640 0004 0446     		mov	r4, r0
1383:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 1641              		.loc 1 1383 0
 1642 0006 FFF7FEFF 		bl	vTaskSuspendAll
 1643              	.LVL97:
1388:../FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 1644              		.loc 1 1388 0
 1645 000a FFF7FEFF 		bl	get_us_time
 1646              	.LVL98:
1393:../FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
 1647              		.loc 1 1393 0
 1648 000e 6423     		movs	r3, #100
 1649 0010 B0FBF3F5 		udiv	r5, r0, r3
 1650              	.LVL99:
1402:../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 1651              		.loc 1 1402 0
 1652 0014 224F     		ldr	r7, .L146
1400:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 1653              		.loc 1 1400 0
 1654 0016 2349     		ldr	r1, .L146+4
1399:../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 1655              		.loc 1 1399 0
 1656 0018 0023     		movs	r3, #0
 1657 001a 2370     		strb	r3, [r4, #0]
1400:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 1658              		.loc 1 1400 0
 1659 001c 2046     		mov	r0, r4
 1660 001e FFF7FEFF 		bl	strcat
1402:../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 1661              		.loc 1 1402 0
 1662 0022 D7F81461 		ldr	r6, [r7, #276]
1408:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 1663              		.loc 1 1408 0
 1664 0026 4FF01408 		mov	r8, #20
1402:../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 1665              		.loc 1 1402 0
 1666 002a 0136     		adds	r6, r6, #1
 1667              	.LVL100:
1408:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 1668              		.loc 1 1408 0
 1669 002c 4837     		adds	r7, r7, #72
 1670              	.L140:
1406:../FreeRTOS/Source/tasks.c **** 				uxQueue--;
 1671              		.loc 1 1406 0
 1672 002e 013E     		subs	r6, r6, #1
 1673              	.LVL101:
1408:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 1674              		.loc 1 1408 0
 1675 0030 08FB06F3 		mul	r3, r8, r6
 1676 0034 F918     		adds	r1, r7, r3
 1677 0036 FB58     		ldr	r3, [r7, r3]
 1678 0038 23B1     		cbz	r3, .L139
1410:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
 1679              		.loc 1 1410 0
 1680 003a 2046     		mov	r0, r4
 1681 003c 2A46     		mov	r2, r5
 1682 003e 5223     		movs	r3, #82
 1683 0040 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1684              	.L139:
1412:../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 1685              		.loc 1 1412 0
 1686 0044 002E     		cmp	r6, #0
 1687 0046 F2D1     		bne	.L140
1414:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 1688              		.loc 1 1414 0
 1689 0048 154E     		ldr	r6, .L146
 1690              	.LVL102:
 1691 004a 336C     		ldr	r3, [r6, #64]
 1692 004c 1B68     		ldr	r3, [r3, #0]
 1693 004e 2BB1     		cbz	r3, .L141
1416:../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
 1694              		.loc 1 1416 0
 1695 0050 316C     		ldr	r1, [r6, #64]
 1696 0052 2046     		mov	r0, r4
 1697 0054 2A46     		mov	r2, r5
 1698 0056 4223     		movs	r3, #66
 1699 0058 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1700              	.L141:
1419:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 1701              		.loc 1 1419 0
 1702 005c F36B     		ldr	r3, [r6, #60]
 1703 005e 1B68     		ldr	r3, [r3, #0]
 1704 0060 33B1     		cbz	r3, .L142
1421:../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
 1705              		.loc 1 1421 0
 1706 0062 0F4B     		ldr	r3, .L146
 1707 0064 2046     		mov	r0, r4
 1708 0066 D96B     		ldr	r1, [r3, #60]
 1709 0068 2A46     		mov	r2, r5
 1710 006a 4223     		movs	r3, #66
 1711 006c FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1712              	.L142:
1426:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 1713              		.loc 1 1426 0
 1714 0070 0B4E     		ldr	r6, .L146
 1715 0072 D6F8E830 		ldr	r3, [r6, #232]
 1716 0076 33B1     		cbz	r3, .L143
1428:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
 1717              		.loc 1 1428 0
 1718 0078 2046     		mov	r0, r4
 1719 007a 06F1E801 		add	r1, r6, #232
 1720 007e 2A46     		mov	r2, r5
 1721 0080 4423     		movs	r3, #68
 1722 0082 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1723              	.L143:
1435:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 1724              		.loc 1 1435 0
 1725 0086 D6F8FC30 		ldr	r3, [r6, #252]
 1726 008a 2BB1     		cbz	r3, .L144
1437:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime, tsk
 1727              		.loc 1 1437 0
 1728 008c 2046     		mov	r0, r4
 1729 008e 0649     		ldr	r1, .L146+8
 1730 0090 2A46     		mov	r2, r5
 1731 0092 5323     		movs	r3, #83
 1732 0094 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1733              	.L144:
1443:../FreeRTOS/Source/tasks.c **** 	}
 1734              		.loc 1 1443 0
 1735 0098 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
1442:../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
 1736              		.loc 1 1442 0
 1737 009c FFF7FEBF 		b	xTaskResumeAll
 1738              	.L147:
 1739              		.align	2
 1740              	.L146:
 1741 00a0 00000000 		.word	.LANCHOR0
 1742 00a4 6B000000 		.word	.LC4
 1743 00a8 FC000000 		.word	.LANCHOR0+252
 1744              		.cfi_endproc
 1745              	.LFE127:
 1747              		.section	.text.prvIdleTask,"ax",%progbits
 1748              		.align	1
 1749              		.thumb
 1750              		.thumb_func
 1752              	prvIdleTask:
 1753              	.LFB139:
1921:../FreeRTOS/Source/tasks.c **** {
 1754              		.loc 1 1921 0
 1755              		.cfi_startproc
 1756              		@ args = 0, pretend = 0, frame = 0
 1757              		@ frame_needed = 0, uses_anonymous_args = 0
 1758              	.LVL103:
 1759 0000 38B5     		push	{r3, r4, r5, lr}
 1760              	.LCFI15:
 1761              		.cfi_def_cfa_offset 16
 1762              		.cfi_offset 14, -4
 1763              		.cfi_offset 5, -8
 1764              		.cfi_offset 4, -12
 1765              		.cfi_offset 3, -16
 1766              	.LBB56:
 1767              	.LBB57:
2111:../FreeRTOS/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 1768              		.loc 1 2111 0
 1769 0002 144C     		ldr	r4, .L155
 1770              	.LVL104:
 1771              	.L154:
 1772 0004 D4F82031 		ldr	r3, [r4, #288]
 1773 0008 F3B1     		cbz	r3, .L149
2113:../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 1774              		.loc 1 2113 0
 1775 000a FFF7FEFF 		bl	vTaskSuspendAll
2114:../FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 1776              		.loc 1 2114 0
 1777 000e D4F8E850 		ldr	r5, [r4, #232]
 1778              	.LVL105:
2115:../FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
 1779              		.loc 1 2115 0
 1780 0012 FFF7FEFF 		bl	xTaskResumeAll
2117:../FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 1781              		.loc 1 2117 0
 1782 0016 BDB1     		cbz	r5, .L149
 1783              	.LBB58:
2121:../FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 1784              		.loc 1 2121 0
 1785 0018 FFF7FEFF 		bl	vPortEnterCritical
2123:../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 1786              		.loc 1 2123 0
 1787 001c D4F8F430 		ldr	r3, [r4, #244]
 1788 0020 DD68     		ldr	r5, [r3, #12]
 1789              	.LVL106:
2124:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1790              		.loc 1 2124 0
 1791 0022 281D     		adds	r0, r5, #4
 1792 0024 FFF7FEFF 		bl	vListRemove
2125:../FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 1793              		.loc 1 2125 0
 1794 0028 636C     		ldr	r3, [r4, #68]
 1795 002a 013B     		subs	r3, r3, #1
 1796 002c 6364     		str	r3, [r4, #68]
2126:../FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 1797              		.loc 1 2126 0
 1798 002e D4F82031 		ldr	r3, [r4, #288]
 1799 0032 013B     		subs	r3, r3, #1
 1800 0034 C4F82031 		str	r3, [r4, #288]
2128:../FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 1801              		.loc 1 2128 0
 1802 0038 FFF7FEFF 		bl	vPortExitCritical
 1803              	.LVL107:
 1804              	.LBB59:
 1805              	.LBB60:
2314:../FreeRTOS/Source/tasks.c **** 
2315:../FreeRTOS/Source/tasks.c **** #endif
2316:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2317:../FreeRTOS/Source/tasks.c **** 
2318:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2319:../FreeRTOS/Source/tasks.c **** 
2320:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2321:../FreeRTOS/Source/tasks.c **** 	{
2322:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2323:../FreeRTOS/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2324:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2325:../FreeRTOS/Source/tasks.c **** 
2326:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2327:../FreeRTOS/Source/tasks.c **** 
2328:../FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2329:../FreeRTOS/Source/tasks.c **** 		{
2330:../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2331:../FreeRTOS/Source/tasks.c **** 		}
2332:../FreeRTOS/Source/tasks.c **** 		#else
2333:../FreeRTOS/Source/tasks.c **** 		{
2334:../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2335:../FreeRTOS/Source/tasks.c **** 		}
2336:../FreeRTOS/Source/tasks.c **** 		#endif
2337:../FreeRTOS/Source/tasks.c **** 
2338:../FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2339:../FreeRTOS/Source/tasks.c **** 
2340:../FreeRTOS/Source/tasks.c **** 		return uxReturn;
2341:../FreeRTOS/Source/tasks.c **** 	}
2342:../FreeRTOS/Source/tasks.c **** 
2343:../FreeRTOS/Source/tasks.c **** #endif
2344:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2345:../FreeRTOS/Source/tasks.c **** 
2346:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2347:../FreeRTOS/Source/tasks.c **** 
2348:../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2349:../FreeRTOS/Source/tasks.c **** 	{
2350:../FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2351:../FreeRTOS/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2352:../FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 1806              		.loc 1 2352 0
 1807 003c 286B     		ldr	r0, [r5, #48]
 1808 003e FFF7FEFF 		bl	free
2353:../FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
 1809              		.loc 1 2353 0
 1810 0042 2846     		mov	r0, r5
 1811 0044 FFF7FEFF 		bl	free
 1812              	.LVL108:
 1813              	.L149:
 1814              	.LBE60:
 1815              	.LBE59:
 1816              	.LBE58:
 1817              	.LBE57:
 1818              	.LBE56:
1951:../FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 1819              		.loc 1 1951 0
 1820 0048 A36C     		ldr	r3, [r4, #72]
 1821 004a 012B     		cmp	r3, #1
 1822 004c DAD9     		bls	.L154
1953:../FreeRTOS/Source/tasks.c **** 				taskYIELD();
 1823              		.loc 1 1953 0
 1824 004e FFF7FEFF 		bl	vPortYieldFromISR
 1825 0052 D7E7     		b	.L154
 1826              	.L156:
 1827              		.align	2
 1828              	.L155:
 1829 0054 00000000 		.word	.LANCHOR0
 1830              		.cfi_endproc
 1831              	.LFE139:
 1833              		.section	.text.vTaskDelay,"ax",%progbits
 1834              		.align	1
 1835              		.global	vTaskDelay
 1836              		.thumb
 1837              		.thumb_func
 1839              	vTaskDelay:
 1840              	.LFB113:
 729:../FreeRTOS/Source/tasks.c **** 	{
 1841              		.loc 1 729 0
 1842              		.cfi_startproc
 1843              		@ args = 0, pretend = 0, frame = 0
 1844              		@ frame_needed = 0, uses_anonymous_args = 0
 1845              	.LVL109:
 1846 0000 10B5     		push	{r4, lr}
 1847              	.LCFI16:
 1848              		.cfi_def_cfa_offset 8
 1849              		.cfi_offset 14, -4
 1850              		.cfi_offset 4, -8
 729:../FreeRTOS/Source/tasks.c **** 	{
 1851              		.loc 1 729 0
 1852 0002 0446     		mov	r4, r0
 734:../FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 1853              		.loc 1 734 0
 1854 0004 70B1     		cbz	r0, .L158
 736:../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 1855              		.loc 1 736 0
 1856 0006 FFF7FEFF 		bl	vTaskSuspendAll
 1857              	.LVL110:
 750:../FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1858              		.loc 1 750 0
 1859 000a 094B     		ldr	r3, .L160
 1860 000c 9A6B     		ldr	r2, [r3, #56]
 755:../FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1861              		.loc 1 755 0
 1862 000e 586B     		ldr	r0, [r3, #52]
 750:../FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1863              		.loc 1 750 0
 1864 0010 A418     		adds	r4, r4, r2
 1865              	.LVL111:
 755:../FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1866              		.loc 1 755 0
 1867 0012 0430     		adds	r0, r0, #4
 1868 0014 FFF7FEFF 		bl	vListRemove
 756:../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1869              		.loc 1 756 0
 1870 0018 2046     		mov	r0, r4
 1871 001a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 758:../FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 1872              		.loc 1 758 0
 1873 001e FFF7FEFF 		bl	xTaskResumeAll
 1874              	.LVL112:
 763:../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1875              		.loc 1 763 0
 1876 0022 18B9     		cbnz	r0, .L157
 1877              	.LVL113:
 1878              	.L158:
 767:../FreeRTOS/Source/tasks.c **** 	}
 1879              		.loc 1 767 0
 1880 0024 BDE81040 		pop	{r4, lr}
 765:../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 1881              		.loc 1 765 0
 1882 0028 FFF7FEBF 		b	vPortYieldFromISR
 1883              	.LVL114:
 1884              	.L157:
 1885 002c 10BD     		pop	{r4, pc}
 1886              	.L161:
 1887 002e 00BF     		.align	2
 1888              	.L160:
 1889 0030 00000000 		.word	.LANCHOR0
 1890              		.cfi_endproc
 1891              	.LFE113:
 1893              		.section	.text.vTaskDelayUntil,"ax",%progbits
 1894              		.align	1
 1895              		.global	vTaskDelayUntil
 1896              		.thumb
 1897              		.thumb_func
 1899              	vTaskDelayUntil:
 1900              	.LFB112:
 664:../FreeRTOS/Source/tasks.c **** 	{
 1901              		.loc 1 664 0
 1902              		.cfi_startproc
 1903              		@ args = 0, pretend = 0, frame = 0
 1904              		@ frame_needed = 0, uses_anonymous_args = 0
 1905              	.LVL115:
 1906 0000 38B5     		push	{r3, r4, r5, lr}
 1907              	.LCFI17:
 1908              		.cfi_def_cfa_offset 16
 1909              		.cfi_offset 14, -4
 1910              		.cfi_offset 5, -8
 1911              		.cfi_offset 4, -12
 1912              		.cfi_offset 3, -16
 664:../FreeRTOS/Source/tasks.c **** 	{
 1913              		.loc 1 664 0
 1914 0002 0C46     		mov	r4, r1
 1915 0004 0546     		mov	r5, r0
 671:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 1916              		.loc 1 671 0
 1917 0006 FFF7FEFF 		bl	vTaskSuspendAll
 1918              	.LVL116:
 676:../FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1919              		.loc 1 676 0
 1920 000a 134A     		ldr	r2, .L170
 674:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1921              		.loc 1 674 0
 1922 000c 2B68     		ldr	r3, [r5, #0]
 676:../FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1923              		.loc 1 676 0
 1924 000e 916B     		ldr	r1, [r2, #56]
 1925 0010 9942     		cmp	r1, r3
 674:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1926              		.loc 1 674 0
 1927 0012 1C44     		add	r4, r4, r3
 1928              	.LVL117:
 676:../FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1929              		.loc 1 676 0
 1930 0014 02D2     		bcs	.L163
 683:../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 1931              		.loc 1 683 0
 1932 0016 9C42     		cmp	r4, r3
 1933 0018 08D2     		bcs	.L167
 1934 001a 01E0     		b	.L169
 1935              	.L163:
 693:../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1936              		.loc 1 693 0
 1937 001c 9C42     		cmp	r4, r3
 1938 001e 07D3     		bcc	.L168
 1939              	.L169:
 693:../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1940              		.loc 1 693 0 is_stmt 0 discriminator 1
 1941 0020 936B     		ldr	r3, [r2, #56]
 666:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 1942              		.loc 1 666 0 is_stmt 1 discriminator 1
 1943 0022 9C42     		cmp	r4, r3
 1944 0024 94BF     		ite	ls
 1945 0026 0023     		movls	r3, #0
 1946 0028 0123     		movhi	r3, #1
 1947 002a 02E0     		b	.L164
 1948              	.L167:
 666:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 1949              		.loc 1 666 0 is_stmt 0
 1950 002c 0023     		movs	r3, #0
 1951 002e 00E0     		b	.L164
 1952              	.L168:
 695:../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 1953              		.loc 1 695 0 is_stmt 1
 1954 0030 0123     		movs	r3, #1
 1955              	.L164:
 1956              	.LVL118:
 700:../FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 1957              		.loc 1 700 0
 1958 0032 2C60     		str	r4, [r5, #0]
 702:../FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 1959              		.loc 1 702 0
 1960 0034 3BB1     		cbz	r3, .L165
 709:../FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1961              		.loc 1 709 0
 1962 0036 084B     		ldr	r3, .L170
 1963              	.LVL119:
 1964 0038 586B     		ldr	r0, [r3, #52]
 1965 003a 0430     		adds	r0, r0, #4
 1966 003c FFF7FEFF 		bl	vListRemove
 710:../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1967              		.loc 1 710 0
 1968 0040 2046     		mov	r0, r4
 1969 0042 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 1970              	.L165:
 713:../FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 1971              		.loc 1 713 0
 1972 0046 FFF7FEFF 		bl	xTaskResumeAll
 1973              	.LVL120:
 717:../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1974              		.loc 1 717 0
 1975 004a 18B9     		cbnz	r0, .L162
 721:../FreeRTOS/Source/tasks.c **** 	}
 1976              		.loc 1 721 0
 1977 004c BDE83840 		pop	{r3, r4, r5, lr}
 719:../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 1978              		.loc 1 719 0
 1979 0050 FFF7FEBF 		b	vPortYieldFromISR
 1980              	.LVL121:
 1981              	.L162:
 1982 0054 38BD     		pop	{r3, r4, r5, pc}
 1983              	.L171:
 1984 0056 00BF     		.align	2
 1985              	.L170:
 1986 0058 00000000 		.word	.LANCHOR0
 1987              		.cfi_endproc
 1988              	.LFE112:
 1990              		.section	.text.vTaskSetApplicationTaskTag,"ax",%progbits
 1991              		.align	1
 1992              		.global	vTaskSetApplicationTaskTag
 1993              		.thumb
 1994              		.thumb_func
 1996              	vTaskSetApplicationTaskTag:
 1997              	.LFB130:
1581:../FreeRTOS/Source/tasks.c **** 	{
 1998              		.loc 1 1581 0
 1999              		.cfi_startproc
 2000              		@ args = 0, pretend = 0, frame = 0
 2001              		@ frame_needed = 0, uses_anonymous_args = 0
 2002              	.LVL122:
 2003 0000 38B5     		push	{r3, r4, r5, lr}
 2004              	.LCFI18:
 2005              		.cfi_def_cfa_offset 16
 2006              		.cfi_offset 14, -4
 2007              		.cfi_offset 5, -8
 2008              		.cfi_offset 4, -12
 2009              		.cfi_offset 3, -16
1581:../FreeRTOS/Source/tasks.c **** 	{
 2010              		.loc 1 1581 0
 2011 0002 0D46     		mov	r5, r1
1585:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2012              		.loc 1 1585 0
 2013 0004 0446     		mov	r4, r0
 2014 0006 08B9     		cbnz	r0, .L173
1587:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2015              		.loc 1 1587 0
 2016 0008 044B     		ldr	r3, .L175
 2017 000a 5C6B     		ldr	r4, [r3, #52]
 2018              	.LVL123:
 2019              	.L173:
1596:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2020              		.loc 1 1596 0
 2021 000c FFF7FEFF 		bl	vPortEnterCritical
 2022              	.LVL124:
1597:../FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
 2023              		.loc 1 1597 0
 2024 0010 A564     		str	r5, [r4, #72]
1599:../FreeRTOS/Source/tasks.c **** 	}
 2025              		.loc 1 1599 0
 2026 0012 BDE83840 		pop	{r3, r4, r5, lr}
1598:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2027              		.loc 1 1598 0
 2028 0016 FFF7FEBF 		b	vPortExitCritical
 2029              	.L176:
 2030 001a 00BF     		.align	2
 2031              	.L175:
 2032 001c 00000000 		.word	.LANCHOR0
 2033              		.cfi_endproc
 2034              	.LFE130:
 2036              		.section	.text.xTaskGetApplicationTaskTag,"ax",%progbits
 2037              		.align	1
 2038              		.global	xTaskGetApplicationTaskTag
 2039              		.thumb
 2040              		.thumb_func
 2042              	xTaskGetApplicationTaskTag:
 2043              	.LFB131:
1607:../FreeRTOS/Source/tasks.c **** 	{
 2044              		.loc 1 1607 0
 2045              		.cfi_startproc
 2046              		@ args = 0, pretend = 0, frame = 0
 2047              		@ frame_needed = 0, uses_anonymous_args = 0
 2048              	.LVL125:
 2049 0000 10B5     		push	{r4, lr}
 2050              	.LCFI19:
 2051              		.cfi_def_cfa_offset 8
 2052              		.cfi_offset 14, -4
 2053              		.cfi_offset 4, -8
1612:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2054              		.loc 1 1612 0
 2055 0002 0446     		mov	r4, r0
 2056 0004 08B9     		cbnz	r0, .L178
1614:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2057              		.loc 1 1614 0
 2058 0006 044B     		ldr	r3, .L180
 2059 0008 5C6B     		ldr	r4, [r3, #52]
 2060              	.LVL126:
 2061              	.L178:
1623:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2062              		.loc 1 1623 0
 2063 000a FFF7FEFF 		bl	vPortEnterCritical
 2064              	.LVL127:
1624:../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
 2065              		.loc 1 1624 0
 2066 000e A46C     		ldr	r4, [r4, #72]
 2067              	.LVL128:
1625:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2068              		.loc 1 1625 0
 2069 0010 FFF7FEFF 		bl	vPortExitCritical
1628:../FreeRTOS/Source/tasks.c **** 	}
 2070              		.loc 1 1628 0
 2071 0014 2046     		mov	r0, r4
 2072 0016 10BD     		pop	{r4, pc}
 2073              	.L181:
 2074              		.align	2
 2075              	.L180:
 2076 0018 00000000 		.word	.LANCHOR0
 2077              		.cfi_endproc
 2078              	.LFE131:
 2080              		.section	.text.xTaskCallApplicationTaskHook,"ax",%progbits
 2081              		.align	1
 2082              		.global	xTaskCallApplicationTaskHook
 2083              		.thumb
 2084              		.thumb_func
 2086              	xTaskCallApplicationTaskHook:
 2087              	.LFB132:
1636:../FreeRTOS/Source/tasks.c **** 	{
 2088              		.loc 1 1636 0
 2089              		.cfi_startproc
 2090              		@ args = 0, pretend = 0, frame = 0
 2091              		@ frame_needed = 0, uses_anonymous_args = 0
 2092              	.LVL129:
 2093 0000 08B5     		push	{r3, lr}
 2094              	.LCFI20:
 2095              		.cfi_def_cfa_offset 8
 2096              		.cfi_offset 14, -4
 2097              		.cfi_offset 3, -8
1641:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2098              		.loc 1 1641 0
 2099 0002 0346     		mov	r3, r0
 2100 0004 08B9     		cbnz	r0, .L183
1643:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2101              		.loc 1 1643 0
 2102 0006 044B     		ldr	r3, .L187
 2103 0008 5B6B     		ldr	r3, [r3, #52]
 2104              	.LVL130:
 2105              	.L183:
1650:../FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
 2106              		.loc 1 1650 0
 2107 000a 9B6C     		ldr	r3, [r3, #72]
 2108              	.LVL131:
 2109 000c 13B1     		cbz	r3, .L186
1652:../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
 2110              		.loc 1 1652 0
 2111 000e 0846     		mov	r0, r1
 2112              	.LVL132:
 2113 0010 9847     		blx	r3
 2114              	.LVL133:
 2115 0012 08BD     		pop	{r3, pc}
 2116              	.LVL134:
 2117              	.L186:
1656:../FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
 2118              		.loc 1 1656 0
 2119 0014 1846     		mov	r0, r3
 2120              	.LVL135:
1660:../FreeRTOS/Source/tasks.c **** 	}
 2121              		.loc 1 1660 0
 2122 0016 08BD     		pop	{r3, pc}
 2123              	.L188:
 2124              		.align	2
 2125              	.L187:
 2126 0018 00000000 		.word	.LANCHOR0
 2127              		.cfi_endproc
 2128              	.LFE132:
 2130              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2131              		.align	1
 2132              		.global	vTaskSwitchContext
 2133              		.thumb
 2134              		.thumb_func
 2136              	vTaskSwitchContext:
 2137              	.LFB133:
1666:../FreeRTOS/Source/tasks.c **** {
 2138              		.loc 1 1666 0
 2139              		.cfi_startproc
 2140              		@ args = 0, pretend = 0, frame = 0
 2141              		@ frame_needed = 0, uses_anonymous_args = 0
 2142 0000 38B5     		push	{r3, r4, r5, lr}
 2143              	.LCFI21:
 2144              		.cfi_def_cfa_offset 16
 2145              		.cfi_offset 14, -4
 2146              		.cfi_offset 5, -8
 2147              		.cfi_offset 4, -12
 2148              		.cfi_offset 3, -16
1667:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2149              		.loc 1 1667 0
 2150 0002 1E4C     		ldr	r4, .L195
 2151 0004 D4F82431 		ldr	r3, [r4, #292]
 2152 0008 1BB1     		cbz	r3, .L190
1671:../FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2153              		.loc 1 1671 0
 2154 000a 0123     		movs	r3, #1
 2155 000c C4F83431 		str	r3, [r4, #308]
 2156 0010 38BD     		pop	{r3, r4, r5, pc}
 2157              	.L190:
 2158              	.LBB61:
1684:../FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 2159              		.loc 1 1684 0
 2160 0012 FFF7FEFF 		bl	get_us_time
 2161              	.LVL136:
1692:../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 2162              		.loc 1 1692 0
 2163 0016 636B     		ldr	r3, [r4, #52]
 2164 0018 D4F83821 		ldr	r2, [r4, #312]
 2165 001c D96C     		ldr	r1, [r3, #76]
1693:../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
 2166              		.loc 1 1693 0
 2167 001e C4F83801 		str	r0, [r4, #312]
1692:../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 2168              		.loc 1 1692 0
 2169 0022 8A1A     		subs	r2, r1, r2
 2170 0024 1218     		adds	r2, r2, r0
 2171 0026 DA64     		str	r2, [r3, #76]
 2172              	.LBE61:
1701:../FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2173              		.loc 1 1701 0
 2174 0028 04F14800 		add	r0, r4, #72
 2175              	.LVL137:
 2176 002c 1423     		movs	r3, #20
 2177 002e 04E0     		b	.L192
 2178              	.L193:
1704:../FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;
 2179              		.loc 1 1704 0
 2180 0030 D4F81C21 		ldr	r2, [r4, #284]
 2181 0034 013A     		subs	r2, r2, #1
 2182 0036 C4F81C21 		str	r2, [r4, #284]
 2183              	.L192:
1701:../FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2184              		.loc 1 1701 0 discriminator 1
 2185 003a D4F81C51 		ldr	r5, [r4, #284]
 2186 003e 0F4A     		ldr	r2, .L195
 2187 0040 5D43     		muls	r5, r3, r5
 2188 0042 02F14801 		add	r1, r2, #72
 2189 0046 4559     		ldr	r5, [r0, r5]
 2190 0048 002D     		cmp	r5, #0
 2191 004a F1D0     		beq	.L193
 2192              	.LBB62:
1709:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2193              		.loc 1 1709 0
 2194 004c D2F81C31 		ldr	r3, [r2, #284]
 2195 0050 1422     		movs	r2, #20
 2196 0052 02FB0313 		mla	r3, r2, r3, r1
 2197              	.LVL138:
 2198 0056 03F10801 		add	r1, r3, #8
 2199 005a 5A68     		ldr	r2, [r3, #4]
 2200 005c 5268     		ldr	r2, [r2, #4]
 2201 005e 5A60     		str	r2, [r3, #4]
 2202 0060 8A42     		cmp	r2, r1
 2203 0062 04BF     		itt	eq
 2204 0064 5268     		ldreq	r2, [r2, #4]
 2205 0066 5A60     		streq	r2, [r3, #4]
 2206 0068 5B68     		ldr	r3, [r3, #4]
 2207              	.LVL139:
 2208 006a DA68     		ldr	r2, [r3, #12]
 2209 006c 034B     		ldr	r3, .L195
 2210 006e 5A63     		str	r2, [r3, #52]
 2211              	.LBE62:
1711:../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2212              		.loc 1 1711 0
 2213 0070 5B6B     		ldr	r3, [r3, #52]
 2214 0072 9A6C     		ldr	r2, [r3, #72]
 2215 0074 024B     		ldr	r3, .L195+4
 2216 0076 DA60     		str	r2, [r3, #12]
 2217 0078 38BD     		pop	{r3, r4, r5, pc}
 2218              	.L196:
 2219 007a 00BF     		.align	2
 2220              	.L195:
 2221 007c 00000000 		.word	.LANCHOR0
 2222 0080 00740040 		.word	1073771520
 2223              		.cfi_endproc
 2224              	.LFE133:
 2226              		.section	.text.vTaskSuspend,"ax",%progbits
 2227              		.align	1
 2228              		.global	vTaskSuspend
 2229              		.thumb
 2230              		.thumb_func
 2232              	vTaskSuspend:
 2233              	.LFB116:
 905:../FreeRTOS/Source/tasks.c **** 	{
 2234              		.loc 1 905 0
 2235              		.cfi_startproc
 2236              		@ args = 0, pretend = 0, frame = 0
 2237              		@ frame_needed = 0, uses_anonymous_args = 0
 2238              	.LVL140:
 2239 0000 70B5     		push	{r4, r5, r6, lr}
 2240              	.LCFI22:
 2241              		.cfi_def_cfa_offset 16
 2242              		.cfi_offset 14, -4
 2243              		.cfi_offset 6, -8
 2244              		.cfi_offset 5, -12
 2245              		.cfi_offset 4, -16
 905:../FreeRTOS/Source/tasks.c **** 	{
 2246              		.loc 1 905 0
 2247 0002 0446     		mov	r4, r0
 908:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2248              		.loc 1 908 0
 2249 0004 FFF7FEFF 		bl	vPortEnterCritical
 2250              	.LVL141:
 912:../FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 2251              		.loc 1 912 0
 2252 0008 174B     		ldr	r3, .L205
 2253 000a 5A6B     		ldr	r2, [r3, #52]
 2254 000c 9442     		cmp	r4, r2
 2255 000e 01D0     		beq	.L198
 918:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 2256              		.loc 1 918 0
 2257 0010 2546     		mov	r5, r4
 2258 0012 0CB9     		cbnz	r4, .L199
 2259              	.L198:
 918:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 2260              		.loc 1 918 0 is_stmt 0 discriminator 1
 2261 0014 5D6B     		ldr	r5, [r3, #52]
 2262 0016 0024     		movs	r4, #0
 2263              	.LVL142:
 2264              	.L199:
 923:../FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 2265              		.loc 1 923 0 is_stmt 1 discriminator 3
 2266 0018 2E1D     		adds	r6, r5, #4
 2267 001a 3046     		mov	r0, r6
 2268 001c FFF7FEFF 		bl	vListRemove
 926:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 2269              		.loc 1 926 0 discriminator 3
 2270 0020 AB6A     		ldr	r3, [r5, #40]
 2271 0022 1BB1     		cbz	r3, .L200
 928:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 2272              		.loc 1 928 0
 2273 0024 05F11800 		add	r0, r5, #24
 2274 0028 FFF7FEFF 		bl	vListRemove
 2275              	.L200:
 931:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 2276              		.loc 1 931 0
 2277 002c 0E4D     		ldr	r5, .L205
 2278              	.LVL143:
 2279 002e 3146     		mov	r1, r6
 2280 0030 05F1FC00 		add	r0, r5, #252
 2281 0034 FFF7FEFF 		bl	vListInsertEnd
 933:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2282              		.loc 1 933 0
 2283 0038 FFF7FEFF 		bl	vPortExitCritical
 935:../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 2284              		.loc 1 935 0
 2285 003c 002C     		cmp	r4, #0
 2286 003e 11D1     		bne	.L197
 937:../FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 2287              		.loc 1 937 0
 2288 0040 D5F81031 		ldr	r3, [r5, #272]
 2289 0044 1BB1     		cbz	r3, .L202
 961:../FreeRTOS/Source/tasks.c **** 	}
 2290              		.loc 1 961 0
 2291 0046 BDE87040 		pop	{r4, r5, r6, lr}
 940:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 2292              		.loc 1 940 0
 2293 004a FFF7FEBF 		b	vPortYieldFromISR
 2294              	.L202:
 947:../FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 2295              		.loc 1 947 0
 2296 004e D5F8FC20 		ldr	r2, [r5, #252]
 2297 0052 6B6C     		ldr	r3, [r5, #68]
 2298 0054 9A42     		cmp	r2, r3
 2299 0056 01D1     		bne	.L203
 953:../FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 2300              		.loc 1 953 0
 2301 0058 6C63     		str	r4, [r5, #52]
 2302 005a 70BD     		pop	{r4, r5, r6, pc}
 2303              	.L203:
 961:../FreeRTOS/Source/tasks.c **** 	}
 2304              		.loc 1 961 0
 2305 005c BDE87040 		pop	{r4, r5, r6, lr}
 957:../FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 2306              		.loc 1 957 0
 2307 0060 FFF7FEBF 		b	vTaskSwitchContext
 2308              	.L197:
 2309 0064 70BD     		pop	{r4, r5, r6, pc}
 2310              	.L206:
 2311 0066 00BF     		.align	2
 2312              	.L205:
 2313 0068 00000000 		.word	.LANCHOR0
 2314              		.cfi_endproc
 2315              	.LFE116:
 2317              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2318              		.align	1
 2319              		.global	vTaskPlaceOnEventList
 2320              		.thumb
 2321              		.thumb_func
 2323              	vTaskPlaceOnEventList:
 2324              	.LFB134:
1718:../FreeRTOS/Source/tasks.c **** {
 2325              		.loc 1 1718 0
 2326              		.cfi_startproc
 2327              		@ args = 0, pretend = 0, frame = 0
 2328              		@ frame_needed = 0, uses_anonymous_args = 0
 2329              	.LVL144:
 2330 0000 38B5     		push	{r3, r4, r5, lr}
 2331              	.LCFI23:
 2332              		.cfi_def_cfa_offset 16
 2333              		.cfi_offset 14, -4
 2334              		.cfi_offset 5, -8
 2335              		.cfi_offset 4, -12
 2336              		.cfi_offset 3, -16
1729:../FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2337              		.loc 1 1729 0
 2338 0002 0D4C     		ldr	r4, .L209
1718:../FreeRTOS/Source/tasks.c **** {
 2339              		.loc 1 1718 0
 2340 0004 0D46     		mov	r5, r1
1729:../FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2341              		.loc 1 1729 0
 2342 0006 616B     		ldr	r1, [r4, #52]
 2343              	.LVL145:
 2344 0008 1831     		adds	r1, r1, #24
 2345 000a FFF7FEFF 		bl	vListInsert
 2346              	.LVL146:
1734:../FreeRTOS/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2347              		.loc 1 1734 0
 2348 000e 606B     		ldr	r0, [r4, #52]
 2349 0010 0430     		adds	r0, r0, #4
 2350 0012 FFF7FEFF 		bl	vListRemove
1739:../FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2351              		.loc 1 1739 0
 2352 0016 6B1C     		adds	r3, r5, #1
 2353 0018 07D1     		bne	.L208
1744:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2354              		.loc 1 1744 0
 2355 001a 616B     		ldr	r1, [r4, #52]
 2356 001c 04F1FC00 		add	r0, r4, #252
 2357 0020 0431     		adds	r1, r1, #4
1762:../FreeRTOS/Source/tasks.c **** }
 2358              		.loc 1 1762 0
 2359 0022 BDE83840 		pop	{r3, r4, r5, lr}
1744:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2360              		.loc 1 1744 0
 2361 0026 FFF7FEBF 		b	vListInsertEnd
 2362              	.L208:
1750:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2363              		.loc 1 1750 0
 2364 002a A06B     		ldr	r0, [r4, #56]
 2365              	.LVL147:
 2366 002c 2818     		adds	r0, r5, r0
 2367              	.LVL148:
1762:../FreeRTOS/Source/tasks.c **** }
 2368              		.loc 1 1762 0
 2369 002e BDE83840 		pop	{r3, r4, r5, lr}
1751:../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2370              		.loc 1 1751 0
 2371 0032 FFF7FEBF 		b	prvAddCurrentTaskToDelayedList
 2372              	.LVL149:
 2373              	.L210:
 2374 0036 00BF     		.align	2
 2375              	.L209:
 2376 0038 00000000 		.word	.LANCHOR0
 2377              		.cfi_endproc
 2378              	.LFE134:
 2380              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2381              		.align	1
 2382              		.global	xTaskRemoveFromEventList
 2383              		.thumb
 2384              		.thumb_func
 2386              	xTaskRemoveFromEventList:
 2387              	.LFB135:
1800:../FreeRTOS/Source/tasks.c **** {
 2388              		.loc 1 1800 0
 2389              		.cfi_startproc
 2390              		@ args = 0, pretend = 0, frame = 0
 2391              		@ frame_needed = 0, uses_anonymous_args = 0
 2392              	.LVL150:
 2393 0000 70B5     		push	{r4, r5, r6, lr}
 2394              	.LCFI24:
 2395              		.cfi_def_cfa_offset 16
 2396              		.cfi_offset 14, -4
 2397              		.cfi_offset 6, -8
 2398              		.cfi_offset 5, -12
 2399              		.cfi_offset 4, -16
1817:../FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2400              		.loc 1 1817 0
 2401 0002 C368     		ldr	r3, [r0, #12]
1821:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2402              		.loc 1 1821 0
 2403 0004 134D     		ldr	r5, .L216
1817:../FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2404              		.loc 1 1817 0
 2405 0006 DC68     		ldr	r4, [r3, #12]
 2406              	.LVL151:
1819:../FreeRTOS/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2407              		.loc 1 1819 0
 2408 0008 04F11806 		add	r6, r4, #24
 2409 000c 3046     		mov	r0, r6
 2410              	.LVL152:
 2411 000e FFF7FEFF 		bl	vListRemove
1821:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2412              		.loc 1 1821 0
 2413 0012 D5F82431 		ldr	r3, [r5, #292]
1830:../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2414              		.loc 1 1830 0
 2415 0016 05F1D400 		add	r0, r5, #212
1821:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2416              		.loc 1 1821 0
 2417 001a 73B9     		cbnz	r3, .L215
1823:../FreeRTOS/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2418              		.loc 1 1823 0
 2419 001c 261D     		adds	r6, r4, #4
 2420 001e 3046     		mov	r0, r6
 2421 0020 FFF7FEFF 		bl	vListRemove
1824:../FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2422              		.loc 1 1824 0
 2423 0024 E36A     		ldr	r3, [r4, #44]
 2424 0026 D5F81C21 		ldr	r2, [r5, #284]
 2425 002a 9342     		cmp	r3, r2
 2426 002c 0A4A     		ldr	r2, .L216+4
 2427 002e 88BF     		it	hi
 2428 0030 C5F81C31 		strhi	r3, [r5, #284]
 2429 0034 1420     		movs	r0, #20
 2430 0036 00FB0320 		mla	r0, r0, r3, r2
 2431              	.L215:
1830:../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2432              		.loc 1 1830 0
 2433 003a 3146     		mov	r1, r6
 2434 003c FFF7FEFF 		bl	vListInsertEnd
1833:../FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2435              		.loc 1 1833 0
 2436 0040 044B     		ldr	r3, .L216
1839:../FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2437              		.loc 1 1839 0
 2438 0042 E06A     		ldr	r0, [r4, #44]
1833:../FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2439              		.loc 1 1833 0
 2440 0044 5B6B     		ldr	r3, [r3, #52]
 2441              	.LVL153:
1839:../FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2442              		.loc 1 1839 0
 2443 0046 DB6A     		ldr	r3, [r3, #44]
 2444              	.LVL154:
 2445 0048 9842     		cmp	r0, r3
 2446 004a 34BF     		ite	cc
 2447 004c 0020     		movcc	r0, #0
 2448 004e 0120     		movcs	r0, #1
1847:../FreeRTOS/Source/tasks.c **** }
 2449              		.loc 1 1847 0
 2450 0050 70BD     		pop	{r4, r5, r6, pc}
 2451              	.L217:
 2452 0052 00BF     		.align	2
 2453              	.L216:
 2454 0054 00000000 		.word	.LANCHOR0
 2455 0058 48000000 		.word	.LANCHOR0+72
 2456              		.cfi_endproc
 2457              	.LFE135:
 2459              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2460              		.align	1
 2461              		.global	vTaskSetTimeOutState
 2462              		.thumb
 2463              		.thumb_func
 2465              	vTaskSetTimeOutState:
 2466              	.LFB136:
1851:../FreeRTOS/Source/tasks.c **** {
 2467              		.loc 1 1851 0
 2468              		.cfi_startproc
 2469              		@ args = 0, pretend = 0, frame = 0
 2470              		@ frame_needed = 0, uses_anonymous_args = 0
 2471              		@ link register save eliminated.
 2472              	.LVL155:
1853:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2473              		.loc 1 1853 0
 2474 0000 034B     		ldr	r3, .L219
 2475 0002 D3F82C21 		ldr	r2, [r3, #300]
1854:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2476              		.loc 1 1854 0
 2477 0006 9B6B     		ldr	r3, [r3, #56]
1853:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2478              		.loc 1 1853 0
 2479 0008 0260     		str	r2, [r0, #0]
1854:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2480              		.loc 1 1854 0
 2481 000a 4360     		str	r3, [r0, #4]
1855:../FreeRTOS/Source/tasks.c **** }
 2482              		.loc 1 1855 0
 2483 000c 7047     		bx	lr
 2484              	.L220:
 2485 000e 00BF     		.align	2
 2486              	.L219:
 2487 0010 00000000 		.word	.LANCHOR0
 2488              		.cfi_endproc
 2489              	.LFE136:
 2491              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2492              		.align	1
 2493              		.global	xTaskCheckForTimeOut
 2494              		.thumb
 2495              		.thumb_func
 2497              	xTaskCheckForTimeOut:
 2498              	.LFB137:
1859:../FreeRTOS/Source/tasks.c **** {
 2499              		.loc 1 1859 0
 2500              		.cfi_startproc
 2501              		@ args = 0, pretend = 0, frame = 0
 2502              		@ frame_needed = 0, uses_anonymous_args = 0
 2503              	.LVL156:
 2504 0000 38B5     		push	{r3, r4, r5, lr}
 2505              	.LCFI25:
 2506              		.cfi_def_cfa_offset 16
 2507              		.cfi_offset 14, -4
 2508              		.cfi_offset 5, -8
 2509              		.cfi_offset 4, -12
 2510              		.cfi_offset 3, -16
1859:../FreeRTOS/Source/tasks.c **** {
 2511              		.loc 1 1859 0
 2512 0002 0D46     		mov	r5, r1
 2513 0004 0446     		mov	r4, r0
1865:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 2514              		.loc 1 1865 0
 2515 0006 FFF7FEFF 		bl	vPortEnterCritical
 2516              	.LVL157:
1871:../FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2517              		.loc 1 1871 0
 2518 000a 2B68     		ldr	r3, [r5, #0]
 2519 000c 5A1C     		adds	r2, r3, #1
 2520 000e 17D0     		beq	.L224
1878:../FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2521              		.loc 1 1878 0
 2522 0010 0F4A     		ldr	r2, .L227
 2523 0012 2168     		ldr	r1, [r4, #0]
 2524 0014 D2F82C01 		ldr	r0, [r2, #300]
 2525 0018 8842     		cmp	r0, r1
 2526 001a 1146     		mov	r1, r2
 2527 001c 03D0     		beq	.L223
1878:../FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2528              		.loc 1 1878 0 is_stmt 0 discriminator 1
 2529 001e 906B     		ldr	r0, [r2, #56]
 2530 0020 6268     		ldr	r2, [r4, #4]
 2531 0022 9042     		cmp	r0, r2
 2532 0024 0ED2     		bcs	.L226
 2533              	.L223:
1886:../FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2534              		.loc 1 1886 0 is_stmt 1
 2535 0026 896B     		ldr	r1, [r1, #56]
 2536 0028 6268     		ldr	r2, [r4, #4]
 2537 002a 891A     		subs	r1, r1, r2
 2538 002c 9942     		cmp	r1, r3
 2539 002e 09D2     		bcs	.L226
1889:../FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2540              		.loc 1 1889 0
 2541 0030 0749     		ldr	r1, .L227
 2542 0032 896B     		ldr	r1, [r1, #56]
 2543 0034 521A     		subs	r2, r2, r1
 2544 0036 D318     		adds	r3, r2, r3
 2545 0038 2B60     		str	r3, [r5, #0]
1890:../FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2546              		.loc 1 1890 0
 2547 003a 2046     		mov	r0, r4
 2548 003c FFF7FEFF 		bl	vTaskSetTimeOutState
 2549              	.LVL158:
 2550              	.L224:
1873:../FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 2551              		.loc 1 1873 0
 2552 0040 0024     		movs	r4, #0
 2553              	.LVL159:
 2554 0042 00E0     		b	.L222
 2555              	.LVL160:
 2556              	.L226:
1895:../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2557              		.loc 1 1895 0
 2558 0044 0124     		movs	r4, #1
 2559              	.LVL161:
 2560              	.L222:
1898:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2561              		.loc 1 1898 0
 2562 0046 FFF7FEFF 		bl	vPortExitCritical
1901:../FreeRTOS/Source/tasks.c **** }
 2563              		.loc 1 1901 0
 2564 004a 2046     		mov	r0, r4
 2565 004c 38BD     		pop	{r3, r4, r5, pc}
 2566              	.L228:
 2567 004e 00BF     		.align	2
 2568              	.L227:
 2569 0050 00000000 		.word	.LANCHOR0
 2570              		.cfi_endproc
 2571              	.LFE137:
 2573              		.section	.text.vTaskMissedYield,"ax",%progbits
 2574              		.align	1
 2575              		.global	vTaskMissedYield
 2576              		.thumb
 2577              		.thumb_func
 2579              	vTaskMissedYield:
 2580              	.LFB138:
1905:../FreeRTOS/Source/tasks.c **** {
 2581              		.loc 1 1905 0
 2582              		.cfi_startproc
 2583              		@ args = 0, pretend = 0, frame = 0
 2584              		@ frame_needed = 0, uses_anonymous_args = 0
 2585              		@ link register save eliminated.
1906:../FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2586              		.loc 1 1906 0
 2587 0000 024B     		ldr	r3, .L230
 2588 0002 0122     		movs	r2, #1
 2589 0004 C3F83421 		str	r2, [r3, #308]
1907:../FreeRTOS/Source/tasks.c **** }
 2590              		.loc 1 1907 0
 2591 0008 7047     		bx	lr
 2592              	.L231:
 2593 000a 00BF     		.align	2
 2594              	.L230:
 2595 000c 00000000 		.word	.LANCHOR0
 2596              		.cfi_endproc
 2597              	.LFE138:
 2599              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 2600              		.align	1
 2601              		.global	uxTaskGetStackHighWaterMark
 2602              		.thumb
 2603              		.thumb_func
 2605              	uxTaskGetStackHighWaterMark:
 2606              	.LFB147:
2321:../FreeRTOS/Source/tasks.c **** 	{
 2607              		.loc 1 2321 0
 2608              		.cfi_startproc
 2609              		@ args = 0, pretend = 0, frame = 0
 2610              		@ frame_needed = 0, uses_anonymous_args = 0
 2611              	.LVL162:
 2612 0000 08B5     		push	{r3, lr}
 2613              	.LCFI26:
 2614              		.cfi_def_cfa_offset 8
 2615              		.cfi_offset 14, -4
 2616              		.cfi_offset 3, -8
2326:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 2617              		.loc 1 2326 0
 2618 0002 08B9     		cbnz	r0, .L233
2326:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 2619              		.loc 1 2326 0 is_stmt 0 discriminator 1
 2620 0004 024B     		ldr	r3, .L235
 2621 0006 586B     		ldr	r0, [r3, #52]
 2622              	.LVL163:
 2623              	.L233:
2338:../FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 2624              		.loc 1 2338 0 is_stmt 1 discriminator 3
 2625 0008 006B     		ldr	r0, [r0, #48]
 2626              	.LVL164:
 2627 000a FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 2628              	.LVL165:
2341:../FreeRTOS/Source/tasks.c **** 	}
 2629              		.loc 1 2341 0 discriminator 3
 2630 000e 08BD     		pop	{r3, pc}
 2631              	.L236:
 2632              		.align	2
 2633              	.L235:
 2634 0010 00000000 		.word	.LANCHOR0
 2635              		.cfi_endproc
 2636              	.LFE147:
 2638              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 2639              		.align	1
 2640              		.global	xTaskGetCurrentTaskHandle
 2641              		.thumb
 2642              		.thumb_func
 2644              	xTaskGetCurrentTaskHandle:
 2645              	.LFB149:
2354:../FreeRTOS/Source/tasks.c **** 	}
2355:../FreeRTOS/Source/tasks.c **** 
2356:../FreeRTOS/Source/tasks.c **** #endif
2357:../FreeRTOS/Source/tasks.c **** 
2358:../FreeRTOS/Source/tasks.c **** 
2359:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2360:../FreeRTOS/Source/tasks.c **** 
2361:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2362:../FreeRTOS/Source/tasks.c **** 
2363:../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2364:../FreeRTOS/Source/tasks.c **** 	{
 2646              		.loc 1 2364 0
 2647              		.cfi_startproc
 2648              		@ args = 0, pretend = 0, frame = 0
 2649              		@ frame_needed = 0, uses_anonymous_args = 0
 2650              		@ link register save eliminated.
2365:../FreeRTOS/Source/tasks.c **** 	xTaskHandle xReturn;
2366:../FreeRTOS/Source/tasks.c **** 
2367:../FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
2368:../FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2369:../FreeRTOS/Source/tasks.c **** 		individual execution thread. */
2370:../FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 2651              		.loc 1 2370 0
 2652 0000 014B     		ldr	r3, .L238
 2653 0002 586B     		ldr	r0, [r3, #52]
 2654              	.LVL166:
2371:../FreeRTOS/Source/tasks.c **** 
2372:../FreeRTOS/Source/tasks.c **** 		return xReturn;
2373:../FreeRTOS/Source/tasks.c **** 	}
 2655              		.loc 1 2373 0
 2656 0004 7047     		bx	lr
 2657              	.L239:
 2658 0006 00BF     		.align	2
 2659              	.L238:
 2660 0008 00000000 		.word	.LANCHOR0
 2661              		.cfi_endproc
 2662              	.LFE149:
 2664              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 2665              		.align	1
 2666              		.global	vTaskPriorityInherit
 2667              		.thumb
 2668              		.thumb_func
 2670              	vTaskPriorityInherit:
 2671              	.LFB150:
2374:../FreeRTOS/Source/tasks.c **** 
2375:../FreeRTOS/Source/tasks.c **** #endif
2376:../FreeRTOS/Source/tasks.c **** 
2377:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2378:../FreeRTOS/Source/tasks.c **** 
2379:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2380:../FreeRTOS/Source/tasks.c **** 
2381:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2382:../FreeRTOS/Source/tasks.c **** 	{
2383:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
2384:../FreeRTOS/Source/tasks.c **** 
2385:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2386:../FreeRTOS/Source/tasks.c **** 		{
2387:../FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2388:../FreeRTOS/Source/tasks.c **** 		}
2389:../FreeRTOS/Source/tasks.c **** 		else
2390:../FreeRTOS/Source/tasks.c **** 		{
2391:../FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2392:../FreeRTOS/Source/tasks.c **** 			{
2393:../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2394:../FreeRTOS/Source/tasks.c **** 			}
2395:../FreeRTOS/Source/tasks.c **** 			else
2396:../FreeRTOS/Source/tasks.c **** 			{
2397:../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2398:../FreeRTOS/Source/tasks.c **** 			}
2399:../FreeRTOS/Source/tasks.c **** 		}
2400:../FreeRTOS/Source/tasks.c **** 
2401:../FreeRTOS/Source/tasks.c **** 		return xReturn;
2402:../FreeRTOS/Source/tasks.c **** 	}
2403:../FreeRTOS/Source/tasks.c **** 
2404:../FreeRTOS/Source/tasks.c **** #endif
2405:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2406:../FreeRTOS/Source/tasks.c **** 
2407:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2408:../FreeRTOS/Source/tasks.c **** 
2409:../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2410:../FreeRTOS/Source/tasks.c **** 	{
 2672              		.loc 1 2410 0
 2673              		.cfi_startproc
 2674              		@ args = 0, pretend = 0, frame = 0
 2675              		@ frame_needed = 0, uses_anonymous_args = 0
 2676              	.LVL167:
 2677 0000 70B5     		push	{r4, r5, r6, lr}
 2678              	.LCFI27:
 2679              		.cfi_def_cfa_offset 16
 2680              		.cfi_offset 14, -4
 2681              		.cfi_offset 6, -8
 2682              		.cfi_offset 5, -12
 2683              		.cfi_offset 4, -16
2411:../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
2412:../FreeRTOS/Source/tasks.c **** 
2413:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxMutexHolder );
2414:../FreeRTOS/Source/tasks.c **** 
2415:../FreeRTOS/Source/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 2684              		.loc 1 2415 0
 2685 0002 174C     		ldr	r4, .L244
 2686 0004 C36A     		ldr	r3, [r0, #44]
 2687 0006 626B     		ldr	r2, [r4, #52]
 2688 0008 D26A     		ldr	r2, [r2, #44]
 2689 000a 9342     		cmp	r3, r2
2410:../FreeRTOS/Source/tasks.c **** 	{
 2690              		.loc 1 2410 0
 2691 000c 0546     		mov	r5, r0
 2692              		.loc 1 2415 0
 2693 000e 26D2     		bcs	.L240
 2694              	.LVL168:
2416:../FreeRTOS/Source/tasks.c **** 		{
2417:../FreeRTOS/Source/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2418:../FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 2695              		.loc 1 2418 0
 2696 0010 626B     		ldr	r2, [r4, #52]
 2697 0012 D26A     		ldr	r2, [r2, #44]
 2698 0014 C2F10502 		rsb	r2, r2, #5
2419:../FreeRTOS/Source/tasks.c **** 
2420:../FreeRTOS/Source/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2421:../FreeRTOS/Source/tasks.c **** 			be moved in to a new list. */
2422:../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 2699              		.loc 1 2422 0
 2700 0018 1421     		movs	r1, #20
2418:../FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 2701              		.loc 1 2418 0
 2702 001a 8261     		str	r2, [r0, #24]
 2703              		.loc 1 2422 0
 2704 001c 04F14802 		add	r2, r4, #72
 2705 0020 01FB0323 		mla	r3, r1, r3, r2
 2706 0024 4269     		ldr	r2, [r0, #20]
 2707 0026 9A42     		cmp	r2, r3
2423:../FreeRTOS/Source/tasks.c **** 			{
2424:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
2425:../FreeRTOS/Source/tasks.c **** 
2426:../FreeRTOS/Source/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2427:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
2428:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
2429:../FreeRTOS/Source/tasks.c **** 			}
2430:../FreeRTOS/Source/tasks.c **** 			else
2431:../FreeRTOS/Source/tasks.c **** 			{
2432:../FreeRTOS/Source/tasks.c **** 				/* Just inherit the priority. */
2433:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2708              		.loc 1 2433 0
 2709 0028 1EBF     		ittt	ne
 2710 002a 636B     		ldrne	r3, [r4, #52]
 2711 002c DB6A     		ldrne	r3, [r3, #44]
 2712 002e C362     		strne	r3, [r0, #44]
2422:../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 2713              		.loc 1 2422 0
 2714 0030 15D1     		bne	.L240
2424:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 2715              		.loc 1 2424 0
 2716 0032 061D     		adds	r6, r0, #4
 2717              	.LVL169:
 2718 0034 3046     		mov	r0, r6
 2719              	.LVL170:
 2720 0036 FFF7FEFF 		bl	vListRemove
2427:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2721              		.loc 1 2427 0
 2722 003a 636B     		ldr	r3, [r4, #52]
2428:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 2723              		.loc 1 2428 0
 2724 003c D4F81C21 		ldr	r2, [r4, #284]
2427:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2725              		.loc 1 2427 0
 2726 0040 DB6A     		ldr	r3, [r3, #44]
2428:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 2727              		.loc 1 2428 0
 2728 0042 9342     		cmp	r3, r2
 2729 0044 074A     		ldr	r2, .L244+4
 2730 0046 88BF     		it	hi
 2731 0048 C4F81C31 		strhi	r3, [r4, #284]
 2732 004c 1420     		movs	r0, #20
 2733 004e 00FB0320 		mla	r0, r0, r3, r2
 2734 0052 3146     		mov	r1, r6
2427:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2735              		.loc 1 2427 0
 2736 0054 EB62     		str	r3, [r5, #44]
2434:../FreeRTOS/Source/tasks.c **** 			}
2435:../FreeRTOS/Source/tasks.c **** 		}
2436:../FreeRTOS/Source/tasks.c **** 	}
 2737              		.loc 1 2436 0
 2738 0056 BDE87040 		pop	{r4, r5, r6, lr}
2428:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 2739              		.loc 1 2428 0
 2740 005a FFF7FEBF 		b	vListInsertEnd
 2741              	.L240:
 2742 005e 70BD     		pop	{r4, r5, r6, pc}
 2743              	.L245:
 2744              		.align	2
 2745              	.L244:
 2746 0060 00000000 		.word	.LANCHOR0
 2747 0064 48000000 		.word	.LANCHOR0+72
 2748              		.cfi_endproc
 2749              	.LFE150:
 2751              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 2752              		.align	1
 2753              		.global	vTaskPriorityDisinherit
 2754              		.thumb
 2755              		.thumb_func
 2757              	vTaskPriorityDisinherit:
 2758              	.LFB151:
2437:../FreeRTOS/Source/tasks.c **** 
2438:../FreeRTOS/Source/tasks.c **** #endif
2439:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2440:../FreeRTOS/Source/tasks.c **** 
2441:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2442:../FreeRTOS/Source/tasks.c **** 
2443:../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2444:../FreeRTOS/Source/tasks.c **** 	{
 2759              		.loc 1 2444 0
 2760              		.cfi_startproc
 2761              		@ args = 0, pretend = 0, frame = 0
 2762              		@ frame_needed = 0, uses_anonymous_args = 0
 2763              	.LVL171:
 2764 0000 38B5     		push	{r3, r4, r5, lr}
 2765              	.LCFI28:
 2766              		.cfi_def_cfa_offset 16
 2767              		.cfi_offset 14, -4
 2768              		.cfi_offset 5, -8
 2769              		.cfi_offset 4, -12
 2770              		.cfi_offset 3, -16
 2771              		.loc 1 2444 0
 2772 0002 0446     		mov	r4, r0
2445:../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
2446:../FreeRTOS/Source/tasks.c **** 
2447:../FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 2773              		.loc 1 2447 0
 2774 0004 E0B1     		cbz	r0, .L246
2448:../FreeRTOS/Source/tasks.c **** 		{
2449:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 2775              		.loc 1 2449 0
 2776 0006 C26A     		ldr	r2, [r0, #44]
 2777 0008 436C     		ldr	r3, [r0, #68]
 2778 000a 9A42     		cmp	r2, r3
 2779 000c 18D0     		beq	.L246
2450:../FreeRTOS/Source/tasks.c **** 			{
2451:../FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2452:../FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2453:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 2780              		.loc 1 2453 0
 2781 000e 051D     		adds	r5, r0, #4
 2782 0010 2846     		mov	r0, r5
 2783              	.LVL172:
 2784 0012 FFF7FEFF 		bl	vListRemove
2454:../FreeRTOS/Source/tasks.c **** 
2455:../FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding ourselves into the new
2456:../FreeRTOS/Source/tasks.c **** 				ready list. */
2457:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 2785              		.loc 1 2457 0
 2786 0016 636C     		ldr	r3, [r4, #68]
2458:../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 2787              		.loc 1 2458 0
 2788 0018 C3F10502 		rsb	r2, r3, #5
 2789 001c A261     		str	r2, [r4, #24]
2459:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 2790              		.loc 1 2459 0
 2791 001e 094A     		ldr	r2, .L249
2457:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 2792              		.loc 1 2457 0
 2793 0020 E362     		str	r3, [r4, #44]
 2794              		.loc 1 2459 0
 2795 0022 D2F81C11 		ldr	r1, [r2, #284]
 2796 0026 8B42     		cmp	r3, r1
 2797 0028 88BF     		it	hi
 2798 002a C2F81C31 		strhi	r3, [r2, #284]
 2799 002e 064A     		ldr	r2, .L249+4
 2800 0030 1420     		movs	r0, #20
 2801 0032 00FB0320 		mla	r0, r0, r3, r2
 2802 0036 2946     		mov	r1, r5
2460:../FreeRTOS/Source/tasks.c **** 			}
2461:../FreeRTOS/Source/tasks.c **** 		}
2462:../FreeRTOS/Source/tasks.c **** 	}
 2803              		.loc 1 2462 0
 2804 0038 BDE83840 		pop	{r3, r4, r5, lr}
2459:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 2805              		.loc 1 2459 0
 2806 003c FFF7FEBF 		b	vListInsertEnd
 2807              	.L246:
 2808 0040 38BD     		pop	{r3, r4, r5, pc}
 2809              	.L250:
 2810 0042 00BF     		.align	2
 2811              	.L249:
 2812 0044 00000000 		.word	.LANCHOR0
 2813 0048 48000000 		.word	.LANCHOR0+72
 2814              		.cfi_endproc
 2815              	.LFE151:
 2817              		.global	pxCurrentTCB
 2818              		.section	.rodata.str1.1,"aMS",%progbits,1
 2819              	.LC0:
 2820 0000 25752020 		.ascii	"%u  %c  %-16s          0   0%%  %5u\015\012\000"
 2820      25632020 
 2820      252D3136 
 2820      73202020 
 2820      20202020 
 2821              	.LC1:
 2822 0026 25752020 		.ascii	"%u  %c  %-16s %10u %3u%%  %5u\015\012\000"
 2822      25632020 
 2822      252D3136 
 2822      73202531 
 2822      30752025 
 2823              	.LC2:
 2824 0046 25752020 		.ascii	"%u  %c  %-16s %10u  <1%%  %5u\015\012\000"
 2824      25632020 
 2824      252D3136 
 2824      73202531 
 2824      30752020 
 2825              	.LC3:
 2826 0066 49444C45 		.ascii	"IDLE\000"
 2826      00
 2827              	.LC4:
 2828 006b 0D0A00   		.ascii	"\015\012\000"
 2829              		.data
 2830              		.align	2
 2831              		.set	.LANCHOR1,. + 0
 2834              	xNextTaskUnblockTime:
 2835 0000 FFFFFFFF 		.word	-1
 2836              		.bss
 2837              		.align	2
 2838              		.set	.LANCHOR0,. + 0
 2841              	pcStatsString:
 2842 0000 00000000 		.space	50
 2842      00000000 
 2842      00000000 
 2842      00000000 
 2842      00000000 
 2843 0032 0000     		.space	2
 2846              	pxCurrentTCB:
 2847 0034 00000000 		.space	4
 2850              	xTickCount:
 2851 0038 00000000 		.space	4
 2854              	pxOverflowDelayedTaskList:
 2855 003c 00000000 		.space	4
 2858              	pxDelayedTaskList:
 2859 0040 00000000 		.space	4
 2862              	uxCurrentNumberOfTasks:
 2863 0044 00000000 		.space	4
 2866              	pxReadyTasksLists:
 2867 0048 00000000 		.space	100
 2867      00000000 
 2867      00000000 
 2867      00000000 
 2867      00000000 
 2870              	xDelayedTaskList1:
 2871 00ac 00000000 		.space	20
 2871      00000000 
 2871      00000000 
 2871      00000000 
 2871      00000000 
 2874              	xDelayedTaskList2:
 2875 00c0 00000000 		.space	20
 2875      00000000 
 2875      00000000 
 2875      00000000 
 2875      00000000 
 2878              	xPendingReadyList:
 2879 00d4 00000000 		.space	20
 2879      00000000 
 2879      00000000 
 2879      00000000 
 2879      00000000 
 2882              	xTasksWaitingTermination:
 2883 00e8 00000000 		.space	20
 2883      00000000 
 2883      00000000 
 2883      00000000 
 2883      00000000 
 2886              	xSuspendedTaskList:
 2887 00fc 00000000 		.space	20
 2887      00000000 
 2887      00000000 
 2887      00000000 
 2887      00000000 
 2890              	xSchedulerRunning:
 2891 0110 00000000 		.space	4
 2894              	uxTopUsedPriority:
 2895 0114 00000000 		.space	4
 2898              	uxTaskNumber:
 2899 0118 00000000 		.space	4
 2902              	uxTopReadyPriority:
 2903 011c 00000000 		.space	4
 2906              	uxTasksDeleted:
 2907 0120 00000000 		.space	4
 2910              	uxSchedulerSuspended:
 2911 0124 00000000 		.space	4
 2914              	xIdleTaskHandle:
 2915 0128 00000000 		.space	4
 2918              	xNumOfOverflows:
 2919 012c 00000000 		.space	4
 2922              	uxMissedTicks:
 2923 0130 00000000 		.space	4
 2926              	xMissedYield:
 2927 0134 00000000 		.space	4
 2930              	ulTaskSwitchedInTime:
 2931 0138 00000000 		.space	4
 2932              		.text
 2933              	.Letext0:
 2934              		.file 2 "d:\\elektronik\\ides\\eclipse\\yagarto\\bin\\../lib/gcc/arm-none-eabi/4.6.2/include/stdde
 2935              		.file 3 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\FreeRTOS\\Source\\include/projdefs.h"
 2936              		.file 4 "d:/elektronik/ides/eclipse/yagarto/lib/gcc/../../arm-none-eabi/sys-include/stdint.h"
 2937              		.file 5 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\CMSIS\\Device\\STM32F4xx\\Include/stm32f4x
 2938              		.file 6 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\FreeRTOS\\Source\\include/../../Source/por
 2939              		.file 7 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\FreeRTOS\\Source\\include/FreeRTOS.h"
 2940              		.file 8 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\FreeRTOS\\Source\\include/list.h"
 2941              		.file 9 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\FreeRTOS\\Source\\include/task.h"
 2942              		.file 10 "D:\\Elektronik\\WorspaceEclipse\\ThunderCryer\\CMSIS\\Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
  C:\Temp\ccbyfOX7.s:19     .text.usTaskCheckFreeStackSpace:00000000 $t
  C:\Temp\ccbyfOX7.s:23     .text.usTaskCheckFreeStackSpace:00000000 usTaskCheckFreeStackSpace
  C:\Temp\ccbyfOX7.s:55     .text.prvGenerateRunTimeStatsForTasksInList:00000000 $t
  C:\Temp\ccbyfOX7.s:59     .text.prvGenerateRunTimeStatsForTasksInList:00000000 prvGenerateRunTimeStatsForTasksInList
  C:\Temp\ccbyfOX7.s:210    .text.prvGenerateRunTimeStatsForTasksInList:000000cc $d
  C:\Temp\ccbyfOX7.s:218    .text.prvAddCurrentTaskToDelayedList:00000000 $t
  C:\Temp\ccbyfOX7.s:222    .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
  C:\Temp\ccbyfOX7.s:281    .text.prvAddCurrentTaskToDelayedList:00000034 $d
  C:\Temp\ccbyfOX7.s:287    .text.xTaskGenericCreate:00000000 $t
  C:\Temp\ccbyfOX7.s:292    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
  C:\Temp\ccbyfOX7.s:600    .text.xTaskGenericCreate:0000018c $d
  C:\Temp\ccbyfOX7.s:605    .text.vTaskDelete:00000000 $t
  C:\Temp\ccbyfOX7.s:610    .text.vTaskDelete:00000000 vTaskDelete
  C:\Temp\ccbyfOX7.s:684    .text.vTaskDelete:00000064 $d
  C:\Temp\ccbyfOX7.s:689    .text.uxTaskPriorityGet:00000000 $t
  C:\Temp\ccbyfOX7.s:694    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
  C:\Temp\ccbyfOX7.s:729    .text.uxTaskPriorityGet:00000018 $d
  C:\Temp\ccbyfOX7.s:734    .text.vTaskPrioritySet:00000000 $t
  C:\Temp\ccbyfOX7.s:739    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
  C:\Temp\ccbyfOX7.s:850    .text.vTaskPrioritySet:00000090 $d
  C:\Temp\ccbyfOX7.s:855    .text.xTaskIsTaskSuspended:00000000 $t
  C:\Temp\ccbyfOX7.s:860    .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
  C:\Temp\ccbyfOX7.s:902    .text.xTaskIsTaskSuspended:00000024 $d
  C:\Temp\ccbyfOX7.s:907    .text.vTaskResume:00000000 $t
  C:\Temp\ccbyfOX7.s:912    .text.vTaskResume:00000000 vTaskResume
  C:\Temp\ccbyfOX7.s:979    .text.vTaskResume:00000060 $d
  C:\Temp\ccbyfOX7.s:984    .text.xTaskResumeFromISR:00000000 $t
  C:\Temp\ccbyfOX7.s:989    .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
  C:\Temp\ccbyfOX7.s:1058   .text.xTaskResumeFromISR:0000005c $d
  C:\Temp\ccbyfOX7.s:1064   .text.vTaskStartScheduler:00000000 $t
  C:\Temp\ccbyfOX7.s:1069   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
  C:\Temp\ccbyfOX7.s:1134   .text.vTaskStartScheduler:00000048 $d
  C:\Temp\ccbyfOX7.s:1752   .text.prvIdleTask:00000000 prvIdleTask
  C:\Temp\ccbyfOX7.s:1141   .text.vTaskEndScheduler:00000000 $t
  C:\Temp\ccbyfOX7.s:1146   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
  C:\Temp\ccbyfOX7.s:1170   .text.vTaskEndScheduler:00000014 $d
  C:\Temp\ccbyfOX7.s:1175   .text.vTaskSuspendAll:00000000 $t
  C:\Temp\ccbyfOX7.s:1180   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
  C:\Temp\ccbyfOX7.s:1197   .text.vTaskSuspendAll:00000010 $d
  C:\Temp\ccbyfOX7.s:1202   .text.xTaskGetTickCount:00000000 $t
  C:\Temp\ccbyfOX7.s:1207   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
  C:\Temp\ccbyfOX7.s:1232   .text.xTaskGetTickCount:00000014 $d
  C:\Temp\ccbyfOX7.s:1237   .text.xTaskGetTickCountFromISR:00000000 $t
  C:\Temp\ccbyfOX7.s:1242   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
  C:\Temp\ccbyfOX7.s:1274   .text.xTaskGetTickCountFromISR:00000018 $d
  C:\Temp\ccbyfOX7.s:1279   .text.uxTaskGetNumberOfTasks:00000000 $t
  C:\Temp\ccbyfOX7.s:1284   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
  C:\Temp\ccbyfOX7.s:1299   .text.uxTaskGetNumberOfTasks:00000008 $d
  C:\Temp\ccbyfOX7.s:1304   .text.xTaskGetIdleTaskHandle:00000000 $t
  C:\Temp\ccbyfOX7.s:1309   .text.xTaskGetIdleTaskHandle:00000000 xTaskGetIdleTaskHandle
  C:\Temp\ccbyfOX7.s:1324   .text.xTaskGetIdleTaskHandle:00000008 $d
  C:\Temp\ccbyfOX7.s:1329   .text.vTaskIncrementTick:00000000 $t
  C:\Temp\ccbyfOX7.s:1334   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
  C:\Temp\ccbyfOX7.s:1468   .text.vTaskIncrementTick:000000bc $d
  C:\Temp\ccbyfOX7.s:1474   .text.xTaskResumeAll:00000000 $t
  C:\Temp\ccbyfOX7.s:1479   .text.xTaskResumeAll:00000000 xTaskResumeAll
  C:\Temp\ccbyfOX7.s:1613   .text.xTaskResumeAll:000000bc $d
  C:\Temp\ccbyfOX7.s:1618   .text.vTaskGetRunTimeStats:00000000 $t
  C:\Temp\ccbyfOX7.s:1623   .text.vTaskGetRunTimeStats:00000000 vTaskGetRunTimeStats
  C:\Temp\ccbyfOX7.s:1741   .text.vTaskGetRunTimeStats:000000a0 $d
  C:\Temp\ccbyfOX7.s:1748   .text.prvIdleTask:00000000 $t
  C:\Temp\ccbyfOX7.s:1829   .text.prvIdleTask:00000054 $d
  C:\Temp\ccbyfOX7.s:1834   .text.vTaskDelay:00000000 $t
  C:\Temp\ccbyfOX7.s:1839   .text.vTaskDelay:00000000 vTaskDelay
  C:\Temp\ccbyfOX7.s:1889   .text.vTaskDelay:00000030 $d
  C:\Temp\ccbyfOX7.s:1894   .text.vTaskDelayUntil:00000000 $t
  C:\Temp\ccbyfOX7.s:1899   .text.vTaskDelayUntil:00000000 vTaskDelayUntil
  C:\Temp\ccbyfOX7.s:1986   .text.vTaskDelayUntil:00000058 $d
  C:\Temp\ccbyfOX7.s:1991   .text.vTaskSetApplicationTaskTag:00000000 $t
  C:\Temp\ccbyfOX7.s:1996   .text.vTaskSetApplicationTaskTag:00000000 vTaskSetApplicationTaskTag
  C:\Temp\ccbyfOX7.s:2032   .text.vTaskSetApplicationTaskTag:0000001c $d
  C:\Temp\ccbyfOX7.s:2037   .text.xTaskGetApplicationTaskTag:00000000 $t
  C:\Temp\ccbyfOX7.s:2042   .text.xTaskGetApplicationTaskTag:00000000 xTaskGetApplicationTaskTag
  C:\Temp\ccbyfOX7.s:2076   .text.xTaskGetApplicationTaskTag:00000018 $d
  C:\Temp\ccbyfOX7.s:2081   .text.xTaskCallApplicationTaskHook:00000000 $t
  C:\Temp\ccbyfOX7.s:2086   .text.xTaskCallApplicationTaskHook:00000000 xTaskCallApplicationTaskHook
  C:\Temp\ccbyfOX7.s:2126   .text.xTaskCallApplicationTaskHook:00000018 $d
  C:\Temp\ccbyfOX7.s:2131   .text.vTaskSwitchContext:00000000 $t
  C:\Temp\ccbyfOX7.s:2136   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
  C:\Temp\ccbyfOX7.s:2221   .text.vTaskSwitchContext:0000007c $d
  C:\Temp\ccbyfOX7.s:2227   .text.vTaskSuspend:00000000 $t
  C:\Temp\ccbyfOX7.s:2232   .text.vTaskSuspend:00000000 vTaskSuspend
  C:\Temp\ccbyfOX7.s:2313   .text.vTaskSuspend:00000068 $d
  C:\Temp\ccbyfOX7.s:2318   .text.vTaskPlaceOnEventList:00000000 $t
  C:\Temp\ccbyfOX7.s:2323   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
  C:\Temp\ccbyfOX7.s:2376   .text.vTaskPlaceOnEventList:00000038 $d
  C:\Temp\ccbyfOX7.s:2381   .text.xTaskRemoveFromEventList:00000000 $t
  C:\Temp\ccbyfOX7.s:2386   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
  C:\Temp\ccbyfOX7.s:2454   .text.xTaskRemoveFromEventList:00000054 $d
  C:\Temp\ccbyfOX7.s:2460   .text.vTaskSetTimeOutState:00000000 $t
  C:\Temp\ccbyfOX7.s:2465   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
  C:\Temp\ccbyfOX7.s:2487   .text.vTaskSetTimeOutState:00000010 $d
  C:\Temp\ccbyfOX7.s:2492   .text.xTaskCheckForTimeOut:00000000 $t
  C:\Temp\ccbyfOX7.s:2497   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
  C:\Temp\ccbyfOX7.s:2569   .text.xTaskCheckForTimeOut:00000050 $d
  C:\Temp\ccbyfOX7.s:2574   .text.vTaskMissedYield:00000000 $t
  C:\Temp\ccbyfOX7.s:2579   .text.vTaskMissedYield:00000000 vTaskMissedYield
  C:\Temp\ccbyfOX7.s:2595   .text.vTaskMissedYield:0000000c $d
  C:\Temp\ccbyfOX7.s:2600   .text.uxTaskGetStackHighWaterMark:00000000 $t
  C:\Temp\ccbyfOX7.s:2605   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
  C:\Temp\ccbyfOX7.s:2634   .text.uxTaskGetStackHighWaterMark:00000010 $d
  C:\Temp\ccbyfOX7.s:2639   .text.xTaskGetCurrentTaskHandle:00000000 $t
  C:\Temp\ccbyfOX7.s:2644   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
  C:\Temp\ccbyfOX7.s:2660   .text.xTaskGetCurrentTaskHandle:00000008 $d
  C:\Temp\ccbyfOX7.s:2665   .text.vTaskPriorityInherit:00000000 $t
  C:\Temp\ccbyfOX7.s:2670   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
  C:\Temp\ccbyfOX7.s:2746   .text.vTaskPriorityInherit:00000060 $d
  C:\Temp\ccbyfOX7.s:2752   .text.vTaskPriorityDisinherit:00000000 $t
  C:\Temp\ccbyfOX7.s:2757   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
  C:\Temp\ccbyfOX7.s:2812   .text.vTaskPriorityDisinherit:00000044 $d
  C:\Temp\ccbyfOX7.s:2846   .bss:00000034 pxCurrentTCB
  C:\Temp\ccbyfOX7.s:2830   .data:00000000 $d
  C:\Temp\ccbyfOX7.s:2834   .data:00000000 xNextTaskUnblockTime
  C:\Temp\ccbyfOX7.s:2837   .bss:00000000 $d
  C:\Temp\ccbyfOX7.s:2841   .bss:00000000 pcStatsString
  C:\Temp\ccbyfOX7.s:2850   .bss:00000038 xTickCount
  C:\Temp\ccbyfOX7.s:2854   .bss:0000003c pxOverflowDelayedTaskList
  C:\Temp\ccbyfOX7.s:2858   .bss:00000040 pxDelayedTaskList
  C:\Temp\ccbyfOX7.s:2862   .bss:00000044 uxCurrentNumberOfTasks
  C:\Temp\ccbyfOX7.s:2866   .bss:00000048 pxReadyTasksLists
  C:\Temp\ccbyfOX7.s:2870   .bss:000000ac xDelayedTaskList1
  C:\Temp\ccbyfOX7.s:2874   .bss:000000c0 xDelayedTaskList2
  C:\Temp\ccbyfOX7.s:2878   .bss:000000d4 xPendingReadyList
  C:\Temp\ccbyfOX7.s:2882   .bss:000000e8 xTasksWaitingTermination
  C:\Temp\ccbyfOX7.s:2886   .bss:000000fc xSuspendedTaskList
  C:\Temp\ccbyfOX7.s:2890   .bss:00000110 xSchedulerRunning
  C:\Temp\ccbyfOX7.s:2894   .bss:00000114 uxTopUsedPriority
  C:\Temp\ccbyfOX7.s:2898   .bss:00000118 uxTaskNumber
  C:\Temp\ccbyfOX7.s:2902   .bss:0000011c uxTopReadyPriority
  C:\Temp\ccbyfOX7.s:2906   .bss:00000120 uxTasksDeleted
  C:\Temp\ccbyfOX7.s:2910   .bss:00000124 uxSchedulerSuspended
  C:\Temp\ccbyfOX7.s:2914   .bss:00000128 xIdleTaskHandle
  C:\Temp\ccbyfOX7.s:2918   .bss:0000012c xNumOfOverflows
  C:\Temp\ccbyfOX7.s:2922   .bss:00000130 uxMissedTicks
  C:\Temp\ccbyfOX7.s:2926   .bss:00000134 xMissedYield
  C:\Temp\ccbyfOX7.s:2930   .bss:00000138 ulTaskSwitchedInTime
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
sprintf
strcat
vListInsert
malloc
free
memset
strncpy
vListInitialiseItem
pxPortInitialiseStack
vPortEnterCritical
vListInitialise
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
init_us_timer
xPortStartScheduler
vPortEndScheduler
get_us_time
